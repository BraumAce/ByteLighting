---
category: 
- 软考
tag: 
- 系统架构设计师
- 系统分析与设计
order: 2
comment: true
---

# 设计模式

## 1. 面向对象的设计原则（SOLID）

### 1.1 单一职责原则（Single Responsibility Principle, SRP）

1. 简介：<u>一个类只负责一个功能领域中的相应职责</u>（避免混乱）
2. 定义：单一职责原则要求类应该只有一个设计目的

### 1.2 开闭原则（Open Closed Principle，OCP）

1. 简介：<u>对扩展开放，对修改关闭</u>（提高系统的扩展性、稳定性）
2. 定义：可扩展系统并提供新行为，通过添加抽象层实现，是其他原则的基础。对扩展开放对修改封闭

### 1.3 里氏替换原则（Liskov Substitution Principle，LSP）

1. 简介：<u>所有引用基类的地方必须能透明地使用其子类的对象</u>（<u>子类可完全替换父类</u>）
2. 定义：软件实体使用基类对象时适用于子类对象，设计时应将变化类设计为抽象类或接口

### 1.4 接口隔离原则（Interface Segregation Principle，ISP）

1. 简介：类之间的依赖关系应该建立在最小的接口上（<u>使用多个具体接口，避免接口冗余</u>）
2. 定义：分逻辑和狭义两种理解，前者将接口视为角色，后者要求接口提供客户端需要的行为，将大接口方法分至小接口

### 1.5 依赖倒转原则（Dependency Inversion Principle，DIP）

1. 简介：<u>依赖于抽象，不能依赖于具体实现</u>
2. 定义：抽象不依赖于细节，针对接口编程，是实现开闭原则的主要机制，与各种技术和框架相关

### 1.6 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）

1. 简介：<u>尽量使用合成/聚合，而不是通过继承达到复用的目的</u>（减少继承带来的紧耦合，提高灵活性）
2. 定义：通过组合或聚合关系复用已有对象，比继承更灵活，耦合度低。

### 1.7 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）

1. 简介：<u>一个软件实体应当尽可能少的与其他实体发生相互作用</u>（减少复杂度）
2. 定义：软件实体应尽量少与其他实体相互作用，分狭义和广义原则，狭义降低类耦合但可能影响通信效率，广义主要控制信息相关方面，利于子系统解耦和复用

## 2. 设计模型分类

可以按两个准则来分类：

1. 按目的划分：**创建型、结构型、行为型**
2. 按范围划分：**<u>类设计模式</u>**、**<u>对象设计模式</u>**

## 3. 创建型模式

这类模式提供创建对象的机制，将 “对象的创建” 从具体使用中解耦，能够提升已有代码的灵活性和可复用性。

### 3.1 工厂方法（Factory Method）

> 动态生产对象

1. 要点：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
2. 特点：**<u>父类负责抽象</u>**，**<u>子类负责具体实现</u>**，实现解耦的创建与使用
3. 场景：多种类型商品不同接口、统一发奖服务

### 3.2 抽象工厂方法（Abstract Factory Method）

> 生产成系列对象

1. 要点：提供一个 **<u>创建一系列</u>** 相关或相互依赖对象的接口，而无需制定他们具体的类
2. 特点：创建一系列相关产品，**<u>用于创建一个产品家族</u>**
3. 场景：代理类抽象场景

### 3.3 建造器（Builder）

> 复杂对象构造

1. 要点：<u>将一个</u> **<u>复杂对象的构建与其表示相分离</u>**，使得同样的构建过程可以创建不同的表示
2. 特点：适合 <u>对象属性多，构建步骤复杂</u> 的场景
3. 场景：套餐选配、各项装修物料组合

### 3.4 原型（Prototype）

> 克隆对象

1. 要点：用原型实例指定创建对象的种类，并且**<u>通过拷贝这些原型创建新的对象</u>**
2. 特点：允许对象在<u>不了解要创建对象的确切类</u>以及如何创建等细节的情况下<u>创建自定义对象</u>

### 3.5 单例（Singleton）

> 单实例

1. 要点：**<u>保证一个类仅有一个实例</u>**，并提供一个访问它的全局访问点

## 4. 结构型模式

这类模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。

### 4.1 适配器（Adapter）

> 转换接口

1. 要点：将一个类的接口转换成客户希望的另外一个接口
2. 特点：使原本不相容的接口得以协同工作

### 4.2 桥接（Bridge）

> 继承树拆分

1. 要点：将 **<u>抽象接口与实现分离</u>**，使它们都可以独立的变化

### 4.3 组合（Composite）

> 树形目录结构

1. 要点：<u>将对象组合成树形结构</u>，以表示 “部分-整体” 的层次结构
2. 特点：使得用户对单个对象和组合对象的使用具有 <u>一致性</u>

### 4.4 装饰器（Decorator）

> 动态附加职责

1. 要点：**<u>灵活动态</u>** 地为一个对象 **<u>添加</u>** 一些额外的功能
2. 特点：
    1. 避免大量子类产生类膨胀，<u>不改变原有对象结构，有效控制类的增长</u>
    2. 比派生一个子类更灵活，可以在运行时按需组合功能，而不必通过大量子类来静态扩展

### 4.5 外观（Facade）

> 动态统一接口

1. 要点：为子系统中的一组接口提供一个一致的界面，提供一个统一的高层接口
2. 特点：
    1. **<u>为系统提供统一的对外接口</u>**，<u>简化调用</u>（相当于一个黑箱）
    2. 提高了一致性和可移植性，降低了调用性能

### 4.6 享元（Flyweight）

> 汉字编码

1. 要点：运用 **<u>共享</u>** <u>技术</u> 有效地支持大量细粒度的对象
2. 特点：提供支持大量细粒度对象共享的有效方法

### 4.7 代理（Proxy）

> 快捷方式

1. 要点：**<u>为其他对象提供一种代理</u>** 以控制对这个对象的访问
2. 特点：用于 <u>控制访问对象的方式</u>
3. 场景：远程代理、虚拟代理、安全代理

## 5. 行为型模式

这类模式负责对象间的高效沟通和职责委派。

### 5.1 解释器（Interpreter）

> 虚拟机的机制

1. 要点：给定一个语言，定义它的文法表示，并 <u>定义一个解释器</u>，解释语言中的句子
2. 特点：解释执行语句，**<u>定义语言文法</u>**（用于编译器、规则引擎）

### 5.2 模板方法（Template Method）

> 框架

1. 要点：定义一个 **<u>算法的骨架</u>** <u>（模板）</u>，具体实现延迟到交给子类去做
2. 特点：表示一个作用于某对象结构中的各元素的操作，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤

### 5.3 责任链（Chain of Responsibility）

> 传递职责

1. 要点：避免请求发送者和接收者耦合在一起，让多个对象都有可能接收到请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止
2. 特点：<u>解耦请求发送者和接收者</u>，使多个对象都有可能接收请求，而发送者不需要知道哪个对象会处理它

### 5.4 命令（Command）

> 日志记录，可撤销

1. 要点：**<u>将一个请求封装成一个对象</u>**，可以用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作

### 5.5 迭代器（Iterator）

> 数据集

1. 要点：提供一种方法 <u>顺序访问一个聚合对象中各个元素</u>，而 <u>又无需暴露该对象的内部表示</u>
2. 特点：<u>遍历</u> 集合中的各个元素，隐藏内部结构

### 5.6 中介者（Mediator）

> 不直接引用

1. 要点：用一个中介对象来封装一系列的对象交互，<u>中介者使各对象不需要显示地相互引用</u>，从而 <u>使其耦合松散</u>，而且 <u>可以独立地改变它们之间的交互</u>
2. 特点：**<u>解耦</u>** 对象间的复杂交互，用一个中介同一封装交互逻辑，降低耦合度

### 5.7 备忘录（Memento）

> 游戏存档

1. 要点：在不破坏封装性的前提下，捕获一个对象的内部状态，并<u>在该对象之外保存这个状态</u>

### 5.8 观察者（Observer）

> 联动

1. 要点：定义对象间的一种多对多的依赖关系，<u>当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新</u>
2. 特点：用于 **<u>建立对象之间的通知机制</u>**

### 5.9 状态（State）

> 状态变成类

1. 要点：<u>运行对象在内部状态发生改变时改变它的行为</u>，对象看起来好像修改了它的类

### 5.10 策略（Strategy）

> 多方案切换

1. 要点：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换
2. 特点：让算法可以独立于使用它的用户而变化。**<u>封装算法</u>**，<u>灵活替换</u>

### 5.11 访问者（Visitor）

> 数据与操作分离

1. 要点：主要 <u>将数据结构与数据操作分离</u>
2. 特点：在不改变各元素的类的前提下定义作用于这些元素的新操作

### 5.12 空对象（Null Object）

1. 要点：<u>一个空对象取代 NULL 对象实例的检查</u>，这个空对象实现了相同的接口，但对请求不做任何操作或提供默认操作
2. 特点：<u>解决在系统中使用 null 值可能导致的问题</u>，运行系统在没有合适的对象时，使用一个 “安全” 的空对象继续运行，而不是失败

