---
category: 
- 软考
tag: 
- 系统架构设计师
- 软件工程
order: 3
comment: true
---

# 软件测试

## 1. 概念

1. 定义：使用人工或自动的手段来运行或测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。
2. 目的：
    1. 确保软件的质量
    2. 确认软件以正确的方式做了用户所期望的事情
3. 主要工作：
    1. 发现软件的错误
    2. 有效定义和实现软件成分由底层至高层的组装过程
    3. 验证软件是否满足任务书和系统定义文档所规定的技术要求
    4. 为软件质量模型的建立提供依据
4. 基本原则：
    1. <u>测试能发现缺陷，但无法证明软件 “无缺陷” 或绝对正确</u>
    2. <u>每个测试用例都必须定义预期的输出或结果</u>
    3. <u>测试用例中不仅要说明合法有效的输入条件，还应该描述那些不期望的、非法的输入条件</u>
    4. 缺陷的群集效应：<u>80% 的软件错误都可以在大概 20% 的模块中找到根源</u>（也称为二八原则）

## 2. 测试方法

### 2.1 以测试过程中程序执行状态分类

#### 2.1.1 静态测试

1. 概念：程序静止时，通过人工或自动方式对代码和文档进行审查和分析。
2. 目的：在早期发现语法错误、逻辑缺陷和设计问题。
3. 测试方法：
    1. **<u>桌面检查</u>**：程序员检查自己编写的程序，在程序编译后，单元测试前。
    2. **<u>代码审查</u>**：由若干个程序员和测试人员组成评审小组，通过召开程序评审会来进行审查。
    3. **<u>代码走查</u>**：也是采用开会来对代码进行审查，但并非简单的检查代码，而是由测试人员提供测试用例，让程序员扮演计算机的角色，手动运行测试用例，检查代码逻辑。

#### 2.1.2 动态测试

1. 概念：通过运行被测试程序，对得到的运行结果与预期的结果进行比较分析，同时分析运行效率和健壮性能等。
2. 测试方法：
    1. 黑盒测试方法：**<u>边界值分析</u>**、**<u>等价类划分</u>**、**<u>错误推测法</u>**
    2. 白盒测试方法：**<u>逻辑覆盖</u>**、**<u>基本路径测试</u>**
3. 分为 3 个步骤：
    1. 构造测试实例；
    2. 执行程序；
    3. 分析结果。

### 2.2 以具体实现算法细节和系统内部结构的相关情况分类

#### 2.2.1 黑盒测试

1. 概念：**<u>功能性测试</u>**，不了解软件代码结构，根据功能设计用例，测试软件功能。
2. 黑盒测试法：
    1. **功能测试**：
    2. **边界值分析**：基于错误通常出现在输入边界的经验来设计测试用例
    3. **等价类划分**：将输入域划分为有效和无效等价类，并从每类中选取代表值进行测试
    4. **判定表**：用于分析多个逻辑条件取值组合及其对应的执行动作，尤其在条件与动作组合复杂时最有效
    5. **错误推测法**：
    6. **因果图**：通过建立输入与输出之间的逻辑因果关系图，生成测试用例

#### 2.2.2 白盒测试

1. 概念：**<u>结构性测试</u>**，明确代码流程，根据代码逻辑设计用例，进行用例覆盖。
2. 白盒测试法：
    1. **控制流分析**：主要检查程序控制结构及执行路径是否正确，例如死循环、无效路径等，不涉及数据异常
    2. **数据流分析**：用于分析数据在程序中的生命周期，包括定义、初始化、赋值、引用等。它能够发现典型的数据异常（如未初始化变量的使用、无效赋值、未使用的数据等）
    3. **路径分析**：
    4. **程序变异**：通过对代码做微小变更生成变异程序，并用测试用例检测变异体是否能被识别，评估测试用例集的强度。
3. 根据测试用例的覆盖程度，分为：
    1. **语句覆盖**：要求测试用例设计要确保每条语句在程序中 <u>至少执行一次</u>，目的是测试程序的基本功能是否正常。<u>覆盖强度较低</u>。
    2. **判定覆盖**：判定覆盖要求测试用例 <u>至少覆盖</u> **<u>每个判定表达式</u>** 的所有可能结果，类似于分支覆盖，但 <u>着眼于判定条件的每个可能的结果</u>。<u>覆盖强度比语句覆盖稍高</u>。
    3. **条件覆盖**：条件覆盖要求判断表达式中的 **<u>每个子条件</u>**（如 if 语句中的布尔表达式）在测试用例中 <u>至少</u> 为真一次，为假一次。<u>覆盖强度比判定覆盖高</u>。
    4. **判定/条件覆盖**：
    5. **组合条件覆盖**：组合覆盖要求设计足够多的测试用例，使得 **<u>每个条件</u>** 的 <u>所有可能组合至少出现一次</u>。即每个条件的所有可能组合应被覆盖。<u>覆盖强度仅次于路径覆盖</u>。
    6. **路径覆盖**：要求测试用例执行程序中的每一条可能的路径，即程序中每个判断和条件组合的不同路径都被执行到。<u>覆盖强度最高</u>。

#### 2.2.3 灰盒测试

1. 概念：即既有黑盒，也有白盒。
2. 不仅关注程序的输入输出，也对系统的内部逻辑有所了解。

### 2.3 以程序执行的方式分类

#### 2.3.1 人工测试

#### 2.3.2 自动化测试（自动化执行测试脚本）

1. **数据驱动测试**：
    1. 核心思想：**<u>将测试逻辑与测试数据分离</u>**，即测试脚本保持不变，测试数据通过外部数据源进行管理。
    2. 过程：测试脚本通过读取 **<u>外部数据文件</u>**，动态获取输入数据，从而对不同的测试场景进行验证。
2. 根据实现方式的不同，对脚本分类：
    1. **线性脚本**：直接通过录制手工执行的测试过程得到脚本，包含所有击键、鼠标动作和输入数据，可以完整回放
    2. **结构化脚本**：类似结构化程序设计，具有逻辑结构和函数调用，不一定来源于录制过程
    3. **共享脚本**：可供多个测试用例调用
    4. **数据驱动脚本**：测试数据存储在外部文件
    5. **关键字驱动脚本**：

## 3. 测试阶段

![V 模型](https://cloud.bytelighting.cn/f/W9QH7/V%E6%A8%A1%E5%9E%8B.png)

### 3.1 单元测试（模块测试）

1. 概念：对软件中的最小单元（如函数或方法）进行测试，以验证其是否按照预期工作。
2. 测试对象：可独立编译或汇编的 <u>程序模块</u>、<u>软件构件</u> 或 <u>OO软件中的类</u>（统称为模块）
3. 测试依据：**<u>软件详细设计说明书</u>**
4. 在进行单元测试时，被测模块的上下游依赖可能尚未完成或不可用，因此常常使用 **<u>驱动模块</u>**（Driver）和 **<u>桩模块</u>**（Stub）来模拟这些依赖，以便隔离测试。
    1. **驱动模块**：用来 <u>调用被测模块</u>
    2. **桩模块**：用来 <u>模拟被测模块所调用的子模块</u>
5. **<u>代码覆盖率</u>** 是 <u>用来衡量单元测试对功能代码的测试情况</u>，通过统计代码中各行、分支、类等的执行情况，量化测试的充分度。

### 3.2 集成测试

1. 测试目的：检查模块之间，以及模块和已集成的软件之间的 **<u>接口关系</u>**，并验证已集成的软件是否符合设计要求
2. 测试依据：**<u>软件概要设计说明书</u>**
3. 测试方法：一般采用 <u>黑盒测试方法</u>
4. 组装策略：
    1. **<u>一次性组装</u>**：一次性完成所有模块集成
    2. **<u>增量组装</u>**：逐步进行模块集成

### 3.3 确认测试（有效性测试）

1. 作用：用于验证 <u>软件的功能</u>、<u>性能</u>、和 <u>其他特性是否</u> 与 **<u>用户需求</u>** <u>一致</u>
2. 目的：在真实的用户工作环境下，检验软件系统是否满足开发技术合同或 SRS。验收测试的结论是用户确定是否接收该软件的主要依据。
3. 根据 <u>用户的参与程度</u> 不同，可分为：
    1. **<u>内部确认测试</u>**：主要由软件开发组织内部按照 SRS 进行测试
    2. **<u>Alpha 测试</u>**：用户在开发环境下进行测试
    3. **<u>Beta 测试</u>**：用户在实际使用环境下进行测试，通过改测试后，产品才能交付用户
    4. **<u>验收测试</u>**：针对 SRS，在交付前以用户为主进行的测试。其测试对象为 <u>完整的、集成的计算机系统</u>。
4. 除了应该满足一般测试的准入条件外，在进行验收测试之前，应确认被测软件系统已通过系统测试。

### 3.4 系统测试

1. 测试对象：完整的、集成的计算机系统
2. 测试目的：在 <u>真实系统工作环境</u> 下，<u>验证完成的软件配置项能否和系统正确连接</u>，并满足 <u>系统/子系统设计文档和软件开发合同规定</u> 的要求
3. 测试依据：**<u>软件需求规格说明书</u>**
4. 测试内容：
    1. <u>功能测试</u>、<u>健壮性测试</u>、<u>性能测试</u>、<u>用户界面测试</u>、<u>安全性测试</u>、<u>安装与反安装测试</u>等
    2. 最重要的工作是进行 <u>功能测试</u> 与 <u>性能测试</u>。
    3. **<u>功能测试</u>**主要采用 <u>黑盒测试方法</u>
    4. **<u>性能测试</u>**主要指标有 <u>响应时间</u>、<u>吞吐量</u>、<u>并发用户数</u> 和 <u>资源利用率</u> 等

### 3.5 性能测试

1. 概念：通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。
2. 分类：
    1. **<u>强度测试</u>**：模拟极端恶劣的环境（如环境不稳定、低内存等）来测试系统在 <u>资源受限条件</u> 下的稳定性。
    2. **<u>负载测试</u>**：确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。关注 <u>系统在逐步增加负载下的性能变化</u>。
    3. **<u>压力测试</u>**：通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。主要 <u>关注系统的崩溃点</u>。
3. **<u>容量测试</u>**：测试系统能同时处理的在线最大用户数。

### 3.6 配置项测试

1. 测试对象：<u>软件配置项</u>
2. 测试目的：<u>检验软件配置项与 SRS 的一致性</u>
3. 测试依据：<u>SRS</u>
4. 在此之间，应确认被测软件配置项已通过单元测试和集成测试。

### 3.7 回归测试

1. 测试目的：测试 <u>软件变更之后</u>，<u>变更部分的正确性和对变更需求的符合性</u>，以及软件 <u>原有的</u>、<u>正确的功能</u>、<u>性能</u> 和 <u>其他规定的要求</u> 的不损害性。

### 3.8 其他测试

1. **AB 测试**：
    1. 是为 Web 或 App 界面或流程制作两个或多个版本，在同一时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。
    2. 核心目的：比较不同版本的效果差异，前提是控制变量一致，因此应在 <u>相同时间段</u> 内，将 <u>成分相似的用户群体</u>（如地域、设备、访问渠道等）<u>随机分配</u> 到不同版本，以确保测试的公平性和结果的可比性。
2. **Web 测试**：是软件测试的一部分，是针对 Web 应用的一类测试。由于 Web 应用与用户直接相关，又通常需要承受长时间的大量操作，因此 Web 项目的功能和性能都必须经过可靠的验证。
3. **链接测试**：链接是 Web 应用系统的一个主要特征，它是在页面之间切换和指导用户去一些未知地址页面的主要手段。链接测试可分为 3 个方面。首先，测试所有链接是否按指示那样确实链接到了该链接的页面；其次，测试所链接的页面是否存在；最后，保证 Web 应用系统上没有孤立的页面。
4. **表单测试**：当用户通过表单提交信息的时候，都希望表单能正常工作。如果使用表单来进行在线注册，要确保提交按钮能正常工作，当注册完成后应返回注册成功的消息。如果使用表单收集配送信息，应确保程序能够正确处理这些数据，最后能让用户收到信息。

## 4. 测试模型

### 4.1 W 模型

1. 概念：W 模型是对 **<u>V 模型</u>** 的一个重要改进，充分体现了尽早开展测试的原则，并将 V 模型中以发现缺陷为目标上升为保证软件质量为目标。
2. 特点：W 模型实际上是两个 V 的叠加，一个 V 描述 **<u>开发过程</u>**，另外一个 V 描述 **<u>测试过程</u>**。但测试的起始时机不再是编码结束之后，而是从需求分析时开始，且与开发的每一个阶段活动同步进行。
3. 特征图：

![W 模型](https://cloud.bytelighting.cn/f/lvOFD/W%E6%A8%A1%E5%9E%8B.png)

### 4.2 H 模型

1. 概念：H 模型 <u>把测试活动从软件开发过程中独立出来</u>，在软件过程的任何一个时间点上，只要测试条件满足即开展测试。
2. 特点：
    1. 改进了 W 和 V 模型高度依赖于开发的瀑布模型的缺陷
    2. 测试的流程与其他流程是并行的
    3. H 模型比 W 模型更好的地方是：<u>能够兼顾测试的效率和灵活性，适合于各种规模及类型的软件项目</u>。
3. 特征图：

![H 模型](https://cloud.bytelighting.cn/f/EzNSY/H%E6%A8%A1%E5%9E%8B.png)

### 4.3 敏捷测试模型

1. 概念：敏捷测试源于 **<u>敏捷开发</u>**。敏捷测试 **<u>是敏捷开发的组成部分</u>**，需要与开发流程良好融合
2. 特点：敏捷测试在整个敏捷开发过程中，需要与项目的其他人员甚至用户保持紧密协作，时刻关注需求变化并实施测试，以体现测试的时效性和适应性，这对测试人员有比较高的能力要求。
3. 特征图：

![敏捷测试模型](https://cloud.bytelighting.cn/f/NXBUv/%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B.png)

## 5. 测试用例设计

### 5.1 黑盒测试用例

场景：将程序看做一个黑盒子，只知道输入输出，不知道内部代码。

1. **<u>等价类划分</u>**：
    1. 把所有的数据按照某种特性进行归类，而后在每类的数据里选取一个即可。
    2. 设计原则：
        1. <u>设计一个新的测试用例</u>，<u>使其尽可能多地覆盖尚未被覆盖的有效等价类</u>，重复这一步，直到所有的有效等价类都被覆盖为止；
        2. 计一个新的测试用例，<u>使其仅覆盖一个尚未被覆盖的无效等价类</u>，重复这一步，直到所有的无效等价类都被覆盖为止）。
2. **<u>边界值分析</u>**：将 <u>每类的边界值</u> 作为测试用例，边界值一般为范围的两端值以及在此范围之外的与此范围间隔最小的两个值。
3. **<u>错误推测</u>**：没有固定的方法，凭经验而言，来推测有可能产生问题的地方，作为测试用例进行测试。
4. **<u>因果图</u>**：通过图形化方式，由一个 <u>结果来反推原因</u> 的方法，具体结果具体分析，没有固定方法。常与 <u>判定表</u> 结合使用。
5. **<u>判定表驱动法</u>**：用于 <u>分析多个逻辑条件取值组合</u> 及其 <u>对应的执行动作</u>，尤其在 <u>条件与动作组合复杂</u> 时最有效。

### 5.2 白盒测试用例

场景：知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例。

覆盖级别 <u>从低到高</u> 分为：

1. **<u>语句覆盖</u>**（SC）：逻辑代码中的所有语句都要被执行一遍，覆盖层级最低，因为执行了所有的语句，不代表执行了所有的条件判断。
2. **<u>判定覆盖</u>**（DC）：逻辑代码中的所有判断语句的条件的真假分支都要覆盖一次。
3. **<u>条件覆盖</u>**（CC）：针对每一个判断条件内的每一个独立条件都要执行一遍真和假。
4. **<u>条件判定组合覆盖</u>**（CDC）：同时满足判定覆盖和条件覆盖。
5. **<u>路径覆盖</u>**：逻辑代码中的所有可行路径都覆盖了，覆盖层级最高。

## 6. 调试

### 6.1 概念

1. 测试是 <u>发现错误</u>；调试是 <u>找出错误的代码和原因</u>。
2. 调试需要：
    1. 确定 <u>错误的准确位置</u>；
    2. 确定问题的 <u>原因并设法改正</u>；
    3. 改正后要 <u>进行回归测试</u>。

### 6.2 调试方法

1. **蛮力法**：又称为穷举法或枚举法，穷举出所有可能的方法一一尝试。
2. **回溯法**：又称为试探法，按选优条件向前搜索，以达到目标，当发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。
3. **演绎法**：是由一般到特殊的推理方法，与 “归纳法” 相反，从一般性的前提出发。得出具体陈述或个别结论的过程。
4. **归纳法**：是由特殊到一般的推理方法，从测试所暴露的问题出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在。

### 6.3 软件度量中软件的两种属性

1. **外部属性**：指 <u>面向管理者和用户</u> 的属性，<u>可直接测量</u>，一般为 <u>性能指标</u>。
2. **内部属性**：指 <u>软件产品本身</u> 的的属性，如 <u>可靠性</u> 等，<u>只能间接测量</u>。

### 6.4 环路复杂度

1. **McCabe 度量法**：又称为 **<u>环路复杂度</u>**，假设有向图中有向边数为 $m$，节点数为 $n$，则此有向图的环路复杂度为 $m - n + 2$。
    1. 注意 $m$ 和 $n$ 代表的含义不能混淆，可以用一个最简单的环路来做特殊值记忆此公式
    2. 另外，针对一个程序流程图，每一个分支边（连线）就是一条有向边，每一条语句（语句框）就是一个顶点。
2. 另一种简单的计算公式：**<u>环路复杂度 = 判定节点个数 + 1</u>**。
    1. 解释：判定节点即分支结构，常表示为菱形

