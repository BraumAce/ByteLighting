---
category: 
- 软考
tag: 
- 系统架构设计师
- 软件工程
order: 2
comment: true
---

# 基于构件的软件工程（CBSE）

## 1. 概念

1. 基于构件的软件工程（Component-Based Software Engineering，CBSE）是一种新型的软件开发模式，旨在通过 <u>复用可重用的软件构件</u> 来构造高质量、高效率的应用软件系统。这种模式强调 <u>将软件系统分解为独立的构件</u>，每个构件都 <u>具有明确定义的功能和接口</u>，可以 <u>独立开发、测试和部署</u>。
2. 是一种基于 **<u>分布对象技术</u>**、强调通过 **<u>可复用构件与构造软件系统</u>** 的软件复用途径（体现了购买而不是重新构造）。
3. 用于 CBSE 的构件应该具备以下特征：
    1. **可组装性**：对于可组装的构件，所有外部交互必须通过公开定义的接口进行。同时它还必须提供对自身信息的外部访问。
    2. **可部署性**：软件必须是 <u>自包含</u> 的，必须能作为一个独立实体在提供其构件模型实现的构件平台上运行。构件总是 <u>二进制形式</u>，无须在部署前编译。如果一个构件实现为一项服务，它不必由用户来部署，而是由服务的提供者来部署。
    3. **文档化**：构件必须是 <u>完全文档化</u> 的，用户根据文档来判断构件是否满足需求。
    4. **独立性**：构件应该是 <u>独立</u> 的，应该可以在无其他特殊构件的情况下进行组装和部署，如确实需要其他构件提供服务，则应显示声明。
    5. **标准化**：构件标准化意味着在CBSE过程中使用的构件必须符合某种标准化的构件模型。此模型会定义构件接口、构件元数据、文档管理、组成以及部署。
    6. **可见性**：<u>没有（外部的）可见状态</u>。构件本身不直接暴露外部可见状态，但可以通过运行时 <u>容器</u>（如应用服务器、框架等）管理状态并对外提供可见性。
4. CSBE 过程的主要活动：
    1. **面向复用的开发**：
        1. 开发将被复用在其他应用程序中的构件或服务。它通常是对已存在的构件进行通用化处理。
    2. **<u>基于复用的开发</u>** **（主要）**：
        1. 复用已存在的构件和服务来开发新的应用程序。
        2. 开发过程：
            1. 系统需求概览
            2. 识别候选构件
            3. 根据发现的构件修改需求
            4. 体系结构设计
            5. 识别候选构件（构件定制与适配）
            6. 组装构件创建系统

## 2. 构件模型

1. 概念：定义了 **构件实现**、**文档化** 以及 **开发的标准**。
2. 包含的模型要素：
    1. **接口**：构件通过 **<u>构件接口</u>** 来定义，构件模型规定应如何定义构件接口以及在接口定义中应该包含的要素，如操作名、参数以及异常等。
    2. **使用信息**：为使构件远程分布和访问，必须给构件一个特定的、全局唯一的名字或句柄。
        1. **<u>构件元数据</u>** 是构件本身相关的数据，比如构件的接口和属性信息。
    3. **部署**：构件模型包括一个规格说明，指出应该如何打包构件使其部署成为一个独立的可执行实体。
        1. 部署信息中包含 <u>有关包中内容的信息</u> 和 <u>它的二进制构成的信息</u>。
3. 构件模型提供了一组被构件使用的通用服务，这种服务包括以下两种：
    1. **<u>平台服务</u>**：允许构件在分布式环境下通信和互操作。
    2. **<u>支持服务</u>**：这是很多构件需要的共性服务。例如，构件都需要的身份认证服务。中间件实现共性的构件服务，并提供这些服务的接口。

## 3. 构件（component）

1. 概念：是软件系统中 <u>可复用的</u>、<u>自包含的</u>、<u>具有明确接口</u>、<u>显示依赖语境</u> 的 **独立功能单元**，可以构建复杂的软件系统。构件可以由更小的单元组成，细到不可再分的构件称为 **原子构件**。
2. **<u>原子构件</u>**：构件的最小单位，不可再分割为更小的构件。 作为构件而言，依然具有独立的功能和明确的接口，是 **复用的基本单元**。通常是 <u>成组部署</u>，某些情况也可以单独部署。
3. 特性：
    1. 组成：**一个构件可以包含多个原子构件或其他构件**，这些组成部分需要作为一个整体来同时部署
    2. **独立部署性**：构件的部署必须能跟它所在的环境及其他构件完全分离，**可以单独部署**
    3. **独立性**：构件作为一个 <u>独立部署单元</u>，不可拆分
    4. **共享型**：具有复用性，可以在 <u>多个构件家族中共享使用</u>（**原子构件的归属唯一**）
    5. **封装性**：对于不影响构件功能的某些属性可以对外部可见
    6. **唯一性**：<u>在同一环境中，只能存在一种构件</u>
4. 一些描述：
    1. **构件是二进制形式，无需在部署前编译**，即构件应以二进制形式交付，能在运行平台上直接部署，不需要重新编译。
    2. **构件元数据是构件本身相关的数据**，即构件元数据描述的是构件自身的信息，如接口、依赖关系、版本号等，是支持构件管理、查找、配置的关键信息。
    3. **构件是一个独立的** **<u>软件单元</u>**，即对应于构件的独立性属性，指构件应能作为一个完整的、独立的软件单元进行部署和运行。
    4. **<u>构件应支持配置性</u>**，即可以通过参数、属性文件或界面配置等方式，使其适应不同系统的需求，这是构件灵活复用的重要保证。
    5. **<u>接口</u>** 是一个 <u>已命名的一组操作的集合</u>，是构件与外界交互的唯一访问点，定义了构件提供的服务及其使用方式。
    6. **<u>构件的部署</u>** 必须能跟它所在的环境及其他构件完全分离，便于组合、替换和复用，是构件独立部署性的体现。
5. 构件和模块的区别：
    1. 模块：强调程序结构的逻辑划分，**内聚性和耦合性**
    2. 构件：强调 **可复用性和接口标准化**
6. 构件与对象的区别：
    1. 构件的四个特征：
        1. **是一个独立部署单元**
        2. **第三方组装单元**
        3. **无外部可见状态（可以利用容器管理自身对外的可见状态）**
        4. **可以包含多个类元素，且一个类元素仅属于一个构件**
    2. 对象的特征：
        1. 是一个 **实例单元**，有唯一标识
        2. **可能具有外部可见状态**
        3. 封装自身状态行为
    3. 核心区别：
        1. **状态的可见性**

## 4. 构件的分类

### 4.1 构建分类

按照外部形态，构成一个软件系统的构件可以分为五类：

1. **<u>独立而成熟的构件</u>**：
    1. 成熟度高，经过实际的多次检验，并且 **<u>隐藏了所有接口</u>**，用户只需通过命令使用。
    2. 例子：数据库管理系统、操作系统等各类系统、系统级应用
2. **<u>有限制的构件</u>**：
    1. **<u>提供接口</u>**，**<u>并指出使用条件和前提</u>**，有可能产生资源冲突或覆盖，需要进行测试。
    2. 例子：面向对象程序设计语言的基础类库
3. **<u>适应性构件</u>**：
    1. 经过 <u>包装</u> 或 <u>接口技术</u> 处理，主要是为了 **<u>解决不兼容</u>** 的问题，可以在各类环境 **直接使用**。
    2. 例子：Active X 组件，**万能适配**
4. **<u>装配的构件</u>**：
    1. 安装的时候已经装配在操作系统或数据库等系统层次，通过 **<u>胶水代码</u>** 连接使用
    2. 例子：大多数软件供应商提供的软件产品
5. **<u>可修改的构件</u>**：
    1. 支持 **<u>版本替换</u>**，可以通过 <u>重新包装</u> 或者 <u>编写接口</u> 来实现功能 **修改或新增**
    2. 例子：应用系统开发中常用的功能模块，**<u>可迭代</u>**

### 4.2 构件分类方法

1. **<u>关键字分类法</u>**：把应用领域的概念按照从抽象到具体的顺序分解为 **树状或有向无回路图**，每个概念都会用一个 **<u>关键字</u>** 来描述（树状图代表 **层级结构**）
2. **<u>刻面分类法</u>**：多种维度（面）去描述，每个维度（面、特征角度）包含若干个表述特征，<u>通过多个面特征的组合去描述一个构件的功能、被操作的数据、构件应用的语境活任意其他特征</u>（比较灵活，多角度描述，适合复杂构件的分类）
3. **<u>超文本组织方法</u>**：一种全文检索的技术，每个构件都有一个相关的说明文档，搜索时根据关键字去匹配构件的说明文档，进而锁定构件的一种分类方法

## 5. 构件组装

1. 概念：将构件库中的构件，经过适当的修改（改参数、改接口等），再相互连接构成新的目标软件的过程。
2. 三种构件组装技术
    1. 基于 **<u>功能</u>**：通过构件提供的功能接口进行组装，强调功能匹配，是常见的组装方式之一
    2. 基于 **<u>数据</u>**：通过共享数据结构或数据格式实现构件之间的连接与通信。（对输入输出有格式要求）
    3. 基于 **<u>对象</u>**：利用面向对象的封装、继承、多态等特性，将构件作为对象进行组装
3. 组装方式：
    1. **<u>顺序组装</u>**：按照 <u>顺序去调用</u> 已有的构件，来创建新的构件，适用于构件作为程序元素或服务，需要 **<u>胶水代码</u>** 保证前一个构件输出与下一个构件输入相兼容。
    2. **<u>层次组装</u>**：一个构件 <u>直接调用</u> 由另一个构件所提供的服务时，被调用的构件为调用的构件提供所需的服务。
        1. 二者之间接口匹配兼容。
        2. 只有接口兼容才能做层次组装。其他组装不需要考虑接口兼容。
    3. **<u>叠加组装</u>**：指 <u>两个或多个构件合并</u>，创建新的构件，新构件合并了原构件的功能，并且对外提供新的接口，与原构件之间无依赖关系，外部应用通过新接口调用原构件接口。
        1. 适合于 <u>构件是程序单元</u> 或者 <u>构件是服务</u> 的情况
4. 构件组装成软件系统的过程可以分为三个不同的层次：
    1. **<u>定制</u>**（Customization）：对已有的构件进行参数或接口上的适配，用来满足当前所需要的系统。
    2. **<u>集成</u>**（Integration）：对定制好的构件连接成一个整体，并且还要处理构件之间的交互关系。
    3. **<u>扩展</u>**（Extension）：在做出一个初始的系统之后，为未来的改变预留一些空间可以用于改造。
5. 构件组装的三种不兼容问题（通过 <u>编写适配器</u> 解决）：
    1. **<u>参数不兼容</u>**：接口每一侧的操作有相同的名字，但参数类型或参数个数不相同。
    2. **<u>操作不兼容</u>**。提供接口和请求接口的操作名不同。
    3. **<u>操作不完备</u>**。一个构件的提供接口是另一个构件请求接口的一个子集，或者相反。

## 6. 构件管理

1. 概念：构件管理是组件化软件开发中的重要环节，旨在对构件进行有效组织、存储、维护和使用，以提升软件复用率和开发效率。
2. 构件管理的内容包括：
    1. **<u>构件描述</u>**：包括构件的功能、接口信息（输入/输出、操作）、应用语境、性能特征等
    2. **<u>构件分类</u>**：指按功能、用途、技术特性等对构件进行分类管理，方便检索与复用
    3. **构件库组织**：包括如何存储和管理构件数据，不仅存储构件的二进制代码，还包括其元数据、文档和版本信息
    4. **人员及权限管理**：为了保证构件库的安全和有序运作，需要对用户角色进行划分和授权
    5. **用户意见反馈**：收集用户在使用构件过程中发现的缺陷、改进建议或适应性修改需求

## 7. 构件失配

1. 概念：指在软件构件复用与组装过程中，由于 <u>构件对系统的假设与实际体系结构不一致</u> 而导致的冲突。
2. 分类：
    1. **<u>构件失配</u>**：通常源于系统对构件基础设施、控制模型和数据模型的假设不一致，例如构件依赖的运行时环境与系统现有环境不匹配
    2. **<u>连接子失配</u>**：主要包括系统对构件交互协议、数据格式等假设不一致而导致的冲突
    3. **<u>由于系统成分对全局体系结构的假设存在冲突引起的失配</u>**：要解决失配问题，首先需要检测出失配问题，井在此基础上通过适当的手段消除检测出的失配问题。
3. 比较：

    |  | 构件失配 | 连接子失配 |
    | :---: | :---: | :---: |
    | 常见情况 | 基础设施、模型失配 | 交互、协议、规范、数据格式失配 |
    | 解决方案 | 适配器、中间件 | 协议转化、接口适配、数据映射 |


## 8. 构件库

1. 概念：构件库不仅仅是构件的简单堆积，它是实现软件复用的物质基础和核心支撑环境。
2. 功能：
    1. **构件检索**：指用户根据查询需求，能够在构件库中快速准确地找到相关的可复用构件。
    2. **构建分类**：指根据某些特定的标准对构件进行组织和分类，以便于更好地管理和查找。
    3. **构建构造**：指构建新的构件或将多个构件组合成新的构件。
    4. **构建获取**：指从构件库中获取所需构件的过程，通常包括下载或调用。

## 9. 面向构件的编程（COP，Component-Oriented Programming）

1. 定义：基于面向对象编程的方式，专注于 **面向构件** 的解决方案。强调以 **<u>构件</u>** 为基本单元进行软件构建，关注构件的 <u>独立部署</u>、<u>可替换性</u>、<u>可重用性</u> 及 <u>安全性</u>。
2. 核心目标：提升构件的可重用性、灵活性和系统安全性。
3. 四个基本要素：
    1. **<u>多态性</u>**：同一个类型的不同实例对象，具有不同的行为，并且能够相互替代（可复用性、灵活性）
    2. **<u>模块封装性</u>**：把已写好的模块封装起来，隐藏内部的实现细节，只对外暴露必要的接口
    3. **<u>后期绑定和装载</u>**：在构件部署的时候进行绑定，为了实现构件的部署独立性，使得构件更灵活，更易于部署和更新
    4. **<u>安全性</u>**：确保构件的类型安全和模块安全，防止非法访问和使用（保护系统的完整性和稳定性，避免因为构件的滥用导致的系统风险）
4. 面向构件的编程目前缺乏完善的方法学支持，存在很多问题，包括：
    1. **<u>异步处理</u>**：依赖事件传播机制去装配构件，构件需要 **监听事件** 并且 **动态地变更** 自身状态
    2. **<u>多线程并发</u>**：引入共享变量机制，容易引起数据竞争，进而导致 **死锁**
    3. **<u>多语言支持</u>**：构件需要 **跨语言交互**，但主流的编程语言尚不原生支持
    4. **<u>调用者封装</u>**：构件接口可能被内部或外部的代码调用，需要严格定义接口，并且**封装调用逻辑**，避免偶尔混乱

## 10. CORBA 构件模型

1. CORBA：面向对象的 **远程调用中间件**，主要通过 3 大组件解耦客户端与服务端的依赖。
2. 三大依赖：
    1. **<u>伺服对象</u>**（Servant）：是 CORBA 对象的真正实现，负责接收和处理来自客户端的请求，**执行具体业务逻辑**。
    2. **<u>对象适配器</u>**（Object Adapter）：作为 ORB 与 Servant 的 **桥梁**，屏蔽 ORB 的执行细节，并为伺服对象提供注册、激活、调用等统一的 **抽象接口。**
    3. **<u>对象请求代理</u>**（Object Request Broke，ORB）：是 CORBA 的核心通信中介，负责 **解析、调用**，查找目标对象以及路由请求（**通信、调用**，不负责实际的执行）
3. **<u>适配器激活器</u>**（Adapter Activator）：用于在需要时自动激活对象适配器，是 <u>协调调用请求与服务实现之间交互</u> 的关键组件，不处理具体业务请求。
4. 应用场景主要分为 3 大类，根据服务器类型分为：
    1. **应用服务器**：EJB 模型、COM+ 模型
    2. **Web 服务器**：Servlet、ASP 
    3. **.NET 框架**：基于 CLR 的构件模型

## 11. 接口定义语言（IDL）

1. 概念：IDL 是 OMG（对象管理组织）在 CORBA（公共对象请求代理架构）中定义的一种与平台和语言无关的接口定义语言，用于描述分布式系统中组件之间的接口规范。
2. 基本元素：
    1. **<u>接口描述</u>**：是 IDL 文件中 <u>最核心</u> 的部分，用于 <u>定义组件对外提供的操作及属性</u>，是实现不同语言互操作的关键。映射为 Java 类或 C++ 类
    2. **<u>模块定义</u>**：用于将 IDL 元素进行逻辑分组，在 Java 中映射为包（Package），在 C++ 中映射为命名空间（Namespace）
    3. **类型定义**：用于定义用户自定义的数据类型，实现复杂数据结构的封装
    4. **常量定义**：用于在 IDL 文件中声明固定的数值或字符串
    5. **异常**：用于定义在方法调用过程中可能发生的错误或特殊条件
    6. **值类型**：用于定义具有状态和行为的可序列化对象

## 12. 企业 Java Bean（Enterprise Java Bean，EJB）

1. 概念：EJB 是企业级 Java 构件，用于开发和部署多层结构的、分布式的、面向对象的 Java 应用系统
2. 三种会话：
    1. **<u>会话型构件</u>** **（Session Bean）**：可以有或没有状态，主要用于 **实现业务逻辑**，**可以直接访问数据库**，或者通过实体访问数据库，负责完成服务端与客户端的交互
    2. **<u>实体型构件</u>** **（Entity Bean）**：使用对象关系映射（O/R），**把数据库的记录映射为内存中的对象**，以此达到内存中的数据与数据库中达到 **同步**（数据持久化）
    3. **<u>消息驱动构件</u>** **（Message-Driven Bean）**：基础是基于 JMS 消息，功能是只能接收 JMS 消息，用于并发和异步处理客户端请求，适合需要 **异步处理** 的场合

## 13. J2EE（现 Jakarta EE）构建模型

1. 概念：J2EE 是一个用于开发企业级应用程序的标准平台，目的是为了简化和规范企业应用系统的开发和部署，提供一整套的服务应用编程接口和协议，**用于开发多层次的分布式应用程序**。
2. J2EE 应用系统支持五种不同类型的构件模型：
    1. **Applet**：浏览器端的 Java 小程序
    2. **Servlet**：服务端的 Java 程序，主要作用是处理 HTTP 请求
    3. **JSP**：动态网页技术，嵌入 Java 代码
    4. **EJB**：企业级业务组件
    5. **Application Client**：独立的客户端程序（桌面应用）
3. **JFC**：一个 GUI 的开发库
4. **JDBC**：Java 的数据库连接 API

## 14. 服务端构件模型

1. 概念：指用于构建 **服务器端** 业务逻辑和应用服务的软件架构标准。
2. 典型解决方案分为两种：
    1. 适用于 **<u>应用服务器</u>** 的构件模型：
        1. **EJB**（Enterprise JavaBeans）模型
        2. **COM+** 模型
        3. 这类模型更适合处理复杂的事务管理、安全性、分布式计算等企业级业务逻辑。
    2. 适用于 **<u> Web 服务器</u>** 的构件模型：
        1. **servlet 模型**
        2. **基于 Visual Basic 和 ASP 技术的模型**
        3. 通常用于处理 Web 请求与响应。



