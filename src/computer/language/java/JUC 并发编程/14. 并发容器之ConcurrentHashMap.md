---
category: 
- 并发编程
tag: 
- JUC
---

# 并发容器之 ConcurrentHashMap

<!-- more -->

## 1. ConcurrentHashMap 简介

在使用 HashMap 时在多线程情况下扩容会出现 CPU 接近 $100\%$ 的情况，因为 hashmap 并不是线程安全的，通常我们可以使用在 Java 体系中古老的 hashtable 类，该类基本上所有的方法都采用 synchronized 进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。另外一种方式通过 Collections 的 `Map<K,V> synchronizedMap(Map<K,V> m)` 将 hashmap 包装成一个线程安全的 map。比如 SynchronzedMap 的 `put` 方法源码为：

```java
public V put(K key, V value) {
    synchronized (mutex) {
        return m.put(key, value);
    }
}
```

实际上 SynchronizedMap 实现依然是采用 synchronized 独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。针对这种境况，$Doug \ Lea$ 大师不遗余力的为我们创造了一些线程安全的并发容器，让每一个 Java 开发人员倍感幸福。

相对于 hashMap 来说，ConcurrentHashMap 就是线程安全的 Map，其中利用了锁分段的思想提高了并发度。

ConcurrentHashMap 在 JDK1.6 的版本网上资料很多，有兴趣的可以去看看。

JDK 1.6版本关键要素：

1. segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；
2. segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。

而到了 JDK 1.8 的 ConcurrentHashMap 就有了很大的变化，光是代码量就足足增加了很多。

1.8 版本舍弃了 segment，并且大量使用了 synchronized，以及 CAS 无锁操作以保证 ConcurrentHashMap 操作的线程安全性。至于为什么不用 ReentrantLock 而是 Synchronzied 呢？实际上，synchronzied 做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级。因此，使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用**数组+链表+红黑树**的数据形式。




