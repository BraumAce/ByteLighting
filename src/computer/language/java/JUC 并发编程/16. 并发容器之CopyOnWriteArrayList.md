---
category: 
- 并发编程
tag: 
- JUC
---

# 并发容器之 CopyOnWriteArrayList

<!-- more -->

## 1. CopyOnWriteArrayList 简介

Java 学习者都清楚 ArrayList 并不是线程安全的，在读线程在读取 ArrayList 的时候如果有写线程在写数据，基于 fast-fail 机制，会抛出 ConcurrentModificationException 异常，也就是说 ArrayList 并不是一个线程安全的容器，当然我们可以用 Vector，或者用 Collections 的静态方法将 ArrayList 包装成一个线程安全的类，但是这些方式都是采用 Java 关键字 `synchronzied` 对方法进行修饰，利用独占式锁来保证线程安全的。但是，由于独占式锁在同一时刻只有一个线程能够获取到对象监视器，很显然这种方式效率并不是太高。

回到业务场景中，有很多业务往往是读多写少的，比如系统配置的信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻其他模块之后对系统信息只需要进行读取，又比如白名单，黑名单等配置，只需要读取名单配置然后检测当前用户是否在该配置范围以内。类似的还有很多业务场景，它们都是属于**读多写少**的场景。

如果在这种情况用到上述的方法，使用 Vector，Collections 转换的这些方式是不合理的，因为尽管多个读线程从同一个数据容器中读取数据，但是读线程对数据容器的数据并不会发生发生修改。自然而然的我们会想到 ReenTrantReadWriteLock（关于读写锁可以看[这篇文章](./11.%20深入理解读写锁ReentrantReadWriteLock.md)），通过**读写分离**的思想，使得读读之间不会阻塞，无疑如果一个 list 能够做到被多个读线程读取的话，性能会大大提升。但是，如果仅仅是将 list 通过读写锁（ReentrantReadWriteLock）进行再一次封装的话，由于读写锁的特性，当写锁被写线程获取后，读写线程都会被阻塞。所以如果仅使用读写锁对 list 进行封装的话，仍然存在读线程在读数据的时候被阻塞的情况，如果想 list 的读效率更高的话，这里就是我们的突破口，如果我们保证读线程无论什么时候都不被阻塞，效率岂不是会更高？

于是乎，$Doug \ Lea$ 大师为我们提供了 CopyOnWriteArrayList 容器可以保证线程安全，保证读读之间在任何时候都不会被阻塞，CopyOnWriteArrayList 也被广泛应用于很多业务场景之中，值得好好认识一番。

