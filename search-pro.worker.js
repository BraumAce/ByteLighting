const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":307,\"nextId\":307,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2#目录\",\"3\":\"2#模板\",\"4\":\"2#笔记\",\"5\":\"2#剑指-offer\",\"6\":\"2#leetcode\",\"7\":\"3\",\"8\":\"4\",\"9\":\"4#目录\",\"10\":\"4#编程语言\",\"11\":\"4#计算机网络\",\"12\":\"4#数据库\",\"13\":\"4#操作系统\",\"14\":\"4#设计模式\",\"15\":\"4#中间件\",\"16\":\"4#git\",\"17\":\"4#docker\",\"18\":\"5\",\"19\":\"6\",\"20\":\"7\",\"21\":\"8\",\"22\":\"8@0\",\"23\":\"8@1\",\"24\":\"9\",\"25\":\"9#_1-vector-维护一个动态数组\",\"26\":\"9#_2-字符串\",\"27\":\"9#_3-在一个数组中查找最长的相同连续子序列\",\"28\":\"9#_4-秦九韶算法\",\"29\":\"9#_5-开栈空间代码\",\"30\":\"9#_6-求-a-除以-b-的正余数\",\"31\":\"9#_7-裴蜀定理\",\"32\":\"9#_8-交互题\",\"33\":\"9#_9-mex函数\",\"34\":\"9#_10-string-与-int-之间的转化\",\"35\":\"9#_11-string-npos\",\"36\":\"9#_12-x-i-1\",\"37\":\"9#_13-assign\",\"38\":\"9#_14-lambda表达式\",\"39\":\"9#_15-max-element-与-min-element\",\"40\":\"9#_16-tuple\",\"41\":\"9@0\",\"42\":\"9@1\",\"43\":\"10\",\"44\":\"10#_1、1230-k倍区间\",\"45\":\"10#题目描述\",\"46\":\"10#思路\",\"47\":\"10#代码\",\"48\":\"10#_2、3956-截断数组\",\"49\":\"10#题目描述-1\",\"50\":\"10#思路-1\",\"51\":\"10#代码-1\",\"52\":\"10#_3、99-激光炸弹\",\"53\":\"10#题目描述-2\",\"54\":\"10#思路-2\",\"55\":\"10#代码-2\",\"56\":\"10@0\",\"57\":\"10@1\",\"58\":\"11\",\"59\":\"11#简介\",\"60\":\"11#基本模板\",\"61\":\"11#_1-初始化\",\"62\":\"11#_2-查询-已路径压缩\",\"63\":\"11#_3-合并\",\"64\":\"11#典例分析\",\"65\":\"11#例一-亲戚关系\",\"66\":\"11#例二-洛谷-p3367-【模板】并查集\",\"67\":\"11@0\",\"68\":\"11@1\",\"69\":\"12\",\"70\":\"12#_1-844-走迷宫-acwing题库-bfs\",\"71\":\"12#题目描述\",\"72\":\"12#思路\",\"73\":\"12#代码\",\"74\":\"12#_2-845-八数码-acwing题库-bfs\",\"75\":\"12#题目描述-1\",\"76\":\"12#思路-1\",\"77\":\"12#代码-1\",\"78\":\"12#_3-1233-全球变暖-acwing题库\",\"79\":\"12#题目描述-2\",\"80\":\"12#思路-2\",\"81\":\"12#代码-2\",\"82\":\"12#_4-842-排列数字-acwing题库-dfs\",\"83\":\"12#题目描述-3\",\"84\":\"12#思路-3\",\"85\":\"12#代码-3\",\"86\":\"12#_4\",\"87\":\"12#_5\",\"88\":\"12@0\",\"89\":\"12@1\",\"90\":\"13\",\"91\":\"13#_1-92-递归实现指数型枚举-acwing题库\",\"92\":\"13#题目描述\",\"93\":\"13#思路\",\"94\":\"13#代码\",\"95\":\"13#_2-94-递归实现排列型枚举-acwing题库\",\"96\":\"13#题目描述-1\",\"97\":\"13#思路-1\",\"98\":\"13#代码-1\",\"99\":\"13#_3-93-递归实现组合型枚举-acwing题库\",\"100\":\"13#题目描述-2\",\"101\":\"13#思路-2\",\"102\":\"13#代码-2\",\"103\":\"13#_4-165-小猫爬山-acwing题库\",\"104\":\"13#题目描述-3\",\"105\":\"13#思路-3\",\"106\":\"13#代码-3\",\"107\":\"13#_5-1209-带分数-acwing题库\",\"108\":\"13#题目描述-4\",\"109\":\"13#思路-4\",\"110\":\"13#代码-4\",\"111\":\"13@0\",\"112\":\"13@1\",\"113\":\"14\",\"114\":\"14#_1-背包问题\",\"115\":\"14#_1-1-01-背包\",\"116\":\"14#_1-2-完全背包\",\"117\":\"14#_1-3-多重背包\",\"118\":\"14#_1-4-分组背包\",\"119\":\"14#_2-线性dp\",\"120\":\"14#_2-1-数字三角形\",\"121\":\"14#_2-2-最长上升子序列\",\"122\":\"14#_2-3-最长公共子序列-不连续\",\"123\":\"14#_2-4-最长公共上升子序列\",\"124\":\"14#_2-5-编辑距离\",\"125\":\"14#_2-6-最短编辑距离\",\"126\":\"14#_3-区间dp\",\"127\":\"14#_4-计数类dp\",\"128\":\"14#_5-数位统计类dp\",\"129\":\"14#_6-状态压缩类dp\",\"130\":\"14#_6-1-蒙德里安的梦想\",\"131\":\"14#_6-2-最短hamilton路径\",\"132\":\"14#_7-树形dp\",\"133\":\"14#_7-1-没有上司的舞会\",\"134\":\"14@0\",\"135\":\"14@1\",\"136\":\"15\",\"137\":\"15#_1-快速排序\",\"138\":\"15#_2-归并排序\",\"139\":\"15#_3-二分算法\",\"140\":\"15#_3-1-二分查找算法模板\",\"141\":\"15#版本1\",\"142\":\"15#版本2\",\"143\":\"15#_3-2-二分答案模板\",\"144\":\"15#_3-3-整数二分\",\"145\":\"15#_3-4-浮点数二分\",\"146\":\"15#_4-高精度算法\",\"147\":\"15#_4-1-高精度加法\",\"148\":\"15#_4-2-高精度减法\",\"149\":\"15#_4-3-高精度整数乘法\",\"150\":\"15#_4-4-高精度整数除法\",\"151\":\"15#_5-前缀和与差分\",\"152\":\"15#_5-1-一维前缀和\",\"153\":\"15#_5-2-二维前缀和\",\"154\":\"15#_5-3-一维差分\",\"155\":\"15#_5-4-二维差分\",\"156\":\"15#_6-位运算\",\"157\":\"15#_6-1-位运算符\",\"158\":\"15#_6-2-用途\",\"159\":\"15#_6-3-例题\",\"160\":\"15#_7-双指针算法\",\"161\":\"15#_8-离散化\",\"162\":\"15#_9-区间合并\",\"163\":\"15@0\",\"164\":\"15@1\",\"165\":\"16\",\"166\":\"16#_1-树与图的存储\",\"167\":\"16#_2-树与图的遍历\",\"168\":\"16#深度优先遍历\",\"169\":\"16#宽度优先遍历\",\"170\":\"16#_3-拓扑排序\",\"171\":\"16#_4-最短路问题\",\"172\":\"16#_4-1-单源最短路\",\"173\":\"16#_4-1-1-朴素版-dijkstra算法\",\"174\":\"16#_4-1-2-堆优化版的dijkstra算法\",\"175\":\"16#_4-1-3-bellman-ford算法-存在负权边\",\"176\":\"16#_4-1-4-spfa算法-存在负权边\",\"177\":\"16#_4-1-5-spfa算法判断图中是否存在负环\",\"178\":\"16#_4-2-多源汇最短路\",\"179\":\"16#_4-2-1-floyd算法\",\"180\":\"16#_5-最小生成树问题\",\"181\":\"16#_5-1-朴素prim算法\",\"182\":\"16#_5-2-kruskal-算法\",\"183\":\"16#_6-染色法判别二分图\",\"184\":\"16#_7-匈牙利算法\",\"185\":\"16@0\",\"186\":\"16@1\",\"187\":\"17\",\"188\":\"17#_1-质数\",\"189\":\"17#_1-1-试除法判定质数\",\"190\":\"17#_1-2-试除法分解质因数\",\"191\":\"17#汇总\",\"192\":\"17#_1-3-筛法求素数\",\"193\":\"17#_1-3-1-朴素筛法-埃氏筛\",\"194\":\"17#_1-3-2-区间筛法\",\"195\":\"17#_1-3-3-线性筛-欧拉筛\",\"196\":\"17#_2-约数\",\"197\":\"17#_2-1-试除法求所有约数\",\"198\":\"17#_2-2-约数个数和约数之和\",\"199\":\"17#_2-3-最大公约数与最小公倍数\",\"200\":\"17#_3-欧拉函数\",\"201\":\"17#_3-1-求欧拉函数\",\"202\":\"17#_3-2-筛法求欧拉函数\",\"203\":\"17#_4-快速幂\",\"204\":\"17#_5-扩展欧几里得算法\",\"205\":\"17#裴蜀定理\",\"206\":\"17#_6-中国剩余定理\",\"207\":\"17#_7-高斯消元\",\"208\":\"17#_8-求组合数\",\"209\":\"17#_8-1-递推法求组合数\",\"210\":\"17#_8-2-通过预处理逆元的方式求组和数\",\"211\":\"17#_8-3-卢卡斯-lucas-定理求组合数\",\"212\":\"17#_8-4-分解质因数法求组合数\",\"213\":\"17#_8-5-卡特兰数\",\"214\":\"17#_9-容斥原理\",\"215\":\"17#_10-博弈论\",\"216\":\"17#_10-1-nim游戏\",\"217\":\"17#_10-2-公平组合游戏icg\",\"218\":\"17#_10-3-有向图游戏\",\"219\":\"17#_10-4-mex运算\",\"220\":\"17#_10-5-sg游戏\",\"221\":\"17#_10-6-有向图游戏的和\",\"222\":\"17@0\",\"223\":\"17@1\",\"224\":\"18\",\"225\":\"18#_1-数组模拟链表\",\"226\":\"18#_1-1-单链表\",\"227\":\"18#_1-2-双链表\",\"228\":\"18#_2-栈\",\"229\":\"18#_2-1-普通栈\",\"230\":\"18#_2-1-单调栈\",\"231\":\"18#_3-队列\",\"232\":\"18#_3-1-普通队列\",\"233\":\"18#_3-2-单调队列\",\"234\":\"18#_4-kmp\",\"235\":\"18#_5-trie树\",\"236\":\"18#_6-并查集\",\"237\":\"18#_6-1-朴素并查集\",\"238\":\"18#_6-2-维护size的并查集\",\"239\":\"18#_6-3-维护到祖宗节点距离的并查集\",\"240\":\"18#_7-堆\",\"241\":\"18#_8-哈希表\",\"242\":\"18#_8-1-拉链法\",\"243\":\"18#_8-2-开放寻址法\",\"244\":\"18#_8-3-字符串哈希\",\"245\":\"18#_9-c-stl简介\",\"246\":\"18#_10-常用库函数\",\"247\":\"18@0\",\"248\":\"18@1\",\"249\":\"19\",\"250\":\"19#_1-区间问题\",\"251\":\"19#_1-1-区间选点\",\"252\":\"19#_1-2-最大不相交区间数量\",\"253\":\"19#_1-3-区间分组\",\"254\":\"19#_1-4-区间覆盖\",\"255\":\"19#_1-5-区间合并\",\"256\":\"19@0\",\"257\":\"19@1\",\"258\":\"20\",\"259\":\"20@0\",\"260\":\"20@1\",\"261\":\"21\",\"262\":\"21#题意\",\"263\":\"21#思路一-递归\",\"264\":\"21#思路二-迭代\",\"265\":\"21@0\",\"266\":\"21@1\",\"267\":\"22\",\"268\":\"22#题意\",\"269\":\"22#思路一-优先队列\",\"270\":\"22#思路二-单调队列\",\"271\":\"22@0\",\"272\":\"22@1\",\"273\":\"23\",\"274\":\"23#linux-安装启动\",\"275\":\"23#docker-安装启动\",\"276\":\"23#windows-安装启动\",\"277\":\"23#windows-后台服务安装\",\"278\":\"23@0\",\"279\":\"23@1\",\"280\":\"24\",\"281\":\"24#什么是对象存储\",\"282\":\"24#特点\",\"283\":\"24@0\",\"284\":\"24@1\",\"285\":\"25\",\"286\":\"25#引入依赖\",\"287\":\"25#配置文件\",\"288\":\"25#minioclient-的常用-api\",\"289\":\"25#bucket-操作\",\"290\":\"25#object-操作\",\"291\":\"25@0\",\"292\":\"25@1\",\"293\":\"26\",\"294\":\"26@0\",\"295\":\"26@1\",\"296\":\"27\",\"297\":\"28\",\"298\":\"29\",\"299\":\"30\",\"300\":\"31\",\"301\":\"32\",\"302\":\"33\",\"303\":\"34\",\"304\":\"35\",\"305\":\"36\",\"306\":\"37\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1,4],\"2\":[1],\"3\":[1,6],\"4\":[1],\"5\":[2],\"6\":[1],\"7\":[1,4],\"8\":[1,9],\"9\":[1],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[1],\"14\":[1],\"15\":[1,44],\"16\":[1],\"17\":[1],\"18\":[1,2],\"19\":[1,3],\"20\":[1,5],\"21\":[1],\"22\":[null,null,1],\"23\":[null,null,1],\"24\":[1],\"25\":[3,14],\"26\":[2,88],\"27\":[2,19],\"28\":[2,23],\"29\":[2,21],\"30\":[6,7],\"31\":[2,25],\"32\":[2,27],\"33\":[2,20],\"34\":[5,39],\"35\":[3,31],\"36\":[5,7],\"37\":[3,44],\"38\":[2,74],\"39\":[6,36],\"40\":[2,32],\"41\":[null,null,1],\"42\":[null,null,2],\"43\":[1],\"44\":[1],\"45\":[1,40],\"46\":[1,70],\"47\":[1,41],\"48\":[1],\"49\":[1,38],\"50\":[1,33],\"51\":[1,41],\"52\":[1],\"53\":[1,47],\"54\":[1,16],\"55\":[1,54],\"56\":[null,null,1],\"57\":[null,null,2],\"58\":[1],\"59\":[1,18],\"60\":[1],\"61\":[2,24],\"62\":[4,21],\"63\":[2,22],\"64\":[1],\"65\":[2,109],\"66\":[5,127],\"67\":[null,null,1],\"68\":[null,null,2],\"69\":[1],\"70\":[2],\"71\":[1,45],\"72\":[1],\"73\":[1,61],\"74\":[2],\"75\":[1,50],\"76\":[1],\"77\":[1,77],\"78\":[1],\"79\":[1,47],\"80\":[1],\"81\":[1],\"82\":[2],\"83\":[1,21],\"84\":[1],\"85\":[1,39],\"86\":[2],\"87\":[2],\"88\":[null,null,1],\"89\":[null,null,4],\"90\":[1],\"91\":[1],\"92\":[1,27],\"93\":[1],\"94\":[1,38],\"95\":[1],\"96\":[1,25],\"97\":[1],\"98\":[1,45],\"99\":[1],\"100\":[1,40],\"101\":[1],\"102\":[1,43],\"103\":[1],\"104\":[1,55],\"105\":[1],\"106\":[1,53],\"107\":[1],\"108\":[1,29],\"109\":[1,46],\"110\":[1,73],\"111\":[null,null,1],\"112\":[null,null,2],\"113\":[1],\"114\":[2,4],\"115\":[3,48],\"116\":[3,45],\"117\":[3,74],\"118\":[3,53],\"119\":[2],\"120\":[3,53],\"121\":[2,73],\"122\":[5,47],\"123\":[3,79],\"124\":[3,83],\"125\":[3,64],\"126\":[2,75],\"127\":[2,60],\"128\":[2,101],\"129\":[2],\"130\":[3,74],\"131\":[3,74],\"132\":[2],\"133\":[3,76],\"134\":[null,null,1],\"135\":[null,null,1],\"136\":[1],\"137\":[2,54],\"138\":[2,58],\"139\":[2],\"140\":[3,13],\"141\":[1,30],\"142\":[1,45],\"143\":[3,36],\"144\":[2,72],\"145\":[3,25],\"146\":[2],\"147\":[3,77],\"148\":[3,106],\"149\":[3,60],\"150\":[2,72],\"151\":[2],\"152\":[3,10],\"153\":[3,15],\"154\":[3,10],\"155\":[3,13],\"156\":[2],\"157\":[3,37],\"158\":[3,138],\"159\":[3,81],\"160\":[2,25],\"161\":[2,34],\"162\":[2,27],\"163\":[null,null,1],\"164\":[null,null,1],\"165\":[1],\"166\":[2,73],\"167\":[2,7],\"168\":[1,16],\"169\":[1,23],\"170\":[2,49],\"171\":[2],\"172\":[3,34],\"173\":[4,84],\"174\":[4,76],\"175\":[7,103],\"176\":[5,88],\"177\":[4,62],\"178\":[3],\"179\":[4,31],\"180\":[2,14],\"181\":[3,106],\"182\":[4,114],\"183\":[2,80],\"184\":[2,94],\"185\":[null,null,1],\"186\":[null,null,1],\"187\":[1],\"188\":[2],\"189\":[2,26],\"190\":[3,47],\"191\":[1,34],\"192\":[3],\"193\":[5,63],\"194\":[4,53],\"195\":[5,65],\"196\":[2],\"197\":[3,27],\"198\":[2,67],\"199\":[3,27],\"200\":[2],\"201\":[3,35],\"202\":[3,60],\"203\":[2,49],\"204\":[2],\"205\":[1,64],\"206\":[2,94],\"207\":[2,83],\"208\":[2],\"209\":[3,29],\"210\":[3,86],\"211\":[5,79],\"212\":[3,73],\"213\":[3,11],\"214\":[2,81],\"215\":[2],\"216\":[3,74],\"217\":[3,17],\"218\":[3,12],\"219\":[3,11],\"220\":[3,23],\"221\":[3,22],\"222\":[null,null,1],\"223\":[null,null,1],\"224\":[1],\"225\":[2],\"226\":[2,49],\"227\":[3,35],\"228\":[2,1],\"229\":[3,20],\"230\":[3,31],\"231\":[2,2],\"232\":[3,24],\"233\":[3,38],\"234\":[2,86],\"235\":[2,41],\"236\":[2],\"237\":[3,32],\"238\":[3,26],\"239\":[3,32],\"240\":[2,90],\"241\":[2],\"242\":[3,27],\"243\":[3,23],\"244\":[3,46],\"245\":[3,144],\"246\":[2,100],\"247\":[null,null,1],\"248\":[null,null,1],\"249\":[1],\"250\":[2],\"251\":[2,54],\"252\":[3,45],\"253\":[3,62],\"254\":[3,65],\"255\":[3,64],\"256\":[null,null,1],\"257\":[null,null,1],\"258\":[1,17],\"259\":[null,null,1],\"260\":[null,null,1],\"261\":[1,1],\"262\":[1,16],\"263\":[3,13],\"264\":[3,21],\"265\":[null,null,1],\"266\":[null,null,3],\"267\":[1,3],\"268\":[1,11],\"269\":[3,41],\"270\":[3],\"271\":[null,null,1],\"272\":[null,null,3],\"273\":[2,16],\"274\":[2,85],\"275\":[2,20],\"276\":[2,42],\"277\":[2,78],\"278\":[null,null,1],\"279\":[null,null,1],\"280\":[2,40],\"281\":[2,56],\"282\":[1,143],\"283\":[null,null,1],\"284\":[null,null,1],\"285\":[3],\"286\":[1,12],\"287\":[1,85],\"288\":[3],\"289\":[2,76],\"290\":[2,95],\"291\":[null,null,1],\"292\":[null,null,1],\"293\":[6],\"294\":[null,null,1],\"295\":[null,null,1],\"296\":[1,3],\"297\":[2],\"298\":[1],\"299\":[1],\"300\":[2],\"301\":[2],\"302\":[1],\"303\":[2],\"304\":[1],\"305\":[2],\"306\":[1]},\"averageFieldLength\":[2.0577758961984505,39.21329057962845,0.3940462345352996],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"个人介绍和档案放置在此。\"]},\"1\":{\"h\":\"算法笔记\",\"t\":[\"此处存放刷题时的思路和笔记，包括算法题、笔试题和面试题等。\"]},\"2\":{\"h\":\"目录\"},\"3\":{\"h\":\"模板\",\"t\":[\"基础算法\",\"数据结构\",\"搜索与图论\",\"数学知识\",\"动态规划\",\"贪心\"]},\"4\":{\"h\":\"笔记\"},\"5\":{\"h\":\"剑指 offer\"},\"6\":{\"h\":\"LeetCode\"},\"7\":{\"h\":\"架构设计\",\"t\":[\"此处存放一些关于 Java 架构以及系统架构方面的笔记知识点。\"]},\"8\":{\"h\":\"计算机\",\"t\":[\"此处存放一些计算机大类的笔记，包括编程语言、计算机网络、操作系统、数据库、Linux、Git、Docker等等。\"]},\"9\":{\"h\":\"目录\"},\"10\":{\"h\":\"编程语言\"},\"11\":{\"h\":\"计算机网络\"},\"12\":{\"h\":\"数据库\"},\"13\":{\"h\":\"操作系统\"},\"14\":{\"h\":\"设计模式\"},\"15\":{\"h\":\"中间件\",\"t\":[\"中间件（英语：Middleware）：是一种在系统软件和用户应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件在客户服务器的操作系统、网络和数据库之上，管理计算资源和网络通信。总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。\",\"也就是说，关于中间件，可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。中间件是一类软件统称，而非一种软件；中间件不仅仅实现互连，还要实现应用之间的互操作。\",\"中间件与操作系统和数据库共同构成基础软件三大支柱，是一种应用于分布式系统的基础软件，位于应用与操作系统、数据库之间，为上层应用软件提供开发、运行和集成的平台。中间件解决了异构网络环境下软件互联和互操作等共性问题，并提供标准接口、协议，为应用软件间共享资源提供了可复用的“标准件”。\",\"常见中间件主要分为：Web中间件、数据库中间件、消息中间件、安全中间件、事务中间件、应用程序服务器中间件、分布式计算中间件等。\"]},\"16\":{\"h\":\"Git\"},\"17\":{\"h\":\"Docker\"},\"18\":{\"h\":\"常用框架\",\"t\":[\"此处存放前后端常用框架的笔记。\"]},\"19\":{\"h\":\"开源项目\",\"t\":[\"此处存放自己写和一些优秀的开源项目，帮助学习。\"]},\"20\":{\"h\":\"程序人生\",\"t\":[\"此处存放一些程序员相关的资源文件，包括但不限于书籍、文章、资料等等。\"]},\"21\":{\"h\":\"剑指offer\"},\"22\":{\"c\":[\"algorithm\"]},\"23\":{\"c\":[\"offer\"]},\"24\":{\"h\":\"一些经验和技巧\"},\"25\":{\"h\":\"1. vector 维护一个动态数组\",\"t\":[\"定义时初始化(一般 +1 防止数组越界) vector<int> a(n + 1, 0); 定义一个二维动态数组 vector<vector<int>> g(n + 1, vector<int>(n + 1));\"]},\"26\":{\"h\":\"2. 字符串\",\"t\":[\"size() 和 length()：这两个函数会返回 string 类型对象中的字符个数，且它们的执行效果相同\",\"strlen() ：是C语言标准库中的函数\",\"// 返回 string 长度，单位字节 size_t length() const noexcept; // 返回 string 长度，单位字节。作用等同于 length() size_t size() const noexcept; // C 标准库函数，返回C风格字符串长度，单位字节 size_t strlen ( const char * str );\",\"（1）当 string 中含有空字符’\\\\0’，使用 strlen() 获取 string 的长度时会被截断，使用成员函数 length() 和 size() 可以返回 string 的真实长度。\",\"（2）cout 对 string 输出时，会过滤掉空字符，输出不会被截断。\",\"（3）在构造或者拼接 string 时，建议同时指定 string 的长度，比如：\",\"如果字符串长度很大（例如超过 1e9）的时候，要使用 s.length() 获取字符串长度，使用 s.size() 会爆掉\",\"max_size()：返回 string 类型对象最多包含的字符数。一旦程序使用长度超过 max_size() 的 string 操作，编译器会拋出 length_error 异常。\",\"resize() ： 修改字符串的长度\",\"str.resize(5); // 长度修改为5\",\"capacity() ：该函数返回在重新分配内存之前，string 类型对象所能包含的最大字符数。\",\"使用 printf() 输出 string 类型\",\"① printf 函数输出字符串是针对 char * 的，即 printf 只能输出c语言的内置数据类型，而 string 不是c语言的内置数据类型。\",\"② string 类型的对象不止包含字符串，还包含了许多用于操作的函数，所以 &str 并非字符串的首地址。\",\"③ 如需输出string对象中的字符串，可以使用 string 的成员函数c_str()，该函数返回字符串的首字符的地址。\",\"string s = \\\"hello\\\"; printf(\\\"%s\\\", s.c_str()); //输出：hello\"]},\"27\":{\"h\":\"3. 在一个数组中查找最长的相同连续子序列\",\"t\":[\"// 在由 0、1 组成的字符串中查找最长的‘1’ for (int i = 0; i < n; i++) { if (s[i] == '1') len++; if (s[i] == '0'){ res = max(res, len); len = 0; } }\"]},\"28\":{\"h\":\"4. 秦九韶算法\",\"t\":[\"int res = 0; for (int i = 1; i <= n; i++) res = res * b + a[i]; //b代表进制位数\",\"将一个 i 进制的数转化为十进制\",\"int get(string s, int i) { int res = 0; for (auto c : s) res = res * i + c - '0'; return res; }\"]},\"29\":{\"h\":\"5. 开栈空间代码\",\"t\":[\"备份，以防爆栈风险\",\"int main() { int size(512<<20); // 512M __asm__ ( \\\"movq %0, %%rsp\\\\n\\\"::\\\"r\\\"((char*)malloc(size)+size)); // YOUR CODE ... exit(0); return 0; }\"]},\"30\":{\"h\":\"6. 求 a 除以 b 的正余数\",\"t\":[\"int get_mod(int a, int mod) { return (a % mod + mod) % mod; }\"]},\"31\":{\"h\":\"7. 裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\"]},\"32\":{\"h\":\"8. 交互题\",\"t\":[\"若要提问，请打印 “ ？+ 问题 ” ，然后从标准输入中输入响应\",\"如果你的程序问了一个无效的问题，或者问题用完了，交互器将立即终止，你的程序将得到一个判断错误的答案。\",\"要给出最终答案，请打印 “ ! + 答案 ”\",\"问完一个问题后，要输出行的末尾并刷新输出，否则将会得到超过限制限制的结果。\",\"C中的 fflush(stdout) 或者C++中的 cout.flush()； Java中的 System.out.flush()； Pascal中的 flush(output)； Python中的 stdout.flush().\"]},\"33\":{\"h\":\"9. mex函数\",\"t\":[\"auto mex = [](vector<int> w) { sort(w.begin(), w.end()); int mx = 0; for (int x : w) if (x == mx) ++mx; return mx; }; int z = mex(v);\"]},\"34\":{\"h\":\"10. string 与 int 之间的转化\",\"t\":[\"（1）int 转 string\",\"通过 to_string() 函数转换\",\"int num = 123; string s = to_string(num); cout << s << endl; // s = \\\"123\\\"\",\"通过 sprintf 转换\",\"int num = 123; char str[256]; sprintf(str, \\\"%d\\\", num); printf(\\\"%s\\\", str);\",\"这是一种C语言中的转换方式，sprintf 也可以换成更安全的 snprintf 函数\",\"（2）string 转 int\",\"通过 sscnaf 转换\",\"string str = \\\"123\\\"; int num = 0; sscanf(str.c_str(), \\\"%d\\\", &num); cout << num << endl; // num = 123\",\"sscanf 函数的第一个参数类型是 const char *，string类型的参数需要转换一下\",\"使用 atoi 转换\",\"string str = \\\"123\\\"; cout << atoi(str.c_str()); // 123\",\"atoi 函数的头文件是 stdlib.h\"]},\"35\":{\"h\":\"11. string::npos\",\"t\":[\"string::npos是一个静态成员常量，表示size_t的最大值（Maximum value for size_t）。该值表示“直到字符串结尾”**，**作为返回值它通常被用作表明没有匹配。\",\"string::npos是这样定义的：\",\"static const size_type npos = -1;\",\"常用于配合 find() 函数使用，该函数有唯一的返回类型，即 string::size_type , 即一个无符号整型类型，可能是整数，也可能是长整数。\",\"如果查找成功，返回按照查找规则找到的第一个字符或者子串的位置；\",\"如果查找失败，返回 string::npos , 即 -1\"]},\"36\":{\"h\":\"12. x >> i & 1\",\"t\":[\"x >> i & 1 用来判断 x 的二进制表示下的每一位是不是 1 .\"]},\"37\":{\"h\":\"13. assign()\",\"t\":[\"C++ 函数 std::vector::assign() 通过替换旧值为向量元素分配新值。 如有必要，它会修改矢量的大小。\",\"assign(n, val) 有两个参数，n — 容器大小，val — 重新赋给每个元素的值；\",\"assign(first, last) 区间，左闭右开\",\"功能：\",\"①将区间 [first,last) 的元素赋值到当前的 vector 容器中；\",\"②赋 n 个值为 x 的元素到 vector 容器中，会覆盖掉 vector 容器中以前的内容。\",\"1.第一种用法 vector<int> v1, v2; v2.assign(v1,begin(), v1.end()); 2.第二种用法 vector<int> a(n + 1); vector<vector<int>> g(n + 1); 一维：a.assign(n + 1, 0); 二维：g.assign(n + 1, vector<int>());\"]},\"38\":{\"h\":\"14. lambda表达式\",\"t\":[\"lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：\",\"[ capture ] ( params ) opt -> ret { body; };\",\"其中\",\"capture 是捕获列表，空表示不捕获任何变量；\",\"& 表示捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）；\",\"= 表示捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）；\",\"=，&foo 表示按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。\",\"bar 按值捕获 bar 变量，同时不捕获其他变量；\",\"this 表示捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。\",\"params 是参数表， opt 是函数选项， ret 是返回值类型， body是函数体\",\"写法示例：\",\"// 计算两个数的和 auto plus = [] (int v1, int v2) -> int { return v1 + v2; } int sum = plus(1, 2);\",\"递归 Lambda 表达式：\",\"//d vector<int> cnt(n); auto dfs = [&](auto self, int u, int p) -> void { for (auto v : adj[u]) { if (v != p) { self(self, v, u); cnt[u] += cnt[v]; } } if (cnt[u] == 0) { cnt[u] = 1; } }; dfs(dfs, 0, -1); //树的根节点从0开始，初始化为-1\"]},\"39\":{\"h\":\"15. max_element() 与 min_element()\",\"t\":[\"max_element() 与min_element() 分别用来求最大元素和最小元素的位置。\",\"接收参数：容器的首尾地址（迭代器）（可以是一个区间）\",\"返回：最值元素的地址（迭代器），需要减去序列头以转换为下标\",\"vector<int> v; int maxPos = max_element(v.begin(), v.end()) - v.begin(); //最大值下标 int minPos = min_element(v.begin(), v.end()) - v.begin();//最小值下标 2）普通数组 int a[] = {1,2,3,4}; int maxPos = max_element(a, a + 2) - a; //最大值下标 int minPos = min_element(a, a + 2) - a;//最小值下标\",\"max_element() 与 min_element() 分别用来求最大元素和最小元素的值。\",\"接收参数：容器的首尾地址（迭代器）（可以是一个区间）\",\"返回：最值元素的值\",\"int maxValue = *max_element(v.begin(), v.end()); //最大值 int minValue = *min_element(v.begin(), v.end()); //最小值 int maxValue = *max_element(a, a + 2); //最大值 int minValue = *min_element(a, a + 2); //最小值\"]},\"40\":{\"h\":\"16. tuple\",\"t\":[\"tuple 是泛化的 std::pair，我们通常是把它当作一个结构体使用，比如我们可以将多个参数整合为一个结构体传递到函数内部，实现一些简洁的操作。\",\"创建\",\"tuple<int,float,int,float> tu = make_tuple(1,2.f,3,4.f);//创建方式一 tuple<int,float,int,float> tu(1,2.f,3,4.f);//创建方式二 //相当于结构体： struct tu { int a; float b; int c; float d; }\",\"同 pair<first, second> 一样\"]},\"41\":{\"c\":[\"笔记\"]},\"42\":{\"c\":[\"ACM\",\"note\"]},\"43\":{\"h\":\"前缀和相关题型\"},\"44\":{\"h\":\"\"},\"45\":{\"h\":\"题目描述\",\"t\":[\"给定一个长度为 N 的数列，A1​,A2​,…AN​，如果其中一段连续的子序列 Ai​,Ai+1​,…Aj​ 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？\",\"输入格式\",\"第一行包含两个整数 N 和 K。 以下 N 行每行包含一个整数 Ai​。\",\"输出格式\",\"输出一个整数，代表 K 倍区间的数目。\",\"数据范围\",\"1⩽N,K⩽1000001⩽Ai​⩽100000\",\"输入样例：\",\"5 2 1 2 3 4 5\",\"输出样例：\",\"6\"]},\"46\":{\"h\":\"思路\",\"t\":[\"翻译：求区间 [l,r] 的和是 k 的倍数的个数。\",\"求区间和，我们可以通过 前缀和 来求出。 定义 sum[i] 表示第 1 个元素到第 i 个元素的和，那么 s[r] - s[l-1] 就是区间 [l,r] 的和。 若满足条件：区间 [l,r] 的和是k的倍数，即 (s[r] - s[l-1]) % k == 0 ，等价于 s[r] % k == s[l-1] % k 。\",\"说人话，这也就意味着：\",\"如果 s[r] mod k 和 s[l - 1] mod k 的余数相等，那么 s[r] - s[l - 1] 的差值必然是 k 的倍数。\",\"比如：13 % 7 == 20 % 7，则 (20 - 7) % 7 == 0\",\"那么题目就是要我们求 前缀和%k==0 的组合有多少种。\",\"用 cnt[i] 存储目前为止前缀和相同的个数，i 表示这个前缀和的值。 每次用 res 来递加 cnt[i] 相同的个数，前面有几个 前缀和的值 和 当前前缀和 相等，那么这个前缀和就能和前面每一个组成一个组合，所以要 res += cnt[s[i]] ，然后再加上现在的前缀和，即 cnt[s[i]]++ 。 初始化 cnt[0] = 1 ，因为当 s[i] == 0 时，这个前缀和本身就是 k 的倍数，不需要再跟别的前缀和组合，计算结果时就要加上这一个。\"]},\"47\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 1e5 + 10; int n, k; ll s[N]; ll cnt[N]; int main() { cin >> n >> k; ll res = 0; cnt[0] = 1; for (int i = 1; i <= n; i++){ cin >> s[i]; s[i] = (s[i] + s[i - 1]) % k; // 每次前缀和都取模 res += cnt[s[i]]; // 和前面每一个都组合一下 cnt[s[i]]++; // 现在又多了一个 } cout << res << endl; return 0; }\"]},\"48\":{\"h\":\"\"},\"49\":{\"h\":\"题目描述\",\"t\":[\"给定一个长度为 n 的数组 a1​,a2​,…,an​ 。 现在，要将该数组从中间截断，得到三个非空子数组。 要求，三个子数组内各元素之和都相等。 请问，共有多少种不同的截断方法？\",\"输入格式\",\"第一行包含整数 n。 第二行包含 n 个整数 a1​,a2​,…,an​ 。\",\"输出格式\",\"输出一个整数，表示截断方法数量。\",\"数据范围\",\"前六个测试点满足 1⩽n⩽10。\",\"所有测试点满足 1⩽n⩽105,−10000⩽ai​⩽10000。\",\"输入样例1：\",\"4 1 2 3 3\",\"输出样例1：\",\"1\",\"输入样例2：\",\"5 1 2 3 4 5\",\"输出样例2：\",\"0\",\"输入样例3：\",\"2 0 0\",\"输出样例3：\",\"0\"]},\"50\":{\"h\":\"思路\",\"t\":[\"先预处理前缀和，先判断如果 s[n] % 3 != 0，则不能被均分为三份，输出 0.\",\"然后从 i = 3 开始枚举前缀和数组，以 i 作为切割点，s[i - 2] 为第一段，s[n] - s[i - 1] 为第三段，如果 第一段 = 第三段 = 3s[n]​​，则第二段也一定相等，都符合条件。\",\"先判断第一段是否符合，记录个数，如果第三段不符合，则表示该切割点不行，继续后移，每次当第三段符合时，都加上第一段符合的个数即可。\"]},\"51\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 1e5 + 10; int n; ll s[N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> s[i]; s[i] += s[i - 1]; } if (s[n] % 3){ cout << 0 << endl; return 0; } ll cnt = 0, res = 0; for (int i = 3; i <= n; i++){ if (s[i - 2] == s[n] / 3) cnt++; if (s[n] - s[i - 1] == s[n] / 3) res += cnt; } cout << res << endl; return 0; }\"]},\"52\":{\"h\":\"\"},\"53\":{\"h\":\"题目描述\",\"t\":[\"地图上有 N 个目标，用整数 Xi​,Yi​ 表示目标在地图上的位置，每个目标都有一个价值 Wi​ 。\",\"注意：不同目标可能在同一位置。\",\"现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x,y 轴平行。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。\",\"输入格式\",\"第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。 接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi​,Yi​,Wi​ ，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。\",\"输出格式\",\"输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。\",\"数据范围\",\"0⩽R⩽1090<N⩽100000⩽Xi​,Yi​⩽50000⩽Wi​⩽1000\",\"输入样例：\",\"2 1 0 0 1 1 1 1\",\"输出样例：\",\"1\"]},\"54\":{\"h\":\"思路\",\"t\":[\"递推求出二维前缀和 。\",\"因为题目的内存限制，我们直接用二维数组读入数据，边读边加。 然后我们再求其前缀和，再从地图右下角枚举边长为 R​ 的正方形，通过下式\",\"s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]\",\"即可计算出该正方形内所有目标的价值之和。\"]},\"55\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 5e3 + 10; // 不能开到 1e5 + 10，二维会爆栈 int n, r; int s[N][N]; int main() { cin >> n >> r; r = min(5001, r); // 因为r最大可取到10^9,但地图没有这么大 for (int i = 1; i <= n; i++){ int x, y, w; cin >> x >> y >> w; s[++x][++y] += w; // 因为数据范围是从0开始的 } //如果i从0开始那么i-1会导致数组越界 for (int i = 1; i <= 5001; i++){ for (int j = 1; j <= 5001; j++){ s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } } int res = 0; for (int i = r; i <= 5001; i++){ for (int j = r; j <= 5001; j++){ res = max(res, s[i][j] - s[i - r][j] - s[i][j - r] + s[i - r][j - r]); } } cout << res << endl; return 0; }\"]},\"56\":{\"c\":[\"笔记\"]},\"57\":{\"c\":[\"ACM\",\"前缀和\"]},\"58\":{\"h\":\"并查集\"},\"59\":{\"h\":\"简介\",\"t\":[\"1.并查集是一种非常精巧实用的数据结构，它主要用于处理一些不相交集合的合并问题。一些常见的用途有求连通子图，求最小生成树的 Kruskal 算法和求最近公共祖先（LCA）等。\",\"2.基本操作主要有：\",\"（1）初始化 init\",\"（2）查询 find\",\"（3）合并 union\"]},\"60\":{\"h\":\"基本模板\"},\"61\":{\"h\":\"1.初始化\",\"t\":[\"int fa[N]; void init(int n){ for (int i = 1; i <= n; i++) fa[i] = i; // 一开始都是独立的，父节点设置为自己 }\",\"假如有编号为 1，2，3，...，n 的 n 个元素，我们用一个数组 fa[N] 来存储每个元素的父节点。一开始，我们先将它们的父节点设为自己。\"]},\"62\":{\"h\":\"2.查询（已路径压缩）\",\"t\":[\"查询一定要进行路径压缩，不然大概率会超时。\",\"int find(int x){ //递归出口，当达到了祖先位置，就返回祖先 if (fa[x] == x) return x; else { //不断往上查找祖先，并进行路径压缩，一直找到祖先的祖先 fa[x] = find(fa[x]); return fa[x]; //返回父亲节点 } }\",\"也可以简写成这样：\",\"int fond(int x){ return fa[x] == x ? x : find(fa[x]); }\"]},\"63\":{\"h\":\"3.合并\",\"t\":[\"最简单的合并就是像下面这样，粗暴的把 i 所在树的根节点接到 j 所在树的根节点下面，但是有可能出现 “头重脚轻” 的不平衡状况，后面例二中将会给出解决方法。\",\"void union(int i, int j){ int x = find(i); // 找到i的根节点 int y = find(j); // 找到j的根节点 fa[x] = y; // i的根节点指向j的根节点 }\"]},\"64\":{\"h\":\"典例分析\"},\"65\":{\"h\":\"例一：亲戚关系\",\"t\":[\"现在有若干家族图谱关系，给出了一些亲戚关系，如 A 和 B 是亲戚，B 和 C 是亲戚，那么 A和 B 也是亲戚。请写一个程序，对于我们的关于亲戚关系的提问，以最快的速度给出答案。\",\"【输入格式】\",\"第一部分是以 N，M 开始。N 为人数（1⩽N⩽20000），这些人的编号为 1，2，3，...，N。 下面有 M行（1⩽M⩽1000000），每行有两个数 a，b，表示 a 和 b 是亲戚。\",\"第二部分是以 Q 开始。以下 Q 行有 Q 行询问（1⩽Q⩽1000000），每行为 c, d, 表示询问 c 和 d 是否为亲戚。\",\"【输出格式】\",\"对于询问 c, d, 输出一行：若 c, d 为亲戚，则输出 “YES” ，否则输出 “NO”。\",\"【输入样例】\",\"10 7 2 4 5 7 1 3 8 9 1 2 5 6 2 3 3 3 4 7 10 8 9\",\"【输出样例】\",\"YES NO YES\",\"【示例代码】\",\"#include <iostream> #include <cstdio> #include <cstdlib> using namespace std; const int N = 20005; int fa[N]; // 父亲数组 // 初始化父亲为它自己 void init (int n){ for (int i = 1; i <= n; i++) fa[i] = i; } // 查找根节点 int find(int x){ if (fa[x] == x) return x; else { // 压缩路径，不断向上寻找最初的根节点 fa[x] = find(fa[x]); return fa[x]; } } // 合并，子节点依附在根节点上 void union(int i, int j){ int x= find(i); int y = find(j); fa[x] = y; } int main(){ int n, m, x, y, q; cin >> n >> m; init(n); for (int i = 1; i <= m; i++){ cin >> x >> y; union(x, y); // 构建依附关系 } scanf(\\\"%d\\\", &q); for (int i = 1; i <= q; i++){ cin >> x >> y; // 询问是否存在依附关系 if (find(x) == find(y)) put(\\\"YES\\\"); else put(\\\"NO\\\"); } return 0; }\"]},\"66\":{\"h\":\"例二：洛谷 P3367 【模板】并查集\",\"t\":[\"find 的主要功能就是从某个节点向上遍历到根节点，其时间复杂度就是树的高度，我们可能习惯性地认为树的高度就是 logN ， 但是不一定。logN 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得 “树” 几乎退化成 “链表'，树的高度最坏情况下可能变成 N。\",\"问题的关键在于，该如何想办法避免树的不平衡呢？\",\"其实关键在于 union 过程。\",\"我们其实是希望，高度小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些。\",\"解决方法是额外使用一个 size 数组，记录每棵树包含的节点数，不妨称为 高度。\",\"如下所示：\",\"void union(int i, int j){ int x = find(i), y = find(j); if (x == y) return; // 小树接在大树下面，较平衡 if (size[x] >= size[y]){ fa[y] = x; size[x] += size[y]; } else { fa[x] = y; size[y] += size[x]; } return; }\",\"下面看题中完整的写法（题是比较简单的一道模板题，用这种写法不过是略微优化了一下）:\",\"【题目描述】\",\"如题，现在有一个并查集，你需要完成合并和查询操作。\",\"【输入格式】\",\"第一行包含两个整数 N, M, 表示共有 N 个元素和 M 个操作。 接下来 M 行，每行包含三个整数 Zi​,Xi​,Yi​。 当 Zi​=1 时，将 Xi​ 与 Yi​ 所在的集合合并。 当 Zi​=2 时，输出 Xi​ 与 Yi​ 是否在同一集合内，是的输出 Y；否则输出 N。\",\"【输出格式】\",\"对于每一个 Zi​=2 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。\",\"【输入样例】\",\"4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4\",\"【输出样例】\",\"N Y N Y\",\"【示例代码】\",\"#include <iostream> #include <cstdio> using namespace std; const int N = 2e5+5; // 父亲数组，高度数组 int fa[N], size[N]; // 初始化 int init(int n) { for (int i = 1; i <= n; i++){ fa[i] = i; // 初始根节点为它自己 size[i] = 1; // 初始高度为1 } } // 查找父节点 int find(int x) { if (fa[x] == x) return x; else fa[x] = find(fa[x]); // 扁平化处理，压缩路径 return fa[x]; } // 合并 void union(int i, int j) { int x = find(i), y = find(j); if (x == y) return; // 比较高度，高度小的接在高的下面，节省查找时间 if (size[x] >= size[y]){ fa[y] = x; size[x] += size[y]; } else { fa[x] = y; size[y] += size[x]; } } int main() { int n, m, z, x, y; cin >> n >> m; init(n);//初始化 for (int i = 1; i <= m; i++){ cin >> z >> x >> y; if (z == 1) union(x, y); if (z == 2){ if (find(x) == find(y)) cout << \\\"Y\\\" << endl; else cout << \\\"N\\\" << endl; } } return 0; }\"]},\"67\":{\"c\":[\"笔记\"]},\"68\":{\"c\":[\"ACM\",\"并查集\"]},\"69\":{\"h\":\"搜索\"},\"70\":{\"h\":\"（BFS）\"},\"71\":{\"h\":\"题目描述\",\"t\":[\"给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1 ，其中 0 表示可以走的路，1 表示不可通过的墙壁。 最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。 数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。\",\"输入格式\",\"第一行包含两个整数 n 和 m。 接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。\",\"输出格式\",\"输出一个整数，表示从左上角移动至右下角的最少移动次数。\",\"数据范围\",\"1⩽n,m⩽100\",\"输入样例：\",\"5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0\",\"输出样例：\",\"8\"]},\"72\":{\"h\":\"思路\"},\"73\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #define PII pair<int, int> using namespace std; const int N = 110; int n, m; int g[N][N]; int d[N][N]; int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; int bfs() { memset(d, -1, sizeof d); queue<PII> q; q.push({1, 1}); d[1][1] = 0; while (q.size()) { auto t = q.front(); q.pop(); for (int i = 0; i < 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x >= 1 && x <= n && y >= 1 && y <= m && g[x][y] == 0 && d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x, y}); } } } return d[n][m]; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; cout << bfs() << endl; return 0; }\"]},\"74\":{\"h\":\"（BFS）\"},\"75\":{\"h\":\"题目描述\",\"t\":[\"在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3 的网格中。\",\"例如：\",\"1 2 3 x 4 6 7 5 8\",\"在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。\",\"我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：\",\"1 2 3 4 5 6 7 8 x\",\"例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。\",\"交换过程如下：\",\"1 2 3 1 2 3 1 2 3 1 2 3 x 4 6 4 x 6 4 5 6 4 5 6 7 5 8 7 5 8 7 x 8 7 8 x\",\"现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。\",\"输入格式\",\"输入占一行，将 3×3 的初始网格描绘出来。\",\"例如，如果初始网格如下所示：\",\"1 2 3 x 4 6 7 5 8\",\"则输入为：1 2 3 x 4 6 7 5 8\",\"输出格式\",\"输出占一行，包含一个整数，表示最少交换次数。\",\"如果不存在解决方案，则输出 −1。\",\"输入样例：\",\"2 3 4 1 5 x 7 6 8\",\"输出样例\",\"19\"]},\"76\":{\"h\":\"思路\"},\"77\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #include <unordered_map> using namespace std; int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; int bfs(string a) { string b = \\\"12345678x\\\"; queue<string> q; // 存储变换后的字符串 unordered_map<string, int> d; // 表示变换到某个字符串时需要的交换次数 q.push(a); d[a] = 0; while (!q.empty()) { auto t = q.front(); q.pop(); int dist = d[t]; // 判断是否变成了目标串 if (t == b) return dist; // 状态转移，变换串 int k = t.find('x'); // 'x'在字符串中的位置 int x = k / 3, y = k % 3; // 'x'在网格中的位置 for (int i = 0; i < 4; i++) { int xx = x + dx[i], yy = y + dy[i]; if (xx >= 0 && xx < 3 && yy >= 0 && yy < 3) { swap(t[k], t[xx * 3 + yy]); // 交换位置 if (!d.count(t)) { d[t] = dist + 1; q.push(t); } swap(t[k], t[xx * 3 + yy]); // 还原，恢复现场 } } } // 找不到解决方案则输出-1 return -1; } int main() { string a; // 将a串变为b串 for (int i = 0; i < 9; i++) { char c; cin >> c; a += c; } cout << bfs(a) << endl; return 0; }\"]},\"78\":{\"h\":\"\"},\"79\":{\"h\":\"题目描述\",\"t\":[\"你有一张某海域 N×N 像素的照片，\\\".\\\" 表示海洋、\\\"#\\\" 表示陆地，如下所示：\",\"....... .##.... .##.... ....##. ..####. ...###. .......\",\"其中 “上下左右” 四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2 座岛屿。 由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。 具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。 例如上图中的海域未来会变成如下样子：\",\"....... ....... ....... ....... ....#.. ....... .......\",\"请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。\",\"输入格式\",\"第一行包含一个整数 N。 以下 N 行 N 列，包含一个由字符 \\\"#\\\" 和 \\\".\\\" 构成的 N×N 字符矩阵，代表一张海域照片，\\\"#\\\" 表示陆地，\\\".\\\" 表示海洋。 照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。\",\"输出格式\",\"一个整数表示答案。\",\"数据范围\",\"1⩽N⩽1000\",\"输入样例1：\",\"7 ....... .##.... .##.... ....##. ..####. ...###. .......\",\"输出样例1：\",\"1\",\"输入样例2：\",\"9 ......... .##.##... .#####... .##.##... ......... .##.#.... .#.###... .#..#.... .........\",\"输出样例2：\",\"1\"]},\"80\":{\"h\":\"思路\"},\"81\":{\"h\":\"代码\"},\"82\":{\"h\":\"（DFS）\"},\"83\":{\"h\":\"题目描述\",\"t\":[\"给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。\",\"现在，请你按照字典序将所有的排列方法输出。\",\"输入格式\",\"共一行，包含一个整数 n。\",\"输出格式\",\"按字典序输出所有排列方案，每个方案占一行。\",\"数据范围\",\"1⩽n⩽7\",\"输入样例：\",\"3\",\"输出样例：\",\"1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1\"]},\"84\":{\"h\":\"思路\"},\"85\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 10; int n; int path[N]; bool st[N]; void dfs(int u) { if (u == n){ for (int i = 0; i < n; i++){ printf(\\\"%d \\\", path[i]); } puts(\\\"\\\"); return; } for (int i = 1; i <= n; i++){ if (!st[i]) { path[u] = i; st[i] = true; dfs(u + 1); st[i] = false; } } } int main() { cin >> n; dfs(0); return 0; }\"]},\"86\":{\"h\":\"4.\"},\"87\":{\"h\":\"5.\"},\"88\":{\"c\":[\"笔记\"]},\"89\":{\"c\":[\"ACM\",\"搜索\",\"BFS\",\"DFS\"]},\"90\":{\"h\":\"递归相关题型\"},\"91\":{\"h\":\"\"},\"92\":{\"h\":\"题目描述\",\"t\":[\"从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。\",\"输入格式\",\"输入一个整数 n。\",\"输出格式\",\"每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。\",\"数据范围\",\"1⩽n⩽15\",\"输入样例：\",\"3\",\"输出样例：\",\"3 2 2 3 1 1 3 1 2 1 2 3\"]},\"93\":{\"h\":\"思路\"},\"94\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n; int st[N]; // 0表示还没考虑，1表示已选，2表示未选 void dfs(int u) { if (u == n) { for (int i = 0; i < n; i++) if (st[i] == 1) cout << i + 1 << ' '; cout << endl; return; } st[u] = 2; dfs(u + 1); st[u] = 0; st[u] = 1; dfs(u + 1); st[u] = 0; } int main() { cin >> n; dfs(0); return 0; }\"]},\"95\":{\"h\":\"\"},\"96\":{\"h\":\"题目描述\",\"t\":[\"把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。\",\"输入格式\",\"一个整数 n。\",\"输出格式\",\"按照从小到大的顺序输出所有方案，每行 1 个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。\",\"数据范围\",\"1⩽n⩽9\",\"输入样例：\",\"3\",\"输出样例：\",\"1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1\"]},\"97\":{\"h\":\"思路\"},\"98\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 10; int n; int st[N]; // 0表示还没放数，1~n表示放的哪些数 bool vis[N]; // 标记是否使用过 void dfs(int u) { if (u > n) { for (int i = 1; i <= n; i++) // 输出方案 cout << st[i] << ' '; puts(\\\"\\\"); return; } // 依次枚举每个分支，即当前位置能填哪些数 for (int i = 1; i <= n; i++){ if (!vis[i]){ st[u] = i; vis[i] = true; dfs(u + 1); // 恢复现场 st[u] = 0; vis[i] = false; } } } int main() { cin >> n; dfs(1); return 0; }\"]},\"99\":{\"h\":\"\"},\"100\":{\"h\":\"题目描述\",\"t\":[\"从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。\",\"输入格式\",\"两个整数 n,m，在同一行用空格隔开。\",\"输出格式\",\"按照从小到大的顺序输出所有方案，每行 1 个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。\",\"数据范围\",\"n>0 , 0⩽m⩽n , n+(n−m)⩽25\",\"输入样例：\",\"5 3\",\"输出样例：\",\"1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5\"]},\"101\":{\"h\":\"思路\"},\"102\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 30; int n, m; int way[N]; void dfs(int u, int start) // u表示第几位，i表示从哪个数开始 { if (u + n - start < m) return; // 剪枝，若剩下可选的数字不能填满剩下的空位则回退 if (u > m) { for (int i = 1; i <= m; i++) cout << way[i] << ' '; puts(\\\"\\\"); return; } for (int i = start; i <= n; i++) // 从start开始枚举剩下的可选数字 { way[u] = i; dfs(u + 1, i + 1); way[u] = 0; // 恢复现场 } } int main() { cin >> n >> m; dfs(1, 1); return 0; }\"]},\"103\":{\"h\":\"\"},\"104\":{\"h\":\"题目描述\",\"t\":[\"翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。 经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕>_<）。 翰翰和达达只好花钱让它们坐索道下山。 索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1​、C2​……CN​。 当然，每辆缆车上的小猫的重量之和不能超过 W。 每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？\",\"输入格式\",\"第 1 行：包含两个用空格隔开的整数，N 和 W。 第 2∼N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci​。\",\"输出格式\",\"输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。\",\"数据范围\",\"1⩽N⩽18 , 1⩽Ci​⩽W⩽108\",\"输入样例：\",\"5 1996 1 2 1994 12 29\",\"输出样例：\",\"2\"]},\"105\":{\"h\":\"思路\"},\"106\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n, m; int c[N]; // 每只猫的重量 int s[N]; // 每辆车所搭载的重量 int res = N; // 初始最坏情况下一只猫一辆车 void dfs(int u, int k) // u只猫，k辆车 { if (k >= res) return; if (u == n){ res = k; return; } for (int i = 0; i < k; i++) // 对每辆车进行枚举 { if (s[i] + c[u] <= m) // 若不超过最大载重 { s[i] += c[u]; dfs(u + 1, k); s[i] -= c[u]; } } // 否则需要再加一辆车 s[k] = c[u]; dfs(u + 1, k + 1); s[k] = 0; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> c[i]; sort(c, c + n, greater()); dfs(0, 0); // 0只猫，0辆车 cout << res << endl; return 0; }\"]},\"107\":{\"h\":\"\"},\"108\":{\"h\":\"题目描述\",\"t\":[\"100 可以表示为带分数的形式：100=3+71469258​\",\"还可以表示为：100=82+1973546​\",\"注意特征：带分数中，数字 1∼9 分别出现且只出现一次（不包含 0）。\",\"类似这样的带分数，100 有 11 种表示法。\",\"输入格式\",\"一个正整数。\",\"输出格式\",\"输出输入数字用数码 1∼9 不重复不遗漏地组成带分数表示的全部种数。\",\"数据范围\",\"1⩽N<106\",\"输入样例1：\",\"100\",\"输出样例1：\",\"11\",\"输入样例2：\",\"105\",\"输出样例2：\",\"6\"]},\"109\":{\"h\":\"思路\",\"t\":[\"题目意思是说，用 1∼9 的 9 个数，构造成一个整数和一个分数，每个数都要用到且只出现一次，分数不考虑约分的情况。可以理解为，构造成 n=a+cb​ 的形式，要求将 9 个数划分给 a,b,c 三个数，9​ 个数必须不重不漏。\",\"步骤：\",\"枚举全排列\",\"枚举位数，a,b,c 三个数的位数可能都不一样\",\"将 a,b,c 转化为数字，带入等式中看是否成立\",\"将 n=a+cb​ 转化为 cn=ca+b ，只需要枚举 a 和 c 即可，最后判断 b=cn−ca 是否成立。从 a 开递递归枚举，每次递归的同时也对 c 枚举，然后每次都 check(a,c) 是否满足条件，若满足则答案 +1 。\"]},\"110\":{\"h\":\"代码\",\"t\":[\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n; bool st[N], backup[N]; int ans; bool check(int a, int c) { int b = c * n - c * a; if (!a || !b || !c) return false; memcpy(backup, st, sizeof st); // 备份 while (b) { int x = b % 10; // 取出b的每一位 b /= 10; if (!x || backup[x]) // 判断每一位上的数字是否用过 return false; // 用过则不合法 backup[x] = true; // 没用过则标记 } for (int i = 1; i <= 9; i++) if (!backup[i]) // 如果有一位没用上，则不合法 return false; return true; } void dfs_c(int u, int a, int c) { if (u >= n) return; // 判断当前a和c是否满足条件，若满足则答案+1 if (check(a, c)) ans++; // 继续枚举 for (int i = 1; i <= 9; i++){ if (!st[i]) { st[i] = true; dfs_c(u + 1, a, c * 10 + i); // a不变，更新c st[i] = false; } } } void dfs_a(int u, int a) { if (u >= n) return; // 对a提前判断一下，能更快一点点 if (a) dfs_c(u, a, 0); // 枚举c：用了几个数，a是几，当前加入的数字是几 for (int i = 1; i <= 9; i++){ if (!st[i]) { st[i] = true; dfs_a(u + 1, a * 10 + i); // 用的数字个数+1，加入i后更新当前a的值 st[i] = false; } } } int main() { cin >> n; dfs_a(0, 0); // 枚举a：用了几个数，当前的值 cout << ans << endl; return 0; }\"]},\"111\":{\"c\":[\"笔记\"]},\"112\":{\"c\":[\"ACM\",\"递归\"]},\"113\":{\"h\":\"动态规划\"},\"114\":{\"h\":\"1. 背包问题\",\"t\":[\"背包问题常用枚举方法\",\"第一维枚举物品\",\"第二维枚举体积\",\"第三维枚举决策\"]},\"115\":{\"h\":\"1.1 01 背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用一次。\",\"求所选物品的总体积不超过背包容量的条件下，最大的总价值。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++){ for (int j = 0; j <= m; j++){ f[i][j] = f[i - 1][j]; //左半边的子集 if (v[i] <= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } cout << f[n][m] << endl; */ //一维 //f[i] 表示总体积是i的情况下，最大价值是多少 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\"]},\"116\":{\"h\":\"1.2 完全背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用无限次。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1100; int n, m; int v[N], w[N]; int f[N]; //表示总体积是i的情况下，最大价值是多少 int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++) for (int j = 0; j <= m; j++) { f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout << f[n][m] << endl; */ //一维 for (int i = 1; i <= n; i++) for (int j = v[i]; j <= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout << f[m] << endl; return 0; }\"]},\"117\":{\"h\":\"1.3 多重背包\",\"t\":[\"有 n 件物品，背包容量为 m，每件物品有有限个。\",\"数据范围 ≤100 的写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); cout << f[n][m] << endl; /* 一维优化写法 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[j] = max(f[j], f[j - k * v[i]] + w[i] * k); } } cout << f[m] << endl; */ return 0; }\",\"数据范围较大时，需要用多重背包的二进制优化方法：\",\"第一种写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; int f[M]; int main() { cin >> n >> m; int cnt = 0; for (int i = 1; i <= n; i++){ int a, b, s; cin >> a >> b >> s; int k = 1; while (k < s){ cnt++; v[cnt] += a * k; w[cnt] += b * k; s -= k; k *= 2; } if (s){ cnt++; v[cnt] += a * s; w[cnt] += b * s; } } n = cnt; for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\",\"第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <vector> using namespace std; const int N = 2010; int n, m; int f[N]; struct Good { int v, w; }; int main() { vector<Good> goods; cin >> n >> m; for (int i = 0; i < n; i++){ int v, w, s; cin >> v >> w >> s; for (int k = 1; k <= s; k *= 2){ s -= k; goods.push_back({v * k, w * k}); } if (s > 0) goods.push_back({v * s, w * s}); } for (auto good : goods){ for (int j = m; j >= good.v; j--){ f[j] = max(f[j], f[j - good.v] + good.w); } } cout << f[m] << endl; return 0; }\"]},\"118\":{\"h\":\"1.4 分组背包\",\"t\":[\"有 n 组物品和一个容量是 m 的背包。\",\"每组物品有若干个，同一组内的物品最多只能选一个。\",\"求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\",\"（一）第一种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++){ cin >> s[i]; for (int j = 0; j < s[i]; j++){ cin >> v[i][j] >> w[i][j]; } } for (int i = 1; i <= n; i++){ for (int j = m; j >= 0; j--){ for (int k = 0; k < s[i]; k++){ if (v[i][k] <= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } } cout << f[m] << endl; return 0; }\",\"（二）第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int f[N], v[N], w[N]; int main() { cin >> n >> m; for (int i = 0; i < n; i++) { int s; cin >> s; for (int j = 0; j < s; j++) cin >> v[j] >> w[j]; for (int j = m; j >= 0; j--) for (int k = 0; k < s; k++) if (j >= v[k]) f[j] = max(f[j], f[j - v[k]] + w[k]); } cout << f[m] << endl; return 0; }\"]},\"119\":{\"h\":\"2. 线性DP\"},\"120\":{\"h\":\"2.1 数字三角形\",\"t\":[\"给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。\",\" 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5\",\"线性DP写法：\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 510, INF = 1e9; int n; int a[N][N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= i; j++) cin >> a[i][j]; for (int i = 0; i <= n; i++) for (int j = 0; j <= i + 1; j++) f[i][j] = -INF; //从上往下遍历 f[1][1] = a[1][1]; for (int i = 2; i <= n; i++) for (int j = 1; j <= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; // 状态转移方程 int ans = -INF; for (int i = 1; i <= n; i++) ans = max(ans, f[n][i]); cout << ans << endl; /*从下往上遍历 for (int i = n; i >= 1; i--) for (int j = n; j >= 1; j--) f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; cout << f[1][1] << endl; */ return 0; }\"]},\"121\":{\"h\":\"2.2 最长上升子序列\",\"t\":[\"求一个序列中严格递增的子序列的最大长度。\",\"（一）朴素DP写法：\",\"状态转移方程：if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1010; int n; int a[N]; int f[N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) { f[i] = 1; // 只有a[1]一个数 for (int j = 1; j <= i; j++) if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1); } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f[i]); cout << ans << endl; return 0; }\",\"（二）二分写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 100010; int n; int q[N]; int a[N]; int main() { cin >> n; for (int i = 0; i < n; i++) cin >> a[i]; int len = 0; q[0] = -2e9; for (int i = 0; i < n; i++) { int l = 0, r = len; while (l < r) { int mid = l + r + 1 >> 1; if (q[mid] < a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } cout << len << endl; return 0; }\",\"（三）单调队列写法：\",\"#include <iostream> #include <cstdio> #include <vector> #include <algorithm> using namespace std; const int N = 100010; int n; int main() { cin >> n; vector<int> arr(n); for (int i = 0; i < n; i++) cin >> arr[i]; vector<int> stk; //模拟堆栈 stk.push_back(arr[0]); for (int i = 1; i < n; i++) //单调队列思维 { if (arr[i] > stk.back()) //如果该元素大于栈顶元素，则将该元素入栈 stk.push_back(arr[i]); else //否则，替换掉第一个大于或等于这个数字的那个数 *lower_bound(stk.begin(), stk.end(), arr[i]) = arr[i]; } cout << stk.size() << endl; return 0; }\"]},\"122\":{\"h\":\"2.3 最长公共子序列（不连续）\",\"t\":[\"给定两个长度分别为 n 和 m 的字符串 A 和 B，\",\"求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\",\"状态转移方程：\",\"f[i][j] = max(f[i-1][j], f[i][j-1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin >> n >> m >> a + 1 >> b + 1; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"123\":{\"h\":\"2.4 最长公共上升子序列\",\"t\":[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\",\"小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\",\"小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。\",\"奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\",\"不过，只要告诉奶牛它的长度就可以了。\",\"数列 A 和 B 的长度均不超过 3000。\",\"输入格式\",\"第一行包含一个整数 N，表示数列 A,B 的长度。 第二行包含 N 个整数，表示数列 A。 第三行包含 N 个整数，表示数列 B。\",\"输出格式\",\"输出一个整数，表示最长公共上升子序列的长度。\",\"数据范围\",\"1≤N≤3000 , 序列中的数字均不超过 231−1 。\",\"输入样例：\",\"4 2 2 1 3 2 1 2 3\",\"输出样例：\",\"2\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 3010; int n; int a[N], b[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; for (int i = 1; i <= n; i++){ int mx = 1; for (int j = 1; j <= n; j++){ f[i][j] = f[i - 1][j]; if (a[i] == b[j]) f[i][j] = max(f[i][j], mx); if (a[i] > b[j]) mx = max(mx, f[i - 1][j] + 1); } } int res = 0; for (int i = 1; i <= n; i++) res = max(res, f[n][i]); cout << res << endl; return 0; }\"]},\"124\":{\"h\":\"2.5 编辑距离\",\"t\":[\"给定 n 个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。\",\"对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。\",\"每个对字符串进行的单个字符的插入、删除或替换算作一次操作。\",\"输入格式\",\"第一行包含两个整数 n 和 m。 接下来 n 行，每行包含一个字符串，表示给定的字符串。 再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。 字符串中只包含小写字母，且长度均不超过 10。\",\"输出格式\",\"输出共 m​ 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。\",\"模板代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 15, M = 1010; int n, m; int f[N][N]; char str[M][N]; int edit_distance(char a[], char b[]) { int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i <= la; i++) f[i][0] = i; for (int j = 0; j <= lb; j++) f[0][j] = j; for (int i = 1; i <= la; i++) for (int j = 1; j <= lb; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } return f[la][lb]; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> str[i] + 1; //下标从1开始存 while (m--){ char s[N]; int limit; cin >> s + 1 >> limit; int res = 0; for (int i = 0; i < n; i++) if (edit_distance(str[i], s) <= limit) res++; cout << res << endl; } return 0; }\"]},\"125\":{\"h\":\"2.6 最短编辑距离\",\"t\":[\"给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：\",\"删除 – 将字符串 A 中的某个字符删除。\",\"插入 – 在字符串 A 的某个位置插入某个字符。\",\"替换 – 将字符串 A 中的某个字符替换为另一个字符。\",\"现在请你求出，将 A 变为 B​ 至少需要进行多少次操作。\",\"状态转移方程：\",\"f[i][j] = min(f[i-1][j] + 1, f[i][j-1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i-1][j-1]); else f[i][j] = min(f[i][j], f[i-1][j-1] + 1); //状态转移方程\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; //所有将a[i]变成b[j]的操作方式 int main() { cin >> n >> a + 1; cin >> m >> b + 1; for (int i = 0; i <= n; i++) f[i][0] = i; for (int j = 0; j <= m; j++) f[0][j] = j; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"126\":{\"h\":\"3. 区间DP\",\"t\":[\"区间 DP 常用模版\",\"所有的区间 dp 问题枚举时，\",\"第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；\",\"第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）\",\"模板代码如下：\",\"for (int len = 1; len <= n; len++) { // 区间长度 for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点 int j = i + len - 1; // 区间终点 if (len == 1) { dp[i][j] = 初始值 continue; } for (int k = i; k < j; k++) { // 枚举分割点，构造状态转移方程 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); } } }\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 310; int n; int a[N], s[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> a[i]; s[i] = s[i - 1] + a[i]; } //区间DP枚举套路：长度+左端点 for (int len = 2; len <= n; len++) //先枚举长度 { for (int i = 1; i + len - 1 <= n; i++) //再枚举左端点，且保证右端点不会超范围 { int j = i + len - 1; //自动得到右端点 f[i][j] = 1e9; //初始化大于1的区间为最大，长度为1的区间为0 for (int k = i; k <= j - 1; k++) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]); } } //得到总区间的最小代价 cout << f[1][n] << endl; return 0; }\"]},\"127\":{\"h\":\"4. 计数类DP\",\"t\":[\"一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。\",\"表示前 i 个整数（1,2…,i）恰好拼成 j 的方案数 求方案数：把集合选 0 个 i，1 个 i，2 个 i，…全部加起来\",\"f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"因此 f[i][j]=f[i−1][j]+f[i][j−i] （这一步类似完全背包的推导）\",\"朴素做法：\",\"// f[i][j] = f[i - 1][j] + f[i][j - i] #include <iostream> using namespace std; const int N = 1e3 + 7, mod = 1e9 + 7; int f[N][N]; int main() { int n; cin >> n; for (int i = 0; i <= n; i ++) { f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 } for (int i = 1; i <= n; i ++) { for (int j = 0; j <= n; j ++) { f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1 if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod; } } cout << f[n][n] << endl; }\",\"一维优化：\",\" f[0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 for (int i = 1; i <= n; i ++) { for (int j = i; j <= n; j ++) { f[j] = (f[j] + f[j - i]) % mod; } } cout << f[n] << endl;\"]},\"128\":{\"h\":\"5. 数位统计类DP\",\"t\":[\"给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0 ~ 9 的出现次数。\",\"#include <bits/stdc++.h> using namespace std; int base[10]; int f[10][10]; int g[10][10]; void init() { base[0] = 1; for(int i = 1 ; i <= 9 ; i++) base[i] = base[i-1]*10; //从00……0 - 99……9 的各位数字有多少个，其中i为数字个数（包含前导零） for(int i = 0 ; i <= 9 ; i++) f[1][i] = 1; for(int i = 2 ; i <= 9 ; i++) for(int j = 0 ; j <= 9 ; j++) f[i][j] = f[i-1][j]*10 + base[i-1]; //从1 - 99……9 的各位数字有多少个，其中i为数字个数（不包含前导零） for(int i = 1 ; i <= 9 ; i++) g[1][i] = 1;//循环从1开始 for(int i = 2 ; i <= 9 ; i++) { g[i][0] = g[i-1][0] + f[i-1][0]*9; for(int j = 1 ; j <= 9 ; j++) g[i][j] = g[i-1][j] + f[i-1][j]*9 + base[i-1]; } } vector<int> dp(int n) { vector<int> ans(10,0); //记录答案 if(n<=0) return ans; //边界条件 vector<int> nums; while(n) nums.push_back(n%10), n/=10; vector<int> last(10,0); //记录前缀中各个数字个数 //统计1 - 99……9(n-1个9)里面各个数字有多少个 for(int i = 0 ; i <= 9 ; i++) ans[i] = g[nums.size()-1][i]; //统计大于10……0(n-1个0) 的树里各个数字有多少个 for(int i = nums.size()-1 ; i >=0 ; i--) { //循环变量i可以表示剩下的数字有多少个 int x = nums[i]; for(int j = i==nums.size()-1 ; j < x ; j++) { //第一次循环不能有0 //前缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k] * base[i]; //当前位置部分 ans[j] += base[i]; //后缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += f[i][k]; } //更新前缀计数器 last[x] ++; //统计叶子节点（这个数本身） if(!i) for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k]; } return ans; } vector<int> ask(int a, int b) { auto x = dp(b); auto y = dp(a-1); vector<int> ans; for(int i = 0 ; i <= 9 ; i++) ans.push_back(x[i]-y[i]); return ans; } void print(vector<int> ans) { for(auto x:ans) printf(\\\"%d \\\",x); puts(\\\"\\\"); } bool check(int x) { auto t = ask(x,x); vector<int> cnt(10,0); while(x) cnt[x%10]++,x/=10; for(int i = 0 ; i <= 9 ; i++) if(cnt[i] != t[i]) return false; return true; } int main() { init(); int a,b; while(cin >> a >> b, a||b) { if(a>b) swap(a,b); auto t = ask(a,b); print(t); } return 0; }\"]},\"129\":{\"h\":\"6. 状态压缩类DP\"},\"130\":{\"h\":\"6.1 蒙德里安的梦想\",\"t\":[\"n×m 的棋盘可以摆放不同的 1×2 小方格的种类数。\",\"状态表示：f[i][j] 表示当前摆到第 i 列的状态是 j 的所有方案。\",\"(其中 j 是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。)\",\"去除无效状态的优化写法：\",\"#include <cstring> #include <iostream> #include <algorithm> #include <vector> using namespace std; typedef long long LL; const int N = 12, M = 1 << N; int n, m; LL f[N][M]; vector<int> state[M]; bool st[M]; int main() { while (cin >> n >> m, n || m) { for (int i = 0; i < 1 << n; i ++ ) { int cnt = 0; bool is_valid = true; for (int j = 0; j < n; j ++ ) if (i >> j & 1) { if (cnt & 1) { is_valid = false; break; } cnt = 0; } else cnt++; if (cnt & 1) is_valid = false; st[i] = is_valid; } for (int i = 0; i < 1 << n; i ++ ) { state[i].clear(); for (int j = 0; j < 1 << n; j ++ ) if ((i & j) == 0 && st[i | j]) state[i].push_back(j); } memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i <= m; i ++ ) for (int j = 0; j < 1 << n; j ++ ) for (auto k : state[j]) f[i][j] += f[i - 1][k]; cout << f[m][0] << endl; } return 0; }\"]},\"131\":{\"h\":\"6.2 最短Hamilton路径\",\"t\":[\"给定一张 n 个点的带权无向图，点从 0 ~ n−1 标号，求起点 0 到终点 n−1 的最短Hamilton路径。\",\"Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。\",\"f[i][j] 表示从 0 走到 j ，走过的所有点的情况是 i 的所有路径。\",\"状态转移方程：f[i][j] = min(f[i][j], f[i-(1<<j)][k] + w[k][j]);\",\"#include<iostream> #include<cstring> #include<algorithm> using namespace std; const int N = 20, M = 1 << N; int n; int f[M][N], w[N][N];//w表示的是无权图 int main() { cin>>n; for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) cin >> w[i][j]; memset(f, 0x3f, sizeof(f)); // 因为要求最小值，所以初始化为无穷大 f[1][0] = 0; // 因为零是起点,所以f[1][0]=0; for (int i = 0; i < 1 << n; i++) // i表示所有的情况 for (int j = 0; j < n; j++) // j表示走到哪一个点 if (i >> j & 1) for (int k = 0; k < n; k++) // k表示走到j这个点之前,以k为终点的最短距离 if (i >> k & 1) // 更新最短距离 f[i][j] = min(f[i][j], f[i - (1<<j)][k] + w[k][j]); // 表示所有点都走过了,且终点是n-1的最短距离 cout << f[(1<<n) - 1][n - 1] << endl; return 0; }\"]},\"132\":{\"h\":\"7. 树形DP\"},\"133\":{\"h\":\"7.1 没有上司的舞会\",\"t\":[\"选了某个节点就不能选父节点和子节点。求最大权值和。\",\"每个人只有两种状态，则设 dp[0][i] 为第 i 个人不来，他的下属所能获得的最大快乐值；\",\"dp[1][i] 为第 i 个人来，他的下属所能获得的最大快乐值。\",\"状态转移方程：\",\"dp[0][i]=∑u=sons​max(dp[1][u],dp[0][u]) 当前节点不选，那么子节点随意\",\"dp[1][i]=∑u=sons​dp[0][u]+happy[i] 当前节点选，子节点不能选\",\"#include <bit/stdc++.h> using namespace std; int n; int dp[2][6010]; int f[2][6010]; // f[0]为父亲，f[1]为高兴值 int ind[6010]; // 入度 int vis[6010]; // 访问标记 int root; // 树的根 void dfs(int u) // 递归从后往前更新 { if (!u) return; vis[u] = 1; // 已访问 root = u; // 最后一个访问到的一定是根，所以一直更新根就行了 dp[0][f[0][u]] += max(dp[1][u] + f[1][u], dp[0][u]); // 给父亲更新 dp[1][f[0][u]] += dp[0][u]; ind[f[0][u]]--; // 更新完一个子节点 if(!ind[f[0][u]]) dfs(f[0][u]); // 在所有子节点更新后再更新（入度为0） } int main() { cin >> n; for (int i = 1; i <= n; i++) scanf(\\\"%d\\\", &f[1][i]); int a,b; for (int i = 1; i < n; i++){ scanf(\\\"%d%d\\\", &a, &b); f[0][a] = b; // 保存节点信息 ind[b]++; } for (int i = 1; i <= n; i++) if(!vis[i] && !ind[i]) // 没有被访问过，没有入度，说明是叶子节点 dfs(i); // 取根节点两种方案的最大值 printf(\\\"%d\\\\n\\\", max(dp[0][root], dp[1][root] + f[1][root])); return 0; }\"]},\"134\":{\"c\":[\"algorithm\"]},\"135\":{\"c\":[\"ACM\"]},\"136\":{\"h\":\"基础算法\"},\"137\":{\"h\":\"1. 快速排序\",\"t\":[\"快排属于分治算法，分治算法都有三步：\",\"分成子问题\",\"递归处理子问题\",\"子问题合并\",\"主要步骤：\",\"确定分界点，可以任选 a[l]，a[r]，a[(l + r) / 2] 其中一个作为分界点。\",\"设置两个头尾指针 i, j，初始化 i = l - 1, j = r + 1 (避免发生边界问题导致死循环) ，向中间移动。每次循环都先将 i 右移和 j 左移，然后判断，如果 a[i] > a[j] 且 i < j，就交换 a[i] 和 a[j].\",\"最后根据分界点分别递归左右两部分。\",\"快排的一般写法如下：\",\"void quick_sort(int q[], int l, int r) { //递归的终止情况 if(l >= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[(l + r) / 2]; while(i < j) { do i++; while(q[i] < x); do j--; while(q[j] > x); if(i < j) swap(q[i], q[j]); } //第二步：递归处理子问题 quick_sort(q, l, j); quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤 }\"]},\"138\":{\"h\":\"2. 归并排序\",\"t\":[\"运用双指针的思想，先递归再合并。\",\"主要步骤：\",\"确定分界点。与快排不同，归并每次都将中点作为分界点，将整个序列均分为两部分。mid = (l + r) / 2\",\"递归排序。对两个子序列分别设置个指针 i, j，从头开始遍历，每次比较 a[i] 和 a[j]，将小的放入一个临时序列 temp[] 中。如果有一部分遍历完了，而另一部分还有剩余，则将剩余那一部分直接接在临时序列的后面，因为剩下的这部分一定是大于前面的。\",\"归并，合二为一。将临时序列放入原序列中。\",\"归并的一般写法如下：\",\"void merge_sort(int a[], int l, int r) { if (l >= r) return; //确定中间分界点 int mid = (l + r) >> 1; //两边递归 merge_sort(a, l, mid); merge_sort(a, mid + 1, r); int k = 0; int i = l, j = mid + 1; //比较左右两半边 while (i <= mid && j <= r) if (a[i] < a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; while (i <= mid)//左半边剩下的 temp[k++] = a[i++]; while (j <= r)//右半边剩下的 temp[k++] = a[j++]; //合并区间 for (i = l, j = 0; i <= r; i++, j++) a[i] = temp[j]; }\"]},\"139\":{\"h\":\"3. 二分算法\"},\"140\":{\"h\":\"3.1 二分查找算法模板\",\"t\":[\"二分模板一共有两个，分别适用于不同情况。\",\"算法思路：假设目标值在闭区间 [l, r]中， 每次将区间长度缩小一半，当 l = r时，我们就找到了目标值。\"]},\"141\":{\"h\":\"版本1\",\"t\":[\"当我们将区间 [l, r]划分成 [l, mid] 和 [mid + 1, r] 时，其更新操作是 r = mid 或者 l = mid + 1; ，计算 mid 时不需要加 1。\",\"C++代码模板：\",\"int bsearch_1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (a[mid] >= x) r = mid; //答案在左边界，要向下取整 else l = mid + 1; //找左端点 } return l; }\"]},\"142\":{\"h\":\"版本2\",\"t\":[\"当我们将区间 [l, r] 划分成 [l, mid - 1] 和 [mid, r] 时，其更新操作是 r = mid - 1 或者 l = mid; ，此时为了防止死循环，计算 mid 时需要加 1。\",\"C++代码模板：\",\"int bsearch_2(int l, int r) { while (l < r) { int mid = l + r + 1 >> 1; if (a[mid] <= k) l = mid; //答案在右边界，要上取整 else r = mid - 1; //找右端点 } return l; }\",\"简单来说就是：\",\"可以将模板 1 中的 check[mid] 换成a[mid] >= x ，用来查找大于等于 x 的第一个元素；\",\"将模板 2 中的 check[mid] 换成 a[mid] <= x ，用来查找小于等于 x 的最后一个元素。\"]},\"143\":{\"h\":\"3.2 二分答案模板\",\"t\":[\"一般来说，二分答案可以用来处理 “最大的最小” 或 “最小的最大” 的问题。\",\"定义区间为闭区间 [l, r] ，每次只需判断答案是否需要更新（是否记下ans）和（可能的）答案在哪一侧（改 L 还是 R ）即可。\",\"int ans; int find(int l, int r) { while (l <= r) { int mid = l + r >> 1; if (check(mid)){ ans = mid; //如果条件成立则记下答案 r = mid - 1; //判断可能的答案更新区间 } else l = mid + 1; } return ans; }\"]},\"144\":{\"h\":\"3.3 整数二分\",\"t\":[\"【例二】A-B 数对\",\"题目描述：给出一串数以及一个数字 C ，要求计算出所有 A - B = C 的数对的个数（不同位置的数字一样的数对算不同的数对）。\",\"这里使用库函数二分的写法：\",\"依次枚举 A ，将问题转变成统计数列中 B + C 出现了多少次。先对数列排序，那么 B + C 会对应这个数列的连续一段，只要找到这个连续段的左端点和右端点即可。(需使用头文件 algorithm )\",\"① lower_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 第一次出现的位置；\",\"② upper_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 最后一次出现的位置的__后面一位__ 。\",\"则这个数出现的次数就可以表示为 upper_bound() - lower_bound() ，时间复杂度为 O(nlogn).\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; const int N = 2e5 + 10; int n, c; ll a[N]; int main() { cin >> n >> c; for (int i = 0; i < n; i++) cin >> a[i]; sort(a, a + n); ll tot = 0; for (int i = 0; i < n; i++) tot += upper_bound(a, a + n, a[i] + c) - lower_bound(a, a + n, a[i] + c); cout << tot << endl; return 0; }\"]},\"145\":{\"h\":\"3.4 浮点数二分\",\"t\":[\"bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l > eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; }\"]},\"146\":{\"h\":\"4. 高精度算法\"},\"147\":{\"h\":\"4.1 高精度加法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的和。 （C = A + B，A >= 0， B >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; const int N = 1e6 + 10; // C = A + B vector<int> add(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; int t = 0; //进位，低位满10向高位进位，低位变为0 for (int i = 0; i < A.size() || i < B.size(); i++){ //两个if把两个数组相同位上的数相加 if (i < A.size()) t += A[i]; if (i < B.size()) t += B[i]; //把相加后的结果除以10求余，压入C数组中 C.push_back(t % 10); //t再除以10，放入高位 t /= 10; } //如果最高位有数，则压入C数组中 if (t) C.push_back(t); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //使用auto编译器会自动判断数据是什么类型 auto C = add(A, B); for (int i = C.size() - 1; i >= 0; i--) printf(\\\"%d\\\", C[i]); return 0; }\"]},\"148\":{\"h\":\"4.2 高精度减法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的差，计算结果可能为负数。\",\"1、前提： C = A - B，满足 A >= B，A >= 0，B >= 0 （如果 B >= A，则将其转化为 -(B - A) ）\",\"2、代码段：(只考虑正数的情况)\",\"#include <iostream> #include <vector> using namespace std; //判断是否有 A >= B bool cmp(vector<int> &A, vector<int> &B) { //A长度不等于B，若A大于B，返回true，否则返回false if (A.size() != B.size()) return A.size() > B.size(); //因为是倒序数组，高位在后面，所以从后遍历 //如果A > B, 返回true，否则返回flase for (int i = A.size() - 1; i >= 0; i--){ if (A[i] != B[i]) return A[i] > B[i]; } return true; } // C = A - B vector<int> sub(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; //定义一个借位的情况 int t = 0; for (int i = 0; i < A.size(); i++){ //t = A的这一位数 t = A[i] - t; //判断B在这一位上有没有数，如果有，则减去B[i] if (i < B.size()) t -= B[i]; //这种写法包含了两种情况：如果t >= 0, 则直接减；若t < 0, 则向高位借位(即t + 10)后再减 //将这一位相减后的结果压入C中 C.push_back((t + 10) % 10); if (t < 0) //t < 0，需要借位，标记为1 t = 1; else //t >= 0，不需要借位，标记为0 t = 0; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //如果A > B，返回A - B if (cmp(A, B)){ auto C = sub(A, B); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", C[i]); } //否则返回 -(B - A) else { auto C = sub(B, A); printf(\\\"-\\\"); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", c[i]); } return 0; }\"]},\"149\":{\"h\":\"4.3 高精度整数乘法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A × B 的值\",\"一般是 高精 × 低精，用 A × b 表示 （C = A * b，A >= 0，b >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; //C = A * b vector<int> mul(vector<int> &A, int b) { vector<int> C; int t = 0; for (int i = 0; i < A.size() || t; i++) { if (i < A.size()) t += A[i] * b; //同加法一样处理进位，逐位压入数组中 C.push_back(t % 10); t /= 10; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int b; cin >> a >> b; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) //倒序插入 A.push_back(a[i] - '0'); auto C = mul(A, b); for (int i = C.size() - 1; i >= 0; i--) //倒序输出 printf(\\\"%d\\\", C[i]); return 0; }\"]},\"150\":{\"h\":\"4.4 高精度整数除法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A / B 的商和余数 (第一行输出所求的商，第二行输出所求余数)\",\"一般是 高精 ÷ 低精，用 A ÷ b 表示 （A / b = C ··· r，A >= 0，b > 0）\",\"代码如下：\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; vector<int> div(vector<int> &A, int b, int &t) //传入t的地址，便于直接对余数进行处理 { vector<int> C; t = 0; for (int i = A.size() - 1; i >= 0; i--) { //将上次的余数×10再加上当前位的数字，得到该位的被除数 t = t * 10 + A[i]; //所得即为商在这一位的数字 C.push_back(t / b); t %= b; } //由于在除法运算中，从高位到低位运算，因此前导0在数组前面，所以需要将其翻转，将前导0置于尾部，从而便于删除前导0 reverse(C.begin(), C.end()); //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int B; cin >> a >> B; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); int t; //t为余数 auto C = div(A, B, t); for (int i = C.size() - 1; i >= 0; i--) cout << C[i]; cout << endl << t << endl; return 0; }\"]},\"151\":{\"h\":\"5. 前缀和与差分\"},\"152\":{\"h\":\"5.1 一维前缀和\",\"t\":[\"S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1]\"]},\"153\":{\"h\":\"5.2 二维前缀和\",\"t\":[\"S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\"]},\"154\":{\"h\":\"5.3 一维差分\",\"t\":[\"给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\"]},\"155\":{\"h\":\"5.4 二维差分\",\"t\":[\"给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\"]},\"156\":{\"h\":\"6. 位运算\"},\"157\":{\"h\":\"6.1 位运算符\",\"t\":[\"位运算符作用于位，并逐位执行操作。\",\"符号\",\"描述\",\"运算规则\",\"&\",\"与\",\"两个位都为1时，结果才为1\",\"|\",\"或\",\"两个位都为0时，结果才为0\",\"^\",\"异或\",\"两个位相同为0，不同为1\",\"~\",\"取反\",\"0变1，1变0\",\"<<\",\"左移\",\"各二进位全部左移若干位，高位丢弃，低位补0\",\">>\",\"右移\",\"各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）\"]},\"158\":{\"h\":\"6.2 用途\",\"t\":[\"1、按位与 (&)\",\"运算规则（全为 1，才为1）\",\"0 & 0 = 0\",\"0 & 1 = 0\",\"1 & 0 = 0\",\"1 & 1 = 1\",\"注意：负数按补码形式参加按位与运算。\",\"（1）清零\",\"如果想将一个单元清零，使其全部二进制位为 0，只要__与一个各位都为零的数值相与__，结果为零。\",\"（2）取一个数的指定位\",\"比如取数 X = 1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位与运算（X & Y = 0000 1110）即可得到 X 的指定位。\",\"（3）判断奇偶\",\"只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a & 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。\",\"2、按位或 (|)\",\"运算规则（全为 0，才为 0）\",\"0 | 0 = 0\",\"0 | 1 = 1\",\"1 | 0 = 1\",\"1 | 1 = 1\",\"（1）常用来对一个数据的某些位设置为1\",\"比如将数 X = 1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位或运算（X | Y = 1010 1111）即可得到。\",\"3、按位异或 (^)\",\"运算规则（相同为 0，不同为 1）\",\"0 ^ 0 = 0\",\"0 ^ 1 = 1\",\"1 ^ 0 = 1\",\"1 ^ 1 = 0\",\"（1）翻转指定位\",\"比如将数 X = 1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行异或运算（X ^ Y = 1010 0001）即可得到。\",\"（2）与 0 相异或值不变\",\"例如：1010 1110 ^ 0000 0000 = 1010 1110\",\"（3）交换两个数\",\"当 x == y 时，直接异或运算进行整数交换后，会导致 x = 0, y = x.\",\"为避免这种情况，必须首先判断两个数是否相等。\",\"void swap(int &a, int &b){ if (a != b){ a ^= b; b ^= a; a ^= b; } }\",\"4、按位取反 (~)\",\"运算规则（0 变 1，1 变 0）\",\"~1 = 0\",\"~0 = 1\",\"（1）使一个数的最低位为 0\",\"使 x 的最低位为 0，可以表示为：a & ~1 。~1 的值为 1111 1111 1111 1110 ，再按 与 运算，最低位一定为 0。因为 ~ 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。\",\"5、左移 (<<)\",\"定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\",\"设 a = 1010 1110，a = a << 2 将 a 的二进制位 左移2位、右补0，即得 a = 1011 1000。\",\"若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2 。比如 左移 k 位，即乘上 2k .\",\"6、右移 (>>)\",\"定义：将一个数的各二进制位全部右移若干位，正数左补 0 ，负数左补 1 ，右边丢弃。\",\"例如：a = a >> 2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。\",\"操作数每右移一位，相当于该数除以 2。比如 右移 k 位，即除以 2k .\",\"bit_operation\"]},\"159\":{\"h\":\"6.3 例题\",\"t\":[\"【例题一】n 的二进制表示中第 k 位数\",\"思路：先把第 k 位数字移动到最后一位，n 右移 k 位，即 n >> k ，再看个位是几，用 n & 1 ，合并两步后，即 n >> k & 1 .\",\"例如求 10 的二进制表示，代码如下：\",\"#include <iostream> using namespace std; int main() { int n = 10; //10的二进制表示为4位数 for (int k = 3; k >= 0; k--) cout << (n >> k & 1); return 0; }\",\"输出如下：\",\"1010\",\"【例题二】二进制中1的个数\",\"给定一个长度为 1 的数列，请你求出数列中每个数的二进制表示中 1 的个数。\",\"输入格式\",\"第一行包含整数 n .\",\"第二行包含 n 个整数，表示整个数列\",\"输出格式\",\"共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。\",\"思路：使用 lowbit(x) 来解决，其表达式为 x & -x ，其中 -x 表示补码，即源码取反加 1 ，-x = (~x + 1)。 作用：返回 x 的最后一位 1，比如 x = 1010, 则 lowbit(x) = 10 ，x = 101000, 则 lowbit(x) = 1000 .\",\"代码如下：\",\"#include <iostream> using namespace std; const int N = 100010; int lowbit(int x) { return x & -x; } int main() { int n; cin >> n; while (n--){ int x; cin >> x; int res = 0; while (x){ x -= lowbit(x); res++; } cout << res << \\\" \\\"; } return 0; }\"]},\"160\":{\"h\":\"7. 双指针算法\",\"t\":[\"for (int i = 0, j = 0; i < n; i++) { while (j < i && check(i, j)) j++; // 具体问题的逻辑 // 例如求长度 res = max(res, i - j + 1); } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\"]},\"161\":{\"h\":\"8. 离散化\",\"t\":[\"vector<int> alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l < r) { int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n }\"]},\"162\":{\"h\":\"9. 区间合并\",\"t\":[\"// 将所有存在交集的区间合并 void merge(vector<PII> &segs) { vector<PII> res; sort(segs.begin(), segs.end()); int L = -2e9, R = -2e9; for (auto seg : segs) if (R < seg.first) { if (st != -2e9) res.push_back({L, R}); L = seg.first, R = seg.second; } else R = max(R, seg.second); if (L != -2e9) res.push_back({L, R}); segs = res; }\"]},\"163\":{\"c\":[\"algorithm\"]},\"164\":{\"c\":[\"ACM\"]},\"165\":{\"h\":\"搜索与图论\"},\"166\":{\"h\":\"1. 树与图的存储\",\"t\":[\"(1) 邻接矩阵：g [a] [b] 存储边 a -> b\",\"(2) 动态邻接矩阵：\",\"int n; struct Edge { int id, w; }; vector<Edge> h[N]; int dist[N]; void dfs(int u, int father, int distance) { dist[u] = distance; for (auto node : h[u]) if (node.id != father) dfs(node.id, u, distance + node.w); } int main() { scanf(\\\"%d\\\", &n); for (int i = 0; i < n - 1; i ++ ) { int a, b, c; scanf(\\\"%d%d%d\\\", &a, &b, &c); h[a].push_back({b, c}); h[b].push_back({a, c}); } dfs(1, -1, 0); // 寻找两点之间的最大距离 int u = 1; for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; dfs(u, -1, 0); for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; int s = dist[u]; printf(\\\"%lld\\\\n\\\", s * 10 + s * (s + 1ll) / 2); return 0; }\",\"(3) 邻接表：\",\"int n, m; //n代表点数，m代表边数 // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a->b void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } // 初始化 idx = 0; memset(h, -1, sizeof h); //存边 for (int i = 0; i < n; i++){ int a, b; cin >> a >> b; add(a, b); //无向图就再写一遍 add(b, a) }\"]},\"167\":{\"h\":\"2. 树与图的遍历\",\"t\":[\"时间复杂度 O(n + m), n 表示点数， m 表示边数\"]},\"168\":{\"h\":\"深度优先遍历\",\"t\":[\"int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } }\"]},\"169\":{\"h\":\"宽度优先遍历\",\"t\":[\"queue<int> q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } }\"]},\"170\":{\"h\":\"3. 拓扑排序\",\"t\":[\"时间复杂度 O(n+m), n 表示点数，m 表示边数\",\"1、图的拓扑序列是针对于有向图而言的，无向图是没有拓扑序列的。有向无环图被称为拓扑图。\",\"2、结论：一个有向无环图，一定至少存在一个入度为 0 的点。\",\"bool topsort() { //采用数组模拟队列的写法，头尾指针 int hh = 0, tt = -1; // d[i] 存储点i的入度，起点的入度为0 for (int i = 1; i <= n; i++) if (!d[i]) //如果不是起点 q[++tt] = i; while (hh <= tt) { int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (--d[j] == 0) q[++tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; }\"]},\"171\":{\"h\":\"4. 最短路问题\"},\"172\":{\"h\":\"4.1 单源最短路\",\"t\":[\"求从一个点到其他所有点的最短距离。\",\"分为两大类：\",\"1、所有边权都是正数（n 个点，m 条边）\",\"朴素版的Dijkstra算法，时间复杂度为 O(n2 + m) ，适合稠密图（边多，点少边比较多）\",\"堆优化版的Dijkstra算法，时间复杂度为 O(mlogn)，适合稀疏图（点多，指边相对于点不多，m 和 n 是同一个级别的类型）\",\"2、存在负权边\",\"Bellman-Ford 算法，时间复杂度为 O(nm)\",\"SPFA 算法，时间复杂度一般为 O(m)，最坏情况为 O(nm)，是Bellman-Ford算法的优化\"]},\"173\":{\"h\":\"4.1.1 朴素版 Dijkstra算法\",\"t\":[\"稠密图用邻接矩阵，稀疏图用邻接表\",\"1.逐个遍历，找到与起点最近的且未确定最短路径的点，访问加入集合并标记。\",\"2.更新第一个点到起点的最短距离，直到第n个点。\",\"__时间复杂度是 O(n2 + m)， n 表示点数，m 表示边数 __\",\"#include <iostream> #include <cstring> #include <algortihm> using namespace std; const int N = 510; int n, m; //点数和边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { //距离都初始化为无穷大 memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i < n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 //遍历n个点，找到一个未加入集合且距离最近的点 for (int j = 1; j <= n; j ++ ) if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; st[t] = true; //标记为已加入到集合中 // 用t更新其他点的距离 for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); } //如果为无穷大，说明不连通，无法形成最短路 if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { cin >> n >> m; //邻接矩阵初始化为无穷大 memset(g, 0x3f, sizeof(g)); while (m--){ int a, b, c; cin >> a >> b >> c; //存入a和b两点之间的距离（有向图） g[a][b] = min(g[a][b], c); //无向图 //g[a][b] = min(g[a][b], c); //g[b][a] = min(a[a][b], c); } cout << dijkstra() << endl; return 0; }\"]},\"174\":{\"h\":\"4.1.2 堆优化版的Dijkstra算法\",\"t\":[\"稀疏图改用__邻接表__的形式存储，可以不需要考虑重边\",\"时间复杂度是 O(mlogn)， n 表示点数，m 表示边数\",\"#define PII pair<int, int> int n; //点的数量 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //存储所有点到1号点的距离 bool st[N]; //存储每个点的最短距离是否已确定 void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; //定义一个小根堆 priority_queue<PII, vector<PII>, greater<PII>> heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"175\":{\"h\":\"4.1.3 Bellman-ford算法（存在负权边）\",\"t\":[\"1.可以用结构体存储点和边，包括负权边。\",\"2.具体步骤：两重 for 循环，迭代 n-1 次，每次备份一下，每次循环遍历所有边，更新两点之间的最短距离，如点 a->b 的更新方式为（松弛操作）\",\"for n 次 for 所有边 a, b, w (松弛操作) dist[b] = min(dist[b], backup[a] + w);\",\"backup[ ] 数组是上一次迭代后 dist[ ] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[ ] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点。\",\"3.循环 n-1 次之后，对于所有的点都 一定满足 dist[b] <= dist[a] + w，该式被称为三角不等式。\",\"4.如果图中存在负权回路，那么最短路可能为负无穷。（不是一定）\",\"5.是否能到达 n 号点的判断中需要进行 if(dist[n] > INF/2) 判断，而并非是 if(dist[n] == INF) 判断，原因是 INF 是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，``dist[n]大于某个与INF` 相同数量级的数即可。\",\"6.bellman-ford算法擅长解决有边数限制的最短路问题。\",\"时间复杂度 O(nm)， n 表示点数，m 表示边数\",\"int n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i < n; i ++ ) { for (int j = 0; j < m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] > dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] > 0x3f3f3f3f / 2) return -1; return dist[n]; }\"]},\"176\":{\"h\":\"4.1.4 SPFA算法 （存在负权边）\",\"t\":[\"1.用队列来存储\",\"2.while queue 不为空，\",\"取出作为 t ，t = q.front; q.pop();\",\"更新 t 的所有出边，如：t -> b, 把b加入 queue\",\"3.基本步骤\",\"建立一个队列，初始时队列里只有起始点\",\"再建立一个数组记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到它本身的路径赋为0）\",\"再建立一个数组，标记点是否在队列中\",\"队头不断出队，计算起始点经过队头到其他点的距离是否变短，如果变短且该点不在队列中，则把该点加入到队尾\",\"重复执行直到队列为空\",\"在保存最短路径的数组中，就得到了最短路径\",\"4.SPFA求最短路\",\"时间复杂度 平均情况下 O(m)， 最坏情况下 O(nm)， n 表示点数， m 表示边数\",\"int n, m; // 总点数和总边数 int h[N], e[M], w[M], ne[M], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 int add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue<int> q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"177\":{\"h\":\"4.1.5 SPFA算法判断图中是否存在负环\",\"t\":[\"时间复杂度 O(nm)， n 表示点数， m 表示边数\",\"int n; //总点数 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //dist[x]存储1号点到x的最短距离， int cnt[N]; //cnt[x]存储1到x的最短路中经过的点数 bool st[N]; //存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue<int> q; for (int i = 1; i <= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (cnt[j] >= n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; }\"]},\"178\":{\"h\":\"4.2 多源汇最短路\"},\"179\":{\"h\":\"4.2.1 Floyd算法\",\"t\":[\"1.使用邻接矩阵存图\",\"2.三重循环，时间复杂度O(n^3)\",\"初始化： for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (i == j) d[i][j] = 0; else d[i][j] = INF; //算法结束后，d[a][b]表示a到b的距离 for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\"]},\"180\":{\"h\":\"5. 最小生成树问题\",\"t\":[\"最小生成树就是将 n 个顶点， n - 1 条边，通过一个连接起来，且使权值最小的一种结构。\",\"换句话来说，就是给定一个无向图，在图中选择若干条边把图中的所有节点连接起来，要求边长之和最小。在图论中，叫做求最小生成树。\"]},\"181\":{\"h\":\"5.1 朴素Prim算法\",\"t\":[\"可理解为 “加点法”， 每次迭代找到不在连通块中的距离最近的点，加入到连通块中，将连通块逐渐扩大，最后将整个图连通起来，并且边长之和最小。\",\"1、先把所有距离初始化为正无穷\",\"dist[i] = +INF;\",\"2、n次迭代，找到不在集合当中的最小的点，这个集合指当前已经在连通块中的所有点，找到该点赋给 t ，用 t 更新其他点到集合的距离，再把 t 加到集合当中去\",\"先累加，再更新\",\"for (int i = 0; i < n; i++) t <- 距离最近的点; t = ture;更新t\",\"时间复杂度为 O(n2 + m)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> #define ll long long using namespace std; const int N = 1e5 + 10, M = N * 2; int n, m; // n表示点数，m表示边数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; //最小生成树所有边的长度之和 for (int i = 0; i < n; i++) { int t = -1; for (int j = 1; j <= n; j++) //如果没有在树中，且到树的距离最短，则选择该点 if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; //一定要先累加，再进行更新生成树 if (i && dist[t] == INF) return INF; if (i) //(不是起点)把找到的符合条件的点的长度加上 res += dist[t]; st[t] = true; for (int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { cin >> n >> m; memset(g, 0x3f, sizeof g); for (int i = 1; i <= m; i++){ int a, b, c; cin >> a >> b >> c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(\\\"impossible\\\"); else printf(\\\"%d\\\\n\\\", t); }\"]},\"182\":{\"h\":\"5.2 Kruskal 算法\",\"t\":[\"可理解为 “加边法”，最初最小生成树的边数为 0，每次迭代选择一条不在集合内的权值最短的边，加入到集合中，组成最小生成树。\",\"1、使用快排将所有边按权值从小到大排序。时间复杂度为 O(log n).\",\"2、从小到大依次枚举每组边 a 、b，权重 c ，如果 a、b不连通，就将这条边加入集合中，直到具有 n 个顶点的连通块筛选出来 n-1 条边为止。时间复杂度为 O(n) .\",\"3、判断 a、b是否连通的方法为：使用并查集。\",\"初始化各个顶点在不同的集合中，父节点为它自己。\",\"按快排的从小到大的顺序遍历每条边，判断这条边的两个顶点是否有相同的父节点，如果有那就使在同一个集合中。\",\"如果该条边上的两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则加入这条边到集合中，连通这两个顶点。\",\"时间复杂度是 O(mlogm)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> using namespace std; const int N = 2e5 + 10; int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 int rank[N]; // 树的高度 //结构体存储 两点及其权值 struct Edge { int a, b, w; //重载小于号，因为再给边排序的时候是按照边的权重进行排序的，这样当两个边进行比较的时候就会使用他们的权重进行比较了 bool operator< (const Edge &W)const { return w < W.w; } }edges[M]; void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int x, int y) { int px = find(x), py = find(y); if (px == py) return; if (rank[px] < rank[py]){ p[px] = py; } else { p[py] = px; if (rank[px] == rank[py]) rank[px]++; } } int kruskal() { sort(edges, edges + m); init(n); int res = 0; //存的是最小生成树的所有边的权值 int cnt = 0; //存的是当前加入的边数 for (int i = 0; i < m; i++) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; pa = find(a), pb = find(b); if (pa != pb) // 如果两个连通块不连通，则将这两个连通块合并 { union(a, b); res += w; cnt++; } } //只有当 cnt == n - 1 时才能表示已经将所有点加入到集合中，可以生成最小生成树 if (cnt < n - 1) return INF; return res; }\"]},\"183\":{\"h\":\"6. 染色法判别二分图\",\"t\":[\"二分图： 将所有点分成__两个集合__，使得__所有边__只出现在集合之间，就是 二分图\",\"性质： 一定不含有奇数环，可能包含长度为偶数的环，不一定是__连通图__。\",\"DFS思路：\",\"染色可以使用 1 和 2 区分__不同颜色__，用 0 表示 未染色\",\"遍历所有点，每次将__未染色的点__进行 dfs，默认染成 1 或 2\",\"由于某个点染色成功并不代表整个图就是二分图，因此只有某个点染色失败才能立刻 break/return，__染色失败__相当于存在两个相邻的点染成了相同的颜色\",\"时间复杂度 O(n + m)， n 表示点数，m 表示边数\",\"int n, m; //n表示点数，m表示边数 int h[N], e[M], ne[M], idx; //邻接表存储图 int color[N]; //表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 //参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i <= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; }\"]},\"184\":{\"h\":\"7. 匈牙利算法\",\"t\":[\"相关概念：\",\"匹配：在图论中，一个 [匹配] 是一个边的集合，其中任意两条边都不依附于同一个顶点。\",\"最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。\",\"完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。\",\"交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边...形成的路径叫交替路。\",\"增广路：从一个未匹配路出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。\",\"算法描述：\",\"如果你想找的妹子已经有了男朋友，\",\"你就去问问她男朋友，\",\"你有没有备胎，\",\"把这个让给我好吧\",\"多么真实而实用的算法\",\"tips：因为你要去问的都是男孩子，所以存边的时候，都是由男孩子指向女孩子\",\"时间复杂度是 O(nm)， n 表示点数，m 表示边数\",\"int n1, n2; //n1表示第一个集合中的点数，n2表示第二个集合中的点数 // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int h[N], e[M], ne[M], idx; int match[N]; //存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; //表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { //遍历所有点 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) //如果在这一轮的匹配中，这个点还未被匹配 { st[j] = true; //那就匹配并标记 //如果这个点未被匹配，且原来匹配的点能找到另一个点(下家)匹配，则匹配成功 if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i <= n1; i ++ ) { //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化 memset(st, false, sizeof st); if (find(i)) res++; }\"]},\"185\":{\"c\":[\"algorithm\"]},\"186\":{\"c\":[\"ACM\"]},\"187\":{\"h\":\"数学知识\"},\"188\":{\"h\":\"1. 质数\"},\"189\":{\"h\":\"1.1 试除法判定质数\",\"t\":[\"从小到大遍历，只判断能否被小于 sqrt(x) 的数整除。\",\"时间复杂度为 O(sqrt(n)).\",\"bool is_prime(int x) { if (x < 2) return false; for (int i = 2; i <= x / i; i++) if (x % i == 0) return false; return true; }\"]},\"190\":{\"h\":\"1.2 试除法分解质因数\",\"t\":[\"从小到大尝试 n 的所有因数，每个正整数都能够以唯一的方式表示成它的质因数的乘积。\",\"结论：n 中最多只包含一个大于 sqrt(n) 的因子。\",\"反证法证明：如果有两个大于 sqrt(n) 的因子，那么相乘会大于 n。于是我们发现只有一个大于 sqrt(n) 的因子，可以对其进行优化。如果最后 n 还是 >1，说明这就是大于 sqrt(n) 的唯一质因子，输出即可。\",\"时间复杂度为 O(log n) ~ O(sqrt(n)).\",\"void divide(int x) { for (int i = 2; i <= x / i; i++) if (x % i == 0) { int s = 0; //s表示次幂 while (x % i == 0) { x /= i; s++; } cout << i << ' ' << s << endl; //输出i的s次幂 } if (x > 1) cout << x << ' ' << 1 << endl; cout << endl; }\"]},\"191\":{\"h\":\"汇总\",\"t\":[\"// 假设输入都是正数 // 素数测试 O(√n) bool is_prime(int n) { for (int i = 2; i <= n / i; i++){ if (n % i == 0) return false; } return n != 1; } // 约数枚举 O(√n) vector<int> divisor(int n) { vector<int> res; for (int i = 1; i <= n / i; i++){ if (n % i == 0){ res.push_back(i); if (i != n / i) res.push_back(n / i); } } return res; } // 整数分解 O(√n) map<int, int> prime_factor(int n) { map<int, int> res; for (int i = 2; i <= n / i; i++){ while (n % i == 0){ ++res[i]; n /= i; } } if (n != 1) res[n] = 1; return res; }\"]},\"192\":{\"h\":\"1.3 筛法求素数\"},\"193\":{\"h\":\"1.3.1 朴素筛法（埃氏筛）\",\"t\":[\"从 2 到 n 枚举，（一个数的倍数一定是合数）筛掉它的倍数，如果该数没有被筛掉，那它就是一个质数。\",\"（1）调和级数：当 n 趋于无穷大时，1 + 1/2 + 1/3 + … + 1/n = ln n + C.\",\"（2）对朴素筛法的优化：任何一个合数都能写成几个质数相乘的形式。只需要判断 2 ~ n-1 中的所有质数，只要它不是 n 的约数，那么 n 就是一个质因数。\",\"（3）质数定理：1~n 当中有 n/ln n 个质数。\",\"（4）思路：从小到大枚举所有的质数，然后删去它们的所有的倍数，就删去了所有的合数，剩下的就是质数。\",\"时间复杂度为 O(n ln ln n).\",\"int primes[N], cnt; // primes[]存储所有素数，cnt记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (st[i]) continue; primes[cnt++] = i; for (int j = i; j <= n; j += i) //用质数把其所有的倍数都筛掉 st[j] = true; } }\"]},\"194\":{\"h\":\"1.3.2 区间筛法\",\"t\":[\"给定整数 a 和 b ，问区间 [a,b) 内有多少个素数。\",\"解法：\",\"因为 b 以内的合数的最小质因数一定不超过 b​ ，如果有 b​ 以内的素数表的话，就可以把埃氏筛法运用在 [a,b) 上了。\",\"所以先预处理好 [a,b​) 和 [a,b) 的素数表，然后从 [a,b​) 的表中筛得素数的同时，也将其倍数从 [a,b) 的表中划去，最后剩下的就是区间 [a,b) 内的素数了。\",\"#define ll long long bool is_primes[N]; bool is_primes2[N]; void get_prime(ll a, ll b) { for (int i = 0; (ll)i * i < b; i++) is_primes2[i] = true; for (int i = 0; i < b - a; i++) is_prime[i] = true; // is_primes[i - a] = true => i是素数 for (int i = 2; (ll)i * i < b; i++){ if (is_primes2[i]){ for (int j = 2 * i; (ll)j * j < b; j += i) is_primes2[j] = true; for (ll j = max(2LL, (a + i - 1) / i; j < b; j += i) is_primes[j - a] = false; } } }\"]},\"195\":{\"h\":\"1.3.3 线性筛（欧拉筛）\",\"t\":[\"核心思路：用最小质因子去筛合数。\",\"当 i % primes[j] != 0 时， 说明此时遍历到的 primes[j] 不是 i 的质因子，只可能是此时 primes[j] 的最小质因子， 所以 primes[j] * i 的最小质因子就是 primes[j].\",\"当有 i % primes[j] == 0 时， 因为我们是从小到大遍历的，说明此时的 prime[j] 是满足条件的第一个数，即找到了 primes[j] 就是 i 的最小质因子， 因此 primes[j] * i 的最小质因子也就是 primes[j]， 之后用 st[primes[j + 1] * i] = true 去筛合数时，就不是用最小质因子去更新了， 所以此时应该退出循环，避免重复筛选。\",\"时间复杂度为 O(k)\",\"int primes[N]; // primes[]存储所有素数 int cnt; //记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] <= n / i; j++) { //标记，pj一定是pj*i的最小质因子 st[primes[j] * i] = true; //从小到大遍历，如果 i%pj=0，则pj一定是i的最小公因子 if (i % primes[j] == 0) break; } } }\"]},\"196\":{\"h\":\"2. 约数\"},\"197\":{\"h\":\"2.1 试除法求所有约数\",\"t\":[\"从小到大判断，如果当前数能整除目标数，说明这个数是它的一个约数。\",\"vector<int> get_divisors(int x) { vector<int> res; //从小到大枚举n的所有约数对里面比较小的那一个 for (int i = 1; i <= x / i; i++) if (x % i == 0) { res.push_back(i); //特判最中间的数 if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; }\"]},\"198\":{\"h\":\"2.2 约数个数和约数之和\",\"t\":[\"如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\",\"约数之和\",\"#include <iostream> #include <algorithm> #include <unordered_map> #include <vector> using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin >> n; unordered_map<int, int> primes; while (n -- ) { int x; cin >> x; for (int i = 2; i <= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x > 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; } cout << res << endl; return 0; }\"]},\"199\":{\"h\":\"2.3 最大公约数与最小公倍数\",\"t\":[\"欧几里得算法（辗转相除法)：\",\"每次都让较大的数对较小数取模，可以缩小问题规模而保持最大公约数不变，然后重复(递归)这个步骤。递归边界使某数变成了0，而此时另一个数即为所求答案.\",\"最坏情况下的时间复杂度为 O(log max(x, y))。\",\"对于大多数情况，辗转相除法时间可以忽略不计。\",\"int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\",\"用两数之积除以他们的最大公约数可得最小公倍数：\",\"int lcm(int a, int b) { return a * gcd(a, b) / b; //注意乘除的先后顺序，防止溢出 }\"]},\"200\":{\"h\":\"3. 欧拉函数\"},\"201\":{\"h\":\"3.1 求欧拉函数\",\"t\":[\"欧拉函数的定义\",\"1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)。 若在算数基本定理中，N=p1a1​​p2a2​​...pmam​​ ，则： ϕ(N)=N×p1​p1​−1​×p2​p2​−1​×…×pm​pm​−1​\",\"//求x的欧拉函数 int phi(int x) { int res = x; for (int i = 2; i <= x / i; i++) //分解质因数 if (x % i == 0) { res = res / i * (i - 1); //用上面的公式定义求，先整除再乘 while (x % i == 0) x /= i; } if (x > 1) res = res / x * (x - 1); return res; }\"]},\"202\":{\"h\":\"3.2 筛法求欧拉函数\",\"t\":[\"思路：质数 i 的欧拉函数即为 phi[i] = i - 1：1 ~ i−1均与 i 互质，共 i−1个。 phi[primes[j] * i] 分为两种情况： ① i % primes[j] == 0 时：primes[j] 是 i 的最小质因子，也是 primes[j] * i 的最小质因子，因此 1 - 1 / primes[j] 这一项在 phi[i] 中计算过了，只需将基数 N 修正为 primes[j] 倍，最终结果为 phi[i] * primes[j] 。 ② i % primes[j] != 0：primes[j] 不是 i 的质因子，只是 primes[j] * i 的最小质因子，因此不仅需要将基数 N 修正为 primes[j] 倍，还需要补上 1 - 1 / primes[j] 这一项，因此最终结果 phi[i] * (primes[j] - 1) 。\",\"int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i <= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] <= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } }\"]},\"203\":{\"h\":\"4. 快速幂\",\"t\":[\"基本思路：\",\"预处理出 a20,a21,a22,...,a2logk 这 k 个数\",\"将 ab 用 a20,a21,a22,...,a2logk 这 k 个数来组合，即组合成 ab=a2x1​×a2x2​×...×a2xt​=a2x1​+2x2​+...+2xt​​\",\"即用二进制来表示\",\"k&1 就是判断 k 的二进制表示中第 0 位上的数是否为 1，若为 1，则为 true，反之为 false.\",\"k&1 也可以用来判断奇数和偶数，b&1 = true 时为奇数，b&1 = false 时为偶数。\",\"求 ak mod p， 时间复杂度为 O(logk)\",\"int qmi(int a, int k, int p) { int res = 1 % p; while (k) { if (k&1) res = res * a % p; k >>= 1; a = a * a % p; } return res; }\"]},\"204\":{\"h\":\"5. 扩展欧几里得算法\"},\"205\":{\"h\":\"裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\",\"用于求解方程 ax+by=gcd(a,b)​ 的解\",\"当 b=0 时，ax+by=a 所以有 x=1,y=0\",\"当 b=0 时 ，因为 $gcd(a, b) = gcd(b, a % b) $\",\"​ 所以 x=y′,y=x′−[a/b]∗y′\",\"求整数 x 和 y 使得 ax+by=1\",\"如果 gcd(a,b)=1，显然无解。反之，若 gcd(a,b)=1 ，则可以通过扩展欧几里得来求解。\",\"事实上，一定存在整数对 (x,y) 使得 ax+by=gcd(a,b) .\",\"// 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; }\"]},\"206\":{\"h\":\"6. 中国剩余定理\",\"t\":[\"给定 2n 个整数 a1​,a2​,...,an​ 和 m1​,m2​,...,mn​ ，求一个最小的非负整数 x ，满足 ∀i∈[1,n],x≡mi​(modai​) .\",\"输入格式\",\"第 1 行包含整数 n。\",\"第 2...n+1 行：每 i+1 行包含两个整数 ai​ 和 mi​ ，数之间用空格隔开。\",\"输出格式\",\"输出最小非负整数 x ，如果 x 不存在，则输出 -1.\",\"如果存在 x ，则数据保证 x 一定在 64 位整数范围内。\",\"思路\",\"对于每两个式子，将其等价转换\",\"用扩展欧几里得算法找出一组解\",\"并且判断是否有解\",\"找到最小整数解\",\"等效替代\",\"相当于是每次考虑合并两个式子，将这 n 个式子合并 n - 1 次后变为一个式子。最后剩下的式子就满足我们的答案。\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; //扩展欧几里得 ll exgcd(ll a, ll b, ll &x, ll &y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } //可能为负数，取模加模再取模 ll inline mod(ll a, ll b) { return ((a % b) + b) % b; } int main() { ll n; scanf(\\\"%lld\\\", &n); ll a1, m1; scanf(\\\"%lld%lld\\\", &a1, &m1); for (ll i = 1; i < n; i++) { ll a2, m2, k1, k2; scanf(\\\"%lld%lld\\\", &a2, &m2); ll d = exgcd(a1, -a2, k1, k2); if ((m2 - m1) % d) { puts(\\\"-1\\\"); return 0; } k1 = k1 * (m2 - m1) / d; k1 = mod(k1, abs(a2 / d)); m1 = m1 + k1 * a1; a1 = abs(a1 / d * a2); } printf(\\\"%lld\\\\n\\\", m1); return 0; }\"]},\"207\":{\"h\":\"7. 高斯消元\",\"t\":[\"给定一个包含 n 个方程 n 个未知数的线性方程组。方程组中的系数为实数。\",\"要求求解这个方程组。\",\"（线性代数方法解非齐次线性方程组）\",\"前置知识：初等行（列）变换\",\"把某一行乘一个非00的数 (方程的两边同时乘上一个非00数不改变方程的解)\",\"交换某两行 (交换两个方程的位置)\",\"把某行的若干倍加到另一行上去 （把一个方程的若干倍加到另一个方程上去）\",\"高斯消元适用解法\",\"通过初等行变换把 增广矩阵 化为 阶梯型矩阵 并回代得到方程的解\",\"适用于求解包含 n 个方程，n 个未知数的多元线性方程组\",\"算法步骤\",\"枚举每一列c,\",\"找到当前列绝对值最大的一行\",\"用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）\",\"用初等行变换(1) 将该行的第一个数变成 11 （其余所有的数字依次跟着变化）\",\"用初等行变换(3) 将下面所有行的当且列的值变成 0\",\"时间复杂度为 O(n^3)\",\"const int eps = 1e-6; //控制精度，小于eps视为0 int a[N][N]; // a[N][N]是增广矩阵 int gauss() { int r, c; //行row,列col for (r = 0, c = 0; c < n; c ++ ) { int t = r; // 找到绝对值最大的行 for (int i = r; i < n; i ++ ) if (abs(a[i][c]) > abs(a[t][c])) t = i; if (abs(a[t][c]) < eps) continue; // 将绝对值最大的行换到最顶端 for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); // 将当前行的首位变成1 for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; // 用当前行将下面所有的列消成0 for (int i = r + 1; i < n; i ++ ) if (fabs(a[i][c]) > eps) for (int j = n; j >= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r < n) { for (int i = r; i < n; i ++ ) if (fabs(a[i][n]) > eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i >= 0; i -- ) for (int j = i + 1; j < n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 }\"]},\"208\":{\"h\":\"8. 求组合数\"},\"209\":{\"h\":\"8.1 递推法求组合数\",\"t\":[\"适用题型：\",\"给定两个正整数 a 与 b ，求 Cab​mod(1e9+7)\",\"递推式：\",\"Cab​=Ca−1b−1​+Ca−1b​\",\"// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i < N; i++) for (int j = 0; j <= i; j++) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\"]},\"210\":{\"h\":\"8.2 通过预处理逆元的方式求组和数\",\"t\":[\"用 infact(a!) 表示 a! 的逆元\",\"Cab​=b!∗(a−b)!a!​=a!∗infact(b!)∗infact((a−b)!)\",\"快速幂求逆元\",\"费马小定理：如果 p 是一个质数，而整数 a 不是 p 的倍数，则有 ap−1≡1(modp) .\",\"乘法逆元的定义\",\"若整数 b, m 互质，并且对于任意的整数 a，如果满足 b | a，则存在一个整数 x，使得 a / b ≡ a * x (mod m) ，则称 x 为 b 的模 m 乘法逆元，记为 b−1(modm) .\",\"b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，bm−2 即为 b 的乘法逆元。\",\"结论：当 b 与 m 互质时，b 的乘法逆元为 bm−2.\",\"​ 当 b 为 m 的倍数时，b 的逆元不存在。b∗x%m==0 ，b 乘任意一个 x % m 一定等于 0.\",\"首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i < N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; }\"]},\"211\":{\"h\":\"8.3 卢卡斯(Lucas)定理求组合数\",\"t\":[\"给定 n 组询问，每组询问给定三个整数 a,b,p，其中 p 是质数，请你输出 Cab​modp 的值。\",\"Lucas 定理：Cab​≡Ca%pb%p​∗Cpa​pb​​(modp)\",\"Cba​=(a−b!)∗b!a!​=(a−b)∗(a−b−1)∗…∗1∗b!a∗(a−1)∗(a−2)∗…∗(a−b+1)∗(a−b)∗…∗1​=b!a∗(a−1)∗(a−2)∗…(a−b+1)​\",\"因此可以递推的每次乘 a 然后 除以 b ，因为从 a 到 a - b + 1，所以是乘 b 次。\",\"若p是质数，则对于任意整数 1 <= m <= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k, int p) // 快速幂模板 { int res = 1 % p; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a < b) return 0; LL x = 1, y = 1; // x是分子，y是分母 for (int i = a, j = 1; j <= b; i --, j ++ ) { x = (LL)x * i % p; y = (LL)y * j % p; } return x * (LL)qmi(y, p - 2, p) % p; } int lucas(LL a, LL b, int p) { if (a < p && b < p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } int main() { int n; cin >> n; while (n--) { ll a, b, p; cin >> a >> b >> p; cout << lucas(a, b, p) << endl; } return 0; }\"]},\"212\":{\"h\":\"8.4 分解质因数法求组合数\",\"t\":[\"输入 a, b，求 Cab​ 的值。\",\"方法：对阶乘分解质因数之后，用高精度相乘即可。\",\"步骤：\",\"筛素数\",\"求每个质数的次数\",\"用高精度乘法把所有质因子乘上\",\"当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i <= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] <= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n!中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector<int> mul(vector<int> a, int b) // 高精度乘低精度模板 { vector<int> c; int t = 0; for (int i = 0; i < a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i < cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector<int> res; res.push_back(1); for (int i = 0; i < cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j < sum[i]; j ++ ) res = mul(res, primes[i]);\"]},\"213\":{\"h\":\"8.5 卡特兰数\",\"t\":[\"给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\"]},\"214\":{\"h\":\"9. 容斥原理\",\"t\":[\"给定一个整数 n 和 m 个不同的质数 p1​,p2​,...,pm​ .\",\"请你求出 1 ~ n 中能被 p1​,p2​,...,pm​​ 中至少一个数整除的整数有多少个。\",\"记 Si​ 为 1 ~ n 中能整除 pi​​ 的集合，根据容斥原理，所有数的个数为各个集合的并集，计算公式如下\",\"#include<iostream> using namespace std; #define ll long long const int N = 20; int p[N], n, m; int main() { cin >> n >> m; for(int i = 0; i < m; i++) cin >> p[i]; int res = 0; //枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合) for(int i = 1; i < 1 << m; i++) { int t = 1; //选中集合对应质数的乘积 int s = 0; //选中的集合数量 //枚举当前状态的每一位 for(int j = 0; j < m; j++){ //选中一个集合 if(i >> j & 1){ //乘积大于n, 则n/t = 0, 跳出这轮循环 if((LL)t * p[j] > n){ t = -1; break; } s++; //有一个1，集合数量+1 t *= p[j]; } } if(t != -1) { if (s % 2) //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量 res += n / t; else //反之则为 -1 res -= n / t; } } cout << res << endl; return 0; }\"]},\"215\":{\"h\":\"10. 博弈论\"},\"216\":{\"h\":\"10.1 NIM游戏\",\"t\":[\"必胜状态和必败状态\",\"必胜状态，先手进行__某一个操作__，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即__先手可以走到某一个必败状态__。\",\"必败状态，先手__无论如何操作__，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即__先手走不到任何一个必败状态__。\",\"给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\",\"我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\",\"定理： NIM博弈先手必胜，当且仅当 a1 ^ a2 ^ … ^ an != 0\",\"#include <iostream> #include <algorithm> using namespace std; int main() { int n; cin >> n; int res = 0; while (n--) { int x; cin >> x; res ^= x; //每次异或操作 } if (res) puts(\\\"Yes\\\"); else puts(\\\"No\\\"); return 0; }\"]},\"217\":{\"h\":\"10.2 公平组合游戏ICG\",\"t\":[\"若一个游戏满足：\",\"由两名玩家交替行动；\",\"在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\",\"不能行动的玩家判负；\",\"则称该游戏为一个公平组合游戏。\",\"NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件 2 和条件 3 。\"]},\"218\":{\"h\":\"10.3 有向图游戏\",\"t\":[\"给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\"]},\"219\":{\"h\":\"10.4 Mex运算\",\"t\":[\"设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\"]},\"220\":{\"h\":\"10.5 SG游戏\",\"t\":[\"在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\"]},\"221\":{\"h\":\"10.6 有向图游戏的和\",\"t\":[\"设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\",\"定理\",\"有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\"]},\"222\":{\"c\":[\"algorithm\"]},\"223\":{\"c\":[\"ACM\"]},\"224\":{\"h\":\"数据结构\"},\"225\":{\"h\":\"1. 数组模拟链表\"},\"226\":{\"h\":\"1.1 单链表\",\"t\":[\"也称静态链表（邻接表：n 个链表，主要应用：存储图和树）单链表只能存储当前节点的值和指向下一节点的指针，无法存储上一节点\",\"// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; //-1表示不存在， idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a,; ne[idx] = head,; head = idx ++ ; } // 将一个新的节点x插入下标是k的后面 void add(int k, int x){ e[idx] = x; // 1.先存值 ne[idx] = ne[k]; // 2.新节点的下一节点指向 k 指向的下一节点 ne[k] = idx; // 3.k指向的下一节点指向新节点 idx++; // 4.index指向下一个指针 } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将下标是k的点后面的点删掉 void remove(int x){ // 直接将其指向下下个节点，在算法竞赛中一般不需要考虑删除的那个节点该如何处理 ne[k] = ne[ne[k]]; }\"]},\"227\":{\"h\":\"1.2 双链表\",\"t\":[\"（主要用来优化某些问题）有两个指针，一个指向前，一个指向后。\",\"// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { // 0是左端点，1是右端点 r[0] = 1; l[1] = 0; idx = 2; // 0和1都被占用了，所以idx从2开始 } // 在节点k的右边插入一个数x // 如果要插在k的左边，就把k改为l[k] void insert(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx++; } // 删除第k个点 void remove(int k) { l[r[k]] = l[k]; r[l[k]] = r[k]; }\"]},\"228\":{\"h\":\"2. 栈\",\"t\":[\"先进后出\"]},\"229\":{\"h\":\"2.1 普通栈\",\"t\":[\"// tt表示栈顶 int stk[N]; //栈数组从0开始 int tt = 0; // 向栈顶插入一个数 stk[++tt] = x; // 从栈顶弹出一个数 tt--; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt > 0) not empty { } else empty\"]},\"230\":{\"h\":\"2.1 单调栈\",\"t\":[\"给定一个序列，找到每一个数左边离他最近的比它小的数。\",\"性质：如果 ax​≥ay​,x<y，那么 ax​ 永远不会被输出，可以删掉。比如 a3​≥a5​，那么 a3​ 永远不会被输出。\",\"常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i <= n; i++) { while (tt && check(stk[tt], i)) tt--; stk[++tt] = i; }\"]},\"231\":{\"h\":\"3. 队列\",\"t\":[\"先进先出，后进后出\"]},\"232\":{\"h\":\"3.1 普通队列\",\"t\":[\"// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[++tt] = x; // 从队头弹出一个数 hh++; // 队头的值 q[hh]; //同理队尾 q[tt] // 判断队列是否为空 if (hh <= tt) not empty { } else empty\"]},\"233\":{\"h\":\"3.2 单调队列\",\"t\":[\"求滑动窗口里的最大值和最小值。用单调队列来优化。\",\"步骤：\",\"判断队头是否已经滑出窗口\",\"判断当前元素与队尾元素是否满足单调性问题\",\"若满足条件，弹出队尾元素，将当前元素加入队尾\",\"如果窗口满足条件，则输出结果\",\"【注意】队列里面存的是下标\",\"常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i < n; i++) { //判断队头是否滑出窗口 if (hh <= tt && check_out(q[hh])) hh++; //判断当前元素与队尾元素是否满足单调性问题 while (hh <= tt && check(q[tt], i)) tt--; q[++tt] = i; //将当前元素加入到队尾 //如果满足条件再输出结果 if() }\"]},\"234\":{\"h\":\"4. KMP\",\"t\":[\"关于为什么求 next 数组和匹配的操作类似： 因为本质是一样的：对于 S 串每一个特定的下标 i，在满足 s[i-j+1，i]=p[0，j] 的前提下，我们需要找出 j 的最大值。 唯一不同的在于，求 next 数组时，我们关心对于每个不同的下标 i,j 能走多远；匹配时，我们只关心 j 是否走到末尾.\",\"非常有意思的说法是： 求 next 数组时，对于每个 i：\\\"j走到哪了呀？我用数组记录一下你的位置\\\" 匹配时，对于每个 i：\\\"到终点和我说声，匹配完我输出一下，没事别叫我。\\\"\",\"#include <iostream> using namespace std; const int N = 100010, M = 10010; // N为模式串长度，M匹配串长度 int n, m; int ne[M]; // next[]数组，避免和头文件next冲突 char s[N], p[M]; // s为模式串， p为匹配串 int main() { cin >> n >> s+1; cin >> m >> p+1; //下标从1开始 // 求next[]数组 for (int i = 2, j = 0; i <= m; i++) { while (j && p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } // 匹配操作 for (int i = 1, j = 0; i <= n; i++) { while (j && s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == m) // 满足匹配条件，打印开头下标, 从0开始 { // 匹配完成后的具体操作 // 如：输出以0开始的匹配子串的首字母下标 // printf(\\\"%d \\\", i - m); (若从1开始，加1) j = ne[j]; // 再次继续匹配 } } return 0; }\"]},\"235\":{\"h\":\"5. Trie树\",\"t\":[\"Trie 树又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构。\",\"存储形式如下：\",\"Trie树存储形式\",\"// son[][]存储树中每个节点的子节点，因为存的都是英文字母，最多有26个 int son[N][26]; int cnt[N]; // cnt[]存储以每个节点结尾的单词数量 int idx; // 存储当前用到的下标，0号点既是根节点，又是空节点 // 插入一个字符串 void insert(char *str) { int p = 0; // 字符串以'0'结尾，所以可以用str[i]结束 for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; }\"]},\"236\":{\"h\":\"6. 并查集\"},\"237\":{\"h\":\"6.1 朴素并查集\",\"t\":[\" int p[N]; // 存储每个点的祖宗节点 int rank[N]; // 树的高度 // 初始化，假定节点编号是1~n void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 合并x和y所在的两个集合： void union(int x, int y) { int px = find(x), py = find(y); if (rank[px] < rank[py]){ p[px] = py; rank[py] += rank[px]; } else { p[py] = px; rank[px] += rank[py]; } }\"]},\"238\":{\"h\":\"6.2 维护size的并查集\",\"t\":[\" int p[N], size[N]; // p[]存储每个点的祖宗节点 // size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);\"]},\"239\":{\"h\":\"6.3 维护到祖宗节点距离的并查集\",\"t\":[\" int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\"]},\"240\":{\"h\":\"7. 堆\",\"t\":[\"1、作用：维护一个数组集合\",\"2、堆是一棵（完全）二叉树，长得非常平衡，除最后一层节点，所有节点均不为空，最后一层节点从左向右排列，根节点小于等于左右两个子节点，即小根堆。\",\"3、存储：用一个一维数组存储树，下标从 1 开始。其中元素 x 的左儿子为 2x，x 的右儿子为 2x+1.\",\"4、5个基本操作\",\"heap 表示堆，size 表示大小\",\"1. 插入一个数 heap[++size] = x; up(size); 2. 求集合当中的最小值 heap[1]; 3. 删除最小值 heap[1] = heap[size]; size--; down(1); 4. 删除任意一个元素 heap[k] = heap[size]; size--; down(k); up(k); //down和up只会执行其中一个 5. 修改任意一个元素 heap[K] = x; down(k); up(k);\",\"// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) // 跟两个儿子比较大小 { // t表示该元素与它的左、右儿子相比最小的元素，初始化为它自身 int t = u; // 若左二子小于它，则最小的数为左二子 if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2; // 若右儿子小于它，则最小的数为右儿子 if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1; // 如果它本身不是最小的数，则往下沉，继续down()操作 if (u != t) { heap_swap(u, t); down(t); } } void up(int u) //只需要跟一个父亲比较大小就行 { // 如果比父节点大，就交换位置，上浮 while (u / 2 && h[u] < h[u / 2]) { heap_swap(u, u / 2); u >>= 1; //x /= 2 } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i);\"]},\"241\":{\"h\":\"8. 哈希表\"},\"242\":{\"h\":\"8.1 拉链法\",\"t\":[\"int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { //哈希函数离散化 int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; }\"]},\"243\":{\"h\":\"8.2 开放寻址法\",\"t\":[\"int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { // 哈希函数 int k = (x % N + N) % N; while (h[k] != null && h[k] != x) { k++; // 如果到了末尾，那么再从头开始查找 if (k == N) k = 0; } return k; }\"]},\"244\":{\"h\":\"8.3 字符串哈希\",\"t\":[\"核心思想：将字符串看成 P 进制数，P 的经验值是 131 或 13331，取这两个值的冲突概率低 小技巧：取模的数用 2^64，这样直接用 unsigned long long 存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N]; // h[k]存储字符串前k个字母的哈希值 ULL p[N]; // p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i <= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }\"]},\"245\":{\"h\":\"9. C++ STL简介\",\"t\":[\"vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair<int, int> first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string, 字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列，本身就是有序的，默认按 key 排序 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 没找到则返回end() count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 (3) 例如：s.erase(unique(s.begin(), d.end()), s,end()) 将一个容器中重复的元素删除，对字符串也适用 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() 用 first 和 second 查找每个键值对的元素 [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 都可以是‘哈希表’ 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset<10000> s; ~, &, |, ^ >>, << ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反\"]},\"246\":{\"h\":\"10. 常用库函数\",\"t\":[\"1. reverse 翻转\",\"翻转一个 vector ：\",\"reverse(a.begin(), a.end());\",\"翻转一个数组，元素存放在下标 1 ~ n ：\",\"reverse(a + 1, a + n + 1);\",\"2. unique 去重\",\"返回去重（只去掉相邻的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。\",\"把一个 vector 去重：\",\"int m = unique(a.begin(), a.end()) – a.begin();\",\"把一个数组去重，元素存放在下标 1 ~ n：\",\"int m = unique(a + 1, a + n + 1) – (a + 1);\",\"3. random_shuffle 随机打乱： 用法与 reverse 相同。\",\"4. sort 排序：\",\"对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载 “小于号” 运算符。\",\"把一个 int 数组（元素存放在下标 1 ~ n ）从大到小排序，传入比较函数：\",\"int a[MAX_SIZE]; bool cmp(int a, int b) { return a > b; } sort(a + 1, a + n + 1, cmp);\",\"从大到小排序需要加入第三个参数：\",\"sort(a.begin(), a.end(), greater<int>());\",\"对自定义的结构体 vector 排序，重载 \\\"小于号\\\" 运算符：\",\"struct node { int id, x, y; }; vector<node> a; bool operator < (const node &a, const node &b) { return a.x < b.x || a.x == b.x && a.y < b.y; } sort(a.begin(), a.end());\",\"5. lower_bound / upper_bound 二分：\",\"lower_bound 的第三个参数传入一个元素 x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于 x 的元素的位置的迭代器（指针）。\",\"upper_bound 的用法和 lower_bound 大致相同，唯一的区别是查找第一个大于 x 的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。\",\"在有序 int 数组（元素存放在下标 1 ~ n ）中查找大于等于 x 的最小整数的下标：\",\"int i = lower_bound(a + 1, a + 1 + n, x) - a;\",\"在有序 vector<int> 中查找小于等于 x 的最大整数（假设一定存在）：\",\"int y = *--upper_bound(a.begin(), a.end(), x);\",\"找不到则返回最后一个元素的下标+1，是越界的。\"]},\"247\":{\"c\":[\"algorithm\"]},\"248\":{\"c\":[\"ACM\"]},\"249\":{\"h\":\"贪心\"},\"250\":{\"h\":\"1. 区间问题\"},\"251\":{\"h\":\"1.1 区间选点\",\"t\":[\"给定 N个闭区间 ，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node &W) const { return r < W.r; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; //按右端点从小到大排序 sort(arr + 1, arr + 1 + n); int ans = 0; int R = -2e9; //R表示上一连续区间的最右端的点 for (int i = 1; i <= n; i++) { if (arr[i].l > R) //如果不能覆盖掉右端点，则点数+1，更新右端点 { ans++; R = arr[i].r; } } cout << ans << endl; return 0; }\"]},\"252\":{\"h\":\"1.2 最大不相交区间数量\",\"t\":[\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node & W) const { return l < W.l; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; sort(arr + 1, arr + 1 + n); int res = 1, R = arr[1].r; for (int i = 2; i <= n; i++){ if (arr[i].l <= R) R = min(R, arr[i].r); else { res++; R = arr[i].r; } } cout << res << endl; return 0; }\"]},\"253\":{\"h\":\"1.3 区间分组\",\"t\":[\"给定 N个闭区间 ，要求分成若干组，使得每组内部区间两两之间没有交集，求分成的最小组数。\",\"#include <iostream> #include <algorithm> #include <queue> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; //重载小于运算符，按左端点从小到大排序 bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); //用一个小根堆来维护所有组的右端点 priority_queue<int, vector<int>, greater<int>> heap; for (int i = 0; i < n; i++){ auto t = Range[i]; if (heap.empty() || heap.top() >= t.l) //放不进去则新开一组 heap.push(t.r); else { heap.pop(); heap.push(t.r); //放进去并更新右端点 } } cout << heap.size() << endl; return 0; }\"]},\"254\":{\"h\":\"1.4 区间覆盖\",\"t\":[\"给定 N 个闭区间，以及一个线段区间，请你选择尽量少的区间，将指定线段区间完全覆盖。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; int L, R; cin >> L >> R; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); int res = 0; bool f = false; for (int i = 0; i < n; ){ //依次遍历每个区间 int j = i, r = -2e9; //j表示第几个区间 //遍历所有左端点在L的左边的区间，选出右端点最大的 while (j < n && Range[j].l <= L){ r = max(r, Range[j].r); j++; } if (r < L){ //如果所有右端点都小于L，则无解 res = -1; break; } res++; if (r >= R){ //循环出口 f = true; break; } //更新端点和遍历的区间 L = r; i = j; } if (!f) res = -1; cout << res << endl; return 0; }\"]},\"255\":{\"h\":\"1.5 区间合并\",\"t\":[\"#include <iostream> #include <cstdio> #include <algorithm> #include <vector> #define PII pair<int, int> using namespace std; const int N = 1e5 + 5; int n; vector <PII> nums, ans; void merge(vector<PII> &nums){ //按左端点排序 sort(nums.begin(), nums.end()); //l代表区间左端点，r代表区间右端点 int l = -2e9, r = -2e9; for (auto num : nums){ //如果两区间无法合并 if (r < num.first){ if (l != -2e9) ans.push_back({l, r});//将新的区间放入ans数组中 l = num.first, r = num.second;//更新区间 } //若两区间部分存在交集，小的合并到大的中 else r = max(r, num.second); } if (l != -2e9) ans.push_back({l, r}); } int main() { cin >> n; for (int i = 0; i < n; i++){ int l, r; cin >> l >> r; nums.push_back({l, r}); } merge(nums); cout << ans.size() << endl; return 0; }\"]},\"256\":{\"c\":[\"algorithm\"]},\"257\":{\"c\":[\"ACM\"]},\"258\":{\"h\":\"插件\",\"t\":[\"我做了一款vuepress的音乐可视化播放插件\",\"vuepress-plugin-player\",\"Vuepress 音乐播放器 & 沉浸式 源码：RayShineHub.github.io\",\"搭建 VuePress 博客，你可能会用到的一些插件\",\"博客搭建系列 - 冴羽\"]},\"259\":{\"c\":[\"教程\"]},\"260\":{\"c\":[\"Blog\"]},\"261\":{\"h\":\"二叉树的中序遍历\",\"t\":[\"二叉树的中序遍历\"]},\"262\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\",\"二叉树的 中序遍历: 从根节点开始，首先遍历左子树，然后访问根节点，最后访问右子树。然后在遍历左子树的时候，同样首先遍历左子节点的左子树，然后访问根节点，最后遍历左子节点的右子树...\"]},\"263\":{\"h\":\"思路一（递归）\",\"t\":[\"按照中序遍历的过程，对每个节点的进行相同的递归处理。先处理这个节点的左子树，再处理这个节点，最后处理这个节点的右子树。\",\"递归终点：当处理的节点是空节点时，说明该节点的子树是空子树，无法继续向下处理了，递归结束，向上返回结果。\",\"代码：\"]},\"264\":{\"h\":\"思路二（迭代）\",\"t\":[\"在递归的方法中，其实隐式地维护了一个栈结构：一直递归寻找最下层的左节点，直到找到并处理完后，再返回处理上一层找到的节点。类似于栈中的先进后出，最后找到的节点处理完后，才会处理之前找到的节点。\",\"因此利用迭代的思想，使用一个栈，迭代地寻找当前节点的左子节点，找到后处理并弹出，同理再处理该节点和该节点的右子节点。全部弹出后，最后返回上一层，即当前节点的父节点。此时父节点相当于当前节点，当前节点相当于左节点，继续上述迭代处理即可。\",\"代码：\"]},\"265\":{\"c\":[\"hot100\"]},\"266\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"267\":{\"h\":\"滑动窗口最大值\",\"t\":[\"239. 滑动窗口最大值 \"]},\"268\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\",\"返回 滑动窗口中的最大值 。\"]},\"269\":{\"h\":\"思路一（优先队列）\",\"t\":[\"使用优先队列，维护值和下标，窗口每次移动，判断当前最大值的位置，若已滑出窗口，则更新最大值，否则不更新。将每次移动的最大值保存在 ans[]中。\",\"代码：\",\"class Solution { public: vector<int> maxSlidingWindow(vector<int>& nums, int k) { int n = nums.size(); priority_queue<pair<int, int>> q; for (int i = 0; i < k; i++){ q.push({nums[i], i}); } vector<int> ans = {q.top().first}; for (int i = k; i < n; i++){ q.push({nums[i], i}); while (q.top().second <= i - k){ q.pop(); } ans.push_back(q.top().first); } return ans; } };\"]},\"270\":{\"h\":\"思路二（单调队列）\"},\"271\":{\"c\":[\"hot100\"]},\"272\":{\"c\":[\"滑动窗口\",\"优先队列\",\"单调队列\"]},\"273\":{\"h\":\"MinIO 安装与部署\",\"t\":[\"官方仓库\",\"GitHub：https://github.com/minio\",\"GItee镜像：https://gitee.com/mirrors/minio\",\"官网下载：https://www.minio.org.cn/download.shtml#/\"]},\"274\":{\"h\":\"Linux 安装启动\",\"t\":[\"下载安装包：\",\"wget https://dl.minio.org.cn/server/minio/release/linux-amd64/minio\",\"赋予可执行权限：\",\"chmod +x minio\",\"前台启动：\",\"MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address \\\":9001\\\"\",\"命令解释：\",\"MINIO_ROOT_USER=admin：指定MinIO的用户名\",\"MINIO_ROOT_PASSWORD=password：指定MinIO密码 （用户名和密码都可以省略，默认均为 minioadmin）\",\"./minio server：在 minio 所在目录下启动 minio 服务，可修改\",\"/mnt/data：指定数据存放位置，可以自定义修改\",\"--console-address \\\":9001\\\"：指定 MinIO 控制台的监听地址和端口\",\"后台启动：\",\"# 最简单的，只需要在最后面加上 & 即可，但关闭会话服务会停止 nohub ./minio server /mnt/data > /opt/minio/data/minio.log 2>&1 --console-address \\\":9001\\\" &\",\"命令解释：\",\"nohup：这是一个 Unix 命令，用于运行另一个命令在后台，并且忽略挂起（HUP）信号，即使你退出了终端或关闭了会话，该命令也会继续执行；\",\"> /opt/minio/data/minio.log：这部分是将标准输出（stdout）重定向到 /opt/minio/data/minio.log 文件，这意味着 MinIO 服务器的所有正常输出（如启动信息、状态更新等）都会被写入到这个日志文件中；\",\"2>&1：这部分是将标准错误输出（stderr）重定向到标准输出（stdout），即输出到 /opt/minio/data/minio.log 文件，这样，无论是标准输出还是错误输出，都会被写入到同一个日志文件中；\",\"&：这个符号是在命令的末尾，用于将命令放到后台执行，也就是即使你启动了 MinIO 服务器，你的终端或 shell 会话也不会被阻塞，你可以继续执行其他命令；\"]},\"275\":{\"h\":\"Docker 安装启动\",\"t\":[\"搜索 MinIO 镜像：\",\"docker search minio\",\"拉取 MinIO 镜像：\",\"docker pull minio/minio\",\"启动 MinIO 容器：\",\"docker run -p 9000:9000 -p 9001:9001 minio/minio server /mnt/docker/data --console-address \\\":9001\\\"\"]},\"276\":{\"h\":\"Windows 安装启动\",\"t\":[\"下载 Windows 版的 MinIO：\",\"https://dl.min.io/server/minio/release/windows-amd64/minio.exe\",\"进入到 minio.exe 所在的目录，导航栏输入 cmd 进入终端，执行：\",\"minio.exe server D:\\\\dev\\\\MinIO\\\\data --console-address \\\":9001\\\"\",\"启动 MinIO 服务，其中 D:\\\\dev\\\\MinIO\\\\data 是 MinIO 存储数据的目录路径\",\"在浏览器输入 http://localhost:9000/，登录 MinIO 服务器 web 管理后台\",\"提示\",\"默认用户名和密码都是 minioadmin\"]},\"277\":{\"h\":\"Windows 后台服务安装\",\"t\":[\"使用上述命令将 MinIO 在 Windows 上启动，关闭终端后服务就会停止。如果要使用 Windows 搭建 MinIO 服务器，需要将其注册为 Windows 服务。\",\"下载 WinSW-x64.exe：https://github.com/winsw/winsw/releases\",\"将 WinSW.exe 复制到自己指定的目录，重命名为 minio-server.exe.\",\"在同目录下创建 minio-server.xml。注意，xml 和 exe 必须同名。\",\"配置 minio-server.xml 文件，内容如下:\",\"<service> <id>minio-server</id> <name>minio-server</name> <description>minio文件存储服务</description> <executable>%BASE%\\\\minio.exe</executable> <arguments>server \\\"%BASE%\\\\data\\\"</arguments> <logpath>%BASE%\\\\logs</logpath> <log mode=\\\"roll-by-size-time\\\"> <sizeThreshold>10240</sizeThreshold> <pattern>yyyyMMdd</pattern> <autoRollAtTime>00:00:00</autoRollAtTime> <zipOlderThanNumDays>5<zipOlderThanNumDays> <zipDateFormat>yyyyMMdd</zipDateFormat> </log> </service>\",\"执行 cmd 命令注册系统服务\",\"minio-server.exe install\",\"卸载服务\",\"minio-server.exe uninstall\"]},\"278\":{\"c\":[\"中间件\"]},\"279\":{\"c\":[\"MinIO\"]},\"280\":{\"h\":\"MinIO 概述\",\"t\":[\"官网链接\",\"MinIO官网：https://min.io/\",\"中文官网：http://minio.org.cn/\",\"MinIO 是一个高性能的分布式对象存储系统，基于 Apache License v2.0 开源协议，兼容亚马逊 S3 云存储服务接口，非常适合存储大容量的数据，包括但不限于：\",\"文本数据：新闻报道、社交媒体文章、博客......\",\"语音数据：音频形式存储的数据，语音mp3文件......\",\"图像数据：各种图片......\",\"视频数据：各种视频、电影......\",\"非结构化数据：没有明确结构的数据，比如社交评论、日志文件......\"]},\"281\":{\"h\":\"什么是对象存储？\",\"t\":[\"对象存储（Object Storage）是一种数据存储架构，它以对象为单位来处理、存储和检索数据，每个对象都包含了数据本身以及元数据，适合存放任意类型的文件。通常通过基于 HTTP 或 HTTPS 协议的 API（应用程序编程接口）进行数据读写。常见的有阿里云对象存储服务（OSS）、腾讯云对象存储（COS）等。\",\"所以基于对象的形式， MinIO 存储的元数据主要包括对象的描述信息，如用户（account）、存储桶（bucket）以及存储桶索引（bucket index）等。\",\"对于企业来说，可以使用各种公有云提供的 OSS 服务，将业务数据存储在云上，既能节省存储成本，也能使用云存储服务提供的 API 接口，方便使用和管理数据。但对于数据传输的安全性和及时性有较高要求的业务来说，使用公有云的 OSS 服务，就要付出较高的公网带宽传输成本，以及对数据安全的保障服务。在这种情况下，利用 MinIO 轻便、高性能、可拓展性的特点，企业可以快速搭建自己的内部对象存储服务。\",\"当然，对于个人来说，MinIO 是 100% 开源的，这就意味着个人也可以基于 MinIO 搭建自己专属的对象存储服务器。\"]},\"282\":{\"h\":\"特点\",\"t\":[\"文档全面： MinIO 作为一款基于 Golang 语言开发的一款高性能的分布式式存储方案的开源项目，有十分完善的官方文档。\",\"MinIO 文档\",\"中文文档地址：https://www.minio.org.cn/docs/minio/\",\"高性能： MinIO 号称是目前速度最快的对象存储服务器。在标准硬件上，对象存储的读/写速度最高可以高达 183GB/s 和 171GB/s。对象存储可以作为主存储层，用来处理 Spark、Presto、TensorFlow、HAO.ai 等各种复杂工作负载以及成为 Hadoop HDFS 的替代品。\",\"云原生： 容器化、基于 K8S 的编排、多租户支持。 用作云原生应用程序的主要存储，和传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。\",\"可拓展： 不同 MinIO 集群可以组成联邦，并形成一个全局的命名空间，并且支持跨越多个数据中心。 并且除了 MinIO 自己的文件系统，还支持 DAS、 JBODs、NAS、Google 云存储和 Azure Blob 存储。\",\"Amazon S3 标准兼容: 亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界内大家都认可的标准。MinIO 在很早的时候就采用了 S3 兼容协议，并且 MinIO 是第一个支持 S3 Select 的产品。 使用 Amazon S3 v2 / v4 API，可以使用 MinIO SDK，MinIO Client，AWS SDK 和 AWS CLI 访问 MinIO 服务器。\",\"支持全面： 目前 MinIO 支持市面主流的开发语言并且可以通过 SDK 快速集成快速集成使用。\",\"常用语言的 SDK\",\"GO SDK：https://github.com/minio/minio-go\",\"Java SDK：https://github.com/minio/minio-java\",\"Python SDK：https://github.com/minio/minio-py\",\"可视化管理界面： MinIO 除了通过传统的命令行进行操作之外，还提供可视化的操作管理界面，在服务安装后，可以直接通过浏览器登录系统，完成文件夹、文件的管理，非常方便使用。\",\"数据存储高容错： Minio 的存储机制使用纠删码（Erasure Code）和校验和（CheckSum）。 校验和：保护数据免受硬件故障和无声数据损坏。 纠删码：是一种恢复丢失和损坏数据的数学算法。通过数学算法将数据分割成多个数据块和校验块，并将这些块分散存储在不同的磁盘上。这种机制使得即使部分磁盘发生故障，也能通过剩余的数据块和校验块恢复原始数据，从而提高系统的可靠性和容错能力。 具体地，MinIO 使用 Reed-Solomon 码作为其纠删码算法，将一个对象拆分成 N/2 份数据和 N/2 份奇偶校验块。如果是 12 块盘，一个对象会被分成 6 个数据块、 6 个奇偶校验块，可以丢失任意 6 块盘（不管其是存放的数据块还是奇偶校验块），仍可以从剩下的盘中的数据进行恢复。 这样的设计，保证了即使在最坏的情况，即丢失一半数量的硬盘的情况下仍能保证数据的安全性。\"]},\"283\":{\"c\":[\"中间件\"]},\"284\":{\"c\":[\"MinIO\"]},\"285\":{\"h\":\"SpringBoot 整合 MinIO\"},\"286\":{\"h\":\"引入依赖\",\"t\":[\"<dependency> <groupId>io.minio</groupId> <artifactId>minio</artifactId> <version>8.5.9</version> </dependency>\"]},\"287\":{\"h\":\"配置文件\",\"t\":[\"MinIO 中的 Bucket、Object\",\"Bucket 是存储 Object 的逻辑空间，每个 Bucket 之间的数据是相互隔离的，对用户而言，相当于存放文件的顶层文件夹\",\"Object 是存储到 MinIO 的基本对象，对用户而言，相当于文件\",\"SpringBoot 使用 MinIO 非常方便，只需要创建 MinIOClient 即可，后续通过调用 API 对 MinIO 服务进行配置和操作。\",\"在 application.yml 中配置 MinIO 连接信息\",\"minio: endpoint: http://localhost:9000 # 服务器地址和端口 accessKey: minioadmin # minio用户名 secretKey: minioadmin # minio密码 bucket: user-bucket # 使用的存储桶（可选）\",\"添加 MinIO 实体类\",\"@Data @Component @ConfigurationProperties(prefix = \\\"minio\\\") public class MinIOInfo { private String endpoint; private String accessKey; private String secretKey; private String bucket; }\",\"将 MinIOClient 注册为 Bean 对象，后续通过注入 minioClient 对象即可实现对 MinIO 的操作。\",\"@Configuration public class Config { @Resource private MinIOInfo minIOInfo; @Bean public MinioClient minioClient() { //链式编程，构建MinioClient对象 return MinioClient.builder() .endpoint(minIOInfo.getEndpoint()) .credentials(minIOInfo.getAccessKey(), minIOInfo.getSecretKey()) .build(); } }\",\"支持多线程\",\"MinioClient 对象是单例的，那么有没有线程安全问题呢？\",\"答案是：没有线程安全问题。MinIO 官方团队表示，可以多个线程共同使用一个 MinIOClient 对象。\"]},\"288\":{\"h\":\"MinioClient 的常用 API\"},\"289\":{\"h\":\"Bucket 操作\",\"t\":[\"bucketExists()：用于检查指定的存储桶是否存在，返回布尔值，表示存储桶是否存在\",\" void test01() throws Exception { boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(\\\"myfile\\\").build()); System.out.println(\\\"myfile目录是否存在：\\\" + isBucketExists); }\",\"makeBucket()：用于创建一个新的存储桶（bucket），需要指定存储桶的名称\",\" void test02() throws Exception { String bucketName = \\\"myfile2\\\"; boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build()); if (!isBucketExists) { minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build()); } else { System.out.println(\\\"bucket已经存在，不需要创建\\\"); } String policyJsonString = \\\"{\\\\\\\"Version\\\\\\\" : \\\\\\\"2012-10-17\\\\\\\",\\\\\\\"Statement\\\\\\\":[{\\\\\\\"Sid\\\\\\\":\\\\\\\"PublicRead\\\\\\\",\\\\\\\"Effect\\\\\\\":\\\\\\\"Allow\\\\\\\",\\\\\\\"Principal\\\\\\\":{\\\\\\\"AWS\\\\\\\":\\\\\\\"*\\\\\\\"},\\\\\\\"Action\\\\\\\":[\\\\\\\"s3:GetObject\\\\\\\"],\\\\\\\"Resource\\\\\\\":[\\\\\\\"arn:aws:s3:::\\\" + bucketName + \\\"/*\\\\\\\"]}]}\\\"; //创建存储桶的时候，设置该存储桶里面的文件的访问策略，运行公开的读； minioClient.setBucketPolicy(SetBucketPolicyArgs.builder() .bucket(bucketName) .config(policyJsonString)//json串，里面是访问策略 .build()); }\",\"listBuckets()：用于列出用户有权访问的所有存储桶，返回存储桶的列表\",\" void test03() throws Exception { List<Bucket> bucketList = minioClient.listBuckets(); bucketList.forEach(bucket -> { System.out.println(bucket.name() + \\\" -- \\\" + bucket.creationDate()); }); }\",\"removeBucket()：用于删除一个已存在的存储桶（bucket），删除失败会抛出异常\",\" void test04() throws Exception { minioClient.removeBucket(RemoveBucketArgs.builder().bucket(\\\"myfile2\\\").build()); }\"]},\"290\":{\"h\":\"Object 操作\",\"t\":[\"putObject()：用于上传文件到指定的存储桶\",\" void test05() throws Exception { File file = new File(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\"); // 文件路径 ObjectWriteResponse objectWriteResponse = minioClient.putObject(PutObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .stream(new FileInputStream(file), file.length(), -1) // 使用stream流读取文件，自动获取文件大小 .build() ); System.out.println(objectWriteResponse); ObjectWriteResponse objectWriteResponse2 = minioClient.uploadObject(UploadObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test2.jpg\\\") .filename(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\") // 指定文件路径 .build() ); System.out.println(objectWriteResponse); }\",\"statObject()：用于检查指定的对象（文件）的状态\",\" void test06() throws Exception { StatObjectResponse statObjectResponse = minioClient.statObject(StatObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(statObjectResponse); }\",\"getPresignedObjectUrl()：用于生成一个对象（文件）的签名URL，以便可以通过HTTP访问\",\" void test07() throws Exception { String presignedObjectUrl = minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .expiry(3, TimeUnit.MINUTES) .method(Method.GET) .build() ); System.out.println(presignedObjectUrl); }\",\"getObject()：用于从指定的存储桶中下载文件\",\" void test08() throws Exception { GetObjectResponse getObjectResponse = minioClient.getObject(GetObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(getObjectResponse.transferTo(new FileOutputStream(\\\"D:\\\\\\\\MinIO\\\\\\\\123.jpg\\\"))); }\",\"listObjects()：用于列出指定存储桶中的所有对象（文件）\",\" void test09() throws Exception { Iterable<Result<Item>> listObjects = minioClient.listObjects(ListObjectsArgs.builder() .bucket(\\\"myfile\\\") .build() ); listObjects.forEach( itemResult -> { try { Item item = itemResult.get(); System.out.println(item.objectName()); } catch (Exception e) { throw new RuntimeException(e); } }); }\",\"removeObject()：用于删除指定存储桶中的对象，需要指定存储桶名称和对象键\",\" void test10() throws Exception { minioClient.removeObject(RemoveObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); }\"]},\"291\":{\"c\":[\"中间件\"]},\"292\":{\"c\":[\"MinIO\"]},\"293\":{\"h\":\"如何实现 List 转 Map 后依然有序？\"},\"294\":{\"c\":[\"杂项\"]},\"295\":{\"c\":[\"工作笔记\"]},\"296\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"297\":{\"h\":\"For Offer\"},\"298\":{\"h\":\"Note\"},\"299\":{\"h\":\"Template\"},\"300\":{\"h\":\"Tool Build\"},\"301\":{\"h\":\"Hot 100\"},\"302\":{\"h\":\"Leetcode\"},\"303\":{\"h\":\"Min IO\"},\"304\":{\"h\":\"Middleware\"},\"305\":{\"h\":\"Work Note\"},\"306\":{\"h\":\"Sundry\"}},\"dirtCount\":0,\"index\":[[\"工作笔记\",{\"2\":{\"295\":1}}],[\"杂项\",{\"2\":{\"294\":1}}],[\"里面是访问策略\",{\"1\":{\"289\":1}}],[\"里面各个数字有多少个\",{\"1\":{\"128\":1}}],[\"链式编程\",{\"1\":{\"287\":1}}],[\"链表\",{\"1\":{\"66\":1}}],[\"注册为\",{\"1\":{\"287\":1}}],[\"注意multimap不支持此操作\",{\"1\":{\"245\":1}}],[\"注意乘除的先后顺序\",{\"1\":{\"199\":1}}],[\"注意特征\",{\"1\":{\"108\":1}}],[\"注意\",{\"1\":{\"53\":1,\"158\":1,\"233\":1,\"277\":1}}],[\"实体类\",{\"1\":{\"287\":1}}],[\"实现一些简洁的操作\",{\"1\":{\"40\":1}}],[\"添加\",{\"1\":{\"287\":1}}],[\"添加一条边a\",{\"1\":{\"166\":1}}],[\"连接信息\",{\"1\":{\"287\":1}}],[\"连通图\",{\"1\":{\"183\":1}}],[\"连通这两个顶点\",{\"1\":{\"182\":1}}],[\"引入依赖\",{\"0\":{\"286\":1}}],[\"仍可以从剩下的盘中的数据进行恢复\",{\"1\":{\"282\":1}}],[\"仍然为前闭后开\",{\"1\":{\"246\":1}}],[\"块盘\",{\"1\":{\"282\":2}}],[\"份奇偶校验块\",{\"1\":{\"282\":1}}],[\"份数据和\",{\"1\":{\"282\":1}}],[\"码作为其纠删码算法\",{\"1\":{\"282\":1}}],[\"纠删码\",{\"1\":{\"282\":1}}],[\"保证了即使在最坏的情况\",{\"1\":{\"282\":1}}],[\"保护数据免受硬件故障和无声数据损坏\",{\"1\":{\"282\":1}}],[\"保存节点信息\",{\"1\":{\"133\":1}}],[\"校验和\",{\"1\":{\"282\":1}}],[\"目前\",{\"1\":{\"282\":1}}],[\"目录\",{\"0\":{\"2\":1,\"9\":1}}],[\"支持多线程\",{\"1\":{\"287\":1}}],[\"支持市面主流的开发语言并且可以通过\",{\"1\":{\"282\":1}}],[\"支持全面\",{\"1\":{\"282\":1}}],[\"支持比较运算\",{\"1\":{\"245\":2}}],[\"兼容协议\",{\"1\":{\"282\":1}}],[\"兼容亚马逊\",{\"1\":{\"280\":1}}],[\"亚马逊云的\",{\"1\":{\"282\":1}}],[\"自己的文件系统\",{\"1\":{\"282\":1}}],[\"自动获取文件大小\",{\"1\":{\"290\":1}}],[\"自动获得\",{\"1\":{\"126\":1}}],[\"自动得到右端点\",{\"1\":{\"126\":1}}],[\"集群可以组成联邦\",{\"1\":{\"282\":1}}],[\"集合数量+1\",{\"1\":{\"214\":1}}],[\"云存储和\",{\"1\":{\"282\":1}}],[\"云存储服务接口\",{\"1\":{\"280\":1}}],[\"云原生应用程序需要更高的吞吐量和更低的延迟\",{\"1\":{\"282\":1}}],[\"云原生\",{\"1\":{\"282\":1}}],[\"写速度最高可以高达\",{\"1\":{\"282\":1}}],[\"写法示例\",{\"1\":{\"38\":1}}],[\"号称是目前速度最快的对象存储服务器\",{\"1\":{\"282\":1}}],[\"号点的判断中需要进行\",{\"1\":{\"175\":1}}],[\"语言开发的一款高性能的分布式式存储方案的开源项目\",{\"1\":{\"282\":1}}],[\"语音mp3文件\",{\"1\":{\"280\":1}}],[\"语音数据\",{\"1\":{\"280\":1}}],[\"企业可以快速搭建自己的内部对象存储服务\",{\"1\":{\"281\":1}}],[\"轻便\",{\"1\":{\"281\":1}}],[\"利用\",{\"1\":{\"281\":1}}],[\"利用迭代器\",{\"1\":{\"246\":1}}],[\"既能节省存储成本\",{\"1\":{\"281\":1}}],[\"腾讯云对象存储\",{\"1\":{\"281\":1}}],[\"应用程序编程接口\",{\"1\":{\"281\":1}}],[\"应用程序服务器中间件\",{\"1\":{\"15\":1}}],[\"通常通过基于\",{\"1\":{\"281\":1}}],[\"通过数学算法将数据分割成多个数据块和校验块\",{\"1\":{\"282\":1}}],[\"通过定理求组合数c\",{\"1\":{\"211\":1}}],[\"通过预处理逆元的方式求组和数\",{\"0\":{\"210\":1}}],[\"通过初等行变换把\",{\"1\":{\"207\":1}}],[\"通过一个连接起来\",{\"1\":{\"180\":1}}],[\"通过下式\",{\"1\":{\"54\":1}}],[\"通过替换旧值为向量元素分配新值\",{\"1\":{\"37\":1}}],[\"通过\",{\"1\":{\"34\":3,\"212\":1}}],[\"什么是对象存储\",{\"0\":{\"281\":1}}],[\"日志文件\",{\"1\":{\"280\":1}}],[\"电影\",{\"1\":{\"280\":1}}],[\"视频数据\",{\"1\":{\"280\":1}}],[\"音频形式存储的数据\",{\"1\":{\"280\":1}}],[\"音乐播放器\",{\"1\":{\"258\":1}}],[\"社交媒体文章\",{\"1\":{\"280\":1}}],[\"新闻报道\",{\"1\":{\"280\":1}}],[\"新节点的下一节点指向\",{\"1\":{\"226\":1}}],[\"概述\",{\"0\":{\"280\":1}}],[\"卸载服务\",{\"1\":{\"277\":1}}],[\"配置文件\",{\"0\":{\"287\":1}}],[\"配置\",{\"1\":{\"277\":1}}],[\"复制到自己指定的目录\",{\"1\":{\"277\":1}}],[\"提示\",{\"1\":{\"276\":1}}],[\"管理后台\",{\"1\":{\"276\":1}}],[\"管理计算资源和网络通信\",{\"1\":{\"15\":1}}],[\"登录\",{\"1\":{\"276\":1}}],[\"执行\",{\"1\":{\"276\":1,\"277\":1}}],[\"导航栏输入\",{\"1\":{\"276\":1}}],[\"版的\",{\"1\":{\"276\":1}}],[\"版本2\",{\"0\":{\"142\":1}}],[\"版本1\",{\"0\":{\"141\":1}}],[\"启动\",{\"1\":{\"275\":1,\"276\":1}}],[\"拉取\",{\"1\":{\"275\":1}}],[\"拉链法\",{\"0\":{\"242\":1}}],[\"镜像\",{\"1\":{\"275\":2}}],[\"文档\",{\"1\":{\"282\":1}}],[\"文档全面\",{\"1\":{\"282\":1}}],[\"文本数据\",{\"1\":{\"280\":1}}],[\"文件路径\",{\"1\":{\"290\":1}}],[\"文件的管理\",{\"1\":{\"282\":1}}],[\"文件\",{\"1\":{\"274\":2,\"277\":1,\"290\":3}}],[\"文章\",{\"1\":{\"20\":1}}],[\"信号\",{\"1\":{\"274\":1}}],[\"命令注册系统服务\",{\"1\":{\"277\":1}}],[\"命令\",{\"1\":{\"274\":1}}],[\"命令解释\",{\"1\":{\"274\":2}}],[\"控制台的监听地址和端口\",{\"1\":{\"274\":1}}],[\"控制精度\",{\"1\":{\"207\":1}}],[\"服务进行配置和操作\",{\"1\":{\"287\":1}}],[\"服务器地址和端口\",{\"1\":{\"287\":1}}],[\"服务器\",{\"1\":{\"274\":1,\"276\":1,\"277\":1,\"282\":1}}],[\"服务器的所有正常输出\",{\"1\":{\"274\":1}}],[\"服务\",{\"1\":{\"274\":1,\"276\":1,\"277\":1,\"281\":2}}],[\"赋予可执行权限\",{\"1\":{\"274\":1}}],[\"官方团队表示\",{\"1\":{\"287\":1}}],[\"官方仓库\",{\"1\":{\"273\":1}}],[\"官网链接\",{\"1\":{\"280\":1}}],[\"官网下载\",{\"1\":{\"273\":1}}],[\"安装启动\",{\"0\":{\"274\":1,\"275\":1,\"276\":1}}],[\"安装与部署\",{\"0\":{\"273\":1}}],[\"安全中间件\",{\"1\":{\"15\":1}}],[\"窗口每次移动\",{\"1\":{\"269\":1}}],[\"滑动窗口\",{\"2\":{\"272\":1}}],[\"滑动窗口中的最大值\",{\"1\":{\"268\":1}}],[\"滑动窗口每次只向右移动一位\",{\"1\":{\"268\":1}}],[\"滑动窗口最大值\",{\"0\":{\"267\":1},\"1\":{\"267\":1}}],[\"才会处理之前找到的节点\",{\"1\":{\"264\":1}}],[\"才为\",{\"1\":{\"158\":1}}],[\"才为1\",{\"1\":{\"158\":1}}],[\"教程\",{\"2\":{\"259\":1}}],[\"冴羽\",{\"1\":{\"258\":1}}],[\"博客搭建系列\",{\"1\":{\"258\":1}}],[\"博客\",{\"1\":{\"258\":1,\"280\":1}}],[\"博弈论\",{\"0\":{\"215\":1}}],[\"搭建自己专属的对象存储服务器\",{\"1\":{\"281\":1}}],[\"搭建\",{\"1\":{\"258\":1,\"277\":1}}],[\"源码\",{\"1\":{\"258\":1}}],[\"沉浸式\",{\"1\":{\"258\":1}}],[\"插件\",{\"0\":{\"258\":1}}],[\"插入的数是一个pair\",{\"1\":{\"245\":1}}],[\"插入一个元素\",{\"1\":{\"245\":1}}],[\"插入一个数\",{\"1\":{\"240\":1,\"245\":1}}],[\"插入一个字符串\",{\"1\":{\"235\":1}}],[\"插入\",{\"1\":{\"125\":1}}],[\"放进去并更新右端点\",{\"1\":{\"253\":1}}],[\"放不进去则新开一组\",{\"1\":{\"253\":1}}],[\"放入高位\",{\"1\":{\"147\":1}}],[\"唯一的区别是查找第一个大于\",{\"1\":{\"246\":1}}],[\"唯一不同的在于\",{\"1\":{\"234\":1}}],[\"大致相同\",{\"1\":{\"246\":1}}],[\"大于某个与inf`\",{\"1\":{\"175\":1}}],[\"传入比较函数\",{\"1\":{\"246\":1}}],[\"传入t的地址\",{\"1\":{\"150\":1}}],[\"随机打乱\",{\"1\":{\"246\":1}}],[\"元素存放在下标\",{\"1\":{\"246\":4}}],[\"圧位\",{\"1\":{\"245\":1}}],[\"增删改查的时间复杂度是\",{\"1\":{\"245\":1}}],[\"增广矩阵\",{\"1\":{\"207\":1}}],[\"增广路\",{\"1\":{\"184\":1}}],[\"本身就是有序的\",{\"1\":{\"245\":1}}],[\"本题有自定义校验器\",{\"1\":{\"92\":1}}],[\"红黑树\",{\"1\":{\"245\":1}}],[\"弹出栈顶元素\",{\"1\":{\"245\":1}}],[\"弹出堆顶元素\",{\"1\":{\"245\":1}}],[\"弹出队头元素\",{\"1\":{\"245\":1}}],[\"弹出队尾元素\",{\"1\":{\"233\":1}}],[\"默认用户名和密码都是\",{\"1\":{\"276\":1}}],[\"默认均为\",{\"1\":{\"274\":1}}],[\"默认按\",{\"1\":{\"245\":1}}],[\"默认是大根堆\",{\"1\":{\"245\":1}}],[\"默认染成\",{\"1\":{\"183\":1}}],[\"优先队列\",{\"0\":{\"269\":1},\"1\":{\"245\":1},\"2\":{\"272\":1}}],[\"起始下标\",{\"1\":{\"245\":1}}],[\"起点的入度为0\",{\"1\":{\"170\":1}}],[\"清空\",{\"1\":{\"245\":1}}],[\"清零\",{\"1\":{\"158\":1}}],[\"溢出的结果就是取模的结果\",{\"1\":{\"244\":1}}],[\"核心思想\",{\"1\":{\"244\":1}}],[\"核心思路\",{\"1\":{\"195\":1}}],[\"哈希函数\",{\"1\":{\"243\":1}}],[\"哈希函数离散化\",{\"1\":{\"242\":1}}],[\"哈希表\",{\"0\":{\"241\":1},\"1\":{\"245\":1}}],[\"跟两个儿子比较大小\",{\"1\":{\"240\":1}}],[\"及其映射关系\",{\"1\":{\"240\":1}}],[\"根节点小于等于左右两个子节点\",{\"1\":{\"240\":1}}],[\"根据具体问题\",{\"1\":{\"239\":1}}],[\"根据容斥原理\",{\"1\":{\"214\":1}}],[\"长得非常平衡\",{\"1\":{\"240\":1}}],[\"长度为1的区间为0\",{\"1\":{\"126\":1}}],[\"长度+左端点\",{\"1\":{\"126\":1}}],[\"长度修改为5\",{\"1\":{\"26\":1}}],[\"长度\",{\"1\":{\"26\":2}}],[\"堆是一棵\",{\"1\":{\"240\":1}}],[\"堆\",{\"0\":{\"240\":1}}],[\"堆优化版的dijkstra算法\",{\"0\":{\"174\":1},\"1\":{\"172\":1}}],[\"又是空节点\",{\"1\":{\"235\":1}}],[\"打印开头下标\",{\"1\":{\"234\":1}}],[\"我做了一款vuepress的音乐可视化播放插件\",{\"1\":{\"258\":1}}],[\"我用数组记录一下你的位置\",{\"1\":{\"234\":1}}],[\"我们只关心\",{\"1\":{\"234\":1}}],[\"我们关心对于每个不同的下标\",{\"1\":{\"234\":1}}],[\"我们需要找出\",{\"1\":{\"234\":1}}],[\"我们讨论的博弈问题一般都只考虑理想情况\",{\"1\":{\"216\":1}}],[\"我们把这种游戏称为nim博弈\",{\"1\":{\"216\":1}}],[\"我们就找到了目标值\",{\"1\":{\"140\":1}}],[\"我们就称这个区间\",{\"1\":{\"45\":1}}],[\"我们将这样的一种表示称为正整数\",{\"1\":{\"127\":1}}],[\"我们的目的是通过交换\",{\"1\":{\"75\":1}}],[\"我们其实是希望\",{\"1\":{\"66\":1}}],[\"我们可能习惯性地认为树的高度就是\",{\"1\":{\"66\":1}}],[\"我们可以通过\",{\"1\":{\"46\":1}}],[\"我们先将它们的父节点设为自己\",{\"1\":{\"61\":1}}],[\"我们用一个数组\",{\"1\":{\"61\":1}}],[\"我们直接用二维数组读入数据\",{\"1\":{\"54\":1}}],[\"我们通常是把它当作一个结构体使用\",{\"1\":{\"40\":1}}],[\"非结构化数据\",{\"1\":{\"280\":1}}],[\"非常方便\",{\"1\":{\"287\":1}}],[\"非常方便使用\",{\"1\":{\"282\":1}}],[\"非常适合存储大容量的数据\",{\"1\":{\"280\":1}}],[\"非常有意思的说法是\",{\"1\":{\"234\":1}}],[\"非匹配边\",{\"1\":{\"184\":1}}],[\"能走多远\",{\"1\":{\"234\":1}}],[\"能更快一点点\",{\"1\":{\"110\":1}}],[\"串每一个特定的下标\",{\"1\":{\"234\":1}}],[\"队头的值\",{\"1\":{\"232\":1}}],[\"队头不断出队\",{\"1\":{\"176\":1}}],[\"队列里面存的是下标\",{\"1\":{\"233\":1}}],[\"队列\",{\"0\":{\"231\":1},\"1\":{\"245\":1}}],[\"永远不会被输出\",{\"1\":{\"230\":2}}],[\"向上返回结果\",{\"1\":{\"263\":1}}],[\"向栈顶插入一个元素\",{\"1\":{\"245\":1}}],[\"向栈顶插入一个数\",{\"1\":{\"229\":1}}],[\"向队尾插入一个元素\",{\"1\":{\"245\":1}}],[\"向队尾插入一个数\",{\"1\":{\"232\":1}}],[\"向哈希表中插入一个数\",{\"1\":{\"242\":1}}],[\"向中间移动\",{\"1\":{\"137\":1}}],[\"普通队列\",{\"0\":{\"232\":1}}],[\"普通栈\",{\"0\":{\"229\":1}}],[\"普通数组\",{\"1\":{\"39\":1}}],[\"栈顶的值\",{\"1\":{\"229\":1}}],[\"栈数组从0开始\",{\"1\":{\"229\":1}}],[\"栈\",{\"0\":{\"228\":1},\"1\":{\"245\":1}}],[\"双端队列\",{\"1\":{\"245\":1}}],[\"双链表\",{\"0\":{\"227\":1}}],[\"双指针算法\",{\"0\":{\"160\":1}}],[\"主要用来优化某些问题\",{\"1\":{\"227\":1}}],[\"主要应用\",{\"1\":{\"226\":1}}],[\"主要步骤\",{\"1\":{\"137\":1,\"138\":1}}],[\"任何一个公平组合游戏都可以转化为有向图游戏\",{\"1\":{\"218\":1}}],[\"任何一个合数都能写成几个质数相乘的形式\",{\"1\":{\"193\":1}}],[\"图像数据\",{\"1\":{\"280\":1}}],[\"图中有一个唯一的起点\",{\"1\":{\"218\":1}}],[\"图的拓扑序列是针对于有向图而言的\",{\"1\":{\"170\":1}}],[\"胜负判定也比较复杂\",{\"1\":{\"217\":1}}],[\"公平组合游戏icg\",{\"0\":{\"217\":1}}],[\"整合\",{\"0\":{\"285\":1}}],[\"整个有向图游戏g的sg函数值被定义为有向图游戏起点s的sg函数值\",{\"1\":{\"220\":1}}],[\"整局游戏第一个行动的称为先手\",{\"1\":{\"216\":1}}],[\"整数分解\",{\"1\":{\"191\":1}}],[\"整数二分\",{\"0\":{\"144\":1}}],[\"留给后手都是一个必胜状态时\",{\"1\":{\"216\":1}}],[\"留给后手是一个必败状态时\",{\"1\":{\"216\":1}}],[\"某一个操作\",{\"1\":{\"216\":1}}],[\"必须同名\",{\"1\":{\"277\":1}}],[\"必须首先判断两个数是否相等\",{\"1\":{\"158\":1}}],[\"必败状态\",{\"1\":{\"216\":1}}],[\"必胜状态\",{\"1\":{\"216\":1}}],[\"必胜状态和必败状态\",{\"1\":{\"216\":1}}],[\"跳出这轮循环\",{\"1\":{\"214\":1}}],[\"选出右端点最大的\",{\"1\":{\"254\":1}}],[\"选中奇数个集合\",{\"1\":{\"214\":1}}],[\"选中一个集合\",{\"1\":{\"214\":1}}],[\"选中的集合数量\",{\"1\":{\"214\":1}}],[\"选中集合对应质数的乘积\",{\"1\":{\"214\":1}}],[\"选了某个节点就不能选父节点和子节点\",{\"1\":{\"133\":1}}],[\"至少选中一个集合\",{\"1\":{\"214\":1}}],[\"至少需要进行多少次操作\",{\"1\":{\"125\":1}}],[\"至少需要移动多少次\",{\"1\":{\"71\":1}}],[\"卡特兰数\",{\"0\":{\"213\":1}}],[\"方便使用和管理数据\",{\"1\":{\"281\":1}}],[\"方法\",{\"1\":{\"212\":1}}],[\"方程的两边同时乘上一个非00数不改变方程的解\",{\"1\":{\"207\":1}}],[\"方程组中的系数为实数\",{\"1\":{\"207\":1}}],[\"定理\",{\"1\":{\"211\":1,\"216\":1,\"221\":1}}],[\"定理求组合数\",{\"0\":{\"211\":1}}],[\"定义成小根堆的方式\",{\"1\":{\"245\":1}}],[\"定义有向图游戏g\",{\"1\":{\"221\":1}}],[\"定义sg\",{\"1\":{\"220\":1}}],[\"定义mex\",{\"1\":{\"219\":1}}],[\"定义一个小根堆\",{\"1\":{\"174\":1}}],[\"定义一个借位的情况\",{\"1\":{\"148\":1}}],[\"定义一个二维动态数组\",{\"1\":{\"25\":1}}],[\"定义区间为闭区间\",{\"1\":{\"143\":1}}],[\"定义\",{\"1\":{\"46\":1,\"158\":2}}],[\"定义时初始化\",{\"1\":{\"25\":1}}],[\"卢卡斯\",{\"0\":{\"211\":1}}],[\"预处理范围内的所有质数\",{\"1\":{\"212\":1}}],[\"预处理阶乘的余数和阶乘逆元的余数\",{\"1\":{\"210\":1}}],[\"预处理出\",{\"1\":{\"203\":1}}],[\"乘积大于n\",{\"1\":{\"214\":1}}],[\"乘任意一个\",{\"1\":{\"210\":1}}],[\"乘法逆元\",{\"1\":{\"210\":1}}],[\"乘法逆元的定义\",{\"1\":{\"210\":1}}],[\"≡\",{\"1\":{\"210\":1}}],[\"费马小定理\",{\"1\":{\"210\":1}}],[\"∗1​=b\",{\"1\":{\"211\":1}}],[\"∗1∗b\",{\"1\":{\"211\":1}}],[\"∗b\",{\"1\":{\"211\":1}}],[\"∗infact\",{\"1\":{\"210\":2}}],[\"∗\",{\"1\":{\"210\":1,\"211\":9}}],[\"∗y\",{\"1\":{\"205\":1}}],[\"未确定阶梯型的行\",{\"1\":{\"207\":1}}],[\"未染色的点\",{\"1\":{\"183\":1}}],[\"未染色\",{\"1\":{\"183\":1}}],[\"适用题型\",{\"1\":{\"209\":1}}],[\"适用于求解包含\",{\"1\":{\"207\":1}}],[\"适合存放任意类型的文件\",{\"1\":{\"281\":1}}],[\"适合稀疏图\",{\"1\":{\"172\":1}}],[\"适合稠密图\",{\"1\":{\"172\":1}}],[\"阶梯型矩阵\",{\"1\":{\"207\":1}}],[\"化为\",{\"1\":{\"207\":1}}],[\"初等行\",{\"1\":{\"207\":1}}],[\"初始时队列里只有起始点\",{\"1\":{\"176\":1}}],[\"初始值\",{\"1\":{\"126\":1}}],[\"初始最坏情况下一只猫一辆车\",{\"1\":{\"106\":1}}],[\"初始高度为1\",{\"1\":{\"66\":1}}],[\"初始根节点为它自己\",{\"1\":{\"66\":1}}],[\"初始化find\",{\"1\":{\"239\":1}}],[\"初始化各个顶点在不同的集合中\",{\"1\":{\"182\":1}}],[\"初始化大于1的区间为最大\",{\"1\":{\"126\":1}}],[\"初始化父亲为它自己\",{\"1\":{\"65\":1}}],[\"初始化\",{\"0\":{\"61\":1},\"1\":{\"46\":1,\"59\":1,\"66\":2,\"137\":1,\"166\":1,\"179\":1,\"226\":1,\"227\":1,\"237\":1,\"238\":1,\"239\":1,\"244\":1}}],[\"初始化为它自身\",{\"1\":{\"240\":1}}],[\"初始化为\",{\"1\":{\"38\":1}}],[\"扩展欧几里得\",{\"1\":{\"206\":1}}],[\"扩展欧几里得算法\",{\"0\":{\"204\":1}}],[\"∀i∈\",{\"1\":{\"206\":1}}],[\"事实上\",{\"1\":{\"205\":1}}],[\"事务中间件\",{\"1\":{\"15\":1}}],[\"显然无解\",{\"1\":{\"205\":1}}],[\"=1\",{\"1\":{\"205\":1}}],[\"−\",{\"1\":{\"205\":1}}],[\"−1\",{\"1\":{\"75\":1}}],[\"−10000⩽ai​⩽10000\",{\"1\":{\"49\":1}}],[\"$\",{\"1\":{\"205\":1}}],[\"$gcd\",{\"1\":{\"205\":1}}],[\"​=\",{\"1\":{\"211\":1}}],[\"​=a\",{\"1\":{\"210\":1}}],[\"​\",{\"1\":{\"205\":2,\"210\":1,\"211\":1}}],[\"​​\",{\"1\":{\"50\":1}}],[\"反之则为\",{\"1\":{\"214\":1}}],[\"反之\",{\"1\":{\"205\":1}}],[\"反之为\",{\"1\":{\"203\":1}}],[\"反证法证明\",{\"1\":{\"190\":1}}],[\"倍增的思想\",{\"1\":{\"245\":1}}],[\"倍\",{\"1\":{\"202\":2}}],[\"倍区间的数目\",{\"1\":{\"45\":1}}],[\"倍区间吗\",{\"1\":{\"45\":1}}],[\"倍区间\",{\"1\":{\"45\":1}}],[\"修改任意一个元素\",{\"1\":{\"240\":1}}],[\"修改字符串的长度\",{\"1\":{\"26\":1}}],[\"修正为\",{\"1\":{\"202\":2}}],[\"互质时\",{\"1\":{\"210\":1}}],[\"互质\",{\"1\":{\"202\":1,\"210\":2}}],[\"互质的数的个数被称为欧拉函数\",{\"1\":{\"201\":1}}],[\"互质的充分必要条件是存在整数\",{\"1\":{\"31\":1,\"205\":1}}],[\"ϕ\",{\"1\":{\"201\":2}}],[\"记\",{\"1\":{\"214\":1}}],[\"记为\",{\"1\":{\"201\":1,\"210\":1}}],[\"记录素数个数\",{\"1\":{\"195\":1}}],[\"记录前缀中各个数字个数\",{\"1\":{\"128\":1}}],[\"记录答案\",{\"1\":{\"128\":1}}],[\"记录每棵树包含的节点数\",{\"1\":{\"66\":1}}],[\"记录个数\",{\"1\":{\"50\":1}}],[\"防止溢出\",{\"1\":{\"199\":1}}],[\"防止数组越界\",{\"1\":{\"25\":1}}],[\"辗转相除法时间可以忽略不计\",{\"1\":{\"199\":1}}],[\"辗转相除法\",{\"1\":{\"199\":1}}],[\"欧拉函数的定义\",{\"1\":{\"201\":1}}],[\"欧拉函数\",{\"0\":{\"200\":1}}],[\"欧拉筛\",{\"0\":{\"195\":1}}],[\"欧几里得算法\",{\"1\":{\"199\":1}}],[\"约数之和\",{\"1\":{\"198\":2}}],[\"约数个数\",{\"1\":{\"198\":1}}],[\"约数个数和约数之和\",{\"0\":{\"198\":1}}],[\"约数\",{\"0\":{\"196\":1}}],[\"约数枚举\",{\"1\":{\"191\":1}}],[\"避免和头文件next冲突\",{\"1\":{\"234\":1}}],[\"避免重复筛选\",{\"1\":{\"195\":1}}],[\"避免发生边界问题导致死循环\",{\"1\":{\"137\":1}}],[\"线性代数方法解非齐次线性方程组\",{\"1\":{\"207\":1}}],[\"线性筛法求素数\",{\"1\":{\"212\":1}}],[\"线性筛\",{\"0\":{\"195\":1}}],[\"线性dp写法\",{\"1\":{\"120\":1}}],[\"线性dp\",{\"0\":{\"119\":1}}],[\"内容如下\",{\"1\":{\"277\":1}}],[\"内的素数了\",{\"1\":{\"194\":1}}],[\"内有多少个素数\",{\"1\":{\"194\":1}}],[\"上启动\",{\"1\":{\"277\":1}}],[\"上浮\",{\"1\":{\"240\":1}}],[\"上了\",{\"1\":{\"194\":1}}],[\"上下左右四个相邻像素中有海洋\",{\"1\":{\"79\":1}}],[\"上下左右\",{\"1\":{\"79\":1}}],[\"解法\",{\"1\":{\"194\":1}}],[\"解决方法是额外使用一个\",{\"1\":{\"66\":1}}],[\"剩下的就是质数\",{\"1\":{\"193\":1}}],[\"趋于无穷大时\",{\"1\":{\"193\":1}}],[\"调和级数\",{\"1\":{\"193\":1}}],[\"筛素数\",{\"1\":{\"212\":1}}],[\"筛法求出范围内的所有质数\",{\"1\":{\"212\":1}}],[\"筛法求欧拉函数\",{\"0\":{\"202\":1}}],[\"筛法求素数\",{\"0\":{\"192\":1}}],[\"筛掉它的倍数\",{\"1\":{\"193\":1}}],[\"埃氏筛\",{\"0\":{\"193\":1}}],[\"√n\",{\"1\":{\"191\":3}}],[\"素数测试\",{\"1\":{\"191\":1}}],[\"汇总\",{\"0\":{\"191\":1}}],[\"于是我们发现只有一个大于\",{\"1\":{\"190\":1}}],[\"试除法求所有约数\",{\"0\":{\"197\":1}}],[\"试除法分解质因数\",{\"0\":{\"190\":1}}],[\"试除法判定质数\",{\"0\":{\"189\":1}}],[\"质数定理\",{\"1\":{\"193\":1}}],[\"质数\",{\"0\":{\"188\":1},\"1\":{\"202\":1}}],[\"那它就是一个质数\",{\"1\":{\"193\":1}}],[\"那就匹配并标记\",{\"1\":{\"184\":1}}],[\"那么有没有线程安全问题呢\",{\"1\":{\"287\":1}}],[\"那么再从头开始查找\",{\"1\":{\"243\":1}}],[\"那么相乘会大于\",{\"1\":{\"190\":1}}],[\"那么它就是一个完美匹配\",{\"1\":{\"184\":1}}],[\"那么加上自己之后一共有n+1个点\",{\"1\":{\"177\":1}}],[\"那么最短路可能为负无穷\",{\"1\":{\"175\":1}}],[\"那么子节点随意\",{\"1\":{\"133\":1}}],[\"那么称这一段数是两个数列的公共上升子序列\",{\"1\":{\"123\":1}}],[\"那么这个前缀和就能和前面每一个组成一个组合\",{\"1\":{\"46\":1}}],[\"那么题目就是要我们求\",{\"1\":{\"46\":1}}],[\"那么\",{\"1\":{\"46\":2,\"65\":1,\"144\":1,\"193\":1,\"230\":2}}],[\"那么对于任意的整数\",{\"1\":{\"31\":1,\"205\":1}}],[\"出发的点不算\",{\"1\":{\"184\":1}}],[\"出现了多少次\",{\"1\":{\"144\":1}}],[\"形成的路径叫交替路\",{\"1\":{\"184\":1}}],[\"完成文件夹\",{\"1\":{\"282\":1}}],[\"完全\",{\"1\":{\"240\":1}}],[\"完全背包\",{\"0\":{\"116\":1}}],[\"完美匹配\",{\"1\":{\"184\":1}}],[\"称为这个图的最大匹配\",{\"1\":{\"184\":1}}],[\"称为正确排列\",{\"1\":{\"75\":1}}],[\"匹配完成后的具体操作\",{\"1\":{\"234\":1}}],[\"匹配完我输出一下\",{\"1\":{\"234\":1}}],[\"匹配操作\",{\"1\":{\"234\":1}}],[\"匹配时\",{\"1\":{\"234\":2}}],[\"匹配边\",{\"1\":{\"184\":1}}],[\"匹配\",{\"1\":{\"184\":3}}],[\"匈牙利算法中只会用到从第一个集合指向第二个集合的边\",{\"1\":{\"184\":1}}],[\"匈牙利算法\",{\"0\":{\"184\":1}}],[\"参数\",{\"1\":{\"183\":1}}],[\"遍历\",{\"1\":{\"262\":1}}],[\"遍历所有左端点在l的左边的区间\",{\"1\":{\"254\":1}}],[\"遍历所有点\",{\"1\":{\"183\":1,\"184\":1}}],[\"遍历n个点\",{\"1\":{\"173\":1}}],[\"区分\",{\"1\":{\"183\":1}}],[\"区间覆盖\",{\"0\":{\"254\":1}}],[\"区间分组\",{\"0\":{\"253\":1}}],[\"区间选点\",{\"0\":{\"251\":1}}],[\"区间问题\",{\"0\":{\"250\":1}}],[\"区间筛法\",{\"0\":{\"194\":1}}],[\"区间合并\",{\"0\":{\"162\":1,\"255\":1}}],[\"区间终点\",{\"1\":{\"126\":1}}],[\"区间长度\",{\"1\":{\"126\":1}}],[\"区间dp枚举套路\",{\"1\":{\"126\":1}}],[\"区间dp\",{\"0\":{\"126\":1}}],[\"区间\",{\"1\":{\"37\":1,\"46\":1,\"126\":1}}],[\"染色失败\",{\"1\":{\"183\":1}}],[\"染色可以使用\",{\"1\":{\"183\":1}}],[\"染色法判别二分图\",{\"0\":{\"183\":1}}],[\"性质\",{\"1\":{\"183\":1,\"230\":1}}],[\"权重\",{\"1\":{\"182\":1}}],[\"值是0x3f3f3f3f\",{\"1\":{\"181\":1}}],[\"距离最近的点\",{\"1\":{\"181\":1}}],[\"距离都初始化为无穷大\",{\"1\":{\"173\":1}}],[\"叫做求最小生成树\",{\"1\":{\"180\":1}}],[\"换句话来说\",{\"1\":{\"180\":1}}],[\"换成\",{\"1\":{\"142\":1}}],[\"换成a\",{\"1\":{\"142\":1}}],[\"多租户支持\",{\"1\":{\"282\":1}}],[\"多么真实而实用的算法\",{\"1\":{\"184\":1}}],[\"多源汇最短路\",{\"0\":{\"178\":1}}],[\"多重背包\",{\"0\":{\"117\":1}}],[\"除了通过传统的命令行进行操作之外\",{\"1\":{\"282\":1}}],[\"除了自己\",{\"1\":{\"177\":1}}],[\"除最后一层节点\",{\"1\":{\"240\":1}}],[\"除以\",{\"0\":{\"30\":1},\"1\":{\"211\":1}}],[\"原理\",{\"1\":{\"177\":1}}],[\"原因是\",{\"1\":{\"175\":1}}],[\"总点数\",{\"1\":{\"177\":1}}],[\"总点数和总边数\",{\"1\":{\"176\":1}}],[\"总的作用是为处于自己上层的应用软件提供运行与开发的环境\",{\"1\":{\"15\":1}}],[\"平均情况下\",{\"1\":{\"176\":1}}],[\"重命名为\",{\"1\":{\"277\":1}}],[\"重定向到标准输出\",{\"1\":{\"274\":1}}],[\"重定向到\",{\"1\":{\"274\":1}}],[\"重载小于运算符\",{\"1\":{\"253\":1}}],[\"重载小于号\",{\"1\":{\"182\":1}}],[\"重载\",{\"1\":{\"246\":1}}],[\"重复执行直到队列为空\",{\"1\":{\"176\":1}}],[\"重新赋给每个元素的值\",{\"1\":{\"37\":1}}],[\"建堆\",{\"1\":{\"240\":1}}],[\"建立一个队列\",{\"1\":{\"176\":1}}],[\"建议同时指定\",{\"1\":{\"26\":1}}],[\"路径中至少存在两个相同的点\",{\"1\":{\"175\":1}}],[\"路径的定义是从\",{\"1\":{\"131\":1}}],[\"由两名玩家交替行动\",{\"1\":{\"217\":1}}],[\"由抽屉原理一定有两个点相同\",{\"1\":{\"177\":1}}],[\"由抽屉原理\",{\"1\":{\"175\":1}}],[\"由于某个点染色成功并不代表整个图就是二分图\",{\"1\":{\"183\":1}}],[\"由于是每个点同时向外出发\",{\"1\":{\"175\":1}}],[\"由于在除法运算中\",{\"1\":{\"150\":1}}],[\"由于全球变暖导致了海面上升\",{\"1\":{\"79\":1}}],[\"``dist\",{\"1\":{\"175\":1}}],[\"影响到下一个点\",{\"1\":{\"175\":1}}],[\"松弛操作\",{\"1\":{\"175\":2}}],[\"次后变为一个式子\",{\"1\":{\"206\":1}}],[\"次之后\",{\"1\":{\"175\":1}}],[\"次\",{\"1\":{\"175\":2,\"211\":1}}],[\"次询问\",{\"1\":{\"124\":1}}],[\"迭代地寻找当前节点的左子节点\",{\"1\":{\"264\":1}}],[\"迭代\",{\"0\":{\"264\":1},\"1\":{\"175\":1},\"2\":{\"266\":1}}],[\"迭代器的++\",{\"1\":{\"245\":1}}],[\"迭代器\",{\"1\":{\"39\":3}}],[\"稀疏图改用\",{\"1\":{\"174\":1}}],[\"稀疏图用邻接表\",{\"1\":{\"173\":1}}],[\"无论是标准输出还是错误输出\",{\"1\":{\"274\":1}}],[\"无论如何操作\",{\"1\":{\"216\":1}}],[\"无法继续向下处理了\",{\"1\":{\"263\":1}}],[\"无法存储上一节点\",{\"1\":{\"226\":1}}],[\"无法移动者判负\",{\"1\":{\"218\":1}}],[\"无法形成最短路\",{\"1\":{\"173\":1}}],[\"无解\",{\"1\":{\"207\":1}}],[\"无向图\",{\"1\":{\"173\":1}}],[\"无向图是没有拓扑序列的\",{\"1\":{\"170\":1}}],[\"无向图就再写一遍\",{\"1\":{\"166\":1}}],[\"寻找距离最小的点\",{\"1\":{\"173\":1}}],[\"寻找两点之间的最大距离\",{\"1\":{\"166\":1}}],[\"访问\",{\"1\":{\"282\":1}}],[\"访问加入集合并标记\",{\"1\":{\"173\":1}}],[\"访问标记\",{\"1\":{\"133\":1}}],[\"逐个遍历\",{\"1\":{\"173\":1}}],[\"逐位压入数组中\",{\"1\":{\"149\":1}}],[\"稠密图用邻接矩阵\",{\"1\":{\"173\":1}}],[\"指定文件路径\",{\"1\":{\"290\":1}}],[\"指定\",{\"1\":{\"274\":1}}],[\"指定数据存放位置\",{\"1\":{\"274\":1}}],[\"指定minio密码\",{\"1\":{\"274\":1}}],[\"指定minio的用户名\",{\"1\":{\"274\":1}}],[\"指定的部分应该是提前排好序的\",{\"1\":{\"246\":1}}],[\"指定的部分上执行二分查找\",{\"1\":{\"246\":1}}],[\"指定的部分进行快速排序\",{\"1\":{\"246\":1}}],[\"指向的下一节点\",{\"1\":{\"226\":1}}],[\"指边相对于点不多\",{\"1\":{\"172\":1}}],[\"指针\",{\"1\":{\"38\":1,\"246\":3}}],[\"点的数量\",{\"1\":{\"174\":1}}],[\"点数和边数\",{\"1\":{\"173\":1}}],[\"点多\",{\"1\":{\"172\":1}}],[\"点少边比较多\",{\"1\":{\"172\":1}}],[\"点从\",{\"1\":{\"131\":1}}],[\"条边为止\",{\"1\":{\"182\":1}}],[\"条边\",{\"1\":{\"172\":1,\"180\":1}}],[\"头尾指针\",{\"1\":{\"170\":1}}],[\"头重脚轻\",{\"1\":{\"63\":1}}],[\"采用数组模拟队列的写法\",{\"1\":{\"170\":1}}],[\"结束\",{\"1\":{\"235\":1}}],[\"结尾\",{\"1\":{\"235\":1}}],[\"结构体存储\",{\"1\":{\"182\":1}}],[\"结论\",{\"1\":{\"170\":1,\"190\":1,\"210\":1}}],[\"结果为零\",{\"1\":{\"158\":1}}],[\"结果才为0\",{\"1\":{\"157\":1}}],[\"结果才为1\",{\"1\":{\"157\":1}}],[\"拓扑排序\",{\"0\":{\"170\":1}}],[\"宽度优先遍历\",{\"0\":{\"169\":1}}],[\"深度优先遍历\",{\"0\":{\"168\":1}}],[\"存在乘法逆元的充要条件是\",{\"1\":{\"210\":1}}],[\"存在负权边\",{\"0\":{\"175\":1,\"176\":1},\"1\":{\"172\":1}}],[\"存的是当前加入的边数\",{\"1\":{\"182\":1}}],[\"存的是最小生成树的所有边的权值\",{\"1\":{\"182\":1}}],[\"存入a和b两点之间的距离\",{\"1\":{\"173\":1}}],[\"存边\",{\"1\":{\"166\":1}}],[\"存储桶\",{\"1\":{\"281\":1}}],[\"存储的元数据主要包括对象的描述信息\",{\"1\":{\"281\":1}}],[\"存储和检索数据\",{\"1\":{\"281\":1}}],[\"存储数据的目录路径\",{\"1\":{\"276\":1}}],[\"存储字符串前k个字母的哈希值\",{\"1\":{\"244\":1}}],[\"存储堆中下标是k的点是第几个插入的\",{\"1\":{\"240\":1}}],[\"存储堆中的值\",{\"1\":{\"240\":1}}],[\"存储第k个插入的点在堆中的位置\",{\"1\":{\"240\":1}}],[\"存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\",{\"1\":{\"184\":1}}],[\"存储x到p\",{\"1\":{\"239\":1}}],[\"存储x是否被筛掉\",{\"1\":{\"193\":1,\"195\":1,\"202\":1}}],[\"存储当前用到的下标\",{\"1\":{\"235\":1}}],[\"存储以每个节点结尾的单词数量\",{\"1\":{\"235\":1}}],[\"存储树中每个节点的子节点\",{\"1\":{\"235\":1}}],[\"存储形式如下\",{\"1\":{\"235\":1}}],[\"存储节点的next指针\",{\"1\":{\"226\":1}}],[\"存储节点的值\",{\"1\":{\"226\":1}}],[\"存储图和树\",{\"1\":{\"226\":1}}],[\"存储其他点到当前最小生成树的距离\",{\"1\":{\"181\":1}}],[\"存储1到x的最短路中经过的点数\",{\"1\":{\"177\":1}}],[\"存储1到x的最短路距离\",{\"1\":{\"175\":1}}],[\"存储1号点到x的最短距离\",{\"1\":{\"177\":1}}],[\"存储1号点到每个点的最短距离\",{\"1\":{\"173\":1}}],[\"存储所有质数\",{\"1\":{\"212\":1}}],[\"存储所有素数\",{\"1\":{\"193\":1,\"195\":1,\"202\":1}}],[\"存储所有边\",{\"1\":{\"181\":1}}],[\"存储所有点到1号点的距离\",{\"1\":{\"174\":1}}],[\"存储所有待离散化的值\",{\"1\":{\"161\":1}}],[\"存储每个数是否已被筛掉\",{\"1\":{\"212\":1}}],[\"存储每个数的欧拉函数\",{\"1\":{\"202\":1}}],[\"存储每个质数的次数\",{\"1\":{\"212\":1}}],[\"存储每个点的祖宗节点\",{\"1\":{\"237\":1,\"238\":1,\"239\":1}}],[\"存储每个点的最短距离是否已确定\",{\"1\":{\"174\":1}}],[\"存储每个点的最短路是否已经确定\",{\"1\":{\"173\":1}}],[\"存储每个点是否已经在生成树中\",{\"1\":{\"181\":1}}],[\"存储每个点是否在队列中\",{\"1\":{\"176\":1,\"177\":1}}],[\"存储每个点到1号点的最短距离\",{\"1\":{\"176\":1}}],[\"存储每条边\",{\"1\":{\"173\":1}}],[\"存储点i的入度\",{\"1\":{\"170\":1}}],[\"存储这个单链表的头结点\",{\"1\":{\"166\":1}}],[\"存储k所有可以走到的点\",{\"1\":{\"166\":1}}],[\"存储边\",{\"1\":{\"166\":1}}],[\"存储\",{\"1\":{\"147\":1,\"148\":1,\"240\":1,\"244\":2,\"282\":1}}],[\"存储变换后的字符串\",{\"1\":{\"77\":1}}],[\"存储目前为止前缀和相同的个数\",{\"1\":{\"46\":1}}],[\"邻接表存储图\",{\"1\":{\"183\":1}}],[\"邻接表存储所有边\",{\"1\":{\"174\":1,\"176\":1,\"177\":1,\"184\":1}}],[\"邻接表\",{\"1\":{\"166\":1,\"174\":1,\"226\":1}}],[\"邻接矩阵初始化为无穷大\",{\"1\":{\"173\":1}}],[\"邻接矩阵\",{\"1\":{\"166\":1,\"181\":1}}],[\"动态维护有序序列\",{\"1\":{\"245\":1}}],[\"动态邻接矩阵\",{\"1\":{\"166\":1}}],[\"动态规划\",{\"0\":{\"113\":1},\"1\":{\"3\":1}}],[\"映射到1\",{\"1\":{\"161\":1}}],[\"去重\",{\"1\":{\"246\":2}}],[\"去筛合数时\",{\"1\":{\"195\":1}}],[\"去掉重复元素\",{\"1\":{\"161\":1}}],[\"去除无效状态的优化写法\",{\"1\":{\"130\":1}}],[\"离散化\",{\"0\":{\"161\":1}}],[\"维护值和下标\",{\"1\":{\"269\":1}}],[\"维护一个数组集合\",{\"1\":{\"240\":1}}],[\"维护一个动态数组\",{\"0\":{\"25\":1}}],[\"维护到祖宗节点距离的并查集\",{\"0\":{\"239\":1}}],[\"维护size的并查集\",{\"0\":{\"238\":1}}],[\"维护某种次序\",{\"1\":{\"160\":1}}],[\"具体地\",{\"1\":{\"282\":1}}],[\"具体方法是\",{\"1\":{\"218\":1}}],[\"具体步骤\",{\"1\":{\"175\":1}}],[\"具体问题的逻辑\",{\"1\":{\"160\":1}}],[\"具体来说如果一块陆地像素与海洋相邻\",{\"1\":{\"79\":1}}],[\"得看被移数是正还是负\",{\"1\":{\"158\":1}}],[\"得到该位的被除数\",{\"1\":{\"150\":1}}],[\"得到总区间的最小代价\",{\"1\":{\"126\":1}}],[\"得到三个非空子数组\",{\"1\":{\"49\":1}}],[\"负数左补\",{\"1\":{\"158\":1}}],[\"负数按补码形式参加按位与运算\",{\"1\":{\"158\":1}}],[\"正数左补\",{\"1\":{\"158\":1}}],[\"逻辑运算符和其他运算符都高\",{\"1\":{\"158\":1}}],[\"逻辑右移\",{\"1\":{\"157\":1}}],[\"关闭终端后服务就会停止\",{\"1\":{\"277\":1}}],[\"关于为什么求\",{\"1\":{\"234\":1}}],[\"关于中间件\",{\"1\":{\"15\":1}}],[\"关系运算符\",{\"1\":{\"158\":1}}],[\"翻转一个数组\",{\"1\":{\"246\":1}}],[\"翻转一个\",{\"1\":{\"246\":1}}],[\"翻转\",{\"1\":{\"246\":1}}],[\"翻转指定位\",{\"1\":{\"158\":1}}],[\"翻译\",{\"1\":{\"46\":1}}],[\"令\",{\"1\":{\"158\":3}}],[\"全部弹出后\",{\"1\":{\"264\":1}}],[\"全部加起来\",{\"1\":{\"127\":1}}],[\"全为\",{\"1\":{\"158\":2}}],[\"算术右移\",{\"1\":{\"157\":1}}],[\"算法步骤\",{\"1\":{\"207\":1}}],[\"算法描述\",{\"1\":{\"184\":1}}],[\"算法结束后\",{\"1\":{\"179\":1}}],[\"算法\",{\"0\":{\"182\":1},\"1\":{\"172\":2}}],[\"算法思路\",{\"1\":{\"140\":1}}],[\"算法和求最近公共祖先\",{\"1\":{\"59\":1}}],[\"算法笔记\",{\"0\":{\"1\":1}}],[\"各种视频\",{\"1\":{\"280\":1}}],[\"各种图片\",{\"1\":{\"280\":1}}],[\"各编译器处理方法不一样\",{\"1\":{\"157\":1}}],[\"各二进位全部右移若干位\",{\"1\":{\"157\":1}}],[\"各二进位全部左移若干位\",{\"1\":{\"157\":1}}],[\"各行\",{\"1\":{\"92\":1}}],[\"异或\",{\"1\":{\"157\":1}}],[\"异常\",{\"1\":{\"26\":1}}],[\"^=\",{\"1\":{\"158\":3,\"216\":1}}],[\"^\",{\"1\":{\"157\":1,\"158\":7,\"216\":3,\"221\":3,\"245\":1}}],[\"描述\",{\"1\":{\"157\":1}}],[\"符号\",{\"1\":{\"157\":1}}],[\"位整数范围内\",{\"1\":{\"206\":1}}],[\"位上的数是否为\",{\"1\":{\"203\":1}}],[\"位数字移动到最后一位\",{\"1\":{\"159\":1}}],[\"位数\",{\"1\":{\"159\":1}}],[\"位进行翻转\",{\"1\":{\"158\":1}}],[\"位设置为\",{\"1\":{\"158\":1}}],[\"位为\",{\"1\":{\"158\":3}}],[\"位\",{\"1\":{\"158\":4,\"159\":1}}],[\"位运算符作用于位\",{\"1\":{\"157\":1}}],[\"位运算符\",{\"0\":{\"157\":1}}],[\"位运算\",{\"0\":{\"156\":1}}],[\"位于应用与操作系统\",{\"1\":{\"15\":1}}],[\"便于直接对余数进行处理\",{\"1\":{\"150\":1}}],[\"÷\",{\"1\":{\"150\":2}}],[\"倒序输出\",{\"1\":{\"149\":1}}],[\"倒序插入\",{\"1\":{\"149\":1}}],[\"倒序存放\",{\"1\":{\"147\":1,\"148\":1}}],[\"低精\",{\"1\":{\"149\":1,\"150\":1}}],[\"低位补0\",{\"1\":{\"157\":1}}],[\"低位变为0\",{\"1\":{\"147\":1}}],[\"低位满10向高位进位\",{\"1\":{\"147\":1}}],[\"×a2xt​=a2x1​+2x2​+\",{\"1\":{\"203\":1}}],[\"×pm​pm​−1​\",{\"1\":{\"201\":1}}],[\"×\",{\"1\":{\"149\":3}}],[\"满足匹配条件\",{\"1\":{\"234\":1}}],[\"满足任意前缀中0的个数都不少于1的个数的序列的数量为\",{\"1\":{\"213\":1}}],[\"满足\",{\"1\":{\"148\":1,\"206\":1}}],[\"压入c数组中\",{\"1\":{\"147\":1}}],[\"压缩路径\",{\"1\":{\"65\":1,\"66\":1}}],[\"进入终端\",{\"1\":{\"276\":1}}],[\"进入到\",{\"1\":{\"276\":1}}],[\"进制数\",{\"1\":{\"244\":1}}],[\"进制的数转化为十进制\",{\"1\":{\"28\":1}}],[\"进行数据读写\",{\"1\":{\"281\":1}}],[\"进行\",{\"1\":{\"183\":1}}],[\"进行异或运算\",{\"1\":{\"158\":1}}],[\"进行按位或运算\",{\"1\":{\"158\":1}}],[\"进行按位与运算\",{\"1\":{\"158\":1}}],[\"进位\",{\"1\":{\"147\":1}}],[\"节省时间\",{\"1\":{\"147\":1,\"148\":1}}],[\"节省查找时间\",{\"1\":{\"66\":1}}],[\"直到找到并处理完后\",{\"1\":{\"264\":1}}],[\"直到具有\",{\"1\":{\"182\":1}}],[\"直到第n个点\",{\"1\":{\"173\":1}}],[\"直到字符串结尾\",{\"1\":{\"35\":1}}],[\"直接将其指向下下个节点\",{\"1\":{\"226\":1}}],[\"直接异或运算进行整数交换后\",{\"1\":{\"158\":1}}],[\"直接搜索数组a和b\",{\"1\":{\"147\":1,\"148\":1}}],[\"加1\",{\"1\":{\"234\":1}}],[\"加边法\",{\"1\":{\"182\":1}}],[\"加到集合当中去\",{\"1\":{\"181\":1}}],[\"加入到集合中\",{\"1\":{\"182\":1}}],[\"加入到连通块中\",{\"1\":{\"181\":1}}],[\"加入i后更新当前a的值\",{\"1\":{\"110\":1}}],[\"加点法\",{\"1\":{\"181\":1}}],[\"加上\",{\"1\":{\"147\":1,\"148\":1}}],[\"检查x是否满足某种性质\",{\"1\":{\"145\":1}}],[\"浮点数二分\",{\"0\":{\"145\":1}}],[\"需使用头文件\",{\"1\":{\"144\":1}}],[\"需要指定存储桶名称和对象键\",{\"1\":{\"290\":1}}],[\"需要指定存储桶的名称\",{\"1\":{\"289\":1}}],[\"需要将其注册为\",{\"1\":{\"277\":1}}],[\"需要保证头结点存在\",{\"1\":{\"226\":1}}],[\"需要借位\",{\"1\":{\"148\":1}}],[\"需要用多重背包的二进制优化方法\",{\"1\":{\"117\":1}}],[\"需要减去序列头以转换为下标\",{\"1\":{\"39\":1}}],[\"改\",{\"1\":{\"143\":1}}],[\"简单来说就是\",{\"1\":{\"142\":1}}],[\"简介\",{\"0\":{\"59\":1}}],[\"此时父节点相当于当前节点\",{\"1\":{\"264\":1}}],[\"此时为了防止死循环\",{\"1\":{\"142\":1}}],[\"此处存放自己写和一些优秀的开源项目\",{\"1\":{\"19\":1}}],[\"此处存放前后端常用框架的笔记\",{\"1\":{\"18\":1}}],[\"此处存放一些程序员相关的资源文件\",{\"1\":{\"20\":1}}],[\"此处存放一些计算机大类的笔记\",{\"1\":{\"8\":1}}],[\"此处存放一些关于\",{\"1\":{\"7\":1}}],[\"此处存放刷题时的思路和笔记\",{\"1\":{\"1\":1}}],[\"划分成\",{\"1\":{\"141\":1,\"142\":1}}],[\"假定节点编号是1~n\",{\"1\":{\"237\":1,\"238\":1,\"239\":1}}],[\"假设一定存在\",{\"1\":{\"246\":1}}],[\"假设输入都是正数\",{\"1\":{\"191\":1}}],[\"假设目标值在闭区间\",{\"1\":{\"140\":1}}],[\"假如有编号为\",{\"1\":{\"61\":1}}],[\"两名玩家交替地把这枚棋子沿有向边进行移动\",{\"1\":{\"218\":1}}],[\"两名玩家轮流行动\",{\"1\":{\"216\":1}}],[\"两人都采取最优策略\",{\"1\":{\"216\":1}}],[\"两点及其权值\",{\"1\":{\"182\":1}}],[\"两重\",{\"1\":{\"175\":1}}],[\"两个迭代器\",{\"1\":{\"246\":1}}],[\"两个集合\",{\"1\":{\"183\":1}}],[\"两个位相同为0\",{\"1\":{\"157\":1}}],[\"两个位都为0时\",{\"1\":{\"157\":1}}],[\"两个位都为1时\",{\"1\":{\"157\":1}}],[\"两个if把两个数组相同位上的数相加\",{\"1\":{\"147\":1}}],[\"两个整数\",{\"1\":{\"100\":1}}],[\"两边递归\",{\"1\":{\"138\":1}}],[\"确定中间分界点\",{\"1\":{\"138\":1}}],[\"确定分界点\",{\"1\":{\"137\":1,\"138\":1}}],[\"合二为一\",{\"1\":{\"138\":1}}],[\"合并a和b所在的两个集合\",{\"1\":{\"238\":1,\"239\":1}}],[\"合并x和y所在的两个集合\",{\"1\":{\"237\":1}}],[\"合并两步后\",{\"1\":{\"159\":1}}],[\"合并区间\",{\"1\":{\"138\":1}}],[\"合并\",{\"0\":{\"63\":1},\"1\":{\"59\":1,\"65\":1,\"66\":1}}],[\"归并的一般写法如下\",{\"1\":{\"138\":1}}],[\"归并\",{\"1\":{\"138\":1}}],[\"归并每次都将中点作为分界点\",{\"1\":{\"138\":1}}],[\"归并排序\",{\"0\":{\"138\":1}}],[\"运行公开的读\",{\"1\":{\"289\":1}}],[\"运行和集成的平台\",{\"1\":{\"15\":1}}],[\"运算符\",{\"1\":{\"246\":2}}],[\"运算符的优先级比算术运算符\",{\"1\":{\"158\":1}}],[\"运算的结果\",{\"1\":{\"220\":1}}],[\"运算\",{\"1\":{\"158\":1}}],[\"运算规则\",{\"1\":{\"157\":1,\"158\":4}}],[\"运用双指针的思想\",{\"1\":{\"138\":1}}],[\"设置该存储桶里面的文件的访问策略\",{\"1\":{\"289\":1}}],[\"设置两个头尾指针\",{\"1\":{\"137\":1}}],[\"设g1\",{\"1\":{\"221\":1}}],[\"设从x出发共有k条有向边\",{\"1\":{\"220\":1}}],[\"设s表示一个非负整数集合\",{\"1\":{\"219\":1}}],[\"设\",{\"1\":{\"158\":1}}],[\"设计模式\",{\"0\":{\"14\":1}}],[\"子串长度\",{\"1\":{\"245\":1}}],[\"子问题合并\",{\"1\":{\"137\":2}}],[\"子节点不能选\",{\"1\":{\"133\":1}}],[\"子节点依附在根节点上\",{\"1\":{\"65\":1}}],[\"快速集成快速集成使用\",{\"1\":{\"282\":1}}],[\"快速幂模板\",{\"1\":{\"210\":1,\"211\":1}}],[\"快速幂求逆元\",{\"1\":{\"210\":1}}],[\"快速幂\",{\"0\":{\"203\":1}}],[\"快速排序\",{\"0\":{\"137\":1}}],[\"快排这一步不需要操作\",{\"1\":{\"137\":1}}],[\"快排的一般写法如下\",{\"1\":{\"137\":1}}],[\"快排属于分治算法\",{\"1\":{\"137\":1}}],[\"取模的数用\",{\"1\":{\"244\":1}}],[\"取模加模再取模\",{\"1\":{\"206\":1}}],[\"取这两个值的冲突概率低\",{\"1\":{\"244\":1}}],[\"取走最后一件物品者获胜\",{\"1\":{\"216\":1}}],[\"取走任意多个物品\",{\"1\":{\"216\":1}}],[\"取出作为\",{\"1\":{\"176\":1}}],[\"取出b的每一位\",{\"1\":{\"110\":1}}],[\"取一个数的指定位\",{\"1\":{\"158\":1}}],[\"取反\",{\"1\":{\"157\":1}}],[\"取决于题目对精度的要求\",{\"1\":{\"145\":1}}],[\"取根节点两种方案的最大值\",{\"1\":{\"133\":1}}],[\"说明该节点的子树是空子树\",{\"1\":{\"263\":1}}],[\"说明这个数是它的一个约数\",{\"1\":{\"197\":1}}],[\"说明这就是大于\",{\"1\":{\"190\":1}}],[\"说明此时的\",{\"1\":{\"195\":1}}],[\"说明此时遍历到的\",{\"1\":{\"195\":1}}],[\"说明两个顶点已经连通\",{\"1\":{\"182\":1}}],[\"说明图中存在负权回路\",{\"1\":{\"175\":1}}],[\"说明不连通\",{\"1\":{\"173\":1}}],[\"说明存在拓扑序列\",{\"1\":{\"170\":1}}],[\"说明是叶子节点\",{\"1\":{\"133\":1}}],[\"说人话\",{\"1\":{\"46\":1}}],[\"入度为0\",{\"1\":{\"133\":1}}],[\"入度\",{\"1\":{\"133\":1}}],[\"他的下属所能获得的最大快乐值\",{\"1\":{\"133\":2}}],[\"没找到则返回end\",{\"1\":{\"245\":1}}],[\"没事别叫我\",{\"1\":{\"234\":1}}],[\"没有线程安全问题\",{\"1\":{\"287\":1}}],[\"没有明确结构的数据\",{\"1\":{\"280\":1}}],[\"没有入度\",{\"1\":{\"133\":1}}],[\"没有被访问过\",{\"1\":{\"133\":1}}],[\"没有上司的舞会\",{\"0\":{\"133\":1}}],[\"没用过则标记\",{\"1\":{\"110\":1}}],[\"走交替路\",{\"1\":{\"184\":1}}],[\"走过的所有点的情况是\",{\"1\":{\"131\":1}}],[\"走到\",{\"1\":{\"131\":1}}],[\"到\",{\"1\":{\"131\":1,\"193\":1,\"211\":1,\"214\":1}}],[\"到终点和我说声\",{\"1\":{\"234\":1}}],[\"到终点\",{\"1\":{\"131\":1}}],[\"|\",{\"1\":{\"130\":1,\"157\":1,\"158\":6,\"210\":1,\"245\":1}}],[\"||\",{\"1\":{\"110\":3,\"130\":1,\"147\":1,\"149\":1,\"173\":1,\"181\":1,\"184\":1,\"246\":1,\"253\":1}}],[\"蒙德里安的梦想\",{\"0\":{\"130\":1}}],[\"状态更新等\",{\"1\":{\"274\":1}}],[\"状态表示\",{\"1\":{\"130\":1}}],[\"状态压缩类dp\",{\"0\":{\"129\":1}}],[\"状态转移方程\",{\"1\":{\"120\":1,\"121\":1,\"122\":1,\"125\":2,\"131\":1,\"133\":1}}],[\"状态转移\",{\"1\":{\"77\":1}}],[\"后依然有序\",{\"0\":{\"293\":1}}],[\"后续通过注入\",{\"1\":{\"287\":1}}],[\"后续通过调用\",{\"1\":{\"287\":1}}],[\"后台服务安装\",{\"0\":{\"277\":1}}],[\"后台启动\",{\"1\":{\"274\":1}}],[\"后进后出\",{\"1\":{\"231\":1}}],[\"后再减\",{\"1\":{\"148\":1}}],[\"后面一位\",{\"1\":{\"144\":1}}],[\"后面例二中将会给出解决方法\",{\"1\":{\"63\":1}}],[\"后缀部分\",{\"1\":{\"128\":1}}],[\"循环出口\",{\"1\":{\"254\":1}}],[\"循环\",{\"1\":{\"175\":2}}],[\"循环变量i可以表示剩下的数字有多少个\",{\"1\":{\"128\":1}}],[\"循环从1开始\",{\"1\":{\"128\":1}}],[\"统计叶子节点\",{\"1\":{\"128\":1}}],[\"统计大于10\",{\"1\":{\"128\":1}}],[\"统计1\",{\"1\":{\"128\":1}}],[\"边\",{\"1\":{\"175\":1}}],[\"边多\",{\"1\":{\"172\":1}}],[\"边界条件\",{\"1\":{\"128\":1}}],[\"边读边加\",{\"1\":{\"54\":1}}],[\"~x\",{\"1\":{\"159\":1}}],[\"~0\",{\"1\":{\"158\":1}}],[\"~1\",{\"1\":{\"158\":3}}],[\"~\",{\"1\":{\"128\":1,\"131\":1,\"157\":1,\"158\":2,\"190\":1,\"193\":1,\"202\":1,\"214\":2,\"244\":1,\"245\":1,\"246\":4}}],[\"特点\",{\"0\":{\"282\":1}}],[\"特判最中间的数\",{\"1\":{\"197\":1}}],[\"特殊\",{\"1\":{\"127\":1}}],[\"特别地\",{\"1\":{\"31\":1,\"205\":1,\"220\":1}}],[\"特别是应用软件对于系统软件的集中的逻辑\",{\"1\":{\"15\":1}}],[\"容斥原理\",{\"0\":{\"214\":1}}],[\"容量为0时\",{\"1\":{\"127\":2}}],[\"容器化\",{\"1\":{\"282\":1}}],[\"容器\",{\"1\":{\"275\":1}}],[\"容器的首尾地址\",{\"1\":{\"39\":2}}],[\"容器中以前的内容\",{\"1\":{\"37\":1}}],[\"容器中\",{\"1\":{\"37\":2}}],[\"容器大小\",{\"1\":{\"37\":1}}],[\"朴素并查集\",{\"0\":{\"237\":1}}],[\"朴素筛法\",{\"0\":{\"193\":1}}],[\"朴素prim算法\",{\"0\":{\"181\":1}}],[\"朴素版\",{\"0\":{\"173\":1}}],[\"朴素版的dijkstra算法\",{\"1\":{\"172\":1}}],[\"朴素做法\",{\"1\":{\"127\":1}}],[\"朴素dp写法\",{\"1\":{\"121\":1}}],[\"因此利用迭代的思想\",{\"1\":{\"264\":1}}],[\"因此可以递推的每次乘\",{\"1\":{\"211\":1}}],[\"因此可以用\",{\"1\":{\"158\":1}}],[\"因此最终结果\",{\"1\":{\"202\":1}}],[\"因此不仅需要将基数\",{\"1\":{\"202\":1}}],[\"因此只有某个点染色失败才能立刻\",{\"1\":{\"183\":1}}],[\"因此需要对\",{\"1\":{\"175\":1}}],[\"因此前导0在数组前面\",{\"1\":{\"150\":1}}],[\"因此\",{\"1\":{\"127\":1,\"195\":1,\"202\":1}}],[\"因为存的都是英文字母\",{\"1\":{\"235\":1}}],[\"因为本质是一样的\",{\"1\":{\"234\":1}}],[\"因为围棋交战双方分别只能落黑子和白子\",{\"1\":{\"217\":1}}],[\"因为从\",{\"1\":{\"211\":1}}],[\"因为我们是从小到大遍历的\",{\"1\":{\"195\":1}}],[\"因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化\",{\"1\":{\"184\":1}}],[\"因为你要去问的都是男孩子\",{\"1\":{\"184\":1}}],[\"因为再给边排序的时候是按照边的权重进行排序的\",{\"1\":{\"182\":1}}],[\"因为\",{\"1\":{\"158\":1,\"194\":1,\"205\":1}}],[\"因为是倒序数组\",{\"1\":{\"148\":1}}],[\"因为剩下的这部分一定是大于前面的\",{\"1\":{\"138\":1}}],[\"因为零是起点\",{\"1\":{\"131\":1}}],[\"因为要求最小值\",{\"1\":{\"131\":1}}],[\"因为数据范围是从0开始的\",{\"1\":{\"55\":1}}],[\"因为r最大可取到10^9\",{\"1\":{\"55\":1}}],[\"因为题目的内存限制\",{\"1\":{\"54\":1}}],[\"因为当\",{\"1\":{\"46\":1}}],[\"恰好拼成\",{\"1\":{\"127\":1}}],[\"恰好不重不漏地分布在这\",{\"1\":{\"75\":1}}],[\"计数类dp\",{\"0\":{\"127\":1}}],[\"计算子串\",{\"1\":{\"244\":1}}],[\"计算公式如下\",{\"1\":{\"214\":1}}],[\"计算起始点经过队头到其他点的距离是否变短\",{\"1\":{\"176\":1}}],[\"计算结果可能为负数\",{\"1\":{\"148\":1}}],[\"计算结果时就要加上这一个\",{\"1\":{\"46\":1}}],[\"计算它们的差\",{\"1\":{\"148\":1}}],[\"计算它们的和\",{\"1\":{\"147\":1}}],[\"计算\",{\"1\":{\"141\":1,\"142\":1}}],[\"计算两个数的和\",{\"1\":{\"38\":1}}],[\"计算机网络\",{\"0\":{\"11\":1},\"1\":{\"8\":1}}],[\"计算机\",{\"0\":{\"8\":1}}],[\"替换\",{\"1\":{\"125\":1}}],[\"替换掉第一个大于或等于这个数字的那个数\",{\"1\":{\"121\":1}}],[\"删除失败会抛出异常\",{\"1\":{\"289\":1}}],[\"删除这个迭代器\",{\"1\":{\"245\":1}}],[\"删除所有x\",{\"1\":{\"245\":1}}],[\"删除任意一个元素\",{\"1\":{\"240\":1}}],[\"删除最小值\",{\"1\":{\"240\":1}}],[\"删除第k个点\",{\"1\":{\"227\":1}}],[\"删除前导0\",{\"1\":{\"148\":1,\"149\":1,\"150\":1}}],[\"删除\",{\"1\":{\"125\":1}}],[\"删除或替换算作一次操作\",{\"1\":{\"124\":1}}],[\"经过若干操作变为\",{\"1\":{\"125\":1}}],[\"经历了千辛万苦\",{\"1\":{\"104\":1}}],[\"序列中的数字均不超过\",{\"1\":{\"123\":1}}],[\"奶牛半懂不懂\",{\"1\":{\"123\":1}}],[\"再返回处理上一层找到的节点\",{\"1\":{\"264\":1}}],[\"再处理这个节点\",{\"1\":{\"263\":1}}],[\"再次继续匹配\",{\"1\":{\"234\":1}}],[\"再进行更新生成树\",{\"1\":{\"181\":1}}],[\"再更新\",{\"1\":{\"181\":1}}],[\"再把\",{\"1\":{\"181\":1}}],[\"再建立一个数组\",{\"1\":{\"176\":1}}],[\"再建立一个数组记录起始点到所有点的最短路径\",{\"1\":{\"176\":1}}],[\"再看个位是几\",{\"1\":{\"159\":1}}],[\"再按\",{\"1\":{\"158\":1}}],[\"再枚举左端点\",{\"1\":{\"126\":1}}],[\"再接下来\",{\"1\":{\"124\":1}}],[\"再让他们研究了最长公共子序列\",{\"1\":{\"123\":1}}],[\"再从地图右下角枚举边长为\",{\"1\":{\"54\":1}}],[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目\",{\"1\":{\"123\":1}}],[\"模拟堆栈\",{\"1\":{\"121\":1}}],[\"模板代码如下\",{\"1\":{\"126\":1}}],[\"模板代码\",{\"1\":{\"124\":1}}],[\"模板\",{\"0\":{\"3\":1,\"66\":1}}],[\"单词查找树\",{\"1\":{\"235\":1}}],[\"单调栈\",{\"0\":{\"230\":1}}],[\"单调队列\",{\"0\":{\"233\":1,\"270\":1},\"2\":{\"272\":1}}],[\"单调队列思维\",{\"1\":{\"121\":1}}],[\"单调队列写法\",{\"1\":{\"121\":1}}],[\"单链表只能存储当前节点的值和指向下一节点的指针\",{\"1\":{\"226\":1}}],[\"单链表\",{\"0\":{\"226\":1}}],[\"单源最短路\",{\"0\":{\"172\":1}}],[\"单位字节\",{\"1\":{\"26\":3}}],[\"三重循环\",{\"1\":{\"179\":1}}],[\"三\",{\"1\":{\"121\":1}}],[\"三个数的位数可能都不一样\",{\"1\":{\"109\":1}}],[\"三个数\",{\"1\":{\"109\":1}}],[\"三个子数组内各元素之和都相等\",{\"1\":{\"49\":1}}],[\"二叉树的\",{\"1\":{\"262\":1}}],[\"二叉树的中序遍历\",{\"0\":{\"261\":1},\"1\":{\"261\":1}}],[\"二叉树\",{\"1\":{\"240\":1},\"2\":{\"266\":1}}],[\"二进制中1的个数\",{\"1\":{\"159\":1}}],[\"二分\",{\"1\":{\"246\":1}}],[\"二分图\",{\"1\":{\"183\":2}}],[\"二分求出x对应的离散化的值\",{\"1\":{\"161\":1}}],[\"二分答案可以用来处理\",{\"1\":{\"143\":1}}],[\"二分答案模板\",{\"0\":{\"143\":1}}],[\"二分模板一共有两个\",{\"1\":{\"140\":1}}],[\"二分查找算法模板\",{\"0\":{\"140\":1}}],[\"二分算法\",{\"0\":{\"139\":1}}],[\"二分写法\",{\"1\":{\"121\":1}}],[\"二\",{\"1\":{\"118\":1,\"121\":1}}],[\"二维差分\",{\"0\":{\"155\":1}}],[\"二维前缀和\",{\"0\":{\"153\":1}}],[\"二维会爆栈\",{\"1\":{\"55\":1}}],[\"二维\",{\"1\":{\"37\":1,\"115\":1,\"116\":1}}],[\"组询问\",{\"1\":{\"211\":1}}],[\"组成最小生成树\",{\"1\":{\"182\":1}}],[\"组成的字符串中查找最长的\",{\"1\":{\"27\":1}}],[\"组物品和一个容量是\",{\"1\":{\"118\":1}}],[\"≤100\",{\"1\":{\"117\":1}}],[\"件物品\",{\"1\":{\"115\":1,\"116\":1,\"117\":1}}],[\"背包容量为\",{\"1\":{\"115\":1,\"116\":1,\"117\":1}}],[\"背包\",{\"0\":{\"115\":1}}],[\"背包问题常用枚举方法\",{\"1\":{\"114\":1}}],[\"背包问题\",{\"0\":{\"114\":1}}],[\"更新区间\",{\"1\":{\"255\":1}}],[\"更新端点和遍历的区间\",{\"1\":{\"254\":1}}],[\"更新右端点\",{\"1\":{\"251\":1}}],[\"更新t\",{\"1\":{\"181\":1}}],[\"更新其他点到集合的距离\",{\"1\":{\"181\":1}}],[\"更新\",{\"1\":{\"176\":1}}],[\"更新两点之间的最短距离\",{\"1\":{\"175\":1}}],[\"更新第一个点到起点的最短距离\",{\"1\":{\"173\":1}}],[\"更新完一个子节点\",{\"1\":{\"133\":1}}],[\"更新最短距离\",{\"1\":{\"131\":1}}],[\"更新前缀计数器\",{\"1\":{\"128\":1}}],[\"更新c\",{\"1\":{\"110\":1}}],[\"更平衡一些\",{\"1\":{\"66\":1}}],[\"继续上述迭代处理即可\",{\"1\":{\"264\":1}}],[\"继续down\",{\"1\":{\"240\":1}}],[\"继续枚举\",{\"1\":{\"110\":1}}],[\"继续后移\",{\"1\":{\"50\":1}}],[\"判断当前最大值的位置\",{\"1\":{\"269\":1}}],[\"判断当前元素与队尾元素是否满足单调性问题\",{\"1\":{\"233\":2}}],[\"判断当前a和c是否满足条件\",{\"1\":{\"110\":1}}],[\"判断队头是否滑出窗口\",{\"1\":{\"233\":1}}],[\"判断队头是否已经滑出窗口\",{\"1\":{\"233\":1}}],[\"判断队列是否为空\",{\"1\":{\"232\":1}}],[\"判断栈是否为空\",{\"1\":{\"229\":1}}],[\"判断这条边的两个顶点是否有相同的父节点\",{\"1\":{\"182\":1}}],[\"判断\",{\"1\":{\"175\":2,\"182\":1}}],[\"判断奇偶\",{\"1\":{\"158\":1}}],[\"判断b在这一位上有没有数\",{\"1\":{\"148\":1}}],[\"判断是否全为0\",{\"1\":{\"245\":1}}],[\"判断是否至少有一个1\",{\"1\":{\"245\":1}}],[\"判断是否有\",{\"1\":{\"148\":1}}],[\"判断是否变成了目标串\",{\"1\":{\"77\":1}}],[\"判断可能的答案更新区间\",{\"1\":{\"143\":1}}],[\"判断每一位上的数字是否用过\",{\"1\":{\"110\":1}}],[\"带入等式中看是否成立\",{\"1\":{\"109\":1}}],[\"带分数中\",{\"1\":{\"108\":1}}],[\"枚举当前状态的每一位\",{\"1\":{\"214\":1}}],[\"枚举每一列c\",{\"1\":{\"207\":1}}],[\"枚举分割点\",{\"1\":{\"126\":1}}],[\"枚举起点\",{\"1\":{\"126\":1}}],[\"枚举从1\",{\"1\":{\"214\":1}}],[\"枚举从\",{\"1\":{\"126\":1}}],[\"枚举a\",{\"1\":{\"110\":1}}],[\"枚举c\",{\"1\":{\"110\":1}}],[\"枚举\",{\"1\":{\"109\":1,\"193\":1}}],[\"枚举位数\",{\"1\":{\"109\":1}}],[\"枚举全排列\",{\"1\":{\"109\":1}}],[\"步骤\",{\"1\":{\"109\":1,\"212\":1,\"233\":1}}],[\"种表示法\",{\"1\":{\"108\":1}}],[\"类似于栈中的先进后出\",{\"1\":{\"264\":1}}],[\"类似这样的带分数\",{\"1\":{\"108\":1}}],[\"类型的对象不止包含字符串\",{\"1\":{\"26\":1}}],[\"类型\",{\"1\":{\"26\":1}}],[\"类型对象所能包含的最大字符数\",{\"1\":{\"26\":1}}],[\"类型对象最多包含的字符数\",{\"1\":{\"26\":1}}],[\"类型对象中的字符个数\",{\"1\":{\"26\":1}}],[\"美元\",{\"1\":{\"104\":1}}],[\"索道上的缆车最大承重量为\",{\"1\":{\"104\":1}}],[\"翰翰和达达就要付\",{\"1\":{\"104\":1}}],[\"翰翰和达达只好花钱让它们坐索道下山\",{\"1\":{\"104\":1}}],[\"翰翰和达达饲养了\",{\"1\":{\"104\":1}}],[\"呜咕>\",{\"1\":{\"104\":1}}],[\"小的合并到大的中\",{\"1\":{\"255\":1}}],[\"小的数\",{\"1\":{\"230\":1}}],[\"小于号\",{\"1\":{\"246\":2}}],[\"小于eps视为0\",{\"1\":{\"207\":1}}],[\"小技巧\",{\"1\":{\"244\":1}}],[\"小方格的种类数\",{\"1\":{\"130\":1}}],[\"小沐沐要你来告诉奶牛什么是最长公共上升子序列\",{\"1\":{\"123\":1}}],[\"小沐沐说\",{\"1\":{\"123\":1}}],[\"小沐沐先让奶牛研究了最长上升子序列\",{\"1\":{\"123\":1}}],[\"小猫们终于爬上了山顶\",{\"1\":{\"104\":1}}],[\"小猫们要去爬山\",{\"1\":{\"104\":1}}],[\"小树接在大树下面\",{\"1\":{\"66\":1}}],[\"只去掉相邻的相同元素\",{\"1\":{\"246\":1}}],[\"只是\",{\"1\":{\"202\":1}}],[\"只需将基数\",{\"1\":{\"202\":1}}],[\"只需要创建\",{\"1\":{\"287\":1}}],[\"只需要在最后面加上\",{\"1\":{\"274\":1}}],[\"只需要跟一个父亲比较大小就行\",{\"1\":{\"240\":1}}],[\"只需要判断\",{\"1\":{\"193\":1}}],[\"只需要另找一个数\",{\"1\":{\"158\":3}}],[\"只需要枚举\",{\"1\":{\"109\":1}}],[\"只可能是此时\",{\"1\":{\"195\":1}}],[\"只判断能否被小于\",{\"1\":{\"189\":1}}],[\"只出现在集合之间\",{\"1\":{\"183\":1}}],[\"只有祖宗节点的有意义\",{\"1\":{\"238\":1}}],[\"只有先手必胜和先手必败两种情况\",{\"1\":{\"216\":1}}],[\"只有当\",{\"1\":{\"182\":1}}],[\"只有a\",{\"1\":{\"121\":1}}],[\"只考虑正数的情况\",{\"1\":{\"148\":1}}],[\"只要它不是\",{\"1\":{\"193\":1}}],[\"只要根据最未位是\",{\"1\":{\"158\":1}}],[\"只要\",{\"1\":{\"158\":1}}],[\"只要找到这个连续段的左端点和右端点即可\",{\"1\":{\"144\":1}}],[\"只要告诉奶牛它的长度就可以了\",{\"1\":{\"123\":1}}],[\"只小猫的重量\",{\"1\":{\"104\":1}}],[\"只小猫的重量分别是\",{\"1\":{\"104\":1}}],[\"只小猫都运送下山\",{\"1\":{\"104\":1}}],[\"只小猫\",{\"1\":{\"104\":1}}],[\"只能输出c语言的内置数据类型\",{\"1\":{\"26\":1}}],[\"剪枝\",{\"1\":{\"102\":1}}],[\"⩽25\",{\"1\":{\"100\":1}}],[\"排序\",{\"1\":{\"245\":1,\"246\":2}}],[\"排在\",{\"1\":{\"100\":1}}],[\"排成一排\",{\"1\":{\"83\":1}}],[\"依次遍历每个区间\",{\"1\":{\"254\":1}}],[\"依次经过非匹配边\",{\"1\":{\"184\":1}}],[\"依次枚举第一个集合中的每个点能否匹配第二个集合中的点\",{\"1\":{\"184\":1}}],[\"依次枚举\",{\"1\":{\"144\":1}}],[\"依次枚举每个分支\",{\"1\":{\"98\":1}}],[\"依照科学家的预测\",{\"1\":{\"79\":1}}],[\"标记\",{\"1\":{\"195\":1}}],[\"标记点是否在队列中\",{\"1\":{\"176\":1}}],[\"标记为已加入到集合中\",{\"1\":{\"173\":1}}],[\"标记为0\",{\"1\":{\"148\":1}}],[\"标记为1\",{\"1\":{\"148\":1}}],[\"标记是否使用过\",{\"1\":{\"98\":1}}],[\"标号\",{\"1\":{\"131\":1}}],[\"标准兼容\",{\"1\":{\"282\":1}}],[\"标准库函数\",{\"1\":{\"26\":1}}],[\"标准件\",{\"1\":{\"15\":1}}],[\"字典序\",{\"1\":{\"245\":1}}],[\"字典序较小的排在前面\",{\"1\":{\"96\":1,\"100\":1}}],[\"字符矩阵\",{\"1\":{\"79\":1}}],[\"字符串哈希\",{\"0\":{\"244\":1}}],[\"字符串以\",{\"1\":{\"235\":1}}],[\"字符串中只包含小写字母\",{\"1\":{\"124\":1}}],[\"字符串\",{\"0\":{\"26\":1},\"1\":{\"245\":1}}],[\"首先遍历左子树\",{\"1\":{\"262\":1}}],[\"首先预处理出所有阶乘取模的余数fact\",{\"1\":{\"210\":1}}],[\"首先\",{\"1\":{\"96\":1,\"100\":1}}],[\"把一个数组去重\",{\"1\":{\"246\":1}}],[\"把一个\",{\"1\":{\"246\":2}}],[\"把一个方程的若干倍加到另一个方程上去\",{\"1\":{\"207\":1}}],[\"把第k位取反\",{\"1\":{\"245\":1}}],[\"把所有位变成0\",{\"1\":{\"245\":1}}],[\"把所有位置成1\",{\"1\":{\"245\":1}}],[\"把每个局面看成图中的一个节点\",{\"1\":{\"218\":1}}],[\"把游戏过程中面临的状态称为局面\",{\"1\":{\"216\":1}}],[\"把这一行换到最上面\",{\"1\":{\"207\":1}}],[\"把这个让给我好吧\",{\"1\":{\"184\":1}}],[\"把某行的若干倍加到另一行上去\",{\"1\":{\"207\":1}}],[\"把某一行乘一个非00的数\",{\"1\":{\"207\":1}}],[\"把找到的符合条件的点的长度加上\",{\"1\":{\"181\":1}}],[\"把b加入\",{\"1\":{\"176\":1}}],[\"把相加后的结果除以10求余\",{\"1\":{\"147\":1}}],[\"把集合选\",{\"1\":{\"127\":1}}],[\"把\",{\"1\":{\"96\":1}}],[\"从而提高系统的可靠性和容错能力\",{\"1\":{\"282\":1}}],[\"从而便于删除前导0\",{\"1\":{\"150\":1}}],[\"从根节点开始\",{\"1\":{\"262\":1}}],[\"从大到小排序需要加入第三个参数\",{\"1\":{\"246\":1}}],[\"从大到小排序\",{\"1\":{\"246\":1}}],[\"从0开始\",{\"1\":{\"234\":1}}],[\"从00\",{\"1\":{\"128\":1}}],[\"从队头弹出一个数\",{\"1\":{\"232\":1}}],[\"从栈顶弹出一个数\",{\"1\":{\"229\":1}}],[\"从一个未匹配路出发\",{\"1\":{\"184\":1}}],[\"从一个未匹配点出发\",{\"1\":{\"184\":1}}],[\"从高位到低位运算\",{\"1\":{\"150\":1}}],[\"从小到大枚举n的所有约数对里面比较小的那一个\",{\"1\":{\"197\":1}}],[\"从小到大枚举所有的质数\",{\"1\":{\"193\":1}}],[\"从小到大判断\",{\"1\":{\"197\":1}}],[\"从小到大尝试\",{\"1\":{\"190\":1}}],[\"从小到大遍历\",{\"1\":{\"189\":1,\"195\":1}}],[\"从小到大依次枚举每组边\",{\"1\":{\"182\":1}}],[\"从小到大\",{\"1\":{\"147\":1,\"148\":1}}],[\"从头开始遍历\",{\"1\":{\"138\":1}}],[\"从1\",{\"1\":{\"128\":1}}],[\"从下往上遍历\",{\"1\":{\"120\":1}}],[\"从上往下遍历\",{\"1\":{\"120\":1}}],[\"从顶部出发\",{\"1\":{\"120\":1}}],[\"从start开始枚举剩下的可选数字\",{\"1\":{\"102\":1}}],[\"从\",{\"1\":{\"92\":1,\"100\":1,\"109\":1,\"193\":1}}],[\"共\",{\"1\":{\"202\":1}}],[\"共一行\",{\"1\":{\"83\":1,\"159\":1}}],[\"共有多少种不同的截断方法\",{\"1\":{\"49\":1}}],[\"照片保证第\",{\"1\":{\"79\":1}}],[\"照片中有多少岛屿会被完全淹没\",{\"1\":{\"79\":1}}],[\"构建minioclient对象\",{\"1\":{\"287\":1}}],[\"构建依附关系\",{\"1\":{\"65\":1}}],[\"构造状态转移方程\",{\"1\":{\"126\":1}}],[\"构造成\",{\"1\":{\"109\":1}}],[\"构造成一个整数和一个分数\",{\"1\":{\"109\":1}}],[\"构成的\",{\"1\":{\"79\":1}}],[\"列col\",{\"1\":{\"207\":1}}],[\"列的状态是\",{\"1\":{\"130\":1}}],[\"列的像素都是海洋\",{\"1\":{\"79\":1}}],[\"列\",{\"1\":{\"79\":2,\"207\":1}}],[\"岛屿边缘一个像素的范围会被海水淹没\",{\"1\":{\"79\":1}}],[\"科学家预测未来几十年\",{\"1\":{\"79\":1}}],[\"座岛屿\",{\"1\":{\"79\":1}}],[\"四个方向上连在一起的一片陆地组成一座岛屿\",{\"1\":{\"79\":1}}],[\"像素的照片\",{\"1\":{\"79\":1}}],[\"找不到则返回最后一个元素的下标+1\",{\"1\":{\"246\":1}}],[\"找不到解决方案则输出\",{\"1\":{\"77\":1}}],[\"找出滑动窗口中的最大值\",{\"1\":{\"233\":1}}],[\"找出每个数左边离它最近的比它大\",{\"1\":{\"230\":1}}],[\"找右端点\",{\"1\":{\"142\":1}}],[\"找左端点\",{\"1\":{\"141\":1}}],[\"找到后处理并弹出\",{\"1\":{\"264\":1}}],[\"找到每一个数左边离他最近的比它小的数\",{\"1\":{\"230\":1}}],[\"找到绝对值最大的行\",{\"1\":{\"207\":1}}],[\"找到当前列绝对值最大的一行\",{\"1\":{\"207\":1}}],[\"找到最小整数解\",{\"1\":{\"206\":1}}],[\"找到该点赋给\",{\"1\":{\"181\":1}}],[\"找到不在集合当中的最小的点\",{\"1\":{\"181\":1}}],[\"找到一个未加入集合且距离最近的点\",{\"1\":{\"173\":1}}],[\"找到与起点最近的且未确定最短路径的点\",{\"1\":{\"173\":1}}],[\"找到第一个大于等于x的位置\",{\"1\":{\"161\":1}}],[\"找到j的根节点\",{\"1\":{\"63\":1}}],[\"找到i的根节点\",{\"1\":{\"63\":1}}],[\"恢复现场\",{\"1\":{\"77\":1,\"98\":1,\"102\":1}}],[\"变长数组\",{\"1\":{\"245\":1}}],[\"变换\",{\"1\":{\"207\":1}}],[\"变换串\",{\"1\":{\"77\":1}}],[\"变\",{\"1\":{\"158\":2}}],[\"变成b\",{\"1\":{\"125\":1}}],[\"变为\",{\"1\":{\"125\":1}}],[\"变量\",{\"1\":{\"38\":2}}],[\"包含\",{\"1\":{\"159\":1}}],[\"包含前导零\",{\"1\":{\"128\":1}}],[\"包含两个用空格隔开的整数\",{\"1\":{\"104\":1}}],[\"包含一个由字符\",{\"1\":{\"79\":1}}],[\"包含一个整数\",{\"1\":{\"75\":1,\"83\":1}}],[\"包括但不限于\",{\"1\":{\"280\":1}}],[\"包括但不限于书籍\",{\"1\":{\"20\":1}}],[\"包括负权边\",{\"1\":{\"175\":1}}],[\"包括编程语言\",{\"1\":{\"8\":1}}],[\"包括算法题\",{\"1\":{\"1\":1}}],[\"交替路\",{\"1\":{\"184\":1}}],[\"交换两个点\",{\"1\":{\"240\":1}}],[\"交换两个方程的位置\",{\"1\":{\"207\":1}}],[\"交换两个数\",{\"1\":{\"158\":1}}],[\"交换某两行\",{\"1\":{\"207\":1}}],[\"交换位置\",{\"1\":{\"77\":1}}],[\"交换过程如下\",{\"1\":{\"75\":1}}],[\"交互器将立即终止\",{\"1\":{\"32\":1}}],[\"交互题\",{\"0\":{\"32\":1}}],[\"示例中图形就可以通过让\",{\"1\":{\"75\":1}}],[\"示例代码\",{\"1\":{\"65\":1,\"66\":1}}],[\"右儿子相比最小的元素\",{\"1\":{\"240\":1}}],[\"右儿子是2x\",{\"1\":{\"240\":1}}],[\"右边丢弃\",{\"1\":{\"158\":1}}],[\"右边补0\",{\"1\":{\"158\":1}}],[\"右补0\",{\"1\":{\"158\":1}}],[\"右移\",{\"1\":{\"157\":1,\"158\":2,\"159\":1}}],[\"右移和\",{\"1\":{\"137\":1}}],[\"右半边剩下的\",{\"1\":{\"138\":1}}],[\"右端点\",{\"1\":{\"126\":1}}],[\"右三个方向的数字交换成功得到正确排列\",{\"1\":{\"75\":1}}],[\"右四个方向之一的数字交换\",{\"1\":{\"75\":1}}],[\"右任意一个方向移动一个位置\",{\"1\":{\"71\":1}}],[\"左补\",{\"1\":{\"158\":2}}],[\"左边的二进制位丢弃\",{\"1\":{\"158\":1}}],[\"左半边剩下的\",{\"1\":{\"138\":1}}],[\"左半边的子集\",{\"1\":{\"115\":1}}],[\"左移2位\",{\"1\":{\"158\":1}}],[\"左移\",{\"1\":{\"137\":1,\"157\":1,\"158\":2}}],[\"左\",{\"1\":{\"71\":1,\"75\":1}}],[\"左闭右开\",{\"1\":{\"37\":1}}],[\"下载\",{\"1\":{\"276\":1,\"277\":1}}],[\"下载安装包\",{\"1\":{\"274\":1}}],[\"下标从\",{\"1\":{\"240\":1}}],[\"下标从1开始\",{\"1\":{\"234\":1}}],[\"下标从1开始存\",{\"1\":{\"124\":1}}],[\"下家\",{\"1\":{\"184\":1}}],[\"下\",{\"1\":{\"71\":1,\"75\":2}}],[\"下面看题中完整的写法\",{\"1\":{\"66\":1}}],[\"下面有\",{\"1\":{\"65\":1}}],[\"已访问\",{\"1\":{\"133\":1}}],[\"已知该人每次可以向上\",{\"1\":{\"71\":1}}],[\"已路径压缩\",{\"0\":{\"62\":1}}],[\"处的数字为\",{\"1\":{\"71\":1}}],[\"处和\",{\"1\":{\"71\":1}}],[\"处\",{\"1\":{\"71\":2}}],[\"有十分完善的官方文档\",{\"1\":{\"282\":1}}],[\"有两个指针\",{\"1\":{\"227\":1}}],[\"有两个参数\",{\"1\":{\"37\":1}}],[\"有一个大小为\",{\"1\":{\"268\":1}}],[\"有一个1\",{\"1\":{\"214\":1}}],[\"有一个人位于左上角\",{\"1\":{\"71\":1}}],[\"有唯一解\",{\"1\":{\"207\":1}}],[\"有无穷多组解\",{\"1\":{\"207\":1}}],[\"有向图游戏的某个局面必败\",{\"1\":{\"221\":1}}],[\"有向图游戏的某个局面必胜\",{\"1\":{\"221\":1}}],[\"有向图游戏的和的sg函数值等于它包含的各个子游戏sg函数值的异或和\",{\"1\":{\"221\":1}}],[\"有向图游戏的和\",{\"0\":{\"221\":1}}],[\"有向图游戏\",{\"0\":{\"218\":1}}],[\"有向图\",{\"1\":{\"173\":1}}],[\"有向无环图被称为拓扑图\",{\"1\":{\"170\":1}}],[\"有的补0\",{\"1\":{\"157\":1}}],[\"有的补符号位\",{\"1\":{\"157\":1}}],[\"有符号数\",{\"1\":{\"157\":1}}],[\"有\",{\"1\":{\"108\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"211\":1}}],[\"或指针\",{\"1\":{\"246\":3}}],[\"或\",{\"1\":{\"71\":2,\"143\":1,\"157\":1,\"183\":1,\"244\":1,\"281\":1}}],[\"或者重载\",{\"1\":{\"246\":1}}],[\"或者\",{\"1\":{\"38\":1,\"66\":1,\"141\":1,\"142\":1,\"158\":1}}],[\"或者c++中的\",{\"1\":{\"32\":1}}],[\"或者问题用完了\",{\"1\":{\"32\":1}}],[\"搜索\",{\"0\":{\"69\":1},\"1\":{\"275\":1},\"2\":{\"89\":1}}],[\"搜索与图论\",{\"0\":{\"165\":1},\"1\":{\"3\":1}}],[\"比较左右两半边\",{\"1\":{\"138\":1}}],[\"比较高度\",{\"1\":{\"66\":1}}],[\"比如社交评论\",{\"1\":{\"280\":1}}],[\"比如围棋\",{\"1\":{\"217\":1}}],[\"比如归并排序中合并两个有序序列的操作\",{\"1\":{\"160\":1}}],[\"比如将数\",{\"1\":{\"158\":2}}],[\"比如取数\",{\"1\":{\"158\":1}}],[\"比如我们可以将多个参数整合为一个结构体传递到函数内部\",{\"1\":{\"40\":1}}],[\"比如\",{\"1\":{\"26\":1,\"46\":1,\"158\":2,\"159\":1,\"230\":1}}],[\"扁平化处理\",{\"1\":{\"66\":1}}],[\"将业务数据存储在云上\",{\"1\":{\"281\":1}}],[\"将每次移动的最大值保存在\",{\"1\":{\"269\":1}}],[\"将新的区间放入ans数组中\",{\"1\":{\"255\":1}}],[\"将指定线段区间完全覆盖\",{\"1\":{\"254\":1}}],[\"将第k位变成v\",{\"1\":{\"245\":1}}],[\"将当前元素加入到队尾\",{\"1\":{\"233\":1}}],[\"将当前元素加入队尾\",{\"1\":{\"233\":1}}],[\"将当前行的首位变成1\",{\"1\":{\"207\":1}}],[\"将下标是k的点后面的点删掉\",{\"1\":{\"226\":1}}],[\"将下面所有行的当且列的值变成\",{\"1\":{\"207\":1}}],[\"将头结点删除\",{\"1\":{\"226\":1}}],[\"将绝对值最大的行换到最顶端\",{\"1\":{\"207\":1}}],[\"将该行的第一个数变成\",{\"1\":{\"207\":1}}],[\"将这\",{\"1\":{\"206\":1}}],[\"将这一位相减后的结果压入c中\",{\"1\":{\"148\":1}}],[\"将其等价转换\",{\"1\":{\"206\":1}}],[\"将连通块逐渐扩大\",{\"1\":{\"181\":1}}],[\"将所有点分成\",{\"1\":{\"183\":1}}],[\"将所有存在交集的区间合并\",{\"1\":{\"162\":1}}],[\"将所有值排序\",{\"1\":{\"161\":1}}],[\"将前导0置于尾部\",{\"1\":{\"150\":1}}],[\"将上次的余数×10再加上当前位的数字\",{\"1\":{\"150\":1}}],[\"将问题转变成统计数列中\",{\"1\":{\"144\":1}}],[\"将模板\",{\"1\":{\"142\":1}}],[\"将临时序列放入原序列中\",{\"1\":{\"138\":1}}],[\"将小的放入一个临时序列\",{\"1\":{\"138\":1}}],[\"将整个序列均分为两部分\",{\"1\":{\"138\":1}}],[\"将字符串看成\",{\"1\":{\"244\":1}}],[\"将字符串\",{\"1\":{\"125\":2}}],[\"将会有很多种排列方法\",{\"1\":{\"83\":1}}],[\"将数字\",{\"1\":{\"83\":1}}],[\"将a串变为b串\",{\"1\":{\"77\":1}}],[\"将\",{\"1\":{\"66\":1,\"75\":1,\"109\":2,\"125\":1,\"158\":2,\"203\":1,\"277\":1,\"287\":1}}],[\"将一个对象拆分成\",{\"1\":{\"282\":1}}],[\"将一个容器中重复的元素删除\",{\"1\":{\"245\":1}}],[\"将一个新的节点x插入下标是k的后面\",{\"1\":{\"226\":1}}],[\"将一个数的各二进制位全部右移若干位\",{\"1\":{\"158\":1}}],[\"将一个运算对象的各二进制位全部左移若干位\",{\"1\":{\"158\":1}}],[\"将一个\",{\"1\":{\"28\":1}}],[\"题意\",{\"0\":{\"262\":1,\"268\":1}}],[\"题目意思是说\",{\"1\":{\"109\":1}}],[\"题目描述\",{\"0\":{\"45\":1,\"49\":1,\"53\":1,\"71\":1,\"75\":1,\"79\":1,\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"104\":1,\"108\":1},\"1\":{\"66\":1,\"144\":1}}],[\"题是比较简单的一道模板题\",{\"1\":{\"66\":1}}],[\"较平衡\",{\"1\":{\"66\":1}}],[\"高性能\",{\"1\":{\"281\":1,\"282\":1}}],[\"高斯消元适用解法\",{\"1\":{\"207\":1}}],[\"高斯消元\",{\"0\":{\"207\":1}}],[\"高位补0\",{\"1\":{\"157\":1}}],[\"高位丢弃\",{\"1\":{\"157\":1}}],[\"高位在后面\",{\"1\":{\"148\":1}}],[\"高精\",{\"1\":{\"149\":1,\"150\":1}}],[\"高精度乘低精度模板\",{\"1\":{\"212\":1}}],[\"高精度整数除法\",{\"0\":{\"150\":1}}],[\"高精度整数乘法\",{\"0\":{\"149\":1}}],[\"高精度减法\",{\"0\":{\"148\":1}}],[\"高精度加法\",{\"0\":{\"147\":1}}],[\"高精度算法\",{\"0\":{\"146\":1}}],[\"高度小的接在高的下面\",{\"1\":{\"66\":1}}],[\"高度小一些的树接到大一些的树下面\",{\"1\":{\"66\":1}}],[\"高度数组\",{\"1\":{\"66\":1}}],[\"高度\",{\"1\":{\"66\":1}}],[\"高效地开发和集成复杂的应用软件\",{\"1\":{\"15\":1}}],[\"过程\",{\"1\":{\"66\":1}}],[\"几乎退化成\",{\"1\":{\"66\":1}}],[\"树又称字典树\",{\"1\":{\"235\":1}}],[\"树与图的遍历\",{\"0\":{\"167\":1}}],[\"树与图的存储\",{\"0\":{\"166\":1}}],[\"树形dp\",{\"0\":{\"132\":1}}],[\"树的高度\",{\"1\":{\"182\":1,\"237\":1}}],[\"树的高度最坏情况下可能变成\",{\"1\":{\"66\":1}}],[\"树的根\",{\"1\":{\"133\":1}}],[\"树的根节点从0开始\",{\"1\":{\"38\":1}}],[\"树\",{\"1\":{\"66\":1}}],[\"其实隐式地维护了一个栈结构\",{\"1\":{\"264\":1}}],[\"其实关键在于\",{\"1\":{\"66\":1}}],[\"其余所有的数字依次跟着变化\",{\"1\":{\"207\":1}}],[\"其余位为\",{\"1\":{\"158\":3}}],[\"其表达式为\",{\"1\":{\"159\":1}}],[\"其更新操作是\",{\"1\":{\"141\":1,\"142\":1}}],[\"其位数和棋盘的行数一致\",{\"1\":{\"130\":1}}],[\"其次\",{\"1\":{\"96\":1,\"100\":1}}],[\"其时间复杂度就是树的高度\",{\"1\":{\"66\":1}}],[\"其中元素\",{\"1\":{\"240\":1}}],[\"其中任意两条边都不依附于同一个顶点\",{\"1\":{\"184\":1}}],[\"其中的第\",{\"1\":{\"159\":1}}],[\"其中一个作为分界点\",{\"1\":{\"137\":1}}],[\"其中i为数字个数\",{\"1\":{\"128\":2}}],[\"其中第\",{\"1\":{\"104\":1}}],[\"其中\",{\"1\":{\"38\":1,\"71\":1,\"79\":1,\"130\":1,\"159\":1,\"211\":1,\"276\":1}}],[\"洛谷\",{\"0\":{\"66\":1}}],[\"询问是否存在依附关系\",{\"1\":{\"65\":1}}],[\"查找每个键值对的元素\",{\"1\":{\"245\":1}}],[\"查找一个数\",{\"1\":{\"245\":1}}],[\"查找父节点\",{\"1\":{\"66\":1}}],[\"查找根节点\",{\"1\":{\"65\":1}}],[\"查询字符串出现的次数\",{\"1\":{\"235\":1}}],[\"查询一定要进行路径压缩\",{\"1\":{\"62\":1}}],[\"查询\",{\"0\":{\"62\":1},\"1\":{\"59\":1}}],[\"父节点为它自己\",{\"1\":{\"182\":1}}],[\"父节点设置为自己\",{\"1\":{\"61\":1}}],[\"父亲数组\",{\"1\":{\"65\":1,\"66\":1}}],[\"否则不更新\",{\"1\":{\"269\":1}}],[\"否则不存在拓扑序列\",{\"1\":{\"170\":1}}],[\"否则返回最小生成树的树边权重之和\",{\"1\":{\"181\":1}}],[\"否则返回\",{\"1\":{\"148\":1}}],[\"否则返回flase\",{\"1\":{\"148\":1}}],[\"否则返回false\",{\"1\":{\"148\":1,\"177\":1}}],[\"否则\",{\"1\":{\"121\":1}}],[\"否则需要再加一辆车\",{\"1\":{\"106\":1}}],[\"否则输出\",{\"1\":{\"65\":1,\"66\":1}}],[\"否则将会得到超过限制限制的结果\",{\"1\":{\"32\":1}}],[\"qmi\",{\"1\":{\"203\":1,\"210\":2,\"211\":2}}],[\"query\",{\"1\":{\"235\":1}}],[\"queue\",{\"1\":{\"176\":2,\"245\":2}}],[\"queue<pair<int\",{\"1\":{\"269\":1}}],[\"queue<pii\",{\"1\":{\"174\":1}}],[\"queue<pii>\",{\"1\":{\"73\":1}}],[\"queue<int\",{\"1\":{\"245\":1,\"253\":1}}],[\"queue<int>\",{\"1\":{\"169\":1,\"176\":1,\"177\":1}}],[\"queue<string>\",{\"1\":{\"77\":1}}],[\"quick\",{\"1\":{\"137\":3}}],[\"q\",{\"1\":{\"65\":6,\"73\":6,\"77\":6,\"121\":4,\"137\":8,\"169\":6,\"170\":3,\"176\":8,\"177\":6,\"232\":4,\"233\":3,\"245\":1,\"269\":7}}],[\"给你一个整数数组\",{\"1\":{\"268\":1}}],[\"给你一个初始网格\",{\"1\":{\"75\":1}}],[\"给以\",{\"1\":{\"155\":1}}],[\"给区间\",{\"1\":{\"154\":1}}],[\"给出一串数以及一个数字\",{\"1\":{\"144\":1}}],[\"给出了一些亲戚关系\",{\"1\":{\"65\":1}}],[\"给父亲更新\",{\"1\":{\"133\":1}}],[\"给定n堆物品\",{\"1\":{\"216\":1}}],[\"给定n个0和n个1\",{\"1\":{\"213\":1}}],[\"给定整数\",{\"1\":{\"194\":1}}],[\"给定一张\",{\"1\":{\"131\":1}}],[\"给定一个二叉树的根节点\",{\"1\":{\"262\":1}}],[\"给定一个序列\",{\"1\":{\"230\":1}}],[\"给定一个有向无环图\",{\"1\":{\"218\":1}}],[\"给定一个包含\",{\"1\":{\"207\":1}}],[\"给定一个如下图所示的数字三角形\",{\"1\":{\"120\":1}}],[\"给定一个整数\",{\"1\":{\"83\":1,\"214\":1}}],[\"给定一个\",{\"1\":{\"71\":1}}],[\"给定一个长度为\",{\"1\":{\"45\":1,\"49\":1,\"159\":1}}],[\"给定两个非负整数\",{\"1\":{\"149\":1,\"150\":1}}],[\"给定两个正整数\",{\"1\":{\"147\":1,\"148\":1,\"209\":1}}],[\"给定两个整数\",{\"1\":{\"128\":1}}],[\"给定两个字符串\",{\"1\":{\"125\":1}}],[\"给定两个长度分别为\",{\"1\":{\"122\":1}}],[\"给定\",{\"1\":{\"124\":1,\"206\":1,\"211\":1,\"251\":1,\"253\":1,\"254\":1}}],[\"亲戚关系\",{\"0\":{\"65\":1}}],[\"例题二\",{\"1\":{\"159\":1}}],[\"例题一\",{\"1\":{\"159\":1}}],[\"例题\",{\"0\":{\"159\":1}}],[\"例如求长度\",{\"1\":{\"160\":1}}],[\"例如求\",{\"1\":{\"159\":1}}],[\"例如上图中的海域未来会变成如下样子\",{\"1\":{\"79\":1}}],[\"例如上图就有\",{\"1\":{\"79\":1}}],[\"例如\",{\"1\":{\"75\":3,\"100\":1,\"147\":1,\"148\":1,\"158\":2,\"245\":1}}],[\"例如超过\",{\"1\":{\"26\":1}}],[\"例二\",{\"0\":{\"66\":1},\"1\":{\"144\":1}}],[\"例一\",{\"0\":{\"65\":1}}],[\"典例分析\",{\"0\":{\"64\":1}}],[\"粗暴的把\",{\"1\":{\"63\":1}}],[\"基于\",{\"1\":{\"280\":1,\"282\":1}}],[\"基于平衡二叉树\",{\"1\":{\"245\":1}}],[\"基本思路\",{\"1\":{\"203\":1}}],[\"基本步骤\",{\"1\":{\"176\":1}}],[\"基本模板\",{\"0\":{\"60\":1}}],[\"基本操作主要有\",{\"1\":{\"59\":1}}],[\"基础算法\",{\"0\":{\"136\":1},\"1\":{\"3\":1}}],[\"等各种复杂工作负载以及成为\",{\"1\":{\"282\":1}}],[\"等效替代\",{\"1\":{\"206\":1}}],[\"等\",{\"1\":{\"59\":1,\"281\":2}}],[\"等价于~\",{\"1\":{\"245\":1}}],[\"等价于\",{\"1\":{\"46\":1}}],[\"但对于数据传输的安全性和及时性有较高要求的业务来说\",{\"1\":{\"281\":1}}],[\"但关闭会话服务会停止\",{\"1\":{\"274\":1}}],[\"但城建的棋类游戏\",{\"1\":{\"217\":1}}],[\"但不能不取\",{\"1\":{\"216\":1}}],[\"但归并排序的核心在这一步骤\",{\"1\":{\"137\":1}}],[\"但是疲倦的它们再也不想徒步走下山了\",{\"1\":{\"104\":1}}],[\"但是不一定\",{\"1\":{\"66\":1}}],[\"但是有可能出现\",{\"1\":{\"63\":1}}],[\"但地图没有这么大\",{\"1\":{\"55\":1}}],[\"但其有一个缺点\",{\"1\":{\"53\":1}}],[\"递推式\",{\"1\":{\"209\":1}}],[\"递推法求组合数\",{\"0\":{\"209\":1}}],[\"递推求出二维前缀和\",{\"1\":{\"54\":1}}],[\"递归结束\",{\"1\":{\"263\":1}}],[\"递归终点\",{\"1\":{\"263\":1}}],[\"递归边界使某数变成了0\",{\"1\":{\"199\":1}}],[\"递归排序\",{\"1\":{\"138\":1}}],[\"递归的终止情况\",{\"1\":{\"137\":1}}],[\"递归处理子问题\",{\"1\":{\"137\":2}}],[\"递归从后往前更新\",{\"1\":{\"133\":1}}],[\"递归相关题型\",{\"0\":{\"90\":1}}],[\"递归出口\",{\"1\":{\"62\":1}}],[\"递归\",{\"0\":{\"263\":1},\"1\":{\"38\":1,\"199\":1},\"2\":{\"112\":1,\"266\":1}}],[\"坐标和价值\",{\"1\":{\"53\":1}}],[\"坐标\",{\"1\":{\"53\":1}}],[\"行row\",{\"1\":{\"207\":1}}],[\"行包含两个整数\",{\"1\":{\"206\":1}}],[\"行包含整数\",{\"1\":{\"206\":1}}],[\"行的整数表示第\",{\"1\":{\"104\":1}}],[\"行询问\",{\"1\":{\"65\":1}}],[\"行有\",{\"1\":{\"65\":1}}],[\"行\",{\"1\":{\"53\":1,\"66\":1,\"71\":1,\"79\":3,\"104\":2,\"124\":3,\"206\":1}}],[\"行每行包含一个整数\",{\"1\":{\"45\":1}}],[\"接口协议\",{\"1\":{\"282\":1}}],[\"接口\",{\"1\":{\"281\":1}}],[\"接下来\",{\"1\":{\"53\":1,\"66\":1,\"71\":1,\"124\":1}}],[\"接收参数\",{\"1\":{\"39\":2}}],[\"轴平行\",{\"1\":{\"53\":1}}],[\"激光炸弹的投放是通过卫星定位的\",{\"1\":{\"53\":1}}],[\"每\",{\"1\":{\"206\":1}}],[\"每组询问给定三个整数\",{\"1\":{\"211\":1}}],[\"每组物品有若干个\",{\"1\":{\"118\":1}}],[\"每组数据包括三个整数\",{\"1\":{\"53\":1}}],[\"每件物品有有限个\",{\"1\":{\"117\":1}}],[\"每件物品只能使用无限次\",{\"1\":{\"116\":1}}],[\"每件物品只能使用一次\",{\"1\":{\"115\":1}}],[\"每辆车所搭载的重量\",{\"1\":{\"106\":1}}],[\"每辆缆车上的小猫的重量之和不能超过\",{\"1\":{\"104\":1}}],[\"每只猫的重量\",{\"1\":{\"106\":1}}],[\"每租用一辆缆车\",{\"1\":{\"104\":1}}],[\"每个\",{\"1\":{\"287\":1}}],[\"每个对象都包含了数据本身以及元数据\",{\"1\":{\"281\":1}}],[\"每个对字符串进行的单个字符的插入\",{\"1\":{\"124\":1}}],[\"每个正整数都能够以唯一的方式表示成它的质因数的乘积\",{\"1\":{\"190\":1}}],[\"每个人只有两种状态\",{\"1\":{\"133\":1}}],[\"每个数都要用到且只出现一次\",{\"1\":{\"109\":1}}],[\"每个方案占一行\",{\"1\":{\"83\":1}}],[\"每个目标都有一个价值\",{\"1\":{\"53\":1}}],[\"每行一个整数\",{\"1\":{\"104\":1}}],[\"每行\",{\"1\":{\"96\":1,\"100\":1}}],[\"每行输出一个整数作为结果\",{\"1\":{\"124\":1}}],[\"每行输出一种方案\",{\"1\":{\"92\":1}}],[\"每行输入一组数据\",{\"1\":{\"53\":1}}],[\"每行包含一个字符串和一个整数\",{\"1\":{\"124\":1}}],[\"每行包含一个字符串\",{\"1\":{\"124\":1}}],[\"每行包含一个大写字母\",{\"1\":{\"66\":1}}],[\"每行包含\",{\"1\":{\"71\":1}}],[\"每行包含三个整数\",{\"1\":{\"66\":1}}],[\"每行为\",{\"1\":{\"65\":1}}],[\"每行有两个数\",{\"1\":{\"65\":1}}],[\"每次可以移动一步\",{\"1\":{\"218\":1}}],[\"每次可以任选一堆\",{\"1\":{\"216\":1}}],[\"每次异或操作\",{\"1\":{\"216\":1}}],[\"每次都让较大的数对较小数取模\",{\"1\":{\"199\":1}}],[\"每次将\",{\"1\":{\"183\":1}}],[\"每次将区间长度缩小一半\",{\"1\":{\"140\":1}}],[\"每次迭代选择一条不在集合内的权值最短的边\",{\"1\":{\"182\":1}}],[\"每次迭代找到不在连通块中的距离最近的点\",{\"1\":{\"181\":1}}],[\"每次循环遍历所有边\",{\"1\":{\"175\":1}}],[\"每次循环都先将\",{\"1\":{\"137\":1}}],[\"每次备份一下\",{\"1\":{\"175\":1}}],[\"每次只需判断答案是否需要更新\",{\"1\":{\"143\":1}}],[\"每次比较\",{\"1\":{\"138\":1}}],[\"每次询问给出一个字符串和一个操作次数上限\",{\"1\":{\"124\":1}}],[\"每次递归的同时也对\",{\"1\":{\"109\":1}}],[\"每次当第三段符合时\",{\"1\":{\"50\":1}}],[\"每次前缀和都取模\",{\"1\":{\"47\":1}}],[\"每次用\",{\"1\":{\"46\":1}}],[\"地图上有\",{\"1\":{\"53\":1}}],[\"都会被写入到同一个日志文件中\",{\"1\":{\"274\":1}}],[\"都会被写入到这个日志文件中\",{\"1\":{\"274\":1}}],[\"都会输掉游戏\",{\"1\":{\"216\":1}}],[\"都可以是\",{\"1\":{\"245\":1}}],[\"都采取最优策略行动时游戏的结果\",{\"1\":{\"216\":1}}],[\"都是由男孩子指向女孩子\",{\"1\":{\"184\":1}}],[\"都有一行输出\",{\"1\":{\"66\":1}}],[\"都加上第一段符合的个数即可\",{\"1\":{\"50\":1}}],[\"都符合条件\",{\"1\":{\"50\":1}}],[\"都一定是\",{\"1\":{\"31\":1,\"205\":1}}],[\"先处理这个节点的左子树\",{\"1\":{\"263\":1}}],[\"先进先出\",{\"1\":{\"231\":1}}],[\"先进后出\",{\"1\":{\"228\":1}}],[\"先存值\",{\"1\":{\"226\":1}}],[\"先手走不到任何一个必败状态\",{\"1\":{\"216\":1}}],[\"先手\",{\"1\":{\"216\":1}}],[\"先手可以走到某一个必败状态\",{\"1\":{\"216\":1}}],[\"先手进行\",{\"1\":{\"216\":1}}],[\"先整除再乘\",{\"1\":{\"201\":1}}],[\"先累加\",{\"1\":{\"181\":1}}],[\"先把所有距离初始化为正无穷\",{\"1\":{\"181\":1}}],[\"先把第\",{\"1\":{\"159\":1}}],[\"先对数列排序\",{\"1\":{\"144\":1}}],[\"先递归再合并\",{\"1\":{\"138\":1}}],[\"先枚举长度\",{\"1\":{\"126\":1}}],[\"先后与右\",{\"1\":{\"75\":1}}],[\"先判断第一段是否符合\",{\"1\":{\"50\":1}}],[\"先判断如果\",{\"1\":{\"50\":1}}],[\"先预处理前缀和\",{\"1\":{\"50\":1}}],[\"所谓采取最优策略是指\",{\"1\":{\"216\":1}}],[\"所含匹配边数最多的匹配\",{\"1\":{\"184\":1}}],[\"所得即为商在这一位的数字\",{\"1\":{\"150\":1}}],[\"所有节点均不为空\",{\"1\":{\"240\":1}}],[\"所有数的个数为各个集合的并集\",{\"1\":{\"214\":1}}],[\"所有的顶点都是匹配点\",{\"1\":{\"184\":1}}],[\"所有的区间\",{\"1\":{\"126\":1}}],[\"所有边\",{\"1\":{\"175\":1,\"183\":1}}],[\"所有边权都是正数\",{\"1\":{\"172\":1}}],[\"所有将a\",{\"1\":{\"125\":1}}],[\"所有测试点满足\",{\"1\":{\"49\":1}}],[\"所在的目录\",{\"1\":{\"276\":1}}],[\"所在的集合合并\",{\"1\":{\"66\":1}}],[\"所在目录下启动\",{\"1\":{\"274\":1}}],[\"所在树的根节点下面\",{\"1\":{\"63\":1}}],[\"所在树的根节点接到\",{\"1\":{\"63\":1}}],[\"所以基于对象的形式\",{\"1\":{\"281\":1}}],[\"所以可以用str\",{\"1\":{\"235\":1}}],[\"所以idx从2开始\",{\"1\":{\"227\":1}}],[\"所以是乘\",{\"1\":{\"211\":1}}],[\"所以有\",{\"1\":{\"205\":1}}],[\"所以此时应该退出循环\",{\"1\":{\"195\":1}}],[\"所以先预处理好\",{\"1\":{\"194\":1}}],[\"所以这里只用存一个方向的边\",{\"1\":{\"184\":1}}],[\"所以存边的时候\",{\"1\":{\"184\":1}}],[\"所以存在环\",{\"1\":{\"177\":1}}],[\"所以需要将其翻转\",{\"1\":{\"150\":1}}],[\"所以从后遍历\",{\"1\":{\"148\":1}}],[\"所以一直更新根就行了\",{\"1\":{\"133\":1}}],[\"所以f\",{\"1\":{\"131\":1}}],[\"所以初始化为无穷大\",{\"1\":{\"131\":1}}],[\"所以他们想知道\",{\"1\":{\"104\":1}}],[\"所以要\",{\"1\":{\"46\":1}}],[\"所以\",{\"1\":{\"26\":1,\"195\":1,\"205\":1}}],[\"请你选择尽量少的区间\",{\"1\":{\"254\":1}}],[\"请你在数轴上选择尽量少的点\",{\"1\":{\"251\":1}}],[\"请你输出\",{\"1\":{\"211\":1}}],[\"请你求出数列中每个数的二进制表示中\",{\"1\":{\"159\":1}}],[\"请你求出\",{\"1\":{\"127\":1,\"214\":1}}],[\"请你求出给定的\",{\"1\":{\"124\":1}}],[\"请你求出得到正确排列至少需要进行多少次交换\",{\"1\":{\"75\":1}}],[\"请你按照字典序将所有的排列方法输出\",{\"1\":{\"83\":1}}],[\"请你计算\",{\"1\":{\"79\":1}}],[\"请写一个程序\",{\"1\":{\"65\":1}}],[\"请问\",{\"1\":{\"49\":1,\"71\":1}}],[\"请打印\",{\"1\":{\"32\":2}}],[\"现在给定一个正整数\",{\"1\":{\"127\":1}}],[\"现在请你求出\",{\"1\":{\"125\":1}}],[\"现在要将\",{\"1\":{\"125\":1}}],[\"现在又让他们研究最长公共上升子序列了\",{\"1\":{\"123\":1}}],[\"现在又多了一个\",{\"1\":{\"47\":1}}],[\"现在有一个并查集\",{\"1\":{\"66\":1}}],[\"现在有一种新型的激光炸弹\",{\"1\":{\"53\":1}}],[\"现在有若干家族图谱关系\",{\"1\":{\"65\":1}}],[\"现在\",{\"1\":{\"49\":1,\"75\":1,\"83\":1}}],[\"代替\",{\"1\":{\"158\":1}}],[\"代码段\",{\"1\":{\"148\":1}}],[\"代码如下\",{\"1\":{\"147\":1,\"149\":1,\"150\":1,\"159\":2}}],[\"代码\",{\"0\":{\"47\":1,\"51\":1,\"55\":1,\"73\":1,\"77\":1,\"81\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1},\"1\":{\"123\":1,\"125\":1,\"126\":1,\"263\":1,\"264\":1,\"269\":1}}],[\"代表一张海域照片\",{\"1\":{\"79\":1}}],[\"代表一颗炸弹最多能炸掉地图上目标的总价值数目\",{\"1\":{\"53\":1}}],[\"代表\",{\"1\":{\"45\":1}}],[\"不管其是存放的数据块还是奇偶校验块\",{\"1\":{\"282\":1}}],[\"不支持\",{\"1\":{\"245\":1}}],[\"不满足条件\",{\"1\":{\"217\":1}}],[\"不能行动的玩家判负\",{\"1\":{\"217\":1}}],[\"不能开到\",{\"1\":{\"55\":1}}],[\"不存在\",{\"1\":{\"206\":1}}],[\"不一定是\",{\"1\":{\"183\":1}}],[\"不包括自己\",{\"1\":{\"177\":1}}],[\"不包含前导零\",{\"1\":{\"128\":1}}],[\"不包含\",{\"1\":{\"108\":1}}],[\"不为空\",{\"1\":{\"176\":1}}],[\"不是\",{\"1\":{\"195\":1,\"202\":1,\"210\":1}}],[\"不是起点\",{\"1\":{\"181\":1}}],[\"不是一定\",{\"1\":{\"175\":1}}],[\"不是c语言的内置数据类型\",{\"1\":{\"26\":1}}],[\"不需要创建\",{\"1\":{\"289\":1}}],[\"不需要初始化dist数组\",{\"1\":{\"177\":1}}],[\"不需要借位\",{\"1\":{\"148\":1}}],[\"不需要再跟别的前缀和组合\",{\"1\":{\"46\":1}}],[\"不用全部遍历\",{\"1\":{\"147\":1,\"148\":1}}],[\"不含前导0\",{\"1\":{\"147\":1,\"148\":1,\"149\":1,\"150\":1}}],[\"不重不漏地经过每个点恰好一次\",{\"1\":{\"131\":1}}],[\"不重复不遗漏地组成带分数表示的全部种数\",{\"1\":{\"108\":1}}],[\"不过\",{\"1\":{\"123\":1}}],[\"不连续\",{\"0\":{\"122\":1}}],[\"不同\",{\"1\":{\"282\":1}}],[\"不同颜色\",{\"1\":{\"183\":1}}],[\"不同为\",{\"1\":{\"158\":1}}],[\"不同为1\",{\"1\":{\"157\":1}}],[\"不同位置的数字一样的数对算不同的数对\",{\"1\":{\"144\":1}}],[\"不同方案\",{\"1\":{\"92\":1}}],[\"不同目标可能在同一位置\",{\"1\":{\"53\":1}}],[\"不妨称为\",{\"1\":{\"66\":1}}],[\"不断向上寻找最初的根节点\",{\"1\":{\"65\":1}}],[\"不断往上查找祖先\",{\"1\":{\"62\":1}}],[\"不然大概率会超时\",{\"1\":{\"62\":1}}],[\"然后在遍历左子树的时候\",{\"1\":{\"262\":1}}],[\"然后访问根节点\",{\"1\":{\"262\":2}}],[\"然后\",{\"1\":{\"211\":1}}],[\"然后重复\",{\"1\":{\"199\":1}}],[\"然后删去它们的所有的倍数\",{\"1\":{\"193\":1}}],[\"然后将\",{\"1\":{\"158\":3}}],[\"然后判断\",{\"1\":{\"137\":1}}],[\"然后每次都\",{\"1\":{\"109\":1}}],[\"然后我们再求其前缀和\",{\"1\":{\"54\":1}}],[\"然后从\",{\"1\":{\"50\":1,\"194\":1}}],[\"然后从标准输入中输入响应\",{\"1\":{\"32\":1}}],[\"然后再加上现在的前缀和\",{\"1\":{\"46\":1}}],[\"前台启动\",{\"1\":{\"274\":1}}],[\"前置知识\",{\"1\":{\"207\":1}}],[\"前提\",{\"1\":{\"148\":1}}],[\"前缀部分\",{\"1\":{\"128\":1}}],[\"前缀和与差分\",{\"0\":{\"151\":1}}],[\"前缀和的值\",{\"1\":{\"46\":1}}],[\"前缀和\",{\"1\":{\"46\":2},\"2\":{\"57\":1}}],[\"前缀和相关题型\",{\"0\":{\"43\":1}}],[\"前\",{\"1\":{\"127\":2}}],[\"前面\",{\"1\":{\"100\":1}}],[\"前面有几个\",{\"1\":{\"46\":1}}],[\"前六个测试点满足\",{\"1\":{\"49\":1}}],[\"相关概念\",{\"1\":{\"184\":1}}],[\"相当于文件\",{\"1\":{\"287\":1}}],[\"相当于存放文件的顶层文件夹\",{\"1\":{\"287\":1}}],[\"相当于存在两个相邻的点染成了相同的颜色\",{\"1\":{\"183\":1}}],[\"相当于是每次考虑合并两个式子\",{\"1\":{\"206\":1}}],[\"相当于该数除以\",{\"1\":{\"158\":1}}],[\"相当于该数乘以\",{\"1\":{\"158\":1}}],[\"相当于结构体\",{\"1\":{\"40\":1}}],[\"相异或值不变\",{\"1\":{\"158\":1}}],[\"相同\",{\"1\":{\"246\":1}}],[\"相同数量级的数即可\",{\"1\":{\"175\":1}}],[\"相同为\",{\"1\":{\"158\":1}}],[\"相同的个数\",{\"1\":{\"46\":1}}],[\"相邻两个数用一个空格隔开\",{\"1\":{\"100\":1}}],[\"相邻两个数用恰好\",{\"1\":{\"92\":1}}],[\"相等\",{\"1\":{\"46\":1}}],[\"来解决\",{\"1\":{\"159\":1}}],[\"来判断\",{\"1\":{\"158\":1}}],[\"来决定\",{\"1\":{\"158\":1}}],[\"来存储每个元素的父节点\",{\"1\":{\"61\":1}}],[\"来递加\",{\"1\":{\"46\":1}}],[\"来求出\",{\"1\":{\"46\":1}}],[\"用作云原生应用程序的主要存储\",{\"1\":{\"282\":1}}],[\"用于删除指定存储桶中的对象\",{\"1\":{\"290\":1}}],[\"用于删除一个已存在的存储桶\",{\"1\":{\"289\":1}}],[\"用于列出指定存储桶中的所有对象\",{\"1\":{\"290\":1}}],[\"用于列出用户有权访问的所有存储桶\",{\"1\":{\"289\":1}}],[\"用于从指定的存储桶中下载文件\",{\"1\":{\"290\":1}}],[\"用于生成一个对象\",{\"1\":{\"290\":1}}],[\"用于检查指定的对象\",{\"1\":{\"290\":1}}],[\"用于检查指定的存储桶是否存在\",{\"1\":{\"289\":1}}],[\"用于上传文件到指定的存储桶\",{\"1\":{\"290\":1}}],[\"用于创建一个新的存储桶\",{\"1\":{\"289\":1}}],[\"用于将命令放到后台执行\",{\"1\":{\"274\":1}}],[\"用于运行另一个命令在后台\",{\"1\":{\"274\":1}}],[\"用于求解方程\",{\"1\":{\"205\":1}}],[\"用户名和密码都可以省略\",{\"1\":{\"274\":1}}],[\"用一个小根堆来维护所有组的右端点\",{\"1\":{\"253\":1}}],[\"用一个一维数组存储树\",{\"1\":{\"240\":1}}],[\"用法与\",{\"1\":{\"246\":1}}],[\"用单调队列来优化\",{\"1\":{\"233\":1}}],[\"用高精度乘法将所有质因子相乘\",{\"1\":{\"212\":2}}],[\"用高精度乘法把所有质因子乘上\",{\"1\":{\"212\":1}}],[\"用高精度相乘即可\",{\"1\":{\"212\":1}}],[\"用当前行将下面所有的列消成0\",{\"1\":{\"207\":1}}],[\"用初等行变换\",{\"1\":{\"207\":3}}],[\"用扩展欧几里得算法找出一组解\",{\"1\":{\"206\":1}}],[\"用上面的公式定义求\",{\"1\":{\"201\":1}}],[\"用两数之积除以他们的最大公约数可得最小公倍数\",{\"1\":{\"199\":1}}],[\"用两个指针维护一段区间\",{\"1\":{\"160\":1}}],[\"用最小质因子去筛合数\",{\"1\":{\"195\":1}}],[\"用质数把其所有的倍数都筛掉\",{\"1\":{\"193\":1}}],[\"用队列来存储\",{\"1\":{\"176\":1}}],[\"用t更新其他点的距离\",{\"1\":{\"173\":1}}],[\"用途\",{\"0\":{\"158\":1}}],[\"用的数字个数+1\",{\"1\":{\"110\":1}}],[\"用了几个数\",{\"1\":{\"110\":2}}],[\"用过则不合法\",{\"1\":{\"110\":1}}],[\"用来处理\",{\"1\":{\"282\":1}}],[\"用来查找小于等于\",{\"1\":{\"142\":1}}],[\"用来查找大于等于\",{\"1\":{\"142\":1}}],[\"用来表示哪一行的小方块是横着放的\",{\"1\":{\"130\":1}}],[\"用来表示一个迷宫\",{\"1\":{\"71\":1}}],[\"用来判断\",{\"1\":{\"36\":1}}],[\"用这种写法不过是略微优化了一下\",{\"1\":{\"66\":1}}],[\"用整数\",{\"1\":{\"53\":1}}],[\"用\",{\"1\":{\"46\":1,\"109\":1,\"149\":1,\"150\":1,\"159\":1,\"181\":1,\"183\":1,\"203\":1,\"210\":1,\"245\":1}}],[\"则更新最大值\",{\"1\":{\"269\":1}}],[\"则无解\",{\"1\":{\"254\":1}}],[\"则点数+1\",{\"1\":{\"251\":1}}],[\"则往下沉\",{\"1\":{\"240\":1}}],[\"则最小的数为右儿子\",{\"1\":{\"240\":1}}],[\"则最小的数为左二子\",{\"1\":{\"240\":1}}],[\"则优先采取该行动\",{\"1\":{\"216\":1}}],[\"则系数应该是1\",{\"1\":{\"214\":1}}],[\"则n\",{\"1\":{\"214\":1}}],[\"则对于任意整数\",{\"1\":{\"211\":1}}],[\"则称该游戏为一个公平组合游戏\",{\"1\":{\"217\":1}}],[\"则称该局面必败\",{\"1\":{\"216\":1}}],[\"则称\",{\"1\":{\"210\":1}}],[\"则存在一个整数\",{\"1\":{\"210\":1}}],[\"则有\",{\"1\":{\"210\":1}}],[\"则数据保证\",{\"1\":{\"206\":1}}],[\"则可以通过扩展欧几里得来求解\",{\"1\":{\"205\":1}}],[\"则为\",{\"1\":{\"203\":1}}],[\"则pj一定是i的最小公因子\",{\"1\":{\"195\":1}}],[\"则匹配成功\",{\"1\":{\"184\":1}}],[\"则这条交替路称为增广路\",{\"1\":{\"184\":1}}],[\"则这个数出现的次数就可以表示为\",{\"1\":{\"144\":1}}],[\"则加入这条边到集合中\",{\"1\":{\"182\":1}}],[\"则选择该点\",{\"1\":{\"181\":1}}],[\"则说明存在环\",{\"1\":{\"177\":1}}],[\"则把该点加入到队尾\",{\"1\":{\"176\":1}}],[\"则返回inf\",{\"1\":{\"181\":1}}],[\"则返回true\",{\"1\":{\"177\":1}}],[\"则返回\",{\"1\":{\"174\":1,\"175\":1}}],[\"则每左移一位\",{\"1\":{\"158\":1}}],[\"则向高位借位\",{\"1\":{\"148\":1}}],[\"则直接减\",{\"1\":{\"148\":1}}],[\"则减去b\",{\"1\":{\"148\":1}}],[\"则压入c数组中\",{\"1\":{\"147\":1}}],[\"则将这两个连通块合并\",{\"1\":{\"182\":1}}],[\"则将其转化为\",{\"1\":{\"148\":1}}],[\"则将剩余那一部分直接接在临时序列的后面\",{\"1\":{\"138\":1}}],[\"则将该元素入栈\",{\"1\":{\"121\":1}}],[\"则设\",{\"1\":{\"133\":1}}],[\"则不需要将j重复插入\",{\"1\":{\"176\":1}}],[\"则不合法\",{\"1\":{\"110\":1}}],[\"则不能被均分为三份\",{\"1\":{\"50\":1}}],[\"则输入为\",{\"1\":{\"75\":1}}],[\"则输出结果\",{\"1\":{\"233\":1}}],[\"则输出\",{\"1\":{\"65\":1,\"75\":1,\"206\":1}}],[\"则表示该切割点不行\",{\"1\":{\"50\":1}}],[\"则第二段也一定相等\",{\"1\":{\"50\":1}}],[\"则\",{\"1\":{\"46\":1,\"159\":2,\"201\":1}}],[\"就要付出较高的公网带宽传输成本\",{\"1\":{\"281\":1}}],[\"就把k改为l\",{\"1\":{\"227\":1}}],[\"就不是公平组合游戏\",{\"1\":{\"217\":1}}],[\"就不是用最小质因子去更新了\",{\"1\":{\"195\":1}}],[\"就可以把埃氏筛法运用在\",{\"1\":{\"194\":1}}],[\"就删去了所有的合数\",{\"1\":{\"193\":1}}],[\"就将这条边加入集合中\",{\"1\":{\"182\":1}}],[\"就得到了最短路径\",{\"1\":{\"176\":1}}],[\"就说明存在一条长度是n+1的最短路径\",{\"1\":{\"175\":1}}],[\"就交换位置\",{\"1\":{\"240\":1}}],[\"就交换\",{\"1\":{\"137\":1}}],[\"就返回祖先\",{\"1\":{\"62\":1}}],[\"就是判断\",{\"1\":{\"203\":1}}],[\"就是一个质因数\",{\"1\":{\"193\":1}}],[\"就是\",{\"1\":{\"183\":1,\"195\":1}}],[\"就是给定一个无向图\",{\"1\":{\"180\":1}}],[\"就是奇数\",{\"1\":{\"158\":1}}],[\"就是偶数\",{\"1\":{\"158\":1}}],[\"就是其爆炸范围\",{\"1\":{\"53\":1}}],[\"就是区间\",{\"1\":{\"46\":1}}],[\"就默认添加此选项\",{\"1\":{\"38\":1}}],[\"思路二\",{\"0\":{\"264\":1,\"270\":1}}],[\"思路一\",{\"0\":{\"263\":1,\"269\":1}}],[\"思路\",{\"0\":{\"46\":1,\"50\":1,\"54\":1,\"72\":1,\"76\":1,\"80\":1,\"84\":1,\"93\":1,\"97\":1,\"101\":1,\"105\":1,\"109\":1},\"1\":{\"159\":2,\"193\":1,\"202\":1,\"206\":1}}],[\"输入的参数是pair或者迭代器\",{\"1\":{\"245\":1}}],[\"输入一个迭代器\",{\"1\":{\"245\":1}}],[\"输入一个整数\",{\"1\":{\"92\":1}}],[\"输入是一个数x\",{\"1\":{\"245\":1}}],[\"输入\",{\"1\":{\"212\":1}}],[\"输入占一行\",{\"1\":{\"75\":1}}],[\"输入样例3\",{\"1\":{\"49\":1}}],[\"输入样例2\",{\"1\":{\"49\":1,\"79\":1,\"108\":1}}],[\"输入样例1\",{\"1\":{\"49\":1,\"79\":1,\"108\":1}}],[\"输入样例\",{\"1\":{\"45\":1,\"53\":1,\"65\":1,\"66\":1,\"71\":1,\"75\":1,\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"104\":1,\"123\":1}}],[\"输入格式\",{\"1\":{\"45\":1,\"49\":1,\"53\":1,\"65\":1,\"66\":1,\"71\":1,\"75\":1,\"79\":1,\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"104\":1,\"108\":1,\"123\":1,\"124\":1,\"159\":1,\"206\":1}}],[\"输出选择的点的最小数量\",{\"1\":{\"251\":1}}],[\"输出以0开始的匹配子串的首字母下标\",{\"1\":{\"234\":1}}],[\"输出最小非负整数\",{\"1\":{\"206\":1}}],[\"输出i的s次幂\",{\"1\":{\"190\":1}}],[\"输出即可\",{\"1\":{\"190\":1}}],[\"输出如下\",{\"1\":{\"159\":1}}],[\"输出共\",{\"1\":{\"124\":1}}],[\"输出输入数字用数码\",{\"1\":{\"108\":1}}],[\"输出方案\",{\"1\":{\"98\":1}}],[\"输出所有可能的次序\",{\"1\":{\"96\":1}}],[\"输出所有可能的选择方案\",{\"1\":{\"92\":1,\"100\":1}}],[\"输出空行\",{\"1\":{\"92\":1}}],[\"输出占一行\",{\"1\":{\"75\":1}}],[\"输出一行\",{\"1\":{\"65\":1}}],[\"输出一个正整数\",{\"1\":{\"53\":1}}],[\"输出一个整数\",{\"1\":{\"45\":1,\"49\":1,\"71\":1,\"104\":1,\"123\":1}}],[\"输出样例3\",{\"1\":{\"49\":1}}],[\"输出样例2\",{\"1\":{\"49\":1,\"79\":1,\"108\":1}}],[\"输出样例1\",{\"1\":{\"49\":1,\"79\":1,\"108\":1}}],[\"输出样例\",{\"1\":{\"45\":1,\"53\":1,\"65\":1,\"66\":1,\"71\":1,\"75\":1,\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"104\":1,\"123\":1}}],[\"输出格式\",{\"1\":{\"45\":1,\"49\":1,\"53\":1,\"65\":1,\"66\":1,\"71\":1,\"75\":1,\"79\":1,\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"104\":1,\"108\":1,\"123\":1,\"124\":1,\"159\":1,\"206\":1}}],[\"输出\",{\"1\":{\"26\":2,\"50\":1,\"66\":1}}],[\"输出不会被截断\",{\"1\":{\"26\":1}}],[\"输出时\",{\"1\":{\"26\":1}}],[\"你可以继续执行其他命令\",{\"1\":{\"274\":1}}],[\"你可能会用到的一些插件\",{\"1\":{\"258\":1}}],[\"你的终端或\",{\"1\":{\"274\":1}}],[\"你的程序将得到一个判断错误的答案\",{\"1\":{\"32\":1}}],[\"你只可以看到在滑动窗口内的\",{\"1\":{\"268\":1}}],[\"你有没有备胎\",{\"1\":{\"184\":1}}],[\"你有一张某海域\",{\"1\":{\"79\":1}}],[\"你就去问问她男朋友\",{\"1\":{\"184\":1}}],[\"你需要完成合并和查询操作\",{\"1\":{\"66\":1}}],[\"你能求出数列中总共有多少个\",{\"1\":{\"45\":1}}],[\"jpg\",{\"1\":{\"290\":9}}],[\"json串\",{\"1\":{\"289\":1}}],[\"jbods\",{\"1\":{\"282\":1}}],[\"j表示第几个区间\",{\"1\":{\"254\":1}}],[\"j表示走到哪一个点\",{\"1\":{\"131\":1}}],[\"j走到哪了呀\",{\"1\":{\"234\":1}}],[\"j+1\",{\"1\":{\"234\":1}}],[\"j++\",{\"1\":{\"55\":2,\"73\":1,\"115\":1,\"116\":2,\"117\":1,\"118\":2,\"120\":3,\"121\":1,\"122\":1,\"123\":1,\"124\":2,\"125\":2,\"128\":3,\"131\":2,\"138\":3,\"160\":1,\"179\":2,\"181\":2,\"195\":1,\"209\":1,\"214\":1,\"234\":2,\"254\":1}}],[\"j−i\",{\"1\":{\"127\":1}}],[\"j\",{\"1\":{\"45\":1,\"54\":4,\"55\":12,\"63\":3,\"65\":2,\"66\":4,\"73\":3,\"115\":14,\"116\":13,\"117\":25,\"118\":22,\"120\":19,\"121\":6,\"122\":16,\"123\":9,\"124\":16,\"125\":27,\"126\":16,\"127\":28,\"128\":12,\"130\":18,\"131\":14,\"137\":14,\"138\":8,\"153\":1,\"160\":4,\"168\":3,\"169\":4,\"170\":3,\"173\":12,\"174\":5,\"175\":6,\"176\":6,\"177\":8,\"179\":10,\"181\":10,\"183\":4,\"184\":6,\"193\":4,\"194\":9,\"195\":15,\"202\":20,\"207\":10,\"209\":7,\"211\":4,\"212\":8,\"214\":5,\"234\":20,\"254\":5}}],[\"java中的\",{\"1\":{\"32\":1}}],[\"java\",{\"1\":{\"7\":1,\"282\":2}}],[\"k8s\",{\"1\":{\"282\":1}}],[\"key\",{\"1\":{\"245\":1}}],[\"kmp\",{\"0\":{\"234\":1}}],[\"k指向的下一节点指向新节点\",{\"1\":{\"226\":1}}],[\"k2\",{\"1\":{\"206\":2}}],[\"k1\",{\"1\":{\"206\":7}}],[\"k表示走到j这个点之前\",{\"1\":{\"131\":1}}],[\"k++\",{\"1\":{\"117\":2,\"118\":2,\"126\":2,\"128\":3,\"131\":1,\"138\":4,\"179\":1,\"243\":1}}],[\"k辆车\",{\"1\":{\"106\":1}}],[\"kruskal\",{\"0\":{\"182\":1},\"1\":{\"59\":1,\"182\":1}}],[\"k==0\",{\"1\":{\"46\":1}}],[\"k⩽1000001⩽ai​⩽100000\",{\"1\":{\"45\":1}}],[\"k\",{\"1\":{\"45\":5,\"46\":8,\"47\":3,\"77\":5,\"106\":8,\"117\":22,\"118\":10,\"126\":8,\"128\":12,\"130\":2,\"131\":7,\"138\":1,\"142\":1,\"158\":2,\"159\":9,\"166\":1,\"179\":4,\"195\":1,\"203\":9,\"210\":4,\"211\":4,\"226\":6,\"227\":11,\"240\":8,\"242\":5,\"243\":6,\"244\":2,\"245\":3,\"268\":2,\"269\":4}}],[\"之后的尾迭代器\",{\"1\":{\"246\":1}}],[\"之后用\",{\"1\":{\"195\":1}}],[\"之间的数据是相互隔离的\",{\"1\":{\"287\":1}}],[\"之间的所有数字中\",{\"1\":{\"128\":1}}],[\"之间的顺序任意\",{\"1\":{\"92\":1}}],[\"之间的转化\",{\"0\":{\"34\":1}}],[\"之和是\",{\"1\":{\"45\":1}}],[\"同样首先遍历左子节点的左子树\",{\"1\":{\"262\":1}}],[\"同加法一样处理进位\",{\"1\":{\"149\":1}}],[\"同理再处理该节点和该节点的右子节点\",{\"1\":{\"264\":1}}],[\"同理队尾\",{\"1\":{\"232\":1}}],[\"同理\",{\"1\":{\"147\":1,\"148\":1}}],[\"同一组内的物品最多只能选一个\",{\"1\":{\"118\":1}}],[\"同一行内的数升序排列\",{\"1\":{\"100\":1}}],[\"同一行内的数必须升序排列\",{\"1\":{\"92\":1}}],[\"同一行相邻两个数用一个空格隔开\",{\"1\":{\"96\":1}}],[\"同\",{\"1\":{\"40\":1}}],[\"同时\",{\"1\":{\"216\":1}}],[\"同时不捕获其他变量\",{\"1\":{\"38\":1}}],[\"同时还能够为该应用程序提供相关的服务的软件\",{\"1\":{\"15\":1}}],[\"创建存储桶的时候\",{\"1\":{\"289\":1}}],[\"创建方式二\",{\"1\":{\"40\":1}}],[\"创建方式一\",{\"1\":{\"40\":1}}],[\"创建\",{\"1\":{\"40\":1}}],[\"最简单的\",{\"1\":{\"274\":1}}],[\"最简单的合并就是像下面这样\",{\"1\":{\"63\":1}}],[\"最多有26个\",{\"1\":{\"235\":1}}],[\"最终结果为\",{\"1\":{\"202\":1}}],[\"最坏情况下的时间复杂度为\",{\"1\":{\"199\":1}}],[\"最坏情况下\",{\"1\":{\"176\":1}}],[\"最坏情况为\",{\"1\":{\"172\":1}}],[\"最低位一定为\",{\"1\":{\"158\":1}}],[\"最小生成树所有边的长度之和\",{\"1\":{\"181\":1}}],[\"最小生成树就是将\",{\"1\":{\"180\":1}}],[\"最小生成树问题\",{\"0\":{\"180\":1}}],[\"最小的最大\",{\"1\":{\"143\":1}}],[\"最小值\",{\"1\":{\"39\":2,\"233\":1}}],[\"最小值下标\",{\"1\":{\"39\":2}}],[\"最后返回上一层\",{\"1\":{\"264\":1}}],[\"最后返回c数组\",{\"1\":{\"147\":1,\"148\":1}}],[\"最后找到的节点处理完后\",{\"1\":{\"264\":1}}],[\"最后处理这个节点的右子树\",{\"1\":{\"263\":1}}],[\"最后遍历左子节点的右子树\",{\"1\":{\"262\":1}}],[\"最后访问右子树\",{\"1\":{\"262\":1}}],[\"最后剩下的式子就满足我们的答案\",{\"1\":{\"206\":1}}],[\"最后剩下的就是区间\",{\"1\":{\"194\":1}}],[\"最后将整个图连通起来\",{\"1\":{\"181\":1}}],[\"最后一层节点从左向右排列\",{\"1\":{\"240\":1}}],[\"最后一次出现的位置的\",{\"1\":{\"144\":1}}],[\"最后一个访问到的一定是根\",{\"1\":{\"133\":1}}],[\"最后根据分界点分别递归左右两部分\",{\"1\":{\"137\":1}}],[\"最后判断\",{\"1\":{\"109\":1}}],[\"最短路问题\",{\"0\":{\"171\":1}}],[\"最短hamilton路径\",{\"0\":{\"131\":1}}],[\"最短编辑距离\",{\"0\":{\"125\":1}}],[\"最长公共上升子序列\",{\"0\":{\"123\":1}}],[\"最长公共子序列\",{\"0\":{\"122\":1}}],[\"最长上升子序列\",{\"0\":{\"121\":1}}],[\"最大不相交区间数量\",{\"0\":{\"252\":1}}],[\"最大公约数与最小公倍数\",{\"0\":{\"199\":1}}],[\"最大匹配\",{\"1\":{\"184\":1}}],[\"最大的最小\",{\"1\":{\"143\":1}}],[\"最大的总价值\",{\"1\":{\"115\":1}}],[\"最大价值是多少\",{\"1\":{\"115\":1,\"116\":1}}],[\"最大值\",{\"1\":{\"39\":2}}],[\"最大值下标\",{\"1\":{\"39\":2}}],[\"最少需要付多少美元才能把这\",{\"1\":{\"104\":1}}],[\"最初最小生成树的边数为\",{\"1\":{\"182\":1}}],[\"最初\",{\"1\":{\"71\":1}}],[\"最值元素的值\",{\"1\":{\"39\":1}}],[\"最值元素的地址\",{\"1\":{\"39\":1}}],[\"分为两种情况\",{\"1\":{\"202\":1}}],[\"分为两大类\",{\"1\":{\"172\":1}}],[\"分解质因数的方式比较好用\",{\"1\":{\"212\":1}}],[\"分解质因数法求组合数\",{\"0\":{\"212\":1}}],[\"分解质因数\",{\"1\":{\"201\":1}}],[\"分成子问题\",{\"1\":{\"137\":2}}],[\"分治算法都有三步\",{\"1\":{\"137\":1}}],[\"分组背包\",{\"0\":{\"118\":1}}],[\"分数不考虑约分的情况\",{\"1\":{\"109\":1}}],[\"分别到达节点y1\",{\"1\":{\"220\":1}}],[\"分别适用于不同情况\",{\"1\":{\"140\":1}}],[\"分别出现且只出现一次\",{\"1\":{\"108\":1}}],[\"分别代表目标的\",{\"1\":{\"53\":1}}],[\"分别代表地图上的目标数目和正方形包含的横纵位置数量\",{\"1\":{\"53\":1}}],[\"分别用来求最大元素和最小元素的值\",{\"1\":{\"39\":1}}],[\"分别用来求最大元素和最小元素的位置\",{\"1\":{\"39\":1}}],[\"分布式计算中间件等\",{\"1\":{\"15\":1}}],[\"分布式应用软件借助这种软件在不同的技术之间共享资源\",{\"1\":{\"15\":1}}],[\"user\",{\"1\":{\"287\":1}}],[\"user=admin\",{\"1\":{\"274\":2}}],[\"using\",{\"1\":{\"47\":1,\"51\":1,\"55\":1,\"65\":1,\"66\":1,\"73\":1,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"130\":1,\"131\":1,\"133\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"173\":1,\"181\":1,\"182\":1,\"198\":1,\"206\":1,\"214\":1,\"216\":1,\"234\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"ull\",{\"1\":{\"244\":4}}],[\"uploadobjectargs\",{\"1\":{\"290\":1}}],[\"uploadobject\",{\"1\":{\"290\":1}}],[\"up\",{\"1\":{\"240\":4}}],[\"upper\",{\"1\":{\"144\":3,\"245\":4,\"246\":3}}],[\"u表示当前节点\",{\"1\":{\"183\":1}}],[\"u表示第几位\",{\"1\":{\"102\":1}}],[\"u只猫\",{\"1\":{\"106\":1}}],[\"unsigned\",{\"1\":{\"244\":2}}],[\"uninstall\",{\"1\":{\"277\":1}}],[\"unix\",{\"1\":{\"274\":1}}],[\"unique\",{\"1\":{\"161\":1,\"245\":1,\"246\":3}}],[\"union\",{\"1\":{\"59\":1,\"63\":1,\"65\":2,\"66\":4,\"182\":2,\"237\":1}}],[\"unordered\",{\"1\":{\"77\":1,\"198\":1,\"245\":4}}],[\"u\",{\"1\":{\"38\":6,\"85\":4,\"94\":8,\"98\":5,\"102\":6,\"106\":8,\"110\":7,\"133\":16,\"166\":11,\"168\":4,\"183\":3,\"235\":7,\"239\":2,\"240\":17}}],[\"捕获\",{\"1\":{\"38\":1}}],[\"让\",{\"1\":{\"38\":1}}],[\"按照中序遍历的过程\",{\"1\":{\"263\":1}}],[\"按照从小到大的顺序输出所有方案\",{\"1\":{\"96\":1,\"100\":1}}],[\"按左端点排序\",{\"1\":{\"255\":1}}],[\"按左端点从小到大排序\",{\"1\":{\"253\":1}}],[\"按右端点从小到大排序\",{\"1\":{\"251\":1}}],[\"按字典序\",{\"1\":{\"245\":1}}],[\"按字典序输出所有排列方案\",{\"1\":{\"83\":1}}],[\"按快排的从小到大的顺序遍历每条边\",{\"1\":{\"182\":1}}],[\"按位取反\",{\"1\":{\"158\":1}}],[\"按位异或\",{\"1\":{\"158\":1}}],[\"按位或\",{\"1\":{\"158\":1}}],[\"按位与\",{\"1\":{\"158\":1}}],[\"按值捕获\",{\"1\":{\"38\":2}}],[\"按引用捕获\",{\"1\":{\"38\":1}}],[\"空表示不捕获任何变量\",{\"1\":{\"38\":1}}],[\">1\",{\"1\":{\"190\":1}}],[\">b\",{\"1\":{\"166\":1,\"175\":1}}],[\">=0\",{\"1\":{\"128\":1}}],[\">=\",{\"1\":{\"66\":2,\"73\":2,\"77\":2,\"106\":1,\"110\":2,\"115\":1,\"116\":1,\"117\":3,\"118\":3,\"120\":2,\"127\":1,\"137\":1,\"138\":1,\"141\":1,\"142\":1,\"147\":5,\"148\":12,\"149\":4,\"150\":4,\"159\":1,\"161\":1,\"177\":1,\"207\":3,\"253\":1,\"254\":1}}],[\">\",{\"1\":{\"38\":3,\"98\":1,\"102\":1,\"117\":1,\"121\":1,\"123\":1,\"137\":2,\"145\":1,\"148\":5,\"149\":1,\"150\":2,\"166\":3,\"173\":1,\"174\":1,\"175\":3,\"176\":2,\"177\":1,\"181\":1,\"190\":1,\"198\":1,\"201\":1,\"207\":3,\"214\":1,\"229\":1,\"246\":1,\"251\":1,\"274\":2,\"277\":1,\"289\":1,\"290\":1}}],[\">>=\",{\"1\":{\"203\":1,\"210\":1,\"211\":1,\"240\":1}}],[\">>\",{\"0\":{\"36\":1},\"1\":{\"36\":1,\"47\":3,\"51\":2,\"55\":5,\"65\":6,\"66\":5,\"73\":3,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":2,\"106\":3,\"110\":1,\"115\":4,\"116\":4,\"117\":15,\"118\":10,\"120\":2,\"121\":7,\"122\":4,\"123\":3,\"124\":5,\"125\":4,\"126\":2,\"127\":1,\"128\":2,\"130\":3,\"131\":3,\"133\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":3,\"147\":2,\"148\":2,\"149\":2,\"150\":2,\"157\":1,\"158\":2,\"159\":5,\"161\":1,\"166\":2,\"173\":5,\"181\":5,\"198\":2,\"211\":4,\"214\":4,\"216\":2,\"234\":4,\"245\":1,\"251\":3,\"252\":3,\"253\":3,\"254\":5,\"255\":3}}],[\"表示存储桶是否存在\",{\"1\":{\"289\":1}}],[\"表示大小\",{\"1\":{\"240\":1}}],[\"表示堆\",{\"1\":{\"240\":1}}],[\"表示祖宗节点所在集合中的点的数量\",{\"1\":{\"238\":1}}],[\"表示队头\",{\"1\":{\"232\":1}}],[\"表示节点的右指针\",{\"1\":{\"227\":1}}],[\"表示节点的左指针\",{\"1\":{\"227\":1}}],[\"表示节点的值\",{\"1\":{\"227\":1}}],[\"表示每个点的颜色\",{\"1\":{\"183\":1}}],[\"表示a到b的距离\",{\"1\":{\"179\":1}}],[\"表示1号点已经被遍历过\",{\"1\":{\"169\":1}}],[\"表示点j已经被遍历过\",{\"1\":{\"169\":1}}],[\"表示点u已经被遍历过\",{\"1\":{\"168\":1}}],[\"表示点数\",{\"1\":{\"167\":1,\"170\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":1}}],[\"表示边数\",{\"1\":{\"167\":1,\"170\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":1}}],[\"表示补码\",{\"1\":{\"159\":1}}],[\"表示整个数列\",{\"1\":{\"159\":1}}],[\"表示精度\",{\"1\":{\"145\":1}}],[\"表示所有点都走过了\",{\"1\":{\"131\":1}}],[\"表示从a个苹果中选b个的方案数\",{\"1\":{\"209\":1}}],[\"表示从\",{\"1\":{\"131\":1}}],[\"表示从左上角移动至右下角的最少移动次数\",{\"1\":{\"71\":1}}],[\"表示当前摆到第\",{\"1\":{\"130\":1}}],[\"表示前\",{\"1\":{\"127\":1}}],[\"表示一次询问中满足条件的字符串个数\",{\"1\":{\"124\":1}}],[\"表示一次询问\",{\"1\":{\"124\":1}}],[\"表示给定的字符串\",{\"1\":{\"124\":1}}],[\"表示最长公共上升子序列的长度\",{\"1\":{\"123\":1}}],[\"表示最少需要多少美元\",{\"1\":{\"104\":1}}],[\"表示最少交换次数\",{\"1\":{\"75\":1}}],[\"表示数列\",{\"1\":{\"123\":3}}],[\"表示总体积是i的情况下\",{\"1\":{\"115\":1,\"116\":1}}],[\"表示陆地\",{\"1\":{\"79\":2}}],[\"表示海洋\",{\"1\":{\"79\":2}}],[\"表示变换到某个字符串时需要的交换次数\",{\"1\":{\"77\":1}}],[\"表示完整的二维数组迷宫\",{\"1\":{\"71\":1}}],[\"表示不可通过的墙壁\",{\"1\":{\"71\":1}}],[\"表示可以走的路\",{\"1\":{\"71\":1}}],[\"表示共有\",{\"1\":{\"66\":1}}],[\"表示询问\",{\"1\":{\"65\":1}}],[\"表示\",{\"1\":{\"65\":1,\"149\":1,\"150\":1,\"183\":1,\"210\":1}}],[\"表示目标在地图上的位置\",{\"1\":{\"53\":1}}],[\"表示截断方法数量\",{\"1\":{\"49\":1}}],[\"表示这个前缀和的值\",{\"1\":{\"46\":1}}],[\"表示第二个集合中的每个点是否已经被遍历过\",{\"1\":{\"184\":1}}],[\"表示第\",{\"1\":{\"46\":1}}],[\"表示捕获当前类中的\",{\"1\":{\"38\":1}}],[\"表示捕获外部作用域中所有变量\",{\"1\":{\"38\":2}}],[\"表示按值捕获外部作用域中所有变量\",{\"1\":{\"38\":1}}],[\"表示size\",{\"1\":{\"35\":1}}],[\"表达式\",{\"1\":{\"38\":1}}],[\"表达式拥有和当前类成员函数同样的访问权限\",{\"1\":{\"38\":1}}],[\"表达式的语法形式可简单归纳如下\",{\"1\":{\"38\":1}}],[\"表达式定义了一个匿名函数\",{\"1\":{\"38\":1}}],[\"第i堆物品有ai个\",{\"1\":{\"216\":1}}],[\"第i行j列格子左上部分所有元素的和\",{\"1\":{\"153\":1}}],[\"第三步\",{\"1\":{\"137\":1}}],[\"第三行包含\",{\"1\":{\"123\":1}}],[\"第三维枚举决策\",{\"1\":{\"114\":1}}],[\"第三段\",{\"1\":{\"50\":1}}],[\"第\",{\"1\":{\"79\":3,\"104\":2,\"206\":2}}],[\"第二个元素\",{\"1\":{\"245\":1}}],[\"第二个行动的称为后手\",{\"1\":{\"216\":1}}],[\"第二行输出所求余数\",{\"1\":{\"150\":1}}],[\"第二行包含\",{\"1\":{\"49\":1,\"123\":1,\"159\":1}}],[\"第二步\",{\"1\":{\"137\":1}}],[\"第二维枚举起点\",{\"1\":{\"126\":1}}],[\"第二维枚举体积\",{\"1\":{\"114\":1}}],[\"第二种写法\",{\"1\":{\"117\":1,\"118\":1}}],[\"第二种用法\",{\"1\":{\"37\":1}}],[\"第二部分是以\",{\"1\":{\"65\":1}}],[\"第一个元素\",{\"1\":{\"245\":1}}],[\"第一次出现的位置\",{\"1\":{\"144\":1}}],[\"第一次循环不能有0\",{\"1\":{\"128\":1}}],[\"第一步\",{\"1\":{\"137\":1}}],[\"第一维通常是枚举区间长度\",{\"1\":{\"126\":1}}],[\"第一维枚举物品\",{\"1\":{\"114\":1}}],[\"第一种写法\",{\"1\":{\"117\":1,\"118\":1}}],[\"第一种用法\",{\"1\":{\"37\":1}}],[\"第一部分是以\",{\"1\":{\"65\":1}}],[\"第一行输出所求的商\",{\"1\":{\"150\":1}}],[\"第一行输入正整数\",{\"1\":{\"53\":1}}],[\"第一行包含一个整数\",{\"1\":{\"79\":1,\"123\":1}}],[\"第一行包含整数\",{\"1\":{\"49\":1,\"159\":1}}],[\"第一行包含两个整数\",{\"1\":{\"45\":1,\"66\":1,\"71\":1,\"124\":1}}],[\"第一段\",{\"1\":{\"50\":1}}],[\"个奇偶校验块\",{\"1\":{\"282\":1}}],[\"个闭区间\",{\"1\":{\"254\":1}}],[\"个链表\",{\"1\":{\"226\":1}}],[\"个不同的质数\",{\"1\":{\"214\":1}}],[\"个未知数的多元线性方程组\",{\"1\":{\"207\":1}}],[\"个未知数的线性方程组\",{\"1\":{\"207\":1}}],[\"个方程\",{\"1\":{\"207\":2}}],[\"个式子合并\",{\"1\":{\"206\":1}}],[\"个质数\",{\"1\":{\"193\":1}}],[\"个顶点的连通块筛选出来\",{\"1\":{\"182\":1}}],[\"个顶点\",{\"1\":{\"180\":1}}],[\"个点\",{\"1\":{\"172\":1}}],[\"个点的带权无向图\",{\"1\":{\"131\":1}}],[\"个位\",{\"1\":{\"147\":1,\"148\":1}}],[\"个位置的正方形内的所有目标\",{\"1\":{\"53\":1}}],[\"个人来\",{\"1\":{\"133\":1}}],[\"个人不来\",{\"1\":{\"133\":1}}],[\"个人介绍和档案放置在此\",{\"1\":{\"0\":1}}],[\"个物品全不选也是一种方案\",{\"1\":{\"127\":2}}],[\"个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串\",{\"1\":{\"124\":1}}],[\"个长度不超过\",{\"1\":{\"124\":1}}],[\"个数据块\",{\"1\":{\"282\":1}}],[\"个数字\",{\"1\":{\"268\":1}}],[\"个数字和一个\",{\"1\":{\"75\":1}}],[\"个数来组合\",{\"1\":{\"203\":1}}],[\"个数的二进制表示中\",{\"1\":{\"159\":1}}],[\"个数表示数列中的第\",{\"1\":{\"159\":1}}],[\"个数必须不重不漏\",{\"1\":{\"109\":1}}],[\"个数划分给\",{\"1\":{\"109\":1}}],[\"个数\",{\"1\":{\"109\":1,\"203\":1}}],[\"个\",{\"1\":{\"96\":1,\"100\":2,\"127\":3}}],[\"个空格隔开\",{\"1\":{\"92\":1}}],[\"个操作\",{\"1\":{\"66\":1}}],[\"个目标\",{\"1\":{\"53\":1}}],[\"个整数中随机选出\",{\"1\":{\"100\":1}}],[\"个整数中随机选取任意多个\",{\"1\":{\"92\":1}}],[\"个整数排成一行后随机打乱顺序\",{\"1\":{\"96\":1}}],[\"个整数\",{\"1\":{\"49\":1,\"71\":1,\"123\":2,\"127\":1,\"159\":2,\"206\":1}}],[\"个元素和\",{\"1\":{\"66\":1}}],[\"个元素\",{\"1\":{\"61\":1}}],[\"个元素的和\",{\"1\":{\"46\":1}}],[\"个元素到第\",{\"1\":{\"46\":1}}],[\"个值为\",{\"1\":{\"37\":1}}],[\"功能\",{\"1\":{\"37\":1}}],[\"它以对象为单位来处理\",{\"1\":{\"281\":1}}],[\"它的\",{\"1\":{\"262\":1}}],[\"它的行动规则是任选某个有向图游戏gi\",{\"1\":{\"221\":1}}],[\"它的一个重要推论是\",{\"1\":{\"31\":1,\"205\":1}}],[\"它们按照某种顺序排成长度为2n的序列\",{\"1\":{\"213\":1}}],[\"它就会被淹没\",{\"1\":{\"79\":1}}],[\"它主要用于处理一些不相交集合的合并问题\",{\"1\":{\"59\":1}}],[\"它会修改矢量的大小\",{\"1\":{\"37\":1}}],[\"可选\",{\"1\":{\"287\":1}}],[\"可视化管理界面\",{\"1\":{\"282\":1}}],[\"可拓展\",{\"1\":{\"282\":1}}],[\"可拓展性的特点\",{\"1\":{\"281\":1}}],[\"可修改\",{\"1\":{\"274\":1}}],[\"可计算出去重后的元素个数\",{\"1\":{\"246\":1}}],[\"可把一堆取光\",{\"1\":{\"216\":1}}],[\"可理解为\",{\"1\":{\"181\":1,\"182\":1}}],[\"可能为负数\",{\"1\":{\"206\":1}}],[\"可能包含长度为偶数的环\",{\"1\":{\"183\":1}}],[\"可能的\",{\"1\":{\"143\":1}}],[\"可能是整数\",{\"1\":{\"35\":1}}],[\"可进行的操作有\",{\"1\":{\"125\":1}}],[\"可使物品总体积不超过背包容量\",{\"1\":{\"118\":1}}],[\"可以多个线程共同使用一个\",{\"1\":{\"287\":1}}],[\"可以丢失任意\",{\"1\":{\"282\":1}}],[\"可以直接通过浏览器登录系统\",{\"1\":{\"282\":1}}],[\"可以自定义修改\",{\"1\":{\"274\":1}}],[\"可以在第三个参数传入定义大小比较的函数\",{\"1\":{\"246\":1}}],[\"可以在区间\",{\"1\":{\"144\":2}}],[\"可以删掉\",{\"1\":{\"230\":1}}],[\"可以执行的合法行动与轮到哪名玩家无关\",{\"1\":{\"217\":1}}],[\"可以用费马小定理求逆元\",{\"1\":{\"210\":1}}],[\"可以用结构体存储点和边\",{\"1\":{\"175\":1}}],[\"可以缩小问题规模而保持最大公约数不变\",{\"1\":{\"199\":1}}],[\"可以对其进行优化\",{\"1\":{\"190\":1}}],[\"可以生成最小生成树\",{\"1\":{\"182\":1}}],[\"可以不需要考虑重边\",{\"1\":{\"174\":1}}],[\"可以将模板\",{\"1\":{\"142\":1}}],[\"可以任选\",{\"1\":{\"137\":1}}],[\"可以表示为\",{\"1\":{\"158\":1}}],[\"可以表示为带分数的形式\",{\"1\":{\"108\":1}}],[\"可以表示成若干个正整数之和\",{\"1\":{\"127\":1}}],[\"可以把\",{\"1\":{\"75\":1}}],[\"可以摧毁一个包含\",{\"1\":{\"53\":1}}],[\"可以是一个区间\",{\"1\":{\"39\":2}}],[\"可以使用各种公有云提供的\",{\"1\":{\"281\":1}}],[\"可以使用\",{\"1\":{\"26\":1,\"282\":1}}],[\"可以返回\",{\"1\":{\"26\":1}}],[\"可以理解为\",{\"1\":{\"15\":1,\"109\":1}}],[\"作用\",{\"1\":{\"159\":1,\"240\":1}}],[\"作用等同于\",{\"1\":{\"26\":1}}],[\"作为一款基于\",{\"1\":{\"282\":1}}],[\"作为切割点\",{\"1\":{\"50\":1}}],[\"作为返回值它通常被用作表明没有匹配\",{\"1\":{\"35\":1}}],[\"该命令也会继续执行\",{\"1\":{\"274\":1}}],[\"该游戏被称为有向图游戏\",{\"1\":{\"218\":1}}],[\"该点到它本身的路径赋为0\",{\"1\":{\"176\":1}}],[\"该表格的初始值要赋为极大值\",{\"1\":{\"176\":1}}],[\"该式被称为三角不等式\",{\"1\":{\"175\":1}}],[\"该人从左上角移动至右下角\",{\"1\":{\"71\":1}}],[\"该如何想办法避免树的不平衡呢\",{\"1\":{\"66\":1}}],[\"该函数常用于离散化\",{\"1\":{\"246\":1}}],[\"该函数有唯一的返回类型\",{\"1\":{\"35\":1}}],[\"该函数返回字符串的首字符的地址\",{\"1\":{\"26\":1}}],[\"该函数返回在重新分配内存之前\",{\"1\":{\"26\":1}}],[\"该值表示\",{\"1\":{\"35\":1}}],[\"hot\",{\"0\":{\"301\":1}}],[\"hot100\",{\"2\":{\"265\":1,\"271\":1}}],[\"hdfs\",{\"1\":{\"282\":1}}],[\"hadoop\",{\"1\":{\"282\":1}}],[\"hao\",{\"1\":{\"282\":1}}],[\"hamilton\",{\"1\":{\"131\":1}}],[\"http\",{\"1\":{\"276\":1,\"280\":1,\"281\":1,\"287\":1}}],[\"https\",{\"1\":{\"273\":3,\"274\":1,\"276\":1,\"277\":1,\"280\":1,\"281\":1,\"282\":4}}],[\"hup\",{\"1\":{\"274\":1}}],[\"hp\",{\"1\":{\"240\":6}}],[\"head\",{\"1\":{\"226\":6}}],[\"head存储链表头\",{\"1\":{\"226\":1}}],[\"heap\",{\"1\":{\"174\":6,\"240\":11,\"253\":7}}],[\"hello\",{\"1\":{\"26\":2}}],[\"hh++\",{\"1\":{\"170\":1,\"232\":1,\"233\":1}}],[\"hh\",{\"1\":{\"170\":2,\"232\":4,\"233\":4}}],[\"h>\",{\"1\":{\"128\":1,\"133\":1,\"181\":1,\"182\":1}}],[\"h\",{\"1\":{\"34\":1,\"166\":10,\"168\":1,\"169\":1,\"170\":1,\"174\":4,\"176\":4,\"177\":2,\"183\":2,\"184\":2,\"240\":11,\"242\":4,\"243\":3,\"244\":6}}],[\"也能通过剩余的数据块和校验块恢复原始数据\",{\"1\":{\"282\":1}}],[\"也能使用云存储服务提供的\",{\"1\":{\"281\":1}}],[\"也称静态链表\",{\"1\":{\"226\":1}}],[\"也是\",{\"1\":{\"202\":1}}],[\"也是亲戚\",{\"1\":{\"65\":1}}],[\"也将其倍数从\",{\"1\":{\"194\":1}}],[\"也就是即使你启动了\",{\"1\":{\"274\":1}}],[\"也就是最少需要多少辆缆车\",{\"1\":{\"104\":1}}],[\"也就是说\",{\"1\":{\"15\":1}}],[\"也可以用来判断奇数和偶数\",{\"1\":{\"203\":1}}],[\"也可以简写成这样\",{\"1\":{\"62\":1}}],[\"也可以换成更安全的\",{\"1\":{\"34\":1}}],[\"也可能是长整数\",{\"1\":{\"35\":1}}],[\"这种机制使得即使部分磁盘发生故障\",{\"1\":{\"282\":1}}],[\"这种写法包含了两种情况\",{\"1\":{\"148\":1}}],[\"这就意味着个人也可以基于\",{\"1\":{\"281\":1}}],[\"这部分是将标准错误输出\",{\"1\":{\"274\":1}}],[\"这部分是将标准输出\",{\"1\":{\"274\":1}}],[\"这意味着\",{\"1\":{\"274\":1}}],[\"这是一个\",{\"1\":{\"274\":1}}],[\"这是一种c语言中的转换方式\",{\"1\":{\"34\":1}}],[\"这一项\",{\"1\":{\"202\":1}}],[\"这一项在\",{\"1\":{\"202\":1}}],[\"这一步类似完全背包的推导\",{\"1\":{\"127\":1}}],[\"这样的设计\",{\"1\":{\"282\":1}}],[\"这样的局面被称为必胜\",{\"1\":{\"216\":1}}],[\"这样\",{\"1\":{\"274\":1}}],[\"这样直接用\",{\"1\":{\"244\":1}}],[\"这样当两个边进行比较的时候就会使用他们的权重进行比较了\",{\"1\":{\"182\":1}}],[\"这样就能避免头重脚轻\",{\"1\":{\"66\":1}}],[\"这条边不要\",{\"1\":{\"182\":1}}],[\"这里使用库函数二分的写法\",{\"1\":{\"144\":1}}],[\"这个符号是在命令的末尾\",{\"1\":{\"274\":1}}],[\"这个公式求出每个质因子的次数\",{\"1\":{\"212\":1}}],[\"这个步骤\",{\"1\":{\"199\":1}}],[\"这个点还未被匹配\",{\"1\":{\"184\":1}}],[\"这个集合指当前已经在连通块中的所有点\",{\"1\":{\"181\":1}}],[\"这个数本身\",{\"1\":{\"128\":1}}],[\"这个前缀和本身就是\",{\"1\":{\"46\":1}}],[\"这天\",{\"1\":{\"104\":1}}],[\"这\",{\"1\":{\"75\":1,\"92\":1,\"96\":1,\"100\":1,\"203\":2}}],[\"这些人的编号为\",{\"1\":{\"65\":1}}],[\"这也就意味着\",{\"1\":{\"46\":1}}],[\"这两个函数会返回\",{\"1\":{\"26\":1}}],[\"函数使用\",{\"1\":{\"35\":1}}],[\"函数的头文件是\",{\"1\":{\"34\":1}}],[\"函数的第一个参数类型是\",{\"1\":{\"34\":1}}],[\"函数\",{\"1\":{\"34\":1,\"37\":1}}],[\"函数转换\",{\"1\":{\"34\":1}}],[\"函数输出字符串是针对\",{\"1\":{\"26\":1}}],[\"转化为\",{\"1\":{\"109\":1}}],[\"转化为数字\",{\"1\":{\"109\":1}}],[\"转换\",{\"1\":{\"34\":3}}],[\"转\",{\"0\":{\"293\":1},\"1\":{\"34\":2}}],[\"与模数\",{\"1\":{\"210\":1}}],[\"与一个各位都为零的数值相与\",{\"1\":{\"158\":1}}],[\"与快排不同\",{\"1\":{\"138\":1}}],[\"与其上\",{\"1\":{\"75\":1}}],[\"与min\",{\"1\":{\"39\":1}}],[\"与\",{\"0\":{\"34\":1,\"39\":1},\"1\":{\"39\":1,\"66\":2,\"157\":1,\"158\":5,\"209\":1,\"210\":1}}],[\"v4\",{\"1\":{\"282\":1}}],[\"vuepress\",{\"1\":{\"258\":3}}],[\"version\",{\"1\":{\"289\":1}}],[\"version>\",{\"1\":{\"286\":1}}],[\"ver\",{\"1\":{\"174\":4}}],[\"vector<node>\",{\"1\":{\"246\":1}}],[\"vector<edge>\",{\"1\":{\"166\":1}}],[\"vector<pii>\",{\"1\":{\"162\":2,\"174\":1,\"255\":1}}],[\"vector<good>\",{\"1\":{\"117\":1}}],[\"vector<vector<int>>\",{\"1\":{\"25\":1,\"37\":1}}],[\"vector<int>\",{\"1\":{\"25\":2,\"33\":1,\"37\":3,\"38\":1,\"39\":1,\"121\":2,\"128\":8,\"130\":1,\"147\":5,\"148\":7,\"149\":4,\"150\":4,\"161\":1,\"191\":2,\"197\":2,\"212\":4,\"245\":1,\"246\":1,\"253\":1,\"269\":3}}],[\"vector\",{\"0\":{\"25\":1},\"1\":{\"37\":4,\"245\":1,\"246\":3,\"255\":1}}],[\"vis\",{\"1\":{\"98\":4,\"133\":3}}],[\"void\",{\"1\":{\"38\":1,\"61\":1,\"63\":1,\"65\":2,\"66\":2,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":2,\"128\":2,\"133\":1,\"137\":1,\"138\":1,\"158\":1,\"162\":1,\"166\":2,\"174\":1,\"182\":2,\"190\":1,\"193\":1,\"194\":1,\"195\":1,\"202\":1,\"212\":1,\"226\":5,\"227\":3,\"235\":1,\"237\":2,\"240\":3,\"242\":1,\"255\":1,\"289\":4,\"290\":6}}],[\"v2\",{\"1\":{\"37\":2,\"38\":2,\"280\":1,\"282\":1}}],[\"v1\",{\"1\":{\"37\":3,\"38\":2}}],[\"valid\",{\"1\":{\"130\":4}}],[\"val\",{\"1\":{\"37\":2,\"144\":4}}],[\"value\",{\"1\":{\"35\":1}}],[\"v\",{\"1\":{\"33\":1,\"38\":4,\"39\":11,\"115\":6,\"116\":6,\"117\":19,\"118\":8,\"245\":1}}],[\"zipdateformat>\",{\"1\":{\"277\":1}}],[\"zi​=2\",{\"1\":{\"66\":2}}],[\"zi​=1\",{\"1\":{\"66\":1}}],[\"zi​\",{\"1\":{\"66\":1}}],[\"z\",{\"1\":{\"33\":1,\"66\":4}}],[\"work\",{\"0\":{\"305\":1}}],[\"web\",{\"1\":{\"276\":1}}],[\"web中间件\",{\"1\":{\"15\":1}}],[\"winsw\",{\"1\":{\"277\":4}}],[\"windows\",{\"0\":{\"276\":1,\"277\":1},\"1\":{\"276\":2,\"277\":3}}],[\"wi​\",{\"1\":{\"53\":2}}],[\"wget\",{\"1\":{\"274\":1}}],[\"www\",{\"1\":{\"273\":1,\"282\":1}}],[\"w表示边的权重\",{\"1\":{\"175\":1}}],[\"w表示的是无权图\",{\"1\":{\"131\":1}}],[\"way\",{\"1\":{\"102\":4}}],[\"while\",{\"1\":{\"73\":1,\"77\":1,\"110\":1,\"117\":1,\"121\":1,\"124\":1,\"128\":3,\"130\":1,\"137\":3,\"138\":3,\"141\":1,\"142\":1,\"143\":1,\"145\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"160\":1,\"161\":1,\"169\":1,\"170\":1,\"173\":1,\"174\":1,\"176\":2,\"177\":1,\"190\":1,\"191\":1,\"198\":3,\"201\":1,\"203\":1,\"210\":1,\"211\":2,\"212\":2,\"216\":1,\"230\":1,\"233\":1,\"234\":2,\"240\":1,\"243\":1,\"254\":1,\"269\":1}}],[\"w\",{\"1\":{\"33\":4,\"55\":3,\"104\":3,\"115\":4,\"116\":4,\"117\":14,\"118\":6,\"126\":1,\"131\":4,\"166\":2,\"174\":4,\"175\":8,\"176\":4,\"177\":3,\"182\":8,\"251\":2,\"252\":2,\"253\":2,\"254\":2}}],[\"9<\",{\"1\":{\"286\":1}}],[\"9000\",{\"1\":{\"275\":2,\"276\":1,\"287\":1}}],[\"9001\",{\"1\":{\"274\":3,\"275\":3,\"276\":1}}],[\"99\",{\"1\":{\"128\":3}}],[\"9​\",{\"1\":{\"109\":1}}],[\"9\",{\"0\":{\"33\":1,\"162\":1,\"214\":1,\"245\":1},\"1\":{\"65\":2,\"77\":1,\"79\":1,\"109\":2,\"110\":3,\"128\":19}}],[\"policyjsonstring\",{\"1\":{\"289\":2}}],[\"pop\",{\"1\":{\"73\":1,\"77\":1,\"148\":1,\"149\":1,\"150\":1,\"169\":1,\"174\":1,\"176\":2,\"177\":1,\"245\":6,\"253\":1,\"269\":1}}],[\"presignedobjecturl\",{\"1\":{\"290\":2}}],[\"presto\",{\"1\":{\"282\":1}}],[\"prefix\",{\"1\":{\"287\":1}}],[\"principal\",{\"1\":{\"289\":1}}],[\"println\",{\"1\":{\"289\":3,\"290\":6}}],[\"print\",{\"1\":{\"128\":2}}],[\"printf\",{\"1\":{\"26\":4,\"34\":1,\"85\":1,\"128\":1,\"133\":1,\"147\":1,\"148\":3,\"149\":1,\"166\":1,\"181\":1,\"206\":1,\"234\":1}}],[\"private\",{\"1\":{\"287\":5}}],[\"primes2\",{\"1\":{\"194\":4}}],[\"primes\",{\"1\":{\"193\":4,\"194\":3,\"195\":17,\"198\":4,\"202\":21,\"212\":9}}],[\"prime\",{\"1\":{\"189\":1,\"191\":2,\"194\":2,\"195\":1}}],[\"prim\",{\"1\":{\"181\":2}}],[\"priority\",{\"1\":{\"174\":1,\"245\":2,\"253\":1,\"269\":1}}],[\"player\",{\"1\":{\"258\":1}}],[\"plugin\",{\"1\":{\"258\":1}}],[\"plus\",{\"1\":{\"38\":2}}],[\"ph\",{\"1\":{\"240\":4}}],[\"phi\",{\"1\":{\"201\":1,\"202\":5}}],[\"p+1\",{\"1\":{\"234\":1}}],[\"p为匹配串\",{\"1\":{\"234\":1}}],[\"pi​​\",{\"1\":{\"214\":1}}],[\"pii\",{\"1\":{\"73\":1,\"174\":1,\"255\":1}}],[\"pm​​\",{\"1\":{\"214\":1}}],[\"pm​\",{\"1\":{\"214\":1}}],[\"pmam​​\",{\"1\":{\"201\":1}}],[\"p2​\",{\"1\":{\"214\":2}}],[\"p2^c2\",{\"1\":{\"198\":1}}],[\"p1​\",{\"1\":{\"214\":2}}],[\"p1^1\",{\"1\":{\"198\":1}}],[\"p1^0\",{\"1\":{\"198\":1}}],[\"p1^c1\",{\"1\":{\"198\":2}}],[\"p^k\",{\"1\":{\"244\":1}}],[\"p^3\",{\"1\":{\"212\":1}}],[\"p^2\",{\"1\":{\"212\":1}}],[\"p​∗cpa​pb​​\",{\"1\":{\"211\":1}}],[\"pk^1\",{\"1\":{\"198\":1}}],[\"pk^0\",{\"1\":{\"198\":1}}],[\"pk^ck\",{\"1\":{\"198\":2}}],[\"pj=0\",{\"1\":{\"195\":1}}],[\"pj一定是pj\",{\"1\":{\"195\":1}}],[\"pb\",{\"1\":{\"182\":2,\"211\":1}}],[\"python\",{\"1\":{\"282\":1}}],[\"python中的\",{\"1\":{\"32\":1}}],[\"py\",{\"1\":{\"182\":6,\"237\":6,\"282\":1}}],[\"px\",{\"1\":{\"182\":7,\"237\":6}}],[\"pull\",{\"1\":{\"275\":1}}],[\"publicread\",{\"1\":{\"289\":1}}],[\"public\",{\"1\":{\"269\":1,\"287\":3}}],[\"push\",{\"1\":{\"73\":2,\"77\":2,\"117\":2,\"121\":2,\"128\":2,\"130\":1,\"147\":4,\"148\":3,\"149\":2,\"150\":2,\"162\":2,\"166\":2,\"169\":2,\"174\":2,\"176\":2,\"177\":2,\"191\":2,\"197\":2,\"212\":3,\"245\":6,\"253\":2,\"255\":3,\"269\":3}}],[\"putobjectargs\",{\"1\":{\"290\":1}}],[\"putobject\",{\"1\":{\"290\":2}}],[\"puts\",{\"1\":{\"85\":1,\"98\":1,\"102\":1,\"128\":1,\"181\":1,\"206\":1,\"216\":2}}],[\"put\",{\"1\":{\"65\":2}}],[\"p3367\",{\"0\":{\"66\":1}}],[\"p\",{\"1\":{\"38\":2,\"182\":8,\"198\":3,\"203\":5,\"210\":5,\"211\":31,\"212\":8,\"214\":4,\"234\":7,\"235\":11,\"237\":8,\"238\":8,\"239\":9,\"244\":10,\"275\":2}}],[\"pattern>\",{\"1\":{\"277\":1}}],[\"path\",{\"1\":{\"85\":3}}],[\"password=password\",{\"1\":{\"274\":2}}],[\"pascal中的\",{\"1\":{\"32\":1}}],[\"pa\",{\"1\":{\"182\":2}}],[\"pair<int\",{\"1\":{\"73\":1,\"174\":1,\"245\":1,\"255\":1}}],[\"pair<first\",{\"1\":{\"40\":1}}],[\"pair\",{\"1\":{\"40\":1}}],[\"params\",{\"1\":{\"38\":2}}],[\"oss\",{\"1\":{\"281\":3}}],[\"objectname\",{\"1\":{\"290\":1}}],[\"objectwriteresponse2\",{\"1\":{\"290\":1}}],[\"objectwriteresponse\",{\"1\":{\"290\":5}}],[\"object\",{\"0\":{\"290\":1},\"1\":{\"281\":1,\"287\":3,\"290\":6}}],[\"org\",{\"1\":{\"273\":1,\"274\":1,\"280\":1,\"282\":1}}],[\"operator\",{\"1\":{\"246\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1}}],[\"operator<\",{\"1\":{\"182\":1}}],[\"operation\",{\"1\":{\"158\":1}}],[\"opt\",{\"1\":{\"38\":2,\"274\":4}}],[\"o\",{\"1\":{\"144\":1,\"167\":1,\"170\":1,\"172\":5,\"173\":1,\"174\":1,\"175\":1,\"176\":2,\"177\":1,\"181\":1,\"182\":3,\"183\":1,\"184\":1,\"189\":1,\"190\":2,\"191\":3,\"193\":1,\"195\":1,\"199\":1,\"203\":1,\"207\":1,\"240\":1,\"245\":4}}],[\"output\",{\"1\":{\"32\":1}}],[\"out\",{\"1\":{\"32\":1,\"233\":1,\"289\":3,\"290\":6}}],[\"offer\",{\"0\":{\"5\":1,\"297\":1},\"2\":{\"23\":1}}],[\"front\",{\"1\":{\"73\":1,\"77\":1,\"169\":1,\"176\":2,\"177\":1,\"245\":5}}],[\"fact\",{\"1\":{\"210\":3}}],[\"factor\",{\"1\":{\"191\":1}}],[\"fabs\",{\"1\":{\"207\":2}}],[\"father\",{\"1\":{\"166\":2}}],[\"false\",{\"1\":{\"85\":1,\"98\":1,\"110\":5,\"128\":1,\"130\":2,\"176\":1,\"177\":2,\"183\":3,\"184\":2,\"189\":2,\"191\":1,\"194\":1,\"203\":2,\"242\":1,\"254\":1}}],[\"fa\",{\"1\":{\"61\":3,\"62\":6,\"63\":1,\"65\":7,\"66\":10}}],[\"f\",{\"1\":{\"40\":4,\"115\":12,\"116\":11,\"117\":19,\"118\":10,\"120\":11,\"121\":9,\"122\":14,\"123\":7,\"124\":13,\"125\":22,\"126\":7,\"127\":25,\"128\":7,\"130\":8,\"131\":12,\"133\":12,\"254\":3}}],[\"flip\",{\"1\":{\"245\":2}}],[\"flag\",{\"1\":{\"183\":3}}],[\"floyd算法\",{\"0\":{\"179\":1}}],[\"float>\",{\"1\":{\"40\":2}}],[\"float\",{\"1\":{\"40\":4}}],[\"flush\",{\"1\":{\"32\":4}}],[\"found\",{\"1\":{\"296\":1}}],[\"fond\",{\"1\":{\"62\":1}}],[\"foo\",{\"1\":{\"38\":2}}],[\"foreach\",{\"1\":{\"289\":1,\"290\":1}}],[\"ford算法擅长解决有边数限制的最短路问题\",{\"1\":{\"175\":1}}],[\"ford算法\",{\"0\":{\"175\":1}}],[\"ford算法的优化\",{\"1\":{\"172\":1}}],[\"ford\",{\"1\":{\"172\":1,\"175\":1}}],[\"for\",{\"0\":{\"297\":1},\"1\":{\"27\":1,\"28\":2,\"33\":1,\"35\":1,\"38\":1,\"47\":1,\"51\":2,\"55\":5,\"61\":1,\"65\":3,\"66\":2,\"73\":3,\"77\":2,\"85\":2,\"94\":1,\"98\":2,\"102\":2,\"106\":2,\"110\":3,\"115\":5,\"116\":5,\"117\":14,\"118\":9,\"120\":9,\"121\":8,\"122\":2,\"123\":5,\"124\":6,\"125\":4,\"126\":7,\"127\":5,\"128\":16,\"130\":7,\"131\":5,\"133\":3,\"138\":1,\"144\":2,\"147\":4,\"148\":6,\"149\":3,\"150\":3,\"159\":1,\"160\":1,\"162\":1,\"166\":5,\"168\":1,\"169\":1,\"170\":2,\"173\":3,\"174\":1,\"175\":5,\"176\":1,\"177\":2,\"179\":5,\"181\":5,\"182\":2,\"183\":2,\"184\":2,\"189\":1,\"190\":1,\"191\":3,\"193\":2,\"194\":5,\"195\":2,\"197\":1,\"198\":2,\"201\":1,\"202\":2,\"206\":1,\"207\":9,\"209\":2,\"210\":1,\"211\":1,\"212\":6,\"214\":3,\"230\":1,\"233\":1,\"234\":2,\"235\":2,\"237\":1,\"238\":1,\"239\":1,\"240\":1,\"242\":1,\"244\":1,\"251\":2,\"252\":2,\"253\":2,\"254\":2,\"255\":2,\"269\":2}}],[\"fileoutputstream\",{\"1\":{\"290\":1}}],[\"filename\",{\"1\":{\"290\":1}}],[\"fileinputstream\",{\"1\":{\"290\":1}}],[\"file\",{\"1\":{\"290\":5}}],[\"first存储距离\",{\"1\":{\"174\":1}}],[\"first\",{\"1\":{\"37\":2,\"73\":2,\"162\":2,\"174\":1,\"198\":1,\"245\":2,\"255\":2,\"269\":2}}],[\"find\",{\"1\":{\"35\":1,\"59\":1,\"62\":3,\"63\":2,\"65\":6,\"66\":9,\"77\":1,\"143\":1,\"161\":1,\"182\":6,\"184\":3,\"237\":4,\"238\":6,\"239\":5,\"242\":1,\"243\":1,\"245\":2}}],[\"fflush\",{\"1\":{\"32\":1}}],[\"问先手是否必胜\",{\"1\":{\"216\":1}}],[\"问区间\",{\"1\":{\"194\":1}}],[\"问完一个问题后\",{\"1\":{\"32\":1}}],[\"问题枚举时\",{\"1\":{\"126\":1}}],[\"问题的关键在于\",{\"1\":{\"66\":1}}],[\"问题\",{\"1\":{\"32\":1}}],[\"答案是\",{\"1\":{\"287\":1}}],[\"答案在哪一侧\",{\"1\":{\"143\":1}}],[\"答案在右边界\",{\"1\":{\"142\":1}}],[\"答案在左边界\",{\"1\":{\"141\":1}}],[\"答案\",{\"1\":{\"32\":1}}],[\"要上取整\",{\"1\":{\"142\":1}}],[\"要向下取整\",{\"1\":{\"141\":1}}],[\"要求分成若干组\",{\"1\":{\"253\":1}}],[\"要求求解这个方程组\",{\"1\":{\"207\":1}}],[\"要求边长之和最小\",{\"1\":{\"180\":1}}],[\"要求计算\",{\"1\":{\"149\":1,\"150\":1}}],[\"要求计算出所有\",{\"1\":{\"144\":1}}],[\"要求找出一条路径\",{\"1\":{\"120\":1}}],[\"要求将\",{\"1\":{\"109\":1}}],[\"要求\",{\"1\":{\"49\":1}}],[\"要将该数组从中间截断\",{\"1\":{\"49\":1}}],[\"要输出行的末尾并刷新输出\",{\"1\":{\"32\":1}}],[\"要给出最终答案\",{\"1\":{\"32\":1}}],[\"要使用\",{\"1\":{\"26\":1}}],[\"8\",{\"0\":{\"32\":1,\"161\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"213\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1},\"1\":{\"65\":2,\"71\":1,\"75\":10,\"100\":1,\"120\":2}}],[\"成立\",{\"1\":{\"31\":1,\"205\":1}}],[\"使一个数的最低位为\",{\"1\":{\"158\":1}}],[\"使其全部二进制位为\",{\"1\":{\"158\":1}}],[\"使路径上的数字的和最大\",{\"1\":{\"120\":1}}],[\"使得每组内部区间两两之间没有交集\",{\"1\":{\"253\":1}}],[\"使得每个区间内至少包含一个选出的点\",{\"1\":{\"251\":1}}],[\"使得行动后对面面临必败局面\",{\"1\":{\"216\":1}}],[\"使得ax\",{\"1\":{\"205\":1}}],[\"使得网格变为如下排列\",{\"1\":{\"75\":1}}],[\"使得\",{\"1\":{\"66\":1,\"183\":1,\"205\":2,\"210\":1}}],[\"使\",{\"1\":{\"31\":2,\"158\":1,\"205\":2}}],[\"使用stream流读取文件\",{\"1\":{\"290\":1}}],[\"使用的存储桶\",{\"1\":{\"287\":1}}],[\"使用公有云的\",{\"1\":{\"281\":1}}],[\"使用上述命令将\",{\"1\":{\"277\":1}}],[\"使用优先队列\",{\"1\":{\"269\":1}}],[\"使用一个栈\",{\"1\":{\"264\":1}}],[\"使用并查集\",{\"1\":{\"182\":1}}],[\"使用快排将所有边按权值从小到大排序\",{\"1\":{\"182\":1}}],[\"使用邻接矩阵存图\",{\"1\":{\"179\":1}}],[\"使用auto编译器会自动判断数据是什么类型\",{\"1\":{\"147\":1}}],[\"使用成员函数\",{\"1\":{\"26\":1}}],[\"使用\",{\"1\":{\"26\":3,\"34\":1,\"159\":1,\"282\":2,\"287\":1}}],[\"yml\",{\"1\":{\"287\":1}}],[\"yk\",{\"1\":{\"220\":3}}],[\"y是分母\",{\"1\":{\"211\":1}}],[\"y=x\",{\"1\":{\"205\":1}}],[\"y=0\",{\"1\":{\"205\":1}}],[\"y2\",{\"1\":{\"153\":3,\"155\":3,\"220\":3}}],[\"y1\",{\"1\":{\"153\":3,\"155\":3,\"220\":1}}],[\"yy\",{\"1\":{\"77\":5}}],[\"yes\",{\"1\":{\"65\":4,\"216\":1}}],[\"yi​⩽50000⩽wi​⩽1000\",{\"1\":{\"53\":1}}],[\"yi​\",{\"1\":{\"53\":2,\"66\":3}}],[\"y\",{\"1\":{\"31\":3,\"53\":2,\"55\":2,\"63\":2,\"65\":7,\"66\":23,\"73\":7,\"77\":2,\"128\":2,\"158\":17,\"182\":2,\"199\":1,\"205\":10,\"206\":4,\"211\":4,\"237\":2,\"246\":4}}],[\"your\",{\"1\":{\"29\":1}}],[\"xml\",{\"1\":{\"277\":3}}],[\"x64\",{\"1\":{\"277\":1}}],[\"x的左儿子是2x\",{\"1\":{\"240\":1}}],[\"x<y\",{\"1\":{\"230\":1}}],[\"x属于自然数\",{\"1\":{\"219\":1}}],[\"x是分子\",{\"1\":{\"211\":1}}],[\"x≡mi​\",{\"1\":{\"206\":1}}],[\"x2\",{\"1\":{\"153\":3,\"155\":3}}],[\"x1\",{\"1\":{\"153\":3,\"155\":3}}],[\"xx\",{\"1\":{\"77\":5}}],[\"x=y\",{\"1\":{\"205\":1}}],[\"x=1\",{\"1\":{\"205\":1}}],[\"x=\",{\"1\":{\"65\":1}}],[\"xi​\",{\"1\":{\"53\":2,\"66\":3}}],[\"x\",{\"0\":{\"36\":1},\"1\":{\"31\":3,\"33\":2,\"36\":2,\"37\":1,\"53\":2,\"55\":2,\"62\":12,\"63\":2,\"65\":13,\"66\":25,\"73\":7,\"75\":12,\"77\":5,\"110\":4,\"128\":13,\"137\":3,\"141\":1,\"142\":4,\"145\":1,\"158\":14,\"159\":18,\"161\":2,\"175\":1,\"177\":2,\"182\":8,\"184\":3,\"189\":5,\"190\":7,\"193\":1,\"195\":1,\"197\":5,\"198\":7,\"199\":1,\"201\":9,\"202\":1,\"205\":9,\"206\":9,\"210\":4,\"211\":4,\"216\":3,\"219\":1,\"220\":2,\"226\":3,\"227\":2,\"229\":1,\"232\":1,\"237\":8,\"238\":6,\"239\":10,\"240\":5,\"242\":6,\"243\":3,\"245\":2,\"246\":12}}],[\"das\",{\"1\":{\"282\":1}}],[\"data\",{\"1\":{\"274\":7,\"275\":1,\"276\":2,\"277\":1,\"287\":1}}],[\"dl\",{\"1\":{\"274\":1,\"276\":1}}],[\"dependency>\",{\"1\":{\"286\":1}}],[\"description>\",{\"1\":{\"277\":1}}],[\"dev\",{\"1\":{\"276\":2}}],[\"deque\",{\"1\":{\"245\":1}}],[\"define\",{\"1\":{\"47\":1,\"51\":1,\"55\":1,\"73\":1,\"144\":1,\"174\":1,\"181\":1,\"194\":1,\"206\":1,\"214\":1,\"255\":1}}],[\"dijkstra\",{\"1\":{\"173\":2,\"174\":1}}],[\"dijkstra算法\",{\"0\":{\"173\":1}}],[\"divisors\",{\"1\":{\"197\":1}}],[\"divisor\",{\"1\":{\"191\":1}}],[\"divide\",{\"1\":{\"190\":1}}],[\"div\",{\"1\":{\"150\":2}}],[\"distance\",{\"1\":{\"124\":2,\"166\":3,\"174\":3,\"239\":1}}],[\"dist\",{\"1\":{\"77\":3,\"166\":7,\"173\":11,\"174\":9,\"175\":19,\"176\":10,\"177\":6,\"181\":10}}],[\"docs\",{\"1\":{\"282\":1}}],[\"docker\",{\"0\":{\"17\":1,\"275\":1},\"1\":{\"275\":4}}],[\"docker等等\",{\"1\":{\"8\":1}}],[\"download\",{\"1\":{\"273\":1}}],[\"down和up只会执行其中一个\",{\"1\":{\"240\":1}}],[\"down\",{\"1\":{\"240\":6}}],[\"double\",{\"1\":{\"145\":6}}],[\"do\",{\"1\":{\"137\":2}}],[\"dp\",{\"1\":{\"126\":7,\"128\":3,\"133\":14}}],[\"dy\",{\"1\":{\"73\":2,\"77\":2}}],[\"dx\",{\"1\":{\"73\":2,\"77\":2}}],[\"dfs思路\",{\"1\":{\"183\":1}}],[\"dfs\",{\"0\":{\"82\":1},\"1\":{\"38\":3,\"85\":3,\"94\":4,\"98\":3,\"102\":3,\"106\":4,\"110\":6,\"133\":3,\"166\":4,\"168\":2,\"183\":4},\"2\":{\"89\":1}}],[\"d\",{\"1\":{\"31\":3,\"34\":2,\"38\":1,\"40\":1,\"65\":5,\"73\":8,\"77\":5,\"85\":1,\"128\":1,\"133\":4,\"147\":1,\"148\":2,\"149\":1,\"166\":4,\"170\":3,\"179\":7,\"181\":1,\"205\":5,\"206\":7,\"234\":1,\"239\":6,\"245\":1,\"276\":2,\"290\":3}}],[\"且x不属于s\",{\"1\":{\"219\":1}}],[\"且原来匹配的点能找到另一个点\",{\"1\":{\"184\":1}}],[\"且到树的距离最短\",{\"1\":{\"181\":1}}],[\"且使权值最小的一种结构\",{\"1\":{\"180\":1}}],[\"且终点是n\",{\"1\":{\"131\":1}}],[\"且保证右端点不会超范围\",{\"1\":{\"126\":1}}],[\"且长度均不超过\",{\"1\":{\"124\":1}}],[\"且数值是严格递增的\",{\"1\":{\"123\":1}}],[\"且总价值最大\",{\"1\":{\"118\":1}}],[\"且一定至少存在一条通路\",{\"1\":{\"71\":1}}],[\"且\",{\"1\":{\"31\":1,\"137\":1,\"205\":1}}],[\"且它们的执行效果相同\",{\"1\":{\"26\":1}}],[\"若已滑出窗口\",{\"1\":{\"269\":1}}],[\"若两区间部分存在交集\",{\"1\":{\"255\":1}}],[\"若右儿子小于它\",{\"1\":{\"240\":1}}],[\"若左二子小于它\",{\"1\":{\"240\":1}}],[\"若左移时舍弃的高位不包含\",{\"1\":{\"158\":1}}],[\"若从1开始\",{\"1\":{\"234\":1}}],[\"若一个游戏满足\",{\"1\":{\"217\":1}}],[\"若在某一局面下存在某种行动\",{\"1\":{\"216\":1}}],[\"若在某一局面下无论采取何种行动\",{\"1\":{\"216\":1}}],[\"若在算数基本定理中\",{\"1\":{\"201\":1}}],[\"若p是质数\",{\"1\":{\"211\":1}}],[\"若整数\",{\"1\":{\"210\":1}}],[\"若为\",{\"1\":{\"203\":1}}],[\"若不进行备份会因此发生串联效应\",{\"1\":{\"175\":1}}],[\"若不超过最大载重\",{\"1\":{\"106\":1}}],[\"若t\",{\"1\":{\"148\":1}}],[\"若a大于b\",{\"1\":{\"148\":1}}],[\"若满足则答案+1\",{\"1\":{\"110\":1}}],[\"若满足则答案\",{\"1\":{\"109\":1}}],[\"若满足条件\",{\"1\":{\"46\":1,\"233\":1}}],[\"若剩下可选的数字不能填满剩下的空位则回退\",{\"1\":{\"102\":1}}],[\"若要提问\",{\"1\":{\"32\":1}}],[\"若\",{\"1\":{\"31\":1,\"65\":1,\"205\":2}}],[\"裴蜀定理\",{\"0\":{\"31\":1,\"205\":1}}],[\"7\",{\"0\":{\"31\":1,\"132\":1,\"133\":1,\"160\":1,\"184\":1,\"207\":1,\"240\":1},\"1\":{\"46\":4,\"65\":3,\"66\":1,\"75\":9,\"79\":1,\"100\":1,\"120\":2,\"127\":2,\"198\":1}}],[\"求分成的最小组数\",{\"1\":{\"253\":1}}],[\"求集合当中的最小值\",{\"1\":{\"240\":1}}],[\"求滑动窗口里的最大值和最小值\",{\"1\":{\"233\":1}}],[\"求每个质因数的次数\",{\"1\":{\"212\":1}}],[\"求每个质数的次数\",{\"1\":{\"212\":1}}],[\"求next\",{\"1\":{\"234\":1}}],[\"求n\",{\"1\":{\"212\":1}}],[\"求组合数\",{\"0\":{\"208\":1}}],[\"求x\",{\"1\":{\"205\":1}}],[\"求x的欧拉函数\",{\"1\":{\"201\":1}}],[\"求整数\",{\"1\":{\"205\":1}}],[\"求欧拉函数\",{\"0\":{\"201\":1}}],[\"求1到n的最短路距离\",{\"1\":{\"175\":1}}],[\"求1号点到n号点的最短距离\",{\"1\":{\"174\":1}}],[\"求1号点到n号点的最短路距离\",{\"1\":{\"176\":1}}],[\"求1号点到n号点的最短路\",{\"1\":{\"173\":1}}],[\"求从一个点到其他所有点的最短距离\",{\"1\":{\"172\":1}}],[\"求最大匹配数\",{\"1\":{\"184\":1}}],[\"求最大权值和\",{\"1\":{\"133\":1}}],[\"求最小生成树的\",{\"1\":{\"59\":1}}],[\"求起点\",{\"1\":{\"131\":1}}],[\"求方案数\",{\"1\":{\"127\":1}}],[\"求既是\",{\"1\":{\"122\":1}}],[\"求一个最小的非负整数\",{\"1\":{\"206\":1}}],[\"求一个序列中严格递增的子序列的最大长度\",{\"1\":{\"121\":1}}],[\"求一颗炸弹最多能炸掉地图上总价值为多少的目标\",{\"1\":{\"53\":1}}],[\"求解将哪些物品装入背包\",{\"1\":{\"118\":1}}],[\"求所选物品的总体积不超过背包容量的条件下\",{\"1\":{\"115\":1}}],[\"求区间和\",{\"1\":{\"46\":1}}],[\"求区间\",{\"1\":{\"46\":1}}],[\"求\",{\"0\":{\"30\":1},\"1\":{\"128\":1,\"203\":1,\"209\":1,\"212\":1,\"234\":2}}],[\"64\",{\"1\":{\"206\":1}}],[\"6010\",{\"1\":{\"133\":4}}],[\"6\",{\"0\":{\"30\":1,\"125\":1,\"129\":1,\"130\":1,\"131\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"183\":1,\"206\":1,\"221\":1,\"236\":1,\"237\":1,\"238\":1,\"239\":1},\"1\":{\"45\":1,\"65\":1,\"75\":9,\"100\":1,\"108\":1,\"120\":1,\"145\":1,\"147\":1,\"148\":1,\"158\":1,\"175\":1,\"207\":1,\"282\":3}}],[\"effect\",{\"1\":{\"289\":1}}],[\"expiry\",{\"1\":{\"290\":1}}],[\"exception\",{\"1\":{\"289\":4,\"290\":7}}],[\"executable>\",{\"1\":{\"277\":1}}],[\"exe<\",{\"1\":{\"277\":1}}],[\"exe\",{\"1\":{\"276\":3,\"277\":6}}],[\"exgcd\",{\"1\":{\"205\":2,\"206\":3}}],[\"exit\",{\"1\":{\"29\":1}}],[\"eulers\",{\"1\":{\"202\":1}}],[\"euler\",{\"1\":{\"202\":7}}],[\"e\",{\"1\":{\"166\":2,\"168\":1,\"169\":1,\"170\":1,\"174\":3,\"176\":3,\"177\":2,\"183\":2,\"184\":2,\"226\":4,\"227\":3,\"242\":3,\"290\":2}}],[\"edges\",{\"1\":{\"175\":4,\"182\":6}}],[\"edge\",{\"1\":{\"166\":1,\"175\":1,\"182\":2}}],[\"edit\",{\"1\":{\"124\":2}}],[\"erasure\",{\"1\":{\"282\":1}}],[\"erase\",{\"1\":{\"161\":1,\"245\":3}}],[\"error\",{\"1\":{\"26\":1}}],[\"eps\",{\"1\":{\"145\":3,\"207\":4}}],[\"empty\",{\"1\":{\"77\":1,\"229\":2,\"232\":2,\"245\":7,\"253\":1}}],[\"else\",{\"1\":{\"62\":1,\"65\":2,\"66\":4,\"121\":2,\"124\":1,\"125\":2,\"130\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"145\":1,\"148\":2,\"161\":1,\"162\":1,\"179\":1,\"181\":1,\"182\":1,\"183\":1,\"209\":1,\"214\":1,\"216\":1,\"229\":1,\"232\":1,\"237\":1,\"252\":1,\"253\":1,\"255\":1,\"289\":1}}],[\"element\",{\"0\":{\"39\":2},\"1\":{\"39\":12}}],[\"endpoint\",{\"1\":{\"287\":3}}],[\"endl\",{\"1\":{\"34\":2,\"47\":1,\"51\":2,\"55\":1,\"66\":2,\"73\":1,\"77\":1,\"94\":1,\"106\":1,\"110\":1,\"115\":2,\"116\":2,\"117\":4,\"118\":2,\"120\":2,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":2,\"130\":1,\"131\":1,\"144\":1,\"150\":2,\"173\":1,\"190\":3,\"198\":1,\"211\":1,\"214\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"end\",{\"1\":{\"33\":1,\"37\":1,\"39\":4,\"121\":1,\"144\":4,\"150\":1,\"161\":3,\"162\":1,\"197\":1,\"245\":5,\"246\":5,\"255\":1}}],[\"roll\",{\"1\":{\"277\":1}}],[\"root\",{\"1\":{\"133\":5,\"262\":1,\"274\":4}}],[\"runtimeexception\",{\"1\":{\"290\":1}}],[\"run\",{\"1\":{\"275\":1}}],[\"rayshinehub\",{\"1\":{\"258\":1}}],[\"range\",{\"1\":{\"253\":8,\"254\":9}}],[\"random\",{\"1\":{\"246\":1}}],[\"rank\",{\"1\":{\"182\":7,\"237\":8}}],[\"r代表区间右端点\",{\"1\":{\"255\":1}}],[\"r表示上一连续区间的最右端的点\",{\"1\":{\"251\":1}}],[\"r时\",{\"1\":{\"140\":1}}],[\"r​\",{\"1\":{\"54\":1}}],[\"r×r\",{\"1\":{\"53\":1}}],[\"r\",{\"1\":{\"29\":1,\"46\":8,\"53\":1,\"54\":4,\"55\":10,\"121\":6,\"137\":8,\"138\":8,\"140\":1,\"141\":7,\"142\":7,\"143\":6,\"145\":4,\"150\":1,\"152\":2,\"154\":2,\"161\":5,\"162\":7,\"207\":12,\"227\":10,\"244\":4,\"251\":8,\"252\":10,\"253\":4,\"254\":12,\"255\":10}}],[\"rsp\",{\"1\":{\"29\":1}}],[\"reed\",{\"1\":{\"282\":1}}],[\"releases\",{\"1\":{\"277\":1}}],[\"release\",{\"1\":{\"274\":1,\"276\":1}}],[\"removeobjectargs\",{\"1\":{\"290\":1}}],[\"removeobject\",{\"1\":{\"290\":2}}],[\"removebucketargs\",{\"1\":{\"289\":1}}],[\"removebucket\",{\"1\":{\"289\":2}}],[\"remove\",{\"1\":{\"226\":2,\"227\":1}}],[\"reverse\",{\"1\":{\"150\":1,\"246\":4}}],[\"ret\",{\"1\":{\"38\":2}}],[\"return\",{\"1\":{\"28\":1,\"29\":1,\"30\":1,\"33\":1,\"38\":1,\"47\":1,\"51\":2,\"55\":1,\"62\":3,\"65\":3,\"66\":6,\"73\":2,\"77\":3,\"85\":2,\"94\":2,\"98\":2,\"102\":3,\"106\":3,\"110\":7,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"128\":6,\"130\":1,\"131\":1,\"133\":2,\"137\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":5,\"149\":2,\"150\":2,\"159\":3,\"161\":1,\"166\":1,\"170\":1,\"173\":3,\"174\":2,\"175\":2,\"176\":2,\"177\":2,\"181\":2,\"182\":5,\"183\":5,\"184\":2,\"189\":3,\"191\":4,\"197\":1,\"198\":1,\"199\":2,\"201\":1,\"203\":1,\"205\":2,\"206\":5,\"207\":3,\"210\":1,\"211\":6,\"212\":2,\"214\":1,\"216\":1,\"234\":1,\"235\":2,\"237\":1,\"238\":1,\"239\":1,\"242\":2,\"243\":1,\"244\":1,\"246\":2,\"251\":2,\"252\":2,\"253\":2,\"254\":2,\"255\":1,\"269\":1,\"287\":1}}],[\"resource\",{\"1\":{\"287\":1,\"289\":1}}],[\"reset\",{\"1\":{\"245\":1}}],[\"res++\",{\"1\":{\"124\":1,\"159\":1,\"184\":1,\"252\":1,\"254\":1}}],[\"res\",{\"1\":{\"27\":2,\"28\":7,\"46\":2,\"47\":3,\"51\":3,\"55\":4,\"106\":4,\"123\":4,\"124\":2,\"159\":2,\"160\":2,\"162\":4,\"181\":3,\"182\":3,\"184\":1,\"191\":7,\"197\":6,\"198\":4,\"201\":6,\"203\":4,\"210\":4,\"211\":4,\"212\":7,\"214\":4,\"216\":3,\"252\":2,\"254\":4}}],[\"resize\",{\"1\":{\"26\":2}}],[\"以便可以通过http访问\",{\"1\":{\"290\":1}}],[\"以便于软件各部件之间的沟通\",{\"1\":{\"15\":1}}],[\"以及对数据安全的保障服务\",{\"1\":{\"281\":1}}],[\"以及存储桶索引\",{\"1\":{\"281\":1}}],[\"以及一个线段区间\",{\"1\":{\"254\":1}}],[\"以及所有阶乘取模的逆元infact\",{\"1\":{\"210\":1}}],[\"以second为第二关键字\",{\"1\":{\"245\":1}}],[\"以first为第一关键字\",{\"1\":{\"245\":1}}],[\"以内的素数表的话\",{\"1\":{\"194\":1}}],[\"以内的合数的最小质因数一定不超过\",{\"1\":{\"194\":1}}],[\"以k为终点的最短距离\",{\"1\":{\"131\":1}}],[\"以最快的速度给出答案\",{\"1\":{\"65\":1}}],[\"以\",{\"1\":{\"50\":1,\"153\":1}}],[\"以下\",{\"1\":{\"45\":1,\"65\":1,\"79\":1}}],[\"以防爆栈风险\",{\"1\":{\"29\":1}}],[\"备份\",{\"1\":{\"29\":1,\"110\":1}}],[\"开源的\",{\"1\":{\"281\":1}}],[\"开源协议\",{\"1\":{\"280\":1}}],[\"开源项目\",{\"0\":{\"19\":1}}],[\"开放寻址法\",{\"0\":{\"243\":1}}],[\"开一个单链表\",{\"1\":{\"166\":1}}],[\"开递递归枚举\",{\"1\":{\"109\":1}}],[\"开始\",{\"1\":{\"65\":2,\"126\":1,\"240\":1}}],[\"开始枚举前缀和数组\",{\"1\":{\"50\":1}}],[\"开栈空间代码\",{\"0\":{\"29\":1}}],[\"build\",{\"0\":{\"300\":1},\"1\":{\"287\":1,\"289\":5,\"290\":7}}],[\"builder\",{\"1\":{\"287\":1,\"289\":5,\"290\":7}}],[\"bucketlist\",{\"1\":{\"289\":2}}],[\"bucket已经存在\",{\"1\":{\"289\":1}}],[\"bucketname\",{\"1\":{\"289\":5}}],[\"bucketexistsargs\",{\"1\":{\"289\":2}}],[\"bucketexists\",{\"1\":{\"289\":3}}],[\"bucket\",{\"0\":{\"289\":1},\"1\":{\"281\":2,\"287\":6,\"289\":10,\"290\":7}}],[\"blob\",{\"1\":{\"282\":1}}],[\"blog\",{\"2\":{\"260\":1}}],[\"b∗x\",{\"1\":{\"210\":1}}],[\"bm−2\",{\"1\":{\"210\":2}}],[\"b−1\",{\"1\":{\"210\":1}}],[\"b=0\",{\"1\":{\"205\":1}}],[\"b=0\",{\"1\":{\"205\":1}}],[\"b=cn−ca\",{\"1\":{\"109\":1}}],[\"b是否连通的方法为\",{\"1\":{\"182\":1}}],[\"b不连通\",{\"1\":{\"182\":1}}],[\"b表示入点\",{\"1\":{\"175\":1}}],[\"bean\",{\"1\":{\"287\":2}}],[\"bellman\",{\"0\":{\"175\":1},\"1\":{\"172\":1,\"175\":2}}],[\"begin\",{\"1\":{\"33\":1,\"37\":1,\"39\":6,\"121\":1,\"144\":4,\"150\":1,\"161\":2,\"162\":1,\"197\":1,\"245\":4,\"246\":6,\"255\":1}}],[\"bitset<10000>\",{\"1\":{\"245\":1}}],[\"bitset\",{\"1\":{\"245\":1}}],[\"bit\",{\"1\":{\"158\":1}}],[\"bsearch\",{\"1\":{\"141\":1,\"142\":1,\"145\":1}}],[\"break\",{\"1\":{\"130\":1,\"183\":2,\"195\":1,\"202\":1,\"212\":1,\"214\":1,\"254\":2}}],[\"b​\",{\"1\":{\"125\":1,\"194\":4}}],[\"base\",{\"1\":{\"128\":8,\"277\":3}}],[\"back\",{\"1\":{\"117\":2,\"121\":3,\"128\":2,\"130\":1,\"147\":4,\"148\":5,\"149\":4,\"150\":4,\"162\":2,\"166\":2,\"191\":2,\"197\":2,\"212\":3,\"245\":7,\"255\":3,\"269\":1}}],[\"backup\",{\"1\":{\"110\":5,\"175\":2}}],[\"bar\",{\"1\":{\"38\":2}}],[\"bound\",{\"1\":{\"121\":1,\"144\":6,\"245\":8,\"246\":7}}],[\"boolean\",{\"1\":{\"289\":2}}],[\"bool\",{\"1\":{\"85\":1,\"98\":1,\"110\":2,\"128\":1,\"130\":2,\"145\":1,\"148\":1,\"170\":1,\"173\":1,\"174\":1,\"176\":1,\"177\":2,\"181\":1,\"182\":1,\"183\":3,\"184\":2,\"189\":1,\"191\":1,\"193\":1,\"194\":2,\"195\":1,\"202\":1,\"212\":1,\"242\":1,\"246\":2,\"251\":1,\"252\":1,\"253\":1,\"254\":2}}],[\"body是函数体\",{\"1\":{\"38\":1}}],[\"body\",{\"1\":{\"38\":1}}],[\"bfs\",{\"0\":{\"70\":1,\"74\":1},\"1\":{\"73\":2,\"77\":2},\"2\":{\"89\":1}}],[\"by\",{\"1\":{\"31\":2,\"205\":3,\"277\":1}}],[\"b代表进制位数\",{\"1\":{\"28\":1}}],[\"b\",{\"0\":{\"30\":1},\"1\":{\"28\":1,\"31\":3,\"40\":1,\"65\":5,\"77\":2,\"109\":3,\"110\":5,\"117\":4,\"122\":6,\"123\":8,\"124\":3,\"125\":6,\"128\":8,\"133\":4,\"144\":4,\"147\":14,\"148\":28,\"149\":11,\"150\":11,\"154\":2,\"158\":5,\"166\":12,\"173\":8,\"174\":2,\"175\":9,\"176\":3,\"179\":1,\"181\":5,\"182\":6,\"194\":13,\"198\":2,\"199\":7,\"203\":2,\"205\":17,\"206\":9,\"209\":2,\"210\":13,\"211\":16,\"212\":8,\"238\":2,\"239\":1,\"240\":4,\"246\":6}}],[\"秦九韶算法\",{\"0\":{\"28\":1}}],[\"404\",{\"1\":{\"296\":1}}],[\"4\",{\"0\":{\"28\":1,\"86\":1,\"118\":1,\"123\":1,\"127\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":2,\"155\":1,\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":2,\"177\":1,\"178\":1,\"179\":1,\"203\":1,\"212\":1,\"219\":1,\"234\":1,\"254\":1},\"1\":{\"39\":1,\"40\":2,\"45\":1,\"49\":2,\"65\":2,\"66\":4,\"73\":3,\"75\":9,\"77\":3,\"100\":6,\"120\":3,\"123\":1,\"147\":1,\"148\":1,\"158\":7,\"175\":1,\"176\":1,\"193\":1,\"226\":1,\"240\":2,\"246\":1}}],[\"<version>8\",{\"1\":{\"286\":1}}],[\"<vector>\",{\"1\":{\"117\":1,\"121\":1,\"130\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"198\":1,\"255\":1}}],[\"<groupid>io\",{\"1\":{\"286\":1}}],[\"<dependency>\",{\"1\":{\"286\":1}}],[\"<description>minio文件存储服务<\",{\"1\":{\"277\":1}}],[\"<zipdateformat>yyyymmdd<\",{\"1\":{\"277\":1}}],[\"<zipolderthannumdays>5<zipolderthannumdays>\",{\"1\":{\"277\":1}}],[\"<pattern>yyyymmdd<\",{\"1\":{\"277\":1}}],[\"<pii>\",{\"1\":{\"255\":1}}],[\"<sizethreshold>10240<\",{\"1\":{\"277\":1}}],[\"<service>\",{\"1\":{\"277\":1}}],[\"<log\",{\"1\":{\"277\":1}}],[\"<logpath>\",{\"1\":{\"277\":1}}],[\"<artifactid>minio<\",{\"1\":{\"286\":1}}],[\"<arguments>server\",{\"1\":{\"277\":1}}],[\"<autorollattime>00\",{\"1\":{\"277\":1}}],[\"<algortihm>\",{\"1\":{\"173\":1}}],[\"<algorithm>\",{\"1\":{\"47\":1,\"51\":1,\"55\":1,\"73\":1,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"130\":1,\"144\":1,\"150\":1,\"198\":1,\"206\":1,\"216\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"<executable>\",{\"1\":{\"277\":1}}],[\"<name>minio\",{\"1\":{\"277\":1}}],[\"<id>minio\",{\"1\":{\"277\":1}}],[\"<iostream>\",{\"1\":{\"47\":1,\"51\":1,\"55\":1,\"65\":1,\"66\":1,\"73\":1,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"130\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"173\":1,\"198\":1,\"206\":1,\"216\":1,\"234\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"<bit\",{\"1\":{\"133\":1}}],[\"<bits\",{\"1\":{\"128\":1,\"181\":1,\"182\":1}}],[\"<unordered\",{\"1\":{\"77\":1,\"198\":1}}],[\"<queue>\",{\"1\":{\"73\":1,\"77\":1,\"253\":1}}],[\"<cstdlib>\",{\"1\":{\"65\":1}}],[\"<cstdio>\",{\"1\":{\"65\":1,\"66\":1,\"115\":1,\"116\":1,\"117\":1,\"121\":2,\"255\":1}}],[\"<cstring>\",{\"1\":{\"47\":1,\"51\":1,\"55\":1,\"73\":1,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"117\":2,\"118\":2,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"130\":1,\"173\":1}}],[\"<<\",{\"1\":{\"34\":5,\"47\":2,\"51\":4,\"55\":2,\"66\":4,\"73\":2,\"77\":2,\"94\":3,\"98\":2,\"102\":2,\"106\":2,\"110\":2,\"115\":4,\"116\":4,\"117\":8,\"118\":4,\"120\":4,\"121\":6,\"122\":2,\"123\":2,\"124\":2,\"125\":2,\"126\":2,\"127\":4,\"130\":7,\"131\":4,\"144\":2,\"150\":4,\"157\":1,\"158\":2,\"159\":3,\"173\":2,\"190\":9,\"198\":2,\"211\":2,\"214\":3,\"245\":1,\"251\":2,\"252\":2,\"253\":2,\"254\":2,\"255\":2}}],[\"<=\",{\"1\":{\"28\":1,\"47\":1,\"51\":2,\"55\":5,\"61\":1,\"65\":3,\"66\":2,\"73\":4,\"85\":1,\"98\":2,\"102\":2,\"106\":1,\"110\":3,\"115\":5,\"116\":5,\"117\":11,\"118\":3,\"120\":7,\"121\":4,\"122\":2,\"123\":5,\"124\":5,\"125\":4,\"126\":6,\"127\":5,\"128\":13,\"130\":1,\"133\":2,\"138\":5,\"142\":2,\"143\":1,\"166\":2,\"170\":2,\"173\":2,\"175\":1,\"177\":1,\"179\":5,\"181\":3,\"182\":1,\"183\":1,\"184\":1,\"189\":1,\"190\":1,\"191\":3,\"193\":2,\"195\":2,\"197\":1,\"198\":1,\"201\":1,\"202\":2,\"207\":1,\"209\":1,\"211\":3,\"212\":2,\"230\":1,\"232\":1,\"233\":2,\"234\":2,\"237\":1,\"238\":1,\"239\":1,\"240\":2,\"244\":1,\"251\":2,\"252\":3,\"254\":1,\"269\":1}}],[\"<\",{\"1\":{\"27\":1,\"73\":1,\"77\":4,\"85\":1,\"94\":1,\"102\":1,\"104\":1,\"106\":2,\"117\":2,\"118\":5,\"121\":8,\"124\":2,\"126\":1,\"128\":1,\"130\":5,\"131\":5,\"133\":1,\"137\":4,\"138\":1,\"141\":1,\"142\":1,\"144\":2,\"147\":4,\"148\":5,\"149\":2,\"160\":2,\"161\":1,\"162\":1,\"166\":2,\"173\":1,\"175\":2,\"181\":3,\"182\":4,\"189\":1,\"194\":5,\"206\":1,\"207\":7,\"209\":1,\"210\":1,\"211\":3,\"212\":4,\"214\":3,\"233\":1,\"237\":1,\"240\":3,\"246\":3,\"251\":2,\"252\":2,\"253\":4,\"254\":6,\"255\":2,\"269\":2,\"277\":3,\"286\":1}}],[\"item\",{\"1\":{\"290\":3}}],[\"itemresult\",{\"1\":{\"290\":2}}],[\"iterable<result<item>>\",{\"1\":{\"290\":1}}],[\"io\",{\"0\":{\"303\":1},\"1\":{\"258\":1,\"276\":1,\"280\":1}}],[\"i的最小质因子\",{\"1\":{\"195\":1}}],[\"i的根节点指向j的根节点\",{\"1\":{\"63\":1}}],[\"i是素数\",{\"1\":{\"194\":1}}],[\"impossible\",{\"1\":{\"181\":1}}],[\"id>\",{\"1\":{\"277\":1}}],[\"idx表示当前用到了哪个节点\",{\"1\":{\"226\":1,\"227\":1}}],[\"idx++\",{\"1\":{\"174\":1,\"176\":1,\"226\":1,\"227\":1}}],[\"idx\",{\"1\":{\"166\":5,\"174\":4,\"176\":4,\"177\":1,\"183\":1,\"184\":1,\"226\":8,\"227\":6,\"235\":2,\"242\":4}}],[\"id\",{\"1\":{\"166\":3,\"246\":1}}],[\"i表示所有的情况\",{\"1\":{\"131\":1}}],[\"i表示从哪个数开始\",{\"1\":{\"102\":1}}],[\"isbucketexists\",{\"1\":{\"289\":4}}],[\"is\",{\"1\":{\"130\":4,\"189\":1,\"191\":1,\"194\":8}}],[\"i==nums\",{\"1\":{\"128\":1}}],[\"i−1个\",{\"1\":{\"202\":1}}],[\"i−1均与\",{\"1\":{\"202\":1}}],[\"i−1\",{\"1\":{\"127\":1}}],[\"i+1\",{\"1\":{\"104\":1,\"206\":1}}],[\"i++\",{\"1\":{\"27\":1,\"28\":1,\"47\":1,\"51\":2,\"55\":3,\"61\":1,\"65\":3,\"66\":2,\"73\":2,\"77\":2,\"85\":2,\"94\":1,\"98\":2,\"102\":2,\"106\":2,\"110\":3,\"115\":3,\"116\":3,\"117\":6,\"118\":3,\"120\":4,\"121\":7,\"122\":1,\"123\":4,\"124\":4,\"125\":2,\"126\":3,\"128\":8,\"131\":2,\"133\":3,\"137\":1,\"138\":3,\"144\":2,\"147\":1,\"148\":1,\"149\":1,\"160\":1,\"166\":1,\"170\":1,\"179\":2,\"181\":3,\"182\":2,\"189\":1,\"190\":1,\"191\":3,\"193\":1,\"194\":3,\"195\":1,\"197\":1,\"201\":1,\"206\":1,\"209\":1,\"214\":2,\"230\":1,\"233\":1,\"234\":2,\"237\":1,\"251\":2,\"252\":2,\"253\":2,\"254\":1,\"255\":1,\"269\":2}}],[\"install\",{\"1\":{\"277\":1}}],[\"insert\",{\"1\":{\"226\":1,\"227\":1,\"235\":1,\"242\":1,\"245\":2}}],[\"inline\",{\"1\":{\"206\":1}}],[\"index\",{\"1\":{\"281\":1}}],[\"index指向下一个指针\",{\"1\":{\"226\":1}}],[\"ind\",{\"1\":{\"133\":5}}],[\"infact\",{\"1\":{\"210\":4}}],[\"inf\",{\"1\":{\"120\":3,\"175\":3,\"179\":1,\"181\":3,\"182\":1}}],[\"init\",{\"1\":{\"59\":1,\"61\":1,\"65\":2,\"66\":2,\"128\":2,\"182\":2,\"226\":1,\"227\":1,\"237\":1}}],[\"include<algorithm>\",{\"1\":{\"131\":1}}],[\"include<cstring>\",{\"1\":{\"131\":1}}],[\"include<iostream>\",{\"1\":{\"131\":1,\"214\":1}}],[\"include\",{\"1\":{\"47\":3,\"51\":3,\"55\":3,\"65\":3,\"66\":2,\"73\":4,\"77\":5,\"85\":3,\"94\":3,\"98\":3,\"102\":3,\"106\":3,\"110\":3,\"115\":3,\"116\":3,\"117\":10,\"118\":6,\"120\":2,\"121\":9,\"122\":3,\"123\":3,\"124\":3,\"125\":3,\"126\":3,\"127\":1,\"128\":1,\"130\":4,\"133\":1,\"144\":2,\"147\":2,\"148\":2,\"149\":2,\"150\":3,\"159\":2,\"173\":3,\"181\":1,\"182\":1,\"198\":4,\"206\":2,\"216\":2,\"234\":1,\"251\":2,\"252\":2,\"253\":3,\"254\":2,\"255\":4}}],[\"int>>\",{\"1\":{\"269\":1}}],[\"int>\",{\"1\":{\"73\":1,\"77\":1,\"174\":1,\"191\":2,\"198\":1,\"245\":1,\"255\":1}}],[\"int\",{\"0\":{\"34\":1},\"1\":{\"27\":1,\"28\":5,\"29\":2,\"30\":3,\"33\":3,\"34\":5,\"38\":6,\"39\":9,\"40\":4,\"47\":4,\"51\":5,\"55\":11,\"61\":3,\"62\":4,\"63\":4,\"65\":14,\"66\":16,\"73\":11,\"77\":10,\"85\":7,\"94\":6,\"98\":7,\"102\":8,\"106\":10,\"110\":16,\"115\":10,\"116\":10,\"117\":32,\"118\":19,\"120\":15,\"121\":25,\"122\":6,\"123\":12,\"124\":14,\"125\":8,\"126\":14,\"127\":9,\"128\":25,\"130\":10,\"131\":9,\"133\":12,\"137\":4,\"138\":6,\"141\":4,\"142\":4,\"143\":5,\"144\":5,\"147\":7,\"148\":8,\"149\":7,\"150\":8,\"158\":2,\"159\":10,\"160\":1,\"161\":4,\"162\":1,\"166\":19,\"168\":4,\"169\":3,\"170\":5,\"173\":11,\"174\":10,\"175\":7,\"176\":10,\"177\":7,\"179\":5,\"181\":15,\"182\":17,\"183\":8,\"184\":8,\"189\":2,\"190\":3,\"191\":6,\"193\":4,\"194\":4,\"195\":5,\"197\":2,\"198\":5,\"199\":6,\"201\":4,\"202\":6,\"203\":5,\"205\":6,\"206\":1,\"207\":13,\"209\":2,\"210\":6,\"211\":14,\"212\":16,\"214\":9,\"216\":4,\"226\":5,\"227\":4,\"229\":2,\"230\":2,\"232\":1,\"233\":2,\"234\":6,\"235\":10,\"237\":9,\"238\":4,\"239\":5,\"240\":7,\"242\":6,\"243\":4,\"244\":3,\"246\":10,\"251\":8,\"252\":7,\"253\":6,\"254\":9,\"255\":6,\"269\":4}}],[\"if\",{\"1\":{\"27\":2,\"33\":1,\"38\":2,\"51\":3,\"62\":1,\"65\":2,\"66\":8,\"73\":1,\"77\":3,\"85\":2,\"94\":2,\"98\":2,\"102\":2,\"106\":3,\"110\":9,\"115\":1,\"116\":1,\"117\":2,\"118\":2,\"121\":4,\"122\":2,\"123\":2,\"124\":2,\"125\":2,\"126\":1,\"127\":1,\"128\":4,\"130\":4,\"131\":2,\"133\":3,\"137\":2,\"138\":2,\"141\":1,\"142\":1,\"143\":1,\"145\":1,\"147\":3,\"148\":5,\"149\":1,\"158\":3,\"161\":1,\"162\":3,\"166\":3,\"168\":1,\"169\":1,\"170\":2,\"173\":2,\"174\":3,\"175\":4,\"176\":3,\"177\":3,\"179\":1,\"181\":4,\"182\":6,\"183\":5,\"184\":3,\"189\":2,\"190\":2,\"191\":4,\"193\":1,\"194\":1,\"195\":2,\"197\":2,\"198\":1,\"201\":2,\"202\":2,\"203\":1,\"205\":1,\"206\":2,\"207\":5,\"209\":1,\"210\":1,\"211\":3,\"212\":2,\"214\":4,\"216\":1,\"229\":1,\"232\":1,\"233\":2,\"234\":3,\"235\":2,\"237\":2,\"238\":1,\"239\":1,\"240\":3,\"242\":1,\"243\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":3,\"255\":3,\"289\":1}}],[\"i\",{\"0\":{\"36\":1},\"1\":{\"27\":4,\"28\":6,\"36\":1,\"45\":1,\"46\":8,\"47\":8,\"50\":4,\"51\":9,\"54\":4,\"55\":14,\"61\":4,\"63\":3,\"65\":10,\"66\":11,\"73\":7,\"77\":6,\"85\":9,\"94\":4,\"98\":9,\"102\":7,\"104\":1,\"106\":8,\"110\":15,\"115\":20,\"116\":19,\"117\":30,\"118\":14,\"120\":25,\"121\":32,\"122\":16,\"123\":18,\"124\":22,\"125\":27,\"126\":26,\"127\":44,\"128\":44,\"130\":19,\"131\":15,\"133\":17,\"137\":11,\"138\":9,\"144\":7,\"147\":19,\"148\":29,\"149\":12,\"150\":12,\"152\":2,\"153\":1,\"159\":2,\"160\":5,\"166\":15,\"168\":5,\"169\":5,\"170\":10,\"173\":3,\"174\":7,\"175\":3,\"176\":7,\"177\":12,\"179\":10,\"181\":9,\"182\":10,\"183\":10,\"184\":9,\"189\":4,\"190\":7,\"191\":18,\"193\":6,\"194\":17,\"195\":15,\"197\":8,\"198\":7,\"201\":8,\"202\":26,\"206\":2,\"207\":30,\"209\":7,\"210\":9,\"211\":3,\"212\":22,\"214\":6,\"230\":4,\"233\":4,\"234\":16,\"235\":9,\"237\":5,\"238\":6,\"239\":6,\"240\":4,\"242\":5,\"244\":8,\"246\":1,\"251\":8,\"252\":9,\"253\":7,\"254\":8,\"255\":2,\"269\":9}}],[\"在服务安装后\",{\"1\":{\"282\":1}}],[\"在很早的时候就采用了\",{\"1\":{\"282\":1}}],[\"在标准硬件上\",{\"1\":{\"282\":1}}],[\"在这种情况下\",{\"1\":{\"281\":1}}],[\"在同目录下创建\",{\"1\":{\"277\":1}}],[\"在同一行用空格隔开\",{\"1\":{\"100\":1}}],[\"在浏览器输入\",{\"1\":{\"276\":1}}],[\"在\",{\"1\":{\"274\":1,\"277\":1,\"287\":1}}],[\"在递归的方法中\",{\"1\":{\"264\":1}}],[\"在有序\",{\"1\":{\"246\":2}}],[\"在有向图游戏中\",{\"1\":{\"220\":1}}],[\"在两个迭代器\",{\"1\":{\"246\":1}}],[\"在哈希表中查询某个数是否存在\",{\"1\":{\"242\":1}}],[\"在满足\",{\"1\":{\"234\":1}}],[\"在节点k的右边插入一个数x\",{\"1\":{\"227\":1}}],[\"在算法竞赛中一般不需要考虑删除的那个节点该如何处理\",{\"1\":{\"226\":1}}],[\"在链表头插入一个数a\",{\"1\":{\"226\":1}}],[\"在起点上放有一枚棋子\",{\"1\":{\"218\":1}}],[\"在游戏进程的任意时刻\",{\"1\":{\"217\":1}}],[\"在游戏过程中\",{\"1\":{\"75\":1}}],[\"在图论中\",{\"1\":{\"180\":1,\"184\":1}}],[\"在图中选择若干条边把图中的所有节点连接起来\",{\"1\":{\"180\":1}}],[\"在保存最短路径的数组中\",{\"1\":{\"176\":1}}],[\"在还未确定最短路的点中\",{\"1\":{\"173\":1}}],[\"在所有子节点更新后再更新\",{\"1\":{\"133\":1}}],[\"在字符串\",{\"1\":{\"125\":1}}],[\"在字符串中的位置\",{\"1\":{\"77\":1}}],[\"在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点\",{\"1\":{\"120\":1}}],[\"在网格中的位置\",{\"1\":{\"77\":1}}],[\"在一个\",{\"1\":{\"75\":1}}],[\"在一个数组中查找最长的相同连续子序列\",{\"0\":{\"27\":1}}],[\"在由\",{\"1\":{\"27\":1}}],[\"在构造或者拼接\",{\"1\":{\"26\":1}}],[\"=p\",{\"1\":{\"234\":1}}],[\"=1\",{\"1\":{\"205\":1}}],[\"=10\",{\"1\":{\"128\":2}}],[\"=n×p1​p1​−1​×p2​p2​−1​×\",{\"1\":{\"201\":1}}],[\"=>\",{\"1\":{\"194\":1}}],[\"=∑u=sons​dp\",{\"1\":{\"133\":1}}],[\"=∑u=sons​max\",{\"1\":{\"133\":1}}],[\"=0\",{\"1\":{\"131\":1}}],[\"=f\",{\"1\":{\"127\":1}}],[\"==\",{\"1\":{\"27\":2,\"33\":1,\"38\":1,\"46\":5,\"51\":2,\"62\":2,\"65\":2,\"66\":6,\"73\":2,\"77\":1,\"85\":1,\"94\":2,\"106\":1,\"122\":2,\"123\":1,\"124\":1,\"125\":2,\"126\":1,\"130\":1,\"148\":1,\"149\":1,\"150\":1,\"158\":3,\"170\":2,\"173\":2,\"174\":1,\"175\":1,\"176\":1,\"179\":1,\"181\":3,\"182\":3,\"183\":3,\"184\":1,\"189\":1,\"190\":2,\"191\":3,\"195\":2,\"197\":1,\"198\":1,\"201\":2,\"202\":2,\"212\":1,\"234\":3,\"242\":1,\"243\":1,\"245\":1,\"246\":1}}],[\"=\",{\"1\":{\"26\":1,\"27\":3,\"28\":5,\"31\":3,\"33\":3,\"34\":8,\"35\":1,\"38\":8,\"39\":9,\"40\":1,\"46\":1,\"47\":5,\"50\":4,\"51\":5,\"55\":9,\"61\":2,\"62\":1,\"63\":3,\"65\":8,\"66\":14,\"73\":11,\"77\":14,\"85\":6,\"94\":6,\"98\":7,\"102\":5,\"106\":8,\"110\":12,\"115\":9,\"116\":9,\"117\":28,\"118\":13,\"120\":17,\"121\":26,\"122\":7,\"123\":12,\"124\":16,\"125\":13,\"126\":18,\"127\":16,\"128\":29,\"130\":15,\"131\":10,\"133\":6,\"137\":5,\"138\":12,\"140\":1,\"141\":5,\"142\":5,\"143\":4,\"144\":5,\"145\":4,\"147\":12,\"148\":20,\"149\":8,\"150\":8,\"152\":2,\"153\":1,\"154\":1,\"155\":2,\"158\":31,\"159\":10,\"160\":3,\"161\":5,\"162\":8,\"166\":14,\"168\":5,\"169\":7,\"170\":10,\"173\":12,\"174\":14,\"175\":8,\"176\":15,\"177\":11,\"179\":8,\"181\":17,\"182\":19,\"183\":8,\"184\":8,\"189\":1,\"190\":3,\"191\":8,\"193\":5,\"194\":10,\"195\":6,\"197\":2,\"198\":11,\"201\":5,\"202\":11,\"203\":5,\"205\":9,\"206\":10,\"207\":16,\"209\":4,\"210\":8,\"211\":10,\"212\":17,\"213\":1,\"214\":12,\"216\":2,\"219\":1,\"220\":2,\"221\":1,\"226\":10,\"227\":10,\"229\":2,\"230\":3,\"232\":3,\"233\":4,\"234\":12,\"235\":9,\"237\":9,\"238\":6,\"239\":8,\"240\":10,\"242\":8,\"243\":4,\"244\":4,\"245\":1,\"246\":4,\"251\":6,\"252\":7,\"253\":4,\"254\":13,\"255\":9,\"269\":4,\"287\":1,\"289\":5,\"290\":8}}],[\"如何实现\",{\"0\":{\"293\":1}}],[\"如用户\",{\"1\":{\"281\":1}}],[\"如启动信息\",{\"1\":{\"274\":1}}],[\"如点\",{\"1\":{\"175\":1}}],[\"如题\",{\"1\":{\"66\":1}}],[\"如下所示\",{\"1\":{\"66\":1,\"79\":1}}],[\"如\",{\"1\":{\"65\":1,\"176\":1,\"234\":1}}],[\"如有必要\",{\"1\":{\"37\":1}}],[\"如果是\",{\"1\":{\"282\":1}}],[\"如果要使用\",{\"1\":{\"277\":1}}],[\"如果要插在k的左边\",{\"1\":{\"227\":1}}],[\"如果两区间无法合并\",{\"1\":{\"255\":1}}],[\"如果两个连通块不连通\",{\"1\":{\"182\":1}}],[\"如果所有右端点都小于l\",{\"1\":{\"254\":1}}],[\"如果所有点都入队了\",{\"1\":{\"170\":1}}],[\"如果到了末尾\",{\"1\":{\"243\":1}}],[\"如果x不在哈希表中\",{\"1\":{\"243\":1}}],[\"如果x在哈希表中\",{\"1\":{\"243\":1}}],[\"如果比父节点大\",{\"1\":{\"240\":1}}],[\"如果它本身不是最小的数\",{\"1\":{\"240\":1}}],[\"如果它们都包含一段位置不一定连续的数\",{\"1\":{\"123\":1}}],[\"如果窗口满足条件\",{\"1\":{\"233\":1}}],[\"如果取模的数是质数\",{\"1\":{\"210\":1}}],[\"如果满足条件再输出结果\",{\"1\":{\"233\":1}}],[\"如果满足\",{\"1\":{\"210\":1}}],[\"如果当前数能整除目标数\",{\"1\":{\"197\":1}}],[\"如果最后\",{\"1\":{\"190\":1}}],[\"如果最高位有数\",{\"1\":{\"147\":1}}],[\"如果这个点未被匹配\",{\"1\":{\"184\":1}}],[\"如果在这一轮的匹配中\",{\"1\":{\"184\":1}}],[\"如果你想找的妹子已经有了男朋友\",{\"1\":{\"184\":1}}],[\"如果你的程序问了一个无效的问题\",{\"1\":{\"32\":1}}],[\"如果途径另一个未匹配点\",{\"1\":{\"184\":1}}],[\"如果一个图的某个匹配中\",{\"1\":{\"184\":1}}],[\"如果该数没有被筛掉\",{\"1\":{\"193\":1}}],[\"如果该条边上的两个顶点在一个集合中\",{\"1\":{\"182\":1}}],[\"如果该元素大于栈顶元素\",{\"1\":{\"121\":1}}],[\"如果没有在树中\",{\"1\":{\"181\":1}}],[\"如果图不连通\",{\"1\":{\"181\":1}}],[\"如果图中存在负权回路\",{\"1\":{\"175\":1}}],[\"如果从1号点到x的最短路中包含至少n个点\",{\"1\":{\"177\":1}}],[\"如果从1号点无法走到n号点则返回\",{\"1\":{\"176\":1}}],[\"如果某条最短路径上有n个点\",{\"1\":{\"177\":1}}],[\"如果队列中已存在j\",{\"1\":{\"176\":1}}],[\"如果变短且该点不在队列中\",{\"1\":{\"176\":1}}],[\"如果第n次迭代仍然会松弛三角不等式\",{\"1\":{\"175\":1}}],[\"如果第三段不符合\",{\"1\":{\"50\":1}}],[\"如果无法从1走到n\",{\"1\":{\"175\":1}}],[\"如果为无穷大\",{\"1\":{\"173\":1}}],[\"如果不能覆盖掉右端点\",{\"1\":{\"251\":1}}],[\"如果不在一个集合中\",{\"1\":{\"182\":1}}],[\"如果不存在\",{\"1\":{\"174\":1}}],[\"如果不存在则返回\",{\"1\":{\"173\":1}}],[\"如果不存在解决方案\",{\"1\":{\"75\":1}}],[\"如果不是起点\",{\"1\":{\"170\":1}}],[\"如果想将一个单元清零\",{\"1\":{\"158\":1}}],[\"如果t\",{\"1\":{\"148\":1}}],[\"如果有两个大于\",{\"1\":{\"190\":1}}],[\"如果有那就使在同一个集合中\",{\"1\":{\"182\":1}}],[\"如果有\",{\"1\":{\"148\":1,\"194\":1}}],[\"如果有一部分遍历完了\",{\"1\":{\"138\":1}}],[\"如果有一位没用上\",{\"1\":{\"110\":1}}],[\"如果a\",{\"1\":{\"148\":2}}],[\"如果条件成立则记下答案\",{\"1\":{\"143\":1}}],[\"如果初始网格如下所示\",{\"1\":{\"75\":1}}],[\"如果存在负环\",{\"1\":{\"177\":1}}],[\"如果存在\",{\"1\":{\"75\":1,\"206\":1}}],[\"如果i从0开始那么i\",{\"1\":{\"55\":1}}],[\"如果\",{\"1\":{\"46\":1,\"50\":1,\"137\":1,\"148\":1,\"182\":1,\"195\":1,\"198\":1,\"205\":1,\"206\":1,\"210\":1,\"230\":1}}],[\"如果其中一段连续的子序列\",{\"1\":{\"45\":1}}],[\"如果已经使用了\",{\"1\":{\"38\":1}}],[\"如果查找失败\",{\"1\":{\"35\":1}}],[\"如果查找成功\",{\"1\":{\"35\":1}}],[\"如果字符串长度很大\",{\"1\":{\"26\":1}}],[\"如需输出string对象中的字符串\",{\"1\":{\"26\":1}}],[\"③\",{\"1\":{\"26\":1}}],[\"并将这些块分散存储在不同的磁盘上\",{\"1\":{\"282\":1}}],[\"并形成一个全局的命名空间\",{\"1\":{\"282\":1}}],[\"并在gi上行动一步\",{\"1\":{\"221\":1}}],[\"并不是第一行\",{\"1\":{\"207\":1}}],[\"并回代得到方程的解\",{\"1\":{\"207\":1}}],[\"并非真正的无穷大\",{\"1\":{\"175\":1}}],[\"并非字符串的首地址\",{\"1\":{\"26\":1}}],[\"并逐位执行操作\",{\"1\":{\"157\":1}}],[\"并且\",{\"1\":{\"282\":1}}],[\"并且除了\",{\"1\":{\"282\":1}}],[\"并且支持跨越多个数据中心\",{\"1\":{\"282\":1}}],[\"并且忽略挂起\",{\"1\":{\"274\":1}}],[\"并且从每个局面向沿着合法行动能够到达的下一个局面连有向边\",{\"1\":{\"218\":1}}],[\"并且对于任意的整数\",{\"1\":{\"210\":1}}],[\"并且判断是否有解\",{\"1\":{\"206\":1}}],[\"并且边长之和最小\",{\"1\":{\"181\":1}}],[\"并且一般\",{\"1\":{\"126\":1}}],[\"并且可以捕获一定范围内的变量\",{\"1\":{\"38\":1}}],[\"并进行路径压缩\",{\"1\":{\"62\":1}}],[\"并查集核心操作\",{\"1\":{\"182\":1}}],[\"并查集的父节点数组\",{\"1\":{\"182\":1}}],[\"并查集是一种非常精巧实用的数据结构\",{\"1\":{\"59\":1}}],[\"并查集\",{\"0\":{\"58\":1,\"66\":1,\"236\":1},\"2\":{\"68\":1}}],[\"并按引用捕获\",{\"1\":{\"38\":1}}],[\"并作为副本在函数体中使用\",{\"1\":{\"38\":1}}],[\"并作为引用在函数体中使用\",{\"1\":{\"38\":1}}],[\"并提供标准接口\",{\"1\":{\"15\":1}}],[\"还提供可视化的操作管理界面\",{\"1\":{\"282\":1}}],[\"还支持\",{\"1\":{\"282\":1}}],[\"还需要补上\",{\"1\":{\"202\":1}}],[\"还是\",{\"1\":{\"143\":1,\"158\":1,\"190\":1}}],[\"还可以表示为\",{\"1\":{\"108\":1}}],[\"还原\",{\"1\":{\"77\":1}}],[\"还包含了许多用于操作的函数\",{\"1\":{\"26\":1}}],[\"还要实现应用之间的互操作\",{\"1\":{\"15\":1}}],[\"②赋\",{\"1\":{\"37\":1}}],[\"②\",{\"1\":{\"26\":1,\"144\":1,\"202\":1}}],[\"而非对某个数的余数时\",{\"1\":{\"212\":1}}],[\"而非一种软件\",{\"1\":{\"15\":1}}],[\"而整数\",{\"1\":{\"210\":1}}],[\"而此时另一个数即为所求答案\",{\"1\":{\"199\":1}}],[\"而并非是\",{\"1\":{\"175\":1}}],[\"而另一部分还有剩余\",{\"1\":{\"138\":1}}],[\"而所有的公共上升子序列中最长的就是最长公共上升子序列了\",{\"1\":{\"123\":1}}],[\"而\",{\"1\":{\"26\":1,\"104\":1}}],[\"即丢失一半数量的硬盘的情况下仍能保证数据的安全性\",{\"1\":{\"282\":1}}],[\"即输出到\",{\"1\":{\"274\":1}}],[\"即使你退出了终端或关闭了会话\",{\"1\":{\"274\":1}}],[\"即当前节点的父节点\",{\"1\":{\"264\":1}}],[\"即当前位置能填哪些数\",{\"1\":{\"98\":1}}],[\"即这个迭代器是去重之后末尾元素的下一个位置\",{\"1\":{\"246\":1}}],[\"即小根堆\",{\"1\":{\"240\":1}}],[\"即sg\",{\"1\":{\"220\":1}}],[\"即两人均无失误\",{\"1\":{\"216\":1}}],[\"即为\",{\"1\":{\"210\":1}}],[\"即用二进制来表示\",{\"1\":{\"203\":1}}],[\"即组合成\",{\"1\":{\"203\":1}}],[\"即找到了\",{\"1\":{\"195\":1}}],[\"即源码取反加\",{\"1\":{\"159\":1}}],[\"即除以\",{\"1\":{\"158\":1}}],[\"即乘上\",{\"1\":{\"158\":1}}],[\"即得\",{\"1\":{\"158\":1}}],[\"即t\",{\"1\":{\"148\":1}}],[\"即可得到\",{\"1\":{\"158\":3}}],[\"即可\",{\"1\":{\"109\":1,\"143\":1,\"274\":1,\"287\":1}}],[\"即可计算出该正方形内所有目标的价值之和\",{\"1\":{\"54\":1}}],[\"即那个正方形的边必须和\",{\"1\":{\"53\":1}}],[\"即一个无符号整型类型\",{\"1\":{\"35\":1}}],[\"即\",{\"1\":{\"26\":1,\"35\":2,\"46\":2,\"158\":3,\"159\":2,\"216\":2,\"219\":1,\"220\":1,\"221\":1}}],[\"①将区间\",{\"1\":{\"37\":1}}],[\"①\",{\"1\":{\"26\":1,\"144\":1,\"202\":1}}],[\"5个基本操作\",{\"1\":{\"240\":1}}],[\"510\",{\"1\":{\"120\":1,\"173\":1}}],[\"512m\",{\"1\":{\"29\":1}}],[\"512<<20\",{\"1\":{\"29\":1}}],[\"5001\",{\"1\":{\"55\":5}}],[\"5e3\",{\"1\":{\"55\":1}}],[\"5\",{\"0\":{\"29\":1,\"87\":1,\"124\":1,\"128\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":1,\"155\":1,\"177\":1,\"180\":1,\"181\":1,\"182\":1,\"204\":1,\"213\":1,\"220\":1,\"235\":1,\"255\":1},\"1\":{\"26\":1,\"45\":2,\"49\":2,\"65\":2,\"71\":2,\"75\":9,\"100\":8,\"104\":1,\"120\":2,\"147\":1,\"148\":1,\"158\":1,\"175\":1,\"240\":1,\"246\":1,\"255\":1,\"286\":1}}],[\"编辑距离\",{\"0\":{\"124\":1}}],[\"编译器会拋出\",{\"1\":{\"26\":1}}],[\"编程语言\",{\"0\":{\"10\":1}}],[\"操作数每右移一位\",{\"1\":{\"158\":1}}],[\"操作\",{\"0\":{\"289\":1,\"290\":1},\"1\":{\"26\":1,\"240\":1}}],[\"操作系统\",{\"0\":{\"13\":1},\"1\":{\"8\":1}}],[\"myfile2\",{\"1\":{\"289\":2}}],[\"myfile目录是否存在\",{\"1\":{\"289\":1}}],[\"myfile\",{\"1\":{\"289\":1,\"290\":7}}],[\"mnt\",{\"1\":{\"274\":3,\"275\":1}}],[\"mn​\",{\"1\":{\"206\":1}}],[\"m匹配串长度\",{\"1\":{\"234\":1}}],[\"m个1\",{\"1\":{\"214\":1}}],[\"m==0\",{\"1\":{\"210\":1}}],[\"m2\",{\"1\":{\"206\":4}}],[\"m2​\",{\"1\":{\"206\":1}}],[\"m1\",{\"1\":{\"206\":7}}],[\"m1​\",{\"1\":{\"206\":1}}],[\"m是边数\",{\"1\":{\"182\":1}}],[\"mlogm\",{\"1\":{\"182\":1}}],[\"mlogn\",{\"1\":{\"172\":1,\"174\":1}}],[\"m表示边数\",{\"1\":{\"175\":1,\"181\":1,\"183\":1}}],[\"m代表边数\",{\"1\":{\"166\":1}}],[\"multimap\",{\"1\":{\"245\":3}}],[\"multiset\",{\"1\":{\"245\":3}}],[\"mul\",{\"1\":{\"149\":2,\"212\":2}}],[\"m​\",{\"1\":{\"124\":1}}],[\"method\",{\"1\":{\"290\":2}}],[\"merge\",{\"1\":{\"138\":3,\"162\":1,\"255\":2}}],[\"memcpy\",{\"1\":{\"110\":1}}],[\"memset\",{\"1\":{\"73\":1,\"130\":1,\"131\":1,\"166\":1,\"173\":2,\"174\":1,\"175\":1,\"176\":1,\"181\":2,\"183\":1,\"184\":1}}],[\"mex运算\",{\"0\":{\"219\":1}}],[\"mex\",{\"1\":{\"33\":2,\"219\":1,\"220\":1}}],[\"mex函数\",{\"0\":{\"33\":1}}],[\"m⩽100\",{\"1\":{\"71\":1}}],[\"m行\",{\"1\":{\"65\":1}}],[\"m\",{\"1\":{\"65\":4,\"66\":6,\"71\":4,\"73\":5,\"100\":2,\"102\":5,\"106\":3,\"115\":7,\"116\":7,\"117\":17,\"118\":9,\"122\":5,\"124\":8,\"125\":5,\"130\":9,\"131\":2,\"166\":1,\"167\":2,\"170\":1,\"172\":4,\"173\":5,\"174\":1,\"175\":4,\"176\":6,\"177\":1,\"181\":6,\"182\":5,\"183\":5,\"184\":3,\"210\":8,\"211\":4,\"214\":6,\"234\":8,\"246\":2}}],[\"mirrors\",{\"1\":{\"273\":1}}],[\"mi​\",{\"1\":{\"206\":1}}],[\"mid\",{\"1\":{\"121\":4,\"138\":7,\"141\":9,\"142\":13,\"143\":5,\"145\":4,\"161\":4}}],[\"middleware\",{\"0\":{\"304\":1},\"1\":{\"15\":1}}],[\"minutes\",{\"1\":{\"290\":1}}],[\"minioinfo\",{\"1\":{\"287\":6}}],[\"minio密码\",{\"1\":{\"287\":1}}],[\"minio用户名\",{\"1\":{\"287\":1}}],[\"minioclient\",{\"0\":{\"288\":1},\"1\":{\"287\":8,\"289\":6,\"290\":9}}],[\"minio<\",{\"1\":{\"286\":1}}],[\"minio官网\",{\"1\":{\"280\":1}}],[\"minioadmin\",{\"1\":{\"274\":1,\"276\":1,\"287\":2}}],[\"minio\",{\"0\":{\"273\":1,\"280\":1,\"285\":1},\"1\":{\"273\":3,\"274\":24,\"275\":8,\"276\":10,\"277\":8,\"280\":2,\"281\":4,\"282\":22,\"287\":10,\"290\":3},\"2\":{\"279\":1,\"284\":1,\"292\":1}}],[\"minvalue\",{\"1\":{\"39\":2}}],[\"minpos\",{\"1\":{\"39\":2}}],[\"min\",{\"0\":{\"39\":1,\"303\":1},\"1\":{\"39\":5,\"55\":1,\"124\":3,\"125\":6,\"126\":2,\"131\":2,\"173\":4,\"175\":1,\"179\":1,\"181\":2,\"219\":1,\"252\":1,\"276\":1,\"280\":1}}],[\"mx\",{\"1\":{\"33\":3,\"123\":4}}],[\"mode=\",{\"1\":{\"277\":1}}],[\"modm\",{\"1\":{\"210\":1}}],[\"modp\",{\"1\":{\"210\":1,\"211\":1}}],[\"modai​\",{\"1\":{\"206\":1}}],[\"mod\",{\"1\":{\"30\":5,\"46\":2,\"127\":4,\"198\":3,\"203\":1,\"206\":2,\"209\":1,\"210\":5,\"211\":1,\"244\":1}}],[\"movq\",{\"1\":{\"29\":1}}],[\"match\",{\"1\":{\"184\":4}}],[\"map\",{\"0\":{\"293\":1},\"1\":{\"245\":3}}],[\"map<int\",{\"1\":{\"191\":2,\"198\":1}}],[\"map<string\",{\"1\":{\"77\":1}}],[\"map>\",{\"1\":{\"77\":1,\"198\":1}}],[\"makebucketargs\",{\"1\":{\"289\":1}}],[\"makebucket\",{\"1\":{\"289\":2}}],[\"make\",{\"1\":{\"40\":1}}],[\"malloc\",{\"1\":{\"29\":1}}],[\"main\",{\"1\":{\"29\":1,\"47\":1,\"51\":1,\"55\":1,\"65\":1,\"66\":1,\"73\":1,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"130\":1,\"131\":1,\"133\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"166\":1,\"173\":1,\"181\":1,\"198\":1,\"206\":1,\"211\":1,\"214\":1,\"216\":1,\"234\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"maxslidingwindow\",{\"1\":{\"269\":1}}],[\"maxvalue\",{\"1\":{\"39\":2}}],[\"maxpos\",{\"1\":{\"39\":2}}],[\"maximum\",{\"1\":{\"35\":1}}],[\"max\",{\"0\":{\"39\":1},\"1\":{\"26\":2,\"27\":1,\"39\":6,\"55\":1,\"115\":2,\"116\":2,\"117\":4,\"118\":2,\"120\":3,\"121\":4,\"122\":4,\"123\":3,\"133\":2,\"160\":1,\"162\":1,\"194\":1,\"199\":1,\"246\":1,\"254\":1,\"255\":1}}],[\"会话也不会被阻塞\",{\"1\":{\"274\":1}}],[\"会随着其他数值而受到影响\",{\"1\":{\"175\":1}}],[\"会导致\",{\"1\":{\"158\":1}}],[\"会对应这个数列的连续一段\",{\"1\":{\"144\":1}}],[\"会覆盖掉\",{\"1\":{\"37\":1}}],[\"会爆掉\",{\"1\":{\"26\":1}}],[\"会过滤掉空字符\",{\"1\":{\"26\":1}}],[\"时为偶数\",{\"1\":{\"203\":1}}],[\"时为奇数\",{\"1\":{\"203\":1}}],[\"时才能表示已经将所有点加入到集合中\",{\"1\":{\"182\":1}}],[\"时间复杂度o\",{\"1\":{\"179\":1}}],[\"时间复杂度是\",{\"1\":{\"173\":1,\"174\":1,\"182\":1,\"184\":1,\"245\":1}}],[\"时间复杂度一般为\",{\"1\":{\"172\":1}}],[\"时间复杂度\",{\"1\":{\"167\":1,\"170\":1,\"175\":1,\"176\":1,\"177\":1,\"183\":1,\"245\":1}}],[\"时间复杂度为\",{\"1\":{\"144\":1,\"172\":3,\"181\":1,\"182\":2,\"189\":1,\"190\":1,\"193\":1,\"195\":1,\"203\":1,\"207\":1}}],[\"时需要加\",{\"1\":{\"142\":1}}],[\"时不需要加\",{\"1\":{\"141\":1}}],[\"时用来初始化\",{\"1\":{\"126\":1}}],[\"时\",{\"1\":{\"26\":1,\"46\":1,\"66\":2,\"141\":1,\"142\":1,\"158\":1,\"195\":2,\"202\":1,\"205\":2}}],[\"310\",{\"1\":{\"126\":1}}],[\"3010\",{\"1\":{\"123\":1}}],[\"3000\",{\"1\":{\"123\":1}}],[\"30\",{\"1\":{\"102\":1}}],[\"3×3\",{\"1\":{\"75\":3}}],[\"3s\",{\"1\":{\"50\":1}}],[\"3\",{\"0\":{\"27\":1,\"63\":1,\"117\":1,\"122\":1,\"126\":1,\"139\":1,\"140\":1,\"143\":1,\"144\":2,\"145\":1,\"149\":1,\"154\":1,\"159\":1,\"170\":1,\"175\":1,\"192\":1,\"193\":1,\"194\":1,\"195\":2,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"211\":1,\"218\":1,\"231\":1,\"232\":1,\"233\":1,\"239\":1,\"244\":1,\"253\":1},\"1\":{\"26\":1,\"39\":1,\"40\":2,\"45\":1,\"49\":3,\"50\":2,\"51\":4,\"59\":1,\"61\":1,\"65\":5,\"66\":2,\"75\":9,\"77\":6,\"83\":7,\"92\":5,\"96\":7,\"100\":9,\"120\":1,\"123\":2,\"145\":1,\"147\":1,\"148\":1,\"158\":3,\"159\":1,\"166\":1,\"175\":1,\"176\":1,\"182\":1,\"193\":2,\"207\":1,\"212\":1,\"217\":1,\"226\":1,\"240\":2,\"245\":1,\"246\":1,\"290\":1}}],[\"对象是单例的\",{\"1\":{\"287\":1}}],[\"对象即可实现对\",{\"1\":{\"287\":1}}],[\"对象\",{\"1\":{\"287\":2}}],[\"对象存储可以作为主存储层\",{\"1\":{\"282\":1}}],[\"对象存储的读\",{\"1\":{\"282\":1}}],[\"对象存储\",{\"1\":{\"281\":1}}],[\"对用户而言\",{\"1\":{\"287\":2}}],[\"对每个节点的进行相同的递归处理\",{\"1\":{\"263\":1}}],[\"对每辆车进行枚举\",{\"1\":{\"106\":1}}],[\"对自定义的结构体\",{\"1\":{\"246\":1}}],[\"对两个迭代器\",{\"1\":{\"246\":1}}],[\"对两个子序列分别设置个指针\",{\"1\":{\"138\":1}}],[\"对字符串也适用\",{\"1\":{\"245\":1}}],[\"对阶乘分解质因数之后\",{\"1\":{\"212\":1}}],[\"对朴素筛法的优化\",{\"1\":{\"193\":1}}],[\"对无符号数\",{\"1\":{\"157\":1}}],[\"对a提前判断一下\",{\"1\":{\"110\":1}}],[\"对应下标的数一一比较\",{\"1\":{\"96\":1,\"100\":1}}],[\"对于个人来说\",{\"1\":{\"281\":1}}],[\"对于企业来说\",{\"1\":{\"281\":1}}],[\"对于\",{\"1\":{\"234\":1}}],[\"对于先手来说是一个必败状态\",{\"1\":{\"216\":1}}],[\"对于先手来说是一个必胜状态\",{\"1\":{\"216\":1}}],[\"对于大多数情况\",{\"1\":{\"199\":1}}],[\"对于所有的点都\",{\"1\":{\"175\":1}}],[\"对于一个序列\",{\"1\":{\"160\":1}}],[\"对于一般的树可能出现极端不平衡的情况\",{\"1\":{\"66\":1}}],[\"对于每个\",{\"1\":{\"234\":2}}],[\"对于每个节点x\",{\"1\":{\"220\":1}}],[\"对于每个点k\",{\"1\":{\"166\":1}}],[\"对于每两个式子\",{\"1\":{\"206\":1}}],[\"对于每次询问\",{\"1\":{\"124\":1}}],[\"对于每一个\",{\"1\":{\"66\":1}}],[\"对于两个序列\",{\"1\":{\"160\":1}}],[\"对于两个数列\",{\"1\":{\"123\":1}}],[\"对于两个不同的行\",{\"1\":{\"96\":1,\"100\":1}}],[\"对于没有选任何数的方案\",{\"1\":{\"92\":1}}],[\"对于询问\",{\"1\":{\"65\":1}}],[\"对于我们的关于亲戚关系的提问\",{\"1\":{\"65\":1}}],[\"对\",{\"1\":{\"26\":1,\"287\":1}}],[\"的签名url\",{\"1\":{\"290\":1}}],[\"的状态\",{\"1\":{\"290\":1}}],[\"的常用\",{\"0\":{\"288\":1}}],[\"的基本对象\",{\"1\":{\"287\":1}}],[\"的逻辑空间\",{\"1\":{\"287\":1}}],[\"的存储机制使用纠删码\",{\"1\":{\"282\":1}}],[\"的产品\",{\"1\":{\"282\":1}}],[\"的编排\",{\"1\":{\"282\":1}}],[\"的替代品\",{\"1\":{\"282\":1}}],[\"的滑动窗口从数组的最左侧移动到数组的最右侧\",{\"1\":{\"268\":1}}],[\"的用法和\",{\"1\":{\"246\":1}}],[\"的第三个参数传入一个元素\",{\"1\":{\"246\":1}}],[\"的第一个元素\",{\"1\":{\"142\":1}}],[\"的减法\",{\"1\":{\"246\":1}}],[\"的哈希值\",{\"1\":{\"244\":1}}],[\"的经验值是\",{\"1\":{\"244\":1}}],[\"的右儿子为\",{\"1\":{\"240\":1}}],[\"的左儿子为\",{\"1\":{\"240\":1}}],[\"的偏移量\",{\"1\":{\"239\":1}}],[\"的距离\",{\"1\":{\"239\":1}}],[\"的前提下\",{\"1\":{\"234\":1}}],[\"的sg函数值构成的集合再执行mex\",{\"1\":{\"220\":1}}],[\"的每一个集合状态\",{\"1\":{\"214\":1}}],[\"的集合\",{\"1\":{\"214\":1}}],[\"的乘法逆元为\",{\"1\":{\"210\":1}}],[\"的乘法逆元\",{\"1\":{\"210\":1}}],[\"的模\",{\"1\":{\"210\":1}}],[\"的逆元不存在\",{\"1\":{\"210\":1}}],[\"的逆元\",{\"1\":{\"210\":1}}],[\"的解\",{\"1\":{\"205\":1}}],[\"的欧拉函数即为\",{\"1\":{\"202\":1}}],[\"的质因子\",{\"1\":{\"195\":1,\"202\":1}}],[\"的表中划去\",{\"1\":{\"194\":1}}],[\"的表中筛得素数的同时\",{\"1\":{\"194\":1}}],[\"的素数表\",{\"1\":{\"194\":1}}],[\"的约数\",{\"1\":{\"193\":1}}],[\"的唯一质因子\",{\"1\":{\"190\":1}}],[\"的因子\",{\"1\":{\"190\":3}}],[\"的更新方式为\",{\"1\":{\"175\":1}}],[\"的点\",{\"1\":{\"170\":1}}],[\"的个数\",{\"1\":{\"159\":2}}],[\"的指定位\",{\"1\":{\"158\":1}}],[\"的低\",{\"1\":{\"158\":6}}],[\"的商和余数\",{\"1\":{\"150\":1}}],[\"的值为\",{\"1\":{\"158\":1}}],[\"的值\",{\"1\":{\"149\":1,\"211\":1,\"212\":1}}],[\"的问题\",{\"1\":{\"143\":1}}],[\"的最大整数\",{\"1\":{\"246\":1}}],[\"的最大值\",{\"1\":{\"234\":1}}],[\"的最小整数的下标\",{\"1\":{\"246\":1}}],[\"的最小质因子也就是\",{\"1\":{\"195\":1}}],[\"的最小质因子就是\",{\"1\":{\"195\":1}}],[\"的最小质因子\",{\"1\":{\"195\":2,\"202\":3}}],[\"的最后一位\",{\"1\":{\"159\":1}}],[\"的最后一个元素\",{\"1\":{\"142\":1}}],[\"的最低位为\",{\"1\":{\"158\":1}}],[\"的最短hamilton路径\",{\"1\":{\"131\":1}}],[\"的所有因数\",{\"1\":{\"190\":1}}],[\"的所有出边\",{\"1\":{\"176\":1}}],[\"的所有路径\",{\"1\":{\"131\":1}}],[\"的所有方案\",{\"1\":{\"130\":1}}],[\"的棋盘可以摆放不同的\",{\"1\":{\"130\":1}}],[\"的树里各个数字有多少个\",{\"1\":{\"128\":1}}],[\"的各位数字有多少个\",{\"1\":{\"128\":2}}],[\"的出现次数\",{\"1\":{\"128\":1}}],[\"的方案数\",{\"1\":{\"127\":1}}],[\"的一种划分\",{\"1\":{\"127\":1}}],[\"的某个位置插入某个字符\",{\"1\":{\"125\":1}}],[\"的子序列的字符串长度最长是多少\",{\"1\":{\"122\":1}}],[\"的子序列又是\",{\"1\":{\"122\":1}}],[\"的字符串以及\",{\"1\":{\"124\":1}}],[\"的字符串\",{\"1\":{\"122\":1}}],[\"的背包\",{\"1\":{\"118\":1}}],[\"的写法\",{\"1\":{\"117\":1}}],[\"的形式存储\",{\"1\":{\"174\":1}}],[\"的形式\",{\"1\":{\"109\":1}}],[\"的初始网格描绘出来\",{\"1\":{\"75\":1}}],[\"的网格中\",{\"1\":{\"75\":2}}],[\"的二进制表示\",{\"1\":{\"159\":1}}],[\"的二进制表示中第\",{\"1\":{\"159\":1,\"203\":1}}],[\"的二进制表示下的每一位是不是\",{\"1\":{\"36\":1}}],[\"的二进制位右移\",{\"1\":{\"158\":1}}],[\"的二进制位\",{\"1\":{\"158\":1}}],[\"的二维整数数组\",{\"1\":{\"71\":1}}],[\"的操作方式\",{\"1\":{\"125\":1}}],[\"的操作\",{\"1\":{\"66\":1,\"287\":1}}],[\"的高度只存在于平衡二叉树\",{\"1\":{\"66\":1}}],[\"的主要功能就是从某个节点向上遍历到根节点\",{\"1\":{\"66\":1}}],[\"的不平衡状况\",{\"1\":{\"63\":1}}],[\"的正方形\",{\"1\":{\"54\":1}}],[\"的正余数\",{\"0\":{\"30\":1}}],[\"的数整除\",{\"1\":{\"189\":1}}],[\"的数对的个数\",{\"1\":{\"144\":1}}],[\"的数组\",{\"1\":{\"49\":1}}],[\"的数列\",{\"1\":{\"45\":1,\"159\":1}}],[\"的组合有多少种\",{\"1\":{\"46\":1}}],[\"的差值必然是\",{\"1\":{\"46\":1}}],[\"的余数相等\",{\"1\":{\"46\":1}}],[\"的和\",{\"1\":{\"46\":1}}],[\"的和是k的倍数\",{\"1\":{\"46\":1}}],[\"的和是\",{\"1\":{\"46\":1}}],[\"的目的是可以在\",{\"1\":{\"38\":1}}],[\"的元素\",{\"1\":{\"246\":1}}],[\"的元素的位置的迭代器\",{\"1\":{\"246\":1}}],[\"的元素到\",{\"1\":{\"37\":1}}],[\"的元素赋值到当前的\",{\"1\":{\"37\":1}}],[\"的倍数时\",{\"1\":{\"210\":1}}],[\"的倍数的个数\",{\"1\":{\"46\":1}}],[\"的倍数\",{\"1\":{\"31\":1,\"45\":1,\"46\":2,\"205\":1,\"210\":1}}],[\"的成员函数c\",{\"1\":{\"26\":1}}],[\"的\",{\"1\":{\"26\":2,\"61\":1,\"109\":1}}],[\"的时候\",{\"1\":{\"26\":1}}],[\"的长度均不超过\",{\"1\":{\"123\":1}}],[\"的长度\",{\"1\":{\"26\":1,\"123\":1}}],[\"的长度时会被截断\",{\"1\":{\"26\":1}}],[\"的真实长度\",{\"1\":{\"26\":1}}],[\"获取字符串长度\",{\"1\":{\"26\":1}}],[\"获取\",{\"1\":{\"26\":1}}],[\"中配置\",{\"1\":{\"287\":1}}],[\"中文文档地址\",{\"1\":{\"282\":1}}],[\"中文官网\",{\"1\":{\"280\":1}}],[\"中序遍历\",{\"1\":{\"262\":1}}],[\"中序\",{\"1\":{\"262\":1}}],[\"中查找小于等于\",{\"1\":{\"246\":1}}],[\"中查找大于等于\",{\"1\":{\"246\":1}}],[\"中能整除\",{\"1\":{\"214\":1}}],[\"中能被\",{\"1\":{\"214\":1}}],[\"中至少一个数整除的整数有多少个\",{\"1\":{\"214\":1}}],[\"中p的次数是\",{\"1\":{\"212\":1}}],[\"中国剩余定理\",{\"0\":{\"206\":1}}],[\"中计算过了\",{\"1\":{\"202\":1}}],[\"中与\",{\"1\":{\"201\":1}}],[\"中最多只包含一个大于\",{\"1\":{\"190\":1}}],[\"中找到\",{\"1\":{\"144\":2}}],[\"中的次数\",{\"1\":{\"212\":1}}],[\"中的所有质数\",{\"1\":{\"193\":1}}],[\"中的每个数加上c\",{\"1\":{\"154\":1}}],[\"中的\",{\"1\":{\"142\":2,\"287\":1}}],[\"中的某个字符替换为另一个字符\",{\"1\":{\"125\":1}}],[\"中的某个字符删除\",{\"1\":{\"125\":1}}],[\"中\",{\"1\":{\"138\":1,\"140\":1,\"269\":1}}],[\"中使用当前类的成员函数和成员变量\",{\"1\":{\"38\":1}}],[\"中含有空字符\",{\"1\":{\"26\":1}}],[\"中间件解决了异构网络环境下软件互联和互操作等共性问题\",{\"1\":{\"15\":1}}],[\"中间件与操作系统和数据库共同构成基础软件三大支柱\",{\"1\":{\"15\":1}}],[\"中间件不仅仅实现互连\",{\"1\":{\"15\":1}}],[\"中间件是一类软件统称\",{\"1\":{\"15\":1}}],[\"中间件在客户服务器的操作系统\",{\"1\":{\"15\":1}}],[\"中间件\",{\"0\":{\"15\":1},\"1\":{\"15\":1},\"2\":{\"278\":1,\"283\":1,\"291\":1}}],[\"当处理的节点是空节点时\",{\"1\":{\"263\":1}}],[\"当且仅当该局面对应节点的sg函数值等于0\",{\"1\":{\"221\":1}}],[\"当且仅当该局面对应节点的sg函数值大于0\",{\"1\":{\"221\":1}}],[\"当且仅当\",{\"1\":{\"216\":1}}],[\"当我们需要求出组合数的真实值\",{\"1\":{\"212\":1}}],[\"当我们将区间\",{\"1\":{\"141\":1,\"142\":1}}],[\"当模数\",{\"1\":{\"210\":1}}],[\"当有\",{\"1\":{\"195\":1}}],[\"当中有\",{\"1\":{\"193\":1}}],[\"当前节点相当于左节点\",{\"1\":{\"264\":1}}],[\"当前节点选\",{\"1\":{\"133\":1}}],[\"当前节点不选\",{\"1\":{\"133\":1}}],[\"当前位置部分\",{\"1\":{\"128\":1}}],[\"当前的值\",{\"1\":{\"110\":1}}],[\"当前加入的数字是几\",{\"1\":{\"110\":1}}],[\"当前前缀和\",{\"1\":{\"46\":1}}],[\"当然\",{\"1\":{\"104\":1,\"246\":1,\"281\":1}}],[\"当达到了祖先位置\",{\"1\":{\"62\":1}}],[\"当\",{\"1\":{\"26\":1,\"66\":2,\"140\":1,\"158\":1,\"193\":1,\"195\":1,\"205\":2,\"210\":2}}],[\"creationdate\",{\"1\":{\"289\":1}}],[\"credentials\",{\"1\":{\"287\":1}}],[\"cmd\",{\"1\":{\"276\":1,\"277\":1}}],[\"cmp\",{\"1\":{\"148\":2,\"246\":2}}],[\"cli\",{\"1\":{\"282\":1}}],[\"client\",{\"1\":{\"282\":1}}],[\"class\",{\"1\":{\"269\":1,\"287\":2}}],[\"clear\",{\"1\":{\"130\":1,\"245\":4}}],[\"cba​=\",{\"1\":{\"211\":1}}],[\"catch\",{\"1\":{\"290\":1}}],[\"cat\",{\"1\":{\"213\":1}}],[\"cab​\",{\"1\":{\"212\":1}}],[\"cab​≡ca\",{\"1\":{\"211\":1}}],[\"cab​=b\",{\"1\":{\"210\":1}}],[\"cab​=ca−1b−1​+ca−1b​\",{\"1\":{\"209\":1}}],[\"cab​modp\",{\"1\":{\"211\":1}}],[\"cab​mod\",{\"1\":{\"209\":1}}],[\"capture\",{\"1\":{\"38\":2}}],[\"capacity\",{\"1\":{\"26\":1}}],[\"ck\",{\"1\":{\"198\":1}}],[\"c2\",{\"1\":{\"198\":1}}],[\"c2​\",{\"1\":{\"104\":1}}],[\"c1\",{\"1\":{\"198\":1}}],[\"c1​\",{\"1\":{\"104\":1}}],[\"c表示当前点的颜色\",{\"1\":{\"183\":1}}],[\"chmod\",{\"1\":{\"274\":1}}],[\"checksum\",{\"1\":{\"282\":1}}],[\"check\",{\"1\":{\"109\":1,\"110\":2,\"128\":1,\"142\":2,\"143\":1,\"145\":2,\"160\":1,\"183\":1,\"230\":1,\"233\":2}}],[\"char\",{\"1\":{\"26\":2,\"29\":1,\"34\":2,\"77\":1,\"122\":1,\"124\":4,\"125\":1,\"234\":1,\"235\":2}}],[\"ci​\",{\"1\":{\"104\":1}}],[\"cin>>n\",{\"1\":{\"131\":1}}],[\"cin\",{\"1\":{\"47\":2,\"51\":2,\"55\":2,\"65\":3,\"66\":2,\"73\":2,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":2,\"110\":1,\"115\":2,\"116\":2,\"117\":6,\"118\":6,\"120\":2,\"121\":6,\"122\":1,\"123\":3,\"124\":3,\"125\":2,\"126\":2,\"127\":1,\"128\":1,\"130\":1,\"131\":1,\"133\":1,\"144\":2,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"166\":1,\"173\":2,\"181\":2,\"198\":2,\"211\":2,\"214\":2,\"216\":2,\"234\":2,\"251\":2,\"252\":2,\"253\":2,\"254\":3,\"255\":2}}],[\"cn\",{\"1\":{\"273\":1,\"274\":1,\"280\":1,\"282\":1}}],[\"cn=ca+b\",{\"1\":{\"109\":1}}],[\"cn​\",{\"1\":{\"104\":1}}],[\"cnt记录素数个数\",{\"1\":{\"193\":1}}],[\"cnt++\",{\"1\":{\"51\":1,\"117\":2,\"130\":1,\"182\":1,\"193\":1,\"195\":1}}],[\"cnt\",{\"1\":{\"38\":5,\"46\":5,\"47\":4,\"51\":2,\"117\":6,\"128\":3,\"130\":4,\"177\":5,\"182\":3,\"193\":1,\"195\":1,\"202\":2,\"212\":4,\"235\":4}}],[\"c++代码模板\",{\"1\":{\"141\":1,\"142\":1}}],[\"c++\",{\"0\":{\"245\":1},\"1\":{\"37\":1}}],[\"c中的\",{\"1\":{\"32\":1}}],[\"cos\",{\"1\":{\"281\":1}}],[\"component\",{\"1\":{\"287\":1}}],[\"com\",{\"1\":{\"273\":2,\"277\":1,\"282\":3}}],[\"color\",{\"1\":{\"183\":7}}],[\"config\",{\"1\":{\"287\":1,\"289\":1}}],[\"configuration\",{\"1\":{\"287\":1}}],[\"configurationproperties\",{\"1\":{\"287\":1}}],[\"console\",{\"1\":{\"274\":3,\"275\":1,\"276\":1}}],[\"const\",{\"1\":{\"26\":3,\"34\":1,\"35\":1,\"47\":1,\"51\":1,\"55\":1,\"65\":1,\"66\":1,\"73\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"130\":1,\"131\":1,\"144\":1,\"145\":1,\"147\":1,\"159\":1,\"173\":1,\"181\":1,\"182\":3,\"198\":1,\"207\":1,\"214\":1,\"234\":1,\"246\":2,\"251\":3,\"252\":3,\"253\":3,\"254\":3,\"255\":1}}],[\"continue\",{\"1\":{\"126\":1,\"174\":1,\"193\":1,\"207\":1}}],[\"count\",{\"1\":{\"77\":1,\"245\":2}}],[\"cout\",{\"1\":{\"26\":1,\"32\":1,\"34\":3,\"47\":1,\"51\":2,\"55\":1,\"66\":2,\"73\":1,\"77\":1,\"94\":2,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":2,\"116\":2,\"117\":4,\"118\":2,\"120\":2,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":2,\"130\":1,\"131\":1,\"144\":1,\"150\":2,\"159\":2,\"173\":1,\"190\":3,\"198\":1,\"211\":1,\"214\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"code\",{\"1\":{\"29\":1,\"282\":1}}],[\"c\",{\"1\":{\"26\":2,\"28\":2,\"34\":2,\"40\":1,\"65\":5,\"77\":3,\"106\":8,\"109\":6,\"110\":10,\"144\":8,\"147\":9,\"148\":14,\"149\":11,\"150\":12,\"154\":2,\"155\":4,\"166\":4,\"173\":5,\"174\":2,\"176\":2,\"181\":3,\"182\":1,\"183\":4,\"193\":1,\"207\":13,\"209\":5,\"211\":6,\"212\":5,\"213\":1,\"245\":1}}],[\"throw\",{\"1\":{\"290\":1}}],[\"throws\",{\"1\":{\"289\":4,\"290\":6}}],[\"this\",{\"1\":{\"38\":3}}],[\"test10\",{\"1\":{\"290\":1}}],[\"test2\",{\"1\":{\"290\":1}}],[\"test\",{\"1\":{\"290\":5}}],[\"test09\",{\"1\":{\"290\":1}}],[\"test08\",{\"1\":{\"290\":1}}],[\"test07\",{\"1\":{\"290\":1}}],[\"test06\",{\"1\":{\"290\":1}}],[\"test05\",{\"1\":{\"290\":1}}],[\"test04\",{\"1\":{\"289\":1}}],[\"test03\",{\"1\":{\"289\":1}}],[\"test02\",{\"1\":{\"289\":1}}],[\"test01\",{\"1\":{\"289\":1}}],[\"tensorflow\",{\"1\":{\"282\":1}}],[\"template\",{\"0\":{\"299\":1}}],[\"temp\",{\"1\":{\"138\":6}}],[\"timeunit\",{\"1\":{\"290\":1}}],[\"time\",{\"1\":{\"277\":1}}],[\"tips\",{\"1\":{\"184\":1}}],[\"t表示该元素与它的左\",{\"1\":{\"240\":1}}],[\"try\",{\"1\":{\"290\":1}}],[\"transferto\",{\"1\":{\"290\":1}}],[\"trie\",{\"1\":{\"235\":1}}],[\"trie树存储形式\",{\"1\":{\"235\":1}}],[\"trie树\",{\"0\":{\"235\":1}}],[\"true\",{\"1\":{\"85\":1,\"98\":1,\"110\":4,\"128\":1,\"130\":1,\"148\":1,\"168\":1,\"169\":2,\"173\":1,\"174\":1,\"176\":2,\"177\":3,\"181\":1,\"183\":2,\"184\":2,\"189\":1,\"193\":1,\"194\":4,\"195\":2,\"202\":1,\"203\":2,\"212\":1,\"242\":1,\"254\":1}}],[\"t为当前这种状态的集合数量\",{\"1\":{\"214\":1}}],[\"t为余数\",{\"1\":{\"150\":1}}],[\"tt表示队尾\",{\"1\":{\"232\":1}}],[\"tt表示栈顶\",{\"1\":{\"229\":1}}],[\"tt\",{\"1\":{\"170\":3,\"229\":4,\"230\":4,\"232\":3,\"233\":5}}],[\"t再除以10\",{\"1\":{\"147\":1}}],[\"ture\",{\"1\":{\"181\":1}}],[\"tu\",{\"1\":{\"40\":3}}],[\"tuple<int\",{\"1\":{\"40\":2}}],[\"tuple\",{\"0\":{\"40\":1},\"1\":{\"40\":2}}],[\"typedef\",{\"1\":{\"130\":1,\"198\":1,\"244\":1}}],[\"type\",{\"1\":{\"35\":2}}],[\"t的最大值\",{\"1\":{\"35\":1}}],[\"tool\",{\"0\":{\"300\":1}}],[\"top\",{\"1\":{\"174\":1,\"245\":2,\"253\":1,\"269\":3}}],[\"topsort\",{\"1\":{\"170\":1}}],[\"tot\",{\"1\":{\"144\":3}}],[\"to\",{\"1\":{\"34\":2}}],[\"t\",{\"1\":{\"26\":3,\"35\":1,\"73\":5,\"77\":11,\"128\":4,\"147\":7,\"148\":11,\"149\":5,\"150\":9,\"169\":2,\"170\":2,\"173\":7,\"174\":3,\"176\":9,\"177\":6,\"181\":16,\"198\":4,\"202\":4,\"207\":5,\"212\":7,\"214\":8,\"240\":8,\"253\":4}}],[\"返回存储桶的列表\",{\"1\":{\"289\":1}}],[\"返回布尔值\",{\"1\":{\"289\":1}}],[\"返回指向第一个大于等于\",{\"1\":{\"246\":1}}],[\"返回去重\",{\"1\":{\"246\":1}}],[\"返回有多少个1\",{\"1\":{\"245\":1}}],[\"返回大于x的最小的数的迭代器\",{\"1\":{\"245\":1}}],[\"返回大于等于x的最小的数的迭代器\",{\"1\":{\"245\":1}}],[\"返回某一个数的个数\",{\"1\":{\"245\":1}}],[\"返回前驱和后继\",{\"1\":{\"245\":1}}],[\"返回栈顶元素\",{\"1\":{\"245\":1}}],[\"返回堆顶元素\",{\"1\":{\"245\":1}}],[\"返回队尾元素\",{\"1\":{\"245\":1}}],[\"返回队头元素\",{\"1\":{\"245\":1}}],[\"返回字符串所在字符数组的起始地址\",{\"1\":{\"245\":1}}],[\"返回字符串长度\",{\"1\":{\"245\":1}}],[\"返回子串\",{\"1\":{\"245\":1}}],[\"返回是否为空\",{\"1\":{\"245\":1}}],[\"返回元素个数\",{\"1\":{\"245\":1}}],[\"返回x应该插入的位置\",{\"1\":{\"243\":1}}],[\"返回x的下标\",{\"1\":{\"243\":1}}],[\"返回x的祖宗节点\",{\"1\":{\"237\":1,\"238\":1,\"239\":1}}],[\"返回a\",{\"1\":{\"148\":1}}],[\"返回true\",{\"1\":{\"148\":2}}],[\"返回父亲节点\",{\"1\":{\"62\":1}}],[\"返回按照查找规则找到的第一个字符或者子串的位置\",{\"1\":{\"35\":1}}],[\"返回c风格字符串长度\",{\"1\":{\"26\":1}}],[\"返回\",{\"1\":{\"26\":3,\"35\":1,\"39\":2,\"159\":1,\"262\":1,\"268\":1}}],[\"是存储到\",{\"1\":{\"287\":1}}],[\"是存储\",{\"1\":{\"287\":1}}],[\"是第一个支持\",{\"1\":{\"282\":1}}],[\"是全世界内大家都认可的标准\",{\"1\":{\"282\":1}}],[\"是在全球范围内达到共识的对象存储的协议\",{\"1\":{\"282\":1}}],[\"是越界的\",{\"1\":{\"246\":1}}],[\"是堆顶\",{\"1\":{\"240\":1}}],[\"是m个有向图游戏\",{\"1\":{\"221\":1}}],[\"是质数\",{\"1\":{\"211\":1}}],[\"是增广矩阵\",{\"1\":{\"207\":1}}],[\"是满足条件的第一个数\",{\"1\":{\"195\":1}}],[\"是bellman\",{\"1\":{\"172\":1}}],[\"是同一个级别的类型\",{\"1\":{\"172\":1}}],[\"是不是偶数\",{\"1\":{\"158\":1}}],[\"是的输出\",{\"1\":{\"66\":1}}],[\"是否走到末尾\",{\"1\":{\"234\":1}}],[\"是否能到达\",{\"1\":{\"175\":1}}],[\"是否记下ans\",{\"1\":{\"143\":1}}],[\"是否满足条件\",{\"1\":{\"109\":1}}],[\"是否成立\",{\"1\":{\"109\":1}}],[\"是否在同一集合内\",{\"1\":{\"66\":1}}],[\"是否为亲戚\",{\"1\":{\"65\":1}}],[\"是亲戚\",{\"1\":{\"65\":3}}],[\"是\",{\"1\":{\"45\":1,\"202\":1,\"276\":1,\"281\":1}}],[\"是泛化的\",{\"1\":{\"40\":1}}],[\"是返回值类型\",{\"1\":{\"38\":1}}],[\"是函数选项\",{\"1\":{\"38\":1}}],[\"是参数表\",{\"1\":{\"38\":1}}],[\"是捕获列表\",{\"1\":{\"38\":1}}],[\"是整数\",{\"1\":{\"31\":1,\"205\":1}}],[\"是c语言标准库中的函数\",{\"1\":{\"26\":1}}],[\"是一个高性能的分布式对象存储系统\",{\"1\":{\"280\":1}}],[\"是一个质数\",{\"1\":{\"210\":1}}],[\"是一个边的集合\",{\"1\":{\"184\":1}}],[\"是一个确定的值\",{\"1\":{\"175\":1}}],[\"是一个二进制数\",{\"1\":{\"130\":1}}],[\"是一类能够为一种或多种应用程序合作互通\",{\"1\":{\"15\":1}}],[\"是一种恢复丢失和损坏数据的数学算法\",{\"1\":{\"282\":1}}],[\"是一种数据存储架构\",{\"1\":{\"281\":1}}],[\"是一种能够高效存储和查找字符串集合的数据结构\",{\"1\":{\"235\":1}}],[\"是一种应用于分布式系统的基础软件\",{\"1\":{\"15\":1}}],[\"是一种独立的系统软件或服务程序\",{\"1\":{\"15\":1}}],[\"是一种在系统软件和用户应用软件之间连接的软件\",{\"1\":{\"15\":1}}],[\"sdk\",{\"1\":{\"282\":7}}],[\"s3\",{\"1\":{\"280\":1,\"282\":5,\"289\":2}}],[\"shell\",{\"1\":{\"274\":1}}],[\"shtml\",{\"1\":{\"273\":1}}],[\"shuffle\",{\"1\":{\"246\":1}}],[\"solomon\",{\"1\":{\"282\":1}}],[\"solution\",{\"1\":{\"269\":1}}],[\"son\",{\"1\":{\"235\":7}}],[\"sort\",{\"1\":{\"33\":1,\"106\":1,\"137\":3,\"138\":3,\"144\":1,\"161\":1,\"162\":1,\"182\":1,\"197\":1,\"246\":4,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"s+1\",{\"1\":{\"234\":1}}],[\"s++\",{\"1\":{\"190\":1,\"214\":1}}],[\"s为模式串\",{\"1\":{\"234\":1}}],[\"sg\",{\"1\":{\"220\":5,\"221\":4}}],[\"sg游戏\",{\"0\":{\"220\":1}}],[\"sid\",{\"1\":{\"289\":1}}],[\"si​\",{\"1\":{\"214\":1}}],[\"sizethreshold>\",{\"1\":{\"277\":1}}],[\"sizeof\",{\"1\":{\"73\":1,\"110\":1,\"130\":1,\"131\":1,\"166\":1,\"173\":2,\"174\":1,\"175\":1,\"176\":1,\"181\":2,\"183\":1,\"184\":1}}],[\"size\",{\"1\":{\"26\":9,\"29\":2,\"35\":3,\"66\":15,\"73\":1,\"121\":1,\"128\":3,\"147\":7,\"148\":12,\"149\":5,\"150\":4,\"161\":1,\"169\":1,\"174\":1,\"176\":1,\"177\":1,\"212\":1,\"238\":5,\"240\":9,\"245\":7,\"246\":1,\"253\":1,\"255\":1,\"269\":1,\"277\":1}}],[\"s表示次幂\",{\"1\":{\"190\":1}}],[\"sqrt\",{\"1\":{\"189\":2,\"190\":5}}],[\"sundry\",{\"0\":{\"306\":1}}],[\"substr\",{\"1\":{\"245\":1}}],[\"sub\",{\"1\":{\"148\":3}}],[\"sum\",{\"1\":{\"38\":1,\"46\":1,\"212\":3}}],[\"springboot\",{\"0\":{\"285\":1},\"1\":{\"287\":1}}],[\"sprintf\",{\"1\":{\"34\":3}}],[\"spark\",{\"1\":{\"282\":1}}],[\"spfa求最短路\",{\"1\":{\"176\":1}}],[\"spfa算法判断图中是否存在负环\",{\"0\":{\"177\":1}}],[\"spfa算法\",{\"0\":{\"176\":1}}],[\"spfa\",{\"1\":{\"172\":1,\"176\":1,\"177\":1}}],[\"spj\",{\"1\":{\"92\":1}}],[\"swap\",{\"1\":{\"77\":2,\"128\":1,\"137\":1,\"158\":1,\"207\":1,\"240\":6}}],[\"scanf\",{\"1\":{\"65\":1,\"133\":2,\"166\":2,\"206\":3}}],[\"secretkey\",{\"1\":{\"287\":2}}],[\"second存储节点编号\",{\"1\":{\"174\":1}}],[\"second\",{\"1\":{\"73\":2,\"162\":2,\"174\":1,\"198\":1,\"245\":2,\"255\":2,\"269\":1}}],[\"second>\",{\"1\":{\"40\":1}}],[\"select\",{\"1\":{\"282\":1}}],[\"self\",{\"1\":{\"38\":3}}],[\"service>\",{\"1\":{\"277\":1}}],[\"server<\",{\"1\":{\"277\":2}}],[\"server\",{\"1\":{\"274\":4,\"275\":1,\"276\":2,\"277\":5}}],[\"search\",{\"1\":{\"275\":1}}],[\"setbucketpolicyargs\",{\"1\":{\"289\":1}}],[\"setbucketpolicy\",{\"1\":{\"289\":1}}],[\"set\",{\"1\":{\"245\":5}}],[\"seg\",{\"1\":{\"162\":5}}],[\"segs\",{\"1\":{\"162\":5}}],[\"sscanf\",{\"1\":{\"34\":2}}],[\"sscnaf\",{\"1\":{\"34\":1}}],[\"snprintf\",{\"1\":{\"34\":1}}],[\"system\",{\"1\":{\"32\":1,\"289\":3,\"290\":6}}],[\"storage\",{\"1\":{\"281\":1}}],[\"stl简介\",{\"0\":{\"245\":1}}],[\"stk\",{\"1\":{\"121\":7,\"229\":3,\"230\":2}}],[\"stack\",{\"1\":{\"245\":1}}],[\"statobjectargs\",{\"1\":{\"290\":1}}],[\"statobjectresponse\",{\"1\":{\"290\":3}}],[\"statobject\",{\"1\":{\"290\":2}}],[\"statement\",{\"1\":{\"289\":1}}],[\"state\",{\"1\":{\"130\":4}}],[\"static\",{\"1\":{\"35\":1}}],[\"start\",{\"1\":{\"102\":3}}],[\"st\",{\"1\":{\"85\":4,\"94\":6,\"98\":4,\"110\":9,\"130\":3,\"162\":1,\"168\":3,\"169\":3,\"173\":3,\"174\":3,\"176\":5,\"177\":5,\"181\":3,\"184\":5,\"193\":4,\"195\":5,\"202\":4,\"212\":3}}],[\"stderr\",{\"1\":{\"274\":1}}],[\"stdc++\",{\"1\":{\"128\":1,\"133\":1,\"181\":1,\"182\":1}}],[\"std\",{\"1\":{\"37\":1,\"40\":1,\"47\":1,\"51\":1,\"55\":1,\"65\":1,\"66\":1,\"73\":1,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"130\":1,\"131\":1,\"133\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"173\":1,\"181\":1,\"182\":1,\"198\":1,\"206\":1,\"214\":1,\"216\":1,\"234\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"stdlib\",{\"1\":{\"34\":1}}],[\"stdout\",{\"1\":{\"32\":2,\"274\":2}}],[\"stream\",{\"1\":{\"290\":1}}],[\"struct\",{\"1\":{\"40\":1,\"117\":1,\"166\":1,\"175\":1,\"182\":1,\"246\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1}}],[\"str\",{\"1\":{\"26\":5,\"34\":9,\"124\":3,\"235\":6,\"244\":2,\"245\":1}}],[\"strlen\",{\"1\":{\"26\":3,\"124\":2}}],[\"string类型的参数需要转换一下\",{\"1\":{\"34\":1}}],[\"string\",{\"0\":{\"34\":1,\"35\":1},\"1\":{\"26\":17,\"28\":1,\"34\":7,\"35\":4,\"77\":3,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"245\":1,\"287\":4,\"289\":2,\"290\":1}}],[\"s\",{\"1\":{\"26\":5,\"27\":2,\"28\":2,\"34\":4,\"46\":13,\"47\":7,\"50\":4,\"51\":10,\"54\":4,\"55\":10,\"106\":6,\"117\":18,\"118\":8,\"124\":3,\"126\":5,\"152\":3,\"153\":5,\"155\":4,\"166\":4,\"190\":2,\"214\":2,\"219\":2,\"220\":2,\"234\":5,\"245\":4,\"282\":2}}],[\"和校验和\",{\"1\":{\"282\":1}}],[\"和传统对象存储相比\",{\"1\":{\"282\":1}}],[\"和上面类似\",{\"1\":{\"245\":1}}],[\"和条件\",{\"1\":{\"217\":1}}],[\"和前面每一个都组合一下\",{\"1\":{\"47\":1}}],[\"和\",{\"1\":{\"26\":2,\"45\":1,\"46\":2,\"53\":1,\"65\":4,\"71\":1,\"79\":1,\"104\":1,\"109\":1,\"122\":2,\"123\":2,\"124\":1,\"125\":1,\"128\":2,\"137\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"149\":1,\"150\":1,\"172\":1,\"183\":1,\"194\":2,\"205\":1,\"206\":2,\"214\":1,\"245\":1,\"277\":1,\"282\":2}}],[\"2>\",{\"1\":{\"274\":2}}],[\"239\",{\"1\":{\"267\":1}}],[\"231−1\",{\"1\":{\"123\":1}}],[\"2^64\",{\"1\":{\"244\":2}}],[\"2x+1\",{\"1\":{\"240\":1}}],[\"2x\",{\"1\":{\"240\":1}}],[\"26\",{\"1\":{\"235\":1}}],[\"2n\",{\"1\":{\"206\":1,\"213\":1}}],[\"2ll\",{\"1\":{\"194\":1}}],[\"2k\",{\"1\":{\"158\":2}}],[\"2e5\",{\"1\":{\"144\":1,\"182\":1}}],[\"2e5+5\",{\"1\":{\"66\":1}}],[\"2e9\",{\"1\":{\"121\":1,\"162\":4,\"251\":1,\"254\":1,\"255\":4}}],[\"29\",{\"1\":{\"104\":1}}],[\"2∼n+1\",{\"1\":{\"104\":1}}],[\"2表示未选\",{\"1\":{\"94\":1}}],[\"2012\",{\"1\":{\"289\":1}}],[\"2010\",{\"1\":{\"117\":2}}],[\"20005\",{\"1\":{\"65\":1}}],[\"20\",{\"1\":{\"46\":2,\"94\":1,\"106\":1,\"110\":1,\"131\":1,\"214\":1}}],[\"256\",{\"1\":{\"34\":1}}],[\"2\",{\"0\":{\"26\":1,\"62\":1,\"116\":1,\"119\":1,\"120\":1,\"121\":2,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"131\":1,\"138\":1,\"143\":1,\"148\":1,\"153\":1,\"158\":1,\"167\":1,\"174\":1,\"178\":1,\"179\":1,\"182\":1,\"190\":1,\"194\":1,\"196\":1,\"197\":1,\"198\":2,\"199\":1,\"202\":1,\"210\":1,\"217\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"233\":1,\"238\":1,\"243\":1,\"252\":1},\"1\":{\"26\":1,\"34\":1,\"37\":1,\"38\":1,\"39\":6,\"40\":2,\"45\":2,\"49\":3,\"50\":1,\"51\":1,\"53\":1,\"59\":2,\"61\":1,\"65\":4,\"66\":9,\"75\":9,\"79\":1,\"83\":6,\"92\":4,\"94\":1,\"96\":6,\"100\":6,\"104\":2,\"117\":2,\"120\":3,\"123\":5,\"126\":2,\"127\":4,\"128\":2,\"133\":2,\"137\":2,\"138\":1,\"142\":2,\"145\":1,\"147\":1,\"148\":2,\"152\":1,\"158\":9,\"160\":1,\"161\":1,\"166\":2,\"170\":1,\"172\":1,\"173\":1,\"175\":3,\"176\":1,\"179\":1,\"181\":2,\"182\":1,\"183\":2,\"189\":2,\"190\":1,\"191\":2,\"193\":5,\"194\":2,\"195\":1,\"198\":1,\"201\":1,\"202\":1,\"206\":1,\"207\":2,\"210\":1,\"211\":1,\"212\":2,\"214\":1,\"217\":1,\"226\":1,\"227\":1,\"234\":1,\"240\":13,\"245\":1,\"246\":1,\"252\":1,\"282\":2}}],[\"groupid>\",{\"1\":{\"286\":1}}],[\"greater<int>\",{\"1\":{\"246\":1}}],[\"greater<int>>\",{\"1\":{\"245\":1,\"253\":1}}],[\"greater<pii>>\",{\"1\":{\"174\":1}}],[\"greater\",{\"1\":{\"106\":1}}],[\"go\",{\"1\":{\"282\":2}}],[\"google\",{\"1\":{\"282\":1}}],[\"goods\",{\"1\":{\"117\":4}}],[\"good\",{\"1\":{\"117\":5}}],[\"golang\",{\"1\":{\"282\":1}}],[\"g1\",{\"1\":{\"221\":1}}],[\"g被称为有向图游戏g1\",{\"1\":{\"221\":1}}],[\"gm的和\",{\"1\":{\"221\":1}}],[\"gm\",{\"1\":{\"221\":2}}],[\"g2\",{\"1\":{\"221\":3}}],[\"gauss\",{\"1\":{\"207\":1}}],[\"gcd\",{\"1\":{\"31\":1,\"199\":3,\"205\":5}}],[\"getpresignedobjecturlargs\",{\"1\":{\"290\":1}}],[\"getpresignedobjecturl\",{\"1\":{\"290\":2}}],[\"getobjectargs\",{\"1\":{\"290\":1}}],[\"getobjectresponse\",{\"1\":{\"290\":3}}],[\"getobject\",{\"1\":{\"289\":1,\"290\":2}}],[\"getsecretkey\",{\"1\":{\"287\":1}}],[\"getaccesskey\",{\"1\":{\"287\":1}}],[\"getendpoint\",{\"1\":{\"287\":1}}],[\"get\",{\"1\":{\"28\":1,\"30\":1,\"193\":1,\"194\":1,\"195\":1,\"197\":1,\"202\":1,\"212\":6,\"244\":1,\"290\":2}}],[\"g\",{\"1\":{\"25\":1,\"37\":2,\"73\":3,\"128\":7,\"166\":1,\"173\":9,\"181\":7,\"220\":1,\"221\":1}}],[\"gitee\",{\"1\":{\"273\":1}}],[\"gitee镜像\",{\"1\":{\"273\":1}}],[\"github\",{\"1\":{\"258\":1,\"273\":2,\"277\":1,\"282\":3}}],[\"git\",{\"0\":{\"16\":1},\"1\":{\"8\":1}}],[\"00<\",{\"1\":{\"277\":1}}],[\"00\",{\"1\":{\"277\":1}}],[\"0001\",{\"1\":{\"158\":1}}],[\"0000\",{\"1\":{\"158\":6}}],[\"0号点既是根节点\",{\"1\":{\"235\":1}}],[\"0和1都被占用了\",{\"1\":{\"227\":1}}],[\"0是左端点\",{\"1\":{\"227\":1}}],[\"0表示白色\",{\"1\":{\"183\":1}}],[\"0表示还没放数\",{\"1\":{\"98\":1}}],[\"0表示还没考虑\",{\"1\":{\"94\":1}}],[\"0变1\",{\"1\":{\"157\":1}}],[\"0x3f3f3f3f\",{\"1\":{\"173\":1,\"174\":1,\"175\":1,\"176\":1}}],[\"0x3f\",{\"1\":{\"131\":1,\"173\":2,\"174\":1,\"175\":1,\"176\":1,\"181\":2}}],[\"01\",{\"0\":{\"115\":1}}],[\"0辆车\",{\"1\":{\"106\":1}}],[\"0只猫\",{\"1\":{\"106\":1}}],[\"0⩽m⩽n\",{\"1\":{\"100\":1}}],[\"0⩽r⩽1090<n⩽100000⩽xi​\",{\"1\":{\"53\":1}}],[\"0\",{\"1\":{\"25\":1,\"26\":1,\"27\":4,\"28\":3,\"29\":3,\"33\":1,\"34\":1,\"37\":1,\"38\":2,\"46\":4,\"47\":3,\"49\":4,\"50\":2,\"51\":5,\"53\":2,\"55\":2,\"65\":1,\"66\":1,\"71\":22,\"73\":8,\"77\":10,\"85\":3,\"94\":5,\"98\":2,\"102\":2,\"106\":6,\"108\":1,\"110\":4,\"115\":2,\"116\":2,\"117\":8,\"118\":9,\"120\":4,\"121\":11,\"122\":1,\"123\":2,\"124\":8,\"125\":5,\"126\":1,\"127\":7,\"128\":19,\"130\":13,\"131\":13,\"133\":16,\"138\":2,\"144\":4,\"147\":10,\"148\":19,\"149\":9,\"150\":9,\"158\":39,\"159\":4,\"160\":2,\"161\":1,\"166\":6,\"170\":3,\"173\":3,\"174\":2,\"175\":3,\"176\":1,\"179\":1,\"181\":3,\"182\":5,\"183\":2,\"184\":2,\"189\":1,\"190\":3,\"191\":3,\"194\":2,\"195\":4,\"197\":1,\"198\":2,\"201\":2,\"202\":4,\"203\":1,\"205\":1,\"206\":3,\"207\":5,\"209\":2,\"210\":3,\"211\":2,\"212\":8,\"214\":6,\"216\":3,\"226\":1,\"227\":2,\"229\":2,\"230\":1,\"232\":1,\"233\":2,\"234\":4,\"235\":6,\"237\":1,\"239\":1,\"243\":1,\"244\":1,\"251\":2,\"252\":1,\"253\":3,\"254\":4,\"255\":2,\"269\":1,\"280\":1}}],[\"+x\",{\"1\":{\"274\":1}}],[\"+2xt​​\",{\"1\":{\"203\":1}}],[\"+inf\",{\"1\":{\"181\":1}}],[\"+happy\",{\"1\":{\"133\":1}}],[\"+f\",{\"1\":{\"127\":1}}],[\"++size\",{\"1\":{\"240\":1}}],[\"++res\",{\"1\":{\"191\":1}}],[\"++tt\",{\"1\":{\"170\":2,\"229\":1,\"230\":1,\"232\":1,\"233\":1}}],[\"++y\",{\"1\":{\"55\":1}}],[\"++x\",{\"1\":{\"55\":1}}],[\"++\",{\"1\":{\"46\":1,\"47\":1,\"127\":5,\"128\":2,\"130\":6,\"133\":1,\"166\":4,\"173\":3,\"175\":2,\"177\":1,\"182\":1,\"183\":1,\"184\":1,\"198\":3,\"202\":3,\"207\":7,\"210\":1,\"211\":1,\"212\":7,\"226\":1,\"235\":4,\"238\":1,\"239\":1,\"242\":1,\"244\":1,\"245\":1}}],[\"++mx\",{\"1\":{\"33\":1}}],[\"+=\",{\"1\":{\"38\":1,\"46\":1,\"47\":1,\"51\":2,\"55\":2,\"66\":4,\"77\":1,\"106\":1,\"117\":4,\"128\":4,\"130\":1,\"133\":2,\"144\":1,\"147\":2,\"149\":1,\"154\":1,\"155\":2,\"181\":1,\"182\":1,\"193\":1,\"194\":2,\"212\":2,\"214\":1,\"237\":2,\"238\":1,\"239\":1}}],[\"+size\",{\"1\":{\"29\":1}}],[\"+\",{\"1\":{\"25\":3,\"28\":2,\"30\":1,\"31\":2,\"32\":2,\"37\":4,\"38\":1,\"39\":4,\"47\":2,\"51\":1,\"54\":1,\"55\":4,\"73\":3,\"77\":5,\"85\":1,\"94\":3,\"98\":1,\"102\":3,\"106\":5,\"110\":4,\"115\":2,\"116\":2,\"117\":4,\"118\":2,\"120\":6,\"121\":6,\"122\":4,\"123\":1,\"124\":7,\"125\":8,\"126\":12,\"127\":10,\"128\":4,\"131\":2,\"133\":2,\"137\":5,\"138\":4,\"141\":4,\"142\":2,\"143\":2,\"144\":8,\"145\":1,\"147\":3,\"148\":2,\"150\":1,\"152\":4,\"153\":1,\"154\":1,\"155\":4,\"159\":1,\"160\":1,\"161\":3,\"166\":3,\"167\":1,\"172\":1,\"173\":2,\"174\":2,\"175\":4,\"176\":2,\"177\":3,\"179\":1,\"181\":2,\"182\":2,\"183\":1,\"193\":5,\"194\":1,\"195\":1,\"198\":11,\"205\":3,\"206\":2,\"207\":2,\"209\":1,\"211\":1,\"212\":3,\"213\":1,\"234\":4,\"240\":4,\"242\":2,\"243\":1,\"244\":2,\"245\":1,\"246\":13,\"251\":4,\"252\":4,\"253\":2,\"254\":2,\"255\":1,\"289\":5}}],[\"+1\",{\"1\":{\"25\":1,\"109\":1}}],[\"nas\",{\"1\":{\"282\":1}}],[\"name\",{\"1\":{\"289\":1}}],[\"name>\",{\"1\":{\"277\":1}}],[\"namespace\",{\"1\":{\"47\":1,\"51\":1,\"55\":1,\"65\":1,\"66\":1,\"73\":1,\"77\":1,\"85\":1,\"94\":1,\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"115\":1,\"116\":1,\"117\":3,\"118\":2,\"120\":1,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"130\":1,\"131\":1,\"133\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"173\":1,\"181\":1,\"182\":1,\"198\":1,\"206\":1,\"214\":1,\"216\":1,\"234\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"n个闭区间\",{\"1\":{\"251\":1,\"253\":1}}],[\"null\",{\"1\":{\"243\":1}}],[\"nums\",{\"1\":{\"128\":5,\"255\":7,\"268\":1,\"269\":4}}],[\"num\",{\"1\":{\"34\":8,\"255\":5}}],[\"n为模式串长度\",{\"1\":{\"234\":1}}],[\"nim博弈属于公平组合游戏\",{\"1\":{\"217\":1}}],[\"nim博弈先手必胜\",{\"1\":{\"216\":1}}],[\"nim博弈不存在平局\",{\"1\":{\"216\":1}}],[\"nim游戏\",{\"0\":{\"216\":1}}],[\"n=p1a1​​p2a2​​\",{\"1\":{\"201\":1}}],[\"n=a+cb​\",{\"1\":{\"109\":2}}],[\"n1表示第一个集合中的点数\",{\"1\":{\"184\":1}}],[\"n1\",{\"1\":{\"184\":2}}],[\"n是点数\",{\"1\":{\"182\":1}}],[\"n次迭代\",{\"1\":{\"181\":1}}],[\"n^3\",{\"1\":{\"179\":1,\"207\":1}}],[\"n表示点数\",{\"1\":{\"175\":1,\"181\":1,\"183\":1}}],[\"nm\",{\"1\":{\"172\":2,\"175\":1,\"176\":1,\"177\":1,\"184\":1}}],[\"n2表示第二个集合中的点数\",{\"1\":{\"184\":1}}],[\"n2\",{\"1\":{\"172\":1,\"173\":1,\"181\":1,\"184\":1}}],[\"new\",{\"1\":{\"290\":4}}],[\"next\",{\"1\":{\"234\":4}}],[\"ne\",{\"1\":{\"166\":2,\"168\":1,\"169\":1,\"170\":1,\"174\":3,\"176\":3,\"177\":2,\"183\":2,\"184\":2,\"226\":10,\"234\":5,\"242\":3}}],[\"n代表点数\",{\"1\":{\"166\":1}}],[\"nlogn\",{\"1\":{\"144\":1}}],[\"n−1\",{\"1\":{\"131\":3}}],[\"n−m\",{\"1\":{\"100\":1}}],[\"n<=0\",{\"1\":{\"128\":1}}],[\"n共有多少种不同的划分方法\",{\"1\":{\"127\":1}}],[\"n+1\",{\"1\":{\"206\":1}}],[\"n+m\",{\"1\":{\"170\":1}}],[\"n+\",{\"1\":{\"100\":1}}],[\"n>0\",{\"1\":{\"100\":1}}],[\"n×n\",{\"1\":{\"79\":2}}],[\"n×m\",{\"1\":{\"71\":1,\"130\":1}}],[\"nohup\",{\"1\":{\"274\":1}}],[\"nohub\",{\"1\":{\"274\":1}}],[\"none\",{\"1\":{\"245\":1}}],[\"not\",{\"1\":{\"229\":1,\"232\":1,\"296\":1}}],[\"note\",{\"0\":{\"298\":1,\"305\":1},\"2\":{\"42\":1}}],[\"node\",{\"1\":{\"166\":4,\"246\":3,\"251\":2,\"252\":2}}],[\"no\",{\"1\":{\"65\":3,\"216\":1}}],[\"noexcept\",{\"1\":{\"26\":2}}],[\"npos是这样定义的\",{\"1\":{\"35\":1}}],[\"npos是一个静态成员常量\",{\"1\":{\"35\":1}}],[\"npos\",{\"0\":{\"35\":1},\"1\":{\"35\":2}}],[\"n\",{\"1\":{\"25\":3,\"27\":1,\"28\":1,\"29\":1,\"37\":7,\"38\":1,\"45\":3,\"47\":6,\"49\":3,\"50\":3,\"51\":10,\"53\":3,\"55\":6,\"61\":6,\"65\":10,\"66\":16,\"71\":4,\"73\":10,\"79\":5,\"83\":2,\"85\":8,\"92\":2,\"94\":6,\"96\":2,\"98\":8,\"100\":2,\"102\":6,\"104\":4,\"106\":9,\"110\":8,\"115\":11,\"116\":11,\"117\":26,\"118\":19,\"120\":14,\"121\":21,\"122\":10,\"123\":16,\"124\":13,\"125\":10,\"126\":13,\"127\":16,\"128\":6,\"130\":11,\"131\":13,\"133\":6,\"144\":9,\"147\":1,\"159\":14,\"160\":1,\"161\":1,\"166\":13,\"167\":2,\"170\":3,\"172\":2,\"173\":13,\"174\":10,\"175\":13,\"176\":7,\"177\":11,\"179\":5,\"180\":2,\"181\":14,\"182\":14,\"183\":6,\"184\":4,\"189\":1,\"190\":10,\"191\":15,\"193\":16,\"194\":2,\"195\":5,\"198\":5,\"201\":3,\"202\":8,\"206\":8,\"207\":21,\"209\":1,\"210\":3,\"211\":8,\"212\":14,\"213\":3,\"214\":11,\"216\":3,\"226\":3,\"227\":3,\"229\":1,\"230\":1,\"232\":1,\"233\":1,\"234\":5,\"235\":2,\"237\":4,\"238\":3,\"239\":3,\"240\":6,\"242\":9,\"243\":5,\"244\":3,\"246\":8,\"251\":7,\"252\":7,\"253\":7,\"254\":9,\"255\":4,\"269\":2,\"282\":2}}],[\"aws\",{\"1\":{\"282\":2,\"289\":2}}],[\"amazon\",{\"1\":{\"282\":2}}],[\"amd64\",{\"1\":{\"274\":1,\"276\":1}}],[\"azure\",{\"1\":{\"282\":1}}],[\"action\",{\"1\":{\"289\":1}}],[\"accesskey\",{\"1\":{\"287\":2}}],[\"account\",{\"1\":{\"281\":1}}],[\"acm\",{\"2\":{\"42\":1,\"57\":1,\"68\":1,\"89\":1,\"112\":1,\"135\":1,\"164\":1,\"186\":1,\"223\":1,\"248\":1,\"257\":1}}],[\"application\",{\"1\":{\"287\":1}}],[\"api\",{\"0\":{\"288\":1},\"1\":{\"281\":2,\"282\":2,\"287\":1}}],[\"apache\",{\"1\":{\"280\":1}}],[\"ap−1≡1\",{\"1\":{\"210\":1}}],[\"arn\",{\"1\":{\"289\":1}}],[\"artifactid>\",{\"1\":{\"286\":1}}],[\"arguments>\",{\"1\":{\"277\":1}}],[\"arr\",{\"1\":{\"121\":7,\"251\":7,\"252\":9}}],[\"a3​\",{\"1\":{\"230\":1}}],[\"a3​≥a5​\",{\"1\":{\"230\":1}}],[\"a−2\",{\"1\":{\"211\":2}}],[\"a−1\",{\"1\":{\"211\":2}}],[\"a−b+1\",{\"1\":{\"211\":2}}],[\"a−b−1\",{\"1\":{\"211\":1}}],[\"a−b\",{\"1\":{\"210\":2,\"211\":3}}],[\"a∗\",{\"1\":{\"211\":2}}],[\"a1\",{\"1\":{\"206\":6,\"216\":1}}],[\"a1​\",{\"1\":{\"45\":1,\"49\":2,\"206\":1}}],[\"ak\",{\"1\":{\"203\":1}}],[\"abs\",{\"1\":{\"206\":2,\"207\":3}}],[\"ab=a2x1​×a2x2​×\",{\"1\":{\"203\":1}}],[\"ab\",{\"1\":{\"203\":1}}],[\"a2\",{\"1\":{\"206\":5,\"216\":1}}],[\"a2logk\",{\"1\":{\"203\":2}}],[\"a22\",{\"1\":{\"203\":2}}],[\"a21\",{\"1\":{\"203\":2}}],[\"a20\",{\"1\":{\"203\":2}}],[\"a2​\",{\"1\":{\"45\":1,\"49\":2,\"206\":1}}],[\"a表示出点\",{\"1\":{\"175\":1}}],[\"allow\",{\"1\":{\"289\":1}}],[\"alls\",{\"1\":{\"161\":9}}],[\"algorithm\",{\"1\":{\"144\":1},\"2\":{\"22\":1,\"134\":1,\"163\":1,\"185\":1,\"222\":1,\"247\":1,\"256\":1}}],[\"a的这一位数\",{\"1\":{\"148\":1}}],[\"a长度不等于b\",{\"1\":{\"148\":1}}],[\"address\",{\"1\":{\"274\":3,\"275\":1,\"276\":1}}],[\"add\",{\"1\":{\"147\":2,\"166\":3,\"174\":1,\"176\":1,\"226\":1}}],[\"adj\",{\"1\":{\"38\":1}}],[\"a>b\",{\"1\":{\"128\":1}}],[\"a||b\",{\"1\":{\"128\":1}}],[\"a是几\",{\"1\":{\"110\":1}}],[\"a不变\",{\"1\":{\"110\":1}}],[\"any\",{\"1\":{\"245\":1}}],[\"an\",{\"1\":{\"216\":1}}],[\"ans++\",{\"1\":{\"110\":1,\"251\":1}}],[\"ans\",{\"1\":{\"110\":2,\"120\":4,\"121\":4,\"128\":13,\"143\":3,\"251\":2,\"255\":4,\"269\":4}}],[\"an​\",{\"1\":{\"45\":1,\"49\":2,\"206\":1}}],[\"a和\",{\"1\":{\"65\":1}}],[\"aj​\",{\"1\":{\"45\":1}}],[\"ai\",{\"1\":{\"282\":1}}],[\"ai+1​\",{\"1\":{\"45\":1}}],[\"ai​\",{\"1\":{\"45\":2,\"206\":1}}],[\"ask\",{\"1\":{\"128\":3}}],[\"assign\",{\"0\":{\"37\":1},\"1\":{\"37\":6}}],[\"asm\",{\"1\":{\"29\":1}}],[\"atoi\",{\"1\":{\"34\":3}}],[\"ax​\",{\"1\":{\"230\":1}}],[\"ax​≥ay​\",{\"1\":{\"230\":1}}],[\"ax\",{\"1\":{\"31\":2,\"205\":2}}],[\"ax+by=1\",{\"1\":{\"205\":1}}],[\"ax+by=a\",{\"1\":{\"205\":1}}],[\"ax+by=gcd\",{\"1\":{\"205\":2}}],[\"ax+by\",{\"1\":{\"31\":1,\"205\":1}}],[\"autorollattime>\",{\"1\":{\"277\":1}}],[\"auto\",{\"1\":{\"28\":1,\"33\":1,\"38\":4,\"73\":1,\"77\":1,\"117\":1,\"128\":5,\"130\":1,\"147\":1,\"148\":2,\"149\":1,\"150\":1,\"162\":1,\"166\":1,\"174\":1,\"176\":1,\"177\":1,\"198\":1,\"253\":1,\"255\":1}}],[\"a\",{\"0\":{\"30\":1},\"1\":{\"25\":1,\"28\":1,\"30\":2,\"31\":3,\"37\":2,\"39\":11,\"40\":1,\"65\":3,\"77\":6,\"109\":6,\"110\":13,\"117\":4,\"120\":5,\"121\":10,\"122\":6,\"123\":8,\"124\":3,\"125\":10,\"126\":3,\"128\":8,\"133\":3,\"137\":7,\"138\":12,\"141\":1,\"142\":2,\"144\":13,\"147\":15,\"148\":27,\"149\":17,\"150\":15,\"152\":5,\"158\":17,\"166\":13,\"173\":9,\"174\":3,\"175\":9,\"176\":3,\"179\":1,\"181\":5,\"182\":8,\"194\":13,\"198\":2,\"199\":6,\"203\":5,\"205\":15,\"206\":6,\"207\":17,\"209\":2,\"210\":13,\"211\":22,\"212\":10,\"226\":2,\"235\":2,\"238\":2,\"239\":3,\"240\":4,\"246\":29}}],[\"一定等于\",{\"1\":{\"210\":1}}],[\"一定在\",{\"1\":{\"206\":1}}],[\"一定不含有奇数环\",{\"1\":{\"183\":1}}],[\"一定要先累加\",{\"1\":{\"181\":1}}],[\"一定满足\",{\"1\":{\"175\":1}}],[\"一定至少存在一个入度为\",{\"1\":{\"170\":1}}],[\"一定存在整数对\",{\"1\":{\"205\":1}}],[\"一定存在整数\",{\"1\":{\"31\":1,\"205\":1}}],[\"一直递归寻找最下层的左节点\",{\"1\":{\"264\":1}}],[\"一直走到底层\",{\"1\":{\"120\":1}}],[\"一直找到祖先的祖先\",{\"1\":{\"62\":1}}],[\"一\",{\"1\":{\"118\":1,\"121\":1}}],[\"一个对象会被分成\",{\"1\":{\"282\":1}}],[\"一个指向后\",{\"1\":{\"227\":1}}],[\"一个指向前\",{\"1\":{\"227\":1}}],[\"一个图所有匹配中\",{\"1\":{\"184\":1}}],[\"一个\",{\"1\":{\"184\":1}}],[\"一个有向无环图\",{\"1\":{\"170\":1}}],[\"一个数的倍数一定是合数\",{\"1\":{\"193\":1}}],[\"一个数\",{\"1\":{\"121\":1}}],[\"一个正整数\",{\"1\":{\"108\":1,\"127\":1}}],[\"一个整数\",{\"1\":{\"96\":1}}],[\"一个整数表示答案\",{\"1\":{\"79\":1}}],[\"一开始\",{\"1\":{\"61\":1}}],[\"一开始都是独立的\",{\"1\":{\"61\":1}}],[\"一些常见的用途有求连通子图\",{\"1\":{\"59\":1}}],[\"一些经验和技巧\",{\"0\":{\"24\":1}}],[\"一样\",{\"1\":{\"40\":1}}],[\"一维差分\",{\"0\":{\"154\":1}}],[\"一维前缀和\",{\"0\":{\"152\":1}}],[\"一维优化\",{\"1\":{\"127\":1}}],[\"一维优化写法\",{\"1\":{\"117\":1}}],[\"一维\",{\"1\":{\"37\":1,\"115\":1,\"116\":1}}],[\"一旦程序使用长度超过\",{\"1\":{\"26\":1}}],[\"一般是\",{\"1\":{\"149\":1,\"150\":1}}],[\"一般来说\",{\"1\":{\"143\":1}}],[\"一般\",{\"1\":{\"25\":1}}],[\"17\",{\"1\":{\"289\":1}}],[\"171gb\",{\"1\":{\"282\":1}}],[\"183gb\",{\"1\":{\"282\":1}}],[\"1是右端点\",{\"1\":{\"227\":1}}],[\"1~n\",{\"1\":{\"193\":1}}],[\"1~n表示放的哪些数\",{\"1\":{\"98\":1}}],[\"1表示不存在\",{\"1\":{\"226\":1}}],[\"1表示黑色\",{\"1\":{\"183\":1}}],[\"1表示未染色\",{\"1\":{\"183\":1}}],[\"1表示已选\",{\"1\":{\"94\":1}}],[\"1ll\",{\"1\":{\"166\":1}}],[\"1变0\",{\"1\":{\"157\":1}}],[\"1<<n\",{\"1\":{\"131\":1}}],[\"1<<j\",{\"1\":{\"131\":2}}],[\"1的最短距离\",{\"1\":{\"131\":1}}],[\"1×2\",{\"1\":{\"130\":1}}],[\"1个0\",{\"1\":{\"128\":1}}],[\"1个9\",{\"1\":{\"128\":1}}],[\"1≤n≤3000\",{\"1\":{\"123\":1}}],[\"1∼9\",{\"1\":{\"108\":2,\"109\":1}}],[\"1∼n\",{\"1\":{\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"201\":1}}],[\"1∼8\",{\"1\":{\"75\":1}}],[\"1994\",{\"1\":{\"104\":1}}],[\"1996\",{\"1\":{\"104\":1}}],[\"19\",{\"1\":{\"75\":1}}],[\"1⩽ci​⩽w⩽108\",{\"1\":{\"104\":1}}],[\"1⩽q⩽1000000\",{\"1\":{\"65\":1}}],[\"1⩽m⩽1000000\",{\"1\":{\"65\":1}}],[\"1⩽n<106\",{\"1\":{\"108\":1}}],[\"1⩽n⩽9\",{\"1\":{\"96\":1}}],[\"1⩽n⩽18\",{\"1\":{\"104\":1}}],[\"1⩽n⩽15\",{\"1\":{\"92\":1}}],[\"1⩽n⩽1000\",{\"1\":{\"79\":1}}],[\"1⩽n⩽105\",{\"1\":{\"49\":1}}],[\"1⩽n⩽10\",{\"1\":{\"49\":1}}],[\"1⩽n⩽7\",{\"1\":{\"83\":1}}],[\"1⩽n⩽20000\",{\"1\":{\"65\":1}}],[\"1⩽n\",{\"1\":{\"45\":1,\"71\":1}}],[\"1会导致数组越界\",{\"1\":{\"55\":1}}],[\"1e6\",{\"1\":{\"147\":1}}],[\"1e\",{\"1\":{\"145\":1,\"207\":1}}],[\"1e3\",{\"1\":{\"127\":1}}],[\"1e5\",{\"1\":{\"47\":1,\"51\":1,\"55\":1,\"181\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1}}],[\"1e9+7\",{\"1\":{\"209\":1}}],[\"1e9\",{\"1\":{\"26\":1,\"120\":1,\"126\":1,\"127\":1,\"198\":1}}],[\"16\",{\"0\":{\"40\":1}}],[\"15\",{\"0\":{\"39\":1},\"1\":{\"124\":1}}],[\"14\",{\"0\":{\"38\":1}}],[\"13331\",{\"1\":{\"244\":1}}],[\"131\",{\"1\":{\"244\":1}}],[\"13\",{\"0\":{\"37\":1},\"1\":{\"46\":1}}],[\"12010\",{\"1\":{\"117\":1}}],[\"12\",{\"0\":{\"36\":1},\"1\":{\"104\":1,\"130\":1,\"282\":1}}],[\"123456\",{\"1\":{\"147\":1,\"148\":1}}],[\"12345678x\",{\"1\":{\"77\":1}}],[\"123\",{\"1\":{\"34\":7,\"290\":1}}],[\"1111\",{\"1\":{\"158\":7,\"214\":1}}],[\"1110\",{\"1\":{\"158\":8}}],[\"1100\",{\"1\":{\"116\":1}}],[\"110\",{\"1\":{\"73\":1,\"117\":1,\"118\":2,\"198\":1}}],[\"11\",{\"0\":{\"35\":1},\"1\":{\"108\":2,\"207\":1}}],[\"10的二进制表示为4位数\",{\"1\":{\"159\":1}}],[\"1011\",{\"1\":{\"158\":1}}],[\"101000\",{\"1\":{\"159\":1}}],[\"1010\",{\"1\":{\"115\":1,\"121\":1,\"122\":1,\"124\":1,\"125\":1,\"158\":8,\"159\":2}}],[\"105\",{\"1\":{\"108\":1}}],[\"10010\",{\"1\":{\"234\":1}}],[\"1000\",{\"1\":{\"158\":1,\"159\":1}}],[\"100010\",{\"1\":{\"121\":2,\"159\":1,\"234\":1}}],[\"100=82+1973546​\",{\"1\":{\"108\":1}}],[\"100=3+71469258​\",{\"1\":{\"108\":1}}],[\"100\",{\"0\":{\"301\":1},\"1\":{\"108\":3,\"281\":1}}],[\"10\",{\"0\":{\"34\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1,\"220\":1,\"221\":1,\"246\":1},\"1\":{\"47\":1,\"51\":1,\"55\":2,\"65\":2,\"85\":1,\"98\":1,\"110\":4,\"124\":2,\"128\":12,\"144\":1,\"147\":3,\"148\":3,\"149\":2,\"150\":1,\"159\":3,\"166\":1,\"181\":1,\"182\":1,\"212\":4,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"289\":1}}],[\"1\",{\"0\":{\"25\":1,\"36\":1,\"61\":1,\"114\":1,\"115\":2,\"116\":1,\"117\":1,\"118\":1,\"120\":1,\"130\":1,\"133\":1,\"137\":1,\"140\":1,\"147\":1,\"152\":1,\"157\":1,\"166\":1,\"172\":1,\"173\":2,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"179\":1,\"181\":1,\"188\":1,\"189\":2,\"190\":1,\"192\":1,\"193\":2,\"194\":1,\"195\":1,\"197\":1,\"201\":1,\"209\":1,\"216\":1,\"225\":1,\"226\":2,\"227\":1,\"229\":1,\"230\":1,\"232\":1,\"237\":1,\"242\":1,\"250\":1,\"251\":2,\"252\":1,\"253\":1,\"254\":1,\"255\":1},\"1\":{\"25\":3,\"26\":1,\"27\":3,\"28\":1,\"31\":1,\"34\":1,\"35\":2,\"36\":2,\"37\":5,\"38\":4,\"39\":1,\"40\":2,\"45\":1,\"46\":7,\"47\":3,\"49\":3,\"50\":1,\"51\":3,\"53\":6,\"55\":7,\"59\":2,\"61\":2,\"65\":6,\"66\":12,\"71\":14,\"73\":15,\"75\":9,\"77\":7,\"79\":4,\"83\":6,\"85\":2,\"92\":5,\"94\":5,\"96\":7,\"98\":4,\"100\":9,\"102\":5,\"104\":3,\"106\":3,\"110\":5,\"115\":5,\"116\":4,\"117\":9,\"118\":2,\"120\":20,\"121\":14,\"122\":14,\"123\":11,\"124\":15,\"125\":22,\"126\":17,\"127\":15,\"128\":20,\"130\":11,\"131\":8,\"133\":14,\"137\":5,\"138\":3,\"141\":6,\"142\":7,\"143\":3,\"147\":4,\"148\":7,\"149\":3,\"150\":4,\"152\":2,\"153\":4,\"154\":1,\"155\":4,\"158\":38,\"159\":9,\"160\":2,\"161\":4,\"166\":9,\"168\":1,\"169\":3,\"170\":5,\"172\":1,\"173\":9,\"174\":5,\"175\":6,\"176\":7,\"177\":3,\"179\":6,\"180\":1,\"181\":6,\"182\":5,\"183\":7,\"184\":2,\"190\":2,\"191\":4,\"193\":6,\"194\":1,\"195\":1,\"197\":1,\"198\":7,\"201\":3,\"202\":11,\"203\":9,\"205\":2,\"206\":7,\"207\":5,\"209\":4,\"210\":7,\"211\":8,\"212\":2,\"213\":1,\"214\":9,\"226\":2,\"227\":2,\"230\":1,\"232\":1,\"233\":1,\"234\":5,\"237\":1,\"238\":2,\"239\":1,\"240\":12,\"242\":1,\"244\":6,\"245\":2,\"246\":14,\"251\":4,\"252\":5,\"254\":2,\"274\":2,\"290\":1}}],[\"资料等等\",{\"1\":{\"20\":1}}],[\"资源共享\",{\"1\":{\"15\":1}}],[\"程序人生\",{\"0\":{\"20\":1}}],[\"帮助学习\",{\"1\":{\"19\":1}}],[\"帮助用户灵活\",{\"1\":{\"15\":1}}],[\"常见的有阿里云对象存储服务\",{\"1\":{\"281\":1}}],[\"常见模型\",{\"1\":{\"230\":1,\"233\":1}}],[\"常见问题分类\",{\"1\":{\"160\":1}}],[\"常见中间件主要分为\",{\"1\":{\"15\":1}}],[\"常用语言的\",{\"1\":{\"282\":1}}],[\"常用库函数\",{\"0\":{\"246\":1}}],[\"常用来对一个数据的某些位设置为1\",{\"1\":{\"158\":1}}],[\"常用模版\",{\"1\":{\"126\":1}}],[\"常用于配合\",{\"1\":{\"35\":1}}],[\"常用框架\",{\"0\":{\"18\":1}}],[\"消息中间件\",{\"1\":{\"15\":1}}],[\"为x的后继节点y1\",{\"1\":{\"220\":1}}],[\"为求出不属于集合s的最小非负整数的运算\",{\"1\":{\"219\":1}}],[\"为质数时\",{\"1\":{\"210\":1}}],[\"为避免这种情况\",{\"1\":{\"158\":1}}],[\"为右下角的子矩阵中的所有元素加上c\",{\"1\":{\"155\":1}}],[\"为右下角的子矩阵的和为\",{\"1\":{\"153\":1}}],[\"为左上角\",{\"1\":{\"153\":1,\"155\":1}}],[\"为高兴值\",{\"1\":{\"133\":1}}],[\"为父亲\",{\"1\":{\"133\":1}}],[\"为\",{\"1\":{\"66\":1,\"158\":2,\"210\":2,\"214\":1}}],[\"为亲戚\",{\"1\":{\"65\":1}}],[\"为人数\",{\"1\":{\"65\":1}}],[\"为第\",{\"1\":{\"133\":2}}],[\"为第三段\",{\"1\":{\"50\":1}}],[\"为第一段\",{\"1\":{\"50\":1}}],[\"为应用软件间共享资源提供了可复用的\",{\"1\":{\"15\":1}}],[\"为上层应用软件提供开发\",{\"1\":{\"15\":1}}],[\"协议的\",{\"1\":{\"281\":1}}],[\"协议\",{\"1\":{\"15\":1}}],[\"网络和数据库之上\",{\"1\":{\"15\":1}}],[\"英语\",{\"1\":{\"15\":1}}],[\"l代表区间左端点\",{\"1\":{\"255\":1}}],[\"lucas\",{\"0\":{\"211\":1},\"1\":{\"211\":4}}],[\"lcm\",{\"1\":{\"199\":1}}],[\"lca\",{\"1\":{\"59\":1}}],[\"ln\",{\"1\":{\"193\":4}}],[\"list\",{\"0\":{\"293\":1}}],[\"listobjectsargs\",{\"1\":{\"290\":1}}],[\"listobjects\",{\"1\":{\"290\":4}}],[\"list<bucket>\",{\"1\":{\"289\":1}}],[\"listbuckets\",{\"1\":{\"289\":2}}],[\"license\",{\"1\":{\"280\":1}}],[\"limit\",{\"1\":{\"124\":3}}],[\"linux\",{\"0\":{\"274\":1},\"1\":{\"8\":1,\"274\":1}}],[\"lb\",{\"1\":{\"124\":4}}],[\"localhost\",{\"1\":{\"276\":1,\"287\":1}}],[\"log>\",{\"1\":{\"277\":1}}],[\"logpath>\",{\"1\":{\"277\":1}}],[\"logs<\",{\"1\":{\"277\":1}}],[\"logk\",{\"1\":{\"203\":1}}],[\"log\",{\"1\":{\"182\":1,\"190\":1,\"199\":1,\"274\":4}}],[\"logn\",{\"1\":{\"66\":2,\"245\":3}}],[\"lowbit\",{\"1\":{\"159\":5}}],[\"lower\",{\"1\":{\"121\":1,\"144\":3,\"245\":4,\"246\":4}}],[\"long\",{\"1\":{\"47\":2,\"51\":2,\"55\":2,\"130\":2,\"144\":2,\"181\":2,\"194\":2,\"198\":2,\"206\":2,\"214\":2,\"244\":4}}],[\"lld\",{\"1\":{\"166\":1,\"206\":6}}],[\"ll\",{\"1\":{\"47\":4,\"51\":3,\"55\":1,\"130\":2,\"144\":3,\"181\":1,\"194\":7,\"198\":4,\"206\":15,\"210\":4,\"211\":10,\"214\":2}}],[\"l\",{\"1\":{\"46\":8,\"121\":4,\"137\":8,\"138\":7,\"140\":2,\"141\":8,\"142\":8,\"143\":6,\"145\":5,\"152\":2,\"154\":2,\"161\":4,\"162\":5,\"227\":8,\"244\":4,\"251\":3,\"252\":5,\"253\":5,\"254\":10,\"255\":9}}],[\"la\",{\"1\":{\"124\":4}}],[\"lamda\",{\"1\":{\"38\":1}}],[\"lambda\",{\"1\":{\"38\":4}}],[\"lambda表达式\",{\"0\":{\"38\":1}}],[\"last\",{\"1\":{\"37\":2,\"128\":4}}],[\"len\",{\"1\":{\"27\":2,\"121\":5,\"126\":12}}],[\"len++\",{\"1\":{\"27\":1,\"126\":2}}],[\"length\",{\"1\":{\"26\":6,\"245\":1,\"290\":1}}],[\"leetcode\",{\"0\":{\"6\":1,\"302\":1}}],[\"架构以及系统架构方面的笔记知识点\",{\"1\":{\"7\":1}}],[\"架构设计\",{\"0\":{\"7\":1}}],[\"剑指offer\",{\"0\":{\"21\":1}}],[\"剑指\",{\"0\":{\"5\":1}}],[\"笔记\",{\"0\":{\"4\":1},\"2\":{\"41\":1,\"56\":1,\"67\":1,\"88\":1,\"111\":1}}],[\"笔试题和面试题等\",{\"1\":{\"1\":1}}],[\"贪心\",{\"0\":{\"249\":1},\"1\":{\"3\":1}}],[\"数之间用空格隔开\",{\"1\":{\"206\":1}}],[\"数对\",{\"1\":{\"144\":1}}],[\"数位统计类dp\",{\"0\":{\"128\":1}}],[\"数列\",{\"1\":{\"123\":1}}],[\"数字三角形\",{\"0\":{\"120\":1}}],[\"数字\",{\"1\":{\"108\":1}}],[\"数组时\",{\"1\":{\"234\":2}}],[\"数组和匹配的操作类似\",{\"1\":{\"234\":1}}],[\"数组模拟链表\",{\"0\":{\"225\":1}}],[\"数组进行备份\",{\"1\":{\"175\":1}}],[\"数组的备份\",{\"1\":{\"175\":1}}],[\"数组是上一次迭代后\",{\"1\":{\"175\":1}}],[\"数组b也是从低位\",{\"1\":{\"147\":1,\"148\":1}}],[\"数组a\",{\"1\":{\"147\":1,\"148\":1}}],[\"数组中只包含\",{\"1\":{\"71\":1}}],[\"数组\",{\"1\":{\"66\":1,\"234\":2,\"246\":2}}],[\"数据存储高容错\",{\"1\":{\"282\":1}}],[\"数据保证\",{\"1\":{\"71\":1}}],[\"数据用空格隔开\",{\"1\":{\"53\":2}}],[\"数据范围较大时\",{\"1\":{\"117\":1}}],[\"数据范围\",{\"1\":{\"45\":1,\"49\":1,\"53\":1,\"71\":1,\"79\":1,\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"104\":1,\"108\":1,\"117\":1,\"123\":1}}],[\"数据库中间件\",{\"1\":{\"15\":1}}],[\"数据库之间\",{\"1\":{\"15\":1}}],[\"数据库\",{\"0\":{\"12\":1},\"1\":{\"8\":1}}],[\"数据结构\",{\"0\":{\"224\":1},\"1\":{\"3\":1}}],[\"数学知识\",{\"0\":{\"187\":1},\"1\":{\"3\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
