const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":150,\"nextId\":150,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2#_1-背包问题\",\"3\":\"2#_1-1-01-背包\",\"4\":\"2#_1-2-完全背包\",\"5\":\"2#_1-3-多重背包\",\"6\":\"2#_1-4-分组背包\",\"7\":\"2#_2-线性dp\",\"8\":\"2#_2-1-数字三角形\",\"9\":\"2#_2-2-最长上升子序列\",\"10\":\"2#_2-3-最长公共子序列-不连续\",\"11\":\"2#_2-4-最长公共上升子序列\",\"12\":\"2#_2-5-编辑距离\",\"13\":\"2#_2-6-最短编辑距离\",\"14\":\"2#_3-区间dp\",\"15\":\"2#_4-计数类dp\",\"16\":\"2#_5-数位统计类dp\",\"17\":\"2#_6-状态压缩类dp\",\"18\":\"2#_6-1\",\"19\":\"2#_6-2-最短hamilton路径\",\"20\":\"2#_7-树形dp\",\"21\":\"2#_7-1-没有上司的舞会\",\"22\":\"2@0\",\"23\":\"2@1\",\"24\":\"3\",\"25\":\"3#_1-快速排序\",\"26\":\"3#_2-归并排序\",\"27\":\"3#_3-二分算法\",\"28\":\"3#_3-1-二分查找算法模板\",\"29\":\"3#版本1\",\"30\":\"3#版本2\",\"31\":\"3#_3-2-二分答案模板\",\"32\":\"3#_3-3-整数二分\",\"33\":\"3#_3-4-浮点数二分\",\"34\":\"3#_4-高精度算法\",\"35\":\"3#_4-1-高精度加法\",\"36\":\"3#_4-2-高精度减法\",\"37\":\"3#_4-3-高精度整数乘法\",\"38\":\"3#_4-4-高精度整数除法\",\"39\":\"3#_5-前缀和与差分\",\"40\":\"3#_5-1-一维前缀和\",\"41\":\"3#_5-2-二维前缀和\",\"42\":\"3#_5-3-一维差分\",\"43\":\"3#_5-4-二维差分\",\"44\":\"3#_6-位运算\",\"45\":\"3#_6-1-位运算符\",\"46\":\"3#_6-2-用途\",\"47\":\"3#_6-3-例题\",\"48\":\"3#_7-双指针算法\",\"49\":\"3#_8-离散化\",\"50\":\"3#_9-区间合并\",\"51\":\"3@0\",\"52\":\"3@1\",\"53\":\"4\",\"54\":\"4#_1-树与图的存储\",\"55\":\"4#_2-树与图的遍历\",\"56\":\"4#深度优先遍历\",\"57\":\"4#宽度优先遍历\",\"58\":\"4#_3-拓扑排序\",\"59\":\"4#_4-最短路问题\",\"60\":\"4#_4-1-单源最短路\",\"61\":\"4#_4-1-1-朴素版-dijkstra算法\",\"62\":\"4#_4-1-2-堆优化版的dijkstra算法\",\"63\":\"4#_4-1-3-bellman-ford算法-存在负权边\",\"64\":\"4#_4-1-4-spfa算法-存在负权边\",\"65\":\"4#_4-1-5-spfa算法判断图中是否存在负环\",\"66\":\"4#_4-2-多源汇最短路\",\"67\":\"4#_4-2-1-floyd算法\",\"68\":\"4#_5-最小生成树问题\",\"69\":\"4#_5-1-朴素prim算法\",\"70\":\"4#_5-2-kruskal-算法\",\"71\":\"4#_6-染色法判别二分图\",\"72\":\"4#_7-匈牙利算法\",\"73\":\"4@0\",\"74\":\"4@1\",\"75\":\"5\",\"76\":\"5#_1-质数\",\"77\":\"5#_1-1-试除法判定质数\",\"78\":\"5#_1-2-试除法分解质因数\",\"79\":\"5#汇总\",\"80\":\"5#_1-3-筛法求素数\",\"81\":\"5#_1-3-1-朴素筛法-埃氏筛\",\"82\":\"5#_1-3-2-区间筛法\",\"83\":\"5#_1-3-3-线性筛-欧拉筛\",\"84\":\"5#_2-约数\",\"85\":\"5#_2-1-试除法求所有约数\",\"86\":\"5#_2-2-约数个数和约数之和\",\"87\":\"5#_2-3-最大公约数与最小公倍数\",\"88\":\"5#_3-欧拉函数\",\"89\":\"5#_3-1-求欧拉函数\",\"90\":\"5#_3-2-筛法求欧拉函数\",\"91\":\"5#_4-快速幂\",\"92\":\"5#_5-扩展欧几里得算法\",\"93\":\"5#裴蜀定理\",\"94\":\"5#_6-中国剩余定理\",\"95\":\"5#_7-高斯消元\",\"96\":\"5#_8-求组合数\",\"97\":\"5#_8-1-递推法求组合数\",\"98\":\"5#_8-2-通过预处理逆元的方式求组和数\",\"99\":\"5#_8-3-卢卡斯-lucas-定理求组合数\",\"100\":\"5#_8-4-分解质因数法求组合数\",\"101\":\"5#_8-5-卡特兰数\",\"102\":\"5#_9-容斥原理\",\"103\":\"5#_10-博弈论\",\"104\":\"5#_10-1-nim游戏\",\"105\":\"5#_10-2-公平组合游戏icg\",\"106\":\"5#_10-3-有向图游戏\",\"107\":\"5#_10-4-mex运算\",\"108\":\"5#_10-5-sg游戏\",\"109\":\"5#_10-6-有向图游戏的和\",\"110\":\"5@0\",\"111\":\"5@1\",\"112\":\"6\",\"113\":\"6#_1-数组模拟链表\",\"114\":\"6#_1-1-单链表\",\"115\":\"6#_1-2-双链表\",\"116\":\"6#_2-栈\",\"117\":\"6#_2-1-普通栈\",\"118\":\"6#_2-1-单调栈\",\"119\":\"6#_3-队列\",\"120\":\"6#_3-1-普通队列\",\"121\":\"6#_3-2-单调队列\",\"122\":\"6#_4-kmp\",\"123\":\"6#_5-trie树\",\"124\":\"6#_6-并查集\",\"125\":\"6#_6-1-朴素并查集\",\"126\":\"6#_6-2-维护size的并查集\",\"127\":\"6#_6-3-维护到祖宗节点距离的并查集\",\"128\":\"6#_7-堆\",\"129\":\"6#_8-哈希表\",\"130\":\"6#_8-1-拉链法\",\"131\":\"6#_8-2-开放寻址法\",\"132\":\"6#_8-3-字符串哈希\",\"133\":\"6#_9-c-stl简介\",\"134\":\"6#_10-常用库函数\",\"135\":\"6@0\",\"136\":\"6@1\",\"137\":\"7\",\"138\":\"7#_1-区间问题\",\"139\":\"7#_1-1-区间选点\",\"140\":\"7#_1-2-最大不相交区间数量\",\"141\":\"7#_1-3-区间分组\",\"142\":\"7#_1-4-区间覆盖\",\"143\":\"7#_1-5-区间合并\",\"144\":\"7@0\",\"145\":\"7@1\",\"146\":\"9\",\"147\":\"10\",\"148\":\"11\",\"149\":\"12\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[2],\"2\":[2,4],\"3\":[3,51],\"4\":[3,48],\"5\":[3,79],\"6\":[3,55],\"7\":[2],\"8\":[3,53],\"9\":[2,74],\"10\":[5,52],\"11\":[3,84],\"12\":[3,85],\"13\":[3,67],\"14\":[2,74],\"15\":[2,61],\"16\":[2,99],\"17\":[2],\"18\":[2,78],\"19\":[3,80],\"20\":[2],\"21\":[3,80],\"22\":[null,null,1],\"23\":[null,null,1],\"24\":[2],\"25\":[2,54],\"26\":[2,58],\"27\":[2],\"28\":[3,13],\"29\":[1,30],\"30\":[1,45],\"31\":[3,36],\"32\":[2,72],\"33\":[3,25],\"34\":[2],\"35\":[3,77],\"36\":[3,106],\"37\":[3,60],\"38\":[2,72],\"39\":[2],\"40\":[3,10],\"41\":[3,15],\"42\":[3,10],\"43\":[3,13],\"44\":[2],\"45\":[3,37],\"46\":[3,138],\"47\":[3,81],\"48\":[2,25],\"49\":[2,34],\"50\":[2,27],\"51\":[null,null,1],\"52\":[null,null,1],\"53\":[2],\"54\":[2,73],\"55\":[2,7],\"56\":[1,16],\"57\":[1,23],\"58\":[2,49],\"59\":[2],\"60\":[3,34],\"61\":[4,84],\"62\":[4,76],\"63\":[7,103],\"64\":[5,88],\"65\":[4,62],\"66\":[3],\"67\":[4,31],\"68\":[2,14],\"69\":[3,106],\"70\":[4,114],\"71\":[2,80],\"72\":[2,94],\"73\":[null,null,1],\"74\":[null,null,1],\"75\":[2],\"76\":[2],\"77\":[2,26],\"78\":[3,47],\"79\":[1,34],\"80\":[3],\"81\":[5,63],\"82\":[4,56],\"83\":[5,65],\"84\":[2],\"85\":[3,27],\"86\":[2,67],\"87\":[3,27],\"88\":[2],\"89\":[3,45],\"90\":[3,63],\"91\":[2,55],\"92\":[2],\"93\":[1,61],\"94\":[2,94],\"95\":[2,83],\"96\":[2],\"97\":[3,33],\"98\":[3,85],\"99\":[5,79],\"100\":[3,74],\"101\":[3,11],\"102\":[2,81],\"103\":[2],\"104\":[3,74],\"105\":[3,17],\"106\":[3,12],\"107\":[3,11],\"108\":[3,23],\"109\":[3,22],\"110\":[null,null,1],\"111\":[null,null,1],\"112\":[2],\"113\":[2],\"114\":[2,48],\"115\":[3,35],\"116\":[2,1],\"117\":[3,20],\"118\":[3,34],\"119\":[2,2],\"120\":[3,24],\"121\":[3,38],\"122\":[2,92],\"123\":[2,40],\"124\":[2],\"125\":[3,32],\"126\":[3,26],\"127\":[3,32],\"128\":[2,87],\"129\":[2],\"130\":[3,27],\"131\":[3,23],\"132\":[3,43],\"133\":[3,142],\"134\":[2,102],\"135\":[null,null,1],\"136\":[null,null,1],\"137\":[2],\"138\":[2],\"139\":[2,54],\"140\":[3,45],\"141\":[3,62],\"142\":[3,65],\"143\":[3,64],\"144\":[null,null,1],\"145\":[null,null,1],\"146\":[1,3],\"147\":[1],\"148\":[1],\"149\":[2]},\"averageFieldLength\":[2.5799285867188426,52.25856709521882,0.18047002577370297],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"将你的个人介绍和档案放置在此处。\"]},\"1\":{\"h\":\"五、动态规划\"},\"2\":{\"h\":\"1. 背包问题\",\"t\":[\"背包问题常用枚举方法\",\"第一维枚举物品\",\"第二维枚举体积\",\"第三维枚举决策\"]},\"3\":{\"h\":\"1.1 01 背包\",\"t\":[\"有 $n$ 件物品，背包容量为 $m$ ，每件物品只能使用__一次__。\",\"求所选物品的总体积不超过背包容量的条件下，最大的总价值。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++){ for (int j = 0; j <= m; j++){ f[i][j] = f[i - 1][j]; //左半边的子集 if (v[i] <= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } cout << f[n][m] << endl; */ //一维 //f[i] 表示总体积是i的情况下，最大价值是多少 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\"]},\"4\":{\"h\":\"1.2 完全背包\",\"t\":[\"有 $n$ 件物品，背包容量为 $m$ ，每件物品只能使用__无限次__。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1100; int n, m; int v[N], w[N]; int f[N]; //表示总体积是i的情况下，最大价值是多少 int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++) for (int j = 0; j <= m; j++) { f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout << f[n][m] << endl; */ //一维 for (int i = 1; i <= n; i++) for (int j = v[i]; j <= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout << f[m] << endl; return 0; }\"]},\"5\":{\"h\":\"1.3 多重背包\",\"t\":[\"有 $n$ 件物品，背包容量为 $m$ ，每件物品有__有限个__。\",\"数据范围 $\\\\leq 100$ 的写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); cout << f[n][m] << endl; /* 一维优化写法 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[j] = max(f[j], f[j - k * v[i]] + w[i] * k); } } cout << f[m] << endl; */ return 0; }\",\"数据范围较大时，需要用多重背包的二进制优化方法：\",\"第一种写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; int f[M]; int main() { cin >> n >> m; int cnt = 0; for (int i = 1; i <= n; i++){ int a, b, s; cin >> a >> b >> s; int k = 1; while (k < s){ cnt++; v[cnt] += a * k; w[cnt] += b * k; s -= k; k *= 2; } if (s){ cnt++; v[cnt] += a * s; w[cnt] += b * s; } } n = cnt; for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\",\"第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <vector> using namespace std; const int N = 2010; int n, m; int f[N]; struct Good { int v, w; }; int main() { vector<Good> goods; cin >> n >> m; for (int i = 0; i < n; i++){ int v, w, s; cin >> v >> w >> s; for (int k = 1; k <= s; k *= 2){ s -= k; goods.push_back({v * k, w * k}); } if (s > 0) goods.push_back({v * s, w * s}); } for (auto good : goods){ for (int j = m; j >= good.v; j--){ f[j] = max(f[j], f[j - good.v] + good.w); } } cout << f[m] << endl; return 0; }\"]},\"6\":{\"h\":\"1.4 分组背包\",\"t\":[\"有 $n$ 组物品和一个容量是 $m$ 的背包。\",\"每组物品有若干个，同一组内的物品最多只能选一个。\",\"求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\",\"（一）第一种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++){ cin >> s[i]; for (int j = 0; j < s[i]; j++){ cin >> v[i][j] >> w[i][j]; } } for (int i = 1; i <= n; i++){ for (int j = m; j >= 0; j--){ for (int k = 0; k < s[i]; k++){ if (v[i][k] <= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } } cout << f[m] << endl; return 0; }\",\"（二）第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int f[N], v[N], w[N]; int main() { cin >> n >> m; for (int i = 0; i < n; i++) { int s; cin >> s; for (int j = 0; j < s; j++) cin >> v[j] >> w[j]; for (int j = m; j >= 0; j--) for (int k = 0; k < s; k++) if (j >= v[k]) f[j] = max(f[j], f[j - v[k]] + w[k]); } cout << f[m] << endl; return 0; }\"]},\"7\":{\"h\":\"2. 线性DP\"},\"8\":{\"h\":\"2.1 数字三角形\",\"t\":[\"给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。\",\" 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5\",\"线性DP写法：\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 510, INF = 1e9; int n; int a[N][N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= i; j++) cin >> a[i][j]; for (int i = 0; i <= n; i++) for (int j = 0; j <= i + 1; j++) f[i][j] = -INF; //从上往下遍历 f[1][1] = a[1][1]; for (int i = 2; i <= n; i++) for (int j = 1; j <= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; // 状态转移方程 int ans = -INF; for (int i = 1; i <= n; i++) ans = max(ans, f[n][i]); cout << ans << endl; /*从下往上遍历 for (int i = n; i >= 1; i--) for (int j = n; j >= 1; j--) f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; cout << f[1][1] << endl; */ return 0; }\"]},\"9\":{\"h\":\"2.2 最长上升子序列\",\"t\":[\"求一个序列中__严格递增的子序列的最大长度__。\",\"(一）朴素DP写法：\",\"状态转移方程：if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1010; int n; int a[N]; int f[N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) { f[i] = 1; // 只有a[1]一个数 for (int j = 1; j <= i; j++) if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1); } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f[i]); cout << ans << endl; return 0; }\",\"（二）二分写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 100010; int n; int q[N]; int a[N]; int main() { cin >> n; for (int i = 0; i < n; i++) cin >> a[i]; int len = 0; q[0] = -2e9; for (int i = 0; i < n; i++) { int l = 0, r = len; while (l < r) { int mid = l + r + 1 >> 1; if (q[mid] < a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } cout << len << endl; return 0; }\",\"（三）单调队列写法：\",\"#include <iostream> #include <cstdio> #include <vector> #include <algorithm> using namespace std; const int N = 100010; int n; int main() { cin >> n; vector<int> arr(n); for (int i = 0; i < n; i++) cin >> arr[i]; vector<int> stk; //模拟堆栈 stk.push_back(arr[0]); for (int i = 1; i < n; i++) //单调队列思维 { if (arr[i] > stk.back()) //如果该元素大于栈顶元素，则将该元素入栈 stk.push_back(arr[i]); else //否则，替换掉第一个大于或等于这个数字的那个数 *lower_bound(stk.begin(), stk.end(), arr[i]) = arr[i]; } cout << stk.size() << endl; return 0; }\"]},\"10\":{\"h\":\"2.3 最长公共子序列（不连续）\",\"t\":[\"给定两个长度分别为 $n$ 和 $m$ 的字符串 A 和 B，\",\"求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\",\"状态转移方程：\",\"f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin >> n >> m >> a + 1 >> b + 1; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i- 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"11\":{\"h\":\"2.4 最长公共上升子序列\",\"t\":[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\",\"小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\",\"小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。\",\"奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\",\"不过，只要告诉奶牛它的长度就可以了。\",\"数列 $A$ 和 $B$ 的长度均不超过 $3000$。\",\"输入格式\",\"第一行包含一个整数 $N$，表示数列 $A，B$ 的长度。\",\"第二行包含 $N$ 个整数，表示数列 $A$。\",\"第三行包含 $N$ 个整数，表示数列 $B$。\",\"输出格式\",\"输出一个整数，表示最长公共上升子序列的长度。\",\"数据范围\",\"$1≤N≤3000$ , 序列中的数字均不超过 $2^{31}−1$ 。\",\"输入样例：\",\"4 2 2 1 3 2 1 2 3\",\"输出样例：\",\"2\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 3010; int n; int a[N], b[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; for (int i = 1; i <= n; i++){ int mx = 1; for (int j = 1; j <= n; j++){ f[i][j] = f[i - 1][j]; if (a[i] == b[j]) f[i][j] = max(f[i][j], mx); if (a[i] > b[j]) mx = max(mx, f[i - 1][j] + 1); } } int res = 0; for (int i = 1; i <= n; i++) res = max(res, f[n][i]); cout << res << endl; return 0; }\"]},\"12\":{\"h\":\"2.5 编辑距离\",\"t\":[\"给定 $n$ 个长度不超过 $10$ 的字符串以及 $m$ 次询问，每次询问给出一个字符串和一个操作次数上限。\",\"对于每次询问，请你求出给定的 $n$ 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。\",\"每个对字符串进行的单个字符的插入、删除或替换算作一次操作。\",\"输入格式\",\"第一行包含两个整数 $n$ 和 $m$ 。\",\"接下来 $n$ 行，每行包含一个字符串，表示给定的字符串。\",\"再接下来 $m$ 行，每行包含一个字符串和一个整数，表示一次询问。\",\"字符串中只包含小写字母，且长度均不超过 $10$ 。\",\"输出格式\",\"输出共 $m$​ 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。\",\"模板代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 15, M = 1010; int n, m; int f[N][N]; char str[M][N]; int edit_distance(char a[], char b[]) { int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i <= la; i++) f[i][0] = i; for (int j = 0; j <= lb; j++) f[0][j] = j; for (int i = 1; i <= la; i++) for (int j = 1; j <= lb; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } return f[la][lb]; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> str[i] + 1; //下标从1开始存 while (m--){ char s[N]; int limit; cin >> s + 1 >> limit; int res = 0; for (int i = 0; i < n; i++) if (edit_distance(str[i], s) <= limit) res++; cout << res << endl; } return 0; }\"]},\"13\":{\"h\":\"2.6 最短编辑距离\",\"t\":[\"给定两个字符串 $A$ 和 $B$，现在要将 $A$ 经过若干操作变为 $B$，可进行的操作有：\",\"删除 – 将字符串 $A$ 中的某个字符删除。\",\"插入 – 在字符串 $A$ 的某个位置插入某个字符。\",\"替换 – 将字符串 $A$ 中的某个字符替换为另一个字符。\",\"现在请你求出，将 $A$ 变为 $B$​ 至少需要进行多少次操作。\",\"状态转移方程：\",\"f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1); if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]); else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; //所有将a[i]变成b[j]的操作方式 int main() { cin >> n >> a + 1; cin >> m >> b + 1; for (int i = 0; i <= n; i++) f[i][0] = i; for (int j = 0; j <= m; j++) f[0][j] = j; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"14\":{\"h\":\"3. 区间DP\",\"t\":[\"区间 DP 常用模版\",\"所有的区间dp问题枚举时，\",\"第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；\",\"第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）\",\"模板代码如下：\",\"for (int len = 1; len <= n; len++) { // 区间长度 for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点 int j = i + len - 1; // 区间终点 if (len == 1) { dp[i][j] = 初始值 continue; } for (int k = i; k < j; k++) { // 枚举分割点，构造状态转移方程 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); } } }\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 310; int n; int a[N], s[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> a[i]; s[i] = s[i - 1] + a[i]; } //区间DP枚举套路：长度+左端点 for (int len = 2; len <= n; len++) //先枚举长度 { for (int i = 1; i + len - 1 <= n; i++) //再枚举左端点，且保证右端点不会超范围 { int j = i + len - 1; //自动得到右端点 f[i][j] = 1e9; //初始化大于1的区间为最大，长度为1的区间为0 for (int k = i; k <= j - 1; k++) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]); } } //得到总区间的最小代价 cout << f[1][n] << endl; return 0; }\"]},\"15\":{\"h\":\"4. 计数类DP\",\"t\":[\"一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。\",\"表示前i个整数（1,2…,i）恰好拼成j的方案数 求方案数：把集合选0个i，1个i，2个i，…全部加起来\",\"f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"因此 $f[i][j]=f[i−1][j]+f[i][j−i];$ (这一步类似完全背包的推导）\",\"朴素做法：\",\"// f[i][j] = f[i - 1][j] + f[i][j - i] #include <iostream> using namespace std; const int N = 1e3 + 7, mod = 1e9 + 7; int f[N][N]; int main() { int n; cin >> n; for (int i = 0; i <= n; i ++) { f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 } for (int i = 1; i <= n; i ++) { for (int j = 0; j <= n; j ++) { f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1 if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod; } } cout << f[n][n] << endl; }\",\"一维优化：\",\" f[0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 for (int i = 1; i <= n; i ++) { for (int j = i; j <= n; j ++) { f[j] = (f[j] + f[j - i]) % mod; } } cout << f[n] << endl;\"]},\"16\":{\"h\":\"5. 数位统计类DP\",\"t\":[\"给定两个整数 a 和 b，求 a 和 b 之间的所有数字中0~9的出现次数。\",\"#include <bits/stdc++.h> using namespace std; int base[10]; int f[10][10]; int g[10][10]; void init() { base[0] = 1; for(int i = 1 ; i <= 9 ; i++) base[i] = base[i-1]*10; //从00……0 - 99……9 的各位数字有多少个，其中i为数字个数（包含前导零） for(int i = 0 ; i <= 9 ; i++) f[1][i] = 1; for(int i = 2 ; i <= 9 ; i++) for(int j = 0 ; j <= 9 ; j++) f[i][j] = f[i-1][j]*10 + base[i-1]; //从1 - 99……9 的各位数字有多少个，其中i为数字个数（不包含前导零） for(int i = 1 ; i <= 9 ; i++) g[1][i] = 1;//循环从1开始 for(int i = 2 ; i <= 9 ; i++) { g[i][0] = g[i-1][0] + f[i-1][0]*9; for(int j = 1 ; j <= 9 ; j++) g[i][j] = g[i-1][j] + f[i-1][j]*9 + base[i-1]; } } vector<int> dp(int n) { vector<int> ans(10,0); //记录答案 if(n<=0) return ans; //边界条件 vector<int> nums; while(n) nums.push_back(n%10), n/=10; vector<int> last(10,0); //记录前缀中各个数字个数 //统计1 - 99……9(n-1个9)里面各个数字有多少个 for(int i = 0 ; i <= 9 ; i++) ans[i] = g[nums.size()-1][i]; //统计大于10……0(n-1个0) 的树里各个数字有多少个 for(int i = nums.size()-1 ; i >=0 ; i--) { //循环变量i可以表示剩下的数字有多少个 int x = nums[i]; for(int j = i==nums.size()-1 ; j < x ; j++) { //第一次循环不能有0 //前缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k] * base[i]; //当前位置部分 ans[j] += base[i]; //后缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += f[i][k]; } //更新前缀计数器 last[x] ++; //统计叶子节点（这个数本身） if(!i) for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k]; } return ans; } vector<int> ask(int a, int b) { auto x = dp(b); auto y = dp(a-1); vector<int> ans; for(int i = 0 ; i <= 9 ; i++) ans.push_back(x[i]-y[i]); return ans; } void print(vector<int> ans) { for(auto x:ans) printf(\\\"%d \\\",x); puts(\\\"\\\"); } bool check(int x) { auto t = ask(x,x); vector<int> cnt(10,0); while(x) cnt[x%10]++,x/=10; for(int i = 0 ; i <= 9 ; i++) if(cnt[i] != t[i]) return false; return true; } int main() { init(); int a,b; while(cin >> a >> b, a||b) { if(a>b) swap(a,b); auto t = ask(a,b); print(t); } return 0; }\"]},\"17\":{\"h\":\"6. 状态压缩类DP\"},\"18\":{\"h\":\"6. 1\",\"t\":[\"$n×m$ 的棋盘可以摆放不同的 $1×2$ 小方格的种类数。\",\"状态表示：$f[i][j]$ 表示当前摆到第 $i$ 列的状态是 $j$ 的所有方案。\",\"(其中 $j$ 是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。)\",\"去除无效状态的优化写法：\",\"#include <cstring> #include <iostream> #include <algorithm> #include <vector> using namespace std; typedef long long LL; const int N = 12, M = 1 << N; int n, m; LL f[N][M]; vector<int> state[M]; bool st[M]; int main() { while (cin >> n >> m, n || m) { for (int i = 0; i < 1 << n; i ++ ) { int cnt = 0; bool is_valid = true; for (int j = 0; j < n; j ++ ) if (i >> j & 1) { if (cnt & 1) { is_valid = false; break; } cnt = 0; } else cnt++; if (cnt & 1) is_valid = false; st[i] = is_valid; } for (int i = 0; i < 1 << n; i ++ ) { state[i].clear(); for (int j = 0; j < 1 << n; j ++ ) if ((i & j) == 0 && st[i | j]) state[i].push_back(j); } memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i <= m; i ++ ) for (int j = 0; j < 1 << n; j ++ ) for (auto k : state[j]) f[i][j] += f[i - 1][k]; cout << f[m][0] << endl; } return 0; }\"]},\"19\":{\"h\":\"6. 2 最短Hamilton路径\",\"t\":[\"给定一张 $n$ 个点的带权无向图，点从 $0$ ~ $n-1$ 标号，求起点 $0$ 到终点 $n-1$ 的最短Hamilton路径。\",\"Hamilton路径的定义是从 $0$ 到 $n-1$ 不重不漏地经过每个点恰好一次。\",\"$f[i][j]$ 表示从 $0$ 走到 $j$ ，走过的所有点的情况是 $i$ 的所有路径。\",\"状态转移方程：f[i][j] = min(f[i][j], f[i-(1<<j)][k] + w[k][j]);\",\"#include<iostream> #include<cstring> #include<algorithm> using namespace std; const int N = 20, M = 1 << N; int n; int f[M][N], w[N][N];//w表示的是无权图 int main() { cin>>n; for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) cin >> w[i][j]; memset(f, 0x3f, sizeof(f)); // 因为要求最小值，所以初始化为无穷大 f[1][0] = 0; // 因为零是起点,所以f[1][0]=0; for (int i = 0; i < 1 << n; i++) // i表示所有的情况 for (int j = 0; j < n; j++) // j表示走到哪一个点 if (i >> j & 1) for (int k = 0; k < n; k++) // k表示走到j这个点之前,以k为终点的最短距离 if (i >> k & 1) // 更新最短距离 f[i][j] = min(f[i][j], f[i - (1<<j)][k] + w[k][j]); // 表示所有点都走过了,且终点是n-1的最短距离 cout << f[(1<<n) - 1][n - 1] << endl; return 0; }\"]},\"20\":{\"h\":\"7. 树形DP\"},\"21\":{\"h\":\"7. 1 没有上司的舞会\",\"t\":[\"选了某个节点就不能选父节点和子节点。求最大权值和。\",\"每个人只有两种状态，则设 $dp[0][i]$ 为第 $i$ 个人不来，他的下属所能获得的最大快乐值；\",\"$dp[1][i]$ 为第 $i$ 个人来，他的下属所能获得的最大快乐值。\",\"状态转移方程：\",\"$dp[0][i]=∑{u=sons}max(dp[1][u],dp[0][u])$ 当前节点不选，那么子节点随意\",\"$dp[1][i]=∑u=sonsdp[0][u]+happy[i]$ 当前节点选，子节点不能选\",\"#include <bit/stdc++.h> using namespace std; int n; int dp[2][6010]; int f[2][6010]; // f[0]为父亲，f[1]为高兴值 int ind[6010]; // 入度 int vis[6010]; // 访问标记 int root; // 树的根 void dfs(int u) // 递归从后往前更新 { if (!u) return; vis[u] = 1; // 已访问 root = u; // 最后一个访问到的一定是根，所以一直更新根就行了 dp[0][f[0][u]] += max(dp[1][u] + f[1][u], dp[0][u]); // 给父亲更新 dp[1][f[0][u]] += dp[0][u]; ind[f[0][u]]--; // 更新完一个子节点 if(!ind[f[0][u]]) dfs(f[0][u]); // 在所有子节点更新后再更新（入度为0） } int main() { cin >> n; for (int i = 1; i <= n; i++) scanf(\\\"%d\\\", &f[1][i]); int a,b; for (int i = 1; i < n; i++){ scanf(\\\"%d%d\\\", &a, &b); f[0][a] = b; // 保存节点信息 ind[b]++; } for (int i = 1; i <= n; i++) if(!vis[i] && !ind[i]) // 没有被访问过，没有入度，说明是叶子节点 dfs(i); // 取根节点两种方案的最大值 printf(\\\"%d\\\\n\\\", max(dp[0][root], dp[1][root] + f[1][root])); return 0; }\"]},\"22\":{\"c\":[\"algorithm\"]},\"23\":{\"c\":[\"ACM\"]},\"24\":{\"h\":\"一、基础算法\"},\"25\":{\"h\":\"1. 快速排序\",\"t\":[\"快排属于分治算法，分治算法都有三步：\",\"分成子问题\",\"递归处理子问题\",\"子问题合并\",\"主要步骤：\",\"确定分界点，可以任选 a[l]，a[r]，a[(l + r) / 2] 其中一个作为分界点。\",\"设置两个头尾指针 i, j，初始化 i = l - 1, j = r + 1 (避免发生边界问题导致死循环) ，向中间移动。每次循环都先将 i 右移和 j 左移，然后判断，如果 a[i] > a[j] 且 i < j，就交换 a[i] 和 a[j].\",\"最后根据分界点分别递归左右两部分。\",\"快排的一般写法如下：\",\"void quick_sort(int q[], int l, int r) { //递归的终止情况 if(l >= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[(l + r) / 2]; while(i < j) { do i++; while(q[i] < x); do j--; while(q[j] > x); if(i < j) swap(q[i], q[j]); } //第二步：递归处理子问题 quick_sort(q, l, j); quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤 }\"]},\"26\":{\"h\":\"2. 归并排序\",\"t\":[\"运用双指针的思想，先递归再合并。\",\"主要步骤：\",\"确定分界点。与快排不同，归并每次都将中点作为分界点，将整个序列均分为两部分。mid = (l + r) / 2\",\"递归排序。对两个子序列分别设置个指针 i, j，从头开始遍历，每次比较 a[i] 和 a[j]，将小的放入一个临时序列 temp[] 中。如果有一部分遍历完了，而另一部分还有剩余，则将剩余那一部分直接接在临时序列的后面，因为剩下的这部分一定是大于前面的。\",\"归并，合二为一。将临时序列放入原序列中。\",\"归并的一般写法如下：\",\"void merge_sort(int a[], int l, int r) { if (l >= r) return; //确定中间分界点 int mid = (l + r) >> 1; //两边递归 merge_sort(a, l, mid); merge_sort(a, mid + 1, r); int k = 0; int i = l, j = mid + 1; //比较左右两半边 while (i <= mid && j <= r) if (a[i] < a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; while (i <= mid)//左半边剩下的 temp[k++] = a[i++]; while (j <= r)//右半边剩下的 temp[k++] = a[j++]; //合并区间 for (i = l, j = 0; i <= r; i++, j++) a[i] = temp[j]; }\"]},\"27\":{\"h\":\"3. 二分算法\"},\"28\":{\"h\":\"3.1 二分查找算法模板\",\"t\":[\"二分模板一共有两个，分别适用于不同情况。\",\"算法思路：假设目标值在闭区间 [l, r]中， 每次将区间长度缩小一半，当 l = r时，我们就找到了目标值。\"]},\"29\":{\"h\":\"版本1\",\"t\":[\"当我们将区间 [l, r] 划分成 [l, mid] 和 [mid + 1, r] 时，其更新操作是 r = mid 或者 l = mid + 1; ，计算 mid 时不需要加 1。\",\"C++代码模板：\",\"int bsearch_1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (a[mid] >= x) r = mid; //答案在左边界，要向下取整 else l = mid + 1; //找左端点 } return l; }\"]},\"30\":{\"h\":\"版本2\",\"t\":[\"当我们将区间 [l, r] 划分成 [l, mid - 1] 和 [mid, r] 时，其更新操作是 r = mid - 1 或者 l = mid; ，此时为了防止死循环，计算 mid 时需要加 1。\",\"C++代码模板：\",\"int bsearch_2(int l, int r) { while (l < r) { int mid = l + r + 1 >> 1; if (a[mid] <= k) l = mid; //答案在右边界，要上取整 else r = mid - 1; //找右端点 } return l; }\",\"简单来说就是：\",\"可以将模板 1 中的 check[mid] 换成a[mid] >= x ，用来查找大于等于 x 的第一个元素；\",\"将模板 2 中的 check[mid] 换成 a[mid] <= x ，用来查找小于等于 x 的最后一个元素。\"]},\"31\":{\"h\":\"3.2 二分答案模板\",\"t\":[\"一般来说，二分答案可以用来处理 “最大的最小” 或 “最小的最大” 的问题。\",\"定义区间为闭区间 [l, r] ，每次只需判断答案是否需要更新（是否记下ans）和（可能的）答案在哪一侧（改 L 还是 R ）即可。\",\"int ans; int find(int l, int r) { while (l <= r) { int mid = l + r >> 1; if (check(mid)){ ans = mid; //如果条件成立则记下答案 r = mid - 1; //判断可能的答案更新区间 } else l = mid + 1; } return ans; }\"]},\"32\":{\"h\":\"3.3 整数二分\",\"t\":[\"【例二】A-B 数对\",\"题目描述：给出一串数以及一个数字 C ，要求计算出所有 A - B = C 的数对的个数（不同位置的数字一样的数对算不同的数对）。\",\"这里使用库函数二分的写法：\",\"依次枚举 A ，将问题转变成统计数列中 B + C 出现了多少次。先对数列排序，那么 B + C 会对应这个数列的连续一段，只要找到这个连续段的左端点和右端点即可。(需使用头文件 algorithm )\",\"① lower_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 第一次出现的位置；\",\"② upper_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 最后一次出现的位置的__后面一位__ 。\",\"则这个数出现的次数就可以表示为 upper_bound() - lower_bound() ，时间复杂度为 O(nlogn).\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; const int N = 2e5 + 10; int n, c; ll a[N]; int main() { cin >> n >> c; for (int i = 0; i < n; i++) cin >> a[i]; sort(a, a + n); ll tot = 0; for (int i = 0; i < n; i++) tot += upper_bound(a, a + n, a[i] + c) - lower_bound(a, a + n, a[i] + c); cout << tot << endl; return 0; }\"]},\"33\":{\"h\":\"3.4 浮点数二分\",\"t\":[\"bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l > eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; }\"]},\"34\":{\"h\":\"4. 高精度算法\"},\"35\":{\"h\":\"4.1 高精度加法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的和。 （C = A + B，A >= 0， B >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; const int N = 1e6 + 10; // C = A + B vector<int> add(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; int t = 0; //进位，低位满10向高位进位，低位变为0 for (int i = 0; i < A.size() || i < B.size(); i++){ //两个if把两个数组相同位上的数相加 if (i < A.size()) t += A[i]; if (i < B.size()) t += B[i]; //把相加后的结果除以10求余，压入C数组中 C.push_back(t % 10); //t再除以10，放入高位 t /= 10; } //如果最高位有数，则压入C数组中 if (t) C.push_back(t); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //使用auto编译器会自动判断数据是什么类型 auto C = add(A, B); for (int i = C.size() - 1; i >= 0; i--) printf(\\\"%d\\\", C[i]); return 0; }\"]},\"36\":{\"h\":\"4.2 高精度减法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的差，计算结果可能为负数。\",\"1、前提： C = A - B，满足 A >= B，A >= 0，B >= 0 （如果 B >= A，则将其转化为 -(B - A) ）\",\"2、代码段：(只考虑正数的情况)\",\"#include <iostream> #include <vector> using namespace std; //判断是否有 A >= B bool cmp(vector<int> &A, vector<int> &B) { //A长度不等于B，若A大于B，返回true，否则返回false if (A.size() != B.size()) return A.size() > B.size(); //因为是倒序数组，高位在后面，所以从后遍历 //如果A > B, 返回true，否则返回flase for (int i = A.size() - 1; i >= 0; i--){ if (A[i] != B[i]) return A[i] > B[i]; } return true; } // C = A - B vector<int> sub(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; //定义一个借位的情况 int t = 0; for (int i = 0; i < A.size(); i++){ //t = A的这一位数 t = A[i] - t; //判断B在这一位上有没有数，如果有，则减去B[i] if (i < B.size()) t -= B[i]; //这种写法包含了两种情况：如果t >= 0, 则直接减；若t < 0, 则向高位借位(即t + 10)后再减 //将这一位相减后的结果压入C中 C.push_back((t + 10) % 10); if (t < 0) //t < 0，需要借位，标记为1 t = 1; else //t >= 0，不需要借位，标记为0 t = 0; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //如果A > B，返回A - B if (cmp(A, B)){ auto C = sub(A, B); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", C[i]); } //否则返回 -(B - A) else { auto C = sub(B, A); printf(\\\"-\\\"); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", c[i]); } return 0; }\"]},\"37\":{\"h\":\"4.3 高精度整数乘法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A × B 的值\",\"一般是 高精 × 低精，用 A × b 表示 （C = A * b，A >= 0，b >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; //C = A * b vector<int> mul(vector<int> &A, int b) { vector<int> C; int t = 0; for (int i = 0; i < A.size() || t; i++) { if (i < A.size()) t += A[i] * b; //同加法一样处理进位，逐位压入数组中 C.push_back(t % 10); t /= 10; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int b; cin >> a >> b; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) //倒序插入 A.push_back(a[i] - '0'); auto C = mul(A, b); for (int i = C.size() - 1; i >= 0; i--) //倒序输出 printf(\\\"%d\\\", C[i]); return 0; }\"]},\"38\":{\"h\":\"4.4 高精度整数除法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A / B 的商和余数 (第一行输出所求的商，第二行输出所求余数)\",\"一般是 高精 ÷ 低精，用 A ÷ b 表示 （A / b = C ··· r，A >= 0，b > 0）\",\"代码如下：\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; vector<int> div(vector<int> &A, int b, int &t) //传入t的地址，便于直接对余数进行处理 { vector<int> C; t = 0; for (int i = A.size() - 1; i >= 0; i--) { //将上次的余数×10再加上当前位的数字，得到该位的被除数 t = t * 10 + A[i]; //所得即为商在这一位的数字 C.push_back(t / b); t %= b; } //由于在除法运算中，从高位到低位运算，因此前导0在数组前面，所以需要将其翻转，将前导0置于尾部，从而便于删除前导0 reverse(C.begin(), C.end()); //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int B; cin >> a >> B; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); int t; //t为余数 auto C = div(A, B, t); for (int i = C.size() - 1; i >= 0; i--) cout << C[i]; cout << endl << t << endl; return 0; }\"]},\"39\":{\"h\":\"5. 前缀和与差分\"},\"40\":{\"h\":\"5.1 一维前缀和\",\"t\":[\"S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1]\"]},\"41\":{\"h\":\"5.2 二维前缀和\",\"t\":[\"S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\"]},\"42\":{\"h\":\"5.3 一维差分\",\"t\":[\"给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\"]},\"43\":{\"h\":\"5.4 二维差分\",\"t\":[\"给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\"]},\"44\":{\"h\":\"6. 位运算\"},\"45\":{\"h\":\"6.1 位运算符\",\"t\":[\"位运算符作用于位，并逐位执行操作。\",\"符号\",\"描述\",\"运算规则\",\"&\",\"与\",\"两个位都为1时，结果才为1\",\"|\",\"或\",\"两个位都为0时，结果才为0\",\"^\",\"异或\",\"两个位相同为0，不同为1\",\"~\",\"取反\",\"0变1，1变0\",\"<<\",\"左移\",\"各二进位全部左移若干位，高位丢弃，低位补0\",\">>\",\"右移\",\"各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）\"]},\"46\":{\"h\":\"6.2 用途\",\"t\":[\"1、按位与 (&)\",\"运算规则（全为 1，才为1）\",\"0 & 0 = 0\",\"0 & 1 = 0\",\"1 & 0 = 0\",\"1 & 1 = 1\",\"注意：负数按补码形式参加按位与运算。\",\"（1）清零\",\"如果想将一个单元清零，使其全部二进制位为 0，只要__与一个各位都为零的数值相与__，结果为零。\",\"（2）取一个数的指定位\",\"比如取数 X = 1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位与运算（X & Y = 0000 1110）即可得到 X 的指定位。\",\"（3）判断奇偶\",\"只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a & 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。\",\"2、按位或 (|)\",\"运算规则（全为 0，才为 0）\",\"0 | 0 = 0\",\"0 | 1 = 1\",\"1 | 0 = 1\",\"1 | 1 = 1\",\"（1）常用来对一个数据的某些位设置为1\",\"比如将数 X = 1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位或运算（X | Y = 1010 1111）即可得到。\",\"3、按位异或 (^)\",\"运算规则（相同为 0，不同为 1）\",\"0 ^ 0 = 0\",\"0 ^ 1 = 1\",\"1 ^ 0 = 1\",\"1 ^ 1 = 0\",\"（1）翻转指定位\",\"比如将数 X = 1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行异或运算（X ^ Y = 1010 0001）即可得到。\",\"（2）与 0 相异或值不变\",\"例如：1010 1110 ^ 0000 0000 = 1010 1110\",\"（3）交换两个数\",\"当 x == y 时，直接异或运算进行整数交换后，会导致 x = 0, y = x.\",\"为避免这种情况，必须首先判断两个数是否相等。\",\"void swap(int &a, int &b){ if (a != b){ a ^= b; b ^= a; a ^= b; } }\",\"4、按位取反 (~)\",\"运算规则（0 变 1，1 变 0）\",\"~1 = 0\",\"~0 = 1\",\"（1）使一个数的最低位为 0\",\"使 x 的最低位为 0，可以表示为：a & ~1 。~1 的值为 1111 1111 1111 1110 ，再按 与 运算，最低位一定为 0。因为 ~ 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。\",\"5、左移 (<<)\",\"定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\",\"设 a = 1010 1110，a = a << 2 将 a 的二进制位 左移2位、右补0，即得 a = 1011 1000。\",\"若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2 。比如 左移 k 位，即乘上 2k .\",\"6、右移 (>>)\",\"定义：将一个数的各二进制位全部右移若干位，正数左补 0 ，负数左补 1 ，右边丢弃。\",\"例如：a = a >> 2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。\",\"操作数每右移一位，相当于该数除以 2。比如 右移 k 位，即除以 2k .\",\"bit_operation\"]},\"47\":{\"h\":\"6.3 例题\",\"t\":[\"【例题一】n 的二进制表示中第 k 位数\",\"思路：先把第 k 位数字移动到最后一位，n 右移 k 位，即 n >> k ，再看个位是几，用 n & 1 ，合并两步后，即 n >> k & 1 .\",\"例如求 10 的二进制表示，代码如下：\",\"#include <iostream> using namespace std; int main() { int n = 10; //10的二进制表示为4位数 for (int k = 3; k >= 0; k--) cout << (n >> k & 1); return 0; }\",\"输出如下：\",\"1010\",\"【例题二】二进制中1的个数\",\"给定一个长度为 1 的数列，请你求出数列中每个数的二进制表示中 1 的个数。\",\"输入格式\",\"第一行包含整数 n .\",\"第二行包含 n 个整数，表示整个数列\",\"输出格式\",\"共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。\",\"思路：使用 lowbit(x) 来解决，其表达式为 x & -x ，其中 -x 表示补码，即源码取反加 1 ，-x = (~x + 1)。 作用：返回 x 的最后一位 1，比如 x = 1010, 则 lowbit(x) = 10 ，x = 101000, 则 lowbit(x) = 1000 .\",\"代码如下：\",\"#include <iostream> using namespace std; const int N = 100010; int lowbit(int x) { return x & -x; } int main() { int n; cin >> n; while (n--){ int x; cin >> x; int res = 0; while (x){ x -= lowbit(x); res++; } cout << res << \\\" \\\"; } return 0; }\"]},\"48\":{\"h\":\"7. 双指针算法\",\"t\":[\"for (int i = 0, j = 0; i < n; i++) { while (j < i && check(i, j)) j++; // 具体问题的逻辑 // 例如求长度 res = max(res, i - j + 1); } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\"]},\"49\":{\"h\":\"8. 离散化\",\"t\":[\"vector<int> alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l < r) { int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n }\"]},\"50\":{\"h\":\"9. 区间合并\",\"t\":[\"// 将所有存在交集的区间合并 void merge(vector<PII> &segs) { vector<PII> res; sort(segs.begin(), segs.end()); int L = -2e9, R = -2e9; for (auto seg : segs) if (R < seg.first) { if (st != -2e9) res.push_back({L, R}); L = seg.first, R = seg.second; } else R = max(R, seg.second); if (L != -2e9) res.push_back({L, R}); segs = res; }\"]},\"51\":{\"c\":[\"algorithm\"]},\"52\":{\"c\":[\"ACM\"]},\"53\":{\"h\":\"三、搜索与图论\"},\"54\":{\"h\":\"1. 树与图的存储\",\"t\":[\"(1) 邻接矩阵：g [a] [b] 存储边 a -> b\",\"(2) 动态邻接矩阵：\",\"int n; struct Edge { int id, w; }; vector<Edge> h[N]; int dist[N]; void dfs(int u, int father, int distance) { dist[u] = distance; for (auto node : h[u]) if (node.id != father) dfs(node.id, u, distance + node.w); } int main() { scanf(\\\"%d\\\", &n); for (int i = 0; i < n - 1; i ++ ) { int a, b, c; scanf(\\\"%d%d%d\\\", &a, &b, &c); h[a].push_back({b, c}); h[b].push_back({a, c}); } dfs(1, -1, 0); // 寻找两点之间的最大距离 int u = 1; for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; dfs(u, -1, 0); for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; int s = dist[u]; printf(\\\"%lld\\\\n\\\", s * 10 + s * (s + 1ll) / 2); return 0; }\",\"(3) 邻接表：\",\"int n, m; //n代表点数，m代表边数 // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a->b void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } // 初始化 idx = 0; memset(h, -1, sizeof h); //存边 for (int i = 0; i < n; i++){ int a, b; cin >> a >> b; add(a, b); //无向图就再写一遍 add(b, a) }\"]},\"55\":{\"h\":\"2. 树与图的遍历\",\"t\":[\"时间复杂度 O(n + m), n 表示点数， m 表示边数\"]},\"56\":{\"h\":\"深度优先遍历\",\"t\":[\"int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } }\"]},\"57\":{\"h\":\"宽度优先遍历\",\"t\":[\"queue<int> q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } }\"]},\"58\":{\"h\":\"3. 拓扑排序\",\"t\":[\"时间复杂度 O(n+m), n 表示点数，m 表示边数\",\"1、图的拓扑序列是针对于有向图而言的，无向图是没有拓扑序列的。有向无环图被称为拓扑图。\",\"2、结论：一个有向无环图，一定至少存在一个入度为 0 的点。\",\"bool topsort() { //采用数组模拟队列的写法，头尾指针 int hh = 0, tt = -1; // d[i] 存储点i的入度，起点的入度为0 for (int i = 1; i <= n; i++) if (!d[i]) //如果不是起点 q[++tt] = i; while (hh <= tt) { int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (--d[j] == 0) q[++tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; }\"]},\"59\":{\"h\":\"4. 最短路问题\"},\"60\":{\"h\":\"4.1 单源最短路\",\"t\":[\"求从一个点到其他所有点的最短距离。\",\"分为两大类：\",\"1、所有边权都是正数（n 个点，m 条边）\",\"朴素版的Dijkstra算法，时间复杂度为 O(n2 + m) ，适合稠密图（边多，点少边比较多）\",\"堆优化版的Dijkstra算法，时间复杂度为 O(mlogn)，适合稀疏图（点多，指边相对于点不多，m 和 n 是同一个级别的类型）\",\"2、存在负权边\",\"Bellman-Ford 算法，时间复杂度为 O(nm)\",\"SPFA 算法，时间复杂度一般为 O(m)，最坏情况为 O(nm)，是Bellman-Ford算法的优化\"]},\"61\":{\"h\":\"4.1.1 朴素版 Dijkstra算法\",\"t\":[\"稠密图用邻接矩阵，稀疏图用邻接表\",\"1.逐个遍历，找到与起点最近的且未确定最短路径的点，访问加入集合并标记。\",\"2.更新第一个点到起点的最短距离，直到第n个点。\",\"__时间复杂度是 O(n2 + m)， n 表示点数，m 表示边数 __\",\"#include <iostream> #include <cstring> #include <algortihm> using namespace std; const int N = 510; int n, m; //点数和边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { //距离都初始化为无穷大 memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i < n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 //遍历n个点，找到一个未加入集合且距离最近的点 for (int j = 1; j <= n; j ++ ) if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; st[t] = true; //标记为已加入到集合中 // 用t更新其他点的距离 for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); } //如果为无穷大，说明不连通，无法形成最短路 if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { cin >> n >> m; //邻接矩阵初始化为无穷大 memset(g, 0x3f, sizeof(g)); while (m--){ int a, b, c; cin >> a >> b >> c; //存入a和b两点之间的距离（有向图） g[a][b] = min(g[a][b], c); //无向图 //g[a][b] = min(g[a][b], c); //g[b][a] = min(a[a][b], c); } cout << dijkstra() << endl; return 0; }\"]},\"62\":{\"h\":\"4.1.2 堆优化版的Dijkstra算法\",\"t\":[\"稀疏图改用__邻接表__的形式存储，可以不需要考虑重边\",\"时间复杂度是 O(mlogn)， n 表示点数，m 表示边数\",\"#define PII pair<int, int> int n; //点的数量 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //存储所有点到1号点的距离 bool st[N]; //存储每个点的最短距离是否已确定 void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; //定义一个小根堆 priority_queue<PII, vector<PII>, greater<PII>> heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"63\":{\"h\":\"4.1.3 Bellman-ford算法（存在负权边）\",\"t\":[\"1.可以用结构体存储点和边，包括负权边。\",\"2.具体步骤：两重 for 循环，迭代 n-1 次，每次备份一下，每次循环遍历所有边，更新两点之间的最短距离，如点 a->b 的更新方式为（松弛操作）\",\"for n 次 for 所有边 a, b, w (松弛操作) dist[b] = min(dist[b], backup[a] + w);\",\"backup[ ] 数组是上一次迭代后 dist[ ] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[ ] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点。\",\"3.循环 n-1 次之后，对于所有的点都 一定满足 dist[b] <= dist[a] + w，该式被称为三角不等式。\",\"4.如果图中存在负权回路，那么最短路可能为负无穷。（不是一定）\",\"5.是否能到达 n 号点的判断中需要进行 if(dist[n] > INF/2) 判断，而并非是 if(dist[n] == INF) 判断，原因是 INF 是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，``dist[n]大于某个与INF` 相同数量级的数即可。\",\"6.bellman-ford算法擅长解决有边数限制的最短路问题。\",\"时间复杂度 O(nm)， n 表示点数，m 表示边数\",\"int n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i < n; i ++ ) { for (int j = 0; j < m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] > dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] > 0x3f3f3f3f / 2) return -1; return dist[n]; }\"]},\"64\":{\"h\":\"4.1.4 SPFA算法 （存在负权边）\",\"t\":[\"1.用队列来存储\",\"2.while queue 不为空，\",\"取出作为 t ，t = q.front; q.pop();\",\"更新 t 的所有出边，如：t -> b, 把b加入 queue\",\"3.基本步骤\",\"建立一个队列，初始时队列里只有起始点\",\"再建立一个数组记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到它本身的路径赋为0）\",\"再建立一个数组，标记点是否在队列中\",\"队头不断出队，计算起始点经过队头到其他点的距离是否变短，如果变短且该点不在队列中，则把该点加入到队尾\",\"重复执行直到队列为空\",\"在保存最短路径的数组中，就得到了最短路径\",\"4.SPFA求最短路\",\"时间复杂度 平均情况下 O(m)， 最坏情况下 O(nm)， n 表示点数， m 表示边数\",\"int n, m; // 总点数和总边数 int h[N], e[M], w[M], ne[M], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 int add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue<int> q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"65\":{\"h\":\"4.1.5 SPFA算法判断图中是否存在负环\",\"t\":[\"时间复杂度 O(nm)， n 表示点数， m 表示边数\",\"int n; //总点数 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //dist[x]存储1号点到x的最短距离， int cnt[N]; //cnt[x]存储1到x的最短路中经过的点数 bool st[N]; //存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue<int> q; for (int i = 1; i <= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (cnt[j] >= n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; }\"]},\"66\":{\"h\":\"4.2 多源汇最短路\"},\"67\":{\"h\":\"4.2.1 Floyd算法\",\"t\":[\"1.使用邻接矩阵存图\",\"2.三重循环，时间复杂度O(n^3)\",\"初始化： for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (i == j) d[i][j] = 0; else d[i][j] = INF; //算法结束后，d[a][b]表示a到b的距离 for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\"]},\"68\":{\"h\":\"5. 最小生成树问题\",\"t\":[\"最小生成树就是将 n 个顶点， n - 1 条边，通过一个连接起来，且使权值最小的一种结构。\",\"换句话来说，就是给定一个无向图，在图中选择若干条边把图中的所有节点连接起来，要求边长之和最小。在图论中，叫做求最小生成树。\"]},\"69\":{\"h\":\"5.1 朴素Prim算法\",\"t\":[\"可理解为 “加点法”， 每次迭代找到不在连通块中的距离最近的点，加入到连通块中，将连通块逐渐扩大，最后将整个图连通起来，并且边长之和最小。\",\"1、先把所有距离初始化为正无穷\",\"dist[i] = +INF;\",\"2、n次迭代，找到不在集合当中的最小的点，这个集合指当前已经在连通块中的所有点，找到该点赋给 t ，用 t 更新其他点到集合的距离，再把 t 加到集合当中去\",\"先累加，再更新\",\"for (int i = 0; i < n; i++) t <- 距离最近的点; t = ture;更新t\",\"时间复杂度为 O(n2 + m)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> #define ll long long using namespace std; const int N = 1e5 + 10, M = N * 2; int n, m; // n表示点数，m表示边数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; //最小生成树所有边的长度之和 for (int i = 0; i < n; i++) { int t = -1; for (int j = 1; j <= n; j++) //如果没有在树中，且到树的距离最短，则选择该点 if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; //一定要先累加，再进行更新生成树 if (i && dist[t] == INF) return INF; if (i) //(不是起点)把找到的符合条件的点的长度加上 res += dist[t]; st[t] = true; for (int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { cin >> n >> m; memset(g, 0x3f, sizeof g); for (int i = 1; i <= m; i++){ int a, b, c; cin >> a >> b >> c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(\\\"impossible\\\"); else printf(\\\"%d\\\\n\\\", t); }\"]},\"70\":{\"h\":\"5.2 Kruskal 算法\",\"t\":[\"可理解为 “加边法”，最初最小生成树的边数为 0，每次迭代选择一条不在集合内的权值最短的边，加入到集合中，组成最小生成树。\",\"1、使用快排将所有边按权值从小到大排序。时间复杂度为 O(log n).\",\"2、从小到大依次枚举每组边 a 、b，权重 c ，如果 a、b不连通，就将这条边加入集合中，直到具有 n 个顶点的连通块筛选出来 n-1 条边为止。时间复杂度为 O(n) .\",\"3、判断 a、b是否连通的方法为：使用并查集。\",\"初始化各个顶点在不同的集合中，父节点为它自己。\",\"按快排的从小到大的顺序遍历每条边，判断这条边的两个顶点是否有相同的父节点，如果有那就使在同一个集合中。\",\"如果该条边上的两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则加入这条边到集合中，连通这两个顶点。\",\"时间复杂度是 O(mlogm)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> using namespace std; const int N = 2e5 + 10; int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 int rank[N]; // 树的高度 //结构体存储 两点及其权值 struct Edge { int a, b, w; //重载小于号，因为再给边排序的时候是按照边的权重进行排序的，这样当两个边进行比较的时候就会使用他们的权重进行比较了 bool operator< (const Edge &W)const { return w < W.w; } }edges[M]; void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int x, int y) { int px = find(x), py = find(y); if (px == py) return; if (rank[px] < rank[py]){ p[px] = py; } else { p[py] = px; if (rank[px] == rank[py]) rank[px]++; } } int kruskal() { sort(edges, edges + m); init(n); int res = 0; //存的是最小生成树的所有边的权值 int cnt = 0; //存的是当前加入的边数 for (int i = 0; i < m; i++) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; pa = find(a), pb = find(b); if (pa != pb) // 如果两个连通块不连通，则将这两个连通块合并 { union(a, b); res += w; cnt++; } } //只有当 cnt == n - 1 时才能表示已经将所有点加入到集合中，可以生成最小生成树 if (cnt < n - 1) return INF; return res; }\"]},\"71\":{\"h\":\"6. 染色法判别二分图\",\"t\":[\"二分图： 将所有点分成__两个集合__，使得__所有边__只出现在集合之间，就是 二分图\",\"性质： 一定不含有奇数环，可能包含长度为偶数的环，不一定是__连通图__。\",\"DFS思路：\",\"染色可以使用 1 和 2 区分__不同颜色__，用 0 表示 未染色\",\"遍历所有点，每次将__未染色的点__进行 dfs，默认染成 1 或 2\",\"由于某个点染色成功并不代表整个图就是二分图，因此只有某个点染色失败才能立刻 break/return，__染色失败__相当于存在两个相邻的点染成了相同的颜色\",\"时间复杂度 O(n + m)， n 表示点数，m 表示边数\",\"int n, m; //n表示点数，m表示边数 int h[N], e[M], ne[M], idx; //邻接表存储图 int color[N]; //表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 //参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i <= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; }\"]},\"72\":{\"h\":\"7. 匈牙利算法\",\"t\":[\"相关概念：\",\"匹配：在图论中，一个 [匹配] 是一个边的集合，其中任意两条边都不依附于同一个顶点。\",\"最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。\",\"完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。\",\"交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边...形成的路径叫交替路。\",\"增广路：从一个未匹配路出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。\",\"算法描述：\",\"如果你想找的妹子已经有了男朋友，\",\"你就去问问她男朋友，\",\"你有没有备胎，\",\"把这个让给我好吧\",\"多么真实而实用的算法\",\"tips：因为你要去问的都是男孩子，所以存边的时候，都是由男孩子指向女孩子\",\"时间复杂度是 O(nm)， n 表示点数，m 表示边数\",\"int n1, n2; //n1表示第一个集合中的点数，n2表示第二个集合中的点数 // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int h[N], e[M], ne[M], idx; int match[N]; //存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; //表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { //遍历所有点 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) //如果在这一轮的匹配中，这个点还未被匹配 { st[j] = true; //那就匹配并标记 //如果这个点未被匹配，且原来匹配的点能找到另一个点(下家)匹配，则匹配成功 if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i <= n1; i ++ ) { //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化 memset(st, false, sizeof st); if (find(i)) res++; }\"]},\"73\":{\"c\":[\"algorithm\"]},\"74\":{\"c\":[\"ACM\"]},\"75\":{\"h\":\"四、数学知识\"},\"76\":{\"h\":\"1. 质数\"},\"77\":{\"h\":\"1.1 试除法判定质数\",\"t\":[\"从小到大遍历，只判断能否被小于 sqrt(x) 的数整除。\",\"时间复杂度为 O(sqrt(n)).\",\"bool is_prime(int x) { if (x < 2) return false; for (int i = 2; i <= x / i; i++) if (x % i == 0) return false; return true; }\"]},\"78\":{\"h\":\"1.2 试除法分解质因数\",\"t\":[\"从小到大尝试 n 的所有因数，每个正整数都能够以唯一的方式表示成它的质因数的乘积。\",\"结论：n 中最多只包含一个大于 sqrt(n) 的因子。\",\"反证法证明：如果有两个大于 sqrt(n) 的因子，那么相乘会大于 n。于是我们发现只有一个大于 sqrt(n) 的因子，可以对其进行优化。如果最后 n 还是 >1，说明这就是大于 sqrt(n) 的唯一质因子，输出即可。\",\"时间复杂度为 O(log n) ~ O(sqrt(n)).\",\"void divide(int x) { for (int i = 2; i <= x / i; i++) if (x % i == 0) { int s = 0; //s表示次幂 while (x % i == 0) { x /= i; s++; } cout << i << ' ' << s << endl; //输出i的s次幂 } if (x > 1) cout << x << ' ' << 1 << endl; cout << endl; }\"]},\"79\":{\"h\":\"汇总\",\"t\":[\"// 假设输入都是正数 // 素数测试 O(√n) bool is_prime(int n) { for (int i = 2; i <= n / i; i++){ if (n % i == 0) return false; } return n != 1; } // 约数枚举 O(√n) vector<int> divisor(int n) { vector<int> res; for (int i = 1; i <= n / i; i++){ if (n % i == 0){ res.push_back(i); if (i != n / i) res.push_back(n / i); } } return res; } // 整数分解 O(√n) map<int, int> prime_factor(int n) { map<int, int> res; for (int i = 2; i <= n / i; i++){ while (n % i == 0){ ++res[i]; n /= i; } } if (n != 1) res[n] = 1; return res; }\"]},\"80\":{\"h\":\"1.3 筛法求素数\"},\"81\":{\"h\":\"1.3.1 朴素筛法（埃氏筛）\",\"t\":[\"从 2 到 n 枚举，（一个数的倍数一定是合数）筛掉它的倍数，如果该数没有被筛掉，那它就是一个质数。\",\"（1）调和级数：当 n 趋于无穷大时，1 + 1/2 + 1/3 + … + 1/n = ln n + C.\",\"（2）对朴素筛法的优化：任何一个合数都能写成几个质数相乘的形式。只需要判断 2 ~ n-1 中的所有质数，只要它不是 n 的约数，那么 n 就是一个质因数。\",\"（3）质数定理：1~n 当中有 n/ln n 个质数。\",\"（4）思路：从小到大枚举所有的质数，然后删去它们的所有的倍数，就删去了所有的合数，剩下的就是质数。\",\"时间复杂度为 O(n ln ln n).\",\"int primes[N], cnt; // primes[]存储所有素数，cnt记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (st[i]) continue; primes[cnt++] = i; for (int j = i; j <= n; j += i) //用质数把其所有的倍数都筛掉 st[j] = true; } }\"]},\"82\":{\"h\":\"1.3.2 区间筛法\",\"t\":[\"给定整数 $a$ 和 $b$ ，问区间 $[a, b)$ 内有多少个素数。\",\"解法：\",\"因为 $b$ 以内的合数的最小质因数一定不超过 $\\\\sqrt{b}$ ，如果有 $\\\\sqrt{b}$ 以内的素数表的话，就可以把埃氏筛法运用在 $[a, b)$ 上了。\",\"所以先预处理好 $[a, \\\\sqrt{b})$ 和 $[a, b)$ 的素数表，然后从 $[a, \\\\sqrt{b})$ 的表中筛得素数的同时，也将其倍数从 $[a, b)$ 的表中划去，最后剩下的就是区间 $[a, b)$ 内的素数了。\",\"#define ll long long bool is_primes[N]; bool is_primes2[N]; void get_prime(ll a, ll b) { for (int i = 0; (ll)i * i < b; i++) is_primes2[i] = true; for (int i = 0; i < b - a; i++) is_prime[i] = true; // is_primes[i - a] = true => i是素数 for (int i = 2; (ll)i * i < b; i++){ if (is_primes2[i]){ for (int j = 2 * i; (ll)j * j < b; j += i) is_primes2[j] = true; for (ll j = max(2LL, (a + i - 1) / i; j < b; j += i) is_primes[j - a] = false; } } }\"]},\"83\":{\"h\":\"1.3.3 线性筛（欧拉筛）\",\"t\":[\"核心思路：用最小质因子去筛合数。\",\"当 i % primes[j] != 0 时， 说明此时遍历到的 primes[j] 不是 i 的质因子，只可能是此时 primes[j] 的最小质因子， 所以 primes[j] * i 的最小质因子就是 primes[j].\",\"当有 i % primes[j] == 0 时， 因为我们是从小到大遍历的，说明此时的 prime[j] 是满足条件的第一个数，即找到了 primes[j] 就是 i 的最小质因子， 因此 primes[j] * i 的最小质因子也就是 primes[j]， 之后用 st[primes[j + 1] * i] = true 去筛合数时，就不是用最小质因子去更新了， 所以此时应该退出循环，避免重复筛选。\",\"时间复杂度为 O(k)\",\"int primes[N]; // primes[]存储所有素数 int cnt; //记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] <= n / i; j++) { //标记，pj一定是pj*i的最小质因子 st[primes[j] * i] = true; //从小到大遍历，如果 i%pj=0，则pj一定是i的最小公因子 if (i % primes[j] == 0) break; } } }\"]},\"84\":{\"h\":\"2. 约数\"},\"85\":{\"h\":\"2.1 试除法求所有约数\",\"t\":[\"从小到大判断，如果当前数能整除目标数，说明这个数是它的一个约数。\",\"vector<int> get_divisors(int x) { vector<int> res; //从小到大枚举n的所有约数对里面比较小的那一个 for (int i = 1; i <= x / i; i++) if (x % i == 0) { res.push_back(i); //特判最中间的数 if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; }\"]},\"86\":{\"h\":\"2.2 约数个数和约数之和\",\"t\":[\"如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\",\"约数之和\",\"#include <iostream> #include <algorithm> #include <unordered_map> #include <vector> using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin >> n; unordered_map<int, int> primes; while (n -- ) { int x; cin >> x; for (int i = 2; i <= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x > 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; } cout << res << endl; return 0; }\"]},\"87\":{\"h\":\"2.3 最大公约数与最小公倍数\",\"t\":[\"欧几里得算法（辗转相除法)：\",\"每次都让较大的数对较小数取模，可以缩小问题规模而保持最大公约数不变，然后重复(递归)这个步骤。递归边界使某数变成了0，而此时另一个数即为所求答案.\",\"最坏情况下的时间复杂度为 O(log max(x, y))。\",\"对于大多数情况，辗转相除法时间可以忽略不计。\",\"int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\",\"用两数之积除以他们的最大公约数可得最小公倍数：\",\"int lcm(int a, int b) { return a * gcd(a, b) / b; //注意乘除的先后顺序，防止溢出 }\"]},\"88\":{\"h\":\"3. 欧拉函数\"},\"89\":{\"h\":\"3.1 求欧拉函数\",\"t\":[\"欧拉函数的定义\",\"1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)。 若在算数基本定理中，$N = p_1^{a_1} p_2^{a_2} ... p_m^{a_m}$ ，则： $ϕ(N) = N × \\\\frac{p_1−1}{p_1} × \\\\frac{p_2−1}{p_2} × … × \\\\frac{p_m−1}{p_m}$\",\"//求x的欧拉函数 int phi(int x) { int res = x; for (int i = 2; i <= x / i; i++) //分解质因数 if (x % i == 0) { res = res / i * (i - 1); //用上面的公式定义求，先整除再乘 while (x % i == 0) x /= i; } if (x > 1) res = res / x * (x - 1); return res; }\"]},\"90\":{\"h\":\"3.2 筛法求欧拉函数\",\"t\":[\"思路：质数 $i$ 的欧拉函数即为 phi[i] = i - 1：$1$ ~ $i−1$均与 $i$ 互质，共 $i−1$个。 phi[primes[j] * i] 分为两种情况： ① i % primes[j] == 0 时：primes[j] 是 i 的最小质因子，也是 primes[j] * i 的最小质因子，因此 1 - 1 / primes[j] 这一项在 phi[i] 中计算过了，只需将基数 $N$ 修正为 primes[j] 倍，最终结果为 phi[i] * primes[j] 。 ② i % primes[j] != 0：primes[j] 不是 $i$ 的质因子，只是 primes[j] * i 的最小质因子，因此不仅需要将基数 $N$ 修正为 primes[j] 倍，还需要补上 1 - 1 / primes[j] 这一项，因此最终结果 phi[i] * (primes[j] - 1) 。\",\"int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i <= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] <= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } }\"]},\"91\":{\"h\":\"4. 快速幂\",\"t\":[\"基本思路：\",\"预处理出 $a{20}, a{21}, a{22}, ..., a{2{logk}}$ 这 k 个数\",\"将 $a^b$ 用 $a{20}, a{21}, a{22}, ..., a{2{logk}}$ 这 k 个数来组合，即组合成 $a^b = a{2{x_1}} × a{2{x_2}} × ... × a{2{x_t}} = a{2 + 2^{x_2} + ... + 2^{x_t}}$​\",\"即用二进制来表示\",\"k&1 就是判断 k 的二进制表示中第 0 位上的数是否为 1，若为 1，则为 true，反之为 false.\",\"k&1 也可以用来判断奇数和偶数，b&1 = true 时为奇数，b&1 = false 时为偶数。\",\"求 ak mod p， 时间复杂度为 O(logk)\",\"int qmi(int a, int k, int p) { int res = 1 % p; while (k) { if (k&1) res = res * a % p; k >>= 1; a = a * a % p; } return res; }\"]},\"92\":{\"h\":\"5. 扩展欧几里得算法\"},\"93\":{\"h\":\"裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\",\"用于求解方程 $ax + by = gcd(a, b)$​ 的解\",\"当 $b = 0$ 时，$ax + by = a$ 所以有 $x = 1, y = 0$\",\"当 $b \\\\ne 0$ 时 ，因为 $gcd(a, b) = gcd(b, a % b) $\",\"​ 所以 $x = y', y = x' - [a/b] * y'$\",\"求整数 $x$ 和 $y$ 使得 $ax + by = 1$\",\"如果 $gcd(a, b) \\\\ne 1$，显然无解。反之，若 $gcd(a, b) = 1$ ，则可以通过扩展欧几里得来求解。\",\"事实上，一定存在整数对 $(x, y)$ 使得 $ax + by = gcd(a, b)$ .\",\"// 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; }\"]},\"94\":{\"h\":\"6. 中国剩余定理\",\"t\":[\"给定 $2n$ 个整数 $a_1, a_2, ... , a_n$ 和 $m_1, m_2, ..., m_n$ ，求一个最小的非负整数 $x$ ，满足 $∀i ∈ [1, n], x ≡ m_i(mod \\\\ a_i)$ .\",\"输入格式\",\"第 1 行包含整数 n。\",\"第 $2 ... n + 1$ 行：每 $i + 1$ 行包含两个整数 $a_i$ 和 $m_i$ ，数之间用空格隔开。\",\"输出格式\",\"输出最小非负整数 x ，如果 x 不存在，则输出 -1.\",\"如果存在 x ，则数据保证 x 一定在 64 位整数范围内。\",\"思路\",\"对于每两个式子，将其等价转换\",\"用扩展欧几里得算法找出一组解\",\"并且判断是否有解\",\"找到最小整数解\",\"等效替代\",\"相当于是每次考虑合并两个式子，将这 n 个式子合并 n - 1 次后变为一个式子。最后剩下的式子就满足我们的答案。\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; //扩展欧几里得 ll exgcd(ll a, ll b, ll &x, ll &y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } //可能为负数，取模加模再取模 ll inline mod(ll a, ll b) { return ((a % b) + b) % b; } int main() { ll n; scanf(\\\"%lld\\\", &n); ll a1, m1; scanf(\\\"%lld%lld\\\", &a1, &m1); for (ll i = 1; i < n; i++) { ll a2, m2, k1, k2; scanf(\\\"%lld%lld\\\", &a2, &m2); ll d = exgcd(a1, -a2, k1, k2); if ((m2 - m1) % d) { puts(\\\"-1\\\"); return 0; } k1 = k1 * (m2 - m1) / d; k1 = mod(k1, abs(a2 / d)); m1 = m1 + k1 * a1; a1 = abs(a1 / d * a2); } printf(\\\"%lld\\\\n\\\", m1); return 0; }\"]},\"95\":{\"h\":\"7. 高斯消元\",\"t\":[\"给定一个包含 n 个方程 n 个未知数的线性方程组。方程组中的系数为实数。\",\"要求求解这个方程组。\",\"（线性代数方法解非齐次线性方程组）\",\"前置知识：初等行（列）变换\",\"把某一行乘一个非00的数 (方程的两边同时乘上一个非00数不改变方程的解)\",\"交换某两行 (交换两个方程的位置)\",\"把某行的若干倍加到另一行上去 （把一个方程的若干倍加到另一个方程上去）\",\"高斯消元适用解法\",\"通过初等行变换把 增广矩阵 化为 阶梯型矩阵 并回代得到方程的解\",\"适用于求解包含 n 个方程，n 个未知数的多元线性方程组\",\"算法步骤\",\"枚举每一列c,\",\"找到当前列绝对值最大的一行\",\"用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）\",\"用初等行变换(1) 将该行的第一个数变成 11 （其余所有的数字依次跟着变化）\",\"用初等行变换(3) 将下面所有行的当且列的值变成 0\",\"时间复杂度为 O(n^3)\",\"const int eps = 1e-6; //控制精度，小于eps视为0 int a[N][N]; // a[N][N]是增广矩阵 int gauss() { int r, c; //行row,列col for (r = 0, c = 0; c < n; c ++ ) { int t = r; // 找到绝对值最大的行 for (int i = r; i < n; i ++ ) if (abs(a[i][c]) > abs(a[t][c])) t = i; if (abs(a[t][c]) < eps) continue; // 将绝对值最大的行换到最顶端 for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); // 将当前行的首位变成1 for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; // 用当前行将下面所有的列消成0 for (int i = r + 1; i < n; i ++ ) if (fabs(a[i][c]) > eps) for (int j = n; j >= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r < n) { for (int i = r; i < n; i ++ ) if (fabs(a[i][n]) > eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i >= 0; i -- ) for (int j = i + 1; j < n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 }\"]},\"96\":{\"h\":\"8. 求组合数\"},\"97\":{\"h\":\"8.1 递推法求组合数\",\"t\":[\"适用题型：\",\"给定两个正整数 a 与 b ，求 $C_a^b \\\\ mod(1e9 + 7)$\",\"递推式：\",\"$C_a ^ b = C_{a - 1} ^ {b - 1} + C_{a - 1} ^ {b}$\",\"// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i < N; i++) for (int j = 0; j <= i; j++) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\"]},\"98\":{\"h\":\"8.2 通过预处理逆元的方式求组和数\",\"t\":[\"用 infact(a!) 表示 a! 的逆元\",\"$C_a^b = \\\\frac{a!}{b!\\\\ * \\\\ (a - b)!} = a! \\\\ * \\\\ infact(b!) \\\\ * \\\\ infact((a - b)!)$\",\"快速幂求逆元\",\"费马小定理：如果 $p$ 是一个质数，而整数 $a$ 不是 $p$ 的倍数，则有 $a^{p - 1} ≡ 1\\\\ (mod\\\\ p)$ .\",\"乘法逆元的定义\",\"若整数 b, m 互质，并且对于任意的整数 a，如果满足 b | a，则存在一个整数 x，使得 a / b ≡ a * x (mod m) ，则称 x 为 b 的模 m 乘法逆元，记为 $b^{-1} (mod\\\\ m)$ .\",\"b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，$b^{m - 2}$ 即为 b 的乘法逆元。\",\"结论：当 b 与 m 互质时，b 的乘法逆元为 $b^{m - 2}$.\",\"​ 当 b 为 m 的倍数时，b 的逆元不存在。$b\\\\ *\\\\ x\\\\ % \\\\ m == 0$ ，b 乘任意一个 x % m 一定等于 0.\",\"首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i < N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; }\"]},\"99\":{\"h\":\"8.3 卢卡斯(Lucas)定理求组合数\",\"t\":[\"给定 n 组询问，每组询问给定三个整数 a,b,p，其中 p 是质数，请你输出 $C_a^b \\\\ mod \\\\ p$ 的值。\",\"$Lucas$ 定理：$C_a^b ≡ C_{a % p} ^{b % p} \\\\ * \\\\ C_{\\\\frac{a}{p}} ^{\\\\frac{b}{p}} \\\\ (mod\\\\ p)$\",\"$C_b^a = \\\\frac{a!}{(a−b!)∗b!} = \\\\frac{a∗(a−1)∗(a−2)∗…∗(a−b+1)∗(a−b)∗…∗1}{(a−b)∗(a−b−1)∗…∗1∗b!} = \\\\frac{a∗(a−1)∗(a−2)∗…(a−b+1)}{b!}$\",\"因此可以递推的每次乘 a 然后 除以 b ，因为从 a 到 a - b + 1，所以是乘 b 次。\",\"若p是质数，则对于任意整数 1 <= m <= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k, int p) // 快速幂模板 { int res = 1 % p; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a < b) return 0; LL x = 1, y = 1; // x是分子，y是分母 for (int i = a, j = 1; j <= b; i --, j ++ ) { x = (LL)x * i % p; y = (LL)y * j % p; } return x * (LL)qmi(y, p - 2, p) % p; } int lucas(LL a, LL b, int p) { if (a < p && b < p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } int main() { int n; cin >> n; while (n--) { ll a, b, p; cin >> a >> b >> p; cout << lucas(a, b, p) << endl; } return 0; }\"]},\"100\":{\"h\":\"8.4 分解质因数法求组合数\",\"t\":[\"输入 a, b，求 $C_a^b$ 的值。\",\"方法：对阶乘分解质因数之后，用高精度相乘即可。\",\"步骤：\",\"筛素数\",\"求每个质数的次数\",\"用高精度乘法把所有质因子乘上\",\"当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i <= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] <= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n!中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector<int> mul(vector<int> a, int b) // 高精度乘低精度模板 { vector<int> c; int t = 0; for (int i = 0; i < a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i < cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector<int> res; res.push_back(1); for (int i = 0; i < cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j < sum[i]; j ++ ) res = mul(res, primes[i]);\"]},\"101\":{\"h\":\"8.5 卡特兰数\",\"t\":[\"给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\"]},\"102\":{\"h\":\"9. 容斥原理\",\"t\":[\"给定一个整数 n 和 m 个不同的质数 $p_1, p_2, ..., p_m$ .\",\"请你求出 1 ~ n 中能被 $p_1, p_2, ..., p_m$​ 中至少一个数整除的整数有多少个。\",\"记 $S_i$ 为 1 ~ n 中能整除 $p_i$​ 的集合，根据容斥原理，所有数的个数为各个集合的并集，计算公式如下\",\"#include<iostream> using namespace std; #define ll long long const int N = 20; int p[N], n, m; int main() { cin >> n >> m; for(int i = 0; i < m; i++) cin >> p[i]; int res = 0; //枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合) for(int i = 1; i < 1 << m; i++) { int t = 1; //选中集合对应质数的乘积 int s = 0; //选中的集合数量 //枚举当前状态的每一位 for(int j = 0; j < m; j++){ //选中一个集合 if(i >> j & 1){ //乘积大于n, 则n/t = 0, 跳出这轮循环 if((LL)t * p[j] > n){ t = -1; break; } s++; //有一个1，集合数量+1 t *= p[j]; } } if(t != -1) { if (s % 2) //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量 res += n / t; else //反之则为 -1 res -= n / t; } } cout << res << endl; return 0; }\"]},\"103\":{\"h\":\"10. 博弈论\"},\"104\":{\"h\":\"10.1 NIM游戏\",\"t\":[\"必胜状态和必败状态\",\"必胜状态，先手进行__某一个操作__，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即__先手可以走到某一个必败状态__。\",\"必败状态，先手__无论如何操作__，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即__先手走不到任何一个必败状态__。\",\"给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\",\"我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\",\"定理： NIM博弈先手必胜，当且仅当 a1 ^ a2 ^ … ^ an != 0\",\"#include <iostream> #include <algorithm> using namespace std; int main() { int n; cin >> n; int res = 0; while (n--) { int x; cin >> x; res ^= x; //每次异或操作 } if (res) puts(\\\"Yes\\\"); else puts(\\\"No\\\"); return 0; }\"]},\"105\":{\"h\":\"10.2 公平组合游戏ICG\",\"t\":[\"若一个游戏满足：\",\"由两名玩家交替行动；\",\"在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\",\"不能行动的玩家判负；\",\"则称该游戏为一个公平组合游戏。\",\"NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件 2 和条件 3 。\"]},\"106\":{\"h\":\"10.3 有向图游戏\",\"t\":[\"给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\"]},\"107\":{\"h\":\"10.4 Mex运算\",\"t\":[\"设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\"]},\"108\":{\"h\":\"10.5 SG游戏\",\"t\":[\"在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\"]},\"109\":{\"h\":\"10.6 有向图游戏的和\",\"t\":[\"设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\",\"定理\",\"有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\"]},\"110\":{\"c\":[\"algorithm\"]},\"111\":{\"c\":[\"ACM\"]},\"112\":{\"h\":\"二、数据结构\"},\"113\":{\"h\":\"1. 数组模拟链表\"},\"114\":{\"h\":\"1.1 单链表\",\"t\":[\"也称静态链表（邻接表：n个链表，主要应用：存储图和树）单链表只能存储当前节点的值和指向下一节点的指针，无法存储上一节点\",\"// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; //-1表示不存在， idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a,; ne[idx] = head,; head = idx ++ ; } //将一个新的节点x插入下标是k的后面 void add(int k, int x){ e[idx] = x; //1.先存值 ne[idx] = ne[k]; //2.新节点的下一节点指向 k 指向的下一节点 ne[k] = idx; //3.k指向的下一节点指向新节点 idx++; //4.index指向下一个指针 } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } //将下标是k的点后面的点删掉 void remove(int x){ //直接将其指向下下个节点，在算法竞赛中一般不需要考虑删除的那个节点该如何处理 ne[k] = ne[ne[k]]; }\"]},\"115\":{\"h\":\"1.2 双链表\",\"t\":[\"（主要用来优化某些问题）有两个指针，一个指向前，一个指向后。\",\"// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1; l[1] = 0; idx = 2; //0和1都被占用了，所以idx从2开始 } // 在节点k的右边插入一个数x ////如果要插在k的左边，就把k改为l[k] void insert(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx++; } // 删除第k个点 void remove(int k) { l[r[k]] = l[k]; r[l[k]] = r[k]; }\"]},\"116\":{\"h\":\"2. 栈\",\"t\":[\"先进后出\"]},\"117\":{\"h\":\"2.1 普通栈\",\"t\":[\"// tt表示栈顶 int stk[N]; //栈数组从0开始 int tt = 0; // 向栈顶插入一个数 stk[++tt] = x; // 从栈顶弹出一个数 tt--; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt > 0) not empty { } else empty\"]},\"118\":{\"h\":\"2.1 单调栈\",\"t\":[\"给定一个序列，找到每一个数左边离他最近的比它小的数。\",\"性质：如果 ax >= ay ，x < y，那么 ax 永远不会被输出，可以删掉。比如 a3 >= a5 ，那么 a3 永远不会被输出。\",\"常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i <= n; i++) { while (tt && check(stk[tt], i)) tt--; stk[++tt] = i; }\"]},\"119\":{\"h\":\"3. 队列\",\"t\":[\"先进先出，后进后出\"]},\"120\":{\"h\":\"3.1 普通队列\",\"t\":[\"// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[++tt] = x; // 从队头弹出一个数 hh++; // 队头的值 q[hh]; //同理队尾 q[tt] // 判断队列是否为空 if (hh <= tt) not empty { } else empty\"]},\"121\":{\"h\":\"3.2 单调队列\",\"t\":[\"求滑动窗口里的最大值和最小值。用单调队列来优化。\",\"步骤：\",\"判断队头是否已经滑出窗口\",\"判断当前元素与队尾元素是否满足单调性问题\",\"若满足条件，弹出队尾元素，将当前元素加入队尾\",\"如果窗口满足条件，则输出结果\",\"【注意】队列里面存的是下标\",\"常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i < n; i++) { //判断队头是否滑出窗口 if (hh <= tt && check_out(q[hh])) hh++; //判断当前元素与队尾元素是否满足单调性问题 while (hh <= tt && check(q[tt], i)) tt--; q[++tt] = i; //将当前元素加入到队尾 //如果满足条件再输出结果 if() }\"]},\"122\":{\"h\":\"4. KMP\",\"t\":[\"关于为什么求 $next$ 数组和匹配的操作类似： 因为本质是一样的：对于 $S$ 串每一个特定的下标 $i$，在满足 s[i-j+1，i]=p[0，j] 的前提下，我们需要找出 $j$ 的最大值。 唯一不同的在于，求 $next$ 数组时，我们关心对于每个不同的下标 $i，j$ 能走多远；匹配时，我们只关心 $j$ 是否走到末尾.\",\"非常有意思的说法是： 求next数组时：对于每个i：“j走到哪了呀？我用数组记录一下你的位置” 匹配时：对于每个i：“到终点和我说声，匹配完我输出一下，没事别叫我。”\",\"#include <iostream> using namespace std; const int N = 100010, M = 10010; //N为模式串长度，M匹配串长度 int n, m; int ne[M]; //next[]数组，避免和头文件next冲突 char s[N], p[M]; //s为模式串， p为匹配串 int main() { cin >> n >> s+1; cin >> m >> p+1; //下标从1开始 //求next[]数组 for (int i = 2, j = 0; i <= m; i++) { while (j && p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } //匹配操作 for (int i = 1, j = 0; i <= n; i++) { while (j && s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == m) //满足匹配条件，打印开头下标, 从0开始 { //匹配完成后的具体操作 //如：输出以0开始的匹配子串的首字母下标 //printf(\\\"%d \\\", i - m); (若从1开始，加1) j = ne[j]; //再次继续匹配 } } return 0; }\"]},\"123\":{\"h\":\"5. Trie树\",\"t\":[\"Trie树又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构。\",\"存储形式如下：\",\"Trie树存储形式\",\"//son[][]存储树中每个节点的子节点，因为存的都是英文字母，最多有26个 int son[N][26]; int cnt[N]; //cnt[]存储以每个节点结尾的单词数量 int idx; //存储当前用到的下标，0号点既是根节点，又是空节点 // 插入一个字符串 void insert(char *str) { int p = 0; //字符串以'0'结尾，所以可以用str[i]结束 for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; }\"]},\"124\":{\"h\":\"6. 并查集\"},\"125\":{\"h\":\"6.1 朴素并查集\",\"t\":[\" int p[N]; // 存储每个点的祖宗节点 int rank[N]; // 树的高度 // 初始化，假定节点编号是1~n void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 合并x和y所在的两个集合： void union(int x, int y) { int px = find(x), py = find(y); if (rank[px] < rank[py]){ p[px] = py; rank[py] += rank[px]; } else { p[py] = px; rank[px] += rank[py]; } }\"]},\"126\":{\"h\":\"6.2 维护size的并查集\",\"t\":[\" int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);\"]},\"127\":{\"h\":\"6.3 维护到祖宗节点距离的并查集\",\"t\":[\" int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\"]},\"128\":{\"h\":\"7. 堆\",\"t\":[\"1、作用：维护一个数组集合\",\"2、堆是一棵（完全）二叉树，长得非常平衡，除最后一层节点，所有节点均不为空，最后一层节点从左向右排列，根节点小于等于左右两个子节点，即小根堆。\",\"3、存储：用一个一维数组存储树，下标从1开始。其中元素x 的左儿子为 2x，x 的右儿子为 2x + 1.\",\"4、5个基本操作\",\"heap表示堆，size表示大小\",\"插入一个数 heap[++size] = x; up(size);\",\"求集合当中的最小值 heap[1];\",\"删除最小值 heap[1] = heap[size]; size--; down(1);\",\"删除任意一个元素 heap[k] = heap[size]; size--; down(k); up(k); //down和up只会执行其中一个\",\"修改任意一个元素 heap[K] = x; down(k); up(k);\",\"// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u)//跟两个儿子比较大小 { //t表示该元素与它的左、右儿子相比最小的元素，初始化为它自身 int t = u; //若左二子小于它，则最小的数为左二子 if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2; //若右儿子小于它，则最小的数为右儿子 if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1; //如果它本身不是最小的数，则往下沉，继续down()操作 if (u != t) { heap_swap(u, t); down(t); } } void up(int u)//只需要跟一个父亲比较大小就行 { //如果比父节点大，就交换位置，上浮 while (u / 2 && h[u] < h[u / 2]) { heap_swap(u, u / 2); u >>= 1; //x /= 2 } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i);\"]},\"129\":{\"h\":\"8. 哈希表\"},\"130\":{\"h\":\"8.1 拉链法\",\"t\":[\"int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { //哈希函数离散化 int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; }\"]},\"131\":{\"h\":\"8.2 开放寻址法\",\"t\":[\"int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { //哈希函数 int k = (x % N + N) % N; while (h[k] != null && h[k] != x) { k++; //如果到了末尾，那么再从头开始查找 if (k == N) k = 0; } return k; }\"]},\"132\":{\"h\":\"8.3 字符串哈希\",\"t\":[\"核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N]; // h[k]存储字符串前k个字母的哈希值 ULL p[N]; //p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i <= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }\"]},\"133\":{\"h\":\"9. C++ STL简介\",\"t\":[\"vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair<int, int> first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列，本身就是有序的，默认按key排序 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 没找到则返回end() count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 (3) 例如：s.erase(unique(s.begin(), d.end()), s,end()) 将一个容器中重复的元素删除，对字符串也适用 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() 用 first 和 second 查找每个键值对的元素 [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 都可以是‘哈希表’ 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset<10000> s; ~, &, |, ^ >>, << ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反\"]},\"134\":{\"h\":\"10. 常用库函数\",\"t\":[\"1. reverse 翻转\",\"翻转一个 vector ：\",\"reverse(a.begin(), a.end());\",\"翻转一个数组，元素存放在下标 1 ~ n ：\",\"reverse(a + 1, a + n + 1);\",\"2. unique 去重\",\"返回去重（只去掉__相邻__的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。\",\"把一个 vector 去重：\",\"int m = unique(a.begin(), a.end()) – a.begin();\",\"把一个数组去重，元素存放在下标 1 ~ n：\",\"int m = unique(a + 1, a + n + 1) – (a + 1);\",\"3. random_shuffle 随机打乱： 用法与 reverse 相同。\",\"4. sort 排序：\",\"对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载 “小于号” 运算符。\",\"把一个 int 数组（元素存放在下标 1 ~ n ）从大到小排序，传入比较函数：\",\"int a[MAX_SIZE]; bool cmp(int a, int b) { return a > b; } sort(a + 1, a + n + 1, cmp);\",\"从大到小排序需要加入第三个参数：\",\"sort(a.begin(), a.end(), greater<int>());\",\"对自定义的结构体 vector 排序，重载 \\\"小于号\\\" 运算符：\",\"struct node { int id, x, y; }; vector<node> a; bool operator < (const node &a, const node &b) { return a.x < b.x || a.x == b.x && a.y < b.y; } sort(a.begin(), a.end());\",\"5. lower_bound / upper_bound 二分：\",\"lower_bound 的第三个参数传入一个元素 x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于 x 的元素的位置的迭代器（指针）。\",\"upper_bound 的用法和 lower_bound 大致相同，唯一的区别是查找第一个大于 x 的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。\",\"在有序 int 数组（元素存放在下标 1 ~ n ）中查找大于等于 x 的最小整数的下标：\",\"int i = lower_bound(a + 1, a + 1 + n, x) - a;\",\"在有序 vector<int> 中查找小于等于 x 的最大整数（假设一定存在）：\",\"int y = *--upper_bound(a.begin(), a.end(), x);\",\"找不到则返回最后一个元素的下标+1，是越界的。\"]},\"135\":{\"c\":[\"algorithm\"]},\"136\":{\"c\":[\"ACM\"]},\"137\":{\"h\":\"六、贪心\"},\"138\":{\"h\":\"1. 区间问题\"},\"139\":{\"h\":\"1.1 区间选点\",\"t\":[\"给定 N个闭区间 ，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node &W) const { return r < W.r; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; //按右端点从小到大排序 sort(arr + 1, arr + 1 + n); int ans = 0; int R = -2e9; //R表示上一连续区间的最右端的点 for (int i = 1; i <= n; i++) { if (arr[i].l > R) //如果不能覆盖掉右端点，则点数+1，更新右端点 { ans++; R = arr[i].r; } } cout << ans << endl; return 0; }\"]},\"140\":{\"h\":\"1.2 最大不相交区间数量\",\"t\":[\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node & W) const { return l < W.l; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; sort(arr + 1, arr + 1 + n); int res = 1, R = arr[1].r; for (int i = 2; i <= n; i++){ if (arr[i].l <= R) R = min(R, arr[i].r); else { res++; R = arr[i].r; } } cout << res << endl; return 0; }\"]},\"141\":{\"h\":\"1.3 区间分组\",\"t\":[\"给定 N个闭区间 ，要求分成若干组，使得每组内部区间两两之间没有交集，求分成的最小组数。\",\"#include <iostream> #include <algorithm> #include <queue> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; //重载小于运算符，按左端点从小到大排序 bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); //用一个小根堆来维护所有组的右端点 priority_queue<int, vector<int>, greater<int>> heap; for (int i = 0; i < n; i++){ auto t = Range[i]; if (heap.empty() || heap.top() >= t.l) //放不进去则新开一组 heap.push(t.r); else { heap.pop(); heap.push(t.r); //放进去并更新右端点 } } cout << heap.size() << endl; return 0; }\"]},\"142\":{\"h\":\"1.4 区间覆盖\",\"t\":[\"给定 N 个闭区间，以及一个线段区间，请你选择尽量少的区间，将指定线段区间完全覆盖。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; int L, R; cin >> L >> R; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); int res = 0; bool f = false; for (int i = 0; i < n; ){ //依次遍历每个区间 int j = i, r = -2e9; //j表示第几个区间 //遍历所有左端点在L的左边的区间，选出右端点最大的 while (j < n && Range[j].l <= L){ r = max(r, Range[j].r); j++; } if (r < L){ //如果所有右端点都小于L，则无解 res = -1; break; } res++; if (r >= R){ //循环出口 f = true; break; } //更新端点和遍历的区间 L = r; i = j; } if (!f) res = -1; cout << res << endl; return 0; }\"]},\"143\":{\"h\":\"1.5 区间合并\",\"t\":[\"#include <iostream> #include <cstdio> #include <algorithm> #include <vector> #define PII pair<int, int> using namespace std; const int N = 1e5 + 5; int n; vector <PII> nums, ans; void merge(vector<PII> &nums){ //按左端点排序 sort(nums.begin(), nums.end()); //l代表区间左端点，r代表区间右端点 int l = -2e9, r = -2e9; for (auto num : nums){ //如果两区间无法合并 if (r < num.first){ if (l != -2e9) ans.push_back({l, r});//将新的区间放入ans数组中 l = num.first, r = num.second;//更新区间 } //若两区间部分存在交集，小的合并到大的中 else r = max(r, num.second); } if (l != -2e9) ans.push_back({l, r}); } int main() { cin >> n; for (int i = 0; i < n; i++){ int l, r; cin >> l >> r; nums.push_back({l, r}); } merge(nums); cout << ans.size() << endl; return 0; }\"]},\"144\":{\"c\":[\"algorithm\"]},\"145\":{\"c\":[\"ACM\"]},\"146\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"147\":{\"h\":\"ACM\"},\"148\":{\"h\":\"Algorithm\"},\"149\":{\"h\":\"For Offer\"}},\"dirtCount\":0,\"index\":[[\"放进去并更新右端点\",{\"1\":{\"141\":1}}],[\"放不进去则新开一组\",{\"1\":{\"141\":1}}],[\"放入高位\",{\"1\":{\"35\":1}}],[\"贪心\",{\"0\":{\"137\":1}}],[\"六\",{\"0\":{\"137\":1}}],[\"唯一的区别是查找第一个大于\",{\"1\":{\"134\":1}}],[\"唯一不同的在于\",{\"1\":{\"122\":1}}],[\"大致相同\",{\"1\":{\"134\":1}}],[\"大于某个与inf`\",{\"1\":{\"63\":1}}],[\"传入比较函数\",{\"1\":{\"134\":1}}],[\"传入t的地址\",{\"1\":{\"38\":1}}],[\"排序\",{\"1\":{\"134\":2}}],[\"随机打乱\",{\"1\":{\"134\":1}}],[\"利用迭代器\",{\"1\":{\"134\":1}}],[\"仍然为前闭后开\",{\"1\":{\"134\":1}}],[\"元素存放在下标\",{\"1\":{\"134\":4}}],[\"翻转一个数组\",{\"1\":{\"134\":1}}],[\"翻转一个\",{\"1\":{\"134\":1}}],[\"翻转\",{\"1\":{\"134\":1}}],[\"翻转指定位\",{\"1\":{\"46\":1}}],[\"等价于~\",{\"1\":{\"133\":1}}],[\"等效替代\",{\"1\":{\"94\":1}}],[\"圧位\",{\"1\":{\"133\":1}}],[\"增删改查的时间复杂度是\",{\"1\":{\"133\":1}}],[\"增广矩阵\",{\"1\":{\"95\":1}}],[\"增广路\",{\"1\":{\"72\":1}}],[\"查找每个键值对的元素\",{\"1\":{\"133\":1}}],[\"查找一个数\",{\"1\":{\"133\":1}}],[\"查询字符串出现的次数\",{\"1\":{\"123\":1}}],[\"本身就是有序的\",{\"1\":{\"133\":1}}],[\"红黑树\",{\"1\":{\"133\":1}}],[\"弹出栈顶元素\",{\"1\":{\"133\":1}}],[\"弹出堆顶元素\",{\"1\":{\"133\":1}}],[\"弹出队头元素\",{\"1\":{\"133\":1}}],[\"弹出队尾元素\",{\"1\":{\"121\":1}}],[\"默认按key排序\",{\"1\":{\"133\":1}}],[\"默认是大根堆\",{\"1\":{\"133\":1}}],[\"默认染成\",{\"1\":{\"71\":1}}],[\"优先队列\",{\"1\":{\"133\":1}}],[\"起始下标\",{\"1\":{\"133\":1}}],[\"起点的入度为0\",{\"1\":{\"58\":1}}],[\"字典序\",{\"1\":{\"133\":1}}],[\"字符串\",{\"1\":{\"133\":1}}],[\"字符串哈希\",{\"0\":{\"132\":1}}],[\"字符串以\",{\"1\":{\"123\":1}}],[\"字符串中只包含小写字母\",{\"1\":{\"12\":1}}],[\"支持比较运算\",{\"1\":{\"133\":2}}],[\"清空\",{\"1\":{\"133\":1}}],[\"清零\",{\"1\":{\"46\":1}}],[\"溢出的结果就是取模的结果\",{\"1\":{\"132\":1}}],[\"核心思想\",{\"1\":{\"132\":1}}],[\"核心思路\",{\"1\":{\"83\":1}}],[\"哈希函数\",{\"1\":{\"131\":1}}],[\"哈希函数离散化\",{\"1\":{\"130\":1}}],[\"哈希表\",{\"0\":{\"129\":1},\"1\":{\"133\":1}}],[\"拉链法\",{\"0\":{\"130\":1}}],[\"建堆\",{\"1\":{\"128\":1}}],[\"建立一个队列\",{\"1\":{\"64\":1}}],[\"上浮\",{\"1\":{\"128\":1}}],[\"上了\",{\"1\":{\"82\":1}}],[\"操作\",{\"1\":{\"128\":1}}],[\"操作数每右移一位\",{\"1\":{\"46\":1}}],[\"继续down\",{\"1\":{\"128\":1}}],[\"跟两个儿子比较大小\",{\"1\":{\"128\":1}}],[\"及其映射关系\",{\"1\":{\"128\":1}}],[\"修改任意一个元素\",{\"1\":{\"128\":1}}],[\"修正为\",{\"1\":{\"90\":2}}],[\"根节点小于等于左右两个子节点\",{\"1\":{\"128\":1}}],[\"根据具体问题\",{\"1\":{\"127\":1}}],[\"根据容斥原理\",{\"1\":{\"102\":1}}],[\"长得非常平衡\",{\"1\":{\"128\":1}}],[\"长度为1的区间为0\",{\"1\":{\"14\":1}}],[\"长度+左端点\",{\"1\":{\"14\":1}}],[\"堆是一棵\",{\"1\":{\"128\":1}}],[\"堆\",{\"0\":{\"128\":1}}],[\"堆优化版的dijkstra算法\",{\"0\":{\"62\":1},\"1\":{\"60\":1}}],[\"维护一个数组集合\",{\"1\":{\"128\":1}}],[\"维护到祖宗节点距离的并查集\",{\"0\":{\"127\":1}}],[\"维护size的并查集\",{\"0\":{\"126\":1}}],[\"维护某种次序\",{\"1\":{\"48\":1}}],[\"假定节点编号是1~n\",{\"1\":{\"125\":1,\"126\":1,\"127\":1}}],[\"假设一定存在\",{\"1\":{\"134\":1}}],[\"假设输入都是正数\",{\"1\":{\"79\":1}}],[\"假设目标值在闭区间\",{\"1\":{\"28\":1}}],[\"又是空节点\",{\"1\":{\"123\":1}}],[\"打印开头下标\",{\"1\":{\"122\":1}}],[\"没找到则返回end\",{\"1\":{\"133\":1}}],[\"没事别叫我\",{\"1\":{\"122\":1}}],[\"没有入度\",{\"1\":{\"21\":1}}],[\"没有被访问过\",{\"1\":{\"21\":1}}],[\"没有上司的舞会\",{\"0\":{\"21\":1}}],[\"我用数组记录一下你的位置\",{\"1\":{\"122\":1}}],[\"我们只关心\",{\"1\":{\"122\":1}}],[\"我们关心对于每个不同的下标\",{\"1\":{\"122\":1}}],[\"我们需要找出\",{\"1\":{\"122\":1}}],[\"我们讨论的博弈问题一般都只考虑理想情况\",{\"1\":{\"104\":1}}],[\"我们把这种游戏称为nim博弈\",{\"1\":{\"104\":1}}],[\"我们就找到了目标值\",{\"1\":{\"28\":1}}],[\"我们将这样的一种表示称为正整数\",{\"1\":{\"15\":1}}],[\"非常有意思的说法是\",{\"1\":{\"122\":1}}],[\"非匹配边\",{\"1\":{\"72\":1}}],[\"能走多远\",{\"1\":{\"122\":1}}],[\"串每一个特定的下标\",{\"1\":{\"122\":1}}],[\"关于为什么求\",{\"1\":{\"122\":1}}],[\"关系运算符\",{\"1\":{\"46\":1}}],[\"普通队列\",{\"0\":{\"120\":1}}],[\"普通栈\",{\"0\":{\"117\":1}}],[\"队头的值\",{\"1\":{\"120\":1}}],[\"队头不断出队\",{\"1\":{\"64\":1}}],[\"队列里面存的是下标\",{\"1\":{\"121\":1}}],[\"队列\",{\"0\":{\"119\":1},\"1\":{\"133\":1}}],[\"永远不会被输出\",{\"1\":{\"118\":2}}],[\"向栈顶插入一个元素\",{\"1\":{\"133\":1}}],[\"向栈顶插入一个数\",{\"1\":{\"117\":1}}],[\"向队尾插入一个元素\",{\"1\":{\"133\":1}}],[\"向队尾插入一个数\",{\"1\":{\"120\":1}}],[\"向哈希表中插入一个数\",{\"1\":{\"130\":1}}],[\"向中间移动\",{\"1\":{\"25\":1}}],[\"栈顶的值\",{\"1\":{\"117\":1}}],[\"栈数组从0开始\",{\"1\":{\"117\":1}}],[\"栈\",{\"0\":{\"116\":1},\"1\":{\"133\":1}}],[\"双端队列\",{\"1\":{\"133\":1}}],[\"双链表\",{\"0\":{\"115\":1}}],[\"双指针算法\",{\"0\":{\"48\":1}}],[\"指定的部分应该是提前排好序的\",{\"1\":{\"134\":1}}],[\"指定的部分上执行二分查找\",{\"1\":{\"134\":1}}],[\"指定的部分进行快速排序\",{\"1\":{\"134\":1}}],[\"指针\",{\"1\":{\"134\":3}}],[\"指向的下一节点\",{\"1\":{\"114\":1}}],[\"指边相对于点不多\",{\"1\":{\"60\":1}}],[\"新节点的下一节点指向\",{\"1\":{\"114\":1}}],[\"主要用来优化某些问题\",{\"1\":{\"115\":1}}],[\"主要应用\",{\"1\":{\"114\":1}}],[\"主要步骤\",{\"1\":{\"25\":1,\"26\":1}}],[\"任何一个公平组合游戏都可以转化为有向图游戏\",{\"1\":{\"106\":1}}],[\"任何一个合数都能写成几个质数相乘的形式\",{\"1\":{\"81\":1}}],[\"图中有一个唯一的起点\",{\"1\":{\"106\":1}}],[\"图的拓扑序列是针对于有向图而言的\",{\"1\":{\"58\":1}}],[\"胜负判定也比较复杂\",{\"1\":{\"105\":1}}],[\"公平组合游戏icg\",{\"0\":{\"105\":1}}],[\"整个有向图游戏g的sg函数值被定义为有向图游戏起点s的sg函数值\",{\"1\":{\"108\":1}}],[\"整局游戏第一个行动的称为先手\",{\"1\":{\"104\":1}}],[\"整数分解\",{\"1\":{\"79\":1}}],[\"整数二分\",{\"0\":{\"32\":1}}],[\"问先手是否必胜\",{\"1\":{\"104\":1}}],[\"问区间\",{\"1\":{\"82\":1}}],[\"但城建的棋类游戏\",{\"1\":{\"105\":1}}],[\"但不能不取\",{\"1\":{\"104\":1}}],[\"但归并排序的核心在这一步骤\",{\"1\":{\"25\":1}}],[\"留给后手都是一个必胜状态时\",{\"1\":{\"104\":1}}],[\"留给后手是一个必败状态时\",{\"1\":{\"104\":1}}],[\"某一个操作\",{\"1\":{\"104\":1}}],[\"必败状态\",{\"1\":{\"104\":1}}],[\"必胜状态\",{\"1\":{\"104\":1}}],[\"必胜状态和必败状态\",{\"1\":{\"104\":1}}],[\"必须首先判断两个数是否相等\",{\"1\":{\"46\":1}}],[\"博弈论\",{\"0\":{\"103\":1}}],[\"集合数量+1\",{\"1\":{\"102\":1}}],[\"跳出这轮循环\",{\"1\":{\"102\":1}}],[\"选出右端点最大的\",{\"1\":{\"142\":1}}],[\"选中奇数个集合\",{\"1\":{\"102\":1}}],[\"选中一个集合\",{\"1\":{\"102\":1}}],[\"选中的集合数量\",{\"1\":{\"102\":1}}],[\"选中集合对应质数的乘积\",{\"1\":{\"102\":1}}],[\"选了某个节点就不能选父节点和子节点\",{\"1\":{\"21\":1}}],[\"至少选中一个集合\",{\"1\":{\"102\":1}}],[\"至少需要进行多少次操作\",{\"1\":{\"13\":1}}],[\"容斥原理\",{\"0\":{\"102\":1}}],[\"容量为0时\",{\"1\":{\"15\":2}}],[\"它的行动规则是任选某个有向图游戏gi\",{\"1\":{\"109\":1}}],[\"它的一个重要推论是\",{\"1\":{\"93\":1}}],[\"它们按照某种顺序排成长度为2n的序列\",{\"1\":{\"101\":1}}],[\"卡特兰数\",{\"0\":{\"101\":1}}],[\"步骤\",{\"1\":{\"100\":1,\"121\":1}}],[\"方法\",{\"1\":{\"100\":1}}],[\"方程的两边同时乘上一个非00数不改变方程的解\",{\"1\":{\"95\":1}}],[\"方程组中的系数为实数\",{\"1\":{\"95\":1}}],[\"除最后一层节点\",{\"1\":{\"128\":1}}],[\"除以\",{\"1\":{\"99\":1}}],[\"除了自己\",{\"1\":{\"65\":1}}],[\"∗1∗b\",{\"1\":{\"99\":1}}],[\"∗1\",{\"1\":{\"99\":1}}],[\"∗\",{\"1\":{\"99\":9}}],[\"∗b\",{\"1\":{\"99\":1}}],[\"请你选择尽量少的区间\",{\"1\":{\"142\":1}}],[\"请你在数轴上选择尽量少的点\",{\"1\":{\"139\":1}}],[\"请你输出\",{\"1\":{\"99\":1}}],[\"请你求出数列中每个数的二进制表示中\",{\"1\":{\"47\":1}}],[\"请你求出\",{\"1\":{\"15\":1,\"102\":1}}],[\"请你求出给定的\",{\"1\":{\"12\":1}}],[\"定理\",{\"1\":{\"99\":1,\"104\":1,\"109\":1}}],[\"定理求组合数\",{\"0\":{\"99\":1}}],[\"定义成小根堆的方式\",{\"1\":{\"133\":1}}],[\"定义有向图游戏g\",{\"1\":{\"109\":1}}],[\"定义sg\",{\"1\":{\"108\":1}}],[\"定义mex\",{\"1\":{\"107\":1}}],[\"定义一个小根堆\",{\"1\":{\"62\":1}}],[\"定义一个借位的情况\",{\"1\":{\"36\":1}}],[\"定义\",{\"1\":{\"46\":2}}],[\"定义区间为闭区间\",{\"1\":{\"31\":1}}],[\"卢卡斯\",{\"0\":{\"99\":1}}],[\"预处理范围内的所有质数\",{\"1\":{\"100\":1}}],[\"预处理阶乘的余数和阶乘逆元的余数\",{\"1\":{\"98\":1}}],[\"预处理出\",{\"1\":{\"91\":1}}],[\"首先预处理出所有阶乘取模的余数fact\",{\"1\":{\"98\":1}}],[\"乘积大于n\",{\"1\":{\"102\":1}}],[\"乘任意一个\",{\"1\":{\"98\":1}}],[\"乘法逆元\",{\"1\":{\"98\":1}}],[\"乘法逆元的定义\",{\"1\":{\"98\":1}}],[\"费马小定理\",{\"1\":{\"98\":1}}],[\"递推式\",{\"1\":{\"97\":1}}],[\"递推法求组合数\",{\"0\":{\"97\":1}}],[\"递归边界使某数变成了0\",{\"1\":{\"87\":1}}],[\"递归\",{\"1\":{\"87\":1}}],[\"递归排序\",{\"1\":{\"26\":1}}],[\"递归的终止情况\",{\"1\":{\"25\":1}}],[\"递归处理子问题\",{\"1\":{\"25\":2}}],[\"递归从后往前更新\",{\"1\":{\"21\":1}}],[\"控制精度\",{\"1\":{\"95\":1}}],[\"未确定阶梯型的行\",{\"1\":{\"95\":1}}],[\"未染色的点\",{\"1\":{\"71\":1}}],[\"未染色\",{\"1\":{\"71\":1}}],[\"适用题型\",{\"1\":{\"97\":1}}],[\"适用于求解包含\",{\"1\":{\"95\":1}}],[\"适合稀疏图\",{\"1\":{\"60\":1}}],[\"适合稠密图\",{\"1\":{\"60\":1}}],[\"阶梯型矩阵\",{\"1\":{\"95\":1}}],[\"化为\",{\"1\":{\"95\":1}}],[\"通过\",{\"1\":{\"100\":1}}],[\"通过定理求组合数c\",{\"1\":{\"99\":1}}],[\"通过预处理逆元的方式求组和数\",{\"0\":{\"98\":1}}],[\"通过初等行变换把\",{\"1\":{\"95\":1}}],[\"通过一个连接起来\",{\"1\":{\"68\":1}}],[\"列col\",{\"1\":{\"95\":1}}],[\"列\",{\"1\":{\"95\":1}}],[\"列的状态是\",{\"1\":{\"18\":1}}],[\"初等行\",{\"1\":{\"95\":1}}],[\"初始时队列里只有起始点\",{\"1\":{\"64\":1}}],[\"初始化为它自身\",{\"1\":{\"128\":1}}],[\"初始化find\",{\"1\":{\"127\":1}}],[\"初始化各个顶点在不同的集合中\",{\"1\":{\"70\":1}}],[\"初始化\",{\"1\":{\"25\":1,\"54\":1,\"67\":1,\"114\":1,\"115\":1,\"125\":1,\"126\":1,\"127\":1,\"132\":1}}],[\"初始化大于1的区间为最大\",{\"1\":{\"14\":1}}],[\"初始值\",{\"1\":{\"14\":1}}],[\"扩展欧几里得\",{\"1\":{\"94\":1}}],[\"扩展欧几里得算法\",{\"0\":{\"92\":1}}],[\"≡\",{\"1\":{\"94\":1,\"98\":2,\"99\":1}}],[\"∈\",{\"1\":{\"94\":1}}],[\"事实上\",{\"1\":{\"93\":1}}],[\"显然无解\",{\"1\":{\"93\":1}}],[\"​\",{\"1\":{\"93\":1,\"98\":1}}],[\"成立\",{\"1\":{\"93\":1}}],[\"都可以是\",{\"1\":{\"133\":1}}],[\"都采取最优策略行动时游戏的结果\",{\"1\":{\"104\":1}}],[\"都会输掉游戏\",{\"1\":{\"104\":1}}],[\"都一定是\",{\"1\":{\"93\":1}}],[\"都是由男孩子指向女孩子\",{\"1\":{\"72\":1}}],[\"裴蜀定理\",{\"0\":{\"93\":1}}],[\"反之则为\",{\"1\":{\"102\":1}}],[\"反之\",{\"1\":{\"93\":1}}],[\"反之为\",{\"1\":{\"91\":1}}],[\"反证法证明\",{\"1\":{\"78\":1}}],[\"还需要补上\",{\"1\":{\"90\":1}}],[\"还是\",{\"1\":{\"31\":1,\"46\":1,\"78\":1}}],[\"倍增的思想\",{\"1\":{\"133\":1}}],[\"倍\",{\"1\":{\"90\":2}}],[\"也称静态链表\",{\"1\":{\"114\":1}}],[\"也可以用来判断奇数和偶数\",{\"1\":{\"91\":1}}],[\"也是\",{\"1\":{\"90\":1}}],[\"也将其倍数从\",{\"1\":{\"82\":1}}],[\"共\",{\"1\":{\"90\":1}}],[\"共一行\",{\"1\":{\"47\":1}}],[\"互质时\",{\"1\":{\"98\":1}}],[\"互质的充分必要条件是存在整数\",{\"1\":{\"93\":1}}],[\"互质的数的个数被称为欧拉函数\",{\"1\":{\"89\":1}}],[\"互质\",{\"1\":{\"90\":1,\"98\":2}}],[\"ϕ\",{\"1\":{\"89\":1}}],[\"记\",{\"1\":{\"102\":1}}],[\"记为\",{\"1\":{\"89\":1,\"98\":1}}],[\"记录素数个数\",{\"1\":{\"83\":1}}],[\"记录前缀中各个数字个数\",{\"1\":{\"16\":1}}],[\"记录答案\",{\"1\":{\"16\":1}}],[\"防止溢出\",{\"1\":{\"87\":1}}],[\"辗转相除法时间可以忽略不计\",{\"1\":{\"87\":1}}],[\"辗转相除法\",{\"1\":{\"87\":1}}],[\"欧拉函数的定义\",{\"1\":{\"89\":1}}],[\"欧拉函数\",{\"0\":{\"88\":1}}],[\"欧拉筛\",{\"0\":{\"83\":1}}],[\"欧几里得算法\",{\"1\":{\"87\":1}}],[\"特别地\",{\"1\":{\"93\":1,\"108\":1}}],[\"特判最中间的数\",{\"1\":{\"85\":1}}],[\"特殊\",{\"1\":{\"15\":1}}],[\"约数之和\",{\"1\":{\"86\":2}}],[\"约数个数\",{\"1\":{\"86\":1}}],[\"约数个数和约数之和\",{\"0\":{\"86\":1}}],[\"约数\",{\"0\":{\"84\":1}}],[\"约数枚举\",{\"1\":{\"79\":1}}],[\"避免和头文件next冲突\",{\"1\":{\"122\":1}}],[\"避免重复筛选\",{\"1\":{\"83\":1}}],[\"避免发生边界问题导致死循环\",{\"1\":{\"25\":1}}],[\"之后的尾迭代器\",{\"1\":{\"134\":1}}],[\"之后用\",{\"1\":{\"83\":1}}],[\"之间的所有数字中0~9的出现次数\",{\"1\":{\"16\":1}}],[\"线性代数方法解非齐次线性方程组\",{\"1\":{\"95\":1}}],[\"线性筛法求素数\",{\"1\":{\"100\":1}}],[\"线性筛\",{\"0\":{\"83\":1}}],[\"线性dp写法\",{\"1\":{\"8\":1}}],[\"线性dp\",{\"0\":{\"7\":1}}],[\"内的素数了\",{\"1\":{\"82\":1}}],[\"内有多少个素数\",{\"1\":{\"82\":1}}],[\"解法\",{\"1\":{\"82\":1}}],[\"剩下的就是质数\",{\"1\":{\"81\":1}}],[\"趋于无穷大时\",{\"1\":{\"81\":1}}],[\"调和级数\",{\"1\":{\"81\":1}}],[\"筛素数\",{\"1\":{\"100\":1}}],[\"筛法求出范围内的所有质数\",{\"1\":{\"100\":1}}],[\"筛法求欧拉函数\",{\"0\":{\"90\":1}}],[\"筛法求素数\",{\"0\":{\"80\":1}}],[\"筛掉它的倍数\",{\"1\":{\"81\":1}}],[\"埃氏筛\",{\"0\":{\"81\":1}}],[\"√n\",{\"1\":{\"79\":3}}],[\"素数测试\",{\"1\":{\"79\":1}}],[\"汇总\",{\"0\":{\"79\":1}}],[\"于是我们发现只有一个大于\",{\"1\":{\"78\":1}}],[\"试除法求所有约数\",{\"0\":{\"85\":1}}],[\"试除法分解质因数\",{\"0\":{\"78\":1}}],[\"试除法判定质数\",{\"0\":{\"77\":1}}],[\"质数定理\",{\"1\":{\"81\":1}}],[\"质数\",{\"0\":{\"76\":1},\"1\":{\"90\":1}}],[\"四\",{\"0\":{\"75\":1}}],[\"下标从1开始\",{\"1\":{\"122\":1,\"128\":1}}],[\"下标从1开始存\",{\"1\":{\"12\":1}}],[\"下家\",{\"1\":{\"72\":1}}],[\"那它就是一个质数\",{\"1\":{\"81\":1}}],[\"那就匹配并标记\",{\"1\":{\"72\":1}}],[\"那么再从头开始查找\",{\"1\":{\"131\":1}}],[\"那么对于任意的整数\",{\"1\":{\"93\":1}}],[\"那么相乘会大于\",{\"1\":{\"78\":1}}],[\"那么它就是一个完美匹配\",{\"1\":{\"72\":1}}],[\"那么加上自己之后一共有n+1个点\",{\"1\":{\"65\":1}}],[\"那么最短路可能为负无穷\",{\"1\":{\"63\":1}}],[\"那么\",{\"1\":{\"32\":1,\"81\":1,\"118\":2}}],[\"那么子节点随意\",{\"1\":{\"21\":1}}],[\"那么称这一段数是两个数列的公共上升子序列\",{\"1\":{\"11\":1}}],[\"你有没有备胎\",{\"1\":{\"72\":1}}],[\"你就去问问她男朋友\",{\"1\":{\"72\":1}}],[\"出发的点不算\",{\"1\":{\"72\":1}}],[\"出现了多少次\",{\"1\":{\"32\":1}}],[\"形成的路径叫交替路\",{\"1\":{\"72\":1}}],[\"依次遍历每个区间\",{\"1\":{\"142\":1}}],[\"依次经过非匹配边\",{\"1\":{\"72\":1}}],[\"依次枚举第一个集合中的每个点能否匹配第二个集合中的点\",{\"1\":{\"72\":1}}],[\"依次枚举\",{\"1\":{\"32\":1}}],[\"交换两个点\",{\"1\":{\"128\":1}}],[\"交换两个方程的位置\",{\"1\":{\"95\":1}}],[\"交换两个数\",{\"1\":{\"46\":1}}],[\"交换某两行\",{\"1\":{\"95\":1}}],[\"交替路\",{\"1\":{\"72\":1}}],[\"完全\",{\"1\":{\"128\":1}}],[\"完全背包\",{\"0\":{\"4\":1}}],[\"完美匹配\",{\"1\":{\"72\":1}}],[\"称为这个图的最大匹配\",{\"1\":{\"72\":1}}],[\"匹配完成后的具体操作\",{\"1\":{\"122\":1}}],[\"匹配完我输出一下\",{\"1\":{\"122\":1}}],[\"匹配操作\",{\"1\":{\"122\":1}}],[\"匹配时\",{\"1\":{\"122\":2}}],[\"匹配边\",{\"1\":{\"72\":1}}],[\"匹配\",{\"1\":{\"72\":3}}],[\"匈牙利算法中只会用到从第一个集合指向第二个集合的边\",{\"1\":{\"72\":1}}],[\"匈牙利算法\",{\"0\":{\"72\":1}}],[\"参数\",{\"1\":{\"71\":1}}],[\"遍历所有左端点在l的左边的区间\",{\"1\":{\"142\":1}}],[\"遍历所有点\",{\"1\":{\"71\":1,\"72\":1}}],[\"遍历n个点\",{\"1\":{\"61\":1}}],[\"区分\",{\"1\":{\"71\":1}}],[\"区间覆盖\",{\"0\":{\"142\":1}}],[\"区间分组\",{\"0\":{\"141\":1}}],[\"区间选点\",{\"0\":{\"139\":1}}],[\"区间问题\",{\"0\":{\"138\":1}}],[\"区间筛法\",{\"0\":{\"82\":1}}],[\"区间合并\",{\"0\":{\"50\":1,\"143\":1}}],[\"区间终点\",{\"1\":{\"14\":1}}],[\"区间长度\",{\"1\":{\"14\":1}}],[\"区间\",{\"1\":{\"14\":1}}],[\"区间dp枚举套路\",{\"1\":{\"14\":1}}],[\"区间dp\",{\"0\":{\"14\":1}}],[\"染色失败\",{\"1\":{\"71\":1}}],[\"染色可以使用\",{\"1\":{\"71\":1}}],[\"染色法判别二分图\",{\"0\":{\"71\":1}}],[\"连通图\",{\"1\":{\"71\":1}}],[\"连通这两个顶点\",{\"1\":{\"70\":1}}],[\"性质\",{\"1\":{\"71\":1,\"118\":1}}],[\"重载小于运算符\",{\"1\":{\"141\":1}}],[\"重载小于号\",{\"1\":{\"70\":1}}],[\"重载\",{\"1\":{\"134\":1}}],[\"重复执行直到队列为空\",{\"1\":{\"64\":1}}],[\"按左端点排序\",{\"1\":{\"143\":1}}],[\"按左端点从小到大排序\",{\"1\":{\"141\":1}}],[\"按右端点从小到大排序\",{\"1\":{\"139\":1}}],[\"按字典序\",{\"1\":{\"133\":1}}],[\"按快排的从小到大的顺序遍历每条边\",{\"1\":{\"70\":1}}],[\"按位取反\",{\"1\":{\"46\":1}}],[\"按位异或\",{\"1\":{\"46\":1}}],[\"按位或\",{\"1\":{\"46\":1}}],[\"按位与\",{\"1\":{\"46\":1}}],[\"父节点为它自己\",{\"1\":{\"70\":1}}],[\"权重\",{\"1\":{\"70\":1}}],[\"组询问\",{\"1\":{\"99\":1}}],[\"组成最小生成树\",{\"1\":{\"70\":1}}],[\"组物品和一个容量是\",{\"1\":{\"6\":1}}],[\"值是0x3f3f3f3f\",{\"1\":{\"69\":1}}],[\"距离最近的点\",{\"1\":{\"69\":1}}],[\"距离都初始化为无穷大\",{\"1\":{\"61\":1}}],[\"加1\",{\"1\":{\"122\":1}}],[\"加入到集合中\",{\"1\":{\"70\":1}}],[\"加入到连通块中\",{\"1\":{\"69\":1}}],[\"加边法\",{\"1\":{\"70\":1}}],[\"加到集合当中去\",{\"1\":{\"69\":1}}],[\"加点法\",{\"1\":{\"69\":1}}],[\"加上\",{\"1\":{\"35\":1,\"36\":1}}],[\"叫做求最小生成树\",{\"1\":{\"68\":1}}],[\"换句话来说\",{\"1\":{\"68\":1}}],[\"换成\",{\"1\":{\"30\":1}}],[\"换成a\",{\"1\":{\"30\":1}}],[\"多么真实而实用的算法\",{\"1\":{\"72\":1}}],[\"多源汇最短路\",{\"0\":{\"66\":1}}],[\"多重背包\",{\"0\":{\"5\":1}}],[\"原理\",{\"1\":{\"65\":1}}],[\"原因是\",{\"1\":{\"63\":1}}],[\"总点数\",{\"1\":{\"65\":1}}],[\"总点数和总边数\",{\"1\":{\"64\":1}}],[\"平均情况下\",{\"1\":{\"64\":1}}],[\"该函数常用于离散化\",{\"1\":{\"134\":1}}],[\"该游戏被称为有向图游戏\",{\"1\":{\"106\":1}}],[\"该点到它本身的路径赋为0\",{\"1\":{\"64\":1}}],[\"该表格的初始值要赋为极大值\",{\"1\":{\"64\":1}}],[\"该式被称为三角不等式\",{\"1\":{\"63\":1}}],[\"基于平衡二叉树\",{\"1\":{\"133\":1}}],[\"基本思路\",{\"1\":{\"91\":1}}],[\"基本步骤\",{\"1\":{\"64\":1}}],[\"基础算法\",{\"0\":{\"24\":1}}],[\"路径中至少存在两个相同的点\",{\"1\":{\"63\":1}}],[\"由两名玩家交替行动\",{\"1\":{\"105\":1}}],[\"由抽屉原理一定有两个点相同\",{\"1\":{\"65\":1}}],[\"由抽屉原理\",{\"1\":{\"63\":1}}],[\"由于某个点染色成功并不代表整个图就是二分图\",{\"1\":{\"71\":1}}],[\"由于是每个点同时向外出发\",{\"1\":{\"63\":1}}],[\"由于在除法运算中\",{\"1\":{\"38\":1}}],[\"``dist\",{\"1\":{\"63\":1}}],[\"号点的判断中需要进行\",{\"1\":{\"63\":1}}],[\"影响到下一个点\",{\"1\":{\"63\":1}}],[\"松弛操作\",{\"1\":{\"63\":2}}],[\"如\",{\"1\":{\"64\":1,\"122\":1}}],[\"如点\",{\"1\":{\"63\":1}}],[\"如果两区间无法合并\",{\"1\":{\"143\":1}}],[\"如果两个连通块不连通\",{\"1\":{\"70\":1}}],[\"如果所有右端点都小于l\",{\"1\":{\"142\":1}}],[\"如果所有点都入队了\",{\"1\":{\"58\":1}}],[\"如果到了末尾\",{\"1\":{\"131\":1}}],[\"如果x不在哈希表中\",{\"1\":{\"131\":1}}],[\"如果x在哈希表中\",{\"1\":{\"131\":1}}],[\"如果比父节点大\",{\"1\":{\"128\":1}}],[\"如果它本身不是最小的数\",{\"1\":{\"128\":1}}],[\"如果它们都包含一段位置不一定连续的数\",{\"1\":{\"11\":1}}],[\"如果窗口满足条件\",{\"1\":{\"121\":1}}],[\"如果要插在k的左边\",{\"1\":{\"115\":1}}],[\"如果取模的数是质数\",{\"1\":{\"98\":1}}],[\"如果满足条件再输出结果\",{\"1\":{\"121\":1}}],[\"如果满足\",{\"1\":{\"98\":1}}],[\"如果存在\",{\"1\":{\"94\":1}}],[\"如果存在负环\",{\"1\":{\"65\":1}}],[\"如果当前数能整除目标数\",{\"1\":{\"85\":1}}],[\"如果最后\",{\"1\":{\"78\":1}}],[\"如果最高位有数\",{\"1\":{\"35\":1}}],[\"如果这个点未被匹配\",{\"1\":{\"72\":1}}],[\"如果在这一轮的匹配中\",{\"1\":{\"72\":1}}],[\"如果你想找的妹子已经有了男朋友\",{\"1\":{\"72\":1}}],[\"如果途径另一个未匹配点\",{\"1\":{\"72\":1}}],[\"如果一个图的某个匹配中\",{\"1\":{\"72\":1}}],[\"如果该数没有被筛掉\",{\"1\":{\"81\":1}}],[\"如果该条边上的两个顶点在一个集合中\",{\"1\":{\"70\":1}}],[\"如果该元素大于栈顶元素\",{\"1\":{\"9\":1}}],[\"如果没有在树中\",{\"1\":{\"69\":1}}],[\"如果图不连通\",{\"1\":{\"69\":1}}],[\"如果图中存在负权回路\",{\"1\":{\"63\":1}}],[\"如果从1号点到x的最短路中包含至少n个点\",{\"1\":{\"65\":1}}],[\"如果从1号点无法走到n号点则返回\",{\"1\":{\"64\":1}}],[\"如果某条最短路径上有n个点\",{\"1\":{\"65\":1}}],[\"如果队列中已存在j\",{\"1\":{\"64\":1}}],[\"如果变短且该点不在队列中\",{\"1\":{\"64\":1}}],[\"如果第n次迭代仍然会松弛三角不等式\",{\"1\":{\"63\":1}}],[\"如果无法从1走到n\",{\"1\":{\"63\":1}}],[\"如果为无穷大\",{\"1\":{\"61\":1}}],[\"如果不能覆盖掉右端点\",{\"1\":{\"139\":1}}],[\"如果不在一个集合中\",{\"1\":{\"70\":1}}],[\"如果不存在\",{\"1\":{\"62\":1}}],[\"如果不存在则返回\",{\"1\":{\"61\":1}}],[\"如果不是起点\",{\"1\":{\"58\":1}}],[\"如果想将一个单元清零\",{\"1\":{\"46\":1}}],[\"如果t\",{\"1\":{\"36\":1}}],[\"如果有两个大于\",{\"1\":{\"78\":1}}],[\"如果有那就使在同一个集合中\",{\"1\":{\"70\":1}}],[\"如果有\",{\"1\":{\"36\":1,\"82\":1}}],[\"如果有一部分遍历完了\",{\"1\":{\"26\":1}}],[\"如果a\",{\"1\":{\"36\":2}}],[\"如果条件成立则记下答案\",{\"1\":{\"31\":1}}],[\"如果\",{\"1\":{\"25\":1,\"36\":1,\"70\":1,\"83\":1,\"86\":1,\"93\":1,\"94\":1,\"98\":1,\"118\":1}}],[\"次后变为一个式子\",{\"1\":{\"94\":1}}],[\"次之后\",{\"1\":{\"63\":1}}],[\"次\",{\"1\":{\"63\":2,\"99\":1}}],[\"次询问\",{\"1\":{\"12\":1}}],[\"迭代器的++\",{\"1\":{\"133\":1}}],[\"迭代\",{\"1\":{\"63\":1}}],[\"具体方法是\",{\"1\":{\"106\":1}}],[\"具体步骤\",{\"1\":{\"63\":1}}],[\"具体问题的逻辑\",{\"1\":{\"48\":1}}],[\"包括负权边\",{\"1\":{\"63\":1}}],[\"包含\",{\"1\":{\"47\":1}}],[\"包含前导零\",{\"1\":{\"16\":1}}],[\"稀疏图改用\",{\"1\":{\"62\":1}}],[\"稀疏图用邻接表\",{\"1\":{\"61\":1}}],[\"寻找距离最小的点\",{\"1\":{\"61\":1}}],[\"寻找两点之间的最大距离\",{\"1\":{\"54\":1}}],[\"直到具有\",{\"1\":{\"70\":1}}],[\"直到第n个点\",{\"1\":{\"61\":1}}],[\"直接将其指向下下个节点\",{\"1\":{\"114\":1}}],[\"直接异或运算进行整数交换后\",{\"1\":{\"46\":1}}],[\"直接搜索数组a和b\",{\"1\":{\"35\":1,\"36\":1}}],[\"访问加入集合并标记\",{\"1\":{\"61\":1}}],[\"访问标记\",{\"1\":{\"21\":1}}],[\"逐个遍历\",{\"1\":{\"61\":1}}],[\"逐位压入数组中\",{\"1\":{\"37\":1}}],[\"稠密图用邻接矩阵\",{\"1\":{\"61\":1}}],[\"点的数量\",{\"1\":{\"62\":1}}],[\"点数和边数\",{\"1\":{\"61\":1}}],[\"点多\",{\"1\":{\"60\":1}}],[\"点少边比较多\",{\"1\":{\"60\":1}}],[\"点从\",{\"1\":{\"19\":1}}],[\"边\",{\"1\":{\"63\":1}}],[\"边多\",{\"1\":{\"60\":1}}],[\"边界条件\",{\"1\":{\"16\":1}}],[\"条边为止\",{\"1\":{\"70\":1}}],[\"条边\",{\"1\":{\"60\":1,\"68\":1}}],[\"单词查找树\",{\"1\":{\"123\":1}}],[\"单调栈\",{\"0\":{\"118\":1}}],[\"单调队列\",{\"0\":{\"121\":1}}],[\"单调队列思维\",{\"1\":{\"9\":1}}],[\"单调队列写法\",{\"1\":{\"9\":1}}],[\"单链表只能存储当前节点的值和指向下一节点的指针\",{\"1\":{\"114\":1}}],[\"单链表\",{\"0\":{\"114\":1}}],[\"单源最短路\",{\"0\":{\"60\":1}}],[\"说明这个数是它的一个约数\",{\"1\":{\"85\":1}}],[\"说明这就是大于\",{\"1\":{\"78\":1}}],[\"说明此时的\",{\"1\":{\"83\":1}}],[\"说明此时遍历到的\",{\"1\":{\"83\":1}}],[\"说明两个顶点已经连通\",{\"1\":{\"70\":1}}],[\"说明图中存在负权回路\",{\"1\":{\"63\":1}}],[\"说明不连通\",{\"1\":{\"61\":1}}],[\"说明存在拓扑序列\",{\"1\":{\"58\":1}}],[\"说明是叶子节点\",{\"1\":{\"21\":1}}],[\"头尾指针\",{\"1\":{\"58\":1}}],[\"采用数组模拟队列的写法\",{\"1\":{\"58\":1}}],[\"结束\",{\"1\":{\"123\":1}}],[\"结尾\",{\"1\":{\"123\":1}}],[\"结构体存储\",{\"1\":{\"70\":1}}],[\"结论\",{\"1\":{\"58\":1,\"78\":1,\"98\":1}}],[\"结果为零\",{\"1\":{\"46\":1}}],[\"结果才为0\",{\"1\":{\"45\":1}}],[\"结果才为1\",{\"1\":{\"45\":1}}],[\"拓扑排序\",{\"0\":{\"58\":1}}],[\"宽度优先遍历\",{\"0\":{\"57\":1}}],[\"深度优先遍历\",{\"0\":{\"56\":1}}],[\"无法存储上一节点\",{\"1\":{\"114\":1}}],[\"无法移动者判负\",{\"1\":{\"106\":1}}],[\"无法形成最短路\",{\"1\":{\"61\":1}}],[\"无论如何操作\",{\"1\":{\"104\":1}}],[\"无解\",{\"1\":{\"95\":1}}],[\"无向图\",{\"1\":{\"61\":1}}],[\"无向图是没有拓扑序列的\",{\"1\":{\"58\":1}}],[\"无向图就再写一遍\",{\"1\":{\"54\":1}}],[\"无限次\",{\"1\":{\"4\":1}}],[\"存在乘法逆元的充要条件是\",{\"1\":{\"98\":1}}],[\"存在负权边\",{\"0\":{\"63\":1,\"64\":1},\"1\":{\"60\":1}}],[\"存的是当前加入的边数\",{\"1\":{\"70\":1}}],[\"存的是最小生成树的所有边的权值\",{\"1\":{\"70\":1}}],[\"存入a和b两点之间的距离\",{\"1\":{\"61\":1}}],[\"存边\",{\"1\":{\"54\":1}}],[\"存储字符串前k个字母的哈希值\",{\"1\":{\"132\":1}}],[\"存储堆中下标是k的点是第几个插入的\",{\"1\":{\"128\":1}}],[\"存储堆中的值\",{\"1\":{\"128\":1}}],[\"存储第k个插入的点在堆中的位置\",{\"1\":{\"128\":1}}],[\"存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\",{\"1\":{\"72\":1}}],[\"存储x到p\",{\"1\":{\"127\":1}}],[\"存储x是否被筛掉\",{\"1\":{\"81\":1,\"83\":1,\"90\":1}}],[\"存储当前用到的下标\",{\"1\":{\"123\":1}}],[\"存储以每个节点结尾的单词数量\",{\"1\":{\"123\":1}}],[\"存储树中每个节点的子节点\",{\"1\":{\"123\":1}}],[\"存储形式如下\",{\"1\":{\"123\":1}}],[\"存储节点的next指针\",{\"1\":{\"114\":1}}],[\"存储节点的值\",{\"1\":{\"114\":1}}],[\"存储图和树\",{\"1\":{\"114\":1}}],[\"存储其他点到当前最小生成树的距离\",{\"1\":{\"69\":1}}],[\"存储1到x的最短路中经过的点数\",{\"1\":{\"65\":1}}],[\"存储1到x的最短路距离\",{\"1\":{\"63\":1}}],[\"存储1号点到x的最短距离\",{\"1\":{\"65\":1}}],[\"存储1号点到每个点的最短距离\",{\"1\":{\"61\":1}}],[\"存储所有质数\",{\"1\":{\"100\":1}}],[\"存储所有素数\",{\"1\":{\"81\":1,\"83\":1,\"90\":1}}],[\"存储所有边\",{\"1\":{\"69\":1}}],[\"存储所有点到1号点的距离\",{\"1\":{\"62\":1}}],[\"存储所有待离散化的值\",{\"1\":{\"49\":1}}],[\"存储每个数是否已被筛掉\",{\"1\":{\"100\":1}}],[\"存储每个数的欧拉函数\",{\"1\":{\"90\":1}}],[\"存储每个质数的次数\",{\"1\":{\"100\":1}}],[\"存储每个点的祖宗节点\",{\"1\":{\"125\":1,\"126\":1,\"127\":1}}],[\"存储每个点的最短距离是否已确定\",{\"1\":{\"62\":1}}],[\"存储每个点的最短路是否已经确定\",{\"1\":{\"61\":1}}],[\"存储每个点是否已经在生成树中\",{\"1\":{\"69\":1}}],[\"存储每个点是否在队列中\",{\"1\":{\"64\":1,\"65\":1}}],[\"存储每个点到1号点的最短距离\",{\"1\":{\"64\":1}}],[\"存储每条边\",{\"1\":{\"61\":1}}],[\"存储点i的入度\",{\"1\":{\"58\":1}}],[\"存储这个单链表的头结点\",{\"1\":{\"54\":1}}],[\"存储k所有可以走到的点\",{\"1\":{\"54\":1}}],[\"存储边\",{\"1\":{\"54\":1}}],[\"存储\",{\"1\":{\"35\":1,\"36\":1,\"128\":1,\"132\":1}}],[\"添加一条边a\",{\"1\":{\"54\":1}}],[\"开放寻址法\",{\"0\":{\"131\":1}}],[\"开一个单链表\",{\"1\":{\"54\":1}}],[\"开始\",{\"1\":{\"14\":1}}],[\"邻接表存储图\",{\"1\":{\"71\":1}}],[\"邻接表存储所有边\",{\"1\":{\"62\":1,\"64\":1,\"65\":1,\"72\":1}}],[\"邻接表\",{\"1\":{\"54\":1,\"62\":1,\"114\":1}}],[\"邻接矩阵初始化为无穷大\",{\"1\":{\"61\":1}}],[\"邻接矩阵\",{\"1\":{\"54\":1,\"69\":1}}],[\"动态维护有序序列\",{\"1\":{\"133\":1}}],[\"动态邻接矩阵\",{\"1\":{\"54\":1}}],[\"动态规划\",{\"0\":{\"1\":1}}],[\"搜索与图论\",{\"0\":{\"53\":1}}],[\"映射到1\",{\"1\":{\"49\":1}}],[\"去重\",{\"1\":{\"134\":2}}],[\"去筛合数时\",{\"1\":{\"83\":1}}],[\"去掉重复元素\",{\"1\":{\"49\":1}}],[\"去除无效状态的优化写法\",{\"1\":{\"18\":1}}],[\"离散化\",{\"0\":{\"49\":1}}],[\"常见模型\",{\"1\":{\"118\":1,\"121\":1}}],[\"常见问题分类\",{\"1\":{\"48\":1}}],[\"常用库函数\",{\"0\":{\"134\":1}}],[\"常用来对一个数据的某些位设置为1\",{\"1\":{\"46\":1}}],[\"常用模版\",{\"1\":{\"14\":1}}],[\"作用\",{\"1\":{\"47\":1,\"128\":1}}],[\"思路\",{\"1\":{\"47\":2,\"81\":1,\"90\":1,\"94\":1}}],[\"得看被移数是正还是负\",{\"1\":{\"46\":1}}],[\"得到该位的被除数\",{\"1\":{\"38\":1}}],[\"得到总区间的最小代价\",{\"1\":{\"14\":1}}],[\"负数左补\",{\"1\":{\"46\":1}}],[\"负数按补码形式参加按位与运算\",{\"1\":{\"46\":1}}],[\"正数左补\",{\"1\":{\"46\":1}}],[\"设g1\",{\"1\":{\"109\":1}}],[\"设从x出发共有k条有向边\",{\"1\":{\"108\":1}}],[\"设s表示一个非负整数集合\",{\"1\":{\"107\":1}}],[\"设\",{\"1\":{\"46\":1}}],[\"设置两个头尾指针\",{\"1\":{\"25\":1}}],[\"逻辑运算符和其他运算符都高\",{\"1\":{\"46\":1}}],[\"逻辑右移\",{\"1\":{\"45\":1}}],[\"会随着其他数值而受到影响\",{\"1\":{\"63\":1}}],[\"会导致\",{\"1\":{\"46\":1}}],[\"会对应这个数列的连续一段\",{\"1\":{\"32\":1}}],[\"相邻\",{\"1\":{\"134\":1}}],[\"相关概念\",{\"1\":{\"72\":1}}],[\"相当于是每次考虑合并两个式子\",{\"1\":{\"94\":1}}],[\"相当于存在两个相邻的点染成了相同的颜色\",{\"1\":{\"71\":1}}],[\"相当于该数除以\",{\"1\":{\"46\":1}}],[\"相当于该数乘以\",{\"1\":{\"46\":1}}],[\"相同\",{\"1\":{\"134\":1}}],[\"相同数量级的数即可\",{\"1\":{\"63\":1}}],[\"相同为\",{\"1\":{\"46\":1}}],[\"相异或值不变\",{\"1\":{\"46\":1}}],[\"才为\",{\"1\":{\"46\":1}}],[\"才为1\",{\"1\":{\"46\":1}}],[\"来解决\",{\"1\":{\"47\":1}}],[\"来判断\",{\"1\":{\"46\":1}}],[\"来决定\",{\"1\":{\"46\":1}}],[\"代替\",{\"1\":{\"46\":1}}],[\"代码段\",{\"1\":{\"36\":1}}],[\"代码如下\",{\"1\":{\"35\":1,\"37\":1,\"38\":1,\"47\":2}}],[\"代码\",{\"1\":{\"11\":1,\"13\":1,\"14\":1}}],[\"就把k改为l\",{\"1\":{\"115\":1}}],[\"就不是公平组合游戏\",{\"1\":{\"105\":1}}],[\"就不是用最小质因子去更新了\",{\"1\":{\"83\":1}}],[\"就可以把埃氏筛法运用在\",{\"1\":{\"82\":1}}],[\"就删去了所有的合数\",{\"1\":{\"81\":1}}],[\"就将这条边加入集合中\",{\"1\":{\"70\":1}}],[\"就得到了最短路径\",{\"1\":{\"64\":1}}],[\"就说明存在一条长度是n+1的最短路径\",{\"1\":{\"63\":1}}],[\"就是判断\",{\"1\":{\"91\":1}}],[\"就是一个质因数\",{\"1\":{\"81\":1}}],[\"就是\",{\"1\":{\"71\":1,\"83\":1}}],[\"就是给定一个无向图\",{\"1\":{\"68\":1}}],[\"就是奇数\",{\"1\":{\"46\":1}}],[\"就是偶数\",{\"1\":{\"46\":1}}],[\"就交换位置\",{\"1\":{\"128\":1}}],[\"就交换\",{\"1\":{\"25\":1}}],[\"进行\",{\"1\":{\"71\":1}}],[\"进行异或运算\",{\"1\":{\"46\":1}}],[\"进行按位或运算\",{\"1\":{\"46\":1}}],[\"进行按位与运算\",{\"1\":{\"46\":1}}],[\"进位\",{\"1\":{\"35\":1}}],[\"然后\",{\"1\":{\"99\":1}}],[\"然后重复\",{\"1\":{\"87\":1}}],[\"然后从\",{\"1\":{\"82\":1}}],[\"然后删去它们的所有的倍数\",{\"1\":{\"81\":1}}],[\"然后将\",{\"1\":{\"46\":3}}],[\"然后判断\",{\"1\":{\"25\":1}}],[\"令\",{\"1\":{\"46\":3}}],[\"位整数范围内\",{\"1\":{\"94\":1}}],[\"位上的数是否为\",{\"1\":{\"91\":1}}],[\"位数字移动到最后一位\",{\"1\":{\"47\":1}}],[\"位数\",{\"1\":{\"47\":1}}],[\"位进行翻转\",{\"1\":{\"46\":1}}],[\"位设置为\",{\"1\":{\"46\":1}}],[\"位为\",{\"1\":{\"46\":3}}],[\"位\",{\"1\":{\"46\":4,\"47\":1}}],[\"位运算符作用于位\",{\"1\":{\"45\":1}}],[\"位运算符\",{\"0\":{\"45\":1}}],[\"位运算\",{\"0\":{\"44\":1}}],[\"比如围棋\",{\"1\":{\"105\":1}}],[\"比如归并排序中合并两个有序序列的操作\",{\"1\":{\"48\":1}}],[\"比如\",{\"1\":{\"46\":2,\"47\":1,\"118\":1}}],[\"比如将数\",{\"1\":{\"46\":2}}],[\"比如取数\",{\"1\":{\"46\":1}}],[\"比较左右两半边\",{\"1\":{\"26\":1}}],[\"注意multimap不支持此操作\",{\"1\":{\"133\":1}}],[\"注意乘除的先后顺序\",{\"1\":{\"87\":1}}],[\"注意\",{\"1\":{\"46\":1,\"121\":1}}],[\"全为\",{\"1\":{\"46\":2}}],[\"全部加起来\",{\"1\":{\"15\":1}}],[\"算法步骤\",{\"1\":{\"95\":1}}],[\"算法描述\",{\"1\":{\"72\":1}}],[\"算法结束后\",{\"1\":{\"67\":1}}],[\"算法\",{\"0\":{\"70\":1},\"1\":{\"60\":2}}],[\"算法思路\",{\"1\":{\"28\":1}}],[\"算术右移\",{\"1\":{\"45\":1}}],[\"各编译器处理方法不一样\",{\"1\":{\"45\":1}}],[\"各二进位全部右移若干位\",{\"1\":{\"45\":1}}],[\"各二进位全部左移若干位\",{\"1\":{\"45\":1}}],[\"异或\",{\"1\":{\"45\":1}}],[\"^=\",{\"1\":{\"46\":3,\"104\":1}}],[\"^\",{\"1\":{\"45\":1,\"46\":7,\"97\":3,\"99\":2,\"104\":3,\"109\":3,\"133\":1}}],[\"与模数\",{\"1\":{\"98\":1}}],[\"与一个各位都为零的数值相与\",{\"1\":{\"46\":1}}],[\"与\",{\"1\":{\"45\":1,\"46\":5,\"97\":1,\"98\":1}}],[\"与快排不同\",{\"1\":{\"26\":1}}],[\"运算符\",{\"1\":{\"134\":2}}],[\"运算符的优先级比算术运算符\",{\"1\":{\"46\":1}}],[\"运算的结果\",{\"1\":{\"108\":1}}],[\"运算\",{\"1\":{\"46\":1}}],[\"运算规则\",{\"1\":{\"45\":1,\"46\":4}}],[\"运用双指针的思想\",{\"1\":{\"26\":1}}],[\"描述\",{\"1\":{\"45\":1}}],[\"符号\",{\"1\":{\"45\":1}}],[\"并在gi上行动一步\",{\"1\":{\"109\":1}}],[\"并不是第一行\",{\"1\":{\"95\":1}}],[\"并回代得到方程的解\",{\"1\":{\"95\":1}}],[\"并查集\",{\"0\":{\"124\":1}}],[\"并查集核心操作\",{\"1\":{\"70\":1}}],[\"并查集的父节点数组\",{\"1\":{\"70\":1}}],[\"并且从每个局面向沿着合法行动能够到达的下一个局面连有向边\",{\"1\":{\"106\":1}}],[\"并且对于任意的整数\",{\"1\":{\"98\":1}}],[\"并且判断是否有解\",{\"1\":{\"94\":1}}],[\"并且边长之和最小\",{\"1\":{\"69\":1}}],[\"并且一般\",{\"1\":{\"14\":1}}],[\"并非真正的无穷大\",{\"1\":{\"63\":1}}],[\"并逐位执行操作\",{\"1\":{\"45\":1}}],[\"以及一个线段区间\",{\"1\":{\"142\":1}}],[\"以及所有阶乘取模的逆元infact\",{\"1\":{\"98\":1}}],[\"以second为第二关键字\",{\"1\":{\"133\":1}}],[\"以first为第一关键字\",{\"1\":{\"133\":1}}],[\"以内的素数表的话\",{\"1\":{\"82\":1}}],[\"以内的合数的最小质因数一定不超过\",{\"1\":{\"82\":1}}],[\"以\",{\"1\":{\"41\":1}}],[\"以k为终点的最短距离\",{\"1\":{\"19\":1}}],[\"便于直接对余数进行处理\",{\"1\":{\"38\":1}}],[\"÷\",{\"1\":{\"38\":2}}],[\"倒序输出\",{\"1\":{\"37\":1}}],[\"倒序插入\",{\"1\":{\"37\":1}}],[\"倒序存放\",{\"1\":{\"35\":1,\"36\":1}}],[\"用一个小根堆来维护所有组的右端点\",{\"1\":{\"141\":1}}],[\"用一个一维数组存储树\",{\"1\":{\"128\":1}}],[\"用法与\",{\"1\":{\"134\":1}}],[\"用单调队列来优化\",{\"1\":{\"121\":1}}],[\"用高精度乘法将所有质因子相乘\",{\"1\":{\"100\":2}}],[\"用高精度乘法把所有质因子乘上\",{\"1\":{\"100\":1}}],[\"用高精度相乘即可\",{\"1\":{\"100\":1}}],[\"用当前行将下面所有的列消成0\",{\"1\":{\"95\":1}}],[\"用初等行变换\",{\"1\":{\"95\":3}}],[\"用扩展欧几里得算法找出一组解\",{\"1\":{\"94\":1}}],[\"用于求解方程\",{\"1\":{\"93\":1}}],[\"用上面的公式定义求\",{\"1\":{\"89\":1}}],[\"用两数之积除以他们的最大公约数可得最小公倍数\",{\"1\":{\"87\":1}}],[\"用两个指针维护一段区间\",{\"1\":{\"48\":1}}],[\"用最小质因子去筛合数\",{\"1\":{\"83\":1}}],[\"用质数把其所有的倍数都筛掉\",{\"1\":{\"81\":1}}],[\"用队列来存储\",{\"1\":{\"64\":1}}],[\"用t更新其他点的距离\",{\"1\":{\"61\":1}}],[\"用途\",{\"0\":{\"46\":1}}],[\"用\",{\"1\":{\"37\":1,\"38\":1,\"47\":1,\"69\":1,\"71\":1,\"91\":1,\"98\":1,\"133\":1}}],[\"用来查找小于等于\",{\"1\":{\"30\":1}}],[\"用来查找大于等于\",{\"1\":{\"30\":1}}],[\"用来表示哪一行的小方块是横着放的\",{\"1\":{\"18\":1}}],[\"低精\",{\"1\":{\"37\":1,\"38\":1}}],[\"低位补0\",{\"1\":{\"45\":1}}],[\"低位变为0\",{\"1\":{\"35\":1}}],[\"低位满10向高位进位\",{\"1\":{\"35\":1}}],[\"×\",{\"1\":{\"37\":3,\"89\":4,\"91\":3}}],[\"返回指向第一个大于等于\",{\"1\":{\"134\":1}}],[\"返回去重\",{\"1\":{\"134\":1}}],[\"返回有多少个1\",{\"1\":{\"133\":1}}],[\"返回大于x的最小的数的迭代器\",{\"1\":{\"133\":1}}],[\"返回大于等于x的最小的数的迭代器\",{\"1\":{\"133\":1}}],[\"返回某一个数的个数\",{\"1\":{\"133\":1}}],[\"返回前驱和后继\",{\"1\":{\"133\":1}}],[\"返回栈顶元素\",{\"1\":{\"133\":1}}],[\"返回堆顶元素\",{\"1\":{\"133\":1}}],[\"返回队尾元素\",{\"1\":{\"133\":1}}],[\"返回队头元素\",{\"1\":{\"133\":1}}],[\"返回字符串所在字符数组的起始地址\",{\"1\":{\"133\":1}}],[\"返回字符串长度\",{\"1\":{\"133\":1}}],[\"返回子串\",{\"1\":{\"133\":1}}],[\"返回是否为空\",{\"1\":{\"133\":1}}],[\"返回元素个数\",{\"1\":{\"133\":1}}],[\"返回x应该插入的位置\",{\"1\":{\"131\":1}}],[\"返回x的下标\",{\"1\":{\"131\":1}}],[\"返回x的祖宗节点\",{\"1\":{\"125\":1,\"126\":1,\"127\":1}}],[\"返回\",{\"1\":{\"47\":1}}],[\"返回a\",{\"1\":{\"36\":1}}],[\"返回true\",{\"1\":{\"36\":2}}],[\"标记\",{\"1\":{\"83\":1}}],[\"标记点是否在队列中\",{\"1\":{\"64\":1}}],[\"标记为已加入到集合中\",{\"1\":{\"61\":1}}],[\"标记为0\",{\"1\":{\"36\":1}}],[\"标记为1\",{\"1\":{\"36\":1}}],[\"标号\",{\"1\":{\"19\":1}}],[\"即这个迭代器是去重之后末尾元素的下一个位置\",{\"1\":{\"134\":1}}],[\"即小根堆\",{\"1\":{\"128\":1}}],[\"即sg\",{\"1\":{\"108\":1}}],[\"即两人均无失误\",{\"1\":{\"104\":1}}],[\"即为\",{\"1\":{\"98\":1}}],[\"即用二进制来表示\",{\"1\":{\"91\":1}}],[\"即组合成\",{\"1\":{\"91\":1}}],[\"即找到了\",{\"1\":{\"83\":1}}],[\"即源码取反加\",{\"1\":{\"47\":1}}],[\"即除以\",{\"1\":{\"46\":1}}],[\"即乘上\",{\"1\":{\"46\":1}}],[\"即得\",{\"1\":{\"46\":1}}],[\"即\",{\"1\":{\"46\":3,\"47\":2,\"104\":2,\"107\":1,\"108\":1,\"109\":1}}],[\"即t\",{\"1\":{\"36\":1}}],[\"即可得到\",{\"1\":{\"46\":3}}],[\"即可\",{\"1\":{\"31\":1}}],[\"若两区间部分存在交集\",{\"1\":{\"143\":1}}],[\"若右儿子小于它\",{\"1\":{\"128\":1}}],[\"若左二子小于它\",{\"1\":{\"128\":1}}],[\"若左移时舍弃的高位不包含\",{\"1\":{\"46\":1}}],[\"若从1开始\",{\"1\":{\"122\":1}}],[\"若满足条件\",{\"1\":{\"121\":1}}],[\"若一个游戏满足\",{\"1\":{\"105\":1}}],[\"若在某一局面下存在某种行动\",{\"1\":{\"104\":1}}],[\"若在某一局面下无论采取何种行动\",{\"1\":{\"104\":1}}],[\"若在算数基本定理中\",{\"1\":{\"89\":1}}],[\"若p是质数\",{\"1\":{\"99\":1}}],[\"若整数\",{\"1\":{\"98\":1}}],[\"若\",{\"1\":{\"93\":2}}],[\"若为\",{\"1\":{\"91\":1}}],[\"若不进行备份会因此发生串联效应\",{\"1\":{\"63\":1}}],[\"若t\",{\"1\":{\"36\":1}}],[\"若a大于b\",{\"1\":{\"36\":1}}],[\"高斯消元适用解法\",{\"1\":{\"95\":1}}],[\"高斯消元\",{\"0\":{\"95\":1}}],[\"高位补0\",{\"1\":{\"45\":1}}],[\"高位丢弃\",{\"1\":{\"45\":1}}],[\"高位在后面\",{\"1\":{\"36\":1}}],[\"高精\",{\"1\":{\"37\":1,\"38\":1}}],[\"高精度乘低精度模板\",{\"1\":{\"100\":1}}],[\"高精度整数除法\",{\"0\":{\"38\":1}}],[\"高精度整数乘法\",{\"0\":{\"37\":1}}],[\"高精度减法\",{\"0\":{\"36\":1}}],[\"高精度加法\",{\"0\":{\"35\":1}}],[\"高精度算法\",{\"0\":{\"34\":1}}],[\"判断是否全为0\",{\"1\":{\"133\":1}}],[\"判断是否至少有一个1\",{\"1\":{\"133\":1}}],[\"判断是否有\",{\"1\":{\"36\":1}}],[\"判断当前元素与队尾元素是否满足单调性问题\",{\"1\":{\"121\":2}}],[\"判断队头是否滑出窗口\",{\"1\":{\"121\":1}}],[\"判断队头是否已经滑出窗口\",{\"1\":{\"121\":1}}],[\"判断队列是否为空\",{\"1\":{\"120\":1}}],[\"判断栈是否为空\",{\"1\":{\"117\":1}}],[\"判断这条边的两个顶点是否有相同的父节点\",{\"1\":{\"70\":1}}],[\"判断\",{\"1\":{\"63\":2,\"70\":1}}],[\"判断奇偶\",{\"1\":{\"46\":1}}],[\"判断b在这一位上有没有数\",{\"1\":{\"36\":1}}],[\"判断可能的答案更新区间\",{\"1\":{\"31\":1}}],[\"满足匹配条件\",{\"1\":{\"122\":1}}],[\"满足任意前缀中0的个数都不少于1的个数的序列的数量为\",{\"1\":{\"101\":1}}],[\"满足\",{\"1\":{\"36\":1,\"94\":1}}],[\"使得每组内部区间两两之间没有交集\",{\"1\":{\"141\":1}}],[\"使得每个区间内至少包含一个选出的点\",{\"1\":{\"139\":1}}],[\"使得行动后对面面临必败局面\",{\"1\":{\"104\":1}}],[\"使得ax\",{\"1\":{\"93\":1}}],[\"使得\",{\"1\":{\"71\":1,\"93\":2,\"98\":1}}],[\"使用并查集\",{\"1\":{\"70\":1}}],[\"使用快排将所有边按权值从小到大排序\",{\"1\":{\"70\":1}}],[\"使用邻接矩阵存图\",{\"1\":{\"67\":1}}],[\"使用\",{\"1\":{\"47\":1}}],[\"使用auto编译器会自动判断数据是什么类型\",{\"1\":{\"35\":1}}],[\"使\",{\"1\":{\"46\":1,\"93\":2}}],[\"使一个数的最低位为\",{\"1\":{\"46\":1}}],[\"使其全部二进制位为\",{\"1\":{\"46\":1}}],[\"使路径上的数字的和最大\",{\"1\":{\"8\":1}}],[\"同时\",{\"1\":{\"104\":1}}],[\"同加法一样处理进位\",{\"1\":{\"37\":1}}],[\"同理队尾\",{\"1\":{\"120\":1}}],[\"同理\",{\"1\":{\"35\":1,\"36\":1}}],[\"同一组内的物品最多只能选一个\",{\"1\":{\"6\":1}}],[\"例题二\",{\"1\":{\"47\":1}}],[\"例题一\",{\"1\":{\"47\":1}}],[\"例题\",{\"0\":{\"47\":1}}],[\"例如求长度\",{\"1\":{\"48\":1}}],[\"例如求\",{\"1\":{\"47\":1}}],[\"例如\",{\"1\":{\"35\":1,\"36\":1,\"46\":2,\"133\":1}}],[\"例二\",{\"1\":{\"32\":1}}],[\"压入c数组中\",{\"1\":{\"35\":1}}],[\"把一个数组去重\",{\"1\":{\"134\":1}}],[\"把一个\",{\"1\":{\"134\":2}}],[\"把一个方程的若干倍加到另一个方程上去\",{\"1\":{\"95\":1}}],[\"把第k位取反\",{\"1\":{\"133\":1}}],[\"把所有位变成0\",{\"1\":{\"133\":1}}],[\"把所有位置成1\",{\"1\":{\"133\":1}}],[\"把每个局面看成图中的一个节点\",{\"1\":{\"106\":1}}],[\"把游戏过程中面临的状态称为局面\",{\"1\":{\"104\":1}}],[\"把这一行换到最上面\",{\"1\":{\"95\":1}}],[\"把这个让给我好吧\",{\"1\":{\"72\":1}}],[\"把某行的若干倍加到另一行上去\",{\"1\":{\"95\":1}}],[\"把某一行乘一个非00的数\",{\"1\":{\"95\":1}}],[\"把找到的符合条件的点的长度加上\",{\"1\":{\"69\":1}}],[\"把b加入\",{\"1\":{\"64\":1}}],[\"把相加后的结果除以10求余\",{\"1\":{\"35\":1}}],[\"把集合选0个i\",{\"1\":{\"15\":1}}],[\"两名玩家交替地把这枚棋子沿有向边进行移动\",{\"1\":{\"106\":1}}],[\"两名玩家轮流行动\",{\"1\":{\"104\":1}}],[\"两人都采取最优策略\",{\"1\":{\"104\":1}}],[\"两点及其权值\",{\"1\":{\"70\":1}}],[\"两重\",{\"1\":{\"63\":1}}],[\"两个迭代器\",{\"1\":{\"134\":1}}],[\"两个集合\",{\"1\":{\"71\":1}}],[\"两个位相同为0\",{\"1\":{\"45\":1}}],[\"两个位都为0时\",{\"1\":{\"45\":1}}],[\"两个位都为1时\",{\"1\":{\"45\":1}}],[\"两个if把两个数组相同位上的数相加\",{\"1\":{\"35\":1}}],[\"两边递归\",{\"1\":{\"26\":1}}],[\"节省时间\",{\"1\":{\"35\":1,\"36\":1}}],[\"取模的数用2^64\",{\"1\":{\"132\":1}}],[\"取模加模再取模\",{\"1\":{\"94\":1}}],[\"取这两个值的冲突概率低\",{\"1\":{\"132\":1}}],[\"取走最后一件物品者获胜\",{\"1\":{\"104\":1}}],[\"取走任意多个物品\",{\"1\":{\"104\":1}}],[\"取出作为\",{\"1\":{\"64\":1}}],[\"取一个数的指定位\",{\"1\":{\"46\":1}}],[\"取反\",{\"1\":{\"45\":1}}],[\"取决于题目对精度的要求\",{\"1\":{\"33\":1}}],[\"取根节点两种方案的最大值\",{\"1\":{\"21\":1}}],[\"检查x是否满足某种性质\",{\"1\":{\"33\":1}}],[\"浮点数二分\",{\"0\":{\"33\":1}}],[\"offer\",{\"0\":{\"149\":1}}],[\"out\",{\"1\":{\"121\":1}}],[\"operator\",{\"1\":{\"134\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1}}],[\"operator<\",{\"1\":{\"70\":1}}],[\"operation\",{\"1\":{\"46\":1}}],[\"o\",{\"1\":{\"32\":1,\"55\":1,\"58\":1,\"60\":5,\"61\":1,\"62\":1,\"63\":1,\"64\":2,\"65\":1,\"69\":1,\"70\":3,\"71\":1,\"72\":1,\"77\":1,\"78\":2,\"79\":3,\"81\":1,\"83\":1,\"87\":1,\"91\":1,\"95\":1,\"128\":1,\"133\":4}}],[\"后进后出\",{\"1\":{\"119\":1}}],[\"后再减\",{\"1\":{\"36\":1}}],[\"后面一位\",{\"1\":{\"32\":1}}],[\"后缀部分\",{\"1\":{\"16\":1}}],[\"②\",{\"1\":{\"32\":1,\"90\":1}}],[\"①\",{\"1\":{\"32\":1,\"90\":1}}],[\"需要保证头结点存在\",{\"1\":{\"114\":1}}],[\"需要借位\",{\"1\":{\"36\":1}}],[\"需要用多重背包的二进制优化方法\",{\"1\":{\"5\":1}}],[\"需使用头文件\",{\"1\":{\"32\":1}}],[\"题目描述\",{\"1\":{\"32\":1}}],[\"改\",{\"1\":{\"31\":1}}],[\"是越界的\",{\"1\":{\"134\":1}}],[\"是堆顶\",{\"1\":{\"128\":1}}],[\"是一种能够高效存储和查找字符串集合的数据结构\",{\"1\":{\"123\":1}}],[\"是一个质数\",{\"1\":{\"98\":1}}],[\"是一个边的集合\",{\"1\":{\"72\":1}}],[\"是一个确定的值\",{\"1\":{\"63\":1}}],[\"是一个二进制数\",{\"1\":{\"18\":1}}],[\"是m个有向图游戏\",{\"1\":{\"109\":1}}],[\"是质数\",{\"1\":{\"99\":1}}],[\"是增广矩阵\",{\"1\":{\"95\":1}}],[\"是整数\",{\"1\":{\"93\":1}}],[\"是\",{\"1\":{\"90\":1}}],[\"是满足条件的第一个数\",{\"1\":{\"83\":1}}],[\"是否走到末尾\",{\"1\":{\"122\":1}}],[\"是否能到达\",{\"1\":{\"63\":1}}],[\"是否记下ans\",{\"1\":{\"31\":1}}],[\"是bellman\",{\"1\":{\"60\":1}}],[\"是同一个级别的类型\",{\"1\":{\"60\":1}}],[\"是不是偶数\",{\"1\":{\"46\":1}}],[\"或指针\",{\"1\":{\"134\":3}}],[\"或\",{\"1\":{\"31\":1,\"45\":1,\"71\":1}}],[\"或者重载\",{\"1\":{\"134\":1}}],[\"或者\",{\"1\":{\"29\":1,\"30\":1,\"46\":1}}],[\"简单来说就是\",{\"1\":{\"30\":1}}],[\"找不到则返回最后一个元素的下标+1\",{\"1\":{\"134\":1}}],[\"找出滑动窗口中的最大值\",{\"1\":{\"121\":1}}],[\"找出每个数左边离它最近的比它大\",{\"1\":{\"118\":1}}],[\"找到每一个数左边离他最近的比它小的数\",{\"1\":{\"118\":1}}],[\"找到绝对值最大的行\",{\"1\":{\"95\":1}}],[\"找到当前列绝对值最大的一行\",{\"1\":{\"95\":1}}],[\"找到最小整数解\",{\"1\":{\"94\":1}}],[\"找到该点赋给\",{\"1\":{\"69\":1}}],[\"找到不在集合当中的最小的点\",{\"1\":{\"69\":1}}],[\"找到一个未加入集合且距离最近的点\",{\"1\":{\"61\":1}}],[\"找到与起点最近的且未确定最短路径的点\",{\"1\":{\"61\":1}}],[\"找到第一个大于等于x的位置\",{\"1\":{\"49\":1}}],[\"找右端点\",{\"1\":{\"30\":1}}],[\"找左端点\",{\"1\":{\"29\":1}}],[\"答案在哪一侧\",{\"1\":{\"31\":1}}],[\"答案在右边界\",{\"1\":{\"30\":1}}],[\"答案在左边界\",{\"1\":{\"29\":1}}],[\"此时为了防止死循环\",{\"1\":{\"30\":1}}],[\"版本2\",{\"0\":{\"30\":1}}],[\"版本1\",{\"0\":{\"29\":1}}],[\"要求分成若干组\",{\"1\":{\"141\":1}}],[\"要求求解这个方程组\",{\"1\":{\"95\":1}}],[\"要求边长之和最小\",{\"1\":{\"68\":1}}],[\"要求计算\",{\"1\":{\"37\":1,\"38\":1}}],[\"要求计算出所有\",{\"1\":{\"32\":1}}],[\"要求找出一条路径\",{\"1\":{\"8\":1}}],[\"要上取整\",{\"1\":{\"30\":1}}],[\"要向下取整\",{\"1\":{\"29\":1}}],[\"计算子串\",{\"1\":{\"132\":1}}],[\"计算公式如下\",{\"1\":{\"102\":1}}],[\"计算起始点经过队头到其他点的距离是否变短\",{\"1\":{\"64\":1}}],[\"计算结果可能为负数\",{\"1\":{\"36\":1}}],[\"计算它们的差\",{\"1\":{\"36\":1}}],[\"计算它们的和\",{\"1\":{\"35\":1}}],[\"计算\",{\"1\":{\"29\":1,\"30\":1}}],[\"计数类dp\",{\"0\":{\"15\":1}}],[\"时为偶数\",{\"1\":{\"91\":1}}],[\"时为奇数\",{\"1\":{\"91\":1}}],[\"时才能表示已经将所有点加入到集合中\",{\"1\":{\"70\":1}}],[\"时间复杂度o\",{\"1\":{\"67\":1}}],[\"时间复杂度是\",{\"1\":{\"61\":1,\"62\":1,\"70\":1,\"72\":1,\"133\":1}}],[\"时间复杂度一般为\",{\"1\":{\"60\":1}}],[\"时间复杂度\",{\"1\":{\"55\":1,\"58\":1,\"63\":1,\"64\":1,\"65\":1,\"71\":1,\"133\":1}}],[\"时间复杂度为\",{\"1\":{\"32\":1,\"60\":3,\"69\":1,\"70\":2,\"77\":1,\"78\":1,\"81\":1,\"83\":1,\"91\":1,\"95\":1}}],[\"时需要加\",{\"1\":{\"30\":1}}],[\"时不需要加\",{\"1\":{\"29\":1}}],[\"时\",{\"1\":{\"29\":1,\"30\":1,\"46\":1,\"83\":2,\"90\":1,\"93\":2}}],[\"时用来初始化\",{\"1\":{\"14\":1}}],[\"划分成\",{\"1\":{\"29\":1,\"30\":1}}],[\"当然\",{\"1\":{\"134\":1}}],[\"当且仅当该局面对应节点的sg函数值等于0\",{\"1\":{\"109\":1}}],[\"当且仅当该局面对应节点的sg函数值大于0\",{\"1\":{\"109\":1}}],[\"当且仅当\",{\"1\":{\"104\":1}}],[\"当我们需要求出组合数的真实值\",{\"1\":{\"100\":1}}],[\"当我们将区间\",{\"1\":{\"29\":1,\"30\":1}}],[\"当模数\",{\"1\":{\"98\":1}}],[\"当有\",{\"1\":{\"83\":1}}],[\"当中有\",{\"1\":{\"81\":1}}],[\"当\",{\"1\":{\"28\":1,\"46\":1,\"81\":1,\"83\":1,\"93\":2,\"98\":2}}],[\"当前节点选\",{\"1\":{\"21\":1}}],[\"当前节点不选\",{\"1\":{\"21\":1}}],[\"当前位置部分\",{\"1\":{\"16\":1}}],[\"合并a和b所在的两个集合\",{\"1\":{\"126\":1,\"127\":1}}],[\"合并x和y所在的两个集合\",{\"1\":{\"125\":1}}],[\"合并两步后\",{\"1\":{\"47\":1}}],[\"合并区间\",{\"1\":{\"26\":1}}],[\"合二为一\",{\"1\":{\"26\":1}}],[\"确定中间分界点\",{\"1\":{\"26\":1}}],[\"确定分界点\",{\"1\":{\"25\":1,\"26\":1}}],[\"而非对某个数的余数时\",{\"1\":{\"100\":1}}],[\"而整数\",{\"1\":{\"98\":1}}],[\"而此时另一个数即为所求答案\",{\"1\":{\"87\":1}}],[\"而并非是\",{\"1\":{\"63\":1}}],[\"而另一部分还有剩余\",{\"1\":{\"26\":1}}],[\"而所有的公共上升子序列中最长的就是最长公共上升子序列了\",{\"1\":{\"11\":1}}],[\"中查找小于等于\",{\"1\":{\"134\":1}}],[\"中查找大于等于\",{\"1\":{\"134\":1}}],[\"中能整除\",{\"1\":{\"102\":1}}],[\"中能被\",{\"1\":{\"102\":1}}],[\"中至少一个数整除的整数有多少个\",{\"1\":{\"102\":1}}],[\"中p的次数是\",{\"1\":{\"100\":1}}],[\"中国剩余定理\",{\"0\":{\"94\":1}}],[\"中计算过了\",{\"1\":{\"90\":1}}],[\"中与\",{\"1\":{\"89\":1}}],[\"中最多只包含一个大于\",{\"1\":{\"78\":1}}],[\"中找到\",{\"1\":{\"32\":2}}],[\"中的次数\",{\"1\":{\"100\":1}}],[\"中的所有质数\",{\"1\":{\"81\":1}}],[\"中的每个数加上c\",{\"1\":{\"42\":1}}],[\"中的\",{\"1\":{\"30\":2}}],[\"中的某个字符替换为另一个字符\",{\"1\":{\"13\":1}}],[\"中的某个字符删除\",{\"1\":{\"13\":1}}],[\"中\",{\"1\":{\"26\":1,\"28\":1}}],[\"对自定义的结构体\",{\"1\":{\"134\":1}}],[\"对两个迭代器\",{\"1\":{\"134\":1}}],[\"对两个子序列分别设置个指针\",{\"1\":{\"26\":1}}],[\"对字符串也适用\",{\"1\":{\"133\":1}}],[\"对阶乘分解质因数之后\",{\"1\":{\"100\":1}}],[\"对朴素筛法的优化\",{\"1\":{\"81\":1}}],[\"对无符号数\",{\"1\":{\"45\":1}}],[\"对于\",{\"1\":{\"122\":1}}],[\"对于先手来说是一个必败状态\",{\"1\":{\"104\":1}}],[\"对于先手来说是一个必胜状态\",{\"1\":{\"104\":1}}],[\"对于大多数情况\",{\"1\":{\"87\":1}}],[\"对于所有的点都\",{\"1\":{\"63\":1}}],[\"对于每个i\",{\"1\":{\"122\":2}}],[\"对于每个节点x\",{\"1\":{\"108\":1}}],[\"对于每个点k\",{\"1\":{\"54\":1}}],[\"对于每两个式子\",{\"1\":{\"94\":1}}],[\"对于每次询问\",{\"1\":{\"12\":1}}],[\"对于两个序列\",{\"1\":{\"48\":1}}],[\"对于两个数列\",{\"1\":{\"11\":1}}],[\"对于一个序列\",{\"1\":{\"48\":1}}],[\"归并的一般写法如下\",{\"1\":{\"26\":1}}],[\"归并\",{\"1\":{\"26\":1}}],[\"归并每次都将中点作为分界点\",{\"1\":{\"26\":1}}],[\"归并排序\",{\"0\":{\"26\":1}}],[\"先进先出\",{\"1\":{\"119\":1}}],[\"先进后出\",{\"1\":{\"116\":1}}],[\"先存值\",{\"1\":{\"114\":1}}],[\"先手走不到任何一个必败状态\",{\"1\":{\"104\":1}}],[\"先手\",{\"1\":{\"104\":1}}],[\"先手可以走到某一个必败状态\",{\"1\":{\"104\":1}}],[\"先手进行\",{\"1\":{\"104\":1}}],[\"先整除再乘\",{\"1\":{\"89\":1}}],[\"先累加\",{\"1\":{\"69\":1}}],[\"先把所有距离初始化为正无穷\",{\"1\":{\"69\":1}}],[\"先把第\",{\"1\":{\"47\":1}}],[\"先对数列排序\",{\"1\":{\"32\":1}}],[\"先递归再合并\",{\"1\":{\"26\":1}}],[\"先枚举长度\",{\"1\":{\"14\":1}}],[\"左补\",{\"1\":{\"46\":2}}],[\"左边的二进制位丢弃\",{\"1\":{\"46\":1}}],[\"左半边剩下的\",{\"1\":{\"26\":1}}],[\"左半边的子集\",{\"1\":{\"3\":1}}],[\"左移2位\",{\"1\":{\"46\":1}}],[\"左移\",{\"1\":{\"25\":1,\"45\":1,\"46\":2}}],[\"右儿子相比最小的元素\",{\"1\":{\"128\":1}}],[\"右儿子是2x\",{\"1\":{\"128\":1}}],[\"右边丢弃\",{\"1\":{\"46\":1}}],[\"右边补0\",{\"1\":{\"46\":1}}],[\"右补0\",{\"1\":{\"46\":1}}],[\"右移\",{\"1\":{\"45\":1,\"46\":2,\"47\":1}}],[\"右移和\",{\"1\":{\"25\":1}}],[\"右半边剩下的\",{\"1\":{\"26\":1}}],[\"右端点\",{\"1\":{\"14\":1}}],[\"子串长度\",{\"1\":{\"133\":1}}],[\"子问题合并\",{\"1\":{\"25\":2}}],[\"子节点不能选\",{\"1\":{\"21\":1}}],[\"分别到达节点y1\",{\"1\":{\"108\":1}}],[\"分别适用于不同情况\",{\"1\":{\"28\":1}}],[\"分为两种情况\",{\"1\":{\"90\":1}}],[\"分为两大类\",{\"1\":{\"60\":1}}],[\"分解质因数的方式比较好用\",{\"1\":{\"100\":1}}],[\"分解质因数法求组合数\",{\"0\":{\"100\":1}}],[\"分解质因数\",{\"1\":{\"89\":1}}],[\"分成子问题\",{\"1\":{\"25\":2}}],[\"分治算法都有三步\",{\"1\":{\"25\":1}}],[\"分组背包\",{\"0\":{\"6\":1}}],[\"快速幂模板\",{\"1\":{\"98\":1,\"99\":1}}],[\"快速幂求逆元\",{\"1\":{\"98\":1}}],[\"快速幂\",{\"0\":{\"91\":1}}],[\"快速排序\",{\"0\":{\"25\":1}}],[\"快排这一步不需要操作\",{\"1\":{\"25\":1}}],[\"快排的一般写法如下\",{\"1\":{\"25\":1}}],[\"快排属于分治算法\",{\"1\":{\"25\":1}}],[\"保存节点信息\",{\"1\":{\"21\":1}}],[\"给以\",{\"1\":{\"43\":1}}],[\"给区间\",{\"1\":{\"42\":1}}],[\"给出一串数以及一个数字\",{\"1\":{\"32\":1}}],[\"给父亲更新\",{\"1\":{\"21\":1}}],[\"给定n堆物品\",{\"1\":{\"104\":1}}],[\"给定n个0和n个1\",{\"1\":{\"101\":1}}],[\"给定整数\",{\"1\":{\"82\":1}}],[\"给定一个序列\",{\"1\":{\"118\":1}}],[\"给定一个有向无环图\",{\"1\":{\"106\":1}}],[\"给定一个整数\",{\"1\":{\"102\":1}}],[\"给定一个包含\",{\"1\":{\"95\":1}}],[\"给定一个长度为\",{\"1\":{\"47\":1}}],[\"给定一个如下图所示的数字三角形\",{\"1\":{\"8\":1}}],[\"给定一张\",{\"1\":{\"19\":1}}],[\"给定两个非负整数\",{\"1\":{\"37\":1,\"38\":1}}],[\"给定两个正整数\",{\"1\":{\"35\":1,\"36\":1,\"97\":1}}],[\"给定两个整数\",{\"1\":{\"16\":1}}],[\"给定两个字符串\",{\"1\":{\"13\":1}}],[\"给定两个长度分别为\",{\"1\":{\"10\":1}}],[\"给定\",{\"1\":{\"12\":1,\"94\":1,\"99\":1,\"139\":1,\"141\":1,\"142\":1}}],[\"已访问\",{\"1\":{\"21\":1}}],[\"树的高度\",{\"1\":{\"70\":1,\"125\":1}}],[\"树的根\",{\"1\":{\"21\":1}}],[\"树与图的遍历\",{\"0\":{\"55\":1}}],[\"树与图的存储\",{\"0\":{\"54\":1}}],[\"树形dp\",{\"0\":{\"20\":1}}],[\"入度为0\",{\"1\":{\"21\":1}}],[\"入度\",{\"1\":{\"21\":1}}],[\"为x的后继节点y1\",{\"1\":{\"108\":1}}],[\"为求出不属于集合s的最小非负整数的运算\",{\"1\":{\"107\":1}}],[\"为质数时\",{\"1\":{\"98\":1}}],[\"为避免这种情况\",{\"1\":{\"46\":1}}],[\"为\",{\"1\":{\"46\":2,\"98\":2,\"102\":1}}],[\"为右下角的子矩阵中的所有元素加上c\",{\"1\":{\"43\":1}}],[\"为右下角的子矩阵的和为\",{\"1\":{\"41\":1}}],[\"为左上角\",{\"1\":{\"41\":1,\"43\":1}}],[\"为高兴值\",{\"1\":{\"21\":1}}],[\"为父亲\",{\"1\":{\"21\":1}}],[\"为第\",{\"1\":{\"21\":2}}],[\"ull\",{\"1\":{\"132\":4}}],[\"up\",{\"1\":{\"128\":4}}],[\"upper\",{\"1\":{\"32\":3,\"133\":4,\"134\":3}}],[\"unsigned\",{\"1\":{\"132\":1}}],[\"unordered\",{\"1\":{\"86\":1,\"133\":4}}],[\"union\",{\"1\":{\"70\":2,\"125\":1}}],[\"unique\",{\"1\":{\"49\":1,\"133\":1,\"134\":3}}],[\"u表示当前节点\",{\"1\":{\"71\":1}}],[\"u\",{\"1\":{\"21\":16,\"54\":11,\"56\":4,\"71\":3,\"123\":7,\"127\":2,\"128\":17}}],[\"u=sons\",{\"1\":{\"21\":1}}],[\"using\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"18\":1,\"19\":1,\"21\":1,\"32\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"47\":2,\"61\":1,\"69\":1,\"70\":1,\"86\":1,\"94\":1,\"102\":1,\"104\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"他的下属所能获得的最大快乐值\",{\"1\":{\"21\":2}}],[\"则无解\",{\"1\":{\"142\":1}}],[\"则点数+1\",{\"1\":{\"139\":1}}],[\"则往下沉\",{\"1\":{\"128\":1}}],[\"则最小的数为右儿子\",{\"1\":{\"128\":1}}],[\"则最小的数为左二子\",{\"1\":{\"128\":1}}],[\"则优先采取该行动\",{\"1\":{\"104\":1}}],[\"则系数应该是1\",{\"1\":{\"102\":1}}],[\"则n\",{\"1\":{\"102\":1}}],[\"则对于任意整数\",{\"1\":{\"99\":1}}],[\"则称该游戏为一个公平组合游戏\",{\"1\":{\"105\":1}}],[\"则称该局面必败\",{\"1\":{\"104\":1}}],[\"则称\",{\"1\":{\"98\":1}}],[\"则存在一个整数\",{\"1\":{\"98\":1}}],[\"则有\",{\"1\":{\"98\":1}}],[\"则数据保证\",{\"1\":{\"94\":1}}],[\"则输出结果\",{\"1\":{\"121\":1}}],[\"则输出\",{\"1\":{\"94\":1}}],[\"则可以通过扩展欧几里得来求解\",{\"1\":{\"93\":1}}],[\"则为\",{\"1\":{\"91\":1}}],[\"则pj一定是i的最小公因子\",{\"1\":{\"83\":1}}],[\"则匹配成功\",{\"1\":{\"72\":1}}],[\"则这条交替路称为增广路\",{\"1\":{\"72\":1}}],[\"则这个数出现的次数就可以表示为\",{\"1\":{\"32\":1}}],[\"则加入这条边到集合中\",{\"1\":{\"70\":1}}],[\"则选择该点\",{\"1\":{\"69\":1}}],[\"则说明存在环\",{\"1\":{\"65\":1}}],[\"则不需要将j重复插入\",{\"1\":{\"64\":1}}],[\"则把该点加入到队尾\",{\"1\":{\"64\":1}}],[\"则返回inf\",{\"1\":{\"69\":1}}],[\"则返回true\",{\"1\":{\"65\":1}}],[\"则返回\",{\"1\":{\"62\":1,\"63\":1}}],[\"则\",{\"1\":{\"47\":2,\"89\":1}}],[\"则每左移一位\",{\"1\":{\"46\":1}}],[\"则向高位借位\",{\"1\":{\"36\":1}}],[\"则直接减\",{\"1\":{\"36\":1}}],[\"则减去b\",{\"1\":{\"36\":1}}],[\"则压入c数组中\",{\"1\":{\"35\":1}}],[\"则将这两个连通块合并\",{\"1\":{\"70\":1}}],[\"则将其转化为\",{\"1\":{\"36\":1}}],[\"则将剩余那一部分直接接在临时序列的后面\",{\"1\":{\"26\":1}}],[\"则将该元素入栈\",{\"1\":{\"9\":1}}],[\"则设\",{\"1\":{\"21\":1}}],[\"更新区间\",{\"1\":{\"143\":1}}],[\"更新端点和遍历的区间\",{\"1\":{\"142\":1}}],[\"更新右端点\",{\"1\":{\"139\":1}}],[\"更新t\",{\"1\":{\"69\":1}}],[\"更新其他点到集合的距离\",{\"1\":{\"69\":1}}],[\"更新\",{\"1\":{\"64\":1}}],[\"更新两点之间的最短距离\",{\"1\":{\"63\":1}}],[\"更新第一个点到起点的最短距离\",{\"1\":{\"61\":1}}],[\"更新完一个子节点\",{\"1\":{\"21\":1}}],[\"更新最短距离\",{\"1\":{\"19\":1}}],[\"更新前缀计数器\",{\"1\":{\"16\":1}}],[\"所谓采取最优策略是指\",{\"1\":{\"104\":1}}],[\"所含匹配边数最多的匹配\",{\"1\":{\"72\":1}}],[\"所得即为商在这一位的数字\",{\"1\":{\"38\":1}}],[\"所以可以用str\",{\"1\":{\"123\":1}}],[\"所以idx从2开始\",{\"1\":{\"115\":1}}],[\"所以是乘\",{\"1\":{\"99\":1}}],[\"所以有\",{\"1\":{\"93\":1}}],[\"所以此时应该退出循环\",{\"1\":{\"83\":1}}],[\"所以\",{\"1\":{\"83\":1,\"93\":1}}],[\"所以先预处理好\",{\"1\":{\"82\":1}}],[\"所以这里只用存一个方向的边\",{\"1\":{\"72\":1}}],[\"所以存边的时候\",{\"1\":{\"72\":1}}],[\"所以存在环\",{\"1\":{\"65\":1}}],[\"所以需要将其翻转\",{\"1\":{\"38\":1}}],[\"所以从后遍历\",{\"1\":{\"36\":1}}],[\"所以一直更新根就行了\",{\"1\":{\"21\":1}}],[\"所以f\",{\"1\":{\"19\":1}}],[\"所以初始化为无穷大\",{\"1\":{\"19\":1}}],[\"所有节点均不为空\",{\"1\":{\"128\":1}}],[\"所有数的个数为各个集合的并集\",{\"1\":{\"102\":1}}],[\"所有的顶点都是匹配点\",{\"1\":{\"72\":1}}],[\"所有的区间dp问题枚举时\",{\"1\":{\"14\":1}}],[\"所有边\",{\"1\":{\"63\":1,\"71\":1}}],[\"所有边权都是正数\",{\"1\":{\"60\":1}}],[\"所有将a\",{\"1\":{\"13\":1}}],[\"因为存的都是英文字母\",{\"1\":{\"123\":1}}],[\"因为本质是一样的\",{\"1\":{\"122\":1}}],[\"因为围棋交战双方分别只能落黑子和白子\",{\"1\":{\"105\":1}}],[\"因为从\",{\"1\":{\"99\":1}}],[\"因为我们是从小到大遍历的\",{\"1\":{\"83\":1}}],[\"因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化\",{\"1\":{\"72\":1}}],[\"因为你要去问的都是男孩子\",{\"1\":{\"72\":1}}],[\"因为再给边排序的时候是按照边的权重进行排序的\",{\"1\":{\"70\":1}}],[\"因为\",{\"1\":{\"46\":1,\"82\":1,\"93\":1}}],[\"因为是倒序数组\",{\"1\":{\"36\":1}}],[\"因为剩下的这部分一定是大于前面的\",{\"1\":{\"26\":1}}],[\"因为零是起点\",{\"1\":{\"19\":1}}],[\"因为要求最小值\",{\"1\":{\"19\":1}}],[\"因此可以递推的每次乘\",{\"1\":{\"99\":1}}],[\"因此可以用\",{\"1\":{\"46\":1}}],[\"因此最终结果\",{\"1\":{\"90\":1}}],[\"因此不仅需要将基数\",{\"1\":{\"90\":1}}],[\"因此只有某个点染色失败才能立刻\",{\"1\":{\"71\":1}}],[\"因此需要对\",{\"1\":{\"63\":1}}],[\"因此前导0在数组前面\",{\"1\":{\"38\":1}}],[\"因此\",{\"1\":{\"15\":1,\"83\":1,\"90\":1}}],[\"走交替路\",{\"1\":{\"72\":1}}],[\"走过的所有点的情况是\",{\"1\":{\"19\":1}}],[\"走到\",{\"1\":{\"19\":1}}],[\"到\",{\"1\":{\"19\":1,\"81\":1,\"99\":1,\"102\":1}}],[\"到终点和我说声\",{\"1\":{\"122\":1}}],[\"到终点\",{\"1\":{\"19\":1}}],[\"hp\",{\"1\":{\"128\":6}}],[\"head\",{\"1\":{\"114\":6}}],[\"head存储链表头\",{\"1\":{\"114\":1}}],[\"heap表示堆\",{\"1\":{\"128\":1}}],[\"heap\",{\"1\":{\"62\":6,\"128\":10,\"141\":7}}],[\"hh++\",{\"1\":{\"58\":1,\"120\":1,\"121\":1}}],[\"hh\",{\"1\":{\"58\":2,\"120\":4,\"121\":4}}],[\"h\",{\"1\":{\"54\":10,\"56\":1,\"57\":1,\"58\":1,\"62\":4,\"64\":4,\"65\":2,\"71\":2,\"72\":2,\"128\":11,\"130\":4,\"131\":3,\"132\":6}}],[\"hamilton路径的定义是从\",{\"1\":{\"19\":1}}],[\"h>\",{\"1\":{\"16\":1,\"21\":1,\"69\":1,\"70\":1}}],[\"~x\",{\"1\":{\"47\":1}}],[\"~0\",{\"1\":{\"46\":1}}],[\"~1\",{\"1\":{\"46\":3}}],[\"~\",{\"1\":{\"19\":1,\"45\":1,\"46\":2,\"78\":1,\"81\":1,\"90\":1,\"102\":2,\"132\":1,\"133\":1,\"134\":4}}],[\"|\",{\"1\":{\"18\":1,\"45\":1,\"46\":6,\"98\":1,\"133\":1}}],[\"||\",{\"1\":{\"18\":1,\"35\":1,\"37\":1,\"61\":1,\"69\":1,\"72\":1,\"134\":1,\"141\":1}}],[\"其余所有的数字依次跟着变化\",{\"1\":{\"95\":1}}],[\"其余位为\",{\"1\":{\"46\":3}}],[\"其表达式为\",{\"1\":{\"47\":1}}],[\"其更新操作是\",{\"1\":{\"29\":1,\"30\":1}}],[\"其位数和棋盘的行数一致\",{\"1\":{\"18\":1}}],[\"其中元素x\",{\"1\":{\"128\":1}}],[\"其中任意两条边都不依附于同一个顶点\",{\"1\":{\"72\":1}}],[\"其中的第\",{\"1\":{\"47\":1}}],[\"其中一个作为分界点\",{\"1\":{\"25\":1}}],[\"其中\",{\"1\":{\"18\":1,\"47\":1,\"99\":1}}],[\"其中i为数字个数\",{\"1\":{\"16\":2}}],[\"小的合并到大的中\",{\"1\":{\"143\":1}}],[\"小的数\",{\"1\":{\"118\":1}}],[\"小于号\",{\"1\":{\"134\":2}}],[\"小于eps视为0\",{\"1\":{\"95\":1}}],[\"小技巧\",{\"1\":{\"132\":1}}],[\"小方格的种类数\",{\"1\":{\"18\":1}}],[\"小沐沐要你来告诉奶牛什么是最长公共上升子序列\",{\"1\":{\"11\":1}}],[\"小沐沐说\",{\"1\":{\"11\":1}}],[\"小沐沐先让奶牛研究了最长上升子序列\",{\"1\":{\"11\":1}}],[\"状态表示\",{\"1\":{\"18\":1}}],[\"状态压缩类dp\",{\"0\":{\"17\":1}}],[\"状态转移方程\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"13\":2,\"19\":1,\"21\":1}}],[\"t表示该元素与它的左\",{\"1\":{\"128\":1}}],[\"trie树存储形式\",{\"1\":{\"123\":1}}],[\"trie树又称字典树\",{\"1\":{\"123\":1}}],[\"trie树\",{\"0\":{\"123\":1}}],[\"true\",{\"1\":{\"16\":1,\"18\":1,\"36\":1,\"56\":1,\"57\":2,\"61\":1,\"62\":1,\"64\":2,\"65\":3,\"69\":1,\"71\":2,\"72\":2,\"77\":1,\"81\":1,\"82\":4,\"83\":2,\"90\":1,\"91\":2,\"100\":1,\"130\":1,\"142\":1}}],[\"t为当前这种状态的集合数量\",{\"1\":{\"102\":1}}],[\"t为余数\",{\"1\":{\"38\":1}}],[\"tips\",{\"1\":{\"72\":1}}],[\"ture\",{\"1\":{\"69\":1}}],[\"tt表示队尾\",{\"1\":{\"120\":1}}],[\"tt表示栈顶\",{\"1\":{\"117\":1}}],[\"tt\",{\"1\":{\"58\":3,\"117\":4,\"118\":4,\"120\":3,\"121\":5}}],[\"top\",{\"1\":{\"62\":1,\"133\":2,\"141\":1}}],[\"topsort\",{\"1\":{\"58\":1}}],[\"tot\",{\"1\":{\"32\":3}}],[\"t再除以10\",{\"1\":{\"35\":1}}],[\"temp\",{\"1\":{\"26\":6}}],[\"typedef\",{\"1\":{\"18\":1,\"86\":1,\"132\":1}}],[\"t\",{\"1\":{\"16\":4,\"35\":7,\"36\":11,\"37\":5,\"38\":9,\"57\":2,\"58\":2,\"61\":7,\"62\":3,\"64\":9,\"65\":6,\"69\":16,\"86\":4,\"90\":4,\"91\":2,\"95\":5,\"100\":7,\"102\":8,\"128\":8,\"141\":4}}],[\"p的经验值是131或13331\",{\"1\":{\"132\":1}}],[\"ph\",{\"1\":{\"128\":4}}],[\"phi\",{\"1\":{\"89\":1,\"90\":5}}],[\"p+1\",{\"1\":{\"122\":1}}],[\"p为匹配串\",{\"1\":{\"122\":1}}],[\"p^k\",{\"1\":{\"132\":1}}],[\"p^3\",{\"1\":{\"100\":1}}],[\"p^2\",{\"1\":{\"100\":1}}],[\"p$\",{\"1\":{\"99\":1}}],[\"pk^1\",{\"1\":{\"86\":1}}],[\"pk^0\",{\"1\":{\"86\":1}}],[\"pk^ck\",{\"1\":{\"86\":2}}],[\"p1^1\",{\"1\":{\"86\":1}}],[\"p1^0\",{\"1\":{\"86\":1}}],[\"p1^c1\",{\"1\":{\"86\":2}}],[\"p2^c2\",{\"1\":{\"86\":1}}],[\"pj=0\",{\"1\":{\"83\":1}}],[\"pj一定是pj\",{\"1\":{\"83\":1}}],[\"pb\",{\"1\":{\"70\":2}}],[\"pa\",{\"1\":{\"70\":2}}],[\"pair<int\",{\"1\":{\"62\":1,\"133\":1,\"143\":1}}],[\"py\",{\"1\":{\"70\":6,\"125\":6}}],[\"px\",{\"1\":{\"70\":7,\"125\":6}}],[\"p\",{\"1\":{\"70\":8,\"86\":3,\"89\":9,\"91\":5,\"98\":5,\"99\":36,\"100\":8,\"102\":8,\"122\":7,\"123\":11,\"125\":8,\"126\":8,\"127\":9,\"132\":8}}],[\"primes2\",{\"1\":{\"82\":4}}],[\"primes\",{\"1\":{\"81\":4,\"82\":3,\"83\":17,\"86\":4,\"90\":21,\"100\":9}}],[\"prime\",{\"1\":{\"77\":1,\"79\":2,\"82\":2,\"83\":1}}],[\"prim\",{\"1\":{\"69\":2}}],[\"priority\",{\"1\":{\"62\":1,\"133\":2,\"141\":1}}],[\"printf\",{\"1\":{\"16\":1,\"21\":1,\"35\":1,\"36\":3,\"37\":1,\"54\":1,\"69\":1,\"94\":1,\"122\":1}}],[\"print\",{\"1\":{\"16\":2}}],[\"pii\",{\"1\":{\"62\":1,\"143\":1}}],[\"pop\",{\"1\":{\"36\":1,\"37\":1,\"38\":1,\"57\":1,\"62\":1,\"64\":2,\"65\":1,\"133\":6,\"141\":1}}],[\"puts\",{\"1\":{\"16\":1,\"69\":1,\"94\":1,\"104\":2}}],[\"push\",{\"1\":{\"5\":2,\"9\":2,\"16\":2,\"18\":1,\"35\":4,\"36\":3,\"37\":2,\"38\":2,\"50\":2,\"54\":2,\"57\":2,\"62\":2,\"64\":2,\"65\":2,\"79\":2,\"85\":2,\"100\":3,\"133\":6,\"141\":2,\"143\":3}}],[\"yk\",{\"1\":{\"108\":3}}],[\"yes\",{\"1\":{\"104\":1}}],[\"y是分母\",{\"1\":{\"99\":1}}],[\"y2\",{\"1\":{\"41\":3,\"43\":3,\"108\":3}}],[\"y1\",{\"1\":{\"41\":3,\"43\":3,\"108\":1}}],[\"y\",{\"1\":{\"16\":2,\"46\":17,\"70\":2,\"87\":1,\"93\":13,\"94\":4,\"99\":4,\"118\":1,\"125\":2,\"134\":4}}],[\"这样直接用unsigned\",{\"1\":{\"132\":1}}],[\"这样的局面被称为必胜\",{\"1\":{\"104\":1}}],[\"这样当两个边进行比较的时候就会使用他们的权重进行比较了\",{\"1\":{\"70\":1}}],[\"这\",{\"1\":{\"91\":2}}],[\"这一项\",{\"1\":{\"90\":1}}],[\"这一项在\",{\"1\":{\"90\":1}}],[\"这一步类似完全背包的推导\",{\"1\":{\"15\":1}}],[\"这条边不要\",{\"1\":{\"70\":1}}],[\"这个公式求出每个质因子的次数\",{\"1\":{\"100\":1}}],[\"这个步骤\",{\"1\":{\"87\":1}}],[\"这个点还未被匹配\",{\"1\":{\"72\":1}}],[\"这个集合指当前已经在连通块中的所有点\",{\"1\":{\"69\":1}}],[\"这个数本身\",{\"1\":{\"16\":1}}],[\"这种写法包含了两种情况\",{\"1\":{\"36\":1}}],[\"这里使用库函数二分的写法\",{\"1\":{\"32\":1}}],[\"x的左儿子是2x\",{\"1\":{\"128\":1}}],[\"x属于自然数\",{\"1\":{\"107\":1}}],[\"x是分子\",{\"1\":{\"99\":1}}],[\"x2\",{\"1\":{\"41\":3,\"43\":3}}],[\"x1\",{\"1\":{\"41\":3,\"43\":3}}],[\"x\",{\"1\":{\"16\":13,\"25\":3,\"29\":1,\"30\":4,\"33\":1,\"46\":14,\"47\":18,\"49\":2,\"63\":1,\"65\":2,\"70\":8,\"72\":3,\"77\":5,\"78\":7,\"81\":1,\"83\":1,\"85\":5,\"86\":7,\"87\":1,\"89\":9,\"90\":1,\"91\":5,\"93\":9,\"94\":9,\"98\":5,\"99\":4,\"104\":3,\"107\":1,\"108\":2,\"114\":3,\"115\":2,\"117\":1,\"118\":1,\"120\":1,\"125\":8,\"126\":6,\"127\":10,\"128\":4,\"130\":6,\"131\":3,\"133\":2,\"134\":12}}],[\"循环出口\",{\"1\":{\"142\":1}}],[\"循环\",{\"1\":{\"63\":2}}],[\"循环变量i可以表示剩下的数字有多少个\",{\"1\":{\"16\":1}}],[\"循环从1开始\",{\"1\":{\"16\":1}}],[\"统计叶子节点\",{\"1\":{\"16\":1}}],[\"统计大于10\",{\"1\":{\"16\":1}}],[\"统计1\",{\"1\":{\"16\":1}}],[\"里面各个数字有多少个\",{\"1\":{\"16\":1}}],[\"99\",{\"1\":{\"16\":3}}],[\"9\",{\"0\":{\"50\":1,\"102\":1,\"133\":1},\"1\":{\"16\":18}}],[\"greater<int>\",{\"1\":{\"134\":1}}],[\"greater<int>>\",{\"1\":{\"133\":1,\"141\":1}}],[\"greater<pii>>\",{\"1\":{\"62\":1}}],[\"g1\",{\"1\":{\"109\":1}}],[\"g被称为有向图游戏g1\",{\"1\":{\"109\":1}}],[\"gm的和\",{\"1\":{\"109\":1}}],[\"gm\",{\"1\":{\"109\":2}}],[\"g2\",{\"1\":{\"109\":3}}],[\"gauss\",{\"1\":{\"95\":1}}],[\"gcd\",{\"1\":{\"87\":3,\"93\":5}}],[\"get\",{\"1\":{\"81\":1,\"82\":1,\"83\":1,\"85\":1,\"90\":1,\"100\":6,\"132\":1}}],[\"g\",{\"1\":{\"16\":7,\"54\":1,\"61\":9,\"69\":7,\"108\":1,\"109\":1}}],[\"goods\",{\"1\":{\"5\":4}}],[\"good\",{\"1\":{\"5\":5}}],[\"前置知识\",{\"1\":{\"95\":1}}],[\"前缀和与差分\",{\"0\":{\"39\":1}}],[\"前缀部分\",{\"1\":{\"16\":1}}],[\"前提\",{\"1\":{\"36\":1}}],[\"前\",{\"1\":{\"15\":2}}],[\"朴素并查集\",{\"0\":{\"125\":1}}],[\"朴素筛法\",{\"0\":{\"81\":1}}],[\"朴素prim算法\",{\"0\":{\"69\":1}}],[\"朴素版\",{\"0\":{\"61\":1}}],[\"朴素版的dijkstra算法\",{\"1\":{\"60\":1}}],[\"朴素做法\",{\"1\":{\"15\":1}}],[\"朴素dp写法\",{\"1\":{\"9\":1}}],[\"恰好拼成j的方案数\",{\"1\":{\"15\":1}}],[\"自动得到右端点\",{\"1\":{\"14\":1}}],[\"自动获得\",{\"1\":{\"14\":1}}],[\"构造状态转移方程\",{\"1\":{\"14\":1}}],[\"枚举当前状态的每一位\",{\"1\":{\"102\":1}}],[\"枚举每一列c\",{\"1\":{\"95\":1}}],[\"枚举\",{\"1\":{\"81\":1}}],[\"枚举分割点\",{\"1\":{\"14\":1}}],[\"枚举起点\",{\"1\":{\"14\":1}}],[\"枚举从1\",{\"1\":{\"102\":1}}],[\"枚举从\",{\"1\":{\"14\":1}}],[\"deque\",{\"1\":{\"133\":1}}],[\"define\",{\"1\":{\"32\":1,\"62\":1,\"69\":1,\"82\":1,\"94\":1,\"102\":1,\"143\":1}}],[\"dijkstra\",{\"1\":{\"61\":2,\"62\":1}}],[\"dijkstra算法\",{\"0\":{\"61\":1}}],[\"dist\",{\"1\":{\"54\":7,\"61\":11,\"62\":9,\"63\":19,\"64\":10,\"65\":6,\"69\":10}}],[\"distance\",{\"1\":{\"12\":2,\"54\":3,\"62\":3,\"127\":1}}],[\"divisors\",{\"1\":{\"85\":1}}],[\"divisor\",{\"1\":{\"79\":1}}],[\"divide\",{\"1\":{\"78\":1}}],[\"div\",{\"1\":{\"38\":2}}],[\"down和up只会执行其中一个\",{\"1\":{\"128\":1}}],[\"down\",{\"1\":{\"128\":6}}],[\"double\",{\"1\":{\"33\":6}}],[\"do\",{\"1\":{\"25\":2}}],[\"dfs思路\",{\"1\":{\"71\":1}}],[\"dfs\",{\"1\":{\"21\":3,\"54\":4,\"56\":2,\"71\":4}}],[\"d\",{\"1\":{\"16\":1,\"21\":4,\"35\":1,\"36\":2,\"37\":1,\"54\":4,\"58\":3,\"67\":7,\"69\":1,\"93\":5,\"94\":7,\"122\":1,\"127\":6,\"133\":1}}],[\"dp\",{\"1\":{\"14\":6,\"16\":3,\"21\":10}}],[\"变长数组\",{\"1\":{\"133\":1}}],[\"变换\",{\"1\":{\"95\":1}}],[\"变\",{\"1\":{\"46\":2}}],[\"变成b\",{\"1\":{\"13\":1}}],[\"变为\",{\"1\":{\"13\":1}}],[\"替换\",{\"1\":{\"13\":1}}],[\"替换掉第一个大于或等于这个数字的那个数\",{\"1\":{\"9\":1}}],[\"在有序\",{\"1\":{\"134\":2}}],[\"在有向图游戏中\",{\"1\":{\"108\":1}}],[\"在两个迭代器\",{\"1\":{\"134\":1}}],[\"在哈希表中查询某个数是否存在\",{\"1\":{\"130\":1}}],[\"在满足\",{\"1\":{\"122\":1}}],[\"在节点k的右边插入一个数x\",{\"1\":{\"115\":1}}],[\"在算法竞赛中一般不需要考虑删除的那个节点该如何处理\",{\"1\":{\"114\":1}}],[\"在链表头插入一个数a\",{\"1\":{\"114\":1}}],[\"在起点上放有一枚棋子\",{\"1\":{\"106\":1}}],[\"在游戏进程的任意时刻\",{\"1\":{\"105\":1}}],[\"在图论中\",{\"1\":{\"68\":1,\"72\":1}}],[\"在图中选择若干条边把图中的所有节点连接起来\",{\"1\":{\"68\":1}}],[\"在保存最短路径的数组中\",{\"1\":{\"64\":1}}],[\"在还未确定最短路的点中\",{\"1\":{\"61\":1}}],[\"在所有子节点更新后再更新\",{\"1\":{\"21\":1}}],[\"在字符串\",{\"1\":{\"13\":1}}],[\"在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点\",{\"1\":{\"8\":1}}],[\"插入的数是一个pair\",{\"1\":{\"133\":1}}],[\"插入一个元素\",{\"1\":{\"133\":1}}],[\"插入一个数\",{\"1\":{\"128\":1,\"133\":1}}],[\"插入一个字符串\",{\"1\":{\"123\":1}}],[\"插入\",{\"1\":{\"13\":1}}],[\"将新的区间放入ans数组中\",{\"1\":{\"143\":1}}],[\"将指定线段区间完全覆盖\",{\"1\":{\"142\":1}}],[\"将第k位变成v\",{\"1\":{\"133\":1}}],[\"将当前元素加入到队尾\",{\"1\":{\"121\":1}}],[\"将当前元素加入队尾\",{\"1\":{\"121\":1}}],[\"将当前行的首位变成1\",{\"1\":{\"95\":1}}],[\"将下标是k的点后面的点删掉\",{\"1\":{\"114\":1}}],[\"将下面所有行的当且列的值变成\",{\"1\":{\"95\":1}}],[\"将头结点删除\",{\"1\":{\"114\":1}}],[\"将绝对值最大的行换到最顶端\",{\"1\":{\"95\":1}}],[\"将该行的第一个数变成\",{\"1\":{\"95\":1}}],[\"将这\",{\"1\":{\"94\":1}}],[\"将这一位相减后的结果压入c中\",{\"1\":{\"36\":1}}],[\"将其等价转换\",{\"1\":{\"94\":1}}],[\"将连通块逐渐扩大\",{\"1\":{\"69\":1}}],[\"将所有点分成\",{\"1\":{\"71\":1}}],[\"将所有存在交集的区间合并\",{\"1\":{\"50\":1}}],[\"将所有值排序\",{\"1\":{\"49\":1}}],[\"将一个容器中重复的元素删除\",{\"1\":{\"133\":1}}],[\"将一个新的节点x插入下标是k的后面\",{\"1\":{\"114\":1}}],[\"将一个数的各二进制位全部右移若干位\",{\"1\":{\"46\":1}}],[\"将一个运算对象的各二进制位全部左移若干位\",{\"1\":{\"46\":1}}],[\"将前导0置于尾部\",{\"1\":{\"38\":1}}],[\"将上次的余数×10再加上当前位的数字\",{\"1\":{\"38\":1}}],[\"将问题转变成统计数列中\",{\"1\":{\"32\":1}}],[\"将模板\",{\"1\":{\"30\":1}}],[\"将临时序列放入原序列中\",{\"1\":{\"26\":1}}],[\"将小的放入一个临时序列\",{\"1\":{\"26\":1}}],[\"将整个序列均分为两部分\",{\"1\":{\"26\":1}}],[\"将\",{\"1\":{\"13\":1,\"46\":2,\"91\":1}}],[\"将字符串看成p进制数\",{\"1\":{\"132\":1}}],[\"将字符串\",{\"1\":{\"13\":2}}],[\"将你的个人介绍和档案放置在此处\",{\"1\":{\"0\":1}}],[\"删除这个迭代器\",{\"1\":{\"133\":1}}],[\"删除所有x\",{\"1\":{\"133\":1}}],[\"删除任意一个元素\",{\"1\":{\"128\":1}}],[\"删除最小值\",{\"1\":{\"128\":1}}],[\"删除第k个点\",{\"1\":{\"115\":1}}],[\"删除前导0\",{\"1\":{\"36\":1,\"37\":1,\"38\":1}}],[\"删除\",{\"1\":{\"13\":1}}],[\"删除或替换算作一次操作\",{\"1\":{\"12\":1}}],[\"可计算出去重后的元素个数\",{\"1\":{\"134\":1}}],[\"可把一堆取光\",{\"1\":{\"104\":1}}],[\"可能为负数\",{\"1\":{\"94\":1}}],[\"可能包含长度为偶数的环\",{\"1\":{\"71\":1}}],[\"可能的\",{\"1\":{\"31\":1}}],[\"可理解为\",{\"1\":{\"69\":1,\"70\":1}}],[\"可以在第三个参数传入定义大小比较的函数\",{\"1\":{\"134\":1}}],[\"可以在区间\",{\"1\":{\"32\":2}}],[\"可以删掉\",{\"1\":{\"118\":1}}],[\"可以执行的合法行动与轮到哪名玩家无关\",{\"1\":{\"105\":1}}],[\"可以用费马小定理求逆元\",{\"1\":{\"98\":1}}],[\"可以用结构体存储点和边\",{\"1\":{\"63\":1}}],[\"可以缩小问题规模而保持最大公约数不变\",{\"1\":{\"87\":1}}],[\"可以对其进行优化\",{\"1\":{\"78\":1}}],[\"可以生成最小生成树\",{\"1\":{\"70\":1}}],[\"可以不需要考虑重边\",{\"1\":{\"62\":1}}],[\"可以表示为\",{\"1\":{\"46\":1}}],[\"可以表示成若干个正整数之和\",{\"1\":{\"15\":1}}],[\"可以将模板\",{\"1\":{\"30\":1}}],[\"可以任选\",{\"1\":{\"25\":1}}],[\"可进行的操作有\",{\"1\":{\"13\":1}}],[\"可使物品总体积不超过背包容量\",{\"1\":{\"6\":1}}],[\"经过若干操作变为\",{\"1\":{\"13\":1}}],[\"现在给定一个正整数\",{\"1\":{\"15\":1}}],[\"现在请你求出\",{\"1\":{\"13\":1}}],[\"现在要将\",{\"1\":{\"13\":1}}],[\"现在又让他们研究最长公共上升子序列了\",{\"1\":{\"11\":1}}],[\"模板代码如下\",{\"1\":{\"14\":1}}],[\"模板代码\",{\"1\":{\"12\":1}}],[\"模拟堆栈\",{\"1\":{\"9\":1}}],[\"再次继续匹配\",{\"1\":{\"122\":1}}],[\"再进行更新生成树\",{\"1\":{\"69\":1}}],[\"再更新\",{\"1\":{\"69\":1}}],[\"再把\",{\"1\":{\"69\":1}}],[\"再建立一个数组\",{\"1\":{\"64\":1}}],[\"再建立一个数组记录起始点到所有点的最短路径\",{\"1\":{\"64\":1}}],[\"再看个位是几\",{\"1\":{\"47\":1}}],[\"再按\",{\"1\":{\"46\":1}}],[\"再枚举左端点\",{\"1\":{\"14\":1}}],[\"再接下来\",{\"1\":{\"12\":1}}],[\"再让他们研究了最长公共子序列\",{\"1\":{\"11\":1}}],[\"行row\",{\"1\":{\"95\":1}}],[\"行包含两个整数\",{\"1\":{\"94\":1}}],[\"行包含整数\",{\"1\":{\"94\":1}}],[\"行\",{\"1\":{\"12\":3,\"94\":1}}],[\"接下来\",{\"1\":{\"12\":1}}],[\"个闭区间\",{\"1\":{\"142\":1}}],[\"个不同的质数\",{\"1\":{\"102\":1}}],[\"个未知数的多元线性方程组\",{\"1\":{\"95\":1}}],[\"个未知数的线性方程组\",{\"1\":{\"95\":1}}],[\"个方程\",{\"1\":{\"95\":2}}],[\"个式子合并\",{\"1\":{\"94\":1}}],[\"个质数\",{\"1\":{\"81\":1}}],[\"个顶点的连通块筛选出来\",{\"1\":{\"70\":1}}],[\"个顶点\",{\"1\":{\"68\":1}}],[\"个点\",{\"1\":{\"60\":1}}],[\"个点的带权无向图\",{\"1\":{\"19\":1}}],[\"个数来组合\",{\"1\":{\"91\":1}}],[\"个数\",{\"1\":{\"91\":1}}],[\"个数的二进制表示中\",{\"1\":{\"47\":1}}],[\"个数表示数列中的第\",{\"1\":{\"47\":1}}],[\"个位\",{\"1\":{\"35\":1,\"36\":1}}],[\"个人来\",{\"1\":{\"21\":1}}],[\"个人不来\",{\"1\":{\"21\":1}}],[\"个物品全不选也是一种方案\",{\"1\":{\"15\":2}}],[\"个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串\",{\"1\":{\"12\":1}}],[\"个长度不超过\",{\"1\":{\"12\":1}}],[\"个整数\",{\"1\":{\"11\":2,\"47\":2,\"94\":1}}],[\"编辑距离\",{\"0\":{\"12\":1}}],[\"−1$\",{\"1\":{\"11\":1}}],[\"序列中的数字均不超过\",{\"1\":{\"11\":1}}],[\"输入的参数是pair或者迭代器\",{\"1\":{\"133\":1}}],[\"输入一个迭代器\",{\"1\":{\"133\":1}}],[\"输入是一个数x\",{\"1\":{\"133\":1}}],[\"输入\",{\"1\":{\"100\":1}}],[\"输入样例\",{\"1\":{\"11\":1}}],[\"输入格式\",{\"1\":{\"11\":1,\"12\":1,\"47\":1,\"94\":1}}],[\"输出选择的点的最小数量\",{\"1\":{\"139\":1}}],[\"输出以0开始的匹配子串的首字母下标\",{\"1\":{\"122\":1}}],[\"输出最小非负整数\",{\"1\":{\"94\":1}}],[\"输出i的s次幂\",{\"1\":{\"78\":1}}],[\"输出即可\",{\"1\":{\"78\":1}}],[\"输出如下\",{\"1\":{\"47\":1}}],[\"输出共\",{\"1\":{\"12\":1}}],[\"输出样例\",{\"1\":{\"11\":1}}],[\"输出一个整数\",{\"1\":{\"11\":1}}],[\"输出格式\",{\"1\":{\"11\":1,\"12\":1,\"47\":1,\"94\":1}}],[\"表示祖宗节点所在集合中的点的数量\",{\"1\":{\"126\":1}}],[\"表示队头\",{\"1\":{\"120\":1}}],[\"表示节点的右指针\",{\"1\":{\"115\":1}}],[\"表示节点的左指针\",{\"1\":{\"115\":1}}],[\"表示节点的值\",{\"1\":{\"115\":1}}],[\"表示第二个集合中的每个点是否已经被遍历过\",{\"1\":{\"72\":1}}],[\"表示每个点的颜色\",{\"1\":{\"71\":1}}],[\"表示a到b的距离\",{\"1\":{\"67\":1}}],[\"表示1号点已经被遍历过\",{\"1\":{\"57\":1}}],[\"表示点j已经被遍历过\",{\"1\":{\"57\":1}}],[\"表示点u已经被遍历过\",{\"1\":{\"56\":1}}],[\"表示点数\",{\"1\":{\"55\":1,\"58\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1}}],[\"表示边数\",{\"1\":{\"55\":1,\"58\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1}}],[\"表示补码\",{\"1\":{\"47\":1}}],[\"表示整个数列\",{\"1\":{\"47\":1}}],[\"表示\",{\"1\":{\"37\":1,\"38\":1,\"71\":1,\"98\":1}}],[\"表示精度\",{\"1\":{\"33\":1}}],[\"表示所有点都走过了\",{\"1\":{\"19\":1}}],[\"表示从a个苹果中选b个的方案数\",{\"1\":{\"97\":1}}],[\"表示从\",{\"1\":{\"19\":1}}],[\"表示当前摆到第\",{\"1\":{\"18\":1}}],[\"表示前i个整数\",{\"1\":{\"15\":1}}],[\"表示一次询问中满足条件的字符串个数\",{\"1\":{\"12\":1}}],[\"表示一次询问\",{\"1\":{\"12\":1}}],[\"表示给定的字符串\",{\"1\":{\"12\":1}}],[\"表示最长公共上升子序列的长度\",{\"1\":{\"11\":1}}],[\"表示数列\",{\"1\":{\"11\":3}}],[\"表示总体积是i的情况下\",{\"1\":{\"3\":1,\"4\":1}}],[\"只去掉\",{\"1\":{\"134\":1}}],[\"只是\",{\"1\":{\"90\":1}}],[\"只需将基数\",{\"1\":{\"90\":1}}],[\"只需要跟一个父亲比较大小就行\",{\"1\":{\"128\":1}}],[\"只需要判断\",{\"1\":{\"81\":1}}],[\"只需要另找一个数\",{\"1\":{\"46\":3}}],[\"只可能是此时\",{\"1\":{\"83\":1}}],[\"只判断能否被小于\",{\"1\":{\"77\":1}}],[\"只出现在集合之间\",{\"1\":{\"71\":1}}],[\"只有祖宗节点的有意义\",{\"1\":{\"126\":1}}],[\"只有先手必胜和先手必败两种情况\",{\"1\":{\"104\":1}}],[\"只有当\",{\"1\":{\"70\":1}}],[\"只有a\",{\"1\":{\"9\":1}}],[\"只考虑正数的情况\",{\"1\":{\"36\":1}}],[\"只要它不是\",{\"1\":{\"81\":1}}],[\"只要根据最未位是\",{\"1\":{\"46\":1}}],[\"只要\",{\"1\":{\"46\":1}}],[\"只要找到这个连续段的左端点和右端点即可\",{\"1\":{\"32\":1}}],[\"只要告诉奶牛它的长度就可以了\",{\"1\":{\"11\":1}}],[\"不支持\",{\"1\":{\"133\":1}}],[\"不满足条件\",{\"1\":{\"105\":1}}],[\"不能行动的玩家判负\",{\"1\":{\"105\":1}}],[\"不存在\",{\"1\":{\"94\":1}}],[\"不一定是\",{\"1\":{\"71\":1}}],[\"不是\",{\"1\":{\"83\":1,\"90\":1,\"98\":1}}],[\"不是起点\",{\"1\":{\"69\":1}}],[\"不是一定\",{\"1\":{\"63\":1}}],[\"不包括自己\",{\"1\":{\"65\":1}}],[\"不包含前导零\",{\"1\":{\"16\":1}}],[\"不需要初始化dist数组\",{\"1\":{\"65\":1}}],[\"不需要借位\",{\"1\":{\"36\":1}}],[\"不为空\",{\"1\":{\"64\":1}}],[\"不同颜色\",{\"1\":{\"71\":1}}],[\"不同为\",{\"1\":{\"46\":1}}],[\"不同为1\",{\"1\":{\"45\":1}}],[\"不同位置的数字一样的数对算不同的数对\",{\"1\":{\"32\":1}}],[\"不用全部遍历\",{\"1\":{\"35\":1,\"36\":1}}],[\"不含前导0\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1}}],[\"不重不漏地经过每个点恰好一次\",{\"1\":{\"19\":1}}],[\"不过\",{\"1\":{\"11\":1}}],[\"不连续\",{\"0\":{\"10\":1}}],[\"奶牛半懂不懂\",{\"1\":{\"11\":1}}],[\"且x不属于s\",{\"1\":{\"107\":1}}],[\"且原来匹配的点能找到另一个点\",{\"1\":{\"72\":1}}],[\"且到树的距离最短\",{\"1\":{\"69\":1}}],[\"且使权值最小的一种结构\",{\"1\":{\"68\":1}}],[\"且\",{\"1\":{\"25\":1,\"93\":1}}],[\"且终点是n\",{\"1\":{\"19\":1}}],[\"且保证右端点不会超范围\",{\"1\":{\"14\":1}}],[\"且长度均不超过\",{\"1\":{\"12\":1}}],[\"且数值是严格递增的\",{\"1\":{\"11\":1}}],[\"且总价值最大\",{\"1\":{\"6\":1}}],[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目\",{\"1\":{\"11\":1}}],[\"和上面类似\",{\"1\":{\"133\":1}}],[\"和条件\",{\"1\":{\"105\":1}}],[\"和\",{\"1\":{\"10\":2,\"11\":2,\"12\":1,\"13\":1,\"16\":2,\"25\":1,\"26\":1,\"29\":1,\"30\":1,\"31\":1,\"37\":1,\"38\":1,\"60\":1,\"71\":1,\"82\":2,\"93\":1,\"94\":2,\"102\":1,\"133\":1}}],[\"否则不存在拓扑序列\",{\"1\":{\"58\":1}}],[\"否则返回最小生成树的树边权重之和\",{\"1\":{\"69\":1}}],[\"否则返回\",{\"1\":{\"36\":1}}],[\"否则返回flase\",{\"1\":{\"36\":1}}],[\"否则返回false\",{\"1\":{\"36\":1,\"65\":1}}],[\"否则\",{\"1\":{\"9\":1}}],[\"三重循环\",{\"1\":{\"67\":1}}],[\"三\",{\"0\":{\"53\":1},\"1\":{\"9\":1}}],[\"empty\",{\"1\":{\"117\":2,\"120\":2,\"133\":7,\"141\":1}}],[\"exgcd\",{\"1\":{\"93\":2,\"94\":3}}],[\"eulers\",{\"1\":{\"90\":1}}],[\"euler\",{\"1\":{\"90\":7}}],[\"e\",{\"1\":{\"54\":2,\"56\":1,\"57\":1,\"58\":1,\"62\":3,\"64\":3,\"65\":2,\"71\":2,\"72\":2,\"114\":4,\"115\":3,\"130\":3}}],[\"edges\",{\"1\":{\"63\":4,\"70\":6}}],[\"edge\",{\"1\":{\"54\":1,\"63\":1,\"70\":2}}],[\"edit\",{\"1\":{\"12\":2}}],[\"erase\",{\"1\":{\"49\":1,\"133\":3}}],[\"eps\",{\"1\":{\"33\":3,\"95\":4}}],[\"end\",{\"1\":{\"9\":1,\"32\":4,\"38\":1,\"49\":3,\"50\":1,\"85\":1,\"133\":5,\"134\":5,\"143\":1}}],[\"endl\",{\"1\":{\"3\":2,\"4\":2,\"5\":4,\"6\":2,\"8\":2,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":2,\"18\":1,\"19\":1,\"32\":1,\"38\":2,\"61\":1,\"78\":3,\"86\":1,\"99\":1,\"102\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"else\",{\"1\":{\"9\":2,\"12\":1,\"13\":2,\"18\":1,\"26\":1,\"29\":1,\"30\":1,\"31\":1,\"33\":1,\"36\":2,\"49\":1,\"50\":1,\"67\":1,\"69\":1,\"70\":1,\"71\":1,\"97\":1,\"102\":1,\"104\":1,\"117\":1,\"120\":1,\"125\":1,\"140\":1,\"141\":1,\"143\":1}}],[\"r代表区间右端点\",{\"1\":{\"143\":1}}],[\"r表示上一连续区间的最右端的点\",{\"1\":{\"139\":1}}],[\"range\",{\"1\":{\"141\":8,\"142\":9}}],[\"random\",{\"1\":{\"134\":1}}],[\"rank\",{\"1\":{\"70\":7,\"125\":8}}],[\"r时\",{\"1\":{\"28\":1}}],[\"root\",{\"1\":{\"21\":5}}],[\"remove\",{\"1\":{\"114\":2,\"115\":1}}],[\"reverse\",{\"1\":{\"38\":1,\"134\":4}}],[\"reset\",{\"1\":{\"133\":1}}],[\"res++\",{\"1\":{\"12\":1,\"47\":1,\"72\":1,\"140\":1,\"142\":1}}],[\"res\",{\"1\":{\"11\":4,\"12\":2,\"47\":2,\"48\":2,\"50\":4,\"69\":3,\"70\":3,\"72\":1,\"79\":7,\"85\":6,\"86\":4,\"89\":6,\"91\":4,\"98\":4,\"99\":4,\"100\":7,\"102\":4,\"104\":3,\"140\":2,\"142\":4}}],[\"return\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":2,\"13\":1,\"14\":1,\"16\":6,\"18\":1,\"19\":1,\"21\":2,\"25\":1,\"26\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"35\":2,\"36\":5,\"37\":2,\"38\":2,\"47\":3,\"49\":1,\"54\":1,\"58\":1,\"61\":3,\"62\":2,\"63\":2,\"64\":2,\"65\":2,\"69\":2,\"70\":5,\"71\":5,\"72\":2,\"77\":3,\"79\":4,\"85\":1,\"86\":1,\"87\":2,\"89\":1,\"91\":1,\"93\":2,\"94\":5,\"95\":3,\"98\":1,\"99\":6,\"100\":2,\"102\":1,\"104\":1,\"122\":1,\"123\":2,\"125\":1,\"126\":1,\"127\":1,\"130\":2,\"131\":1,\"132\":1,\"134\":2,\"139\":2,\"140\":2,\"141\":2,\"142\":2,\"143\":1}}],[\"r\",{\"1\":{\"9\":6,\"25\":8,\"26\":8,\"28\":1,\"29\":7,\"30\":7,\"31\":6,\"33\":4,\"38\":1,\"40\":2,\"42\":2,\"49\":5,\"50\":7,\"95\":12,\"115\":10,\"132\":4,\"139\":8,\"140\":10,\"141\":4,\"142\":12,\"143\":10}}],[\"l代表区间左端点\",{\"1\":{\"143\":1}}],[\"lucas\",{\"0\":{\"99\":1},\"1\":{\"99\":3}}],[\"lcm\",{\"1\":{\"87\":1}}],[\"ln\",{\"1\":{\"81\":4}}],[\"lld\",{\"1\":{\"54\":1,\"94\":6}}],[\"ll\",{\"1\":{\"18\":2,\"32\":3,\"69\":1,\"82\":7,\"86\":4,\"94\":15,\"98\":4,\"99\":10,\"102\":2}}],[\"logn\",{\"1\":{\"133\":3}}],[\"logk\",{\"1\":{\"91\":3}}],[\"log\",{\"1\":{\"70\":1,\"78\":1,\"87\":1}}],[\"lowbit\",{\"1\":{\"47\":5}}],[\"lower\",{\"1\":{\"9\":1,\"32\":3,\"133\":4,\"134\":4}}],[\"long存储\",{\"1\":{\"132\":1}}],[\"long\",{\"1\":{\"18\":2,\"32\":2,\"69\":2,\"82\":2,\"86\":2,\"94\":2,\"102\":2,\"132\":3}}],[\"limit\",{\"1\":{\"12\":3}}],[\"lb\",{\"1\":{\"12\":4}}],[\"last\",{\"1\":{\"16\":4}}],[\"la\",{\"1\":{\"12\":4}}],[\"l\",{\"1\":{\"9\":4,\"25\":8,\"26\":7,\"28\":2,\"29\":8,\"30\":8,\"31\":6,\"33\":5,\"40\":2,\"42\":2,\"49\":4,\"50\":5,\"115\":8,\"132\":4,\"139\":3,\"140\":5,\"141\":5,\"142\":10,\"143\":9}}],[\"length\",{\"1\":{\"133\":1}}],[\"len++\",{\"1\":{\"14\":2}}],[\"len\",{\"1\":{\"9\":5,\"14\":12}}],[\"leq\",{\"1\":{\"5\":1}}],[\"qmi\",{\"1\":{\"91\":1,\"98\":2,\"99\":2}}],[\"query\",{\"1\":{\"123\":1}}],[\"queue\",{\"1\":{\"64\":2,\"133\":2}}],[\"queue<int\",{\"1\":{\"133\":1,\"141\":1}}],[\"queue<int>\",{\"1\":{\"57\":1,\"64\":1,\"65\":1}}],[\"queue<pii\",{\"1\":{\"62\":1}}],[\"quick\",{\"1\":{\"25\":3}}],[\"q\",{\"1\":{\"9\":4,\"25\":8,\"57\":6,\"58\":3,\"64\":8,\"65\":6,\"120\":4,\"121\":3,\"133\":1}}],[\"严格递增的子序列的最大长度\",{\"1\":{\"9\":1}}],[\"最多有26个\",{\"1\":{\"123\":1}}],[\"最终结果为\",{\"1\":{\"90\":1}}],[\"最初最小生成树的边数为\",{\"1\":{\"70\":1}}],[\"最小值\",{\"1\":{\"121\":1}}],[\"最小生成树所有边的长度之和\",{\"1\":{\"69\":1}}],[\"最小生成树就是将\",{\"1\":{\"68\":1}}],[\"最小生成树问题\",{\"0\":{\"68\":1}}],[\"最小的最大\",{\"1\":{\"31\":1}}],[\"最坏情况下的时间复杂度为\",{\"1\":{\"87\":1}}],[\"最坏情况下\",{\"1\":{\"64\":1}}],[\"最坏情况为\",{\"1\":{\"60\":1}}],[\"最低位一定为\",{\"1\":{\"46\":1}}],[\"最后剩下的式子就满足我们的答案\",{\"1\":{\"94\":1}}],[\"最后剩下的就是区间\",{\"1\":{\"82\":1}}],[\"最后将整个图连通起来\",{\"1\":{\"69\":1}}],[\"最后返回c数组\",{\"1\":{\"35\":1,\"36\":1}}],[\"最后一层节点从左向右排列\",{\"1\":{\"128\":1}}],[\"最后一次出现的位置的\",{\"1\":{\"32\":1}}],[\"最后一个访问到的一定是根\",{\"1\":{\"21\":1}}],[\"最后根据分界点分别递归左右两部分\",{\"1\":{\"25\":1}}],[\"最短路问题\",{\"0\":{\"59\":1}}],[\"最短hamilton路径\",{\"0\":{\"19\":1}}],[\"最短编辑距离\",{\"0\":{\"13\":1}}],[\"最长公共上升子序列\",{\"0\":{\"11\":1}}],[\"最长公共子序列\",{\"0\":{\"10\":1}}],[\"最长上升子序列\",{\"0\":{\"9\":1}}],[\"最大不相交区间数量\",{\"0\":{\"140\":1}}],[\"最大公约数与最小公倍数\",{\"0\":{\"87\":1}}],[\"最大匹配\",{\"1\":{\"72\":1}}],[\"最大的最小\",{\"1\":{\"31\":1}}],[\"最大的总价值\",{\"1\":{\"3\":1}}],[\"最大价值是多少\",{\"1\":{\"3\":1,\"4\":1}}],[\"从大到小排序需要加入第三个参数\",{\"1\":{\"134\":1}}],[\"从大到小排序\",{\"1\":{\"134\":1}}],[\"从0开始\",{\"1\":{\"122\":1}}],[\"从00\",{\"1\":{\"16\":1}}],[\"从队头弹出一个数\",{\"1\":{\"120\":1}}],[\"从栈顶弹出一个数\",{\"1\":{\"117\":1}}],[\"从\",{\"1\":{\"81\":1}}],[\"从一个未匹配路出发\",{\"1\":{\"72\":1}}],[\"从一个未匹配点出发\",{\"1\":{\"72\":1}}],[\"从而便于删除前导0\",{\"1\":{\"38\":1}}],[\"从高位到低位运算\",{\"1\":{\"38\":1}}],[\"从小到大枚举n的所有约数对里面比较小的那一个\",{\"1\":{\"85\":1}}],[\"从小到大枚举所有的质数\",{\"1\":{\"81\":1}}],[\"从小到大判断\",{\"1\":{\"85\":1}}],[\"从小到大尝试\",{\"1\":{\"78\":1}}],[\"从小到大遍历\",{\"1\":{\"77\":1,\"83\":1}}],[\"从小到大依次枚举每组边\",{\"1\":{\"70\":1}}],[\"从小到大\",{\"1\":{\"35\":1,\"36\":1}}],[\"从头开始遍历\",{\"1\":{\"26\":1}}],[\"从1\",{\"1\":{\"16\":1}}],[\"从下往上遍历\",{\"1\":{\"8\":1}}],[\"从上往下遍历\",{\"1\":{\"8\":1}}],[\"从顶部出发\",{\"1\":{\"8\":1}}],[\"64\",{\"1\":{\"94\":1}}],[\"6010\",{\"1\":{\"21\":4}}],[\"6\",{\"0\":{\"13\":1,\"17\":1,\"18\":1,\"19\":1,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"71\":1,\"94\":1,\"109\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1},\"1\":{\"8\":1,\"33\":1,\"35\":1,\"36\":1,\"46\":1,\"63\":1,\"95\":1}}],[\"5个基本操作\",{\"1\":{\"128\":1}}],[\"510\",{\"1\":{\"8\":1,\"61\":1}}],[\"5\",{\"0\":{\"12\":1,\"16\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":1,\"65\":1,\"68\":1,\"69\":1,\"70\":1,\"92\":1,\"101\":1,\"108\":1,\"123\":1,\"143\":1},\"1\":{\"8\":2,\"35\":1,\"36\":1,\"46\":1,\"63\":1,\"134\":1,\"143\":1}}],[\"8\",{\"0\":{\"49\":1,\"96\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"129\":1,\"130\":1,\"131\":1,\"132\":1},\"1\":{\"8\":2}}],[\"7\",{\"0\":{\"20\":1,\"21\":1,\"48\":1,\"72\":1,\"95\":1,\"128\":1},\"1\":{\"8\":2,\"15\":2,\"86\":1,\"97\":1}}],[\"数据结构\",{\"0\":{\"112\":1}}],[\"数据范围较大时\",{\"1\":{\"5\":1}}],[\"数据范围\",{\"1\":{\"5\":1,\"11\":1}}],[\"数之间用空格隔开\",{\"1\":{\"94\":1}}],[\"数学知识\",{\"0\":{\"75\":1}}],[\"数组\",{\"1\":{\"122\":2,\"134\":2}}],[\"数组时\",{\"1\":{\"122\":1}}],[\"数组和匹配的操作类似\",{\"1\":{\"122\":1}}],[\"数组模拟链表\",{\"0\":{\"113\":1}}],[\"数组进行备份\",{\"1\":{\"63\":1}}],[\"数组的备份\",{\"1\":{\"63\":1}}],[\"数组是上一次迭代后\",{\"1\":{\"63\":1}}],[\"数组b也是从低位\",{\"1\":{\"35\":1,\"36\":1}}],[\"数组a\",{\"1\":{\"35\":1,\"36\":1}}],[\"数对\",{\"1\":{\"32\":1}}],[\"数位统计类dp\",{\"0\":{\"16\":1}}],[\"数列\",{\"1\":{\"11\":1}}],[\"数字三角形\",{\"0\":{\"8\":1}}],[\"二叉树\",{\"1\":{\"128\":1}}],[\"二进制中1的个数\",{\"1\":{\"47\":1}}],[\"二分\",{\"1\":{\"134\":1}}],[\"二分图\",{\"1\":{\"71\":2}}],[\"二分求出x对应的离散化的值\",{\"1\":{\"49\":1}}],[\"二分答案可以用来处理\",{\"1\":{\"31\":1}}],[\"二分答案模板\",{\"0\":{\"31\":1}}],[\"二分模板一共有两个\",{\"1\":{\"28\":1}}],[\"二分查找算法模板\",{\"0\":{\"28\":1}}],[\"二分算法\",{\"0\":{\"27\":1}}],[\"二分写法\",{\"1\":{\"9\":1}}],[\"二\",{\"0\":{\"112\":1},\"1\":{\"6\":1,\"9\":1}}],[\"二维差分\",{\"0\":{\"43\":1}}],[\"二维前缀和\",{\"0\":{\"41\":1}}],[\"二维\",{\"1\":{\"3\":1,\"4\":1}}],[\"求分成的最小组数\",{\"1\":{\"141\":1}}],[\"求集合当中的最小值\",{\"1\":{\"128\":1}}],[\"求滑动窗口里的最大值和最小值\",{\"1\":{\"121\":1}}],[\"求每个质因数的次数\",{\"1\":{\"100\":1}}],[\"求每个质数的次数\",{\"1\":{\"100\":1}}],[\"求next\",{\"1\":{\"122\":1}}],[\"求next数组时\",{\"1\":{\"122\":1}}],[\"求n\",{\"1\":{\"100\":1}}],[\"求组合数\",{\"0\":{\"96\":1}}],[\"求一个最小的非负整数\",{\"1\":{\"94\":1}}],[\"求一个序列中\",{\"1\":{\"9\":1}}],[\"求x\",{\"1\":{\"93\":1}}],[\"求x的欧拉函数\",{\"1\":{\"89\":1}}],[\"求整数\",{\"1\":{\"93\":1}}],[\"求欧拉函数\",{\"0\":{\"89\":1}}],[\"求最大匹配数\",{\"1\":{\"72\":1}}],[\"求最大权值和\",{\"1\":{\"21\":1}}],[\"求1到n的最短路距离\",{\"1\":{\"63\":1}}],[\"求1号点到n号点的最短距离\",{\"1\":{\"62\":1}}],[\"求1号点到n号点的最短路距离\",{\"1\":{\"64\":1}}],[\"求1号点到n号点的最短路\",{\"1\":{\"61\":1}}],[\"求从一个点到其他所有点的最短距离\",{\"1\":{\"60\":1}}],[\"求起点\",{\"1\":{\"19\":1}}],[\"求\",{\"1\":{\"16\":1,\"91\":1,\"97\":1,\"100\":1,\"122\":1}}],[\"求方案数\",{\"1\":{\"15\":1}}],[\"求既是\",{\"1\":{\"10\":1}}],[\"求解将哪些物品装入背包\",{\"1\":{\"6\":1}}],[\"求所选物品的总体积不超过背包容量的条件下\",{\"1\":{\"3\":1}}],[\"每组询问给定三个整数\",{\"1\":{\"99\":1}}],[\"每组物品有若干个\",{\"1\":{\"6\":1}}],[\"每\",{\"1\":{\"94\":1}}],[\"每次可以移动一步\",{\"1\":{\"106\":1}}],[\"每次可以任选一堆\",{\"1\":{\"104\":1}}],[\"每次异或操作\",{\"1\":{\"104\":1}}],[\"每次都让较大的数对较小数取模\",{\"1\":{\"87\":1}}],[\"每次将\",{\"1\":{\"71\":1}}],[\"每次将区间长度缩小一半\",{\"1\":{\"28\":1}}],[\"每次迭代选择一条不在集合内的权值最短的边\",{\"1\":{\"70\":1}}],[\"每次迭代找到不在连通块中的距离最近的点\",{\"1\":{\"69\":1}}],[\"每次循环遍历所有边\",{\"1\":{\"63\":1}}],[\"每次循环都先将\",{\"1\":{\"25\":1}}],[\"每次备份一下\",{\"1\":{\"63\":1}}],[\"每次只需判断答案是否需要更新\",{\"1\":{\"31\":1}}],[\"每次比较\",{\"1\":{\"26\":1}}],[\"每次询问给出一个字符串和一个操作次数上限\",{\"1\":{\"12\":1}}],[\"每个正整数都能够以唯一的方式表示成它的质因数的乘积\",{\"1\":{\"78\":1}}],[\"每个人只有两种状态\",{\"1\":{\"21\":1}}],[\"每个对字符串进行的单个字符的插入\",{\"1\":{\"12\":1}}],[\"每行输出一个整数作为结果\",{\"1\":{\"12\":1}}],[\"每行包含一个字符串和一个整数\",{\"1\":{\"12\":1}}],[\"每行包含一个字符串\",{\"1\":{\"12\":1}}],[\"每件物品有\",{\"1\":{\"5\":1}}],[\"每件物品只能使用\",{\"1\":{\"3\":1,\"4\":1}}],[\"的元素\",{\"1\":{\"134\":1}}],[\"的元素的位置的迭代器\",{\"1\":{\"134\":1}}],[\"的用法和\",{\"1\":{\"134\":1}}],[\"的第三个参数传入一个元素\",{\"1\":{\"134\":1}}],[\"的第一个元素\",{\"1\":{\"30\":1}}],[\"的减法\",{\"1\":{\"134\":1}}],[\"的相同元素\",{\"1\":{\"134\":1}}],[\"的哈希值\",{\"1\":{\"132\":1}}],[\"的右儿子为\",{\"1\":{\"128\":1}}],[\"的左儿子为\",{\"1\":{\"128\":1}}],[\"的偏移量\",{\"1\":{\"127\":1}}],[\"的距离\",{\"1\":{\"127\":1}}],[\"的前提下\",{\"1\":{\"122\":1}}],[\"的sg函数值构成的集合再执行mex\",{\"1\":{\"108\":1}}],[\"的每一个集合状态\",{\"1\":{\"102\":1}}],[\"的集合\",{\"1\":{\"102\":1}}],[\"的乘法逆元为\",{\"1\":{\"98\":1}}],[\"的乘法逆元\",{\"1\":{\"98\":1}}],[\"的模\",{\"1\":{\"98\":1}}],[\"的逆元不存在\",{\"1\":{\"98\":1}}],[\"的逆元\",{\"1\":{\"98\":1}}],[\"的解\",{\"1\":{\"93\":1}}],[\"的倍数时\",{\"1\":{\"98\":1}}],[\"的倍数\",{\"1\":{\"93\":1,\"98\":1}}],[\"的欧拉函数即为\",{\"1\":{\"90\":1}}],[\"的质因子\",{\"1\":{\"83\":1,\"90\":1}}],[\"的表中划去\",{\"1\":{\"82\":1}}],[\"的表中筛得素数的同时\",{\"1\":{\"82\":1}}],[\"的素数表\",{\"1\":{\"82\":1}}],[\"的约数\",{\"1\":{\"81\":1}}],[\"的唯一质因子\",{\"1\":{\"78\":1}}],[\"的因子\",{\"1\":{\"78\":3}}],[\"的更新方式为\",{\"1\":{\"63\":1}}],[\"的形式存储\",{\"1\":{\"62\":1}}],[\"的点\",{\"1\":{\"58\":1}}],[\"的个数\",{\"1\":{\"47\":2}}],[\"的数整除\",{\"1\":{\"77\":1}}],[\"的数列\",{\"1\":{\"47\":1}}],[\"的数对的个数\",{\"1\":{\"32\":1}}],[\"的二进制表示\",{\"1\":{\"47\":1}}],[\"的二进制表示中第\",{\"1\":{\"47\":1,\"91\":1}}],[\"的二进制位右移\",{\"1\":{\"46\":1}}],[\"的二进制位\",{\"1\":{\"46\":1}}],[\"的指定位\",{\"1\":{\"46\":1}}],[\"的低\",{\"1\":{\"46\":6}}],[\"的商和余数\",{\"1\":{\"38\":1}}],[\"的值为\",{\"1\":{\"46\":1}}],[\"的值\",{\"1\":{\"37\":1,\"99\":1,\"100\":1}}],[\"的问题\",{\"1\":{\"31\":1}}],[\"的最大整数\",{\"1\":{\"134\":1}}],[\"的最大值\",{\"1\":{\"122\":1}}],[\"的最小整数的下标\",{\"1\":{\"134\":1}}],[\"的最小质因子也就是\",{\"1\":{\"83\":1}}],[\"的最小质因子就是\",{\"1\":{\"83\":1}}],[\"的最小质因子\",{\"1\":{\"83\":2,\"90\":3}}],[\"的最后一位\",{\"1\":{\"47\":1}}],[\"的最后一个元素\",{\"1\":{\"30\":1}}],[\"的最低位为\",{\"1\":{\"46\":1}}],[\"的最短hamilton路径\",{\"1\":{\"19\":1}}],[\"的所有因数\",{\"1\":{\"78\":1}}],[\"的所有出边\",{\"1\":{\"64\":1}}],[\"的所有路径\",{\"1\":{\"19\":1}}],[\"的所有方案\",{\"1\":{\"18\":1}}],[\"的棋盘可以摆放不同的\",{\"1\":{\"18\":1}}],[\"的树里各个数字有多少个\",{\"1\":{\"16\":1}}],[\"的各位数字有多少个\",{\"1\":{\"16\":2}}],[\"的一种划分\",{\"1\":{\"15\":1}}],[\"的操作方式\",{\"1\":{\"13\":1}}],[\"的某个位置插入某个字符\",{\"1\":{\"13\":1}}],[\"的长度\",{\"1\":{\"11\":1}}],[\"的长度均不超过\",{\"1\":{\"11\":1}}],[\"的子序列的字符串长度最长是多少\",{\"1\":{\"10\":1}}],[\"的子序列又是\",{\"1\":{\"10\":1}}],[\"的字符串以及\",{\"1\":{\"12\":1}}],[\"的字符串\",{\"1\":{\"10\":1}}],[\"的背包\",{\"1\":{\"6\":1}}],[\"的写法\",{\"1\":{\"5\":1}}],[\"404\",{\"1\":{\"146\":1}}],[\"4\",{\"0\":{\"6\":1,\"11\":1,\"15\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":2,\"43\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":2,\"65\":1,\"66\":1,\"67\":1,\"91\":1,\"100\":1,\"107\":1,\"122\":1,\"142\":1},\"1\":{\"8\":3,\"11\":1,\"35\":1,\"36\":1,\"46\":7,\"63\":1,\"64\":1,\"81\":1,\"114\":1,\"128\":1,\"134\":1}}],[\"b^a\",{\"1\":{\"99\":1}}],[\"by\",{\"1\":{\"93\":7}}],[\"b是否连通的方法为\",{\"1\":{\"70\":1}}],[\"b不连通\",{\"1\":{\"70\":1}}],[\"b表示入点\",{\"1\":{\"63\":1}}],[\"bellman\",{\"0\":{\"63\":1},\"1\":{\"60\":1,\"63\":2}}],[\"begin\",{\"1\":{\"9\":1,\"32\":4,\"38\":1,\"49\":2,\"50\":1,\"85\":1,\"133\":4,\"134\":6,\"143\":1}}],[\"bitset<10000>\",{\"1\":{\"133\":1}}],[\"bitset\",{\"1\":{\"133\":1}}],[\"bit\",{\"1\":{\"46\":1}}],[\"bsearch\",{\"1\":{\"29\":1,\"30\":1,\"33\":1}}],[\"break\",{\"1\":{\"18\":1,\"71\":2,\"83\":1,\"90\":1,\"100\":1,\"102\":1,\"142\":2}}],[\"bool\",{\"1\":{\"16\":1,\"18\":2,\"33\":1,\"36\":1,\"58\":1,\"61\":1,\"62\":1,\"64\":1,\"65\":2,\"69\":1,\"70\":1,\"71\":3,\"72\":2,\"77\":1,\"79\":1,\"81\":1,\"82\":2,\"83\":1,\"90\":1,\"100\":1,\"130\":1,\"134\":2,\"139\":1,\"140\":1,\"141\":1,\"142\":2}}],[\"bound\",{\"1\":{\"9\":1,\"32\":6,\"133\":8,\"134\":7}}],[\"base\",{\"1\":{\"16\":8}}],[\"backup\",{\"1\":{\"63\":2}}],[\"back\",{\"1\":{\"5\":2,\"9\":3,\"16\":2,\"18\":1,\"35\":4,\"36\":5,\"37\":4,\"38\":4,\"50\":2,\"54\":2,\"79\":2,\"85\":2,\"100\":3,\"133\":7,\"143\":3}}],[\"b$\",{\"1\":{\"11\":1}}],[\"b\",{\"1\":{\"5\":4,\"10\":5,\"11\":4,\"12\":3,\"13\":3,\"16\":8,\"21\":4,\"32\":4,\"35\":14,\"36\":28,\"37\":11,\"38\":11,\"42\":2,\"46\":5,\"54\":12,\"61\":8,\"62\":2,\"63\":9,\"64\":3,\"67\":1,\"69\":5,\"70\":6,\"82\":15,\"86\":2,\"87\":7,\"91\":2,\"93\":17,\"94\":9,\"97\":5,\"98\":16,\"99\":19,\"100\":8,\"126\":2,\"127\":1,\"128\":4,\"134\":6}}],[\"a5\",{\"1\":{\"118\":1}}],[\"a3\",{\"1\":{\"118\":2}}],[\"ay\",{\"1\":{\"118\":1}}],[\"any\",{\"1\":{\"133\":1}}],[\"an\",{\"1\":{\"104\":1}}],[\"ans++\",{\"1\":{\"139\":1}}],[\"ans\",{\"1\":{\"8\":4,\"9\":4,\"16\":13,\"31\":3,\"139\":2,\"143\":4}}],[\"a−2\",{\"1\":{\"99\":2}}],[\"a−1\",{\"1\":{\"99\":2}}],[\"a−b−1\",{\"1\":{\"99\":1}}],[\"a−b+1\",{\"1\":{\"99\":2}}],[\"a−b\",{\"1\":{\"99\":3}}],[\"a∗\",{\"1\":{\"99\":2}}],[\"a^b$\",{\"1\":{\"100\":1}}],[\"a^b\",{\"1\":{\"97\":1,\"98\":1,\"99\":2}}],[\"abs\",{\"1\":{\"94\":2,\"95\":3}}],[\"a2\",{\"1\":{\"94\":5,\"104\":1}}],[\"a1\",{\"1\":{\"94\":6,\"104\":1}}],[\"a$\",{\"1\":{\"93\":1}}],[\"ax\",{\"1\":{\"93\":2,\"118\":2}}],[\"ax+by\",{\"1\":{\"93\":1}}],[\"ak\",{\"1\":{\"91\":1}}],[\"a表示出点\",{\"1\":{\"63\":1}}],[\"alls\",{\"1\":{\"49\":9}}],[\"algorithm\",{\"0\":{\"148\":1},\"1\":{\"32\":1},\"2\":{\"22\":1,\"51\":1,\"73\":1,\"110\":1,\"135\":1,\"144\":1}}],[\"a的这一位数\",{\"1\":{\"36\":1}}],[\"a长度不等于b\",{\"1\":{\"36\":1}}],[\"add\",{\"1\":{\"35\":2,\"54\":3,\"62\":1,\"64\":1,\"114\":1}}],[\"acm\",{\"0\":{\"147\":1},\"2\":{\"23\":1,\"52\":1,\"74\":1,\"111\":1,\"136\":1,\"145\":1}}],[\"a>b\",{\"1\":{\"16\":1}}],[\"a||b\",{\"1\":{\"16\":1}}],[\"ask\",{\"1\":{\"16\":3}}],[\"arr\",{\"1\":{\"9\":7,\"139\":7,\"140\":9}}],[\"auto\",{\"1\":{\"5\":1,\"16\":5,\"18\":1,\"35\":1,\"36\":2,\"37\":1,\"38\":1,\"50\":1,\"54\":1,\"62\":1,\"64\":1,\"65\":1,\"86\":1,\"141\":1,\"143\":1}}],[\"a\",{\"1\":{\"5\":4,\"8\":5,\"9\":10,\"10\":6,\"11\":4,\"12\":3,\"13\":4,\"14\":3,\"16\":8,\"21\":3,\"25\":7,\"26\":12,\"29\":1,\"30\":2,\"32\":13,\"35\":15,\"36\":27,\"37\":17,\"38\":15,\"40\":5,\"46\":17,\"54\":13,\"61\":9,\"62\":3,\"63\":9,\"64\":3,\"67\":1,\"69\":5,\"70\":8,\"82\":12,\"86\":2,\"87\":6,\"89\":3,\"91\":15,\"93\":15,\"94\":9,\"95\":17,\"97\":5,\"98\":15,\"99\":24,\"100\":10,\"114\":2,\"123\":2,\"126\":2,\"127\":3,\"128\":4,\"134\":29}}],[\"kmp\",{\"0\":{\"122\":1}}],[\"k指向的下一节点指向新节点\",{\"1\":{\"114\":1}}],[\"k2\",{\"1\":{\"94\":2}}],[\"k1\",{\"1\":{\"94\":7}}],[\"kruskal\",{\"0\":{\"70\":1},\"1\":{\"70\":1}}],[\"k表示走到j这个点之前\",{\"1\":{\"19\":1}}],[\"k++\",{\"1\":{\"5\":2,\"6\":2,\"14\":2,\"16\":3,\"19\":1,\"26\":4,\"67\":1,\"131\":1}}],[\"k\",{\"1\":{\"5\":22,\"6\":10,\"14\":8,\"16\":12,\"18\":2,\"19\":7,\"26\":1,\"30\":1,\"46\":2,\"47\":9,\"54\":1,\"67\":4,\"83\":1,\"91\":9,\"98\":4,\"99\":4,\"114\":6,\"115\":11,\"128\":8,\"130\":5,\"131\":6,\"132\":2,\"133\":3}}],[\"shuffle\",{\"1\":{\"134\":1}}],[\"son\",{\"1\":{\"123\":7}}],[\"sort\",{\"1\":{\"25\":3,\"26\":3,\"32\":1,\"49\":1,\"50\":1,\"70\":1,\"85\":1,\"134\":4,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"s+1\",{\"1\":{\"122\":1}}],[\"s++\",{\"1\":{\"78\":1,\"102\":1}}],[\"s为模式串\",{\"1\":{\"122\":1}}],[\"sg\",{\"1\":{\"108\":5,\"109\":4}}],[\"sg游戏\",{\"0\":{\"108\":1}}],[\"sum\",{\"1\":{\"100\":3}}],[\"substr\",{\"1\":{\"133\":1}}],[\"sub\",{\"1\":{\"36\":3}}],[\"s表示次幂\",{\"1\":{\"78\":1}}],[\"sqrt\",{\"1\":{\"77\":2,\"78\":5,\"82\":4}}],[\"spfa求最短路\",{\"1\":{\"64\":1}}],[\"spfa算法判断图中是否存在负环\",{\"0\":{\"65\":1}}],[\"spfa算法\",{\"0\":{\"64\":1}}],[\"spfa\",{\"1\":{\"60\":1,\"64\":1,\"65\":1}}],[\"set\",{\"1\":{\"133\":5}}],[\"second存储节点编号\",{\"1\":{\"62\":1}}],[\"second\",{\"1\":{\"50\":2,\"62\":1,\"86\":1,\"133\":2,\"143\":2}}],[\"seg\",{\"1\":{\"50\":5}}],[\"segs\",{\"1\":{\"50\":5}}],[\"scanf\",{\"1\":{\"21\":2,\"54\":2,\"94\":3}}],[\"swap\",{\"1\":{\"16\":1,\"25\":1,\"46\":1,\"95\":1,\"128\":6}}],[\"size表示大小\",{\"1\":{\"128\":1}}],[\"sizeof\",{\"1\":{\"18\":1,\"19\":1,\"54\":1,\"61\":2,\"62\":1,\"63\":1,\"64\":1,\"69\":2,\"71\":1,\"72\":1}}],[\"size\",{\"1\":{\"9\":1,\"16\":3,\"35\":7,\"36\":12,\"37\":5,\"38\":4,\"49\":1,\"57\":1,\"62\":1,\"64\":1,\"65\":1,\"100\":1,\"126\":5,\"128\":8,\"133\":7,\"134\":1,\"141\":1,\"143\":1}}],[\"stack\",{\"1\":{\"133\":1}}],[\"state\",{\"1\":{\"18\":4}}],[\"stl简介\",{\"0\":{\"133\":1}}],[\"st\",{\"1\":{\"18\":3,\"50\":1,\"56\":3,\"57\":3,\"61\":3,\"62\":3,\"64\":5,\"65\":5,\"69\":3,\"72\":5,\"81\":4,\"83\":5,\"90\":4,\"100\":3}}],[\"string\",{\"1\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"133\":1}}],[\"strlen\",{\"1\":{\"12\":2}}],[\"str\",{\"1\":{\"12\":3,\"123\":6,\"132\":2,\"133\":1}}],[\"struct\",{\"1\":{\"5\":1,\"54\":1,\"63\":1,\"70\":1,\"134\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1}}],[\"stk\",{\"1\":{\"9\":7,\"117\":3,\"118\":2}}],[\"stdc++\",{\"1\":{\"16\":1,\"21\":1,\"69\":1,\"70\":1}}],[\"std\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"18\":1,\"19\":1,\"21\":1,\"32\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"47\":2,\"61\":1,\"69\":1,\"70\":1,\"86\":1,\"94\":1,\"102\":1,\"104\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"s\",{\"1\":{\"5\":18,\"6\":8,\"12\":3,\"14\":5,\"40\":3,\"41\":5,\"43\":4,\"54\":4,\"78\":2,\"102\":2,\"107\":2,\"108\":2,\"122\":4,\"133\":4}}],[\"3010\",{\"1\":{\"11\":1}}],[\"310\",{\"1\":{\"14\":1}}],[\"31\",{\"1\":{\"11\":1}}],[\"3\",{\"0\":{\"5\":1,\"10\":1,\"14\":1,\"27\":1,\"28\":1,\"31\":1,\"32\":2,\"33\":1,\"37\":1,\"42\":1,\"47\":1,\"58\":1,\"63\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":2,\"87\":1,\"88\":1,\"89\":1,\"90\":1,\"99\":1,\"106\":1,\"119\":1,\"120\":1,\"121\":1,\"127\":1,\"132\":1,\"141\":1},\"1\":{\"8\":1,\"11\":2,\"33\":1,\"35\":1,\"36\":1,\"46\":3,\"47\":1,\"54\":1,\"63\":1,\"64\":1,\"70\":1,\"81\":2,\"95\":1,\"100\":1,\"105\":1,\"114\":1,\"128\":1,\"133\":1,\"134\":1}}],[\"2x\",{\"1\":{\"128\":2}}],[\"26\",{\"1\":{\"123\":1}}],[\"2n\",{\"1\":{\"101\":1}}],[\"22\",{\"1\":{\"91\":2}}],[\"21\",{\"1\":{\"91\":2}}],[\"2−1\",{\"1\":{\"89\":1}}],[\"2^64\",{\"1\":{\"132\":1}}],[\"2^\",{\"1\":{\"89\":1,\"91\":2}}],[\"2ll\",{\"1\":{\"82\":1}}],[\"2k\",{\"1\":{\"46\":2}}],[\"2e5\",{\"1\":{\"32\":1,\"70\":1}}],[\"2e9\",{\"1\":{\"9\":1,\"50\":4,\"139\":1,\"142\":1,\"143\":4}}],[\"20\",{\"1\":{\"19\":1,\"91\":2,\"102\":1}}],[\"2010\",{\"1\":{\"5\":2}}],[\"2个i\",{\"1\":{\"15\":1}}],[\"2\",{\"0\":{\"4\":1,\"7\":1,\"8\":1,\"9\":2,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"19\":1,\"26\":1,\"31\":1,\"36\":1,\"41\":1,\"46\":1,\"55\":1,\"62\":1,\"66\":1,\"67\":1,\"70\":1,\"78\":1,\"82\":1,\"84\":1,\"85\":1,\"86\":2,\"87\":1,\"90\":1,\"98\":1,\"105\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"121\":1,\"126\":1,\"131\":1,\"140\":1},\"1\":{\"5\":2,\"8\":3,\"11\":5,\"14\":2,\"15\":3,\"16\":2,\"21\":2,\"25\":2,\"26\":1,\"30\":2,\"33\":1,\"35\":1,\"36\":2,\"40\":1,\"46\":9,\"48\":1,\"49\":1,\"54\":2,\"58\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"67\":1,\"69\":2,\"70\":1,\"71\":2,\"77\":2,\"78\":1,\"79\":2,\"81\":5,\"82\":2,\"83\":1,\"86\":1,\"89\":3,\"90\":1,\"91\":8,\"94\":2,\"95\":2,\"98\":3,\"99\":1,\"100\":2,\"102\":3,\"105\":1,\"114\":1,\"115\":1,\"122\":1,\"128\":12,\"133\":1,\"134\":1,\"140\":1}}],[\">1\",{\"1\":{\"78\":1}}],[\">b\",{\"1\":{\"54\":1,\"63\":1}}],[\">\",{\"1\":{\"5\":1,\"9\":1,\"11\":1,\"25\":2,\"33\":1,\"36\":5,\"37\":1,\"38\":2,\"54\":3,\"61\":1,\"62\":1,\"63\":3,\"64\":2,\"65\":1,\"69\":1,\"78\":1,\"86\":1,\"89\":1,\"95\":3,\"102\":1,\"117\":1,\"134\":1,\"139\":1}}],[\">=0\",{\"1\":{\"16\":1}}],[\">=\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":3,\"8\":2,\"15\":1,\"25\":1,\"26\":1,\"29\":1,\"30\":1,\"35\":5,\"36\":12,\"37\":4,\"38\":4,\"47\":1,\"49\":1,\"65\":1,\"95\":3,\"118\":2,\"141\":1,\"142\":1}}],[\">>=\",{\"1\":{\"91\":1,\"98\":1,\"99\":1,\"128\":1}}],[\">>\",{\"1\":{\"3\":4,\"4\":4,\"5\":15,\"6\":10,\"8\":2,\"9\":7,\"10\":4,\"11\":3,\"12\":5,\"13\":4,\"14\":2,\"15\":1,\"16\":2,\"18\":3,\"19\":3,\"21\":1,\"26\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":3,\"35\":2,\"36\":2,\"37\":2,\"38\":2,\"45\":1,\"46\":2,\"47\":5,\"49\":1,\"54\":2,\"61\":5,\"69\":5,\"86\":2,\"99\":4,\"102\":4,\"104\":2,\"122\":4,\"133\":1,\"139\":3,\"140\":3,\"141\":3,\"142\":5,\"143\":3}}],[\"一定等于\",{\"1\":{\"98\":1}}],[\"一定在\",{\"1\":{\"94\":1}}],[\"一定存在整数对\",{\"1\":{\"93\":1}}],[\"一定存在整数\",{\"1\":{\"93\":1}}],[\"一定不含有奇数环\",{\"1\":{\"71\":1}}],[\"一定要先累加\",{\"1\":{\"69\":1}}],[\"一定满足\",{\"1\":{\"63\":1}}],[\"一定至少存在一个入度为\",{\"1\":{\"58\":1}}],[\"一般是\",{\"1\":{\"37\":1,\"38\":1}}],[\"一般来说\",{\"1\":{\"31\":1}}],[\"一个指向后\",{\"1\":{\"115\":1}}],[\"一个指向前\",{\"1\":{\"115\":1}}],[\"一个图所有匹配中\",{\"1\":{\"72\":1}}],[\"一个\",{\"1\":{\"72\":1}}],[\"一个有向无环图\",{\"1\":{\"58\":1}}],[\"一个正整数\",{\"1\":{\"15\":1}}],[\"一个数的倍数一定是合数\",{\"1\":{\"81\":1}}],[\"一个数\",{\"1\":{\"9\":1}}],[\"一直走到底层\",{\"1\":{\"8\":1}}],[\"一\",{\"0\":{\"24\":1},\"1\":{\"6\":1,\"9\":1}}],[\"一维差分\",{\"0\":{\"42\":1}}],[\"一维前缀和\",{\"0\":{\"40\":1}}],[\"一维优化\",{\"1\":{\"15\":1}}],[\"一维优化写法\",{\"1\":{\"5\":1}}],[\"一维\",{\"1\":{\"3\":1,\"4\":1}}],[\"一次\",{\"1\":{\"3\":1}}],[\"+inf\",{\"1\":{\"69\":1}}],[\"+happy\",{\"1\":{\"21\":1}}],[\"++size\",{\"1\":{\"128\":1}}],[\"++res\",{\"1\":{\"79\":1}}],[\"++tt\",{\"1\":{\"58\":2,\"117\":1,\"118\":1,\"120\":1,\"121\":1}}],[\"++\",{\"1\":{\"15\":5,\"16\":2,\"18\":6,\"21\":1,\"54\":4,\"61\":3,\"63\":2,\"65\":1,\"70\":1,\"71\":1,\"72\":1,\"86\":3,\"90\":3,\"95\":7,\"98\":1,\"99\":1,\"100\":7,\"114\":1,\"123\":4,\"126\":1,\"127\":1,\"130\":1,\"132\":1,\"133\":1}}],[\"+f\",{\"1\":{\"15\":1}}],[\"+1\",{\"1\":{\"10\":1,\"13\":3}}],[\"+=\",{\"1\":{\"5\":4,\"16\":4,\"18\":1,\"21\":2,\"32\":1,\"35\":2,\"37\":1,\"42\":1,\"43\":2,\"69\":1,\"70\":1,\"81\":1,\"82\":2,\"100\":2,\"102\":1,\"125\":2,\"126\":1,\"127\":1}}],[\"+\",{\"1\":{\"3\":2,\"4\":2,\"5\":4,\"6\":2,\"8\":6,\"9\":6,\"10\":3,\"11\":1,\"12\":7,\"13\":5,\"14\":12,\"15\":10,\"16\":4,\"19\":2,\"21\":2,\"25\":5,\"26\":4,\"29\":4,\"30\":2,\"31\":2,\"32\":8,\"33\":1,\"35\":3,\"36\":2,\"38\":1,\"40\":4,\"41\":1,\"42\":1,\"43\":4,\"47\":1,\"48\":1,\"49\":3,\"54\":3,\"55\":1,\"60\":1,\"61\":2,\"62\":2,\"63\":4,\"64\":2,\"65\":3,\"67\":1,\"69\":2,\"70\":2,\"71\":1,\"81\":5,\"82\":1,\"83\":1,\"86\":11,\"91\":3,\"93\":7,\"94\":4,\"95\":2,\"97\":3,\"99\":1,\"100\":3,\"101\":1,\"122\":4,\"128\":5,\"130\":2,\"131\":1,\"132\":2,\"133\":1,\"134\":13,\"139\":4,\"140\":4,\"141\":2,\"142\":2,\"143\":1}}],[\"0号点既是根节点\",{\"1\":{\"123\":1}}],[\"0和1都被占用了\",{\"1\":{\"115\":1}}],[\"0是左端点\",{\"1\":{\"115\":1}}],[\"0$\",{\"1\":{\"93\":3,\"98\":1}}],[\"0表示白色\",{\"1\":{\"71\":1}}],[\"0001\",{\"1\":{\"46\":1}}],[\"0000\",{\"1\":{\"46\":6}}],[\"0变1\",{\"1\":{\"45\":1}}],[\"0x3f3f3f3f\",{\"1\":{\"61\":1,\"62\":1,\"63\":1,\"64\":1}}],[\"0x3f\",{\"1\":{\"19\":1,\"61\":2,\"62\":1,\"63\":1,\"64\":1,\"69\":2}}],[\"0\",{\"1\":{\"3\":2,\"4\":2,\"5\":8,\"6\":9,\"8\":4,\"9\":11,\"10\":1,\"11\":2,\"12\":8,\"13\":5,\"14\":1,\"15\":6,\"16\":18,\"18\":13,\"19\":9,\"21\":16,\"26\":2,\"32\":4,\"35\":10,\"36\":19,\"37\":9,\"38\":9,\"46\":39,\"47\":4,\"48\":2,\"49\":1,\"54\":6,\"58\":3,\"61\":3,\"62\":2,\"63\":3,\"64\":1,\"67\":1,\"69\":3,\"70\":5,\"71\":2,\"72\":2,\"77\":1,\"78\":3,\"79\":3,\"82\":2,\"83\":4,\"85\":1,\"86\":2,\"89\":2,\"90\":4,\"91\":1,\"93\":1,\"94\":3,\"95\":5,\"97\":2,\"98\":3,\"99\":2,\"100\":8,\"102\":6,\"104\":3,\"114\":1,\"115\":2,\"117\":2,\"118\":1,\"120\":1,\"121\":2,\"122\":4,\"123\":6,\"125\":1,\"127\":1,\"131\":1,\"132\":1,\"139\":2,\"140\":1,\"141\":3,\"142\":4,\"143\":2}}],[\"01\",{\"0\":{\"3\":1}}],[\"j表示第几个区间\",{\"1\":{\"142\":1}}],[\"j表示走到哪一个点\",{\"1\":{\"19\":1}}],[\"j走到哪了呀\",{\"1\":{\"122\":1}}],[\"j$\",{\"1\":{\"122\":1}}],[\"j+1\",{\"1\":{\"122\":1}}],[\"j++\",{\"1\":{\"3\":1,\"4\":2,\"5\":1,\"6\":2,\"8\":3,\"9\":1,\"10\":1,\"11\":1,\"12\":2,\"13\":2,\"16\":3,\"19\":2,\"26\":3,\"48\":1,\"67\":2,\"69\":2,\"83\":1,\"97\":1,\"102\":1,\"122\":2,\"142\":1}}],[\"j−i\",{\"1\":{\"15\":1}}],[\"j\",{\"1\":{\"3\":14,\"4\":13,\"5\":25,\"6\":22,\"8\":19,\"9\":6,\"10\":16,\"11\":9,\"12\":16,\"13\":27,\"14\":16,\"15\":27,\"16\":12,\"18\":16,\"19\":13,\"25\":14,\"26\":8,\"41\":1,\"48\":4,\"56\":3,\"57\":4,\"58\":3,\"61\":12,\"62\":5,\"63\":6,\"64\":6,\"65\":8,\"67\":10,\"69\":10,\"71\":4,\"72\":6,\"81\":4,\"82\":9,\"83\":15,\"90\":20,\"95\":10,\"97\":7,\"99\":4,\"100\":8,\"102\":5,\"122\":17,\"142\":5}}],[\"i$​\",{\"1\":{\"102\":1}}],[\"i$\",{\"1\":{\"94\":2,\"102\":1}}],[\"i的最小质因子\",{\"1\":{\"83\":1}}],[\"i是素数\",{\"1\":{\"82\":1}}],[\"impossible\",{\"1\":{\"69\":1}}],[\"idx表示当前用到了哪个节点\",{\"1\":{\"114\":1,\"115\":1}}],[\"idx++\",{\"1\":{\"62\":1,\"64\":1,\"114\":1,\"115\":1}}],[\"idx\",{\"1\":{\"54\":5,\"62\":4,\"64\":4,\"65\":1,\"71\":1,\"72\":1,\"114\":8,\"115\":6,\"123\":2,\"130\":4}}],[\"id\",{\"1\":{\"54\":3,\"134\":1}}],[\"i表示所有的情况\",{\"1\":{\"19\":1}}],[\"is\",{\"1\":{\"18\":4,\"77\":1,\"79\":1,\"82\":8}}],[\"i==nums\",{\"1\":{\"16\":1}}],[\"i−1\",{\"1\":{\"15\":1}}],[\"if\",{\"1\":{\"3\":1,\"4\":1,\"5\":2,\"6\":2,\"9\":4,\"10\":2,\"11\":2,\"12\":2,\"13\":2,\"14\":1,\"15\":1,\"16\":4,\"18\":4,\"19\":2,\"21\":3,\"25\":2,\"26\":2,\"29\":1,\"30\":1,\"31\":1,\"33\":1,\"35\":3,\"36\":5,\"37\":1,\"46\":3,\"49\":1,\"50\":3,\"54\":3,\"56\":1,\"57\":1,\"58\":2,\"61\":2,\"62\":3,\"63\":4,\"64\":3,\"65\":3,\"67\":1,\"69\":4,\"70\":6,\"71\":5,\"72\":3,\"77\":2,\"78\":2,\"79\":4,\"81\":1,\"82\":1,\"83\":2,\"85\":2,\"86\":1,\"89\":2,\"90\":2,\"91\":1,\"93\":1,\"94\":2,\"95\":5,\"97\":1,\"98\":1,\"99\":3,\"100\":2,\"102\":4,\"104\":1,\"117\":1,\"120\":1,\"121\":2,\"122\":3,\"123\":2,\"125\":2,\"126\":1,\"127\":1,\"128\":3,\"130\":1,\"131\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":3,\"143\":3}}],[\"i++\",{\"1\":{\"3\":3,\"4\":3,\"5\":6,\"6\":3,\"8\":4,\"9\":7,\"10\":1,\"11\":4,\"12\":4,\"13\":2,\"14\":3,\"16\":8,\"19\":2,\"21\":3,\"25\":1,\"26\":3,\"32\":2,\"35\":1,\"36\":1,\"37\":1,\"48\":1,\"54\":1,\"58\":1,\"67\":2,\"69\":3,\"70\":2,\"77\":1,\"78\":1,\"79\":3,\"81\":1,\"82\":3,\"83\":1,\"85\":1,\"89\":1,\"94\":1,\"97\":1,\"102\":2,\"118\":1,\"121\":1,\"122\":2,\"125\":1,\"139\":2,\"140\":2,\"141\":2,\"142\":1,\"143\":1}}],[\"i\",{\"1\":{\"3\":20,\"4\":19,\"5\":30,\"6\":14,\"8\":25,\"9\":32,\"10\":16,\"11\":18,\"12\":22,\"13\":27,\"14\":26,\"15\":40,\"16\":44,\"18\":18,\"19\":14,\"21\":15,\"25\":11,\"26\":9,\"32\":7,\"35\":19,\"36\":29,\"37\":12,\"38\":12,\"40\":2,\"41\":1,\"47\":2,\"48\":5,\"54\":15,\"56\":5,\"57\":5,\"58\":10,\"61\":3,\"62\":7,\"63\":3,\"64\":7,\"65\":12,\"67\":10,\"69\":9,\"70\":10,\"71\":10,\"72\":9,\"77\":4,\"78\":7,\"79\":18,\"81\":6,\"82\":17,\"83\":15,\"85\":8,\"86\":7,\"89\":8,\"90\":23,\"94\":4,\"95\":30,\"97\":7,\"98\":9,\"99\":3,\"100\":22,\"102\":6,\"118\":4,\"121\":4,\"122\":12,\"123\":9,\"125\":5,\"126\":6,\"127\":6,\"128\":4,\"130\":5,\"132\":8,\"134\":1,\"139\":8,\"140\":9,\"141\":7,\"142\":8,\"143\":2}}],[\"insert\",{\"1\":{\"114\":1,\"115\":1,\"123\":1,\"130\":1,\"133\":2}}],[\"inline\",{\"1\":{\"94\":1}}],[\"index指向下一个指针\",{\"1\":{\"114\":1}}],[\"ind\",{\"1\":{\"21\":5}}],[\"init\",{\"1\":{\"16\":2,\"70\":2,\"114\":1,\"115\":1,\"125\":1}}],[\"infact\",{\"1\":{\"98\":6}}],[\"inf\",{\"1\":{\"8\":3,\"63\":3,\"67\":1,\"69\":3,\"70\":1}}],[\"int>\",{\"1\":{\"62\":1,\"79\":2,\"86\":1,\"133\":1,\"143\":1}}],[\"int\",{\"1\":{\"3\":10,\"4\":10,\"5\":32,\"6\":19,\"8\":15,\"9\":25,\"10\":6,\"11\":12,\"12\":14,\"13\":8,\"14\":14,\"15\":9,\"16\":25,\"18\":10,\"19\":9,\"21\":12,\"25\":4,\"26\":6,\"29\":4,\"30\":4,\"31\":5,\"32\":5,\"35\":7,\"36\":8,\"37\":7,\"38\":8,\"46\":2,\"47\":10,\"48\":1,\"49\":4,\"50\":1,\"54\":19,\"56\":4,\"57\":3,\"58\":5,\"61\":11,\"62\":10,\"63\":7,\"64\":10,\"65\":7,\"67\":5,\"69\":15,\"70\":17,\"71\":8,\"72\":8,\"77\":2,\"78\":3,\"79\":6,\"81\":4,\"82\":4,\"83\":5,\"85\":2,\"86\":5,\"87\":6,\"89\":4,\"90\":6,\"91\":5,\"93\":6,\"94\":1,\"95\":13,\"97\":2,\"98\":6,\"99\":14,\"100\":16,\"102\":9,\"104\":4,\"114\":5,\"115\":4,\"117\":2,\"118\":2,\"120\":1,\"121\":2,\"122\":6,\"123\":10,\"125\":9,\"126\":4,\"127\":5,\"128\":7,\"130\":6,\"131\":4,\"132\":3,\"134\":10,\"139\":8,\"140\":7,\"141\":6,\"142\":9,\"143\":6}}],[\"include<algorithm>\",{\"1\":{\"19\":1}}],[\"include<cstring>\",{\"1\":{\"19\":1}}],[\"include<iostream>\",{\"1\":{\"19\":1,\"102\":1}}],[\"include\",{\"1\":{\"3\":3,\"4\":3,\"5\":10,\"6\":6,\"8\":2,\"9\":9,\"10\":3,\"11\":3,\"12\":3,\"13\":3,\"14\":3,\"15\":1,\"16\":1,\"18\":4,\"21\":1,\"32\":2,\"35\":2,\"36\":2,\"37\":2,\"38\":3,\"47\":2,\"61\":3,\"69\":1,\"70\":1,\"86\":4,\"94\":2,\"104\":2,\"122\":1,\"139\":2,\"140\":2,\"141\":3,\"142\":2,\"143\":4}}],[\"c++\",{\"0\":{\"133\":1}}],[\"c++代码模板\",{\"1\":{\"29\":1,\"30\":1}}],[\"cat\",{\"1\":{\"101\":1}}],[\"ck\",{\"1\":{\"86\":1}}],[\"c2\",{\"1\":{\"86\":1}}],[\"c1\",{\"1\":{\"86\":1}}],[\"c表示当前点的颜色\",{\"1\":{\"71\":1}}],[\"cmp\",{\"1\":{\"36\":2,\"134\":2}}],[\"c\",{\"1\":{\"32\":8,\"35\":9,\"36\":14,\"37\":11,\"38\":12,\"42\":2,\"43\":4,\"54\":4,\"61\":5,\"62\":2,\"64\":2,\"69\":3,\"70\":1,\"71\":4,\"81\":1,\"95\":13,\"97\":7,\"99\":8,\"100\":5,\"101\":1,\"133\":1}}],[\"clear\",{\"1\":{\"18\":1,\"133\":4}}],[\"check\",{\"1\":{\"16\":1,\"30\":2,\"31\":1,\"33\":2,\"48\":1,\"71\":1,\"118\":1,\"121\":2}}],[\"char\",{\"1\":{\"10\":1,\"12\":4,\"13\":1,\"122\":1,\"123\":2}}],[\"cnt记录素数个数\",{\"1\":{\"81\":1}}],[\"cnt++\",{\"1\":{\"5\":2,\"18\":1,\"70\":1,\"81\":1,\"83\":1}}],[\"cnt\",{\"1\":{\"5\":6,\"16\":3,\"18\":4,\"65\":5,\"70\":3,\"81\":1,\"83\":1,\"90\":2,\"100\":4,\"123\":4}}],[\"count\",{\"1\":{\"133\":2}}],[\"cout\",{\"1\":{\"3\":2,\"4\":2,\"5\":4,\"6\":2,\"8\":2,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":2,\"18\":1,\"19\":1,\"32\":1,\"38\":2,\"47\":2,\"61\":1,\"78\":3,\"86\":1,\"99\":1,\"102\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"color\",{\"1\":{\"71\":7}}],[\"continue\",{\"1\":{\"14\":1,\"62\":1,\"81\":1,\"95\":1}}],[\"const\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"18\":1,\"19\":1,\"32\":1,\"33\":1,\"35\":1,\"47\":1,\"61\":1,\"69\":1,\"70\":3,\"86\":1,\"95\":1,\"102\":1,\"122\":1,\"134\":2,\"139\":3,\"140\":3,\"141\":3,\"142\":3,\"143\":1}}],[\"cin>>n\",{\"1\":{\"19\":1}}],[\"cin\",{\"1\":{\"3\":2,\"4\":2,\"5\":6,\"6\":6,\"8\":2,\"9\":6,\"10\":1,\"11\":3,\"12\":3,\"13\":2,\"14\":2,\"15\":1,\"16\":1,\"18\":1,\"19\":1,\"21\":1,\"32\":2,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"47\":2,\"54\":1,\"61\":2,\"69\":2,\"86\":2,\"99\":2,\"102\":2,\"104\":2,\"122\":2,\"139\":2,\"140\":2,\"141\":2,\"142\":3,\"143\":2}}],[\"found\",{\"1\":{\"146\":1}}],[\"ford算法擅长解决有边数限制的最短路问题\",{\"1\":{\"63\":1}}],[\"ford算法\",{\"0\":{\"63\":1}}],[\"ford算法的优化\",{\"1\":{\"60\":1}}],[\"ford\",{\"1\":{\"60\":1,\"63\":1}}],[\"for\",{\"0\":{\"149\":1},\"1\":{\"3\":5,\"4\":5,\"5\":14,\"6\":9,\"8\":9,\"9\":8,\"10\":2,\"11\":5,\"12\":6,\"13\":4,\"14\":7,\"15\":5,\"16\":16,\"18\":7,\"19\":5,\"21\":3,\"26\":1,\"32\":2,\"35\":4,\"36\":6,\"37\":3,\"38\":3,\"47\":1,\"48\":1,\"50\":1,\"54\":5,\"56\":1,\"57\":1,\"58\":2,\"61\":3,\"62\":1,\"63\":5,\"64\":1,\"65\":2,\"67\":5,\"69\":5,\"70\":2,\"71\":2,\"72\":2,\"77\":1,\"78\":1,\"79\":3,\"81\":2,\"82\":5,\"83\":2,\"85\":1,\"86\":2,\"89\":1,\"90\":2,\"94\":1,\"95\":9,\"97\":2,\"98\":1,\"99\":1,\"100\":6,\"102\":3,\"118\":1,\"121\":1,\"122\":2,\"123\":2,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"130\":1,\"132\":1,\"139\":2,\"140\":2,\"141\":2,\"142\":2,\"143\":2}}],[\"frac\",{\"1\":{\"89\":3,\"98\":1,\"99\":5}}],[\"front\",{\"1\":{\"57\":1,\"64\":2,\"65\":1,\"133\":5}}],[\"flip\",{\"1\":{\"133\":2}}],[\"flag\",{\"1\":{\"71\":3}}],[\"floyd算法\",{\"0\":{\"67\":1}}],[\"fact\",{\"1\":{\"98\":3}}],[\"factor\",{\"1\":{\"79\":1}}],[\"fabs\",{\"1\":{\"95\":2}}],[\"father\",{\"1\":{\"54\":2}}],[\"false\",{\"1\":{\"16\":1,\"18\":2,\"64\":1,\"65\":2,\"71\":3,\"72\":2,\"77\":2,\"79\":1,\"82\":1,\"91\":2,\"130\":1,\"142\":1}}],[\"first存储距离\",{\"1\":{\"62\":1}}],[\"first\",{\"1\":{\"50\":2,\"62\":1,\"86\":1,\"133\":2,\"143\":2}}],[\"find\",{\"1\":{\"31\":1,\"49\":1,\"70\":6,\"72\":3,\"125\":4,\"126\":6,\"127\":5,\"130\":1,\"131\":1,\"133\":2}}],[\"f\",{\"1\":{\"3\":12,\"4\":11,\"5\":19,\"6\":10,\"8\":11,\"9\":9,\"10\":14,\"11\":7,\"12\":13,\"13\":22,\"14\":7,\"15\":24,\"16\":7,\"18\":7,\"19\":11,\"21\":12,\"142\":3}}],[\"w表示边的权重\",{\"1\":{\"63\":1}}],[\"w表示的是无权图\",{\"1\":{\"19\":1}}],[\"while\",{\"1\":{\"5\":1,\"9\":1,\"12\":1,\"16\":3,\"18\":1,\"25\":3,\"26\":3,\"29\":1,\"30\":1,\"31\":1,\"33\":1,\"36\":1,\"37\":1,\"38\":1,\"47\":2,\"48\":1,\"49\":1,\"57\":1,\"58\":1,\"61\":1,\"62\":1,\"64\":2,\"65\":1,\"78\":1,\"79\":1,\"86\":3,\"89\":1,\"91\":1,\"98\":1,\"99\":2,\"100\":2,\"104\":1,\"118\":1,\"121\":1,\"122\":2,\"128\":1,\"131\":1,\"142\":1}}],[\"w\",{\"1\":{\"3\":4,\"4\":4,\"5\":14,\"6\":6,\"14\":1,\"19\":4,\"54\":2,\"62\":4,\"63\":8,\"64\":4,\"65\":3,\"70\":8,\"139\":2,\"140\":2,\"141\":2,\"142\":2}}],[\"vector\",{\"1\":{\"133\":1,\"134\":3,\"143\":1}}],[\"vector<node>\",{\"1\":{\"134\":1}}],[\"vector<edge>\",{\"1\":{\"54\":1}}],[\"vector<pii>\",{\"1\":{\"50\":2,\"62\":1,\"143\":1}}],[\"vector<int>\",{\"1\":{\"9\":2,\"16\":8,\"18\":1,\"35\":5,\"36\":7,\"37\":4,\"38\":4,\"49\":1,\"79\":2,\"85\":2,\"100\":4,\"133\":1,\"134\":1,\"141\":1}}],[\"vector<good>\",{\"1\":{\"5\":1}}],[\"ver\",{\"1\":{\"62\":4}}],[\"val\",{\"1\":{\"32\":4}}],[\"valid\",{\"1\":{\"18\":4}}],[\"vis\",{\"1\":{\"21\":3}}],[\"void\",{\"1\":{\"16\":2,\"21\":1,\"25\":1,\"26\":1,\"46\":1,\"50\":1,\"54\":2,\"62\":1,\"70\":2,\"78\":1,\"81\":1,\"82\":1,\"83\":1,\"90\":1,\"100\":1,\"114\":5,\"115\":3,\"123\":1,\"125\":2,\"128\":3,\"130\":1,\"143\":1}}],[\"v\",{\"1\":{\"3\":6,\"4\":6,\"5\":19,\"6\":8,\"133\":1}}],[\"m匹配串长度\",{\"1\":{\"122\":1}}],[\"m个1\",{\"1\":{\"102\":1}}],[\"m$​\",{\"1\":{\"102\":1}}],[\"m$\",{\"1\":{\"102\":1}}],[\"m2\",{\"1\":{\"94\":4}}],[\"m1\",{\"1\":{\"94\":7}}],[\"m−1\",{\"1\":{\"89\":1}}],[\"m^\",{\"1\":{\"89\":1}}],[\"m是边数\",{\"1\":{\"70\":1}}],[\"mlogm\",{\"1\":{\"70\":1}}],[\"mlogn\",{\"1\":{\"60\":1,\"62\":1}}],[\"m表示边数\",{\"1\":{\"63\":1,\"69\":1,\"71\":1}}],[\"m代表边数\",{\"1\":{\"54\":1}}],[\"multimap\",{\"1\":{\"133\":3}}],[\"multiset\",{\"1\":{\"133\":3}}],[\"mul\",{\"1\":{\"37\":2,\"100\":2}}],[\"mex\",{\"1\":{\"107\":1,\"108\":1}}],[\"mex运算\",{\"0\":{\"107\":1}}],[\"merge\",{\"1\":{\"26\":3,\"50\":1,\"143\":2}}],[\"memset\",{\"1\":{\"18\":1,\"19\":1,\"54\":1,\"61\":2,\"62\":1,\"63\":1,\"64\":1,\"69\":2,\"71\":1,\"72\":1}}],[\"mod\",{\"1\":{\"15\":4,\"86\":3,\"91\":1,\"94\":3,\"97\":2,\"98\":7,\"99\":3,\"132\":1}}],[\"min\",{\"1\":{\"12\":3,\"13\":3,\"14\":2,\"19\":2,\"61\":4,\"63\":1,\"67\":1,\"69\":2,\"107\":1,\"140\":1}}],[\"mid\",{\"1\":{\"9\":4,\"26\":7,\"29\":9,\"30\":13,\"31\":5,\"33\":4,\"49\":4}}],[\"mx\",{\"1\":{\"11\":4}}],[\"map\",{\"1\":{\"133\":3}}],[\"map>\",{\"1\":{\"86\":1}}],[\"map<int\",{\"1\":{\"79\":2,\"86\":1}}],[\"match\",{\"1\":{\"72\":4}}],[\"max\",{\"1\":{\"3\":2,\"4\":2,\"5\":4,\"6\":2,\"8\":3,\"9\":4,\"10\":2,\"11\":3,\"21\":3,\"48\":1,\"50\":1,\"82\":1,\"87\":1,\"134\":1,\"142\":1,\"143\":1}}],[\"main\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"18\":1,\"19\":1,\"21\":1,\"32\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"47\":2,\"54\":1,\"61\":1,\"69\":1,\"86\":1,\"94\":1,\"99\":1,\"102\":1,\"104\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"m\",{\"1\":{\"3\":6,\"4\":6,\"5\":16,\"6\":8,\"10\":4,\"12\":5,\"13\":5,\"18\":9,\"19\":2,\"54\":1,\"55\":2,\"58\":1,\"60\":4,\"61\":5,\"62\":1,\"63\":4,\"64\":6,\"65\":1,\"69\":6,\"70\":5,\"71\":5,\"72\":3,\"89\":2,\"94\":3,\"98\":12,\"99\":4,\"102\":6,\"122\":8,\"134\":2}}],[\"=p\",{\"1\":{\"122\":1}}],[\"=>\",{\"1\":{\"82\":1}}],[\"=∑u=sonsdp\",{\"1\":{\"21\":1}}],[\"=∑\",{\"1\":{\"21\":1}}],[\"=0\",{\"1\":{\"19\":1}}],[\"=10\",{\"1\":{\"16\":2}}],[\"=f\",{\"1\":{\"15\":1}}],[\"=min\",{\"1\":{\"13\":3}}],[\"=max\",{\"1\":{\"10\":2}}],[\"==\",{\"1\":{\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"18\":1,\"36\":1,\"37\":1,\"38\":1,\"46\":3,\"58\":2,\"61\":2,\"62\":1,\"63\":1,\"64\":1,\"67\":1,\"69\":3,\"70\":3,\"71\":3,\"72\":1,\"77\":1,\"78\":2,\"79\":3,\"83\":2,\"85\":1,\"86\":1,\"89\":2,\"90\":2,\"98\":1,\"100\":1,\"122\":3,\"130\":1,\"131\":1,\"133\":1,\"134\":1}}],[\"==b\",{\"1\":{\"10\":1,\"13\":1}}],[\"=\",{\"1\":{\"3\":9,\"4\":9,\"5\":28,\"6\":13,\"8\":17,\"9\":26,\"10\":5,\"11\":12,\"12\":16,\"13\":10,\"14\":18,\"15\":16,\"16\":29,\"18\":15,\"19\":10,\"21\":6,\"25\":5,\"26\":12,\"28\":1,\"29\":5,\"30\":5,\"31\":4,\"32\":5,\"33\":4,\"35\":12,\"36\":20,\"37\":8,\"38\":8,\"40\":2,\"41\":1,\"42\":1,\"43\":2,\"46\":31,\"47\":10,\"48\":3,\"49\":5,\"50\":8,\"54\":14,\"56\":5,\"57\":7,\"58\":10,\"61\":12,\"62\":14,\"63\":8,\"64\":15,\"65\":11,\"67\":8,\"69\":17,\"70\":19,\"71\":8,\"72\":8,\"77\":1,\"78\":3,\"79\":8,\"81\":5,\"82\":10,\"83\":6,\"85\":2,\"86\":11,\"89\":7,\"90\":11,\"91\":7,\"93\":19,\"94\":10,\"95\":16,\"97\":5,\"98\":10,\"99\":13,\"100\":17,\"101\":1,\"102\":12,\"104\":2,\"107\":1,\"108\":2,\"109\":1,\"114\":10,\"115\":10,\"117\":2,\"118\":3,\"120\":3,\"121\":4,\"122\":12,\"123\":9,\"125\":9,\"126\":6,\"127\":8,\"128\":10,\"130\":8,\"131\":4,\"132\":4,\"133\":1,\"134\":4,\"139\":6,\"140\":7,\"141\":4,\"142\":13,\"143\":9}}],[\"n个闭区间\",{\"1\":{\"139\":1,\"141\":1}}],[\"n个链表\",{\"1\":{\"114\":1}}],[\"num\",{\"1\":{\"143\":5}}],[\"nums\",{\"1\":{\"16\":5,\"143\":7}}],[\"null\",{\"1\":{\"131\":1}}],[\"n为模式串长度\",{\"1\":{\"122\":1}}],[\"none\",{\"1\":{\"133\":1}}],[\"not\",{\"1\":{\"117\":1,\"120\":1,\"146\":1}}],[\"no\",{\"1\":{\"104\":1}}],[\"node\",{\"1\":{\"54\":4,\"134\":3,\"139\":2,\"140\":2}}],[\"nim博弈属于公平组合游戏\",{\"1\":{\"105\":1}}],[\"nim博弈先手必胜\",{\"1\":{\"104\":1}}],[\"nim博弈不存在平局\",{\"1\":{\"104\":1}}],[\"nim游戏\",{\"0\":{\"104\":1}}],[\"n$\",{\"1\":{\"94\":2}}],[\"n1表示第一个集合中的点数\",{\"1\":{\"72\":1}}],[\"n1\",{\"1\":{\"72\":2}}],[\"n是点数\",{\"1\":{\"70\":1}}],[\"n次迭代\",{\"1\":{\"69\":1}}],[\"n^3\",{\"1\":{\"67\":1,\"95\":1}}],[\"n表示点数\",{\"1\":{\"63\":1,\"69\":1,\"71\":1}}],[\"nm\",{\"1\":{\"60\":2,\"63\":1,\"64\":1,\"65\":1,\"72\":1}}],[\"n2表示第二个集合中的点数\",{\"1\":{\"72\":1}}],[\"n2\",{\"1\":{\"60\":1,\"61\":1,\"69\":1,\"72\":1}}],[\"n+m\",{\"1\":{\"58\":1}}],[\"next\",{\"1\":{\"122\":1}}],[\"ne\",{\"1\":{\"54\":2,\"56\":1,\"57\":1,\"58\":1,\"62\":3,\"64\":3,\"65\":2,\"71\":2,\"72\":2,\"93\":2,\"114\":10,\"122\":5,\"130\":3}}],[\"n代表点数\",{\"1\":{\"54\":1}}],[\"nlogn\",{\"1\":{\"32\":1}}],[\"n<=0\",{\"1\":{\"16\":1}}],[\"n共有多少种不同的划分方法\",{\"1\":{\"15\":1}}],[\"n\",{\"1\":{\"3\":10,\"4\":10,\"5\":25,\"6\":18,\"8\":14,\"9\":21,\"10\":9,\"11\":13,\"12\":9,\"13\":10,\"14\":13,\"15\":16,\"16\":6,\"18\":11,\"19\":12,\"21\":6,\"32\":9,\"35\":1,\"47\":14,\"48\":1,\"49\":1,\"54\":13,\"55\":2,\"58\":3,\"60\":2,\"61\":13,\"62\":10,\"63\":13,\"64\":7,\"65\":11,\"67\":5,\"68\":2,\"69\":14,\"70\":14,\"71\":6,\"72\":4,\"77\":1,\"78\":10,\"79\":15,\"81\":16,\"82\":2,\"83\":5,\"86\":5,\"89\":4,\"90\":6,\"94\":9,\"95\":21,\"97\":1,\"98\":3,\"99\":8,\"100\":14,\"101\":3,\"102\":11,\"104\":3,\"114\":2,\"115\":3,\"117\":1,\"118\":1,\"120\":1,\"121\":1,\"122\":5,\"123\":2,\"125\":4,\"126\":3,\"127\":3,\"128\":6,\"130\":9,\"131\":5,\"132\":3,\"134\":8,\"139\":7,\"140\":7,\"141\":7,\"142\":9,\"143\":4}}],[\"namespace\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"18\":1,\"19\":1,\"21\":1,\"32\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"47\":2,\"61\":1,\"69\":1,\"70\":1,\"86\":1,\"94\":1,\"102\":1,\"104\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"<pii>\",{\"1\":{\"143\":1}}],[\"<queue>\",{\"1\":{\"141\":1}}],[\"<unordered\",{\"1\":{\"86\":1}}],[\"<algortihm>\",{\"1\":{\"61\":1}}],[\"<algorithm>\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"18\":1,\"32\":1,\"38\":1,\"86\":1,\"94\":1,\"104\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"<bit\",{\"1\":{\"21\":1}}],[\"<bits\",{\"1\":{\"16\":1,\"69\":1,\"70\":1}}],[\"<vector>\",{\"1\":{\"5\":1,\"9\":1,\"18\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"86\":1,\"143\":1}}],[\"<\",{\"1\":{\"5\":2,\"6\":5,\"9\":8,\"12\":2,\"14\":1,\"16\":1,\"18\":5,\"19\":5,\"21\":1,\"25\":4,\"26\":1,\"29\":1,\"30\":1,\"32\":2,\"35\":4,\"36\":5,\"37\":2,\"48\":2,\"49\":1,\"50\":1,\"54\":2,\"61\":1,\"63\":2,\"69\":3,\"70\":4,\"77\":1,\"82\":5,\"94\":1,\"95\":7,\"97\":1,\"98\":1,\"99\":3,\"100\":4,\"102\":3,\"118\":1,\"121\":1,\"125\":1,\"128\":3,\"134\":3,\"139\":2,\"140\":2,\"141\":4,\"142\":6,\"143\":2}}],[\"<cstring>\",{\"1\":{\"5\":2,\"6\":2,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"18\":1,\"61\":1}}],[\"<cstdio>\",{\"1\":{\"3\":1,\"4\":1,\"5\":1,\"9\":2,\"143\":1}}],[\"<<\",{\"1\":{\"3\":4,\"4\":4,\"5\":8,\"6\":4,\"8\":4,\"9\":6,\"10\":2,\"11\":2,\"12\":2,\"13\":2,\"14\":2,\"15\":4,\"18\":7,\"19\":4,\"32\":2,\"38\":4,\"45\":1,\"46\":2,\"47\":3,\"61\":2,\"78\":9,\"86\":2,\"99\":2,\"102\":3,\"133\":1,\"139\":2,\"140\":2,\"141\":2,\"142\":2,\"143\":2}}],[\"<=\",{\"1\":{\"3\":5,\"4\":5,\"5\":11,\"6\":3,\"8\":7,\"9\":4,\"10\":2,\"11\":5,\"12\":5,\"13\":4,\"14\":6,\"15\":5,\"16\":13,\"18\":1,\"21\":2,\"26\":5,\"30\":2,\"31\":1,\"54\":2,\"58\":2,\"61\":2,\"63\":1,\"65\":1,\"67\":5,\"69\":3,\"70\":1,\"71\":1,\"72\":1,\"77\":1,\"78\":1,\"79\":3,\"81\":2,\"83\":2,\"85\":1,\"86\":1,\"89\":1,\"90\":2,\"95\":1,\"97\":1,\"99\":3,\"100\":2,\"118\":1,\"120\":1,\"121\":2,\"122\":2,\"125\":1,\"126\":1,\"127\":1,\"128\":2,\"132\":1,\"139\":2,\"140\":3,\"142\":1}}],[\"<iostream>\",{\"1\":{\"3\":1,\"4\":1,\"5\":3,\"6\":2,\"8\":1,\"9\":3,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"18\":1,\"32\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"47\":2,\"61\":1,\"86\":1,\"94\":1,\"104\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"$s$\",{\"1\":{\"122\":1}}],[\"$s\",{\"1\":{\"102\":1}}],[\"$p\",{\"1\":{\"102\":3}}],[\"$p$\",{\"1\":{\"98\":2}}],[\"$lucas$\",{\"1\":{\"99\":1}}],[\"$c\",{\"1\":{\"97\":2,\"98\":1,\"99\":3,\"100\":1}}],[\"$∀i\",{\"1\":{\"94\":1}}],[\"$m\",{\"1\":{\"94\":2}}],[\"$m$​\",{\"1\":{\"12\":1}}],[\"$m$\",{\"1\":{\"3\":1,\"4\":1,\"5\":1,\"6\":1,\"10\":1,\"12\":3}}],[\"$2\",{\"1\":{\"94\":1}}],[\"$2n$\",{\"1\":{\"94\":1}}],[\"$2^\",{\"1\":{\"11\":1}}],[\"$y$\",{\"1\":{\"93\":1}}],[\"$gcd\",{\"1\":{\"93\":3}}],[\"$x$\",{\"1\":{\"93\":1,\"94\":1}}],[\"$x\",{\"1\":{\"93\":2}}],[\"$b^\",{\"1\":{\"98\":3}}],[\"$b\",{\"1\":{\"93\":2,\"98\":1}}],[\"$b$​\",{\"1\":{\"13\":1}}],[\"$b$\",{\"1\":{\"11\":3,\"13\":2,\"82\":2}}],[\"$​\",{\"1\":{\"91\":1,\"93\":1}}],[\"$i\",{\"1\":{\"94\":1,\"122\":1}}],[\"$i−1$个\",{\"1\":{\"90\":1}}],[\"$i−1$均与\",{\"1\":{\"90\":1}}],[\"$i$\",{\"1\":{\"18\":1,\"19\":1,\"21\":2,\"90\":3,\"122\":1}}],[\"$ϕ\",{\"1\":{\"89\":1}}],[\"$dp\",{\"1\":{\"21\":4}}],[\"$0$\",{\"1\":{\"19\":4}}],[\"$j$\",{\"1\":{\"18\":2,\"19\":1,\"122\":2}}],[\"$next$\",{\"1\":{\"122\":2}}],[\"$n\",{\"1\":{\"19\":3,\"89\":1}}],[\"$n×m$\",{\"1\":{\"18\":1}}],[\"$n$\",{\"1\":{\"3\":1,\"4\":1,\"5\":1,\"6\":1,\"10\":1,\"11\":3,\"12\":4,\"19\":1,\"90\":2}}],[\"$f\",{\"1\":{\"15\":1,\"18\":1,\"19\":1}}],[\"$1$\",{\"1\":{\"90\":1}}],[\"$1×2$\",{\"1\":{\"18\":1}}],[\"$10$\",{\"1\":{\"12\":2}}],[\"$1≤n≤3000$\",{\"1\":{\"11\":1}}],[\"$a^\",{\"1\":{\"98\":1}}],[\"$a^b\",{\"1\":{\"91\":1}}],[\"$a^b$\",{\"1\":{\"91\":1}}],[\"$ax\",{\"1\":{\"93\":4}}],[\"$a\",{\"1\":{\"11\":1,\"91\":2,\"94\":2}}],[\"$a$\",{\"1\":{\"11\":3,\"13\":6,\"82\":1,\"98\":1}}],[\"$3000$\",{\"1\":{\"11\":1}}],[\"$\",{\"1\":{\"5\":1,\"15\":1,\"18\":1,\"19\":1,\"21\":4,\"82\":18,\"89\":2,\"91\":2,\"93\":5,\"94\":1,\"97\":2,\"98\":5,\"99\":2}}],[\"件物品\",{\"1\":{\"3\":1,\"4\":1,\"5\":1}}],[\"有两个指针\",{\"1\":{\"115\":1}}],[\"有一个1\",{\"1\":{\"102\":1}}],[\"有唯一解\",{\"1\":{\"95\":1}}],[\"有无穷多组解\",{\"1\":{\"95\":1}}],[\"有向图游戏的某个局面必败\",{\"1\":{\"109\":1}}],[\"有向图游戏的某个局面必胜\",{\"1\":{\"109\":1}}],[\"有向图游戏的和的sg函数值等于它包含的各个子游戏sg函数值的异或和\",{\"1\":{\"109\":1}}],[\"有向图游戏的和\",{\"0\":{\"109\":1}}],[\"有向图游戏\",{\"0\":{\"106\":1}}],[\"有向图\",{\"1\":{\"61\":1}}],[\"有向无环图被称为拓扑图\",{\"1\":{\"58\":1}}],[\"有的补0\",{\"1\":{\"45\":1}}],[\"有的补符号位\",{\"1\":{\"45\":1}}],[\"有符号数\",{\"1\":{\"45\":1}}],[\"有限个\",{\"1\":{\"5\":1}}],[\"有\",{\"1\":{\"3\":1,\"4\":1,\"5\":1,\"6\":1,\"99\":1}}],[\"背包容量为\",{\"1\":{\"3\":1,\"4\":1,\"5\":1}}],[\"背包\",{\"0\":{\"3\":1}}],[\"背包问题常用枚举方法\",{\"1\":{\"2\":1}}],[\"背包问题\",{\"0\":{\"2\":1}}],[\"第i堆物品有ai个\",{\"1\":{\"104\":1}}],[\"第i行j列格子左上部分所有元素的和\",{\"1\":{\"41\":1}}],[\"第\",{\"1\":{\"94\":2}}],[\"第三步\",{\"1\":{\"25\":1}}],[\"第三行包含\",{\"1\":{\"11\":1}}],[\"第三维枚举决策\",{\"1\":{\"2\":1}}],[\"第二个元素\",{\"1\":{\"133\":1}}],[\"第二个行动的称为后手\",{\"1\":{\"104\":1}}],[\"第二行输出所求余数\",{\"1\":{\"38\":1}}],[\"第二行包含\",{\"1\":{\"11\":1,\"47\":1}}],[\"第二步\",{\"1\":{\"25\":1}}],[\"第二维枚举起点\",{\"1\":{\"14\":1}}],[\"第二维枚举体积\",{\"1\":{\"2\":1}}],[\"第二种写法\",{\"1\":{\"5\":1,\"6\":1}}],[\"第一个元素\",{\"1\":{\"133\":1}}],[\"第一行输出所求的商\",{\"1\":{\"38\":1}}],[\"第一行包含整数\",{\"1\":{\"47\":1}}],[\"第一行包含两个整数\",{\"1\":{\"12\":1}}],[\"第一行包含一个整数\",{\"1\":{\"11\":1}}],[\"第一次出现的位置\",{\"1\":{\"32\":1}}],[\"第一次循环不能有0\",{\"1\":{\"16\":1}}],[\"第一步\",{\"1\":{\"25\":1}}],[\"第一维通常是枚举区间长度\",{\"1\":{\"14\":1}}],[\"第一维枚举物品\",{\"1\":{\"2\":1}}],[\"第一种写法\",{\"1\":{\"5\":1,\"6\":1}}],[\"1是右端点\",{\"1\":{\"115\":1}}],[\"1−1\",{\"1\":{\"89\":1}}],[\"1^\",{\"1\":{\"89\":1}}],[\"1∼n\",{\"1\":{\"89\":1}}],[\"1~n\",{\"1\":{\"81\":1}}],[\"1表示不存在\",{\"1\":{\"114\":1}}],[\"1表示黑色\",{\"1\":{\"71\":1}}],[\"1表示未染色\",{\"1\":{\"71\":1}}],[\"1ll\",{\"1\":{\"54\":1}}],[\"11\",{\"1\":{\"95\":1}}],[\"1111\",{\"1\":{\"46\":7,\"102\":1}}],[\"1110\",{\"1\":{\"46\":8}}],[\"110\",{\"1\":{\"5\":1,\"6\":2,\"86\":1}}],[\"1100\",{\"1\":{\"4\":1}}],[\"1变0\",{\"1\":{\"45\":1}}],[\"1<<n\",{\"1\":{\"19\":1}}],[\"1<<j\",{\"1\":{\"19\":2}}],[\"1的最短距离\",{\"1\":{\"19\":1}}],[\"1$\",{\"1\":{\"19\":3,\"93\":3,\"94\":2}}],[\"123456\",{\"1\":{\"35\":1,\"36\":1}}],[\"12\",{\"1\":{\"18\":1}}],[\"12010\",{\"1\":{\"5\":1}}],[\"1个0\",{\"1\":{\"16\":1}}],[\"1个9\",{\"1\":{\"16\":1}}],[\"1个i\",{\"1\":{\"15\":1}}],[\"1e5\",{\"1\":{\"69\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"1e6\",{\"1\":{\"35\":1}}],[\"1e\",{\"1\":{\"33\":1,\"95\":1}}],[\"1e3\",{\"1\":{\"15\":1}}],[\"1e9\",{\"1\":{\"8\":1,\"14\":1,\"15\":1,\"86\":1,\"97\":1}}],[\"15\",{\"1\":{\"12\":1}}],[\"10的二进制表示为4位数\",{\"1\":{\"47\":1}}],[\"1011\",{\"1\":{\"46\":1}}],[\"101000\",{\"1\":{\"47\":1}}],[\"1010\",{\"1\":{\"3\":1,\"9\":1,\"10\":1,\"12\":1,\"13\":1,\"46\":8,\"47\":2}}],[\"10\",{\"0\":{\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1,\"134\":1},\"1\":{\"16\":12,\"32\":1,\"35\":3,\"36\":3,\"37\":2,\"38\":1,\"47\":3,\"54\":1,\"69\":1,\"70\":1,\"100\":4,\"139\":1,\"140\":1,\"141\":1,\"142\":1}}],[\"10010\",{\"1\":{\"122\":1}}],[\"1000\",{\"1\":{\"46\":1,\"47\":1}}],[\"100010\",{\"1\":{\"9\":2,\"47\":1,\"122\":1}}],[\"100$\",{\"1\":{\"5\":1}}],[\"1\",{\"0\":{\"2\":1,\"3\":2,\"4\":1,\"5\":1,\"6\":1,\"8\":1,\"18\":1,\"21\":1,\"25\":1,\"28\":1,\"35\":1,\"40\":1,\"45\":1,\"54\":1,\"60\":1,\"61\":2,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"67\":1,\"69\":1,\"76\":1,\"77\":2,\"78\":1,\"80\":1,\"81\":2,\"82\":1,\"83\":1,\"85\":1,\"89\":1,\"97\":1,\"104\":1,\"113\":1,\"114\":2,\"115\":1,\"117\":1,\"118\":1,\"120\":1,\"125\":1,\"130\":1,\"138\":1,\"139\":2,\"140\":1,\"141\":1,\"142\":1,\"143\":1},\"1\":{\"3\":5,\"4\":4,\"5\":9,\"6\":2,\"8\":20,\"9\":14,\"10\":13,\"11\":11,\"12\":15,\"13\":19,\"14\":17,\"15\":14,\"16\":20,\"18\":11,\"19\":8,\"21\":14,\"25\":5,\"26\":3,\"29\":6,\"30\":7,\"31\":3,\"35\":4,\"36\":7,\"37\":3,\"38\":4,\"40\":2,\"41\":4,\"42\":1,\"43\":4,\"46\":38,\"47\":9,\"48\":2,\"49\":4,\"54\":9,\"56\":1,\"57\":3,\"58\":5,\"60\":1,\"61\":9,\"62\":5,\"63\":6,\"64\":7,\"65\":3,\"67\":6,\"68\":1,\"69\":6,\"70\":5,\"71\":7,\"72\":2,\"78\":2,\"79\":4,\"81\":6,\"82\":1,\"83\":1,\"85\":1,\"86\":7,\"89\":5,\"90\":10,\"91\":10,\"93\":3,\"94\":9,\"95\":5,\"97\":7,\"98\":10,\"99\":8,\"100\":2,\"101\":1,\"102\":11,\"114\":2,\"115\":2,\"118\":1,\"120\":1,\"121\":1,\"122\":5,\"125\":1,\"126\":2,\"127\":1,\"128\":11,\"130\":1,\"132\":6,\"133\":2,\"134\":14,\"139\":4,\"140\":5,\"142\":2}}],[\"五\",{\"0\":{\"1\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
