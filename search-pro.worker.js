const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":210,\"nextId\":210,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2#目录\",\"3\":\"2#模板\",\"4\":\"2#笔记\",\"5\":\"2#剑指-offer\",\"6\":\"2#leetcode\",\"7\":\"3\",\"8\":\"4\",\"9\":\"4#目录\",\"10\":\"4#编程语言\",\"11\":\"4#计算机网络\",\"12\":\"4#操作系统\",\"13\":\"4#中间件\",\"14\":\"4#git\",\"15\":\"4#docker\",\"16\":\"5\",\"17\":\"6\",\"18\":\"7\",\"19\":\"8\",\"20\":\"8@0\",\"21\":\"8@1\",\"22\":\"9\",\"23\":\"9#_1-背包问题\",\"24\":\"9#_1-1-01-背包\",\"25\":\"9#_1-2-完全背包\",\"26\":\"9#_1-3-多重背包\",\"27\":\"9#_1-4-分组背包\",\"28\":\"9#_2-线性dp\",\"29\":\"9#_2-1-数字三角形\",\"30\":\"9#_2-2-最长上升子序列\",\"31\":\"9#_2-3-最长公共子序列-不连续\",\"32\":\"9#_2-4-最长公共上升子序列\",\"33\":\"9#_2-5-编辑距离\",\"34\":\"9#_2-6-最短编辑距离\",\"35\":\"9#_3-区间dp\",\"36\":\"9#_4-计数类dp\",\"37\":\"9#_5-数位统计类dp\",\"38\":\"9#_6-状态压缩类dp\",\"39\":\"9#_6-1\",\"40\":\"9#_6-2-最短hamilton路径\",\"41\":\"9#_7-树形dp\",\"42\":\"9#_7-1-没有上司的舞会\",\"43\":\"9@0\",\"44\":\"9@1\",\"45\":\"10\",\"46\":\"10#_1-快速排序\",\"47\":\"10#_2-归并排序\",\"48\":\"10#_3-二分算法\",\"49\":\"10#_3-1-二分查找算法模板\",\"50\":\"10#版本1\",\"51\":\"10#版本2\",\"52\":\"10#_3-2-二分答案模板\",\"53\":\"10#_3-3-整数二分\",\"54\":\"10#_3-4-浮点数二分\",\"55\":\"10#_4-高精度算法\",\"56\":\"10#_4-1-高精度加法\",\"57\":\"10#_4-2-高精度减法\",\"58\":\"10#_4-3-高精度整数乘法\",\"59\":\"10#_4-4-高精度整数除法\",\"60\":\"10#_5-前缀和与差分\",\"61\":\"10#_5-1-一维前缀和\",\"62\":\"10#_5-2-二维前缀和\",\"63\":\"10#_5-3-一维差分\",\"64\":\"10#_5-4-二维差分\",\"65\":\"10#_6-位运算\",\"66\":\"10#_6-1-位运算符\",\"67\":\"10#_6-2-用途\",\"68\":\"10#_6-3-例题\",\"69\":\"10#_7-双指针算法\",\"70\":\"10#_8-离散化\",\"71\":\"10#_9-区间合并\",\"72\":\"10@0\",\"73\":\"10@1\",\"74\":\"11\",\"75\":\"11#_1-树与图的存储\",\"76\":\"11#_2-树与图的遍历\",\"77\":\"11#深度优先遍历\",\"78\":\"11#宽度优先遍历\",\"79\":\"11#_3-拓扑排序\",\"80\":\"11#_4-最短路问题\",\"81\":\"11#_4-1-单源最短路\",\"82\":\"11#_4-1-1-朴素版-dijkstra算法\",\"83\":\"11#_4-1-2-堆优化版的dijkstra算法\",\"84\":\"11#_4-1-3-bellman-ford算法-存在负权边\",\"85\":\"11#_4-1-4-spfa算法-存在负权边\",\"86\":\"11#_4-1-5-spfa算法判断图中是否存在负环\",\"87\":\"11#_4-2-多源汇最短路\",\"88\":\"11#_4-2-1-floyd算法\",\"89\":\"11#_5-最小生成树问题\",\"90\":\"11#_5-1-朴素prim算法\",\"91\":\"11#_5-2-kruskal-算法\",\"92\":\"11#_6-染色法判别二分图\",\"93\":\"11#_7-匈牙利算法\",\"94\":\"11@0\",\"95\":\"11@1\",\"96\":\"12\",\"97\":\"12#_1-质数\",\"98\":\"12#_1-1-试除法判定质数\",\"99\":\"12#_1-2-试除法分解质因数\",\"100\":\"12#汇总\",\"101\":\"12#_1-3-筛法求素数\",\"102\":\"12#_1-3-1-朴素筛法-埃氏筛\",\"103\":\"12#_1-3-2-区间筛法\",\"104\":\"12#_1-3-3-线性筛-欧拉筛\",\"105\":\"12#_2-约数\",\"106\":\"12#_2-1-试除法求所有约数\",\"107\":\"12#_2-2-约数个数和约数之和\",\"108\":\"12#_2-3-最大公约数与最小公倍数\",\"109\":\"12#_3-欧拉函数\",\"110\":\"12#_3-1-求欧拉函数\",\"111\":\"12#_3-2-筛法求欧拉函数\",\"112\":\"12#_4-快速幂\",\"113\":\"12#_5-扩展欧几里得算法\",\"114\":\"12#裴蜀定理\",\"115\":\"12#_6-中国剩余定理\",\"116\":\"12#_7-高斯消元\",\"117\":\"12#_8-求组合数\",\"118\":\"12#_8-1-递推法求组合数\",\"119\":\"12#_8-2-通过预处理逆元的方式求组和数\",\"120\":\"12#_8-3-卢卡斯-lucas-定理求组合数\",\"121\":\"12#_8-4-分解质因数法求组合数\",\"122\":\"12#_8-5-卡特兰数\",\"123\":\"12#_9-容斥原理\",\"124\":\"12#_10-博弈论\",\"125\":\"12#_10-1-nim游戏\",\"126\":\"12#_10-2-公平组合游戏icg\",\"127\":\"12#_10-3-有向图游戏\",\"128\":\"12#_10-4-mex运算\",\"129\":\"12#_10-5-sg游戏\",\"130\":\"12#_10-6-有向图游戏的和\",\"131\":\"12@0\",\"132\":\"12@1\",\"133\":\"13\",\"134\":\"13#_1-数组模拟链表\",\"135\":\"13#_1-1-单链表\",\"136\":\"13#_1-2-双链表\",\"137\":\"13#_2-栈\",\"138\":\"13#_2-1-普通栈\",\"139\":\"13#_2-1-单调栈\",\"140\":\"13#_3-队列\",\"141\":\"13#_3-1-普通队列\",\"142\":\"13#_3-2-单调队列\",\"143\":\"13#_4-kmp\",\"144\":\"13#_5-trie树\",\"145\":\"13#_6-并查集\",\"146\":\"13#_6-1-朴素并查集\",\"147\":\"13#_6-2-维护size的并查集\",\"148\":\"13#_6-3-维护到祖宗节点距离的并查集\",\"149\":\"13#_7-堆\",\"150\":\"13#_8-哈希表\",\"151\":\"13#_8-1-拉链法\",\"152\":\"13#_8-2-开放寻址法\",\"153\":\"13#_8-3-字符串哈希\",\"154\":\"13#_9-c-stl简介\",\"155\":\"13#_10-常用库函数\",\"156\":\"13@0\",\"157\":\"13@1\",\"158\":\"14\",\"159\":\"14#_1-区间问题\",\"160\":\"14#_1-1-区间选点\",\"161\":\"14#_1-2-最大不相交区间数量\",\"162\":\"14#_1-3-区间分组\",\"163\":\"14#_1-4-区间覆盖\",\"164\":\"14#_1-5-区间合并\",\"165\":\"14@0\",\"166\":\"14@1\",\"167\":\"15\",\"168\":\"15@0\",\"169\":\"15@1\",\"170\":\"16\",\"171\":\"16#题意\",\"172\":\"16#思路一-递归\",\"173\":\"16#思路二-迭代\",\"174\":\"16@0\",\"175\":\"16@1\",\"176\":\"17\",\"177\":\"17#题意\",\"178\":\"17#思路一-优先队列\",\"179\":\"17#思路二-单调队列\",\"180\":\"17@0\",\"181\":\"17@1\",\"182\":\"18\",\"183\":\"18#linux-安装启动\",\"184\":\"18#docker-安装启动\",\"185\":\"18#windows-安装启动\",\"186\":\"18#windows-后台服务安装\",\"187\":\"18@0\",\"188\":\"18@1\",\"189\":\"19\",\"190\":\"19#什么是对象存储\",\"191\":\"19#特点\",\"192\":\"19@0\",\"193\":\"19@1\",\"194\":\"20\",\"195\":\"20#引入依赖\",\"196\":\"20#配置文件\",\"197\":\"20#minioclient-的常用-api\",\"198\":\"20#bucket-操作\",\"199\":\"20#object-操作\",\"200\":\"20@0\",\"201\":\"20@1\",\"202\":\"21\",\"203\":\"22\",\"204\":\"23\",\"205\":\"24\",\"206\":\"25\",\"207\":\"26\",\"208\":\"27\",\"209\":\"28\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1,4],\"2\":[1],\"3\":[1,6],\"4\":[1],\"5\":[2],\"6\":[1],\"7\":[1,4],\"8\":[1,9],\"9\":[1],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[1,44],\"14\":[1],\"15\":[1],\"16\":[1,2],\"17\":[1,3],\"18\":[1,5],\"19\":[1],\"20\":[null,null,1],\"21\":[null,null,1],\"22\":[1],\"23\":[2,4],\"24\":[3,49],\"25\":[3,46],\"26\":[3,75],\"27\":[3,53],\"28\":[2],\"29\":[3,53],\"30\":[2,74],\"31\":[5,50],\"32\":[3,79],\"33\":[3,83],\"34\":[3,64],\"35\":[2,74],\"36\":[2,61],\"37\":[2,101],\"38\":[2],\"39\":[2,74],\"40\":[3,74],\"41\":[2],\"42\":[3,76],\"43\":[null,null,1],\"44\":[null,null,1],\"45\":[1],\"46\":[2,54],\"47\":[2,58],\"48\":[2],\"49\":[3,13],\"50\":[1,30],\"51\":[1,45],\"52\":[3,36],\"53\":[2,72],\"54\":[3,25],\"55\":[2],\"56\":[3,77],\"57\":[3,106],\"58\":[3,60],\"59\":[2,72],\"60\":[2],\"61\":[3,10],\"62\":[3,15],\"63\":[3,10],\"64\":[3,13],\"65\":[2],\"66\":[3,37],\"67\":[3,138],\"68\":[3,81],\"69\":[2,25],\"70\":[2,34],\"71\":[2,27],\"72\":[null,null,1],\"73\":[null,null,1],\"74\":[1],\"75\":[2,73],\"76\":[2,7],\"77\":[1,16],\"78\":[1,23],\"79\":[2,49],\"80\":[2],\"81\":[3,34],\"82\":[4,84],\"83\":[4,76],\"84\":[7,103],\"85\":[5,88],\"86\":[4,62],\"87\":[3],\"88\":[4,31],\"89\":[2,14],\"90\":[3,106],\"91\":[4,114],\"92\":[2,80],\"93\":[2,94],\"94\":[null,null,1],\"95\":[null,null,1],\"96\":[1],\"97\":[2],\"98\":[2,26],\"99\":[3,47],\"100\":[1,34],\"101\":[3],\"102\":[5,63],\"103\":[4,53],\"104\":[5,65],\"105\":[2],\"106\":[3,27],\"107\":[2,67],\"108\":[3,27],\"109\":[2],\"110\":[3,35],\"111\":[3,60],\"112\":[2,49],\"113\":[2],\"114\":[1,64],\"115\":[2,94],\"116\":[2,83],\"117\":[2],\"118\":[3,29],\"119\":[3,86],\"120\":[5,79],\"121\":[3,73],\"122\":[3,11],\"123\":[2,81],\"124\":[2],\"125\":[3,74],\"126\":[3,17],\"127\":[3,12],\"128\":[3,11],\"129\":[3,23],\"130\":[3,22],\"131\":[null,null,1],\"132\":[null,null,1],\"133\":[1],\"134\":[2],\"135\":[2,48],\"136\":[3,35],\"137\":[2,1],\"138\":[3,20],\"139\":[3,34],\"140\":[2,2],\"141\":[3,24],\"142\":[3,38],\"143\":[2,87],\"144\":[2,40],\"145\":[2],\"146\":[3,32],\"147\":[3,26],\"148\":[3,32],\"149\":[2,87],\"150\":[2],\"151\":[3,27],\"152\":[3,23],\"153\":[3,43],\"154\":[3,142],\"155\":[2,102],\"156\":[null,null,1],\"157\":[null,null,1],\"158\":[1],\"159\":[2],\"160\":[2,54],\"161\":[3,45],\"162\":[3,62],\"163\":[3,65],\"164\":[3,64],\"165\":[null,null,1],\"166\":[null,null,1],\"167\":[1,17],\"168\":[null,null,1],\"169\":[null,null,1],\"170\":[1,1],\"171\":[1,16],\"172\":[3,13],\"173\":[3,21],\"174\":[null,null,1],\"175\":[null,null,3],\"176\":[1,3],\"177\":[1,11],\"178\":[3,41],\"179\":[3],\"180\":[null,null,1],\"181\":[null,null,3],\"182\":[2,16],\"183\":[2,85],\"184\":[2,20],\"185\":[2,42],\"186\":[2,78],\"187\":[null,null,1],\"188\":[null,null,1],\"189\":[2,40],\"190\":[2,56],\"191\":[1,143],\"192\":[null,null,1],\"193\":[null,null,1],\"194\":[3],\"195\":[1,12],\"196\":[1,85],\"197\":[3],\"198\":[2,76],\"199\":[2,95],\"200\":[null,null,1],\"201\":[null,null,1],\"202\":[1,3],\"203\":[2],\"204\":[1],\"205\":[2],\"206\":[2],\"207\":[1],\"208\":[2],\"209\":[1]},\"averageFieldLength\":[2.271783449127645,42.762975166149765,0.2765932018422391],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"个人介绍和档案放置在此。\"]},\"1\":{\"h\":\"算法笔记\",\"t\":[\"此处存放刷题时的思路和笔记，包括算法题、笔试题和面试题等。\"]},\"2\":{\"h\":\"目录\"},\"3\":{\"h\":\"模板\",\"t\":[\"基础算法\",\"数据结构\",\"搜索与图论\",\"数学知识\",\"动态规划\",\"贪心\"]},\"4\":{\"h\":\"笔记\"},\"5\":{\"h\":\"剑指 offer\"},\"6\":{\"h\":\"LeetCode\"},\"7\":{\"h\":\"架构设计\",\"t\":[\"此处存放一些关于 Java 架构以及系统架构方面的笔记知识点。\"]},\"8\":{\"h\":\"计算机\",\"t\":[\"此处存放一些计算机大类的笔记，包括编程语言、计算机网络、操作系统、数据库、Linux、Git、Docker等等。\"]},\"9\":{\"h\":\"目录\"},\"10\":{\"h\":\"编程语言\"},\"11\":{\"h\":\"计算机网络\"},\"12\":{\"h\":\"操作系统\"},\"13\":{\"h\":\"中间件\",\"t\":[\"中间件（英语：Middleware）：是一种在系统软件和用户应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件在客户服务器的操作系统、网络和数据库之上，管理计算资源和网络通信。总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。\",\"也就是说，关于中间件，可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。中间件是一类软件统称，而非一种软件；中间件不仅仅实现互连，还要实现应用之间的互操作。\",\"中间件与操作系统和数据库共同构成基础软件三大支柱，是一种应用于分布式系统的基础软件，位于应用与操作系统、数据库之间，为上层应用软件提供开发、运行和集成的平台。中间件解决了异构网络环境下软件互联和互操作等共性问题，并提供标准接口、协议，为应用软件间共享资源提供了可复用的“标准件”。\",\"常见中间件主要分为：Web中间件、数据库中间件、消息中间件、安全中间件、事务中间件、应用程序服务器中间件、分布式计算中间件等。\"]},\"14\":{\"h\":\"Git\"},\"15\":{\"h\":\"Docker\"},\"16\":{\"h\":\"常用框架\",\"t\":[\"此处存放前后端常用框架的笔记。\"]},\"17\":{\"h\":\"开源项目\",\"t\":[\"此处存放自己写和一些优秀的开源项目，帮助学习。\"]},\"18\":{\"h\":\"程序人生\",\"t\":[\"此处存放一些程序员相关的资源文件，包括但不限于书籍、文章、资料等等。\"]},\"19\":{\"h\":\"剑指offer\"},\"20\":{\"c\":[\"algorithm\"]},\"21\":{\"c\":[\"offer\"]},\"22\":{\"h\":\"动态规划\"},\"23\":{\"h\":\"1. 背包问题\",\"t\":[\"背包问题常用枚举方法\",\"第一维枚举物品\",\"第二维枚举体积\",\"第三维枚举决策\"]},\"24\":{\"h\":\"1.1 01 背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用 一次。\",\"求所选物品的总体积不超过背包容量的条件下，最大的总价值。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++){ for (int j = 0; j <= m; j++){ f[i][j] = f[i - 1][j]; //左半边的子集 if (v[i] <= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } cout << f[n][m] << endl; */ //一维 //f[i] 表示总体积是i的情况下，最大价值是多少 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\"]},\"25\":{\"h\":\"1.2 完全背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用 无限次。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1100; int n, m; int v[N], w[N]; int f[N]; //表示总体积是i的情况下，最大价值是多少 int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++) for (int j = 0; j <= m; j++) { f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout << f[n][m] << endl; */ //一维 for (int i = 1; i <= n; i++) for (int j = v[i]; j <= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout << f[m] << endl; return 0; }\"]},\"26\":{\"h\":\"1.3 多重背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品有 有限个。\",\"数据范围 ≤100 的写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); cout << f[n][m] << endl; /* 一维优化写法 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[j] = max(f[j], f[j - k * v[i]] + w[i] * k); } } cout << f[m] << endl; */ return 0; }\",\"数据范围较大时，需要用多重背包的二进制优化方法：\",\"第一种写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; int f[M]; int main() { cin >> n >> m; int cnt = 0; for (int i = 1; i <= n; i++){ int a, b, s; cin >> a >> b >> s; int k = 1; while (k < s){ cnt++; v[cnt] += a * k; w[cnt] += b * k; s -= k; k *= 2; } if (s){ cnt++; v[cnt] += a * s; w[cnt] += b * s; } } n = cnt; for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\",\"第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <vector> using namespace std; const int N = 2010; int n, m; int f[N]; struct Good { int v, w; }; int main() { vector<Good> goods; cin >> n >> m; for (int i = 0; i < n; i++){ int v, w, s; cin >> v >> w >> s; for (int k = 1; k <= s; k *= 2){ s -= k; goods.push_back({v * k, w * k}); } if (s > 0) goods.push_back({v * s, w * s}); } for (auto good : goods){ for (int j = m; j >= good.v; j--){ f[j] = max(f[j], f[j - good.v] + good.w); } } cout << f[m] << endl; return 0; }\"]},\"27\":{\"h\":\"1.4 分组背包\",\"t\":[\"有 n 组物品和一个容量是 m 的背包。\",\"每组物品有若干个，同一组内的物品最多只能选一个。\",\"求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\",\"（一）第一种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++){ cin >> s[i]; for (int j = 0; j < s[i]; j++){ cin >> v[i][j] >> w[i][j]; } } for (int i = 1; i <= n; i++){ for (int j = m; j >= 0; j--){ for (int k = 0; k < s[i]; k++){ if (v[i][k] <= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } } cout << f[m] << endl; return 0; }\",\"（二）第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int f[N], v[N], w[N]; int main() { cin >> n >> m; for (int i = 0; i < n; i++) { int s; cin >> s; for (int j = 0; j < s; j++) cin >> v[j] >> w[j]; for (int j = m; j >= 0; j--) for (int k = 0; k < s; k++) if (j >= v[k]) f[j] = max(f[j], f[j - v[k]] + w[k]); } cout << f[m] << endl; return 0; }\"]},\"28\":{\"h\":\"2. 线性DP\"},\"29\":{\"h\":\"2.1 数字三角形\",\"t\":[\"给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。\",\" 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5\",\"线性DP写法：\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 510, INF = 1e9; int n; int a[N][N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= i; j++) cin >> a[i][j]; for (int i = 0; i <= n; i++) for (int j = 0; j <= i + 1; j++) f[i][j] = -INF; //从上往下遍历 f[1][1] = a[1][1]; for (int i = 2; i <= n; i++) for (int j = 1; j <= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; // 状态转移方程 int ans = -INF; for (int i = 1; i <= n; i++) ans = max(ans, f[n][i]); cout << ans << endl; /*从下往上遍历 for (int i = n; i >= 1; i--) for (int j = n; j >= 1; j--) f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; cout << f[1][1] << endl; */ return 0; }\"]},\"30\":{\"h\":\"2.2 最长上升子序列\",\"t\":[\"求一个序列中 严格递增的子序列的最大长度。\",\"(一）朴素DP写法：\",\"状态转移方程：if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1010; int n; int a[N]; int f[N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) { f[i] = 1; // 只有a[1]一个数 for (int j = 1; j <= i; j++) if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1); } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f[i]); cout << ans << endl; return 0; }\",\"（二）二分写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 100010; int n; int q[N]; int a[N]; int main() { cin >> n; for (int i = 0; i < n; i++) cin >> a[i]; int len = 0; q[0] = -2e9; for (int i = 0; i < n; i++) { int l = 0, r = len; while (l < r) { int mid = l + r + 1 >> 1; if (q[mid] < a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } cout << len << endl; return 0; }\",\"（三）单调队列写法：\",\"#include <iostream> #include <cstdio> #include <vector> #include <algorithm> using namespace std; const int N = 100010; int n; int main() { cin >> n; vector<int> arr(n); for (int i = 0; i < n; i++) cin >> arr[i]; vector<int> stk; //模拟堆栈 stk.push_back(arr[0]); for (int i = 1; i < n; i++) //单调队列思维 { if (arr[i] > stk.back()) //如果该元素大于栈顶元素，则将该元素入栈 stk.push_back(arr[i]); else //否则，替换掉第一个大于或等于这个数字的那个数 *lower_bound(stk.begin(), stk.end(), arr[i]) = arr[i]; } cout << stk.size() << endl; return 0; }\"]},\"31\":{\"h\":\"2.3 最长公共子序列（不连续）\",\"t\":[\"给定两个长度分别为 n 和 m 的字符串 A 和 B，\",\"求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\",\"状态转移方程：\",\"f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin >> n >> m >> a + 1 >> b + 1; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i- 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"32\":{\"h\":\"2.4 最长公共上升子序列\",\"t\":[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\",\"小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\",\"小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。\",\"奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\",\"不过，只要告诉奶牛它的长度就可以了。\",\"数列 A 和 B 的长度均不超过 3000。\",\"输入格式\",\"第一行包含一个整数 N，表示数列 A，B 的长度。\",\"第二行包含 N 个整数，表示数列 A。\",\"第三行包含 N 个整数，表示数列 B。\",\"输出格式\",\"输出一个整数，表示最长公共上升子序列的长度。\",\"数据范围\",\"1≤N≤3000 , 序列中的数字均不超过 231−1 。\",\"输入样例：\",\"4 2 2 1 3 2 1 2 3\",\"输出样例：\",\"2\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 3010; int n; int a[N], b[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; for (int i = 1; i <= n; i++){ int mx = 1; for (int j = 1; j <= n; j++){ f[i][j] = f[i - 1][j]; if (a[i] == b[j]) f[i][j] = max(f[i][j], mx); if (a[i] > b[j]) mx = max(mx, f[i - 1][j] + 1); } } int res = 0; for (int i = 1; i <= n; i++) res = max(res, f[n][i]); cout << res << endl; return 0; }\"]},\"33\":{\"h\":\"2.5 编辑距离\",\"t\":[\"给定 n 个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。\",\"对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。\",\"每个对字符串进行的单个字符的插入、删除或替换算作一次操作。\",\"输入格式\",\"第一行包含两个整数 n 和 m 。\",\"接下来 n 行，每行包含一个字符串，表示给定的字符串。\",\"再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。\",\"字符串中只包含小写字母，且长度均不超过 10 。\",\"输出格式\",\"输出共 m​ 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。\",\"模板代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 15, M = 1010; int n, m; int f[N][N]; char str[M][N]; int edit_distance(char a[], char b[]) { int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i <= la; i++) f[i][0] = i; for (int j = 0; j <= lb; j++) f[0][j] = j; for (int i = 1; i <= la; i++) for (int j = 1; j <= lb; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } return f[la][lb]; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> str[i] + 1; //下标从1开始存 while (m--){ char s[N]; int limit; cin >> s + 1 >> limit; int res = 0; for (int i = 0; i < n; i++) if (edit_distance(str[i], s) <= limit) res++; cout << res << endl; } return 0; }\"]},\"34\":{\"h\":\"2.6 最短编辑距离\",\"t\":[\"给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：\",\"删除 – 将字符串 A 中的某个字符删除。\",\"插入 – 在字符串 A 的某个位置插入某个字符。\",\"替换 – 将字符串 A 中的某个字符替换为另一个字符。\",\"现在请你求出，将 A 变为 B​ 至少需要进行多少次操作。\",\"状态转移方程：\",\"f[i][j] = min(f[i-1][j] + 1, f[i][j-1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i-1][j-1]); else f[i][j] = min(f[i][j], f[i-1][j-1] + 1); //状态转移方程\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; //所有将a[i]变成b[j]的操作方式 int main() { cin >> n >> a + 1; cin >> m >> b + 1; for (int i = 0; i <= n; i++) f[i][0] = i; for (int j = 0; j <= m; j++) f[0][j] = j; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"35\":{\"h\":\"3. 区间DP\",\"t\":[\"区间 DP 常用模版\",\"所有的区间dp问题枚举时，\",\"第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；\",\"第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）\",\"模板代码如下：\",\"for (int len = 1; len <= n; len++) { // 区间长度 for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点 int j = i + len - 1; // 区间终点 if (len == 1) { dp[i][j] = 初始值 continue; } for (int k = i; k < j; k++) { // 枚举分割点，构造状态转移方程 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); } } }\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 310; int n; int a[N], s[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> a[i]; s[i] = s[i - 1] + a[i]; } //区间DP枚举套路：长度+左端点 for (int len = 2; len <= n; len++) //先枚举长度 { for (int i = 1; i + len - 1 <= n; i++) //再枚举左端点，且保证右端点不会超范围 { int j = i + len - 1; //自动得到右端点 f[i][j] = 1e9; //初始化大于1的区间为最大，长度为1的区间为0 for (int k = i; k <= j - 1; k++) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]); } } //得到总区间的最小代价 cout << f[1][n] << endl; return 0; }\"]},\"36\":{\"h\":\"4. 计数类DP\",\"t\":[\"一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。\",\"表示前 i 个整数（1, 2…, i）恰好拼成 j 的方案数 求方案数：把集合选 0个 i，1 个 i，2 个 i，…全部加起来\",\"f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"因此 f[i][j]=f[i−1][j]+f[i][j−i] （这一步类似完全背包的推导）\",\"朴素做法：\",\"// f[i][j] = f[i - 1][j] + f[i][j - i] #include <iostream> using namespace std; const int N = 1e3 + 7, mod = 1e9 + 7; int f[N][N]; int main() { int n; cin >> n; for (int i = 0; i <= n; i ++) { f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 } for (int i = 1; i <= n; i ++) { for (int j = 0; j <= n; j ++) { f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1 if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod; } } cout << f[n][n] << endl; }\",\"一维优化：\",\" f[0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 for (int i = 1; i <= n; i ++) { for (int j = i; j <= n; j ++) { f[j] = (f[j] + f[j - i]) % mod; } } cout << f[n] << endl;\"]},\"37\":{\"h\":\"5. 数位统计类DP\",\"t\":[\"给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0 ~ 9 的出现次数。\",\"#include <bits/stdc++.h> using namespace std; int base[10]; int f[10][10]; int g[10][10]; void init() { base[0] = 1; for(int i = 1 ; i <= 9 ; i++) base[i] = base[i-1]*10; //从00……0 - 99……9 的各位数字有多少个，其中i为数字个数（包含前导零） for(int i = 0 ; i <= 9 ; i++) f[1][i] = 1; for(int i = 2 ; i <= 9 ; i++) for(int j = 0 ; j <= 9 ; j++) f[i][j] = f[i-1][j]*10 + base[i-1]; //从1 - 99……9 的各位数字有多少个，其中i为数字个数（不包含前导零） for(int i = 1 ; i <= 9 ; i++) g[1][i] = 1;//循环从1开始 for(int i = 2 ; i <= 9 ; i++) { g[i][0] = g[i-1][0] + f[i-1][0]*9; for(int j = 1 ; j <= 9 ; j++) g[i][j] = g[i-1][j] + f[i-1][j]*9 + base[i-1]; } } vector<int> dp(int n) { vector<int> ans(10,0); //记录答案 if(n<=0) return ans; //边界条件 vector<int> nums; while(n) nums.push_back(n%10), n/=10; vector<int> last(10,0); //记录前缀中各个数字个数 //统计1 - 99……9(n-1个9)里面各个数字有多少个 for(int i = 0 ; i <= 9 ; i++) ans[i] = g[nums.size()-1][i]; //统计大于10……0(n-1个0) 的树里各个数字有多少个 for(int i = nums.size()-1 ; i >=0 ; i--) { //循环变量i可以表示剩下的数字有多少个 int x = nums[i]; for(int j = i==nums.size()-1 ; j < x ; j++) { //第一次循环不能有0 //前缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k] * base[i]; //当前位置部分 ans[j] += base[i]; //后缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += f[i][k]; } //更新前缀计数器 last[x] ++; //统计叶子节点（这个数本身） if(!i) for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k]; } return ans; } vector<int> ask(int a, int b) { auto x = dp(b); auto y = dp(a-1); vector<int> ans; for(int i = 0 ; i <= 9 ; i++) ans.push_back(x[i]-y[i]); return ans; } void print(vector<int> ans) { for(auto x:ans) printf(\\\"%d \\\",x); puts(\\\"\\\"); } bool check(int x) { auto t = ask(x,x); vector<int> cnt(10,0); while(x) cnt[x%10]++,x/=10; for(int i = 0 ; i <= 9 ; i++) if(cnt[i] != t[i]) return false; return true; } int main() { init(); int a,b; while(cin >> a >> b, a||b) { if(a>b) swap(a,b); auto t = ask(a,b); print(t); } return 0; }\"]},\"38\":{\"h\":\"6. 状态压缩类DP\"},\"39\":{\"h\":\"6. 1\",\"t\":[\"n×m 的棋盘可以摆放不同的 1×2 小方格的种类数。\",\"状态表示：f[i][j] 表示当前摆到第 i 列的状态是 j 的所有方案。\",\"(其中 j 是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。)\",\"去除无效状态的优化写法：\",\"#include <cstring> #include <iostream> #include <algorithm> #include <vector> using namespace std; typedef long long LL; const int N = 12, M = 1 << N; int n, m; LL f[N][M]; vector<int> state[M]; bool st[M]; int main() { while (cin >> n >> m, n || m) { for (int i = 0; i < 1 << n; i ++ ) { int cnt = 0; bool is_valid = true; for (int j = 0; j < n; j ++ ) if (i >> j & 1) { if (cnt & 1) { is_valid = false; break; } cnt = 0; } else cnt++; if (cnt & 1) is_valid = false; st[i] = is_valid; } for (int i = 0; i < 1 << n; i ++ ) { state[i].clear(); for (int j = 0; j < 1 << n; j ++ ) if ((i & j) == 0 && st[i | j]) state[i].push_back(j); } memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i <= m; i ++ ) for (int j = 0; j < 1 << n; j ++ ) for (auto k : state[j]) f[i][j] += f[i - 1][k]; cout << f[m][0] << endl; } return 0; }\"]},\"40\":{\"h\":\"6. 2 最短Hamilton路径\",\"t\":[\"给定一张 n 个点的带权无向图，点从 0 ~ n−1 标号，求起点 0 到终点 n−1 的最短Hamilton路径。\",\"Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。\",\"f[i][j] 表示从 0 走到 j ，走过的所有点的情况是 i 的所有路径。\",\"状态转移方程：f[i][j] = min(f[i][j], f[i-(1<<j)][k] + w[k][j]);\",\"#include<iostream> #include<cstring> #include<algorithm> using namespace std; const int N = 20, M = 1 << N; int n; int f[M][N], w[N][N];//w表示的是无权图 int main() { cin>>n; for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) cin >> w[i][j]; memset(f, 0x3f, sizeof(f)); // 因为要求最小值，所以初始化为无穷大 f[1][0] = 0; // 因为零是起点,所以f[1][0]=0; for (int i = 0; i < 1 << n; i++) // i表示所有的情况 for (int j = 0; j < n; j++) // j表示走到哪一个点 if (i >> j & 1) for (int k = 0; k < n; k++) // k表示走到j这个点之前,以k为终点的最短距离 if (i >> k & 1) // 更新最短距离 f[i][j] = min(f[i][j], f[i - (1<<j)][k] + w[k][j]); // 表示所有点都走过了,且终点是n-1的最短距离 cout << f[(1<<n) - 1][n - 1] << endl; return 0; }\"]},\"41\":{\"h\":\"7. 树形DP\"},\"42\":{\"h\":\"7. 1 没有上司的舞会\",\"t\":[\"选了某个节点就不能选父节点和子节点。求最大权值和。\",\"每个人只有两种状态，则设 dp[0][i] 为第 i 个人不来，他的下属所能获得的最大快乐值；\",\"dp[1][i] 为第 i 个人来，他的下属所能获得的最大快乐值。\",\"状态转移方程：\",\"dp[0][i]=∑u=sonsmax(dp[1][u],dp[0][u]) 当前节点不选，那么子节点随意\",\"dp[1][i]=∑u=sonsdp[0][u]+happy[i] 当前节点选，子节点不能选\",\"#include <bit/stdc++.h> using namespace std; int n; int dp[2][6010]; int f[2][6010]; // f[0]为父亲，f[1]为高兴值 int ind[6010]; // 入度 int vis[6010]; // 访问标记 int root; // 树的根 void dfs(int u) // 递归从后往前更新 { if (!u) return; vis[u] = 1; // 已访问 root = u; // 最后一个访问到的一定是根，所以一直更新根就行了 dp[0][f[0][u]] += max(dp[1][u] + f[1][u], dp[0][u]); // 给父亲更新 dp[1][f[0][u]] += dp[0][u]; ind[f[0][u]]--; // 更新完一个子节点 if(!ind[f[0][u]]) dfs(f[0][u]); // 在所有子节点更新后再更新（入度为0） } int main() { cin >> n; for (int i = 1; i <= n; i++) scanf(\\\"%d\\\", &f[1][i]); int a,b; for (int i = 1; i < n; i++){ scanf(\\\"%d%d\\\", &a, &b); f[0][a] = b; // 保存节点信息 ind[b]++; } for (int i = 1; i <= n; i++) if(!vis[i] && !ind[i]) // 没有被访问过，没有入度，说明是叶子节点 dfs(i); // 取根节点两种方案的最大值 printf(\\\"%d\\\\n\\\", max(dp[0][root], dp[1][root] + f[1][root])); return 0; }\"]},\"43\":{\"c\":[\"algorithm\"]},\"44\":{\"c\":[\"ACM\"]},\"45\":{\"h\":\"基础算法\"},\"46\":{\"h\":\"1. 快速排序\",\"t\":[\"快排属于分治算法，分治算法都有三步：\",\"分成子问题\",\"递归处理子问题\",\"子问题合并\",\"主要步骤：\",\"确定分界点，可以任选 a[l]，a[r]，a[(l + r) / 2] 其中一个作为分界点。\",\"设置两个头尾指针 i, j，初始化 i = l - 1, j = r + 1 (避免发生边界问题导致死循环) ，向中间移动。每次循环都先将 i 右移和 j 左移，然后判断，如果 a[i] > a[j] 且 i < j，就交换 a[i] 和 a[j].\",\"最后根据分界点分别递归左右两部分。\",\"快排的一般写法如下：\",\"void quick_sort(int q[], int l, int r) { //递归的终止情况 if(l >= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[(l + r) / 2]; while(i < j) { do i++; while(q[i] < x); do j--; while(q[j] > x); if(i < j) swap(q[i], q[j]); } //第二步：递归处理子问题 quick_sort(q, l, j); quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤 }\"]},\"47\":{\"h\":\"2. 归并排序\",\"t\":[\"运用双指针的思想，先递归再合并。\",\"主要步骤：\",\"确定分界点。与快排不同，归并每次都将中点作为分界点，将整个序列均分为两部分。mid = (l + r) / 2\",\"递归排序。对两个子序列分别设置个指针 i, j，从头开始遍历，每次比较 a[i] 和 a[j]，将小的放入一个临时序列 temp[] 中。如果有一部分遍历完了，而另一部分还有剩余，则将剩余那一部分直接接在临时序列的后面，因为剩下的这部分一定是大于前面的。\",\"归并，合二为一。将临时序列放入原序列中。\",\"归并的一般写法如下：\",\"void merge_sort(int a[], int l, int r) { if (l >= r) return; //确定中间分界点 int mid = (l + r) >> 1; //两边递归 merge_sort(a, l, mid); merge_sort(a, mid + 1, r); int k = 0; int i = l, j = mid + 1; //比较左右两半边 while (i <= mid && j <= r) if (a[i] < a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; while (i <= mid)//左半边剩下的 temp[k++] = a[i++]; while (j <= r)//右半边剩下的 temp[k++] = a[j++]; //合并区间 for (i = l, j = 0; i <= r; i++, j++) a[i] = temp[j]; }\"]},\"48\":{\"h\":\"3. 二分算法\"},\"49\":{\"h\":\"3.1 二分查找算法模板\",\"t\":[\"二分模板一共有两个，分别适用于不同情况。\",\"算法思路：假设目标值在闭区间 [l, r]中， 每次将区间长度缩小一半，当 l = r时，我们就找到了目标值。\"]},\"50\":{\"h\":\"版本1\",\"t\":[\"当我们将区间 [l, r]划分成 [l, mid] 和 [mid + 1, r] 时，其更新操作是 r = mid 或者 l = mid + 1; ，计算 mid 时不需要加 1。\",\"C++代码模板：\",\"int bsearch_1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (a[mid] >= x) r = mid; //答案在左边界，要向下取整 else l = mid + 1; //找左端点 } return l; }\"]},\"51\":{\"h\":\"版本2\",\"t\":[\"当我们将区间 [l, r] 划分成 [l, mid - 1] 和 [mid, r] 时，其更新操作是 r = mid - 1 或者 l = mid; ，此时为了防止死循环，计算 mid 时需要加 1。\",\"C++代码模板：\",\"int bsearch_2(int l, int r) { while (l < r) { int mid = l + r + 1 >> 1; if (a[mid] <= k) l = mid; //答案在右边界，要上取整 else r = mid - 1; //找右端点 } return l; }\",\"简单来说就是：\",\"可以将模板 1 中的 check[mid] 换成a[mid] >= x ，用来查找大于等于 x 的第一个元素；\",\"将模板 2 中的 check[mid] 换成 a[mid] <= x ，用来查找小于等于 x 的最后一个元素。\"]},\"52\":{\"h\":\"3.2 二分答案模板\",\"t\":[\"一般来说，二分答案可以用来处理 “最大的最小” 或 “最小的最大” 的问题。\",\"定义区间为闭区间 [l, r] ，每次只需判断答案是否需要更新（是否记下ans）和（可能的）答案在哪一侧（改 L 还是 R ）即可。\",\"int ans; int find(int l, int r) { while (l <= r) { int mid = l + r >> 1; if (check(mid)){ ans = mid; //如果条件成立则记下答案 r = mid - 1; //判断可能的答案更新区间 } else l = mid + 1; } return ans; }\"]},\"53\":{\"h\":\"3.3 整数二分\",\"t\":[\"【例二】A-B 数对\",\"题目描述：给出一串数以及一个数字 C ，要求计算出所有 A - B = C 的数对的个数（不同位置的数字一样的数对算不同的数对）。\",\"这里使用库函数二分的写法：\",\"依次枚举 A ，将问题转变成统计数列中 B + C 出现了多少次。先对数列排序，那么 B + C 会对应这个数列的连续一段，只要找到这个连续段的左端点和右端点即可。(需使用头文件 algorithm )\",\"① lower_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 第一次出现的位置；\",\"② upper_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 最后一次出现的位置的__后面一位__ 。\",\"则这个数出现的次数就可以表示为 upper_bound() - lower_bound() ，时间复杂度为 O(nlogn).\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; const int N = 2e5 + 10; int n, c; ll a[N]; int main() { cin >> n >> c; for (int i = 0; i < n; i++) cin >> a[i]; sort(a, a + n); ll tot = 0; for (int i = 0; i < n; i++) tot += upper_bound(a, a + n, a[i] + c) - lower_bound(a, a + n, a[i] + c); cout << tot << endl; return 0; }\"]},\"54\":{\"h\":\"3.4 浮点数二分\",\"t\":[\"bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l > eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; }\"]},\"55\":{\"h\":\"4. 高精度算法\"},\"56\":{\"h\":\"4.1 高精度加法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的和。 （C = A + B，A >= 0， B >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; const int N = 1e6 + 10; // C = A + B vector<int> add(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; int t = 0; //进位，低位满10向高位进位，低位变为0 for (int i = 0; i < A.size() || i < B.size(); i++){ //两个if把两个数组相同位上的数相加 if (i < A.size()) t += A[i]; if (i < B.size()) t += B[i]; //把相加后的结果除以10求余，压入C数组中 C.push_back(t % 10); //t再除以10，放入高位 t /= 10; } //如果最高位有数，则压入C数组中 if (t) C.push_back(t); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //使用auto编译器会自动判断数据是什么类型 auto C = add(A, B); for (int i = C.size() - 1; i >= 0; i--) printf(\\\"%d\\\", C[i]); return 0; }\"]},\"57\":{\"h\":\"4.2 高精度减法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的差，计算结果可能为负数。\",\"1、前提： C = A - B，满足 A >= B，A >= 0，B >= 0 （如果 B >= A，则将其转化为 -(B - A) ）\",\"2、代码段：(只考虑正数的情况)\",\"#include <iostream> #include <vector> using namespace std; //判断是否有 A >= B bool cmp(vector<int> &A, vector<int> &B) { //A长度不等于B，若A大于B，返回true，否则返回false if (A.size() != B.size()) return A.size() > B.size(); //因为是倒序数组，高位在后面，所以从后遍历 //如果A > B, 返回true，否则返回flase for (int i = A.size() - 1; i >= 0; i--){ if (A[i] != B[i]) return A[i] > B[i]; } return true; } // C = A - B vector<int> sub(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; //定义一个借位的情况 int t = 0; for (int i = 0; i < A.size(); i++){ //t = A的这一位数 t = A[i] - t; //判断B在这一位上有没有数，如果有，则减去B[i] if (i < B.size()) t -= B[i]; //这种写法包含了两种情况：如果t >= 0, 则直接减；若t < 0, 则向高位借位(即t + 10)后再减 //将这一位相减后的结果压入C中 C.push_back((t + 10) % 10); if (t < 0) //t < 0，需要借位，标记为1 t = 1; else //t >= 0，不需要借位，标记为0 t = 0; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //如果A > B，返回A - B if (cmp(A, B)){ auto C = sub(A, B); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", C[i]); } //否则返回 -(B - A) else { auto C = sub(B, A); printf(\\\"-\\\"); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", c[i]); } return 0; }\"]},\"58\":{\"h\":\"4.3 高精度整数乘法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A × B 的值\",\"一般是 高精 × 低精，用 A × b 表示 （C = A * b，A >= 0，b >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; //C = A * b vector<int> mul(vector<int> &A, int b) { vector<int> C; int t = 0; for (int i = 0; i < A.size() || t; i++) { if (i < A.size()) t += A[i] * b; //同加法一样处理进位，逐位压入数组中 C.push_back(t % 10); t /= 10; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int b; cin >> a >> b; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) //倒序插入 A.push_back(a[i] - '0'); auto C = mul(A, b); for (int i = C.size() - 1; i >= 0; i--) //倒序输出 printf(\\\"%d\\\", C[i]); return 0; }\"]},\"59\":{\"h\":\"4.4 高精度整数除法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A / B 的商和余数 (第一行输出所求的商，第二行输出所求余数)\",\"一般是 高精 ÷ 低精，用 A ÷ b 表示 （A / b = C ··· r，A >= 0，b > 0）\",\"代码如下：\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; vector<int> div(vector<int> &A, int b, int &t) //传入t的地址，便于直接对余数进行处理 { vector<int> C; t = 0; for (int i = A.size() - 1; i >= 0; i--) { //将上次的余数×10再加上当前位的数字，得到该位的被除数 t = t * 10 + A[i]; //所得即为商在这一位的数字 C.push_back(t / b); t %= b; } //由于在除法运算中，从高位到低位运算，因此前导0在数组前面，所以需要将其翻转，将前导0置于尾部，从而便于删除前导0 reverse(C.begin(), C.end()); //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int B; cin >> a >> B; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); int t; //t为余数 auto C = div(A, B, t); for (int i = C.size() - 1; i >= 0; i--) cout << C[i]; cout << endl << t << endl; return 0; }\"]},\"60\":{\"h\":\"5. 前缀和与差分\"},\"61\":{\"h\":\"5.1 一维前缀和\",\"t\":[\"S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1]\"]},\"62\":{\"h\":\"5.2 二维前缀和\",\"t\":[\"S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\"]},\"63\":{\"h\":\"5.3 一维差分\",\"t\":[\"给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\"]},\"64\":{\"h\":\"5.4 二维差分\",\"t\":[\"给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\"]},\"65\":{\"h\":\"6. 位运算\"},\"66\":{\"h\":\"6.1 位运算符\",\"t\":[\"位运算符作用于位，并逐位执行操作。\",\"符号\",\"描述\",\"运算规则\",\"&\",\"与\",\"两个位都为1时，结果才为1\",\"|\",\"或\",\"两个位都为0时，结果才为0\",\"^\",\"异或\",\"两个位相同为0，不同为1\",\"~\",\"取反\",\"0变1，1变0\",\"<<\",\"左移\",\"各二进位全部左移若干位，高位丢弃，低位补0\",\">>\",\"右移\",\"各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）\"]},\"67\":{\"h\":\"6.2 用途\",\"t\":[\"1、按位与 (&)\",\"运算规则（全为 1，才为1）\",\"0 & 0 = 0\",\"0 & 1 = 0\",\"1 & 0 = 0\",\"1 & 1 = 1\",\"注意：负数按补码形式参加按位与运算。\",\"（1）清零\",\"如果想将一个单元清零，使其全部二进制位为 0，只要__与一个各位都为零的数值相与__，结果为零。\",\"（2）取一个数的指定位\",\"比如取数 X = 1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位与运算（X & Y = 0000 1110）即可得到 X 的指定位。\",\"（3）判断奇偶\",\"只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a & 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。\",\"2、按位或 (|)\",\"运算规则（全为 0，才为 0）\",\"0 | 0 = 0\",\"0 | 1 = 1\",\"1 | 0 = 1\",\"1 | 1 = 1\",\"（1）常用来对一个数据的某些位设置为1\",\"比如将数 X = 1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位或运算（X | Y = 1010 1111）即可得到。\",\"3、按位异或 (^)\",\"运算规则（相同为 0，不同为 1）\",\"0 ^ 0 = 0\",\"0 ^ 1 = 1\",\"1 ^ 0 = 1\",\"1 ^ 1 = 0\",\"（1）翻转指定位\",\"比如将数 X = 1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行异或运算（X ^ Y = 1010 0001）即可得到。\",\"（2）与 0 相异或值不变\",\"例如：1010 1110 ^ 0000 0000 = 1010 1110\",\"（3）交换两个数\",\"当 x == y 时，直接异或运算进行整数交换后，会导致 x = 0, y = x.\",\"为避免这种情况，必须首先判断两个数是否相等。\",\"void swap(int &a, int &b){ if (a != b){ a ^= b; b ^= a; a ^= b; } }\",\"4、按位取反 (~)\",\"运算规则（0 变 1，1 变 0）\",\"~1 = 0\",\"~0 = 1\",\"（1）使一个数的最低位为 0\",\"使 x 的最低位为 0，可以表示为：a & ~1 。~1 的值为 1111 1111 1111 1110 ，再按 与 运算，最低位一定为 0。因为 ~ 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。\",\"5、左移 (<<)\",\"定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\",\"设 a = 1010 1110，a = a << 2 将 a 的二进制位 左移2位、右补0，即得 a = 1011 1000。\",\"若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2 。比如 左移 k 位，即乘上 2k .\",\"6、右移 (>>)\",\"定义：将一个数的各二进制位全部右移若干位，正数左补 0 ，负数左补 1 ，右边丢弃。\",\"例如：a = a >> 2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。\",\"操作数每右移一位，相当于该数除以 2。比如 右移 k 位，即除以 2k .\",\"bit_operation\"]},\"68\":{\"h\":\"6.3 例题\",\"t\":[\"【例题一】n 的二进制表示中第 k 位数\",\"思路：先把第 k 位数字移动到最后一位，n 右移 k 位，即 n >> k ，再看个位是几，用 n & 1 ，合并两步后，即 n >> k & 1 .\",\"例如求 10 的二进制表示，代码如下：\",\"#include <iostream> using namespace std; int main() { int n = 10; //10的二进制表示为4位数 for (int k = 3; k >= 0; k--) cout << (n >> k & 1); return 0; }\",\"输出如下：\",\"1010\",\"【例题二】二进制中1的个数\",\"给定一个长度为 1 的数列，请你求出数列中每个数的二进制表示中 1 的个数。\",\"输入格式\",\"第一行包含整数 n .\",\"第二行包含 n 个整数，表示整个数列\",\"输出格式\",\"共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。\",\"思路：使用 lowbit(x) 来解决，其表达式为 x & -x ，其中 -x 表示补码，即源码取反加 1 ，-x = (~x + 1)。 作用：返回 x 的最后一位 1，比如 x = 1010, 则 lowbit(x) = 10 ，x = 101000, 则 lowbit(x) = 1000 .\",\"代码如下：\",\"#include <iostream> using namespace std; const int N = 100010; int lowbit(int x) { return x & -x; } int main() { int n; cin >> n; while (n--){ int x; cin >> x; int res = 0; while (x){ x -= lowbit(x); res++; } cout << res << \\\" \\\"; } return 0; }\"]},\"69\":{\"h\":\"7. 双指针算法\",\"t\":[\"for (int i = 0, j = 0; i < n; i++) { while (j < i && check(i, j)) j++; // 具体问题的逻辑 // 例如求长度 res = max(res, i - j + 1); } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\"]},\"70\":{\"h\":\"8. 离散化\",\"t\":[\"vector<int> alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l < r) { int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n }\"]},\"71\":{\"h\":\"9. 区间合并\",\"t\":[\"// 将所有存在交集的区间合并 void merge(vector<PII> &segs) { vector<PII> res; sort(segs.begin(), segs.end()); int L = -2e9, R = -2e9; for (auto seg : segs) if (R < seg.first) { if (st != -2e9) res.push_back({L, R}); L = seg.first, R = seg.second; } else R = max(R, seg.second); if (L != -2e9) res.push_back({L, R}); segs = res; }\"]},\"72\":{\"c\":[\"algorithm\"]},\"73\":{\"c\":[\"ACM\"]},\"74\":{\"h\":\"搜索与图论\"},\"75\":{\"h\":\"1. 树与图的存储\",\"t\":[\"(1) 邻接矩阵：g [a] [b] 存储边 a -> b\",\"(2) 动态邻接矩阵：\",\"int n; struct Edge { int id, w; }; vector<Edge> h[N]; int dist[N]; void dfs(int u, int father, int distance) { dist[u] = distance; for (auto node : h[u]) if (node.id != father) dfs(node.id, u, distance + node.w); } int main() { scanf(\\\"%d\\\", &n); for (int i = 0; i < n - 1; i ++ ) { int a, b, c; scanf(\\\"%d%d%d\\\", &a, &b, &c); h[a].push_back({b, c}); h[b].push_back({a, c}); } dfs(1, -1, 0); // 寻找两点之间的最大距离 int u = 1; for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; dfs(u, -1, 0); for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; int s = dist[u]; printf(\\\"%lld\\\\n\\\", s * 10 + s * (s + 1ll) / 2); return 0; }\",\"(3) 邻接表：\",\"int n, m; //n代表点数，m代表边数 // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a->b void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } // 初始化 idx = 0; memset(h, -1, sizeof h); //存边 for (int i = 0; i < n; i++){ int a, b; cin >> a >> b; add(a, b); //无向图就再写一遍 add(b, a) }\"]},\"76\":{\"h\":\"2. 树与图的遍历\",\"t\":[\"时间复杂度 O(n + m), n 表示点数， m 表示边数\"]},\"77\":{\"h\":\"深度优先遍历\",\"t\":[\"int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } }\"]},\"78\":{\"h\":\"宽度优先遍历\",\"t\":[\"queue<int> q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } }\"]},\"79\":{\"h\":\"3. 拓扑排序\",\"t\":[\"时间复杂度 O(n+m), n 表示点数，m 表示边数\",\"1、图的拓扑序列是针对于有向图而言的，无向图是没有拓扑序列的。有向无环图被称为拓扑图。\",\"2、结论：一个有向无环图，一定至少存在一个入度为 0 的点。\",\"bool topsort() { //采用数组模拟队列的写法，头尾指针 int hh = 0, tt = -1; // d[i] 存储点i的入度，起点的入度为0 for (int i = 1; i <= n; i++) if (!d[i]) //如果不是起点 q[++tt] = i; while (hh <= tt) { int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (--d[j] == 0) q[++tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; }\"]},\"80\":{\"h\":\"4. 最短路问题\"},\"81\":{\"h\":\"4.1 单源最短路\",\"t\":[\"求从一个点到其他所有点的最短距离。\",\"分为两大类：\",\"1、所有边权都是正数（n 个点，m 条边）\",\"朴素版的Dijkstra算法，时间复杂度为 O(n2 + m) ，适合稠密图（边多，点少边比较多）\",\"堆优化版的Dijkstra算法，时间复杂度为 O(mlogn)，适合稀疏图（点多，指边相对于点不多，m 和 n 是同一个级别的类型）\",\"2、存在负权边\",\"Bellman-Ford 算法，时间复杂度为 O(nm)\",\"SPFA 算法，时间复杂度一般为 O(m)，最坏情况为 O(nm)，是Bellman-Ford算法的优化\"]},\"82\":{\"h\":\"4.1.1 朴素版 Dijkstra算法\",\"t\":[\"稠密图用邻接矩阵，稀疏图用邻接表\",\"1.逐个遍历，找到与起点最近的且未确定最短路径的点，访问加入集合并标记。\",\"2.更新第一个点到起点的最短距离，直到第n个点。\",\"__时间复杂度是 O(n2 + m)， n 表示点数，m 表示边数 __\",\"#include <iostream> #include <cstring> #include <algortihm> using namespace std; const int N = 510; int n, m; //点数和边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { //距离都初始化为无穷大 memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i < n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 //遍历n个点，找到一个未加入集合且距离最近的点 for (int j = 1; j <= n; j ++ ) if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; st[t] = true; //标记为已加入到集合中 // 用t更新其他点的距离 for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); } //如果为无穷大，说明不连通，无法形成最短路 if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { cin >> n >> m; //邻接矩阵初始化为无穷大 memset(g, 0x3f, sizeof(g)); while (m--){ int a, b, c; cin >> a >> b >> c; //存入a和b两点之间的距离（有向图） g[a][b] = min(g[a][b], c); //无向图 //g[a][b] = min(g[a][b], c); //g[b][a] = min(a[a][b], c); } cout << dijkstra() << endl; return 0; }\"]},\"83\":{\"h\":\"4.1.2 堆优化版的Dijkstra算法\",\"t\":[\"稀疏图改用__邻接表__的形式存储，可以不需要考虑重边\",\"时间复杂度是 O(mlogn)， n 表示点数，m 表示边数\",\"#define PII pair<int, int> int n; //点的数量 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //存储所有点到1号点的距离 bool st[N]; //存储每个点的最短距离是否已确定 void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; //定义一个小根堆 priority_queue<PII, vector<PII>, greater<PII>> heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"84\":{\"h\":\"4.1.3 Bellman-ford算法（存在负权边）\",\"t\":[\"1.可以用结构体存储点和边，包括负权边。\",\"2.具体步骤：两重 for 循环，迭代 n-1 次，每次备份一下，每次循环遍历所有边，更新两点之间的最短距离，如点 a->b 的更新方式为（松弛操作）\",\"for n 次 for 所有边 a, b, w (松弛操作) dist[b] = min(dist[b], backup[a] + w);\",\"backup[ ] 数组是上一次迭代后 dist[ ] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[ ] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点。\",\"3.循环 n-1 次之后，对于所有的点都 一定满足 dist[b] <= dist[a] + w，该式被称为三角不等式。\",\"4.如果图中存在负权回路，那么最短路可能为负无穷。（不是一定）\",\"5.是否能到达 n 号点的判断中需要进行 if(dist[n] > INF/2) 判断，而并非是 if(dist[n] == INF) 判断，原因是 INF 是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，``dist[n]大于某个与INF` 相同数量级的数即可。\",\"6.bellman-ford算法擅长解决有边数限制的最短路问题。\",\"时间复杂度 O(nm)， n 表示点数，m 表示边数\",\"int n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i < n; i ++ ) { for (int j = 0; j < m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] > dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] > 0x3f3f3f3f / 2) return -1; return dist[n]; }\"]},\"85\":{\"h\":\"4.1.4 SPFA算法 （存在负权边）\",\"t\":[\"1.用队列来存储\",\"2.while queue 不为空，\",\"取出作为 t ，t = q.front; q.pop();\",\"更新 t 的所有出边，如：t -> b, 把b加入 queue\",\"3.基本步骤\",\"建立一个队列，初始时队列里只有起始点\",\"再建立一个数组记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到它本身的路径赋为0）\",\"再建立一个数组，标记点是否在队列中\",\"队头不断出队，计算起始点经过队头到其他点的距离是否变短，如果变短且该点不在队列中，则把该点加入到队尾\",\"重复执行直到队列为空\",\"在保存最短路径的数组中，就得到了最短路径\",\"4.SPFA求最短路\",\"时间复杂度 平均情况下 O(m)， 最坏情况下 O(nm)， n 表示点数， m 表示边数\",\"int n, m; // 总点数和总边数 int h[N], e[M], w[M], ne[M], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 int add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue<int> q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"86\":{\"h\":\"4.1.5 SPFA算法判断图中是否存在负环\",\"t\":[\"时间复杂度 O(nm)， n 表示点数， m 表示边数\",\"int n; //总点数 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //dist[x]存储1号点到x的最短距离， int cnt[N]; //cnt[x]存储1到x的最短路中经过的点数 bool st[N]; //存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue<int> q; for (int i = 1; i <= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (cnt[j] >= n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; }\"]},\"87\":{\"h\":\"4.2 多源汇最短路\"},\"88\":{\"h\":\"4.2.1 Floyd算法\",\"t\":[\"1.使用邻接矩阵存图\",\"2.三重循环，时间复杂度O(n^3)\",\"初始化： for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (i == j) d[i][j] = 0; else d[i][j] = INF; //算法结束后，d[a][b]表示a到b的距离 for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\"]},\"89\":{\"h\":\"5. 最小生成树问题\",\"t\":[\"最小生成树就是将 n 个顶点， n - 1 条边，通过一个连接起来，且使权值最小的一种结构。\",\"换句话来说，就是给定一个无向图，在图中选择若干条边把图中的所有节点连接起来，要求边长之和最小。在图论中，叫做求最小生成树。\"]},\"90\":{\"h\":\"5.1 朴素Prim算法\",\"t\":[\"可理解为 “加点法”， 每次迭代找到不在连通块中的距离最近的点，加入到连通块中，将连通块逐渐扩大，最后将整个图连通起来，并且边长之和最小。\",\"1、先把所有距离初始化为正无穷\",\"dist[i] = +INF;\",\"2、n次迭代，找到不在集合当中的最小的点，这个集合指当前已经在连通块中的所有点，找到该点赋给 t ，用 t 更新其他点到集合的距离，再把 t 加到集合当中去\",\"先累加，再更新\",\"for (int i = 0; i < n; i++) t <- 距离最近的点; t = ture;更新t\",\"时间复杂度为 O(n2 + m)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> #define ll long long using namespace std; const int N = 1e5 + 10, M = N * 2; int n, m; // n表示点数，m表示边数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; //最小生成树所有边的长度之和 for (int i = 0; i < n; i++) { int t = -1; for (int j = 1; j <= n; j++) //如果没有在树中，且到树的距离最短，则选择该点 if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; //一定要先累加，再进行更新生成树 if (i && dist[t] == INF) return INF; if (i) //(不是起点)把找到的符合条件的点的长度加上 res += dist[t]; st[t] = true; for (int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { cin >> n >> m; memset(g, 0x3f, sizeof g); for (int i = 1; i <= m; i++){ int a, b, c; cin >> a >> b >> c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(\\\"impossible\\\"); else printf(\\\"%d\\\\n\\\", t); }\"]},\"91\":{\"h\":\"5.2 Kruskal 算法\",\"t\":[\"可理解为 “加边法”，最初最小生成树的边数为 0，每次迭代选择一条不在集合内的权值最短的边，加入到集合中，组成最小生成树。\",\"1、使用快排将所有边按权值从小到大排序。时间复杂度为 O(log n).\",\"2、从小到大依次枚举每组边 a 、b，权重 c ，如果 a、b不连通，就将这条边加入集合中，直到具有 n 个顶点的连通块筛选出来 n-1 条边为止。时间复杂度为 O(n) .\",\"3、判断 a、b是否连通的方法为：使用并查集。\",\"初始化各个顶点在不同的集合中，父节点为它自己。\",\"按快排的从小到大的顺序遍历每条边，判断这条边的两个顶点是否有相同的父节点，如果有那就使在同一个集合中。\",\"如果该条边上的两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则加入这条边到集合中，连通这两个顶点。\",\"时间复杂度是 O(mlogm)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> using namespace std; const int N = 2e5 + 10; int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 int rank[N]; // 树的高度 //结构体存储 两点及其权值 struct Edge { int a, b, w; //重载小于号，因为再给边排序的时候是按照边的权重进行排序的，这样当两个边进行比较的时候就会使用他们的权重进行比较了 bool operator< (const Edge &W)const { return w < W.w; } }edges[M]; void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int x, int y) { int px = find(x), py = find(y); if (px == py) return; if (rank[px] < rank[py]){ p[px] = py; } else { p[py] = px; if (rank[px] == rank[py]) rank[px]++; } } int kruskal() { sort(edges, edges + m); init(n); int res = 0; //存的是最小生成树的所有边的权值 int cnt = 0; //存的是当前加入的边数 for (int i = 0; i < m; i++) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; pa = find(a), pb = find(b); if (pa != pb) // 如果两个连通块不连通，则将这两个连通块合并 { union(a, b); res += w; cnt++; } } //只有当 cnt == n - 1 时才能表示已经将所有点加入到集合中，可以生成最小生成树 if (cnt < n - 1) return INF; return res; }\"]},\"92\":{\"h\":\"6. 染色法判别二分图\",\"t\":[\"二分图： 将所有点分成__两个集合__，使得__所有边__只出现在集合之间，就是 二分图\",\"性质： 一定不含有奇数环，可能包含长度为偶数的环，不一定是__连通图__。\",\"DFS思路：\",\"染色可以使用 1 和 2 区分__不同颜色__，用 0 表示 未染色\",\"遍历所有点，每次将__未染色的点__进行 dfs，默认染成 1 或 2\",\"由于某个点染色成功并不代表整个图就是二分图，因此只有某个点染色失败才能立刻 break/return，__染色失败__相当于存在两个相邻的点染成了相同的颜色\",\"时间复杂度 O(n + m)， n 表示点数，m 表示边数\",\"int n, m; //n表示点数，m表示边数 int h[N], e[M], ne[M], idx; //邻接表存储图 int color[N]; //表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 //参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i <= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; }\"]},\"93\":{\"h\":\"7. 匈牙利算法\",\"t\":[\"相关概念：\",\"匹配：在图论中，一个 [匹配] 是一个边的集合，其中任意两条边都不依附于同一个顶点。\",\"最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。\",\"完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。\",\"交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边...形成的路径叫交替路。\",\"增广路：从一个未匹配路出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。\",\"算法描述：\",\"如果你想找的妹子已经有了男朋友，\",\"你就去问问她男朋友，\",\"你有没有备胎，\",\"把这个让给我好吧\",\"多么真实而实用的算法\",\"tips：因为你要去问的都是男孩子，所以存边的时候，都是由男孩子指向女孩子\",\"时间复杂度是 O(nm)， n 表示点数，m 表示边数\",\"int n1, n2; //n1表示第一个集合中的点数，n2表示第二个集合中的点数 // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int h[N], e[M], ne[M], idx; int match[N]; //存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; //表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { //遍历所有点 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) //如果在这一轮的匹配中，这个点还未被匹配 { st[j] = true; //那就匹配并标记 //如果这个点未被匹配，且原来匹配的点能找到另一个点(下家)匹配，则匹配成功 if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i <= n1; i ++ ) { //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化 memset(st, false, sizeof st); if (find(i)) res++; }\"]},\"94\":{\"c\":[\"algorithm\"]},\"95\":{\"c\":[\"ACM\"]},\"96\":{\"h\":\"数学知识\"},\"97\":{\"h\":\"1. 质数\"},\"98\":{\"h\":\"1.1 试除法判定质数\",\"t\":[\"从小到大遍历，只判断能否被小于 sqrt(x) 的数整除。\",\"时间复杂度为 O(sqrt(n)).\",\"bool is_prime(int x) { if (x < 2) return false; for (int i = 2; i <= x / i; i++) if (x % i == 0) return false; return true; }\"]},\"99\":{\"h\":\"1.2 试除法分解质因数\",\"t\":[\"从小到大尝试 n 的所有因数，每个正整数都能够以唯一的方式表示成它的质因数的乘积。\",\"结论：n 中最多只包含一个大于 sqrt(n) 的因子。\",\"反证法证明：如果有两个大于 sqrt(n) 的因子，那么相乘会大于 n。于是我们发现只有一个大于 sqrt(n) 的因子，可以对其进行优化。如果最后 n 还是 >1，说明这就是大于 sqrt(n) 的唯一质因子，输出即可。\",\"时间复杂度为 O(log n) ~ O(sqrt(n)).\",\"void divide(int x) { for (int i = 2; i <= x / i; i++) if (x % i == 0) { int s = 0; //s表示次幂 while (x % i == 0) { x /= i; s++; } cout << i << ' ' << s << endl; //输出i的s次幂 } if (x > 1) cout << x << ' ' << 1 << endl; cout << endl; }\"]},\"100\":{\"h\":\"汇总\",\"t\":[\"// 假设输入都是正数 // 素数测试 O(√n) bool is_prime(int n) { for (int i = 2; i <= n / i; i++){ if (n % i == 0) return false; } return n != 1; } // 约数枚举 O(√n) vector<int> divisor(int n) { vector<int> res; for (int i = 1; i <= n / i; i++){ if (n % i == 0){ res.push_back(i); if (i != n / i) res.push_back(n / i); } } return res; } // 整数分解 O(√n) map<int, int> prime_factor(int n) { map<int, int> res; for (int i = 2; i <= n / i; i++){ while (n % i == 0){ ++res[i]; n /= i; } } if (n != 1) res[n] = 1; return res; }\"]},\"101\":{\"h\":\"1.3 筛法求素数\"},\"102\":{\"h\":\"1.3.1 朴素筛法（埃氏筛）\",\"t\":[\"从 2 到 n 枚举，（一个数的倍数一定是合数）筛掉它的倍数，如果该数没有被筛掉，那它就是一个质数。\",\"（1）调和级数：当 n 趋于无穷大时，1 + 1/2 + 1/3 + … + 1/n = ln n + C.\",\"（2）对朴素筛法的优化：任何一个合数都能写成几个质数相乘的形式。只需要判断 2 ~ n-1 中的所有质数，只要它不是 n 的约数，那么 n 就是一个质因数。\",\"（3）质数定理：1~n 当中有 n/ln n 个质数。\",\"（4）思路：从小到大枚举所有的质数，然后删去它们的所有的倍数，就删去了所有的合数，剩下的就是质数。\",\"时间复杂度为 O(n ln ln n).\",\"int primes[N], cnt; // primes[]存储所有素数，cnt记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (st[i]) continue; primes[cnt++] = i; for (int j = i; j <= n; j += i) //用质数把其所有的倍数都筛掉 st[j] = true; } }\"]},\"103\":{\"h\":\"1.3.2 区间筛法\",\"t\":[\"给定整数 a 和 b ，问区间 [a,b) 内有多少个素数。\",\"解法：\",\"因为 b 以内的合数的最小质因数一定不超过 b​ ，如果有 b​ 以内的素数表的话，就可以把埃氏筛法运用在 [a,b) 上了。\",\"所以先预处理好 [a,b​) 和 [a,b) 的素数表，然后从 [a,b​) 的表中筛得素数的同时，也将其倍数从 [a,b) 的表中划去，最后剩下的就是区间 [a,b) 内的素数了。\",\"#define ll long long bool is_primes[N]; bool is_primes2[N]; void get_prime(ll a, ll b) { for (int i = 0; (ll)i * i < b; i++) is_primes2[i] = true; for (int i = 0; i < b - a; i++) is_prime[i] = true; // is_primes[i - a] = true => i是素数 for (int i = 2; (ll)i * i < b; i++){ if (is_primes2[i]){ for (int j = 2 * i; (ll)j * j < b; j += i) is_primes2[j] = true; for (ll j = max(2LL, (a + i - 1) / i; j < b; j += i) is_primes[j - a] = false; } } }\"]},\"104\":{\"h\":\"1.3.3 线性筛（欧拉筛）\",\"t\":[\"核心思路：用最小质因子去筛合数。\",\"当 i % primes[j] != 0 时， 说明此时遍历到的 primes[j] 不是 i 的质因子，只可能是此时 primes[j] 的最小质因子， 所以 primes[j] * i 的最小质因子就是 primes[j].\",\"当有 i % primes[j] == 0 时， 因为我们是从小到大遍历的，说明此时的 prime[j] 是满足条件的第一个数，即找到了 primes[j] 就是 i 的最小质因子， 因此 primes[j] * i 的最小质因子也就是 primes[j]， 之后用 st[primes[j + 1] * i] = true 去筛合数时，就不是用最小质因子去更新了， 所以此时应该退出循环，避免重复筛选。\",\"时间复杂度为 O(k)\",\"int primes[N]; // primes[]存储所有素数 int cnt; //记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] <= n / i; j++) { //标记，pj一定是pj*i的最小质因子 st[primes[j] * i] = true; //从小到大遍历，如果 i%pj=0，则pj一定是i的最小公因子 if (i % primes[j] == 0) break; } } }\"]},\"105\":{\"h\":\"2. 约数\"},\"106\":{\"h\":\"2.1 试除法求所有约数\",\"t\":[\"从小到大判断，如果当前数能整除目标数，说明这个数是它的一个约数。\",\"vector<int> get_divisors(int x) { vector<int> res; //从小到大枚举n的所有约数对里面比较小的那一个 for (int i = 1; i <= x / i; i++) if (x % i == 0) { res.push_back(i); //特判最中间的数 if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; }\"]},\"107\":{\"h\":\"2.2 约数个数和约数之和\",\"t\":[\"如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\",\"约数之和\",\"#include <iostream> #include <algorithm> #include <unordered_map> #include <vector> using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin >> n; unordered_map<int, int> primes; while (n -- ) { int x; cin >> x; for (int i = 2; i <= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x > 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; } cout << res << endl; return 0; }\"]},\"108\":{\"h\":\"2.3 最大公约数与最小公倍数\",\"t\":[\"欧几里得算法（辗转相除法)：\",\"每次都让较大的数对较小数取模，可以缩小问题规模而保持最大公约数不变，然后重复(递归)这个步骤。递归边界使某数变成了0，而此时另一个数即为所求答案.\",\"最坏情况下的时间复杂度为 O(log max(x, y))。\",\"对于大多数情况，辗转相除法时间可以忽略不计。\",\"int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\",\"用两数之积除以他们的最大公约数可得最小公倍数：\",\"int lcm(int a, int b) { return a * gcd(a, b) / b; //注意乘除的先后顺序，防止溢出 }\"]},\"109\":{\"h\":\"3. 欧拉函数\"},\"110\":{\"h\":\"3.1 求欧拉函数\",\"t\":[\"欧拉函数的定义\",\"1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)。 若在算数基本定理中，N=p1a1​​p2a2​​...pmam​​ ，则： ϕ(N)=N×p1​p1​−1​×p2​p2​−1​×…×pm​pm​−1​\",\"//求x的欧拉函数 int phi(int x) { int res = x; for (int i = 2; i <= x / i; i++) //分解质因数 if (x % i == 0) { res = res / i * (i - 1); //用上面的公式定义求，先整除再乘 while (x % i == 0) x /= i; } if (x > 1) res = res / x * (x - 1); return res; }\"]},\"111\":{\"h\":\"3.2 筛法求欧拉函数\",\"t\":[\"思路：质数 i 的欧拉函数即为 phi[i] = i - 1：1 ~ i−1均与 i 互质，共 i−1个。 phi[primes[j] * i] 分为两种情况： ① i % primes[j] == 0 时：primes[j] 是 i 的最小质因子，也是 primes[j] * i 的最小质因子，因此 1 - 1 / primes[j] 这一项在 phi[i] 中计算过了，只需将基数 N 修正为 primes[j] 倍，最终结果为 phi[i] * primes[j] 。 ② i % primes[j] != 0：primes[j] 不是 i 的质因子，只是 primes[j] * i 的最小质因子，因此不仅需要将基数 N 修正为 primes[j] 倍，还需要补上 1 - 1 / primes[j] 这一项，因此最终结果 phi[i] * (primes[j] - 1) 。\",\"int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i <= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] <= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } }\"]},\"112\":{\"h\":\"4. 快速幂\",\"t\":[\"基本思路：\",\"预处理出 a20,a21,a22,...,a2logk 这 k 个数\",\"将 ab 用 a20,a21,a22,...,a2logk 这 k 个数来组合，即组合成 ab=a2x1​×a2x2​×...×a2xt​=a2x1​+2x2​+...+2xt​​\",\"即用二进制来表示\",\"k&1 就是判断 k 的二进制表示中第 0 位上的数是否为 1，若为 1，则为 true，反之为 false.\",\"k&1 也可以用来判断奇数和偶数，b&1 = true 时为奇数，b&1 = false 时为偶数。\",\"求 ak mod p， 时间复杂度为 O(logk)\",\"int qmi(int a, int k, int p) { int res = 1 % p; while (k) { if (k&1) res = res * a % p; k >>= 1; a = a * a % p; } return res; }\"]},\"113\":{\"h\":\"5. 扩展欧几里得算法\"},\"114\":{\"h\":\"裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\",\"用于求解方程 ax+by=gcd(a,b)​ 的解\",\"当 b=0 时，ax+by=a 所以有 x=1,y=0\",\"当 b=0 时 ，因为 $gcd(a, b) = gcd(b, a % b) $\",\"​ 所以 x=y′,y=x′−[a/b]∗y′\",\"求整数 x 和 y 使得 ax+by=1\",\"如果 gcd(a,b)=1，显然无解。反之，若 gcd(a,b)=1 ，则可以通过扩展欧几里得来求解。\",\"事实上，一定存在整数对 (x,y) 使得 ax+by=gcd(a,b) .\",\"// 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; }\"]},\"115\":{\"h\":\"6. 中国剩余定理\",\"t\":[\"给定 2n 个整数 a1​,a2​,...,an​ 和 m1​,m2​,...,mn​ ，求一个最小的非负整数 x ，满足 ∀i∈[1,n],x≡mi​(modai​) .\",\"输入格式\",\"第 1 行包含整数 n。\",\"第 2...n+1 行：每 i+1 行包含两个整数 ai​ 和 mi​ ，数之间用空格隔开。\",\"输出格式\",\"输出最小非负整数 x ，如果 x 不存在，则输出 -1.\",\"如果存在 x ，则数据保证 x 一定在 64 位整数范围内。\",\"思路\",\"对于每两个式子，将其等价转换\",\"用扩展欧几里得算法找出一组解\",\"并且判断是否有解\",\"找到最小整数解\",\"等效替代\",\"相当于是每次考虑合并两个式子，将这 n 个式子合并 n - 1 次后变为一个式子。最后剩下的式子就满足我们的答案。\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; //扩展欧几里得 ll exgcd(ll a, ll b, ll &x, ll &y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } //可能为负数，取模加模再取模 ll inline mod(ll a, ll b) { return ((a % b) + b) % b; } int main() { ll n; scanf(\\\"%lld\\\", &n); ll a1, m1; scanf(\\\"%lld%lld\\\", &a1, &m1); for (ll i = 1; i < n; i++) { ll a2, m2, k1, k2; scanf(\\\"%lld%lld\\\", &a2, &m2); ll d = exgcd(a1, -a2, k1, k2); if ((m2 - m1) % d) { puts(\\\"-1\\\"); return 0; } k1 = k1 * (m2 - m1) / d; k1 = mod(k1, abs(a2 / d)); m1 = m1 + k1 * a1; a1 = abs(a1 / d * a2); } printf(\\\"%lld\\\\n\\\", m1); return 0; }\"]},\"116\":{\"h\":\"7. 高斯消元\",\"t\":[\"给定一个包含 n 个方程 n 个未知数的线性方程组。方程组中的系数为实数。\",\"要求求解这个方程组。\",\"（线性代数方法解非齐次线性方程组）\",\"前置知识：初等行（列）变换\",\"把某一行乘一个非00的数 (方程的两边同时乘上一个非00数不改变方程的解)\",\"交换某两行 (交换两个方程的位置)\",\"把某行的若干倍加到另一行上去 （把一个方程的若干倍加到另一个方程上去）\",\"高斯消元适用解法\",\"通过初等行变换把 增广矩阵 化为 阶梯型矩阵 并回代得到方程的解\",\"适用于求解包含 n 个方程，n 个未知数的多元线性方程组\",\"算法步骤\",\"枚举每一列c,\",\"找到当前列绝对值最大的一行\",\"用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）\",\"用初等行变换(1) 将该行的第一个数变成 11 （其余所有的数字依次跟着变化）\",\"用初等行变换(3) 将下面所有行的当且列的值变成 0\",\"时间复杂度为 O(n^3)\",\"const int eps = 1e-6; //控制精度，小于eps视为0 int a[N][N]; // a[N][N]是增广矩阵 int gauss() { int r, c; //行row,列col for (r = 0, c = 0; c < n; c ++ ) { int t = r; // 找到绝对值最大的行 for (int i = r; i < n; i ++ ) if (abs(a[i][c]) > abs(a[t][c])) t = i; if (abs(a[t][c]) < eps) continue; // 将绝对值最大的行换到最顶端 for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); // 将当前行的首位变成1 for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; // 用当前行将下面所有的列消成0 for (int i = r + 1; i < n; i ++ ) if (fabs(a[i][c]) > eps) for (int j = n; j >= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r < n) { for (int i = r; i < n; i ++ ) if (fabs(a[i][n]) > eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i >= 0; i -- ) for (int j = i + 1; j < n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 }\"]},\"117\":{\"h\":\"8. 求组合数\"},\"118\":{\"h\":\"8.1 递推法求组合数\",\"t\":[\"适用题型：\",\"给定两个正整数 a 与 b ，求 Cab​mod(1e9+7)\",\"递推式：\",\"Cab​=Ca−1b−1​+Ca−1b​\",\"// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i < N; i++) for (int j = 0; j <= i; j++) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\"]},\"119\":{\"h\":\"8.2 通过预处理逆元的方式求组和数\",\"t\":[\"用 infact(a!) 表示 a! 的逆元\",\"Cab​=b!∗(a−b)!a!​=a!∗infact(b!)∗infact((a−b)!)\",\"快速幂求逆元\",\"费马小定理：如果 p 是一个质数，而整数 a 不是 p 的倍数，则有 ap−1≡1(modp) .\",\"乘法逆元的定义\",\"若整数 b, m 互质，并且对于任意的整数 a，如果满足 b | a，则存在一个整数 x，使得 a / b ≡ a * x (mod m) ，则称 x 为 b 的模 m 乘法逆元，记为 b−1(modm) .\",\"b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，bm−2 即为 b 的乘法逆元。\",\"结论：当 b 与 m 互质时，b 的乘法逆元为 bm−2.\",\"​ 当 b 为 m 的倍数时，b 的逆元不存在。b∗x%m==0 ，b 乘任意一个 x % m 一定等于 0.\",\"首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i < N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; }\"]},\"120\":{\"h\":\"8.3 卢卡斯(Lucas)定理求组合数\",\"t\":[\"给定 n 组询问，每组询问给定三个整数 a,b,p，其中 p 是质数，请你输出 Cab​modp 的值。\",\"Lucas 定理：Cab​≡Ca%pb%p​∗Cpa​pb​​(modp)\",\"Cba​=(a−b!)∗b!a!​=(a−b)∗(a−b−1)∗…∗1∗b!a∗(a−1)∗(a−2)∗…∗(a−b+1)∗(a−b)∗…∗1​=b!a∗(a−1)∗(a−2)∗…(a−b+1)​\",\"因此可以递推的每次乘 a 然后 除以 b ，因为从 a 到 a - b + 1，所以是乘 b 次。\",\"若p是质数，则对于任意整数 1 <= m <= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k, int p) // 快速幂模板 { int res = 1 % p; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a < b) return 0; LL x = 1, y = 1; // x是分子，y是分母 for (int i = a, j = 1; j <= b; i --, j ++ ) { x = (LL)x * i % p; y = (LL)y * j % p; } return x * (LL)qmi(y, p - 2, p) % p; } int lucas(LL a, LL b, int p) { if (a < p && b < p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } int main() { int n; cin >> n; while (n--) { ll a, b, p; cin >> a >> b >> p; cout << lucas(a, b, p) << endl; } return 0; }\"]},\"121\":{\"h\":\"8.4 分解质因数法求组合数\",\"t\":[\"输入 a, b，求 Cab​ 的值。\",\"方法：对阶乘分解质因数之后，用高精度相乘即可。\",\"步骤：\",\"筛素数\",\"求每个质数的次数\",\"用高精度乘法把所有质因子乘上\",\"当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i <= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] <= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n!中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector<int> mul(vector<int> a, int b) // 高精度乘低精度模板 { vector<int> c; int t = 0; for (int i = 0; i < a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i < cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector<int> res; res.push_back(1); for (int i = 0; i < cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j < sum[i]; j ++ ) res = mul(res, primes[i]);\"]},\"122\":{\"h\":\"8.5 卡特兰数\",\"t\":[\"给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\"]},\"123\":{\"h\":\"9. 容斥原理\",\"t\":[\"给定一个整数 n 和 m 个不同的质数 p1​,p2​,...,pm​ .\",\"请你求出 1 ~ n 中能被 p1​,p2​,...,pm​​ 中至少一个数整除的整数有多少个。\",\"记 Si​ 为 1 ~ n 中能整除 pi​​ 的集合，根据容斥原理，所有数的个数为各个集合的并集，计算公式如下\",\"#include<iostream> using namespace std; #define ll long long const int N = 20; int p[N], n, m; int main() { cin >> n >> m; for(int i = 0; i < m; i++) cin >> p[i]; int res = 0; //枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合) for(int i = 1; i < 1 << m; i++) { int t = 1; //选中集合对应质数的乘积 int s = 0; //选中的集合数量 //枚举当前状态的每一位 for(int j = 0; j < m; j++){ //选中一个集合 if(i >> j & 1){ //乘积大于n, 则n/t = 0, 跳出这轮循环 if((LL)t * p[j] > n){ t = -1; break; } s++; //有一个1，集合数量+1 t *= p[j]; } } if(t != -1) { if (s % 2) //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量 res += n / t; else //反之则为 -1 res -= n / t; } } cout << res << endl; return 0; }\"]},\"124\":{\"h\":\"10. 博弈论\"},\"125\":{\"h\":\"10.1 NIM游戏\",\"t\":[\"必胜状态和必败状态\",\"必胜状态，先手进行__某一个操作__，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即__先手可以走到某一个必败状态__。\",\"必败状态，先手__无论如何操作__，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即__先手走不到任何一个必败状态__。\",\"给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\",\"我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\",\"定理： NIM博弈先手必胜，当且仅当 a1 ^ a2 ^ … ^ an != 0\",\"#include <iostream> #include <algorithm> using namespace std; int main() { int n; cin >> n; int res = 0; while (n--) { int x; cin >> x; res ^= x; //每次异或操作 } if (res) puts(\\\"Yes\\\"); else puts(\\\"No\\\"); return 0; }\"]},\"126\":{\"h\":\"10.2 公平组合游戏ICG\",\"t\":[\"若一个游戏满足：\",\"由两名玩家交替行动；\",\"在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\",\"不能行动的玩家判负；\",\"则称该游戏为一个公平组合游戏。\",\"NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件 2 和条件 3 。\"]},\"127\":{\"h\":\"10.3 有向图游戏\",\"t\":[\"给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\"]},\"128\":{\"h\":\"10.4 Mex运算\",\"t\":[\"设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\"]},\"129\":{\"h\":\"10.5 SG游戏\",\"t\":[\"在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\"]},\"130\":{\"h\":\"10.6 有向图游戏的和\",\"t\":[\"设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\",\"定理\",\"有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\"]},\"131\":{\"c\":[\"algorithm\"]},\"132\":{\"c\":[\"ACM\"]},\"133\":{\"h\":\"数据结构\"},\"134\":{\"h\":\"1. 数组模拟链表\"},\"135\":{\"h\":\"1.1 单链表\",\"t\":[\"也称静态链表（邻接表：n个链表，主要应用：存储图和树）单链表只能存储当前节点的值和指向下一节点的指针，无法存储上一节点\",\"// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; //-1表示不存在， idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a,; ne[idx] = head,; head = idx ++ ; } //将一个新的节点x插入下标是k的后面 void add(int k, int x){ e[idx] = x; //1.先存值 ne[idx] = ne[k]; //2.新节点的下一节点指向 k 指向的下一节点 ne[k] = idx; //3.k指向的下一节点指向新节点 idx++; //4.index指向下一个指针 } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } //将下标是k的点后面的点删掉 void remove(int x){ //直接将其指向下下个节点，在算法竞赛中一般不需要考虑删除的那个节点该如何处理 ne[k] = ne[ne[k]]; }\"]},\"136\":{\"h\":\"1.2 双链表\",\"t\":[\"（主要用来优化某些问题）有两个指针，一个指向前，一个指向后。\",\"// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1; l[1] = 0; idx = 2; //0和1都被占用了，所以idx从2开始 } // 在节点k的右边插入一个数x ////如果要插在k的左边，就把k改为l[k] void insert(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx++; } // 删除第k个点 void remove(int k) { l[r[k]] = l[k]; r[l[k]] = r[k]; }\"]},\"137\":{\"h\":\"2. 栈\",\"t\":[\"先进后出\"]},\"138\":{\"h\":\"2.1 普通栈\",\"t\":[\"// tt表示栈顶 int stk[N]; //栈数组从0开始 int tt = 0; // 向栈顶插入一个数 stk[++tt] = x; // 从栈顶弹出一个数 tt--; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt > 0) not empty { } else empty\"]},\"139\":{\"h\":\"2.1 单调栈\",\"t\":[\"给定一个序列，找到每一个数左边离他最近的比它小的数。\",\"性质：如果 ax >= ay ，x < y，那么 ax 永远不会被输出，可以删掉。比如 a3 >= a5 ，那么 a3 永远不会被输出。\",\"常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i <= n; i++) { while (tt && check(stk[tt], i)) tt--; stk[++tt] = i; }\"]},\"140\":{\"h\":\"3. 队列\",\"t\":[\"先进先出，后进后出\"]},\"141\":{\"h\":\"3.1 普通队列\",\"t\":[\"// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[++tt] = x; // 从队头弹出一个数 hh++; // 队头的值 q[hh]; //同理队尾 q[tt] // 判断队列是否为空 if (hh <= tt) not empty { } else empty\"]},\"142\":{\"h\":\"3.2 单调队列\",\"t\":[\"求滑动窗口里的最大值和最小值。用单调队列来优化。\",\"步骤：\",\"判断队头是否已经滑出窗口\",\"判断当前元素与队尾元素是否满足单调性问题\",\"若满足条件，弹出队尾元素，将当前元素加入队尾\",\"如果窗口满足条件，则输出结果\",\"【注意】队列里面存的是下标\",\"常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i < n; i++) { //判断队头是否滑出窗口 if (hh <= tt && check_out(q[hh])) hh++; //判断当前元素与队尾元素是否满足单调性问题 while (hh <= tt && check(q[tt], i)) tt--; q[++tt] = i; //将当前元素加入到队尾 //如果满足条件再输出结果 if() }\"]},\"143\":{\"h\":\"4. KMP\",\"t\":[\"关于为什么求 next 数组和匹配的操作类似： 因为本质是一样的：对于 S 串每一个特定的下标 i，在满足 s[i-j+1，i]=p[0，j] 的前提下，我们需要找出 j 的最大值。 唯一不同的在于，求 next 数组时，我们关心对于每个不同的下标 i，j 能走多远；匹配时，我们只关心 j 是否走到末尾.\",\"非常有意思的说法是： 求next数组时：对于每个i：“j走到哪了呀？我用数组记录一下你的位置” 匹配时：对于每个i：“到终点和我说声，匹配完我输出一下，没事别叫我。”\",\"#include <iostream> using namespace std; const int N = 100010, M = 10010; //N为模式串长度，M匹配串长度 int n, m; int ne[M]; //next[]数组，避免和头文件next冲突 char s[N], p[M]; //s为模式串， p为匹配串 int main() { cin >> n >> s+1; cin >> m >> p+1; //下标从1开始 //求next[]数组 for (int i = 2, j = 0; i <= m; i++) { while (j && p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } //匹配操作 for (int i = 1, j = 0; i <= n; i++) { while (j && s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == m) //满足匹配条件，打印开头下标, 从0开始 { //匹配完成后的具体操作 //如：输出以0开始的匹配子串的首字母下标 //printf(\\\"%d \\\", i - m); (若从1开始，加1) j = ne[j]; //再次继续匹配 } } return 0; }\"]},\"144\":{\"h\":\"5. Trie树\",\"t\":[\"Trie树又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构。\",\"存储形式如下：\",\"Trie树存储形式\",\"//son[][]存储树中每个节点的子节点，因为存的都是英文字母，最多有26个 int son[N][26]; int cnt[N]; //cnt[]存储以每个节点结尾的单词数量 int idx; //存储当前用到的下标，0号点既是根节点，又是空节点 // 插入一个字符串 void insert(char *str) { int p = 0; //字符串以'0'结尾，所以可以用str[i]结束 for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; }\"]},\"145\":{\"h\":\"6. 并查集\"},\"146\":{\"h\":\"6.1 朴素并查集\",\"t\":[\" int p[N]; // 存储每个点的祖宗节点 int rank[N]; // 树的高度 // 初始化，假定节点编号是1~n void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 合并x和y所在的两个集合： void union(int x, int y) { int px = find(x), py = find(y); if (rank[px] < rank[py]){ p[px] = py; rank[py] += rank[px]; } else { p[py] = px; rank[px] += rank[py]; } }\"]},\"147\":{\"h\":\"6.2 维护size的并查集\",\"t\":[\" int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);\"]},\"148\":{\"h\":\"6.3 维护到祖宗节点距离的并查集\",\"t\":[\" int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\"]},\"149\":{\"h\":\"7. 堆\",\"t\":[\"1、作用：维护一个数组集合\",\"2、堆是一棵（完全）二叉树，长得非常平衡，除最后一层节点，所有节点均不为空，最后一层节点从左向右排列，根节点小于等于左右两个子节点，即小根堆。\",\"3、存储：用一个一维数组存储树，下标从1开始。其中元素x 的左儿子为 2x，x 的右儿子为 2x + 1.\",\"4、5个基本操作\",\"heap表示堆，size表示大小\",\"插入一个数 heap[++size] = x; up(size);\",\"求集合当中的最小值 heap[1];\",\"删除最小值 heap[1] = heap[size]; size--; down(1);\",\"删除任意一个元素 heap[k] = heap[size]; size--; down(k); up(k); //down和up只会执行其中一个\",\"修改任意一个元素 heap[K] = x; down(k); up(k);\",\"// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u)//跟两个儿子比较大小 { //t表示该元素与它的左、右儿子相比最小的元素，初始化为它自身 int t = u; //若左二子小于它，则最小的数为左二子 if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2; //若右儿子小于它，则最小的数为右儿子 if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1; //如果它本身不是最小的数，则往下沉，继续down()操作 if (u != t) { heap_swap(u, t); down(t); } } void up(int u)//只需要跟一个父亲比较大小就行 { //如果比父节点大，就交换位置，上浮 while (u / 2 && h[u] < h[u / 2]) { heap_swap(u, u / 2); u >>= 1; //x /= 2 } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i);\"]},\"150\":{\"h\":\"8. 哈希表\"},\"151\":{\"h\":\"8.1 拉链法\",\"t\":[\"int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { //哈希函数离散化 int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; }\"]},\"152\":{\"h\":\"8.2 开放寻址法\",\"t\":[\"int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { //哈希函数 int k = (x % N + N) % N; while (h[k] != null && h[k] != x) { k++; //如果到了末尾，那么再从头开始查找 if (k == N) k = 0; } return k; }\"]},\"153\":{\"h\":\"8.3 字符串哈希\",\"t\":[\"核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N]; // h[k]存储字符串前k个字母的哈希值 ULL p[N]; //p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i <= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }\"]},\"154\":{\"h\":\"9. C++ STL简介\",\"t\":[\"vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair<int, int> first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列，本身就是有序的，默认按key排序 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 没找到则返回end() count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 (3) 例如：s.erase(unique(s.begin(), d.end()), s,end()) 将一个容器中重复的元素删除，对字符串也适用 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() 用 first 和 second 查找每个键值对的元素 [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 都可以是‘哈希表’ 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset<10000> s; ~, &, |, ^ >>, << ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反\"]},\"155\":{\"h\":\"10. 常用库函数\",\"t\":[\"1. reverse 翻转\",\"翻转一个 vector ：\",\"reverse(a.begin(), a.end());\",\"翻转一个数组，元素存放在下标 1 ~ n ：\",\"reverse(a + 1, a + n + 1);\",\"2. unique 去重\",\"返回去重（只去掉__相邻__的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。\",\"把一个 vector 去重：\",\"int m = unique(a.begin(), a.end()) – a.begin();\",\"把一个数组去重，元素存放在下标 1 ~ n：\",\"int m = unique(a + 1, a + n + 1) – (a + 1);\",\"3. random_shuffle 随机打乱： 用法与 reverse 相同。\",\"4. sort 排序：\",\"对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载 “小于号” 运算符。\",\"把一个 int 数组（元素存放在下标 1 ~ n ）从大到小排序，传入比较函数：\",\"int a[MAX_SIZE]; bool cmp(int a, int b) { return a > b; } sort(a + 1, a + n + 1, cmp);\",\"从大到小排序需要加入第三个参数：\",\"sort(a.begin(), a.end(), greater<int>());\",\"对自定义的结构体 vector 排序，重载 \\\"小于号\\\" 运算符：\",\"struct node { int id, x, y; }; vector<node> a; bool operator < (const node &a, const node &b) { return a.x < b.x || a.x == b.x && a.y < b.y; } sort(a.begin(), a.end());\",\"5. lower_bound / upper_bound 二分：\",\"lower_bound 的第三个参数传入一个元素 x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于 x 的元素的位置的迭代器（指针）。\",\"upper_bound 的用法和 lower_bound 大致相同，唯一的区别是查找第一个大于 x 的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。\",\"在有序 int 数组（元素存放在下标 1 ~ n ）中查找大于等于 x 的最小整数的下标：\",\"int i = lower_bound(a + 1, a + 1 + n, x) - a;\",\"在有序 vector<int> 中查找小于等于 x 的最大整数（假设一定存在）：\",\"int y = *--upper_bound(a.begin(), a.end(), x);\",\"找不到则返回最后一个元素的下标+1，是越界的。\"]},\"156\":{\"c\":[\"algorithm\"]},\"157\":{\"c\":[\"ACM\"]},\"158\":{\"h\":\"贪心\"},\"159\":{\"h\":\"1. 区间问题\"},\"160\":{\"h\":\"1.1 区间选点\",\"t\":[\"给定 N个闭区间 ，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node &W) const { return r < W.r; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; //按右端点从小到大排序 sort(arr + 1, arr + 1 + n); int ans = 0; int R = -2e9; //R表示上一连续区间的最右端的点 for (int i = 1; i <= n; i++) { if (arr[i].l > R) //如果不能覆盖掉右端点，则点数+1，更新右端点 { ans++; R = arr[i].r; } } cout << ans << endl; return 0; }\"]},\"161\":{\"h\":\"1.2 最大不相交区间数量\",\"t\":[\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node & W) const { return l < W.l; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; sort(arr + 1, arr + 1 + n); int res = 1, R = arr[1].r; for (int i = 2; i <= n; i++){ if (arr[i].l <= R) R = min(R, arr[i].r); else { res++; R = arr[i].r; } } cout << res << endl; return 0; }\"]},\"162\":{\"h\":\"1.3 区间分组\",\"t\":[\"给定 N个闭区间 ，要求分成若干组，使得每组内部区间两两之间没有交集，求分成的最小组数。\",\"#include <iostream> #include <algorithm> #include <queue> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; //重载小于运算符，按左端点从小到大排序 bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); //用一个小根堆来维护所有组的右端点 priority_queue<int, vector<int>, greater<int>> heap; for (int i = 0; i < n; i++){ auto t = Range[i]; if (heap.empty() || heap.top() >= t.l) //放不进去则新开一组 heap.push(t.r); else { heap.pop(); heap.push(t.r); //放进去并更新右端点 } } cout << heap.size() << endl; return 0; }\"]},\"163\":{\"h\":\"1.4 区间覆盖\",\"t\":[\"给定 N 个闭区间，以及一个线段区间，请你选择尽量少的区间，将指定线段区间完全覆盖。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; int L, R; cin >> L >> R; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); int res = 0; bool f = false; for (int i = 0; i < n; ){ //依次遍历每个区间 int j = i, r = -2e9; //j表示第几个区间 //遍历所有左端点在L的左边的区间，选出右端点最大的 while (j < n && Range[j].l <= L){ r = max(r, Range[j].r); j++; } if (r < L){ //如果所有右端点都小于L，则无解 res = -1; break; } res++; if (r >= R){ //循环出口 f = true; break; } //更新端点和遍历的区间 L = r; i = j; } if (!f) res = -1; cout << res << endl; return 0; }\"]},\"164\":{\"h\":\"1.5 区间合并\",\"t\":[\"#include <iostream> #include <cstdio> #include <algorithm> #include <vector> #define PII pair<int, int> using namespace std; const int N = 1e5 + 5; int n; vector <PII> nums, ans; void merge(vector<PII> &nums){ //按左端点排序 sort(nums.begin(), nums.end()); //l代表区间左端点，r代表区间右端点 int l = -2e9, r = -2e9; for (auto num : nums){ //如果两区间无法合并 if (r < num.first){ if (l != -2e9) ans.push_back({l, r});//将新的区间放入ans数组中 l = num.first, r = num.second;//更新区间 } //若两区间部分存在交集，小的合并到大的中 else r = max(r, num.second); } if (l != -2e9) ans.push_back({l, r}); } int main() { cin >> n; for (int i = 0; i < n; i++){ int l, r; cin >> l >> r; nums.push_back({l, r}); } merge(nums); cout << ans.size() << endl; return 0; }\"]},\"165\":{\"c\":[\"algorithm\"]},\"166\":{\"c\":[\"ACM\"]},\"167\":{\"h\":\"插件\",\"t\":[\"我做了一款vuepress的音乐可视化播放插件\",\"vuepress-plugin-player\",\"Vuepress 音乐播放器 & 沉浸式 源码：RayShineHub.github.io\",\"搭建 VuePress 博客，你可能会用到的一些插件\",\"博客搭建系列 - 冴羽\"]},\"168\":{\"c\":[\"教程\"]},\"169\":{\"c\":[\"Blog\"]},\"170\":{\"h\":\"二叉树的中序遍历\",\"t\":[\"二叉树的中序遍历\"]},\"171\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\",\"二叉树的 中序遍历: 从根节点开始，首先遍历左子树，然后访问根节点，最后访问右子树。然后在遍历左子树的时候，同样首先遍历左子节点的左子树，然后访问根节点，最后遍历左子节点的右子树...\"]},\"172\":{\"h\":\"思路一（递归）\",\"t\":[\"按照中序遍历的过程，对每个节点的进行相同的递归处理。先处理这个节点的左子树，再处理这个节点，最后处理这个节点的右子树。\",\"递归终点：当处理的节点是空节点时，说明该节点的子树是空子树，无法继续向下处理了，递归结束，向上返回结果。\",\"代码：\"]},\"173\":{\"h\":\"思路二（迭代）\",\"t\":[\"在递归的方法中，其实隐式地维护了一个栈结构：一直递归寻找最下层的左节点，直到找到并处理完后，再返回处理上一层找到的节点。类似于栈中的先进后出，最后找到的节点处理完后，才会处理之前找到的节点。\",\"因此利用迭代的思想，使用一个栈，迭代地寻找当前节点的左子节点，找到后处理并弹出，同理再处理该节点和该节点的右子节点。全部弹出后，最后返回上一层，即当前节点的父节点。此时父节点相当于当前节点，当前节点相当于左节点，继续上述迭代处理即可。\",\"代码：\"]},\"174\":{\"c\":[\"hot100\"]},\"175\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"176\":{\"h\":\"滑动窗口最大值\",\"t\":[\"239. 滑动窗口最大值 \"]},\"177\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\",\"返回 滑动窗口中的最大值 。\"]},\"178\":{\"h\":\"思路一（优先队列）\",\"t\":[\"使用优先队列，维护值和下标，窗口每次移动，判断当前最大值的位置，若已滑出窗口，则更新最大值，否则不更新。将每次移动的最大值保存在 ans[]中。\",\"代码：\",\"class Solution { public: vector<int> maxSlidingWindow(vector<int>& nums, int k) { int n = nums.size(); priority_queue<pair<int, int>> q; for (int i = 0; i < k; i++){ q.push({nums[i], i}); } vector<int> ans = {q.top().first}; for (int i = k; i < n; i++){ q.push({nums[i], i}); while (q.top().second <= i - k){ q.pop(); } ans.push_back(q.top().first); } return ans; } };\"]},\"179\":{\"h\":\"思路二（单调队列）\"},\"180\":{\"c\":[\"hot100\"]},\"181\":{\"c\":[\"滑动窗口\",\"优先队列\",\"单调队列\"]},\"182\":{\"h\":\"MinIO 安装与部署\",\"t\":[\"官方仓库\",\"GitHub：https://github.com/minio\",\"GItee镜像：https://gitee.com/mirrors/minio\",\"官网下载：https://www.minio.org.cn/download.shtml#/\"]},\"183\":{\"h\":\"Linux 安装启动\",\"t\":[\"下载安装包：\",\"wget https://dl.minio.org.cn/server/minio/release/linux-amd64/minio\",\"赋予可执行权限：\",\"chmod +x minio\",\"前台启动：\",\"MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address \\\":9001\\\"\",\"命令解释：\",\"MINIO_ROOT_USER=admin：指定MinIO的用户名\",\"MINIO_ROOT_PASSWORD=password：指定MinIO密码 （用户名和密码都可以省略，默认均为 minioadmin）\",\"./minio server：在 minio 所在目录下启动 minio 服务，可修改\",\"/mnt/data：指定数据存放位置，可以自定义修改\",\"--console-address \\\":9001\\\"：指定 MinIO 控制台的监听地址和端口\",\"后台启动：\",\"# 最简单的，只需要在最后面加上 & 即可，但关闭会话服务会停止 nohub ./minio server /mnt/data > /opt/minio/data/minio.log 2>&1 --console-address \\\":9001\\\" &\",\"命令解释：\",\"nohup：这是一个 Unix 命令，用于运行另一个命令在后台，并且忽略挂起（HUP）信号，即使你退出了终端或关闭了会话，该命令也会继续执行；\",\"> /opt/minio/data/minio.log：这部分是将标准输出（stdout）重定向到 /opt/minio/data/minio.log 文件，这意味着 MinIO 服务器的所有正常输出（如启动信息、状态更新等）都会被写入到这个日志文件中；\",\"2>&1：这部分是将标准错误输出（stderr）重定向到标准输出（stdout），即输出到 /opt/minio/data/minio.log 文件，这样，无论是标准输出还是错误输出，都会被写入到同一个日志文件中；\",\"&：这个符号是在命令的末尾，用于将命令放到后台执行，也就是即使你启动了 MinIO 服务器，你的终端或 shell 会话也不会被阻塞，你可以继续执行其他命令；\"]},\"184\":{\"h\":\"Docker 安装启动\",\"t\":[\"搜索 MinIO 镜像：\",\"docker search minio\",\"拉取 MinIO 镜像：\",\"docker pull minio/minio\",\"启动 MinIO 容器：\",\"docker run -p 9000:9000 -p 9001:9001 minio/minio server /mnt/docker/data --console-address \\\":9001\\\"\"]},\"185\":{\"h\":\"Windows 安装启动\",\"t\":[\"下载 Windows 版的 MinIO：\",\"https://dl.min.io/server/minio/release/windows-amd64/minio.exe\",\"进入到 minio.exe 所在的目录，导航栏输入 cmd 进入终端，执行：\",\"minio.exe server D:\\\\dev\\\\MinIO\\\\data --console-address \\\":9001\\\"\",\"启动 MinIO 服务，其中 D:\\\\dev\\\\MinIO\\\\data 是 MinIO 存储数据的目录路径\",\"在浏览器输入 http://localhost:9000/，登录 MinIO 服务器 web 管理后台\",\"提示\",\"默认用户名和密码都是 minioadmin\"]},\"186\":{\"h\":\"Windows 后台服务安装\",\"t\":[\"使用上述命令将 MinIO 在 Windows 上启动，关闭终端后服务就会停止。如果要使用 Windows 搭建 MinIO 服务器，需要将其注册为 Windows 服务。\",\"下载 WinSW-x64.exe：https://github.com/winsw/winsw/releases\",\"将 WinSW.exe 复制到自己指定的目录，重命名为 minio-server.exe.\",\"在同目录下创建 minio-server.xml。注意，xml 和 exe 必须同名。\",\"配置 minio-server.xml 文件，内容如下:\",\"<service> <id>minio-server</id> <name>minio-server</name> <description>minio文件存储服务</description> <executable>%BASE%\\\\minio.exe</executable> <arguments>server \\\"%BASE%\\\\data\\\"</arguments> <logpath>%BASE%\\\\logs</logpath> <log mode=\\\"roll-by-size-time\\\"> <sizeThreshold>10240</sizeThreshold> <pattern>yyyyMMdd</pattern> <autoRollAtTime>00:00:00</autoRollAtTime> <zipOlderThanNumDays>5<zipOlderThanNumDays> <zipDateFormat>yyyyMMdd</zipDateFormat> </log> </service>\",\"执行 cmd 命令注册系统服务\",\"minio-server.exe install\",\"卸载服务\",\"minio-server.exe uninstall\"]},\"187\":{\"c\":[\"中间件\"]},\"188\":{\"c\":[\"MinIO\"]},\"189\":{\"h\":\"MinIO 概述\",\"t\":[\"官网链接\",\"MinIO官网：https://min.io/\",\"中文官网：http://minio.org.cn/\",\"MinIO 是一个高性能的分布式对象存储系统，基于 Apache License v2.0 开源协议，兼容亚马逊 S3 云存储服务接口，非常适合存储大容量的数据，包括但不限于：\",\"文本数据：新闻报道、社交媒体文章、博客......\",\"语音数据：音频形式存储的数据，语音mp3文件......\",\"图像数据：各种图片......\",\"视频数据：各种视频、电影......\",\"非结构化数据：没有明确结构的数据，比如社交评论、日志文件......\"]},\"190\":{\"h\":\"什么是对象存储？\",\"t\":[\"对象存储（Object Storage）是一种数据存储架构，它以对象为单位来处理、存储和检索数据，每个对象都包含了数据本身以及元数据，适合存放任意类型的文件。通常通过基于 HTTP 或 HTTPS 协议的 API（应用程序编程接口）进行数据读写。常见的有阿里云对象存储服务（OSS）、腾讯云对象存储（COS）等。\",\"所以基于对象的形式， MinIO 存储的元数据主要包括对象的描述信息，如用户（account）、存储桶（bucket）以及存储桶索引（bucket index）等。\",\"对于企业来说，可以使用各种公有云提供的 OSS 服务，将业务数据存储在云上，既能节省存储成本，也能使用云存储服务提供的 API 接口，方便使用和管理数据。但对于数据传输的安全性和及时性有较高要求的业务来说，使用公有云的 OSS 服务，就要付出较高的公网带宽传输成本，以及对数据安全的保障服务。在这种情况下，利用 MinIO 轻便、高性能、可拓展性的特点，企业可以快速搭建自己的内部对象存储服务。\",\"当然，对于个人来说，MinIO 是 100% 开源的，这就意味着个人也可以基于 MinIO 搭建自己专属的对象存储服务器。\"]},\"191\":{\"h\":\"特点\",\"t\":[\"文档全面： MinIO 作为一款基于 Golang 语言开发的一款高性能的分布式式存储方案的开源项目，有十分完善的官方文档。\",\"MinIO 文档\",\"中文文档地址：https://www.minio.org.cn/docs/minio/\",\"高性能： MinIO 号称是目前速度最快的对象存储服务器。在标准硬件上，对象存储的读/写速度最高可以高达 183GB/s 和 171GB/s。对象存储可以作为主存储层，用来处理 Spark、Presto、TensorFlow、HAO.ai 等各种复杂工作负载以及成为 Hadoop HDFS 的替代品。\",\"云原生： 容器化、基于 K8S 的编排、多租户支持。 用作云原生应用程序的主要存储，和传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。\",\"可拓展： 不同 MinIO 集群可以组成联邦，并形成一个全局的命名空间，并且支持跨越多个数据中心。 并且除了 MinIO 自己的文件系统，还支持 DAS、 JBODs、NAS、Google 云存储和 Azure Blob 存储。\",\"Amazon S3 标准兼容: 亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界内大家都认可的标准。MinIO 在很早的时候就采用了 S3 兼容协议，并且 MinIO 是第一个支持 S3 Select 的产品。 使用 Amazon S3 v2 / v4 API，可以使用 MinIO SDK，MinIO Client，AWS SDK 和 AWS CLI 访问 MinIO 服务器。\",\"支持全面： 目前 MinIO 支持市面主流的开发语言并且可以通过 SDK 快速集成快速集成使用。\",\"常用语言的 SDK\",\"GO SDK：https://github.com/minio/minio-go\",\"Java SDK：https://github.com/minio/minio-java\",\"Python SDK：https://github.com/minio/minio-py\",\"可视化管理界面： MinIO 除了通过传统的命令行进行操作之外，还提供可视化的操作管理界面，在服务安装后，可以直接通过浏览器登录系统，完成文件夹、文件的管理，非常方便使用。\",\"数据存储高容错： Minio 的存储机制使用纠删码（Erasure Code）和校验和（CheckSum）。 校验和：保护数据免受硬件故障和无声数据损坏。 纠删码：是一种恢复丢失和损坏数据的数学算法。通过数学算法将数据分割成多个数据块和校验块，并将这些块分散存储在不同的磁盘上。这种机制使得即使部分磁盘发生故障，也能通过剩余的数据块和校验块恢复原始数据，从而提高系统的可靠性和容错能力。 具体地，MinIO 使用 Reed-Solomon 码作为其纠删码算法，将一个对象拆分成 N/2 份数据和 N/2 份奇偶校验块。如果是 12 块盘，一个对象会被分成 6 个数据块、 6 个奇偶校验块，可以丢失任意 6 块盘（不管其是存放的数据块还是奇偶校验块），仍可以从剩下的盘中的数据进行恢复。 这样的设计，保证了即使在最坏的情况，即丢失一半数量的硬盘的情况下仍能保证数据的安全性。\"]},\"192\":{\"c\":[\"中间件\"]},\"193\":{\"c\":[\"MinIO\"]},\"194\":{\"h\":\"SpringBoot 整合 MinIO\"},\"195\":{\"h\":\"引入依赖\",\"t\":[\"<dependency> <groupId>io.minio</groupId> <artifactId>minio</artifactId> <version>8.5.9</version> </dependency>\"]},\"196\":{\"h\":\"配置文件\",\"t\":[\"MinIO 中的 Bucket、Object\",\"Bucket 是存储 Object 的逻辑空间，每个 Bucket 之间的数据是相互隔离的，对用户而言，相当于存放文件的顶层文件夹\",\"Object 是存储到 MinIO 的基本对象，对用户而言，相当于文件\",\"SpringBoot 使用 MinIO 非常方便，只需要创建 MinIOClient 即可，后续通过调用 API 对 MinIO 服务进行配置和操作。\",\"在 application.yml 中配置 MinIO 连接信息\",\"minio: endpoint: http://localhost:9000 # 服务器地址和端口 accessKey: minioadmin # minio用户名 secretKey: minioadmin # minio密码 bucket: user-bucket # 使用的存储桶（可选）\",\"添加 MinIO 实体类\",\"@Data @Component @ConfigurationProperties(prefix = \\\"minio\\\") public class MinIOInfo { private String endpoint; private String accessKey; private String secretKey; private String bucket; }\",\"将 MinIOClient 注册为 Bean 对象，后续通过注入 minioClient 对象即可实现对 MinIO 的操作。\",\"@Configuration public class Config { @Resource private MinIOInfo minIOInfo; @Bean public MinioClient minioClient() { //链式编程，构建MinioClient对象 return MinioClient.builder() .endpoint(minIOInfo.getEndpoint()) .credentials(minIOInfo.getAccessKey(), minIOInfo.getSecretKey()) .build(); } }\",\"支持多线程\",\"MinioClient 对象是单例的，那么有没有线程安全问题呢？\",\"答案是：没有线程安全问题。MinIO 官方团队表示，可以多个线程共同使用一个 MinIOClient 对象。\"]},\"197\":{\"h\":\"MinioClient 的常用 API\"},\"198\":{\"h\":\"Bucket 操作\",\"t\":[\"bucketExists()：用于检查指定的存储桶是否存在，返回布尔值，表示存储桶是否存在\",\" void test01() throws Exception { boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(\\\"myfile\\\").build()); System.out.println(\\\"myfile目录是否存在：\\\" + isBucketExists); }\",\"makeBucket()：用于创建一个新的存储桶（bucket），需要指定存储桶的名称\",\" void test02() throws Exception { String bucketName = \\\"myfile2\\\"; boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build()); if (!isBucketExists) { minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build()); } else { System.out.println(\\\"bucket已经存在，不需要创建\\\"); } String policyJsonString = \\\"{\\\\\\\"Version\\\\\\\" : \\\\\\\"2012-10-17\\\\\\\",\\\\\\\"Statement\\\\\\\":[{\\\\\\\"Sid\\\\\\\":\\\\\\\"PublicRead\\\\\\\",\\\\\\\"Effect\\\\\\\":\\\\\\\"Allow\\\\\\\",\\\\\\\"Principal\\\\\\\":{\\\\\\\"AWS\\\\\\\":\\\\\\\"*\\\\\\\"},\\\\\\\"Action\\\\\\\":[\\\\\\\"s3:GetObject\\\\\\\"],\\\\\\\"Resource\\\\\\\":[\\\\\\\"arn:aws:s3:::\\\" + bucketName + \\\"/*\\\\\\\"]}]}\\\"; //创建存储桶的时候，设置该存储桶里面的文件的访问策略，运行公开的读； minioClient.setBucketPolicy(SetBucketPolicyArgs.builder() .bucket(bucketName) .config(policyJsonString)//json串，里面是访问策略 .build()); }\",\"listBuckets()：用于列出用户有权访问的所有存储桶，返回存储桶的列表\",\" void test03() throws Exception { List<Bucket> bucketList = minioClient.listBuckets(); bucketList.forEach(bucket -> { System.out.println(bucket.name() + \\\" -- \\\" + bucket.creationDate()); }); }\",\"removeBucket()：用于删除一个已存在的存储桶（bucket），删除失败会抛出异常\",\" void test04() throws Exception { minioClient.removeBucket(RemoveBucketArgs.builder().bucket(\\\"myfile2\\\").build()); }\"]},\"199\":{\"h\":\"Object 操作\",\"t\":[\"putObject()：用于上传文件到指定的存储桶\",\" void test05() throws Exception { File file = new File(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\"); // 文件路径 ObjectWriteResponse objectWriteResponse = minioClient.putObject(PutObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .stream(new FileInputStream(file), file.length(), -1) // 使用stream流读取文件，自动获取文件大小 .build() ); System.out.println(objectWriteResponse); ObjectWriteResponse objectWriteResponse2 = minioClient.uploadObject(UploadObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test2.jpg\\\") .filename(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\") // 指定文件路径 .build() ); System.out.println(objectWriteResponse); }\",\"statObject()：用于检查指定的对象（文件）的状态\",\" void test06() throws Exception { StatObjectResponse statObjectResponse = minioClient.statObject(StatObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(statObjectResponse); }\",\"getPresignedObjectUrl()：用于生成一个对象（文件）的签名URL，以便可以通过HTTP访问\",\" void test07() throws Exception { String presignedObjectUrl = minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .expiry(3, TimeUnit.MINUTES) .method(Method.GET) .build() ); System.out.println(presignedObjectUrl); }\",\"getObject()：用于从指定的存储桶中下载文件\",\" void test08() throws Exception { GetObjectResponse getObjectResponse = minioClient.getObject(GetObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(getObjectResponse.transferTo(new FileOutputStream(\\\"D:\\\\\\\\MinIO\\\\\\\\123.jpg\\\"))); }\",\"listObjects()：用于列出指定存储桶中的所有对象（文件）\",\" void test09() throws Exception { Iterable<Result<Item>> listObjects = minioClient.listObjects(ListObjectsArgs.builder() .bucket(\\\"myfile\\\") .build() ); listObjects.forEach( itemResult -> { try { Item item = itemResult.get(); System.out.println(item.objectName()); } catch (Exception e) { throw new RuntimeException(e); } }); }\",\"removeObject()：用于删除指定存储桶中的对象，需要指定存储桶名称和对象键\",\" void test10() throws Exception { minioClient.removeObject(RemoveObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); }\"]},\"200\":{\"c\":[\"中间件\"]},\"201\":{\"c\":[\"MinIO\"]},\"202\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"203\":{\"h\":\"For Offer\"},\"204\":{\"h\":\"Template\"},\"205\":{\"h\":\"Tool Build\"},\"206\":{\"h\":\"Hot 100\"},\"207\":{\"h\":\"Leetcode\"},\"208\":{\"h\":\"Min IO\"},\"209\":{\"h\":\"Middleware\"}},\"dirtCount\":0,\"index\":[[\"里面是访问策略\",{\"1\":{\"198\":1}}],[\"里面各个数字有多少个\",{\"1\":{\"37\":1}}],[\"创建存储桶的时候\",{\"1\":{\"198\":1}}],[\"答案是\",{\"1\":{\"196\":1}}],[\"答案在哪一侧\",{\"1\":{\"52\":1}}],[\"答案在右边界\",{\"1\":{\"51\":1}}],[\"答案在左边界\",{\"1\":{\"50\":1}}],[\"构建minioclient对象\",{\"1\":{\"196\":1}}],[\"构造状态转移方程\",{\"1\":{\"35\":1}}],[\"链式编程\",{\"1\":{\"196\":1}}],[\"注册为\",{\"1\":{\"196\":1}}],[\"注意multimap不支持此操作\",{\"1\":{\"154\":1}}],[\"注意乘除的先后顺序\",{\"1\":{\"108\":1}}],[\"注意\",{\"1\":{\"67\":1,\"142\":1,\"186\":1}}],[\"实体类\",{\"1\":{\"196\":1}}],[\"添加\",{\"1\":{\"196\":1}}],[\"添加一条边a\",{\"1\":{\"75\":1}}],[\"连接信息\",{\"1\":{\"196\":1}}],[\"连通图\",{\"1\":{\"92\":1}}],[\"连通这两个顶点\",{\"1\":{\"91\":1}}],[\"引入依赖\",{\"0\":{\"195\":1}}],[\"仍可以从剩下的盘中的数据进行恢复\",{\"1\":{\"191\":1}}],[\"仍然为前闭后开\",{\"1\":{\"155\":1}}],[\"块盘\",{\"1\":{\"191\":2}}],[\"份奇偶校验块\",{\"1\":{\"191\":1}}],[\"份数据和\",{\"1\":{\"191\":1}}],[\"码作为其纠删码算法\",{\"1\":{\"191\":1}}],[\"纠删码\",{\"1\":{\"191\":1}}],[\"保证了即使在最坏的情况\",{\"1\":{\"191\":1}}],[\"保护数据免受硬件故障和无声数据损坏\",{\"1\":{\"191\":1}}],[\"保存节点信息\",{\"1\":{\"42\":1}}],[\"校验和\",{\"1\":{\"191\":1}}],[\"目前\",{\"1\":{\"191\":1}}],[\"目录\",{\"0\":{\"2\":1,\"9\":1}}],[\"支持多线程\",{\"1\":{\"196\":1}}],[\"支持市面主流的开发语言并且可以通过\",{\"1\":{\"191\":1}}],[\"支持全面\",{\"1\":{\"191\":1}}],[\"支持比较运算\",{\"1\":{\"154\":2}}],[\"兼容协议\",{\"1\":{\"191\":1}}],[\"兼容亚马逊\",{\"1\":{\"189\":1}}],[\"亚马逊云的\",{\"1\":{\"191\":1}}],[\"自己的文件系统\",{\"1\":{\"191\":1}}],[\"自动获取文件大小\",{\"1\":{\"199\":1}}],[\"自动获得\",{\"1\":{\"35\":1}}],[\"自动得到右端点\",{\"1\":{\"35\":1}}],[\"集群可以组成联邦\",{\"1\":{\"191\":1}}],[\"集合数量+1\",{\"1\":{\"123\":1}}],[\"云存储和\",{\"1\":{\"191\":1}}],[\"云存储服务接口\",{\"1\":{\"189\":1}}],[\"云原生应用程序需要更高的吞吐量和更低的延迟\",{\"1\":{\"191\":1}}],[\"云原生\",{\"1\":{\"191\":1}}],[\"写速度最高可以高达\",{\"1\":{\"191\":1}}],[\"号称是目前速度最快的对象存储服务器\",{\"1\":{\"191\":1}}],[\"号点的判断中需要进行\",{\"1\":{\"84\":1}}],[\"语言开发的一款高性能的分布式式存储方案的开源项目\",{\"1\":{\"191\":1}}],[\"语音mp3文件\",{\"1\":{\"189\":1}}],[\"语音数据\",{\"1\":{\"189\":1}}],[\"作为一款基于\",{\"1\":{\"191\":1}}],[\"作用\",{\"1\":{\"68\":1,\"149\":1}}],[\"企业可以快速搭建自己的内部对象存储服务\",{\"1\":{\"190\":1}}],[\"轻便\",{\"1\":{\"190\":1}}],[\"利用\",{\"1\":{\"190\":1}}],[\"利用迭代器\",{\"1\":{\"155\":1}}],[\"接口协议\",{\"1\":{\"191\":1}}],[\"接口\",{\"1\":{\"190\":1}}],[\"接下来\",{\"1\":{\"33\":1}}],[\"既能节省存储成本\",{\"1\":{\"190\":1}}],[\"腾讯云对象存储\",{\"1\":{\"190\":1}}],[\"应用程序编程接口\",{\"1\":{\"190\":1}}],[\"应用程序服务器中间件\",{\"1\":{\"13\":1}}],[\"通常通过基于\",{\"1\":{\"190\":1}}],[\"通过数学算法将数据分割成多个数据块和校验块\",{\"1\":{\"191\":1}}],[\"通过\",{\"1\":{\"121\":1}}],[\"通过定理求组合数c\",{\"1\":{\"120\":1}}],[\"通过预处理逆元的方式求组和数\",{\"0\":{\"119\":1}}],[\"通过初等行变换把\",{\"1\":{\"116\":1}}],[\"通过一个连接起来\",{\"1\":{\"89\":1}}],[\"什么是对象存储\",{\"0\":{\"190\":1}}],[\"日志文件\",{\"1\":{\"189\":1}}],[\"电影\",{\"1\":{\"189\":1}}],[\"视频数据\",{\"1\":{\"189\":1}}],[\"音频形式存储的数据\",{\"1\":{\"189\":1}}],[\"音乐播放器\",{\"1\":{\"167\":1}}],[\"社交媒体文章\",{\"1\":{\"189\":1}}],[\"新闻报道\",{\"1\":{\"189\":1}}],[\"新节点的下一节点指向\",{\"1\":{\"135\":1}}],[\"概述\",{\"0\":{\"189\":1}}],[\"卸载服务\",{\"1\":{\"186\":1}}],[\"zipdateformat>\",{\"1\":{\"186\":1}}],[\"配置文件\",{\"0\":{\"196\":1}}],[\"配置\",{\"1\":{\"186\":1}}],[\"复制到自己指定的目录\",{\"1\":{\"186\":1}}],[\"提示\",{\"1\":{\"185\":1}}],[\"管理后台\",{\"1\":{\"185\":1}}],[\"管理计算资源和网络通信\",{\"1\":{\"13\":1}}],[\"登录\",{\"1\":{\"185\":1}}],[\"执行\",{\"1\":{\"185\":1,\"186\":1}}],[\"导航栏输入\",{\"1\":{\"185\":1}}],[\"版的\",{\"1\":{\"185\":1}}],[\"版本2\",{\"0\":{\"51\":1}}],[\"版本1\",{\"0\":{\"50\":1}}],[\"启动\",{\"1\":{\"184\":1,\"185\":1}}],[\"拉取\",{\"1\":{\"184\":1}}],[\"拉链法\",{\"0\":{\"151\":1}}],[\"镜像\",{\"1\":{\"184\":2}}],[\"搜索\",{\"1\":{\"184\":1}}],[\"搜索与图论\",{\"0\":{\"74\":1},\"1\":{\"3\":1}}],[\"文档\",{\"1\":{\"191\":1}}],[\"文档全面\",{\"1\":{\"191\":1}}],[\"文本数据\",{\"1\":{\"189\":1}}],[\"文件路径\",{\"1\":{\"199\":1}}],[\"文件的管理\",{\"1\":{\"191\":1}}],[\"文件\",{\"1\":{\"183\":2,\"186\":1,\"199\":3}}],[\"文章\",{\"1\":{\"18\":1}}],[\"信号\",{\"1\":{\"183\":1}}],[\"命令注册系统服务\",{\"1\":{\"186\":1}}],[\"命令\",{\"1\":{\"183\":1}}],[\"命令解释\",{\"1\":{\"183\":2}}],[\"控制台的监听地址和端口\",{\"1\":{\"183\":1}}],[\"控制精度\",{\"1\":{\"116\":1}}],[\"服务进行配置和操作\",{\"1\":{\"196\":1}}],[\"服务器地址和端口\",{\"1\":{\"196\":1}}],[\"服务器\",{\"1\":{\"183\":1,\"185\":1,\"186\":1,\"191\":1}}],[\"服务器的所有正常输出\",{\"1\":{\"183\":1}}],[\"服务\",{\"1\":{\"183\":1,\"185\":1,\"186\":1,\"190\":2}}],[\"赋予可执行权限\",{\"1\":{\"183\":1}}],[\"官方团队表示\",{\"1\":{\"196\":1}}],[\"官方仓库\",{\"1\":{\"182\":1}}],[\"官网链接\",{\"1\":{\"189\":1}}],[\"官网下载\",{\"1\":{\"182\":1}}],[\"安装启动\",{\"0\":{\"183\":1,\"184\":1,\"185\":1}}],[\"安装与部署\",{\"0\":{\"182\":1}}],[\"安全中间件\",{\"1\":{\"13\":1}}],[\"窗口每次移动\",{\"1\":{\"178\":1}}],[\"滑动窗口\",{\"2\":{\"181\":1}}],[\"滑动窗口中的最大值\",{\"1\":{\"177\":1}}],[\"滑动窗口每次只向右移动一位\",{\"1\":{\"177\":1}}],[\"滑动窗口最大值\",{\"0\":{\"176\":1},\"1\":{\"176\":1}}],[\"继续上述迭代处理即可\",{\"1\":{\"173\":1}}],[\"继续down\",{\"1\":{\"149\":1}}],[\"才会处理之前找到的节点\",{\"1\":{\"173\":1}}],[\"才为\",{\"1\":{\"67\":1}}],[\"才为1\",{\"1\":{\"67\":1}}],[\"类似于栈中的先进后出\",{\"1\":{\"173\":1}}],[\"首先遍历左子树\",{\"1\":{\"171\":1}}],[\"首先预处理出所有阶乘取模的余数fact\",{\"1\":{\"119\":1}}],[\"题意\",{\"0\":{\"171\":1,\"177\":1}}],[\"题目描述\",{\"1\":{\"53\":1}}],[\"教程\",{\"2\":{\"168\":1}}],[\"冴羽\",{\"1\":{\"167\":1}}],[\"博客搭建系列\",{\"1\":{\"167\":1}}],[\"博客\",{\"1\":{\"167\":1,\"189\":1}}],[\"博弈论\",{\"0\":{\"124\":1}}],[\"搭建自己专属的对象存储服务器\",{\"1\":{\"190\":1}}],[\"搭建\",{\"1\":{\"167\":1,\"186\":1}}],[\"源码\",{\"1\":{\"167\":1}}],[\"沉浸式\",{\"1\":{\"167\":1}}],[\"插件\",{\"0\":{\"167\":1}}],[\"插入的数是一个pair\",{\"1\":{\"154\":1}}],[\"插入一个元素\",{\"1\":{\"154\":1}}],[\"插入一个数\",{\"1\":{\"149\":1,\"154\":1}}],[\"插入一个字符串\",{\"1\":{\"144\":1}}],[\"插入\",{\"1\":{\"34\":1}}],[\"放进去并更新右端点\",{\"1\":{\"162\":1}}],[\"放不进去则新开一组\",{\"1\":{\"162\":1}}],[\"放入高位\",{\"1\":{\"56\":1}}],[\"唯一的区别是查找第一个大于\",{\"1\":{\"155\":1}}],[\"唯一不同的在于\",{\"1\":{\"143\":1}}],[\"大致相同\",{\"1\":{\"155\":1}}],[\"大于某个与inf`\",{\"1\":{\"84\":1}}],[\"传入比较函数\",{\"1\":{\"155\":1}}],[\"传入t的地址\",{\"1\":{\"59\":1}}],[\"排序\",{\"1\":{\"155\":2}}],[\"随机打乱\",{\"1\":{\"155\":1}}],[\"元素存放在下标\",{\"1\":{\"155\":4}}],[\"翻转一个数组\",{\"1\":{\"155\":1}}],[\"翻转一个\",{\"1\":{\"155\":1}}],[\"翻转\",{\"1\":{\"155\":1}}],[\"翻转指定位\",{\"1\":{\"67\":1}}],[\"等各种复杂工作负载以及成为\",{\"1\":{\"191\":1}}],[\"等\",{\"1\":{\"190\":2}}],[\"等价于~\",{\"1\":{\"154\":1}}],[\"等效替代\",{\"1\":{\"115\":1}}],[\"圧位\",{\"1\":{\"154\":1}}],[\"增删改查的时间复杂度是\",{\"1\":{\"154\":1}}],[\"增广矩阵\",{\"1\":{\"116\":1}}],[\"增广路\",{\"1\":{\"93\":1}}],[\"查找每个键值对的元素\",{\"1\":{\"154\":1}}],[\"查找一个数\",{\"1\":{\"154\":1}}],[\"查询字符串出现的次数\",{\"1\":{\"144\":1}}],[\"本身就是有序的\",{\"1\":{\"154\":1}}],[\"红黑树\",{\"1\":{\"154\":1}}],[\"弹出栈顶元素\",{\"1\":{\"154\":1}}],[\"弹出堆顶元素\",{\"1\":{\"154\":1}}],[\"弹出队头元素\",{\"1\":{\"154\":1}}],[\"弹出队尾元素\",{\"1\":{\"142\":1}}],[\"默认用户名和密码都是\",{\"1\":{\"185\":1}}],[\"默认均为\",{\"1\":{\"183\":1}}],[\"默认按key排序\",{\"1\":{\"154\":1}}],[\"默认是大根堆\",{\"1\":{\"154\":1}}],[\"默认染成\",{\"1\":{\"92\":1}}],[\"优先队列\",{\"0\":{\"178\":1},\"1\":{\"154\":1},\"2\":{\"181\":1}}],[\"起始下标\",{\"1\":{\"154\":1}}],[\"起点的入度为0\",{\"1\":{\"79\":1}}],[\"字典序\",{\"1\":{\"154\":1}}],[\"字符串\",{\"1\":{\"154\":1}}],[\"字符串哈希\",{\"0\":{\"153\":1}}],[\"字符串以\",{\"1\":{\"144\":1}}],[\"字符串中只包含小写字母\",{\"1\":{\"33\":1}}],[\"清空\",{\"1\":{\"154\":1}}],[\"清零\",{\"1\":{\"67\":1}}],[\"溢出的结果就是取模的结果\",{\"1\":{\"153\":1}}],[\"核心思想\",{\"1\":{\"153\":1}}],[\"核心思路\",{\"1\":{\"104\":1}}],[\"哈希函数\",{\"1\":{\"152\":1}}],[\"哈希函数离散化\",{\"1\":{\"151\":1}}],[\"哈希表\",{\"0\":{\"150\":1},\"1\":{\"154\":1}}],[\"建堆\",{\"1\":{\"149\":1}}],[\"建立一个队列\",{\"1\":{\"85\":1}}],[\"上启动\",{\"1\":{\"186\":1}}],[\"上浮\",{\"1\":{\"149\":1}}],[\"上了\",{\"1\":{\"103\":1}}],[\"跟两个儿子比较大小\",{\"1\":{\"149\":1}}],[\"及其映射关系\",{\"1\":{\"149\":1}}],[\"修改任意一个元素\",{\"1\":{\"149\":1}}],[\"修正为\",{\"1\":{\"111\":2}}],[\"根节点小于等于左右两个子节点\",{\"1\":{\"149\":1}}],[\"根据具体问题\",{\"1\":{\"148\":1}}],[\"根据容斥原理\",{\"1\":{\"123\":1}}],[\"长得非常平衡\",{\"1\":{\"149\":1}}],[\"长度为1的区间为0\",{\"1\":{\"35\":1}}],[\"长度+左端点\",{\"1\":{\"35\":1}}],[\"堆是一棵\",{\"1\":{\"149\":1}}],[\"堆\",{\"0\":{\"149\":1}}],[\"堆优化版的dijkstra算法\",{\"0\":{\"83\":1},\"1\":{\"81\":1}}],[\"维护值和下标\",{\"1\":{\"178\":1}}],[\"维护一个数组集合\",{\"1\":{\"149\":1}}],[\"维护到祖宗节点距离的并查集\",{\"0\":{\"148\":1}}],[\"维护size的并查集\",{\"0\":{\"147\":1}}],[\"维护某种次序\",{\"1\":{\"69\":1}}],[\"假定节点编号是1~n\",{\"1\":{\"146\":1,\"147\":1,\"148\":1}}],[\"假设一定存在\",{\"1\":{\"155\":1}}],[\"假设输入都是正数\",{\"1\":{\"100\":1}}],[\"假设目标值在闭区间\",{\"1\":{\"49\":1}}],[\"又是空节点\",{\"1\":{\"144\":1}}],[\"打印开头下标\",{\"1\":{\"143\":1}}],[\"没找到则返回end\",{\"1\":{\"154\":1}}],[\"没事别叫我\",{\"1\":{\"143\":1}}],[\"没有线程安全问题\",{\"1\":{\"196\":1}}],[\"没有明确结构的数据\",{\"1\":{\"189\":1}}],[\"没有入度\",{\"1\":{\"42\":1}}],[\"没有被访问过\",{\"1\":{\"42\":1}}],[\"没有上司的舞会\",{\"0\":{\"42\":1}}],[\"我做了一款vuepress的音乐可视化播放插件\",{\"1\":{\"167\":1}}],[\"我用数组记录一下你的位置\",{\"1\":{\"143\":1}}],[\"我们只关心\",{\"1\":{\"143\":1}}],[\"我们关心对于每个不同的下标\",{\"1\":{\"143\":1}}],[\"我们需要找出\",{\"1\":{\"143\":1}}],[\"我们讨论的博弈问题一般都只考虑理想情况\",{\"1\":{\"125\":1}}],[\"我们把这种游戏称为nim博弈\",{\"1\":{\"125\":1}}],[\"我们就找到了目标值\",{\"1\":{\"49\":1}}],[\"我们将这样的一种表示称为正整数\",{\"1\":{\"36\":1}}],[\"非结构化数据\",{\"1\":{\"189\":1}}],[\"非常方便\",{\"1\":{\"196\":1}}],[\"非常方便使用\",{\"1\":{\"191\":1}}],[\"非常适合存储大容量的数据\",{\"1\":{\"189\":1}}],[\"非常有意思的说法是\",{\"1\":{\"143\":1}}],[\"非匹配边\",{\"1\":{\"93\":1}}],[\"能走多远\",{\"1\":{\"143\":1}}],[\"串每一个特定的下标\",{\"1\":{\"143\":1}}],[\"普通队列\",{\"0\":{\"141\":1}}],[\"普通栈\",{\"0\":{\"138\":1}}],[\"队头的值\",{\"1\":{\"141\":1}}],[\"队头不断出队\",{\"1\":{\"85\":1}}],[\"队列里面存的是下标\",{\"1\":{\"142\":1}}],[\"队列\",{\"0\":{\"140\":1},\"1\":{\"154\":1}}],[\"永远不会被输出\",{\"1\":{\"139\":2}}],[\"向上返回结果\",{\"1\":{\"172\":1}}],[\"向栈顶插入一个元素\",{\"1\":{\"154\":1}}],[\"向栈顶插入一个数\",{\"1\":{\"138\":1}}],[\"向队尾插入一个元素\",{\"1\":{\"154\":1}}],[\"向队尾插入一个数\",{\"1\":{\"141\":1}}],[\"向哈希表中插入一个数\",{\"1\":{\"151\":1}}],[\"向中间移动\",{\"1\":{\"46\":1}}],[\"栈顶的值\",{\"1\":{\"138\":1}}],[\"栈数组从0开始\",{\"1\":{\"138\":1}}],[\"栈\",{\"0\":{\"137\":1},\"1\":{\"154\":1}}],[\"双端队列\",{\"1\":{\"154\":1}}],[\"双链表\",{\"0\":{\"136\":1}}],[\"双指针算法\",{\"0\":{\"69\":1}}],[\"指定文件路径\",{\"1\":{\"199\":1}}],[\"指定\",{\"1\":{\"183\":1}}],[\"指定数据存放位置\",{\"1\":{\"183\":1}}],[\"指定minio密码\",{\"1\":{\"183\":1}}],[\"指定minio的用户名\",{\"1\":{\"183\":1}}],[\"指定的部分应该是提前排好序的\",{\"1\":{\"155\":1}}],[\"指定的部分上执行二分查找\",{\"1\":{\"155\":1}}],[\"指定的部分进行快速排序\",{\"1\":{\"155\":1}}],[\"指针\",{\"1\":{\"155\":3}}],[\"指向的下一节点\",{\"1\":{\"135\":1}}],[\"指边相对于点不多\",{\"1\":{\"81\":1}}],[\"主要用来优化某些问题\",{\"1\":{\"136\":1}}],[\"主要应用\",{\"1\":{\"135\":1}}],[\"主要步骤\",{\"1\":{\"46\":1,\"47\":1}}],[\"任何一个公平组合游戏都可以转化为有向图游戏\",{\"1\":{\"127\":1}}],[\"任何一个合数都能写成几个质数相乘的形式\",{\"1\":{\"102\":1}}],[\"图像数据\",{\"1\":{\"189\":1}}],[\"图中有一个唯一的起点\",{\"1\":{\"127\":1}}],[\"图的拓扑序列是针对于有向图而言的\",{\"1\":{\"79\":1}}],[\"胜负判定也比较复杂\",{\"1\":{\"126\":1}}],[\"公平组合游戏icg\",{\"0\":{\"126\":1}}],[\"整合\",{\"0\":{\"194\":1}}],[\"整个有向图游戏g的sg函数值被定义为有向图游戏起点s的sg函数值\",{\"1\":{\"129\":1}}],[\"整局游戏第一个行动的称为先手\",{\"1\":{\"125\":1}}],[\"整数分解\",{\"1\":{\"100\":1}}],[\"整数二分\",{\"0\":{\"53\":1}}],[\"问先手是否必胜\",{\"1\":{\"125\":1}}],[\"问区间\",{\"1\":{\"103\":1}}],[\"但对于数据传输的安全性和及时性有较高要求的业务来说\",{\"1\":{\"190\":1}}],[\"但关闭会话服务会停止\",{\"1\":{\"183\":1}}],[\"但城建的棋类游戏\",{\"1\":{\"126\":1}}],[\"但不能不取\",{\"1\":{\"125\":1}}],[\"但归并排序的核心在这一步骤\",{\"1\":{\"46\":1}}],[\"留给后手都是一个必胜状态时\",{\"1\":{\"125\":1}}],[\"留给后手是一个必败状态时\",{\"1\":{\"125\":1}}],[\"某一个操作\",{\"1\":{\"125\":1}}],[\"必须同名\",{\"1\":{\"186\":1}}],[\"必须首先判断两个数是否相等\",{\"1\":{\"67\":1}}],[\"必败状态\",{\"1\":{\"125\":1}}],[\"必胜状态\",{\"1\":{\"125\":1}}],[\"必胜状态和必败状态\",{\"1\":{\"125\":1}}],[\"跳出这轮循环\",{\"1\":{\"123\":1}}],[\"选出右端点最大的\",{\"1\":{\"163\":1}}],[\"选中奇数个集合\",{\"1\":{\"123\":1}}],[\"选中一个集合\",{\"1\":{\"123\":1}}],[\"选中的集合数量\",{\"1\":{\"123\":1}}],[\"选中集合对应质数的乘积\",{\"1\":{\"123\":1}}],[\"选了某个节点就不能选父节点和子节点\",{\"1\":{\"42\":1}}],[\"至少选中一个集合\",{\"1\":{\"123\":1}}],[\"至少需要进行多少次操作\",{\"1\":{\"34\":1}}],[\"容器化\",{\"1\":{\"191\":1}}],[\"容器\",{\"1\":{\"184\":1}}],[\"容斥原理\",{\"0\":{\"123\":1}}],[\"容量为0时\",{\"1\":{\"36\":2}}],[\"它以对象为单位来处理\",{\"1\":{\"190\":1}}],[\"它的\",{\"1\":{\"171\":1}}],[\"它的行动规则是任选某个有向图游戏gi\",{\"1\":{\"130\":1}}],[\"它的一个重要推论是\",{\"1\":{\"114\":1}}],[\"它们按照某种顺序排成长度为2n的序列\",{\"1\":{\"122\":1}}],[\"卡特兰数\",{\"0\":{\"122\":1}}],[\"步骤\",{\"1\":{\"121\":1,\"142\":1}}],[\"方便使用和管理数据\",{\"1\":{\"190\":1}}],[\"方法\",{\"1\":{\"121\":1}}],[\"方程的两边同时乘上一个非00数不改变方程的解\",{\"1\":{\"116\":1}}],[\"方程组中的系数为实数\",{\"1\":{\"116\":1}}],[\"除了通过传统的命令行进行操作之外\",{\"1\":{\"191\":1}}],[\"除了自己\",{\"1\":{\"86\":1}}],[\"除最后一层节点\",{\"1\":{\"149\":1}}],[\"除以\",{\"1\":{\"120\":1}}],[\"请你选择尽量少的区间\",{\"1\":{\"163\":1}}],[\"请你在数轴上选择尽量少的点\",{\"1\":{\"160\":1}}],[\"请你输出\",{\"1\":{\"120\":1}}],[\"请你求出数列中每个数的二进制表示中\",{\"1\":{\"68\":1}}],[\"请你求出\",{\"1\":{\"36\":1,\"123\":1}}],[\"请你求出给定的\",{\"1\":{\"33\":1}}],[\"定理\",{\"1\":{\"120\":1,\"125\":1,\"130\":1}}],[\"定理求组合数\",{\"0\":{\"120\":1}}],[\"定义成小根堆的方式\",{\"1\":{\"154\":1}}],[\"定义有向图游戏g\",{\"1\":{\"130\":1}}],[\"定义sg\",{\"1\":{\"129\":1}}],[\"定义mex\",{\"1\":{\"128\":1}}],[\"定义一个小根堆\",{\"1\":{\"83\":1}}],[\"定义一个借位的情况\",{\"1\":{\"57\":1}}],[\"定义\",{\"1\":{\"67\":2}}],[\"定义区间为闭区间\",{\"1\":{\"52\":1}}],[\"卢卡斯\",{\"0\":{\"120\":1}}],[\"预处理范围内的所有质数\",{\"1\":{\"121\":1}}],[\"预处理阶乘的余数和阶乘逆元的余数\",{\"1\":{\"119\":1}}],[\"预处理出\",{\"1\":{\"112\":1}}],[\"乘积大于n\",{\"1\":{\"123\":1}}],[\"乘任意一个\",{\"1\":{\"119\":1}}],[\"乘法逆元\",{\"1\":{\"119\":1}}],[\"乘法逆元的定义\",{\"1\":{\"119\":1}}],[\"≡\",{\"1\":{\"119\":1}}],[\"费马小定理\",{\"1\":{\"119\":1}}],[\"∗1​=b\",{\"1\":{\"120\":1}}],[\"∗1∗b\",{\"1\":{\"120\":1}}],[\"∗b\",{\"1\":{\"120\":1}}],[\"∗infact\",{\"1\":{\"119\":2}}],[\"∗\",{\"1\":{\"119\":1,\"120\":9}}],[\"∗y\",{\"1\":{\"114\":1}}],[\"递推式\",{\"1\":{\"118\":1}}],[\"递推法求组合数\",{\"0\":{\"118\":1}}],[\"递归结束\",{\"1\":{\"172\":1}}],[\"递归终点\",{\"1\":{\"172\":1}}],[\"递归边界使某数变成了0\",{\"1\":{\"108\":1}}],[\"递归\",{\"0\":{\"172\":1},\"1\":{\"108\":1},\"2\":{\"175\":1}}],[\"递归排序\",{\"1\":{\"47\":1}}],[\"递归的终止情况\",{\"1\":{\"46\":1}}],[\"递归处理子问题\",{\"1\":{\"46\":2}}],[\"递归从后往前更新\",{\"1\":{\"42\":1}}],[\"未确定阶梯型的行\",{\"1\":{\"116\":1}}],[\"未染色的点\",{\"1\":{\"92\":1}}],[\"未染色\",{\"1\":{\"92\":1}}],[\"适用题型\",{\"1\":{\"118\":1}}],[\"适用于求解包含\",{\"1\":{\"116\":1}}],[\"适合存放任意类型的文件\",{\"1\":{\"190\":1}}],[\"适合稀疏图\",{\"1\":{\"81\":1}}],[\"适合稠密图\",{\"1\":{\"81\":1}}],[\"阶梯型矩阵\",{\"1\":{\"116\":1}}],[\"化为\",{\"1\":{\"116\":1}}],[\"列col\",{\"1\":{\"116\":1}}],[\"列\",{\"1\":{\"116\":1}}],[\"列的状态是\",{\"1\":{\"39\":1}}],[\"初等行\",{\"1\":{\"116\":1}}],[\"初始时队列里只有起始点\",{\"1\":{\"85\":1}}],[\"初始化为它自身\",{\"1\":{\"149\":1}}],[\"初始化find\",{\"1\":{\"148\":1}}],[\"初始化各个顶点在不同的集合中\",{\"1\":{\"91\":1}}],[\"初始化\",{\"1\":{\"46\":1,\"75\":1,\"88\":1,\"135\":1,\"136\":1,\"146\":1,\"147\":1,\"148\":1,\"153\":1}}],[\"初始化大于1的区间为最大\",{\"1\":{\"35\":1}}],[\"初始值\",{\"1\":{\"35\":1}}],[\"扩展欧几里得\",{\"1\":{\"115\":1}}],[\"扩展欧几里得算法\",{\"0\":{\"113\":1}}],[\"∀i∈\",{\"1\":{\"115\":1}}],[\"事实上\",{\"1\":{\"114\":1}}],[\"事务中间件\",{\"1\":{\"13\":1}}],[\"显然无解\",{\"1\":{\"114\":1}}],[\"=1\",{\"1\":{\"114\":1}}],[\"−\",{\"1\":{\"114\":1}}],[\"$\",{\"1\":{\"114\":1}}],[\"$gcd\",{\"1\":{\"114\":1}}],[\"​=\",{\"1\":{\"120\":1}}],[\"​=a\",{\"1\":{\"119\":1}}],[\"​\",{\"1\":{\"114\":2,\"119\":1,\"120\":1}}],[\"成立\",{\"1\":{\"114\":1}}],[\"都会被写入到同一个日志文件中\",{\"1\":{\"183\":1}}],[\"都会被写入到这个日志文件中\",{\"1\":{\"183\":1}}],[\"都会输掉游戏\",{\"1\":{\"125\":1}}],[\"都可以是\",{\"1\":{\"154\":1}}],[\"都采取最优策略行动时游戏的结果\",{\"1\":{\"125\":1}}],[\"都一定是\",{\"1\":{\"114\":1}}],[\"都是由男孩子指向女孩子\",{\"1\":{\"93\":1}}],[\"裴蜀定理\",{\"0\":{\"114\":1}}],[\"反之则为\",{\"1\":{\"123\":1}}],[\"反之\",{\"1\":{\"114\":1}}],[\"反之为\",{\"1\":{\"112\":1}}],[\"反证法证明\",{\"1\":{\"99\":1}}],[\"倍增的思想\",{\"1\":{\"154\":1}}],[\"倍\",{\"1\":{\"111\":2}}],[\"共\",{\"1\":{\"111\":1}}],[\"共一行\",{\"1\":{\"68\":1}}],[\"互质时\",{\"1\":{\"119\":1}}],[\"互质的充分必要条件是存在整数\",{\"1\":{\"114\":1}}],[\"互质的数的个数被称为欧拉函数\",{\"1\":{\"110\":1}}],[\"互质\",{\"1\":{\"111\":1,\"119\":2}}],[\"ϕ\",{\"1\":{\"110\":2}}],[\"记\",{\"1\":{\"123\":1}}],[\"记为\",{\"1\":{\"110\":1,\"119\":1}}],[\"记录素数个数\",{\"1\":{\"104\":1}}],[\"记录前缀中各个数字个数\",{\"1\":{\"37\":1}}],[\"记录答案\",{\"1\":{\"37\":1}}],[\"防止溢出\",{\"1\":{\"108\":1}}],[\"辗转相除法时间可以忽略不计\",{\"1\":{\"108\":1}}],[\"辗转相除法\",{\"1\":{\"108\":1}}],[\"欧拉函数的定义\",{\"1\":{\"110\":1}}],[\"欧拉函数\",{\"0\":{\"109\":1}}],[\"欧拉筛\",{\"0\":{\"104\":1}}],[\"欧几里得算法\",{\"1\":{\"108\":1}}],[\"约数之和\",{\"1\":{\"107\":2}}],[\"约数个数\",{\"1\":{\"107\":1}}],[\"约数个数和约数之和\",{\"0\":{\"107\":1}}],[\"约数\",{\"0\":{\"105\":1}}],[\"约数枚举\",{\"1\":{\"100\":1}}],[\"避免和头文件next冲突\",{\"1\":{\"143\":1}}],[\"避免重复筛选\",{\"1\":{\"104\":1}}],[\"避免发生边界问题导致死循环\",{\"1\":{\"46\":1}}],[\"之间的数据是相互隔离的\",{\"1\":{\"196\":1}}],[\"之间的所有数字中\",{\"1\":{\"37\":1}}],[\"之后的尾迭代器\",{\"1\":{\"155\":1}}],[\"之后用\",{\"1\":{\"104\":1}}],[\"线性代数方法解非齐次线性方程组\",{\"1\":{\"116\":1}}],[\"线性筛法求素数\",{\"1\":{\"121\":1}}],[\"线性筛\",{\"0\":{\"104\":1}}],[\"线性dp写法\",{\"1\":{\"29\":1}}],[\"线性dp\",{\"0\":{\"28\":1}}],[\"内容如下\",{\"1\":{\"186\":1}}],[\"内的素数了\",{\"1\":{\"103\":1}}],[\"内有多少个素数\",{\"1\":{\"103\":1}}],[\"也能通过剩余的数据块和校验块恢复原始数据\",{\"1\":{\"191\":1}}],[\"也能使用云存储服务提供的\",{\"1\":{\"190\":1}}],[\"也就是即使你启动了\",{\"1\":{\"183\":1}}],[\"也就是说\",{\"1\":{\"13\":1}}],[\"也称静态链表\",{\"1\":{\"135\":1}}],[\"也可以用来判断奇数和偶数\",{\"1\":{\"112\":1}}],[\"也是\",{\"1\":{\"111\":1}}],[\"也将其倍数从\",{\"1\":{\"103\":1}}],[\"解法\",{\"1\":{\"103\":1}}],[\"剩下的就是质数\",{\"1\":{\"102\":1}}],[\"趋于无穷大时\",{\"1\":{\"102\":1}}],[\"调和级数\",{\"1\":{\"102\":1}}],[\"筛素数\",{\"1\":{\"121\":1}}],[\"筛法求出范围内的所有质数\",{\"1\":{\"121\":1}}],[\"筛法求欧拉函数\",{\"0\":{\"111\":1}}],[\"筛法求素数\",{\"0\":{\"101\":1}}],[\"筛掉它的倍数\",{\"1\":{\"102\":1}}],[\"埃氏筛\",{\"0\":{\"102\":1}}],[\"√n\",{\"1\":{\"100\":3}}],[\"素数测试\",{\"1\":{\"100\":1}}],[\"汇总\",{\"0\":{\"100\":1}}],[\"于是我们发现只有一个大于\",{\"1\":{\"99\":1}}],[\"试除法求所有约数\",{\"0\":{\"106\":1}}],[\"试除法分解质因数\",{\"0\":{\"99\":1}}],[\"试除法判定质数\",{\"0\":{\"98\":1}}],[\"质数定理\",{\"1\":{\"102\":1}}],[\"质数\",{\"0\":{\"97\":1},\"1\":{\"111\":1}}],[\"下载\",{\"1\":{\"185\":1,\"186\":1}}],[\"下载安装包\",{\"1\":{\"183\":1}}],[\"下标从1开始\",{\"1\":{\"143\":1,\"149\":1}}],[\"下标从1开始存\",{\"1\":{\"33\":1}}],[\"下家\",{\"1\":{\"93\":1}}],[\"那它就是一个质数\",{\"1\":{\"102\":1}}],[\"那就匹配并标记\",{\"1\":{\"93\":1}}],[\"那么有没有线程安全问题呢\",{\"1\":{\"196\":1}}],[\"那么再从头开始查找\",{\"1\":{\"152\":1}}],[\"那么对于任意的整数\",{\"1\":{\"114\":1}}],[\"那么相乘会大于\",{\"1\":{\"99\":1}}],[\"那么它就是一个完美匹配\",{\"1\":{\"93\":1}}],[\"那么加上自己之后一共有n+1个点\",{\"1\":{\"86\":1}}],[\"那么最短路可能为负无穷\",{\"1\":{\"84\":1}}],[\"那么\",{\"1\":{\"53\":1,\"102\":1,\"139\":2}}],[\"那么子节点随意\",{\"1\":{\"42\":1}}],[\"那么称这一段数是两个数列的公共上升子序列\",{\"1\":{\"32\":1}}],[\"你可以继续执行其他命令\",{\"1\":{\"183\":1}}],[\"你可能会用到的一些插件\",{\"1\":{\"167\":1}}],[\"你的终端或\",{\"1\":{\"183\":1}}],[\"你只可以看到在滑动窗口内的\",{\"1\":{\"177\":1}}],[\"你有没有备胎\",{\"1\":{\"93\":1}}],[\"你就去问问她男朋友\",{\"1\":{\"93\":1}}],[\"出发的点不算\",{\"1\":{\"93\":1}}],[\"出现了多少次\",{\"1\":{\"53\":1}}],[\"形成的路径叫交替路\",{\"1\":{\"93\":1}}],[\"依次遍历每个区间\",{\"1\":{\"163\":1}}],[\"依次经过非匹配边\",{\"1\":{\"93\":1}}],[\"依次枚举第一个集合中的每个点能否匹配第二个集合中的点\",{\"1\":{\"93\":1}}],[\"依次枚举\",{\"1\":{\"53\":1}}],[\"交换两个点\",{\"1\":{\"149\":1}}],[\"交换两个方程的位置\",{\"1\":{\"116\":1}}],[\"交换两个数\",{\"1\":{\"67\":1}}],[\"交换某两行\",{\"1\":{\"116\":1}}],[\"交替路\",{\"1\":{\"93\":1}}],[\"完成文件夹\",{\"1\":{\"191\":1}}],[\"完全\",{\"1\":{\"149\":1}}],[\"完全背包\",{\"0\":{\"25\":1}}],[\"完美匹配\",{\"1\":{\"93\":1}}],[\"称为这个图的最大匹配\",{\"1\":{\"93\":1}}],[\"匹配完成后的具体操作\",{\"1\":{\"143\":1}}],[\"匹配完我输出一下\",{\"1\":{\"143\":1}}],[\"匹配操作\",{\"1\":{\"143\":1}}],[\"匹配时\",{\"1\":{\"143\":2}}],[\"匹配边\",{\"1\":{\"93\":1}}],[\"匹配\",{\"1\":{\"93\":3}}],[\"匈牙利算法中只会用到从第一个集合指向第二个集合的边\",{\"1\":{\"93\":1}}],[\"匈牙利算法\",{\"0\":{\"93\":1}}],[\"参数\",{\"1\":{\"92\":1}}],[\"遍历\",{\"1\":{\"171\":1}}],[\"遍历所有左端点在l的左边的区间\",{\"1\":{\"163\":1}}],[\"遍历所有点\",{\"1\":{\"92\":1,\"93\":1}}],[\"遍历n个点\",{\"1\":{\"82\":1}}],[\"区分\",{\"1\":{\"92\":1}}],[\"区间覆盖\",{\"0\":{\"163\":1}}],[\"区间分组\",{\"0\":{\"162\":1}}],[\"区间选点\",{\"0\":{\"160\":1}}],[\"区间问题\",{\"0\":{\"159\":1}}],[\"区间筛法\",{\"0\":{\"103\":1}}],[\"区间合并\",{\"0\":{\"71\":1,\"164\":1}}],[\"区间终点\",{\"1\":{\"35\":1}}],[\"区间长度\",{\"1\":{\"35\":1}}],[\"区间\",{\"1\":{\"35\":1}}],[\"区间dp枚举套路\",{\"1\":{\"35\":1}}],[\"区间dp\",{\"0\":{\"35\":1}}],[\"染色失败\",{\"1\":{\"92\":1}}],[\"染色可以使用\",{\"1\":{\"92\":1}}],[\"染色法判别二分图\",{\"0\":{\"92\":1}}],[\"性质\",{\"1\":{\"92\":1,\"139\":1}}],[\"重命名为\",{\"1\":{\"186\":1}}],[\"重定向到标准输出\",{\"1\":{\"183\":1}}],[\"重定向到\",{\"1\":{\"183\":1}}],[\"重载小于运算符\",{\"1\":{\"162\":1}}],[\"重载小于号\",{\"1\":{\"91\":1}}],[\"重载\",{\"1\":{\"155\":1}}],[\"重复执行直到队列为空\",{\"1\":{\"85\":1}}],[\"按照中序遍历的过程\",{\"1\":{\"172\":1}}],[\"按左端点排序\",{\"1\":{\"164\":1}}],[\"按左端点从小到大排序\",{\"1\":{\"162\":1}}],[\"按右端点从小到大排序\",{\"1\":{\"160\":1}}],[\"按字典序\",{\"1\":{\"154\":1}}],[\"按快排的从小到大的顺序遍历每条边\",{\"1\":{\"91\":1}}],[\"按位取反\",{\"1\":{\"67\":1}}],[\"按位异或\",{\"1\":{\"67\":1}}],[\"按位或\",{\"1\":{\"67\":1}}],[\"按位与\",{\"1\":{\"67\":1}}],[\"父节点为它自己\",{\"1\":{\"91\":1}}],[\"权重\",{\"1\":{\"91\":1}}],[\"组询问\",{\"1\":{\"120\":1}}],[\"组成最小生成树\",{\"1\":{\"91\":1}}],[\"组物品和一个容量是\",{\"1\":{\"27\":1}}],[\"值是0x3f3f3f3f\",{\"1\":{\"90\":1}}],[\"距离最近的点\",{\"1\":{\"90\":1}}],[\"距离都初始化为无穷大\",{\"1\":{\"82\":1}}],[\"加1\",{\"1\":{\"143\":1}}],[\"加入到集合中\",{\"1\":{\"91\":1}}],[\"加入到连通块中\",{\"1\":{\"90\":1}}],[\"加边法\",{\"1\":{\"91\":1}}],[\"加到集合当中去\",{\"1\":{\"90\":1}}],[\"加点法\",{\"1\":{\"90\":1}}],[\"加上\",{\"1\":{\"56\":1,\"57\":1}}],[\"叫做求最小生成树\",{\"1\":{\"89\":1}}],[\"换句话来说\",{\"1\":{\"89\":1}}],[\"换成\",{\"1\":{\"51\":1}}],[\"换成a\",{\"1\":{\"51\":1}}],[\"多租户支持\",{\"1\":{\"191\":1}}],[\"多么真实而实用的算法\",{\"1\":{\"93\":1}}],[\"多源汇最短路\",{\"0\":{\"87\":1}}],[\"多重背包\",{\"0\":{\"26\":1}}],[\"原理\",{\"1\":{\"86\":1}}],[\"原因是\",{\"1\":{\"84\":1}}],[\"总点数\",{\"1\":{\"86\":1}}],[\"总点数和总边数\",{\"1\":{\"85\":1}}],[\"总的作用是为处于自己上层的应用软件提供运行与开发的环境\",{\"1\":{\"13\":1}}],[\"平均情况下\",{\"1\":{\"85\":1}}],[\"该命令也会继续执行\",{\"1\":{\"183\":1}}],[\"该函数常用于离散化\",{\"1\":{\"155\":1}}],[\"该游戏被称为有向图游戏\",{\"1\":{\"127\":1}}],[\"该点到它本身的路径赋为0\",{\"1\":{\"85\":1}}],[\"该表格的初始值要赋为极大值\",{\"1\":{\"85\":1}}],[\"该式被称为三角不等式\",{\"1\":{\"84\":1}}],[\"基于\",{\"1\":{\"189\":1,\"191\":1}}],[\"基于平衡二叉树\",{\"1\":{\"154\":1}}],[\"基本思路\",{\"1\":{\"112\":1}}],[\"基本步骤\",{\"1\":{\"85\":1}}],[\"基础算法\",{\"0\":{\"45\":1},\"1\":{\"3\":1}}],[\"路径中至少存在两个相同的点\",{\"1\":{\"84\":1}}],[\"路径的定义是从\",{\"1\":{\"40\":1}}],[\"由两名玩家交替行动\",{\"1\":{\"126\":1}}],[\"由抽屉原理一定有两个点相同\",{\"1\":{\"86\":1}}],[\"由抽屉原理\",{\"1\":{\"84\":1}}],[\"由于某个点染色成功并不代表整个图就是二分图\",{\"1\":{\"92\":1}}],[\"由于是每个点同时向外出发\",{\"1\":{\"84\":1}}],[\"由于在除法运算中\",{\"1\":{\"59\":1}}],[\"``dist\",{\"1\":{\"84\":1}}],[\"影响到下一个点\",{\"1\":{\"84\":1}}],[\"松弛操作\",{\"1\":{\"84\":2}}],[\"如用户\",{\"1\":{\"190\":1}}],[\"如启动信息\",{\"1\":{\"183\":1}}],[\"如\",{\"1\":{\"85\":1,\"143\":1}}],[\"如点\",{\"1\":{\"84\":1}}],[\"如果是\",{\"1\":{\"191\":1}}],[\"如果要使用\",{\"1\":{\"186\":1}}],[\"如果要插在k的左边\",{\"1\":{\"136\":1}}],[\"如果两区间无法合并\",{\"1\":{\"164\":1}}],[\"如果两个连通块不连通\",{\"1\":{\"91\":1}}],[\"如果所有右端点都小于l\",{\"1\":{\"163\":1}}],[\"如果所有点都入队了\",{\"1\":{\"79\":1}}],[\"如果到了末尾\",{\"1\":{\"152\":1}}],[\"如果x不在哈希表中\",{\"1\":{\"152\":1}}],[\"如果x在哈希表中\",{\"1\":{\"152\":1}}],[\"如果比父节点大\",{\"1\":{\"149\":1}}],[\"如果它本身不是最小的数\",{\"1\":{\"149\":1}}],[\"如果它们都包含一段位置不一定连续的数\",{\"1\":{\"32\":1}}],[\"如果窗口满足条件\",{\"1\":{\"142\":1}}],[\"如果取模的数是质数\",{\"1\":{\"119\":1}}],[\"如果满足条件再输出结果\",{\"1\":{\"142\":1}}],[\"如果满足\",{\"1\":{\"119\":1}}],[\"如果存在\",{\"1\":{\"115\":1}}],[\"如果存在负环\",{\"1\":{\"86\":1}}],[\"如果当前数能整除目标数\",{\"1\":{\"106\":1}}],[\"如果最后\",{\"1\":{\"99\":1}}],[\"如果最高位有数\",{\"1\":{\"56\":1}}],[\"如果这个点未被匹配\",{\"1\":{\"93\":1}}],[\"如果在这一轮的匹配中\",{\"1\":{\"93\":1}}],[\"如果你想找的妹子已经有了男朋友\",{\"1\":{\"93\":1}}],[\"如果途径另一个未匹配点\",{\"1\":{\"93\":1}}],[\"如果一个图的某个匹配中\",{\"1\":{\"93\":1}}],[\"如果该数没有被筛掉\",{\"1\":{\"102\":1}}],[\"如果该条边上的两个顶点在一个集合中\",{\"1\":{\"91\":1}}],[\"如果该元素大于栈顶元素\",{\"1\":{\"30\":1}}],[\"如果没有在树中\",{\"1\":{\"90\":1}}],[\"如果图不连通\",{\"1\":{\"90\":1}}],[\"如果图中存在负权回路\",{\"1\":{\"84\":1}}],[\"如果从1号点到x的最短路中包含至少n个点\",{\"1\":{\"86\":1}}],[\"如果从1号点无法走到n号点则返回\",{\"1\":{\"85\":1}}],[\"如果某条最短路径上有n个点\",{\"1\":{\"86\":1}}],[\"如果队列中已存在j\",{\"1\":{\"85\":1}}],[\"如果变短且该点不在队列中\",{\"1\":{\"85\":1}}],[\"如果第n次迭代仍然会松弛三角不等式\",{\"1\":{\"84\":1}}],[\"如果无法从1走到n\",{\"1\":{\"84\":1}}],[\"如果为无穷大\",{\"1\":{\"82\":1}}],[\"如果不能覆盖掉右端点\",{\"1\":{\"160\":1}}],[\"如果不在一个集合中\",{\"1\":{\"91\":1}}],[\"如果不存在\",{\"1\":{\"83\":1}}],[\"如果不存在则返回\",{\"1\":{\"82\":1}}],[\"如果不是起点\",{\"1\":{\"79\":1}}],[\"如果想将一个单元清零\",{\"1\":{\"67\":1}}],[\"如果t\",{\"1\":{\"57\":1}}],[\"如果有两个大于\",{\"1\":{\"99\":1}}],[\"如果有那就使在同一个集合中\",{\"1\":{\"91\":1}}],[\"如果有\",{\"1\":{\"57\":1,\"103\":1}}],[\"如果有一部分遍历完了\",{\"1\":{\"47\":1}}],[\"如果a\",{\"1\":{\"57\":2}}],[\"如果条件成立则记下答案\",{\"1\":{\"52\":1}}],[\"如果\",{\"1\":{\"46\":1,\"57\":1,\"91\":1,\"104\":1,\"107\":1,\"114\":1,\"115\":1,\"119\":1,\"139\":1}}],[\"次后变为一个式子\",{\"1\":{\"115\":1}}],[\"次之后\",{\"1\":{\"84\":1}}],[\"次\",{\"1\":{\"84\":2,\"120\":1}}],[\"次询问\",{\"1\":{\"33\":1}}],[\"迭代地寻找当前节点的左子节点\",{\"1\":{\"173\":1}}],[\"迭代器的++\",{\"1\":{\"154\":1}}],[\"迭代\",{\"0\":{\"173\":1},\"1\":{\"84\":1},\"2\":{\"175\":1}}],[\"具体地\",{\"1\":{\"191\":1}}],[\"具体方法是\",{\"1\":{\"127\":1}}],[\"具体步骤\",{\"1\":{\"84\":1}}],[\"具体问题的逻辑\",{\"1\":{\"69\":1}}],[\"稀疏图改用\",{\"1\":{\"83\":1}}],[\"稀疏图用邻接表\",{\"1\":{\"82\":1}}],[\"寻找距离最小的点\",{\"1\":{\"82\":1}}],[\"寻找两点之间的最大距离\",{\"1\":{\"75\":1}}],[\"直到找到并处理完后\",{\"1\":{\"173\":1}}],[\"直到具有\",{\"1\":{\"91\":1}}],[\"直到第n个点\",{\"1\":{\"82\":1}}],[\"直接将其指向下下个节点\",{\"1\":{\"135\":1}}],[\"直接异或运算进行整数交换后\",{\"1\":{\"67\":1}}],[\"直接搜索数组a和b\",{\"1\":{\"56\":1,\"57\":1}}],[\"访问\",{\"1\":{\"191\":1}}],[\"访问加入集合并标记\",{\"1\":{\"82\":1}}],[\"访问标记\",{\"1\":{\"42\":1}}],[\"逐个遍历\",{\"1\":{\"82\":1}}],[\"逐位压入数组中\",{\"1\":{\"58\":1}}],[\"稠密图用邻接矩阵\",{\"1\":{\"82\":1}}],[\"点的数量\",{\"1\":{\"83\":1}}],[\"点数和边数\",{\"1\":{\"82\":1}}],[\"点多\",{\"1\":{\"81\":1}}],[\"点少边比较多\",{\"1\":{\"81\":1}}],[\"点从\",{\"1\":{\"40\":1}}],[\"边\",{\"1\":{\"84\":1}}],[\"边多\",{\"1\":{\"81\":1}}],[\"边界条件\",{\"1\":{\"37\":1}}],[\"条边为止\",{\"1\":{\"91\":1}}],[\"条边\",{\"1\":{\"81\":1,\"89\":1}}],[\"单词查找树\",{\"1\":{\"144\":1}}],[\"单调栈\",{\"0\":{\"139\":1}}],[\"单调队列\",{\"0\":{\"142\":1,\"179\":1},\"2\":{\"181\":1}}],[\"单调队列思维\",{\"1\":{\"30\":1}}],[\"单调队列写法\",{\"1\":{\"30\":1}}],[\"单链表只能存储当前节点的值和指向下一节点的指针\",{\"1\":{\"135\":1}}],[\"单链表\",{\"0\":{\"135\":1}}],[\"单源最短路\",{\"0\":{\"81\":1}}],[\"说明该节点的子树是空子树\",{\"1\":{\"172\":1}}],[\"说明这个数是它的一个约数\",{\"1\":{\"106\":1}}],[\"说明这就是大于\",{\"1\":{\"99\":1}}],[\"说明此时的\",{\"1\":{\"104\":1}}],[\"说明此时遍历到的\",{\"1\":{\"104\":1}}],[\"说明两个顶点已经连通\",{\"1\":{\"91\":1}}],[\"说明图中存在负权回路\",{\"1\":{\"84\":1}}],[\"说明不连通\",{\"1\":{\"82\":1}}],[\"说明存在拓扑序列\",{\"1\":{\"79\":1}}],[\"说明是叶子节点\",{\"1\":{\"42\":1}}],[\"头尾指针\",{\"1\":{\"79\":1}}],[\"采用数组模拟队列的写法\",{\"1\":{\"79\":1}}],[\"结束\",{\"1\":{\"144\":1}}],[\"结尾\",{\"1\":{\"144\":1}}],[\"结构体存储\",{\"1\":{\"91\":1}}],[\"结论\",{\"1\":{\"79\":1,\"99\":1,\"119\":1}}],[\"结果为零\",{\"1\":{\"67\":1}}],[\"结果才为0\",{\"1\":{\"66\":1}}],[\"结果才为1\",{\"1\":{\"66\":1}}],[\"拓扑排序\",{\"0\":{\"79\":1}}],[\"宽度优先遍历\",{\"0\":{\"78\":1}}],[\"深度优先遍历\",{\"0\":{\"77\":1}}],[\"无论是标准输出还是错误输出\",{\"1\":{\"183\":1}}],[\"无论如何操作\",{\"1\":{\"125\":1}}],[\"无法继续向下处理了\",{\"1\":{\"172\":1}}],[\"无法存储上一节点\",{\"1\":{\"135\":1}}],[\"无法移动者判负\",{\"1\":{\"127\":1}}],[\"无法形成最短路\",{\"1\":{\"82\":1}}],[\"无解\",{\"1\":{\"116\":1}}],[\"无向图\",{\"1\":{\"82\":1}}],[\"无向图是没有拓扑序列的\",{\"1\":{\"79\":1}}],[\"无向图就再写一遍\",{\"1\":{\"75\":1}}],[\"无限次\",{\"1\":{\"25\":1}}],[\"存在乘法逆元的充要条件是\",{\"1\":{\"119\":1}}],[\"存在负权边\",{\"0\":{\"84\":1,\"85\":1},\"1\":{\"81\":1}}],[\"存的是当前加入的边数\",{\"1\":{\"91\":1}}],[\"存的是最小生成树的所有边的权值\",{\"1\":{\"91\":1}}],[\"存入a和b两点之间的距离\",{\"1\":{\"82\":1}}],[\"存边\",{\"1\":{\"75\":1}}],[\"存储桶\",{\"1\":{\"190\":1}}],[\"存储的元数据主要包括对象的描述信息\",{\"1\":{\"190\":1}}],[\"存储和检索数据\",{\"1\":{\"190\":1}}],[\"存储数据的目录路径\",{\"1\":{\"185\":1}}],[\"存储字符串前k个字母的哈希值\",{\"1\":{\"153\":1}}],[\"存储堆中下标是k的点是第几个插入的\",{\"1\":{\"149\":1}}],[\"存储堆中的值\",{\"1\":{\"149\":1}}],[\"存储第k个插入的点在堆中的位置\",{\"1\":{\"149\":1}}],[\"存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\",{\"1\":{\"93\":1}}],[\"存储x到p\",{\"1\":{\"148\":1}}],[\"存储x是否被筛掉\",{\"1\":{\"102\":1,\"104\":1,\"111\":1}}],[\"存储当前用到的下标\",{\"1\":{\"144\":1}}],[\"存储以每个节点结尾的单词数量\",{\"1\":{\"144\":1}}],[\"存储树中每个节点的子节点\",{\"1\":{\"144\":1}}],[\"存储形式如下\",{\"1\":{\"144\":1}}],[\"存储节点的next指针\",{\"1\":{\"135\":1}}],[\"存储节点的值\",{\"1\":{\"135\":1}}],[\"存储图和树\",{\"1\":{\"135\":1}}],[\"存储其他点到当前最小生成树的距离\",{\"1\":{\"90\":1}}],[\"存储1到x的最短路中经过的点数\",{\"1\":{\"86\":1}}],[\"存储1到x的最短路距离\",{\"1\":{\"84\":1}}],[\"存储1号点到x的最短距离\",{\"1\":{\"86\":1}}],[\"存储1号点到每个点的最短距离\",{\"1\":{\"82\":1}}],[\"存储所有质数\",{\"1\":{\"121\":1}}],[\"存储所有素数\",{\"1\":{\"102\":1,\"104\":1,\"111\":1}}],[\"存储所有边\",{\"1\":{\"90\":1}}],[\"存储所有点到1号点的距离\",{\"1\":{\"83\":1}}],[\"存储所有待离散化的值\",{\"1\":{\"70\":1}}],[\"存储每个数是否已被筛掉\",{\"1\":{\"121\":1}}],[\"存储每个数的欧拉函数\",{\"1\":{\"111\":1}}],[\"存储每个质数的次数\",{\"1\":{\"121\":1}}],[\"存储每个点的祖宗节点\",{\"1\":{\"146\":1,\"147\":1,\"148\":1}}],[\"存储每个点的最短距离是否已确定\",{\"1\":{\"83\":1}}],[\"存储每个点的最短路是否已经确定\",{\"1\":{\"82\":1}}],[\"存储每个点是否已经在生成树中\",{\"1\":{\"90\":1}}],[\"存储每个点是否在队列中\",{\"1\":{\"85\":1,\"86\":1}}],[\"存储每个点到1号点的最短距离\",{\"1\":{\"85\":1}}],[\"存储每条边\",{\"1\":{\"82\":1}}],[\"存储点i的入度\",{\"1\":{\"79\":1}}],[\"存储这个单链表的头结点\",{\"1\":{\"75\":1}}],[\"存储k所有可以走到的点\",{\"1\":{\"75\":1}}],[\"存储边\",{\"1\":{\"75\":1}}],[\"存储\",{\"1\":{\"56\":1,\"57\":1,\"149\":1,\"153\":1,\"191\":1}}],[\"邻接表存储图\",{\"1\":{\"92\":1}}],[\"邻接表存储所有边\",{\"1\":{\"83\":1,\"85\":1,\"86\":1,\"93\":1}}],[\"邻接表\",{\"1\":{\"75\":1,\"83\":1,\"135\":1}}],[\"邻接矩阵初始化为无穷大\",{\"1\":{\"82\":1}}],[\"邻接矩阵\",{\"1\":{\"75\":1,\"90\":1}}],[\"动态维护有序序列\",{\"1\":{\"154\":1}}],[\"动态邻接矩阵\",{\"1\":{\"75\":1}}],[\"动态规划\",{\"0\":{\"22\":1},\"1\":{\"3\":1}}],[\"映射到1\",{\"1\":{\"70\":1}}],[\"去重\",{\"1\":{\"155\":2}}],[\"去筛合数时\",{\"1\":{\"104\":1}}],[\"去掉重复元素\",{\"1\":{\"70\":1}}],[\"去除无效状态的优化写法\",{\"1\":{\"39\":1}}],[\"离散化\",{\"0\":{\"70\":1}}],[\"思路二\",{\"0\":{\"173\":1,\"179\":1}}],[\"思路一\",{\"0\":{\"172\":1,\"178\":1}}],[\"思路\",{\"1\":{\"68\":2,\"102\":1,\"111\":1,\"115\":1}}],[\"操作\",{\"0\":{\"198\":1,\"199\":1},\"1\":{\"149\":1}}],[\"操作数每右移一位\",{\"1\":{\"67\":1}}],[\"操作系统\",{\"0\":{\"12\":1},\"1\":{\"8\":1}}],[\"得看被移数是正还是负\",{\"1\":{\"67\":1}}],[\"得到该位的被除数\",{\"1\":{\"59\":1}}],[\"得到总区间的最小代价\",{\"1\":{\"35\":1}}],[\"负数左补\",{\"1\":{\"67\":1}}],[\"负数按补码形式参加按位与运算\",{\"1\":{\"67\":1}}],[\"正数左补\",{\"1\":{\"67\":1}}],[\"设置该存储桶里面的文件的访问策略\",{\"1\":{\"198\":1}}],[\"设置两个头尾指针\",{\"1\":{\"46\":1}}],[\"设g1\",{\"1\":{\"130\":1}}],[\"设从x出发共有k条有向边\",{\"1\":{\"129\":1}}],[\"设s表示一个非负整数集合\",{\"1\":{\"128\":1}}],[\"设\",{\"1\":{\"67\":1}}],[\"逻辑运算符和其他运算符都高\",{\"1\":{\"67\":1}}],[\"逻辑右移\",{\"1\":{\"66\":1}}],[\"关闭终端后服务就会停止\",{\"1\":{\"186\":1}}],[\"关于为什么求\",{\"1\":{\"143\":1}}],[\"关于中间件\",{\"1\":{\"13\":1}}],[\"关系运算符\",{\"1\":{\"67\":1}}],[\"会话也不会被阻塞\",{\"1\":{\"183\":1}}],[\"会随着其他数值而受到影响\",{\"1\":{\"84\":1}}],[\"会导致\",{\"1\":{\"67\":1}}],[\"会对应这个数列的连续一段\",{\"1\":{\"53\":1}}],[\"相邻\",{\"1\":{\"155\":1}}],[\"相关概念\",{\"1\":{\"93\":1}}],[\"相当于文件\",{\"1\":{\"196\":1}}],[\"相当于存放文件的顶层文件夹\",{\"1\":{\"196\":1}}],[\"相当于存在两个相邻的点染成了相同的颜色\",{\"1\":{\"92\":1}}],[\"相当于是每次考虑合并两个式子\",{\"1\":{\"115\":1}}],[\"相当于该数除以\",{\"1\":{\"67\":1}}],[\"相当于该数乘以\",{\"1\":{\"67\":1}}],[\"相同\",{\"1\":{\"155\":1}}],[\"相同数量级的数即可\",{\"1\":{\"84\":1}}],[\"相同为\",{\"1\":{\"67\":1}}],[\"相异或值不变\",{\"1\":{\"67\":1}}],[\"来解决\",{\"1\":{\"68\":1}}],[\"来判断\",{\"1\":{\"67\":1}}],[\"来决定\",{\"1\":{\"67\":1}}],[\"代替\",{\"1\":{\"67\":1}}],[\"代码段\",{\"1\":{\"57\":1}}],[\"代码如下\",{\"1\":{\"56\":1,\"58\":1,\"59\":1,\"68\":2}}],[\"代码\",{\"1\":{\"32\":1,\"34\":1,\"35\":1,\"172\":1,\"173\":1,\"178\":1}}],[\"就要付出较高的公网带宽传输成本\",{\"1\":{\"190\":1}}],[\"就把k改为l\",{\"1\":{\"136\":1}}],[\"就不是公平组合游戏\",{\"1\":{\"126\":1}}],[\"就不是用最小质因子去更新了\",{\"1\":{\"104\":1}}],[\"就可以把埃氏筛法运用在\",{\"1\":{\"103\":1}}],[\"就删去了所有的合数\",{\"1\":{\"102\":1}}],[\"就将这条边加入集合中\",{\"1\":{\"91\":1}}],[\"就得到了最短路径\",{\"1\":{\"85\":1}}],[\"就说明存在一条长度是n+1的最短路径\",{\"1\":{\"84\":1}}],[\"就是判断\",{\"1\":{\"112\":1}}],[\"就是一个质因数\",{\"1\":{\"102\":1}}],[\"就是\",{\"1\":{\"92\":1,\"104\":1}}],[\"就是给定一个无向图\",{\"1\":{\"89\":1}}],[\"就是奇数\",{\"1\":{\"67\":1}}],[\"就是偶数\",{\"1\":{\"67\":1}}],[\"就交换位置\",{\"1\":{\"149\":1}}],[\"就交换\",{\"1\":{\"46\":1}}],[\"进入终端\",{\"1\":{\"185\":1}}],[\"进入到\",{\"1\":{\"185\":1}}],[\"进行数据读写\",{\"1\":{\"190\":1}}],[\"进行\",{\"1\":{\"92\":1}}],[\"进行异或运算\",{\"1\":{\"67\":1}}],[\"进行按位或运算\",{\"1\":{\"67\":1}}],[\"进行按位与运算\",{\"1\":{\"67\":1}}],[\"进位\",{\"1\":{\"56\":1}}],[\"然后在遍历左子树的时候\",{\"1\":{\"171\":1}}],[\"然后访问根节点\",{\"1\":{\"171\":2}}],[\"然后\",{\"1\":{\"120\":1}}],[\"然后重复\",{\"1\":{\"108\":1}}],[\"然后从\",{\"1\":{\"103\":1}}],[\"然后删去它们的所有的倍数\",{\"1\":{\"102\":1}}],[\"然后将\",{\"1\":{\"67\":3}}],[\"然后判断\",{\"1\":{\"46\":1}}],[\"令\",{\"1\":{\"67\":3}}],[\"比如社交评论\",{\"1\":{\"189\":1}}],[\"比如围棋\",{\"1\":{\"126\":1}}],[\"比如归并排序中合并两个有序序列的操作\",{\"1\":{\"69\":1}}],[\"比如\",{\"1\":{\"67\":2,\"68\":1,\"139\":1}}],[\"比如将数\",{\"1\":{\"67\":2}}],[\"比如取数\",{\"1\":{\"67\":1}}],[\"比较左右两半边\",{\"1\":{\"47\":1}}],[\"全部弹出后\",{\"1\":{\"173\":1}}],[\"全部加起来\",{\"1\":{\"36\":1}}],[\"全为\",{\"1\":{\"67\":2}}],[\"算术右移\",{\"1\":{\"66\":1}}],[\"算法步骤\",{\"1\":{\"116\":1}}],[\"算法描述\",{\"1\":{\"93\":1}}],[\"算法结束后\",{\"1\":{\"88\":1}}],[\"算法\",{\"0\":{\"91\":1},\"1\":{\"81\":2}}],[\"算法思路\",{\"1\":{\"49\":1}}],[\"算法笔记\",{\"0\":{\"1\":1}}],[\"各种视频\",{\"1\":{\"189\":1}}],[\"各种图片\",{\"1\":{\"189\":1}}],[\"各编译器处理方法不一样\",{\"1\":{\"66\":1}}],[\"各二进位全部右移若干位\",{\"1\":{\"66\":1}}],[\"各二进位全部左移若干位\",{\"1\":{\"66\":1}}],[\"异或\",{\"1\":{\"66\":1}}],[\"^=\",{\"1\":{\"67\":3,\"125\":1}}],[\"^\",{\"1\":{\"66\":1,\"67\":7,\"125\":3,\"130\":3,\"154\":1}}],[\"与模数\",{\"1\":{\"119\":1}}],[\"与一个各位都为零的数值相与\",{\"1\":{\"67\":1}}],[\"与\",{\"1\":{\"66\":1,\"67\":5,\"118\":1,\"119\":1}}],[\"与快排不同\",{\"1\":{\"47\":1}}],[\"描述\",{\"1\":{\"66\":1}}],[\"符号\",{\"1\":{\"66\":1}}],[\"位整数范围内\",{\"1\":{\"115\":1}}],[\"位上的数是否为\",{\"1\":{\"112\":1}}],[\"位数字移动到最后一位\",{\"1\":{\"68\":1}}],[\"位数\",{\"1\":{\"68\":1}}],[\"位进行翻转\",{\"1\":{\"67\":1}}],[\"位设置为\",{\"1\":{\"67\":1}}],[\"位为\",{\"1\":{\"67\":3}}],[\"位\",{\"1\":{\"67\":4,\"68\":1}}],[\"位运算符作用于位\",{\"1\":{\"66\":1}}],[\"位运算符\",{\"0\":{\"66\":1}}],[\"位运算\",{\"0\":{\"65\":1}}],[\"位于应用与操作系统\",{\"1\":{\"13\":1}}],[\"便于直接对余数进行处理\",{\"1\":{\"59\":1}}],[\"÷\",{\"1\":{\"59\":2}}],[\"倒序输出\",{\"1\":{\"58\":1}}],[\"倒序插入\",{\"1\":{\"58\":1}}],[\"倒序存放\",{\"1\":{\"56\":1,\"57\":1}}],[\"用作云原生应用程序的主要存储\",{\"1\":{\"191\":1}}],[\"用于删除指定存储桶中的对象\",{\"1\":{\"199\":1}}],[\"用于删除一个已存在的存储桶\",{\"1\":{\"198\":1}}],[\"用于列出指定存储桶中的所有对象\",{\"1\":{\"199\":1}}],[\"用于列出用户有权访问的所有存储桶\",{\"1\":{\"198\":1}}],[\"用于从指定的存储桶中下载文件\",{\"1\":{\"199\":1}}],[\"用于生成一个对象\",{\"1\":{\"199\":1}}],[\"用于检查指定的对象\",{\"1\":{\"199\":1}}],[\"用于检查指定的存储桶是否存在\",{\"1\":{\"198\":1}}],[\"用于上传文件到指定的存储桶\",{\"1\":{\"199\":1}}],[\"用于创建一个新的存储桶\",{\"1\":{\"198\":1}}],[\"用于将命令放到后台执行\",{\"1\":{\"183\":1}}],[\"用于运行另一个命令在后台\",{\"1\":{\"183\":1}}],[\"用于求解方程\",{\"1\":{\"114\":1}}],[\"用户名和密码都可以省略\",{\"1\":{\"183\":1}}],[\"用一个小根堆来维护所有组的右端点\",{\"1\":{\"162\":1}}],[\"用一个一维数组存储树\",{\"1\":{\"149\":1}}],[\"用法与\",{\"1\":{\"155\":1}}],[\"用单调队列来优化\",{\"1\":{\"142\":1}}],[\"用高精度乘法将所有质因子相乘\",{\"1\":{\"121\":2}}],[\"用高精度乘法把所有质因子乘上\",{\"1\":{\"121\":1}}],[\"用高精度相乘即可\",{\"1\":{\"121\":1}}],[\"用当前行将下面所有的列消成0\",{\"1\":{\"116\":1}}],[\"用初等行变换\",{\"1\":{\"116\":3}}],[\"用扩展欧几里得算法找出一组解\",{\"1\":{\"115\":1}}],[\"用上面的公式定义求\",{\"1\":{\"110\":1}}],[\"用两数之积除以他们的最大公约数可得最小公倍数\",{\"1\":{\"108\":1}}],[\"用两个指针维护一段区间\",{\"1\":{\"69\":1}}],[\"用最小质因子去筛合数\",{\"1\":{\"104\":1}}],[\"用质数把其所有的倍数都筛掉\",{\"1\":{\"102\":1}}],[\"用队列来存储\",{\"1\":{\"85\":1}}],[\"用t更新其他点的距离\",{\"1\":{\"82\":1}}],[\"用途\",{\"0\":{\"67\":1}}],[\"用\",{\"1\":{\"58\":1,\"59\":1,\"68\":1,\"90\":1,\"92\":1,\"112\":1,\"119\":1,\"154\":1}}],[\"用来处理\",{\"1\":{\"191\":1}}],[\"用来查找小于等于\",{\"1\":{\"51\":1}}],[\"用来查找大于等于\",{\"1\":{\"51\":1}}],[\"用来表示哪一行的小方块是横着放的\",{\"1\":{\"39\":1}}],[\"低精\",{\"1\":{\"58\":1,\"59\":1}}],[\"低位补0\",{\"1\":{\"66\":1}}],[\"低位变为0\",{\"1\":{\"56\":1}}],[\"低位满10向高位进位\",{\"1\":{\"56\":1}}],[\"×a2xt​=a2x1​+2x2​+\",{\"1\":{\"112\":1}}],[\"×pm​pm​−1​\",{\"1\":{\"110\":1}}],[\"×\",{\"1\":{\"58\":3}}],[\"返回存储桶的列表\",{\"1\":{\"198\":1}}],[\"返回布尔值\",{\"1\":{\"198\":1}}],[\"返回指向第一个大于等于\",{\"1\":{\"155\":1}}],[\"返回去重\",{\"1\":{\"155\":1}}],[\"返回有多少个1\",{\"1\":{\"154\":1}}],[\"返回大于x的最小的数的迭代器\",{\"1\":{\"154\":1}}],[\"返回大于等于x的最小的数的迭代器\",{\"1\":{\"154\":1}}],[\"返回某一个数的个数\",{\"1\":{\"154\":1}}],[\"返回前驱和后继\",{\"1\":{\"154\":1}}],[\"返回栈顶元素\",{\"1\":{\"154\":1}}],[\"返回堆顶元素\",{\"1\":{\"154\":1}}],[\"返回队尾元素\",{\"1\":{\"154\":1}}],[\"返回队头元素\",{\"1\":{\"154\":1}}],[\"返回字符串所在字符数组的起始地址\",{\"1\":{\"154\":1}}],[\"返回字符串长度\",{\"1\":{\"154\":1}}],[\"返回子串\",{\"1\":{\"154\":1}}],[\"返回是否为空\",{\"1\":{\"154\":1}}],[\"返回元素个数\",{\"1\":{\"154\":1}}],[\"返回x应该插入的位置\",{\"1\":{\"152\":1}}],[\"返回x的下标\",{\"1\":{\"152\":1}}],[\"返回x的祖宗节点\",{\"1\":{\"146\":1,\"147\":1,\"148\":1}}],[\"返回\",{\"1\":{\"68\":1,\"171\":1,\"177\":1}}],[\"返回a\",{\"1\":{\"57\":1}}],[\"返回true\",{\"1\":{\"57\":2}}],[\"即丢失一半数量的硬盘的情况下仍能保证数据的安全性\",{\"1\":{\"191\":1}}],[\"即输出到\",{\"1\":{\"183\":1}}],[\"即使你退出了终端或关闭了会话\",{\"1\":{\"183\":1}}],[\"即当前节点的父节点\",{\"1\":{\"173\":1}}],[\"即这个迭代器是去重之后末尾元素的下一个位置\",{\"1\":{\"155\":1}}],[\"即小根堆\",{\"1\":{\"149\":1}}],[\"即sg\",{\"1\":{\"129\":1}}],[\"即两人均无失误\",{\"1\":{\"125\":1}}],[\"即为\",{\"1\":{\"119\":1}}],[\"即用二进制来表示\",{\"1\":{\"112\":1}}],[\"即组合成\",{\"1\":{\"112\":1}}],[\"即找到了\",{\"1\":{\"104\":1}}],[\"即源码取反加\",{\"1\":{\"68\":1}}],[\"即除以\",{\"1\":{\"67\":1}}],[\"即乘上\",{\"1\":{\"67\":1}}],[\"即得\",{\"1\":{\"67\":1}}],[\"即\",{\"1\":{\"67\":3,\"68\":2,\"125\":2,\"128\":1,\"129\":1,\"130\":1}}],[\"即t\",{\"1\":{\"57\":1}}],[\"即可得到\",{\"1\":{\"67\":3}}],[\"即可\",{\"1\":{\"52\":1,\"183\":1,\"196\":1}}],[\"若已滑出窗口\",{\"1\":{\"178\":1}}],[\"若两区间部分存在交集\",{\"1\":{\"164\":1}}],[\"若右儿子小于它\",{\"1\":{\"149\":1}}],[\"若左二子小于它\",{\"1\":{\"149\":1}}],[\"若左移时舍弃的高位不包含\",{\"1\":{\"67\":1}}],[\"若从1开始\",{\"1\":{\"143\":1}}],[\"若满足条件\",{\"1\":{\"142\":1}}],[\"若一个游戏满足\",{\"1\":{\"126\":1}}],[\"若在某一局面下存在某种行动\",{\"1\":{\"125\":1}}],[\"若在某一局面下无论采取何种行动\",{\"1\":{\"125\":1}}],[\"若在算数基本定理中\",{\"1\":{\"110\":1}}],[\"若p是质数\",{\"1\":{\"120\":1}}],[\"若整数\",{\"1\":{\"119\":1}}],[\"若\",{\"1\":{\"114\":2}}],[\"若为\",{\"1\":{\"112\":1}}],[\"若不进行备份会因此发生串联效应\",{\"1\":{\"84\":1}}],[\"若t\",{\"1\":{\"57\":1}}],[\"若a大于b\",{\"1\":{\"57\":1}}],[\"判断当前最大值的位置\",{\"1\":{\"178\":1}}],[\"判断当前元素与队尾元素是否满足单调性问题\",{\"1\":{\"142\":2}}],[\"判断是否全为0\",{\"1\":{\"154\":1}}],[\"判断是否至少有一个1\",{\"1\":{\"154\":1}}],[\"判断是否有\",{\"1\":{\"57\":1}}],[\"判断队头是否滑出窗口\",{\"1\":{\"142\":1}}],[\"判断队头是否已经滑出窗口\",{\"1\":{\"142\":1}}],[\"判断队列是否为空\",{\"1\":{\"141\":1}}],[\"判断栈是否为空\",{\"1\":{\"138\":1}}],[\"判断这条边的两个顶点是否有相同的父节点\",{\"1\":{\"91\":1}}],[\"判断\",{\"1\":{\"84\":2,\"91\":1}}],[\"判断奇偶\",{\"1\":{\"67\":1}}],[\"判断b在这一位上有没有数\",{\"1\":{\"57\":1}}],[\"判断可能的答案更新区间\",{\"1\":{\"52\":1}}],[\"满足匹配条件\",{\"1\":{\"143\":1}}],[\"满足任意前缀中0的个数都不少于1的个数的序列的数量为\",{\"1\":{\"122\":1}}],[\"满足\",{\"1\":{\"57\":1,\"115\":1}}],[\"使得每组内部区间两两之间没有交集\",{\"1\":{\"162\":1}}],[\"使得每个区间内至少包含一个选出的点\",{\"1\":{\"160\":1}}],[\"使得行动后对面面临必败局面\",{\"1\":{\"125\":1}}],[\"使得ax\",{\"1\":{\"114\":1}}],[\"使得\",{\"1\":{\"92\":1,\"114\":2,\"119\":1}}],[\"使用stream流读取文件\",{\"1\":{\"199\":1}}],[\"使用的存储桶\",{\"1\":{\"196\":1}}],[\"使用公有云的\",{\"1\":{\"190\":1}}],[\"使用上述命令将\",{\"1\":{\"186\":1}}],[\"使用优先队列\",{\"1\":{\"178\":1}}],[\"使用一个栈\",{\"1\":{\"173\":1}}],[\"使用并查集\",{\"1\":{\"91\":1}}],[\"使用快排将所有边按权值从小到大排序\",{\"1\":{\"91\":1}}],[\"使用邻接矩阵存图\",{\"1\":{\"88\":1}}],[\"使用\",{\"1\":{\"68\":1,\"191\":2,\"196\":1}}],[\"使用auto编译器会自动判断数据是什么类型\",{\"1\":{\"56\":1}}],[\"使\",{\"1\":{\"67\":1,\"114\":2}}],[\"使一个数的最低位为\",{\"1\":{\"67\":1}}],[\"使其全部二进制位为\",{\"1\":{\"67\":1}}],[\"使路径上的数字的和最大\",{\"1\":{\"29\":1}}],[\"例题二\",{\"1\":{\"68\":1}}],[\"例题一\",{\"1\":{\"68\":1}}],[\"例题\",{\"0\":{\"68\":1}}],[\"例如求长度\",{\"1\":{\"69\":1}}],[\"例如求\",{\"1\":{\"68\":1}}],[\"例如\",{\"1\":{\"56\":1,\"57\":1,\"67\":2,\"154\":1}}],[\"例二\",{\"1\":{\"53\":1}}],[\"压入c数组中\",{\"1\":{\"56\":1}}],[\"把一个数组去重\",{\"1\":{\"155\":1}}],[\"把一个\",{\"1\":{\"155\":2}}],[\"把一个方程的若干倍加到另一个方程上去\",{\"1\":{\"116\":1}}],[\"把第k位取反\",{\"1\":{\"154\":1}}],[\"把所有位变成0\",{\"1\":{\"154\":1}}],[\"把所有位置成1\",{\"1\":{\"154\":1}}],[\"把每个局面看成图中的一个节点\",{\"1\":{\"127\":1}}],[\"把游戏过程中面临的状态称为局面\",{\"1\":{\"125\":1}}],[\"把这一行换到最上面\",{\"1\":{\"116\":1}}],[\"把这个让给我好吧\",{\"1\":{\"93\":1}}],[\"把某行的若干倍加到另一行上去\",{\"1\":{\"116\":1}}],[\"把某一行乘一个非00的数\",{\"1\":{\"116\":1}}],[\"把找到的符合条件的点的长度加上\",{\"1\":{\"90\":1}}],[\"把b加入\",{\"1\":{\"85\":1}}],[\"把相加后的结果除以10求余\",{\"1\":{\"56\":1}}],[\"把集合选\",{\"1\":{\"36\":1}}],[\"两名玩家交替地把这枚棋子沿有向边进行移动\",{\"1\":{\"127\":1}}],[\"两名玩家轮流行动\",{\"1\":{\"125\":1}}],[\"两人都采取最优策略\",{\"1\":{\"125\":1}}],[\"两点及其权值\",{\"1\":{\"91\":1}}],[\"两重\",{\"1\":{\"84\":1}}],[\"两个迭代器\",{\"1\":{\"155\":1}}],[\"两个集合\",{\"1\":{\"92\":1}}],[\"两个位相同为0\",{\"1\":{\"66\":1}}],[\"两个位都为0时\",{\"1\":{\"66\":1}}],[\"两个位都为1时\",{\"1\":{\"66\":1}}],[\"两个if把两个数组相同位上的数相加\",{\"1\":{\"56\":1}}],[\"两边递归\",{\"1\":{\"47\":1}}],[\"节省时间\",{\"1\":{\"56\":1,\"57\":1}}],[\"高性能\",{\"1\":{\"190\":1,\"191\":1}}],[\"高斯消元适用解法\",{\"1\":{\"116\":1}}],[\"高斯消元\",{\"0\":{\"116\":1}}],[\"高位补0\",{\"1\":{\"66\":1}}],[\"高位丢弃\",{\"1\":{\"66\":1}}],[\"高位在后面\",{\"1\":{\"57\":1}}],[\"高精\",{\"1\":{\"58\":1,\"59\":1}}],[\"高精度乘低精度模板\",{\"1\":{\"121\":1}}],[\"高精度整数除法\",{\"0\":{\"59\":1}}],[\"高精度整数乘法\",{\"0\":{\"58\":1}}],[\"高精度减法\",{\"0\":{\"57\":1}}],[\"高精度加法\",{\"0\":{\"56\":1}}],[\"高精度算法\",{\"0\":{\"55\":1}}],[\"高效地开发和集成复杂的应用软件\",{\"1\":{\"13\":1}}],[\"取模的数用2^64\",{\"1\":{\"153\":1}}],[\"取模加模再取模\",{\"1\":{\"115\":1}}],[\"取这两个值的冲突概率低\",{\"1\":{\"153\":1}}],[\"取走最后一件物品者获胜\",{\"1\":{\"125\":1}}],[\"取走任意多个物品\",{\"1\":{\"125\":1}}],[\"取出作为\",{\"1\":{\"85\":1}}],[\"取一个数的指定位\",{\"1\":{\"67\":1}}],[\"取反\",{\"1\":{\"66\":1}}],[\"取决于题目对精度的要求\",{\"1\":{\"54\":1}}],[\"取根节点两种方案的最大值\",{\"1\":{\"42\":1}}],[\"检查x是否满足某种性质\",{\"1\":{\"54\":1}}],[\"浮点数二分\",{\"0\":{\"54\":1}}],[\"oss\",{\"1\":{\"190\":3}}],[\"objectname\",{\"1\":{\"199\":1}}],[\"objectwriteresponse2\",{\"1\":{\"199\":1}}],[\"objectwriteresponse\",{\"1\":{\"199\":5}}],[\"object\",{\"0\":{\"199\":1},\"1\":{\"190\":1,\"196\":3,\"199\":6}}],[\"opt\",{\"1\":{\"183\":4}}],[\"operator\",{\"1\":{\"155\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1}}],[\"operator<\",{\"1\":{\"91\":1}}],[\"operation\",{\"1\":{\"67\":1}}],[\"org\",{\"1\":{\"182\":1,\"183\":1,\"189\":1,\"191\":1}}],[\"out\",{\"1\":{\"142\":1,\"198\":3,\"199\":6}}],[\"o\",{\"1\":{\"53\":1,\"76\":1,\"79\":1,\"81\":5,\"82\":1,\"83\":1,\"84\":1,\"85\":2,\"86\":1,\"90\":1,\"91\":3,\"92\":1,\"93\":1,\"98\":1,\"99\":2,\"100\":3,\"102\":1,\"104\":1,\"108\":1,\"112\":1,\"116\":1,\"149\":1,\"154\":4}}],[\"offer\",{\"0\":{\"5\":1,\"203\":1},\"2\":{\"21\":1}}],[\"后续通过注入\",{\"1\":{\"196\":1}}],[\"后续通过调用\",{\"1\":{\"196\":1}}],[\"后台服务安装\",{\"0\":{\"186\":1}}],[\"后台启动\",{\"1\":{\"183\":1}}],[\"后进后出\",{\"1\":{\"140\":1}}],[\"后再减\",{\"1\":{\"57\":1}}],[\"后面一位\",{\"1\":{\"53\":1}}],[\"后缀部分\",{\"1\":{\"37\":1}}],[\"②\",{\"1\":{\"53\":1,\"111\":1}}],[\"①\",{\"1\":{\"53\":1,\"111\":1}}],[\"需要指定存储桶名称和对象键\",{\"1\":{\"199\":1}}],[\"需要指定存储桶的名称\",{\"1\":{\"198\":1}}],[\"需要将其注册为\",{\"1\":{\"186\":1}}],[\"需要保证头结点存在\",{\"1\":{\"135\":1}}],[\"需要借位\",{\"1\":{\"57\":1}}],[\"需要用多重背包的二进制优化方法\",{\"1\":{\"26\":1}}],[\"需使用头文件\",{\"1\":{\"53\":1}}],[\"还提供可视化的操作管理界面\",{\"1\":{\"191\":1}}],[\"还支持\",{\"1\":{\"191\":1}}],[\"还需要补上\",{\"1\":{\"111\":1}}],[\"还是\",{\"1\":{\"52\":1,\"67\":1,\"99\":1}}],[\"还要实现应用之间的互操作\",{\"1\":{\"13\":1}}],[\"改\",{\"1\":{\"52\":1}}],[\"是存储到\",{\"1\":{\"196\":1}}],[\"是存储\",{\"1\":{\"196\":1}}],[\"是第一个支持\",{\"1\":{\"191\":1}}],[\"是全世界内大家都认可的标准\",{\"1\":{\"191\":1}}],[\"是在全球范围内达到共识的对象存储的协议\",{\"1\":{\"191\":1}}],[\"是越界的\",{\"1\":{\"155\":1}}],[\"是堆顶\",{\"1\":{\"149\":1}}],[\"是m个有向图游戏\",{\"1\":{\"130\":1}}],[\"是质数\",{\"1\":{\"120\":1}}],[\"是增广矩阵\",{\"1\":{\"116\":1}}],[\"是整数\",{\"1\":{\"114\":1}}],[\"是\",{\"1\":{\"111\":1,\"185\":1,\"190\":1}}],[\"是满足条件的第一个数\",{\"1\":{\"104\":1}}],[\"是否走到末尾\",{\"1\":{\"143\":1}}],[\"是否能到达\",{\"1\":{\"84\":1}}],[\"是否记下ans\",{\"1\":{\"52\":1}}],[\"是bellman\",{\"1\":{\"81\":1}}],[\"是同一个级别的类型\",{\"1\":{\"81\":1}}],[\"是不是偶数\",{\"1\":{\"67\":1}}],[\"是一个高性能的分布式对象存储系统\",{\"1\":{\"189\":1}}],[\"是一个质数\",{\"1\":{\"119\":1}}],[\"是一个边的集合\",{\"1\":{\"93\":1}}],[\"是一个确定的值\",{\"1\":{\"84\":1}}],[\"是一个二进制数\",{\"1\":{\"39\":1}}],[\"是一类能够为一种或多种应用程序合作互通\",{\"1\":{\"13\":1}}],[\"是一种恢复丢失和损坏数据的数学算法\",{\"1\":{\"191\":1}}],[\"是一种数据存储架构\",{\"1\":{\"190\":1}}],[\"是一种能够高效存储和查找字符串集合的数据结构\",{\"1\":{\"144\":1}}],[\"是一种应用于分布式系统的基础软件\",{\"1\":{\"13\":1}}],[\"是一种独立的系统软件或服务程序\",{\"1\":{\"13\":1}}],[\"是一种在系统软件和用户应用软件之间连接的软件\",{\"1\":{\"13\":1}}],[\"或指针\",{\"1\":{\"155\":3}}],[\"或\",{\"1\":{\"52\":1,\"66\":1,\"92\":1,\"190\":1}}],[\"或者重载\",{\"1\":{\"155\":1}}],[\"或者\",{\"1\":{\"50\":1,\"51\":1,\"67\":1}}],[\"简单来说就是\",{\"1\":{\"51\":1}}],[\"找不到则返回最后一个元素的下标+1\",{\"1\":{\"155\":1}}],[\"找出滑动窗口中的最大值\",{\"1\":{\"142\":1}}],[\"找出每个数左边离它最近的比它大\",{\"1\":{\"139\":1}}],[\"找到后处理并弹出\",{\"1\":{\"173\":1}}],[\"找到每一个数左边离他最近的比它小的数\",{\"1\":{\"139\":1}}],[\"找到绝对值最大的行\",{\"1\":{\"116\":1}}],[\"找到当前列绝对值最大的一行\",{\"1\":{\"116\":1}}],[\"找到最小整数解\",{\"1\":{\"115\":1}}],[\"找到该点赋给\",{\"1\":{\"90\":1}}],[\"找到不在集合当中的最小的点\",{\"1\":{\"90\":1}}],[\"找到一个未加入集合且距离最近的点\",{\"1\":{\"82\":1}}],[\"找到与起点最近的且未确定最短路径的点\",{\"1\":{\"82\":1}}],[\"找到第一个大于等于x的位置\",{\"1\":{\"70\":1}}],[\"找右端点\",{\"1\":{\"51\":1}}],[\"找左端点\",{\"1\":{\"50\":1}}],[\"此时父节点相当于当前节点\",{\"1\":{\"173\":1}}],[\"此时为了防止死循环\",{\"1\":{\"51\":1}}],[\"此处存放自己写和一些优秀的开源项目\",{\"1\":{\"17\":1}}],[\"此处存放前后端常用框架的笔记\",{\"1\":{\"16\":1}}],[\"此处存放一些程序员相关的资源文件\",{\"1\":{\"18\":1}}],[\"此处存放一些计算机大类的笔记\",{\"1\":{\"8\":1}}],[\"此处存放一些关于\",{\"1\":{\"7\":1}}],[\"此处存放刷题时的思路和笔记\",{\"1\":{\"1\":1}}],[\"要求分成若干组\",{\"1\":{\"162\":1}}],[\"要求求解这个方程组\",{\"1\":{\"116\":1}}],[\"要求边长之和最小\",{\"1\":{\"89\":1}}],[\"要求计算\",{\"1\":{\"58\":1,\"59\":1}}],[\"要求计算出所有\",{\"1\":{\"53\":1}}],[\"要求找出一条路径\",{\"1\":{\"29\":1}}],[\"要上取整\",{\"1\":{\"51\":1}}],[\"要向下取整\",{\"1\":{\"50\":1}}],[\"时为偶数\",{\"1\":{\"112\":1}}],[\"时为奇数\",{\"1\":{\"112\":1}}],[\"时才能表示已经将所有点加入到集合中\",{\"1\":{\"91\":1}}],[\"时间复杂度o\",{\"1\":{\"88\":1}}],[\"时间复杂度是\",{\"1\":{\"82\":1,\"83\":1,\"91\":1,\"93\":1,\"154\":1}}],[\"时间复杂度一般为\",{\"1\":{\"81\":1}}],[\"时间复杂度\",{\"1\":{\"76\":1,\"79\":1,\"84\":1,\"85\":1,\"86\":1,\"92\":1,\"154\":1}}],[\"时间复杂度为\",{\"1\":{\"53\":1,\"81\":3,\"90\":1,\"91\":2,\"98\":1,\"99\":1,\"102\":1,\"104\":1,\"112\":1,\"116\":1}}],[\"时需要加\",{\"1\":{\"51\":1}}],[\"时不需要加\",{\"1\":{\"50\":1}}],[\"时\",{\"1\":{\"50\":1,\"51\":1,\"67\":1,\"104\":2,\"111\":1,\"114\":2}}],[\"时用来初始化\",{\"1\":{\"35\":1}}],[\"划分成\",{\"1\":{\"50\":1,\"51\":1}}],[\"当处理的节点是空节点时\",{\"1\":{\"172\":1}}],[\"当然\",{\"1\":{\"155\":1,\"190\":1}}],[\"当且仅当该局面对应节点的sg函数值等于0\",{\"1\":{\"130\":1}}],[\"当且仅当该局面对应节点的sg函数值大于0\",{\"1\":{\"130\":1}}],[\"当且仅当\",{\"1\":{\"125\":1}}],[\"当我们需要求出组合数的真实值\",{\"1\":{\"121\":1}}],[\"当我们将区间\",{\"1\":{\"50\":1,\"51\":1}}],[\"当模数\",{\"1\":{\"119\":1}}],[\"当有\",{\"1\":{\"104\":1}}],[\"当中有\",{\"1\":{\"102\":1}}],[\"当\",{\"1\":{\"49\":1,\"67\":1,\"102\":1,\"104\":1,\"114\":2,\"119\":2}}],[\"当前节点相当于左节点\",{\"1\":{\"173\":1}}],[\"当前节点选\",{\"1\":{\"42\":1}}],[\"当前节点不选\",{\"1\":{\"42\":1}}],[\"当前位置部分\",{\"1\":{\"37\":1}}],[\"合并a和b所在的两个集合\",{\"1\":{\"147\":1,\"148\":1}}],[\"合并x和y所在的两个集合\",{\"1\":{\"146\":1}}],[\"合并两步后\",{\"1\":{\"68\":1}}],[\"合并区间\",{\"1\":{\"47\":1}}],[\"合二为一\",{\"1\":{\"47\":1}}],[\"确定中间分界点\",{\"1\":{\"47\":1}}],[\"确定分界点\",{\"1\":{\"46\":1,\"47\":1}}],[\"对象是单例的\",{\"1\":{\"196\":1}}],[\"对象即可实现对\",{\"1\":{\"196\":1}}],[\"对象\",{\"1\":{\"196\":2}}],[\"对象存储可以作为主存储层\",{\"1\":{\"191\":1}}],[\"对象存储的读\",{\"1\":{\"191\":1}}],[\"对象存储\",{\"1\":{\"190\":1}}],[\"对\",{\"1\":{\"196\":1}}],[\"对用户而言\",{\"1\":{\"196\":2}}],[\"对每个节点的进行相同的递归处理\",{\"1\":{\"172\":1}}],[\"对自定义的结构体\",{\"1\":{\"155\":1}}],[\"对两个迭代器\",{\"1\":{\"155\":1}}],[\"对两个子序列分别设置个指针\",{\"1\":{\"47\":1}}],[\"对字符串也适用\",{\"1\":{\"154\":1}}],[\"对阶乘分解质因数之后\",{\"1\":{\"121\":1}}],[\"对朴素筛法的优化\",{\"1\":{\"102\":1}}],[\"对无符号数\",{\"1\":{\"66\":1}}],[\"对于个人来说\",{\"1\":{\"190\":1}}],[\"对于企业来说\",{\"1\":{\"190\":1}}],[\"对于\",{\"1\":{\"143\":1}}],[\"对于先手来说是一个必败状态\",{\"1\":{\"125\":1}}],[\"对于先手来说是一个必胜状态\",{\"1\":{\"125\":1}}],[\"对于大多数情况\",{\"1\":{\"108\":1}}],[\"对于所有的点都\",{\"1\":{\"84\":1}}],[\"对于每个i\",{\"1\":{\"143\":2}}],[\"对于每个节点x\",{\"1\":{\"129\":1}}],[\"对于每个点k\",{\"1\":{\"75\":1}}],[\"对于每两个式子\",{\"1\":{\"115\":1}}],[\"对于每次询问\",{\"1\":{\"33\":1}}],[\"对于两个序列\",{\"1\":{\"69\":1}}],[\"对于两个数列\",{\"1\":{\"32\":1}}],[\"对于一个序列\",{\"1\":{\"69\":1}}],[\"归并的一般写法如下\",{\"1\":{\"47\":1}}],[\"归并\",{\"1\":{\"47\":1}}],[\"归并每次都将中点作为分界点\",{\"1\":{\"47\":1}}],[\"归并排序\",{\"0\":{\"47\":1}}],[\"先处理这个节点的左子树\",{\"1\":{\"172\":1}}],[\"先进先出\",{\"1\":{\"140\":1}}],[\"先进后出\",{\"1\":{\"137\":1}}],[\"先存值\",{\"1\":{\"135\":1}}],[\"先手走不到任何一个必败状态\",{\"1\":{\"125\":1}}],[\"先手\",{\"1\":{\"125\":1}}],[\"先手可以走到某一个必败状态\",{\"1\":{\"125\":1}}],[\"先手进行\",{\"1\":{\"125\":1}}],[\"先整除再乘\",{\"1\":{\"110\":1}}],[\"先累加\",{\"1\":{\"90\":1}}],[\"先把所有距离初始化为正无穷\",{\"1\":{\"90\":1}}],[\"先把第\",{\"1\":{\"68\":1}}],[\"先对数列排序\",{\"1\":{\"53\":1}}],[\"先递归再合并\",{\"1\":{\"47\":1}}],[\"先枚举长度\",{\"1\":{\"35\":1}}],[\"运行公开的读\",{\"1\":{\"198\":1}}],[\"运行和集成的平台\",{\"1\":{\"13\":1}}],[\"运算符\",{\"1\":{\"155\":2}}],[\"运算符的优先级比算术运算符\",{\"1\":{\"67\":1}}],[\"运算的结果\",{\"1\":{\"129\":1}}],[\"运算\",{\"1\":{\"67\":1}}],[\"运算规则\",{\"1\":{\"66\":1,\"67\":4}}],[\"运用双指针的思想\",{\"1\":{\"47\":1}}],[\"左补\",{\"1\":{\"67\":2}}],[\"左边的二进制位丢弃\",{\"1\":{\"67\":1}}],[\"左半边剩下的\",{\"1\":{\"47\":1}}],[\"左半边的子集\",{\"1\":{\"24\":1}}],[\"左移2位\",{\"1\":{\"67\":1}}],[\"左移\",{\"1\":{\"46\":1,\"66\":1,\"67\":2}}],[\"右儿子相比最小的元素\",{\"1\":{\"149\":1}}],[\"右儿子是2x\",{\"1\":{\"149\":1}}],[\"右边丢弃\",{\"1\":{\"67\":1}}],[\"右边补0\",{\"1\":{\"67\":1}}],[\"右补0\",{\"1\":{\"67\":1}}],[\"右移\",{\"1\":{\"66\":1,\"67\":2,\"68\":1}}],[\"右移和\",{\"1\":{\"46\":1}}],[\"右半边剩下的\",{\"1\":{\"47\":1}}],[\"右端点\",{\"1\":{\"35\":1}}],[\"子串长度\",{\"1\":{\"154\":1}}],[\"子问题合并\",{\"1\":{\"46\":2}}],[\"子节点不能选\",{\"1\":{\"42\":1}}],[\"快速集成快速集成使用\",{\"1\":{\"191\":1}}],[\"快速幂模板\",{\"1\":{\"119\":1,\"120\":1}}],[\"快速幂求逆元\",{\"1\":{\"119\":1}}],[\"快速幂\",{\"0\":{\"112\":1}}],[\"快速排序\",{\"0\":{\"46\":1}}],[\"快排这一步不需要操作\",{\"1\":{\"46\":1}}],[\"快排的一般写法如下\",{\"1\":{\"46\":1}}],[\"快排属于分治算法\",{\"1\":{\"46\":1}}],[\"给你一个整数数组\",{\"1\":{\"177\":1}}],[\"给以\",{\"1\":{\"64\":1}}],[\"给区间\",{\"1\":{\"63\":1}}],[\"给出一串数以及一个数字\",{\"1\":{\"53\":1}}],[\"给父亲更新\",{\"1\":{\"42\":1}}],[\"给定n堆物品\",{\"1\":{\"125\":1}}],[\"给定n个0和n个1\",{\"1\":{\"122\":1}}],[\"给定整数\",{\"1\":{\"103\":1}}],[\"给定一个二叉树的根节点\",{\"1\":{\"171\":1}}],[\"给定一个序列\",{\"1\":{\"139\":1}}],[\"给定一个有向无环图\",{\"1\":{\"127\":1}}],[\"给定一个整数\",{\"1\":{\"123\":1}}],[\"给定一个包含\",{\"1\":{\"116\":1}}],[\"给定一个长度为\",{\"1\":{\"68\":1}}],[\"给定一个如下图所示的数字三角形\",{\"1\":{\"29\":1}}],[\"给定一张\",{\"1\":{\"40\":1}}],[\"给定两个非负整数\",{\"1\":{\"58\":1,\"59\":1}}],[\"给定两个正整数\",{\"1\":{\"56\":1,\"57\":1,\"118\":1}}],[\"给定两个整数\",{\"1\":{\"37\":1}}],[\"给定两个字符串\",{\"1\":{\"34\":1}}],[\"给定两个长度分别为\",{\"1\":{\"31\":1}}],[\"给定\",{\"1\":{\"33\":1,\"115\":1,\"120\":1,\"160\":1,\"162\":1,\"163\":1}}],[\"已访问\",{\"1\":{\"42\":1}}],[\"树的高度\",{\"1\":{\"91\":1,\"146\":1}}],[\"树的根\",{\"1\":{\"42\":1}}],[\"树与图的遍历\",{\"0\":{\"76\":1}}],[\"树与图的存储\",{\"0\":{\"75\":1}}],[\"树形dp\",{\"0\":{\"41\":1}}],[\"入度为0\",{\"1\":{\"42\":1}}],[\"入度\",{\"1\":{\"42\":1}}],[\"user\",{\"1\":{\"196\":1}}],[\"user=admin\",{\"1\":{\"183\":2}}],[\"using\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"42\":1,\"53\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"82\":1,\"90\":1,\"91\":1,\"107\":1,\"115\":1,\"123\":1,\"125\":1,\"143\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"ull\",{\"1\":{\"153\":4}}],[\"uploadobjectargs\",{\"1\":{\"199\":1}}],[\"uploadobject\",{\"1\":{\"199\":1}}],[\"up\",{\"1\":{\"149\":4}}],[\"upper\",{\"1\":{\"53\":3,\"154\":4,\"155\":3}}],[\"unsigned\",{\"1\":{\"153\":1}}],[\"unordered\",{\"1\":{\"107\":1,\"154\":4}}],[\"uninstall\",{\"1\":{\"186\":1}}],[\"unix\",{\"1\":{\"183\":1}}],[\"union\",{\"1\":{\"91\":2,\"146\":1}}],[\"unique\",{\"1\":{\"70\":1,\"154\":1,\"155\":3}}],[\"u表示当前节点\",{\"1\":{\"92\":1}}],[\"u\",{\"1\":{\"42\":16,\"75\":11,\"77\":4,\"92\":3,\"144\":7,\"148\":2,\"149\":17}}],[\"他的下属所能获得的最大快乐值\",{\"1\":{\"42\":2}}],[\"则更新最大值\",{\"1\":{\"178\":1}}],[\"则无解\",{\"1\":{\"163\":1}}],[\"则点数+1\",{\"1\":{\"160\":1}}],[\"则往下沉\",{\"1\":{\"149\":1}}],[\"则最小的数为右儿子\",{\"1\":{\"149\":1}}],[\"则最小的数为左二子\",{\"1\":{\"149\":1}}],[\"则优先采取该行动\",{\"1\":{\"125\":1}}],[\"则系数应该是1\",{\"1\":{\"123\":1}}],[\"则n\",{\"1\":{\"123\":1}}],[\"则对于任意整数\",{\"1\":{\"120\":1}}],[\"则称该游戏为一个公平组合游戏\",{\"1\":{\"126\":1}}],[\"则称该局面必败\",{\"1\":{\"125\":1}}],[\"则称\",{\"1\":{\"119\":1}}],[\"则存在一个整数\",{\"1\":{\"119\":1}}],[\"则有\",{\"1\":{\"119\":1}}],[\"则数据保证\",{\"1\":{\"115\":1}}],[\"则输出结果\",{\"1\":{\"142\":1}}],[\"则输出\",{\"1\":{\"115\":1}}],[\"则可以通过扩展欧几里得来求解\",{\"1\":{\"114\":1}}],[\"则为\",{\"1\":{\"112\":1}}],[\"则pj一定是i的最小公因子\",{\"1\":{\"104\":1}}],[\"则匹配成功\",{\"1\":{\"93\":1}}],[\"则这条交替路称为增广路\",{\"1\":{\"93\":1}}],[\"则这个数出现的次数就可以表示为\",{\"1\":{\"53\":1}}],[\"则加入这条边到集合中\",{\"1\":{\"91\":1}}],[\"则选择该点\",{\"1\":{\"90\":1}}],[\"则说明存在环\",{\"1\":{\"86\":1}}],[\"则不需要将j重复插入\",{\"1\":{\"85\":1}}],[\"则把该点加入到队尾\",{\"1\":{\"85\":1}}],[\"则返回inf\",{\"1\":{\"90\":1}}],[\"则返回true\",{\"1\":{\"86\":1}}],[\"则返回\",{\"1\":{\"83\":1,\"84\":1}}],[\"则\",{\"1\":{\"68\":2,\"110\":1}}],[\"则每左移一位\",{\"1\":{\"67\":1}}],[\"则向高位借位\",{\"1\":{\"57\":1}}],[\"则直接减\",{\"1\":{\"57\":1}}],[\"则减去b\",{\"1\":{\"57\":1}}],[\"则压入c数组中\",{\"1\":{\"56\":1}}],[\"则将这两个连通块合并\",{\"1\":{\"91\":1}}],[\"则将其转化为\",{\"1\":{\"57\":1}}],[\"则将剩余那一部分直接接在临时序列的后面\",{\"1\":{\"47\":1}}],[\"则将该元素入栈\",{\"1\":{\"30\":1}}],[\"则设\",{\"1\":{\"42\":1}}],[\"更新区间\",{\"1\":{\"164\":1}}],[\"更新端点和遍历的区间\",{\"1\":{\"163\":1}}],[\"更新右端点\",{\"1\":{\"160\":1}}],[\"更新t\",{\"1\":{\"90\":1}}],[\"更新其他点到集合的距离\",{\"1\":{\"90\":1}}],[\"更新\",{\"1\":{\"85\":1}}],[\"更新两点之间的最短距离\",{\"1\":{\"84\":1}}],[\"更新第一个点到起点的最短距离\",{\"1\":{\"82\":1}}],[\"更新完一个子节点\",{\"1\":{\"42\":1}}],[\"更新最短距离\",{\"1\":{\"40\":1}}],[\"更新前缀计数器\",{\"1\":{\"37\":1}}],[\"以便可以通过http访问\",{\"1\":{\"199\":1}}],[\"以便于软件各部件之间的沟通\",{\"1\":{\"13\":1}}],[\"以及对数据安全的保障服务\",{\"1\":{\"190\":1}}],[\"以及存储桶索引\",{\"1\":{\"190\":1}}],[\"以及一个线段区间\",{\"1\":{\"163\":1}}],[\"以及所有阶乘取模的逆元infact\",{\"1\":{\"119\":1}}],[\"以second为第二关键字\",{\"1\":{\"154\":1}}],[\"以first为第一关键字\",{\"1\":{\"154\":1}}],[\"以内的素数表的话\",{\"1\":{\"103\":1}}],[\"以内的合数的最小质因数一定不超过\",{\"1\":{\"103\":1}}],[\"以\",{\"1\":{\"62\":1}}],[\"以k为终点的最短距离\",{\"1\":{\"40\":1}}],[\"所在的目录\",{\"1\":{\"185\":1}}],[\"所在目录下启动\",{\"1\":{\"183\":1}}],[\"所谓采取最优策略是指\",{\"1\":{\"125\":1}}],[\"所含匹配边数最多的匹配\",{\"1\":{\"93\":1}}],[\"所得即为商在这一位的数字\",{\"1\":{\"59\":1}}],[\"所以基于对象的形式\",{\"1\":{\"190\":1}}],[\"所以可以用str\",{\"1\":{\"144\":1}}],[\"所以idx从2开始\",{\"1\":{\"136\":1}}],[\"所以是乘\",{\"1\":{\"120\":1}}],[\"所以有\",{\"1\":{\"114\":1}}],[\"所以此时应该退出循环\",{\"1\":{\"104\":1}}],[\"所以\",{\"1\":{\"104\":1,\"114\":1}}],[\"所以先预处理好\",{\"1\":{\"103\":1}}],[\"所以这里只用存一个方向的边\",{\"1\":{\"93\":1}}],[\"所以存边的时候\",{\"1\":{\"93\":1}}],[\"所以存在环\",{\"1\":{\"86\":1}}],[\"所以需要将其翻转\",{\"1\":{\"59\":1}}],[\"所以从后遍历\",{\"1\":{\"57\":1}}],[\"所以一直更新根就行了\",{\"1\":{\"42\":1}}],[\"所以f\",{\"1\":{\"40\":1}}],[\"所以初始化为无穷大\",{\"1\":{\"40\":1}}],[\"所有节点均不为空\",{\"1\":{\"149\":1}}],[\"所有数的个数为各个集合的并集\",{\"1\":{\"123\":1}}],[\"所有的顶点都是匹配点\",{\"1\":{\"93\":1}}],[\"所有的区间dp问题枚举时\",{\"1\":{\"35\":1}}],[\"所有边\",{\"1\":{\"84\":1,\"92\":1}}],[\"所有边权都是正数\",{\"1\":{\"81\":1}}],[\"所有将a\",{\"1\":{\"34\":1}}],[\"因为存的都是英文字母\",{\"1\":{\"144\":1}}],[\"因为本质是一样的\",{\"1\":{\"143\":1}}],[\"因为围棋交战双方分别只能落黑子和白子\",{\"1\":{\"126\":1}}],[\"因为从\",{\"1\":{\"120\":1}}],[\"因为我们是从小到大遍历的\",{\"1\":{\"104\":1}}],[\"因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化\",{\"1\":{\"93\":1}}],[\"因为你要去问的都是男孩子\",{\"1\":{\"93\":1}}],[\"因为再给边排序的时候是按照边的权重进行排序的\",{\"1\":{\"91\":1}}],[\"因为\",{\"1\":{\"67\":1,\"103\":1,\"114\":1}}],[\"因为是倒序数组\",{\"1\":{\"57\":1}}],[\"因为剩下的这部分一定是大于前面的\",{\"1\":{\"47\":1}}],[\"因为零是起点\",{\"1\":{\"40\":1}}],[\"因为要求最小值\",{\"1\":{\"40\":1}}],[\"因此利用迭代的思想\",{\"1\":{\"173\":1}}],[\"因此可以递推的每次乘\",{\"1\":{\"120\":1}}],[\"因此可以用\",{\"1\":{\"67\":1}}],[\"因此最终结果\",{\"1\":{\"111\":1}}],[\"因此不仅需要将基数\",{\"1\":{\"111\":1}}],[\"因此只有某个点染色失败才能立刻\",{\"1\":{\"92\":1}}],[\"因此需要对\",{\"1\":{\"84\":1}}],[\"因此前导0在数组前面\",{\"1\":{\"59\":1}}],[\"因此\",{\"1\":{\"36\":1,\"104\":1,\"111\":1}}],[\"走交替路\",{\"1\":{\"93\":1}}],[\"走过的所有点的情况是\",{\"1\":{\"40\":1}}],[\"走到\",{\"1\":{\"40\":1}}],[\"到\",{\"1\":{\"40\":1,\"102\":1,\"120\":1,\"123\":1}}],[\"到终点和我说声\",{\"1\":{\"143\":1}}],[\"到终点\",{\"1\":{\"40\":1}}],[\"hot\",{\"0\":{\"206\":1}}],[\"hot100\",{\"2\":{\"174\":1,\"180\":1}}],[\"hdfs\",{\"1\":{\"191\":1}}],[\"hadoop\",{\"1\":{\"191\":1}}],[\"hao\",{\"1\":{\"191\":1}}],[\"hamilton\",{\"1\":{\"40\":1}}],[\"http\",{\"1\":{\"185\":1,\"189\":1,\"190\":1,\"196\":1}}],[\"https\",{\"1\":{\"182\":3,\"183\":1,\"185\":1,\"186\":1,\"189\":1,\"190\":1,\"191\":4}}],[\"hup\",{\"1\":{\"183\":1}}],[\"hp\",{\"1\":{\"149\":6}}],[\"head\",{\"1\":{\"135\":6}}],[\"head存储链表头\",{\"1\":{\"135\":1}}],[\"heap表示堆\",{\"1\":{\"149\":1}}],[\"heap\",{\"1\":{\"83\":6,\"149\":10,\"162\":7}}],[\"hh++\",{\"1\":{\"79\":1,\"141\":1,\"142\":1}}],[\"hh\",{\"1\":{\"79\":2,\"141\":4,\"142\":4}}],[\"h\",{\"1\":{\"75\":10,\"77\":1,\"78\":1,\"79\":1,\"83\":4,\"85\":4,\"86\":2,\"92\":2,\"93\":2,\"149\":11,\"151\":4,\"152\":3,\"153\":6}}],[\"h>\",{\"1\":{\"37\":1,\"42\":1,\"90\":1,\"91\":1}}],[\"标准兼容\",{\"1\":{\"191\":1}}],[\"标准件\",{\"1\":{\"13\":1}}],[\"标记\",{\"1\":{\"104\":1}}],[\"标记点是否在队列中\",{\"1\":{\"85\":1}}],[\"标记为已加入到集合中\",{\"1\":{\"82\":1}}],[\"标记为0\",{\"1\":{\"57\":1}}],[\"标记为1\",{\"1\":{\"57\":1}}],[\"标号\",{\"1\":{\"40\":1}}],[\"|\",{\"1\":{\"39\":1,\"66\":1,\"67\":6,\"119\":1,\"154\":1}}],[\"||\",{\"1\":{\"39\":1,\"56\":1,\"58\":1,\"82\":1,\"90\":1,\"93\":1,\"155\":1,\"162\":1}}],[\"其实隐式地维护了一个栈结构\",{\"1\":{\"173\":1}}],[\"其余所有的数字依次跟着变化\",{\"1\":{\"116\":1}}],[\"其余位为\",{\"1\":{\"67\":3}}],[\"其表达式为\",{\"1\":{\"68\":1}}],[\"其更新操作是\",{\"1\":{\"50\":1,\"51\":1}}],[\"其位数和棋盘的行数一致\",{\"1\":{\"39\":1}}],[\"其中元素x\",{\"1\":{\"149\":1}}],[\"其中任意两条边都不依附于同一个顶点\",{\"1\":{\"93\":1}}],[\"其中的第\",{\"1\":{\"68\":1}}],[\"其中一个作为分界点\",{\"1\":{\"46\":1}}],[\"其中\",{\"1\":{\"39\":1,\"68\":1,\"120\":1,\"185\":1}}],[\"其中i为数字个数\",{\"1\":{\"37\":2}}],[\"小的合并到大的中\",{\"1\":{\"164\":1}}],[\"小的数\",{\"1\":{\"139\":1}}],[\"小于号\",{\"1\":{\"155\":2}}],[\"小于eps视为0\",{\"1\":{\"116\":1}}],[\"小技巧\",{\"1\":{\"153\":1}}],[\"小方格的种类数\",{\"1\":{\"39\":1}}],[\"小沐沐要你来告诉奶牛什么是最长公共上升子序列\",{\"1\":{\"32\":1}}],[\"小沐沐说\",{\"1\":{\"32\":1}}],[\"小沐沐先让奶牛研究了最长上升子序列\",{\"1\":{\"32\":1}}],[\"状态更新等\",{\"1\":{\"183\":1}}],[\"状态表示\",{\"1\":{\"39\":1}}],[\"状态压缩类dp\",{\"0\":{\"38\":1}}],[\"状态转移方程\",{\"1\":{\"29\":1,\"30\":1,\"31\":1,\"34\":2,\"40\":1,\"42\":1}}],[\"throw\",{\"1\":{\"199\":1}}],[\"throws\",{\"1\":{\"198\":4,\"199\":6}}],[\"test10\",{\"1\":{\"199\":1}}],[\"test2\",{\"1\":{\"199\":1}}],[\"test\",{\"1\":{\"199\":5}}],[\"test09\",{\"1\":{\"199\":1}}],[\"test08\",{\"1\":{\"199\":1}}],[\"test07\",{\"1\":{\"199\":1}}],[\"test06\",{\"1\":{\"199\":1}}],[\"test05\",{\"1\":{\"199\":1}}],[\"test04\",{\"1\":{\"198\":1}}],[\"test03\",{\"1\":{\"198\":1}}],[\"test02\",{\"1\":{\"198\":1}}],[\"test01\",{\"1\":{\"198\":1}}],[\"tensorflow\",{\"1\":{\"191\":1}}],[\"template\",{\"0\":{\"204\":1}}],[\"temp\",{\"1\":{\"47\":6}}],[\"timeunit\",{\"1\":{\"199\":1}}],[\"time\",{\"1\":{\"186\":1}}],[\"tips\",{\"1\":{\"93\":1}}],[\"t表示该元素与它的左\",{\"1\":{\"149\":1}}],[\"try\",{\"1\":{\"199\":1}}],[\"transferto\",{\"1\":{\"199\":1}}],[\"trie树存储形式\",{\"1\":{\"144\":1}}],[\"trie树又称字典树\",{\"1\":{\"144\":1}}],[\"trie树\",{\"0\":{\"144\":1}}],[\"true\",{\"1\":{\"37\":1,\"39\":1,\"57\":1,\"77\":1,\"78\":2,\"82\":1,\"83\":1,\"85\":2,\"86\":3,\"90\":1,\"92\":2,\"93\":2,\"98\":1,\"102\":1,\"103\":4,\"104\":2,\"111\":1,\"112\":2,\"121\":1,\"151\":1,\"163\":1}}],[\"t为当前这种状态的集合数量\",{\"1\":{\"123\":1}}],[\"t为余数\",{\"1\":{\"59\":1}}],[\"ture\",{\"1\":{\"90\":1}}],[\"tt表示队尾\",{\"1\":{\"141\":1}}],[\"tt表示栈顶\",{\"1\":{\"138\":1}}],[\"tt\",{\"1\":{\"79\":3,\"138\":4,\"139\":4,\"141\":3,\"142\":5}}],[\"tool\",{\"0\":{\"205\":1}}],[\"top\",{\"1\":{\"83\":1,\"154\":2,\"162\":1,\"178\":3}}],[\"topsort\",{\"1\":{\"79\":1}}],[\"tot\",{\"1\":{\"53\":3}}],[\"t再除以10\",{\"1\":{\"56\":1}}],[\"typedef\",{\"1\":{\"39\":1,\"107\":1,\"153\":1}}],[\"t\",{\"1\":{\"37\":4,\"56\":7,\"57\":11,\"58\":5,\"59\":9,\"78\":2,\"79\":2,\"82\":7,\"83\":3,\"85\":9,\"86\":6,\"90\":16,\"107\":4,\"111\":4,\"116\":5,\"121\":7,\"123\":8,\"149\":8,\"162\":4}}],[\"policyjsonstring\",{\"1\":{\"198\":2}}],[\"pop\",{\"1\":{\"57\":1,\"58\":1,\"59\":1,\"78\":1,\"83\":1,\"85\":2,\"86\":1,\"154\":6,\"162\":1,\"178\":1}}],[\"presignedobjecturl\",{\"1\":{\"199\":2}}],[\"presto\",{\"1\":{\"191\":1}}],[\"prefix\",{\"1\":{\"196\":1}}],[\"principal\",{\"1\":{\"198\":1}}],[\"println\",{\"1\":{\"198\":3,\"199\":6}}],[\"printf\",{\"1\":{\"37\":1,\"42\":1,\"56\":1,\"57\":3,\"58\":1,\"75\":1,\"90\":1,\"115\":1,\"143\":1}}],[\"print\",{\"1\":{\"37\":2}}],[\"private\",{\"1\":{\"196\":5}}],[\"primes2\",{\"1\":{\"103\":4}}],[\"primes\",{\"1\":{\"102\":4,\"103\":3,\"104\":17,\"107\":4,\"111\":21,\"121\":9}}],[\"prime\",{\"1\":{\"98\":1,\"100\":2,\"103\":2,\"104\":1}}],[\"prim\",{\"1\":{\"90\":2}}],[\"priority\",{\"1\":{\"83\":1,\"154\":2,\"162\":1,\"178\":1}}],[\"player\",{\"1\":{\"167\":1}}],[\"plugin\",{\"1\":{\"167\":1}}],[\"p的经验值是131或13331\",{\"1\":{\"153\":1}}],[\"ph\",{\"1\":{\"149\":4}}],[\"phi\",{\"1\":{\"110\":1,\"111\":5}}],[\"p+1\",{\"1\":{\"143\":1}}],[\"p为匹配串\",{\"1\":{\"143\":1}}],[\"pi​​\",{\"1\":{\"123\":1}}],[\"pii\",{\"1\":{\"83\":1,\"164\":1}}],[\"pm​​\",{\"1\":{\"123\":1}}],[\"pm​\",{\"1\":{\"123\":1}}],[\"pmam​​\",{\"1\":{\"110\":1}}],[\"p2​\",{\"1\":{\"123\":2}}],[\"p2^c2\",{\"1\":{\"107\":1}}],[\"p1​\",{\"1\":{\"123\":2}}],[\"p1^1\",{\"1\":{\"107\":1}}],[\"p1^0\",{\"1\":{\"107\":1}}],[\"p1^c1\",{\"1\":{\"107\":2}}],[\"p^k\",{\"1\":{\"153\":1}}],[\"p^3\",{\"1\":{\"121\":1}}],[\"p^2\",{\"1\":{\"121\":1}}],[\"p​∗cpa​pb​​\",{\"1\":{\"120\":1}}],[\"pk^1\",{\"1\":{\"107\":1}}],[\"pk^0\",{\"1\":{\"107\":1}}],[\"pk^ck\",{\"1\":{\"107\":2}}],[\"pj=0\",{\"1\":{\"104\":1}}],[\"pj一定是pj\",{\"1\":{\"104\":1}}],[\"pb\",{\"1\":{\"91\":2,\"120\":1}}],[\"pattern>\",{\"1\":{\"186\":1}}],[\"password=password\",{\"1\":{\"183\":2}}],[\"pa\",{\"1\":{\"91\":2}}],[\"pair<int\",{\"1\":{\"83\":1,\"154\":1,\"164\":1}}],[\"python\",{\"1\":{\"191\":1}}],[\"py\",{\"1\":{\"91\":6,\"146\":6,\"191\":1}}],[\"px\",{\"1\":{\"91\":7,\"146\":6}}],[\"p\",{\"1\":{\"91\":8,\"107\":3,\"112\":5,\"119\":5,\"120\":31,\"121\":8,\"123\":4,\"143\":7,\"144\":11,\"146\":8,\"147\":8,\"148\":9,\"153\":8,\"184\":2}}],[\"putobjectargs\",{\"1\":{\"199\":1}}],[\"putobject\",{\"1\":{\"199\":2}}],[\"puts\",{\"1\":{\"37\":1,\"90\":1,\"115\":1,\"125\":2}}],[\"pull\",{\"1\":{\"184\":1}}],[\"publicread\",{\"1\":{\"198\":1}}],[\"public\",{\"1\":{\"178\":1,\"196\":3}}],[\"push\",{\"1\":{\"26\":2,\"30\":2,\"37\":2,\"39\":1,\"56\":4,\"57\":3,\"58\":2,\"59\":2,\"71\":2,\"75\":2,\"78\":2,\"83\":2,\"85\":2,\"86\":2,\"100\":2,\"106\":2,\"121\":3,\"154\":6,\"162\":2,\"164\":3,\"178\":3}}],[\"yml\",{\"1\":{\"196\":1}}],[\"yk\",{\"1\":{\"129\":3}}],[\"yes\",{\"1\":{\"125\":1}}],[\"y是分母\",{\"1\":{\"120\":1}}],[\"y=x\",{\"1\":{\"114\":1}}],[\"y=0\",{\"1\":{\"114\":1}}],[\"y2\",{\"1\":{\"62\":3,\"64\":3,\"129\":3}}],[\"y1\",{\"1\":{\"62\":3,\"64\":3,\"129\":1}}],[\"y\",{\"1\":{\"37\":2,\"67\":17,\"91\":2,\"108\":1,\"114\":10,\"115\":4,\"120\":4,\"139\":1,\"146\":2,\"155\":4}}],[\"这种机制使得即使部分磁盘发生故障\",{\"1\":{\"191\":1}}],[\"这种写法包含了两种情况\",{\"1\":{\"57\":1}}],[\"这就意味着个人也可以基于\",{\"1\":{\"190\":1}}],[\"这部分是将标准错误输出\",{\"1\":{\"183\":1}}],[\"这部分是将标准输出\",{\"1\":{\"183\":1}}],[\"这意味着\",{\"1\":{\"183\":1}}],[\"这是一个\",{\"1\":{\"183\":1}}],[\"这样的设计\",{\"1\":{\"191\":1}}],[\"这样的局面被称为必胜\",{\"1\":{\"125\":1}}],[\"这样\",{\"1\":{\"183\":1}}],[\"这样直接用unsigned\",{\"1\":{\"153\":1}}],[\"这样当两个边进行比较的时候就会使用他们的权重进行比较了\",{\"1\":{\"91\":1}}],[\"这\",{\"1\":{\"112\":2}}],[\"这一项\",{\"1\":{\"111\":1}}],[\"这一项在\",{\"1\":{\"111\":1}}],[\"这一步类似完全背包的推导\",{\"1\":{\"36\":1}}],[\"这条边不要\",{\"1\":{\"91\":1}}],[\"这个符号是在命令的末尾\",{\"1\":{\"183\":1}}],[\"这个公式求出每个质因子的次数\",{\"1\":{\"121\":1}}],[\"这个步骤\",{\"1\":{\"108\":1}}],[\"这个点还未被匹配\",{\"1\":{\"93\":1}}],[\"这个集合指当前已经在连通块中的所有点\",{\"1\":{\"90\":1}}],[\"这个数本身\",{\"1\":{\"37\":1}}],[\"这里使用库函数二分的写法\",{\"1\":{\"53\":1}}],[\"xml\",{\"1\":{\"186\":3}}],[\"x64\",{\"1\":{\"186\":1}}],[\"x的左儿子是2x\",{\"1\":{\"149\":1}}],[\"x属于自然数\",{\"1\":{\"128\":1}}],[\"x是分子\",{\"1\":{\"120\":1}}],[\"x≡mi​\",{\"1\":{\"115\":1}}],[\"x=y\",{\"1\":{\"114\":1}}],[\"x=1\",{\"1\":{\"114\":1}}],[\"x2\",{\"1\":{\"62\":3,\"64\":3}}],[\"x1\",{\"1\":{\"62\":3,\"64\":3}}],[\"x\",{\"1\":{\"37\":13,\"46\":3,\"50\":1,\"51\":4,\"54\":1,\"67\":14,\"68\":18,\"70\":2,\"84\":1,\"86\":2,\"91\":8,\"93\":3,\"98\":5,\"99\":7,\"102\":1,\"104\":1,\"106\":5,\"107\":7,\"108\":1,\"110\":9,\"111\":1,\"114\":9,\"115\":9,\"119\":4,\"120\":4,\"125\":3,\"128\":1,\"129\":2,\"135\":3,\"136\":2,\"138\":1,\"139\":1,\"141\":1,\"146\":8,\"147\":6,\"148\":10,\"149\":4,\"151\":6,\"152\":3,\"154\":2,\"155\":12}}],[\"循环出口\",{\"1\":{\"163\":1}}],[\"循环\",{\"1\":{\"84\":2}}],[\"循环变量i可以表示剩下的数字有多少个\",{\"1\":{\"37\":1}}],[\"循环从1开始\",{\"1\":{\"37\":1}}],[\"统计叶子节点\",{\"1\":{\"37\":1}}],[\"统计大于10\",{\"1\":{\"37\":1}}],[\"统计1\",{\"1\":{\"37\":1}}],[\"包含\",{\"1\":{\"68\":1}}],[\"包含前导零\",{\"1\":{\"37\":1}}],[\"包括但不限于\",{\"1\":{\"189\":1}}],[\"包括但不限于书籍\",{\"1\":{\"18\":1}}],[\"包括负权边\",{\"1\":{\"84\":1}}],[\"包括编程语言\",{\"1\":{\"8\":1}}],[\"包括算法题\",{\"1\":{\"1\":1}}],[\"9<\",{\"1\":{\"195\":1}}],[\"9000\",{\"1\":{\"184\":2,\"185\":1,\"196\":1}}],[\"9001\",{\"1\":{\"183\":3,\"184\":3,\"185\":1}}],[\"99\",{\"1\":{\"37\":3}}],[\"9\",{\"0\":{\"71\":1,\"123\":1,\"154\":1},\"1\":{\"37\":19}}],[\"~x\",{\"1\":{\"68\":1}}],[\"~0\",{\"1\":{\"67\":1}}],[\"~1\",{\"1\":{\"67\":3}}],[\"~\",{\"1\":{\"37\":1,\"40\":1,\"66\":1,\"67\":2,\"99\":1,\"102\":1,\"111\":1,\"123\":2,\"153\":1,\"154\":1,\"155\":4}}],[\"特点\",{\"0\":{\"191\":1}}],[\"特别地\",{\"1\":{\"114\":1,\"129\":1}}],[\"特别是应用软件对于系统软件的集中的逻辑\",{\"1\":{\"13\":1}}],[\"特判最中间的数\",{\"1\":{\"106\":1}}],[\"特殊\",{\"1\":{\"36\":1}}],[\"前台启动\",{\"1\":{\"183\":1}}],[\"前置知识\",{\"1\":{\"116\":1}}],[\"前缀和与差分\",{\"0\":{\"60\":1}}],[\"前缀部分\",{\"1\":{\"37\":1}}],[\"前提\",{\"1\":{\"57\":1}}],[\"前\",{\"1\":{\"36\":2}}],[\"朴素并查集\",{\"0\":{\"146\":1}}],[\"朴素筛法\",{\"0\":{\"102\":1}}],[\"朴素prim算法\",{\"0\":{\"90\":1}}],[\"朴素版\",{\"0\":{\"82\":1}}],[\"朴素版的dijkstra算法\",{\"1\":{\"81\":1}}],[\"朴素做法\",{\"1\":{\"36\":1}}],[\"朴素dp写法\",{\"1\":{\"30\":1}}],[\"恰好拼成\",{\"1\":{\"36\":1}}],[\"计算子串\",{\"1\":{\"153\":1}}],[\"计算公式如下\",{\"1\":{\"123\":1}}],[\"计算起始点经过队头到其他点的距离是否变短\",{\"1\":{\"85\":1}}],[\"计算结果可能为负数\",{\"1\":{\"57\":1}}],[\"计算它们的差\",{\"1\":{\"57\":1}}],[\"计算它们的和\",{\"1\":{\"56\":1}}],[\"计算\",{\"1\":{\"50\":1,\"51\":1}}],[\"计算机网络\",{\"0\":{\"11\":1},\"1\":{\"8\":1}}],[\"计算机\",{\"0\":{\"8\":1}}],[\"计数类dp\",{\"0\":{\"36\":1}}],[\"枚举当前状态的每一位\",{\"1\":{\"123\":1}}],[\"枚举每一列c\",{\"1\":{\"116\":1}}],[\"枚举\",{\"1\":{\"102\":1}}],[\"枚举分割点\",{\"1\":{\"35\":1}}],[\"枚举起点\",{\"1\":{\"35\":1}}],[\"枚举从1\",{\"1\":{\"123\":1}}],[\"枚举从\",{\"1\":{\"35\":1}}],[\"开源的\",{\"1\":{\"190\":1}}],[\"开源协议\",{\"1\":{\"189\":1}}],[\"开源项目\",{\"0\":{\"17\":1}}],[\"开放寻址法\",{\"0\":{\"152\":1}}],[\"开一个单链表\",{\"1\":{\"75\":1}}],[\"开始\",{\"1\":{\"35\":1}}],[\"并将这些块分散存储在不同的磁盘上\",{\"1\":{\"191\":1}}],[\"并形成一个全局的命名空间\",{\"1\":{\"191\":1}}],[\"并在gi上行动一步\",{\"1\":{\"130\":1}}],[\"并不是第一行\",{\"1\":{\"116\":1}}],[\"并回代得到方程的解\",{\"1\":{\"116\":1}}],[\"并查集\",{\"0\":{\"145\":1}}],[\"并查集核心操作\",{\"1\":{\"91\":1}}],[\"并查集的父节点数组\",{\"1\":{\"91\":1}}],[\"并且\",{\"1\":{\"191\":1}}],[\"并且除了\",{\"1\":{\"191\":1}}],[\"并且支持跨越多个数据中心\",{\"1\":{\"191\":1}}],[\"并且忽略挂起\",{\"1\":{\"183\":1}}],[\"并且从每个局面向沿着合法行动能够到达的下一个局面连有向边\",{\"1\":{\"127\":1}}],[\"并且对于任意的整数\",{\"1\":{\"119\":1}}],[\"并且判断是否有解\",{\"1\":{\"115\":1}}],[\"并且边长之和最小\",{\"1\":{\"90\":1}}],[\"并且一般\",{\"1\":{\"35\":1}}],[\"并非真正的无穷大\",{\"1\":{\"84\":1}}],[\"并逐位执行操作\",{\"1\":{\"66\":1}}],[\"并提供标准接口\",{\"1\":{\"13\":1}}],[\"变长数组\",{\"1\":{\"154\":1}}],[\"变换\",{\"1\":{\"116\":1}}],[\"变\",{\"1\":{\"67\":2}}],[\"变成b\",{\"1\":{\"34\":1}}],[\"变为\",{\"1\":{\"34\":1}}],[\"将业务数据存储在云上\",{\"1\":{\"190\":1}}],[\"将每次移动的最大值保存在\",{\"1\":{\"178\":1}}],[\"将新的区间放入ans数组中\",{\"1\":{\"164\":1}}],[\"将指定线段区间完全覆盖\",{\"1\":{\"163\":1}}],[\"将第k位变成v\",{\"1\":{\"154\":1}}],[\"将当前元素加入到队尾\",{\"1\":{\"142\":1}}],[\"将当前元素加入队尾\",{\"1\":{\"142\":1}}],[\"将当前行的首位变成1\",{\"1\":{\"116\":1}}],[\"将下标是k的点后面的点删掉\",{\"1\":{\"135\":1}}],[\"将下面所有行的当且列的值变成\",{\"1\":{\"116\":1}}],[\"将头结点删除\",{\"1\":{\"135\":1}}],[\"将绝对值最大的行换到最顶端\",{\"1\":{\"116\":1}}],[\"将该行的第一个数变成\",{\"1\":{\"116\":1}}],[\"将这\",{\"1\":{\"115\":1}}],[\"将这一位相减后的结果压入c中\",{\"1\":{\"57\":1}}],[\"将其等价转换\",{\"1\":{\"115\":1}}],[\"将连通块逐渐扩大\",{\"1\":{\"90\":1}}],[\"将所有点分成\",{\"1\":{\"92\":1}}],[\"将所有存在交集的区间合并\",{\"1\":{\"71\":1}}],[\"将所有值排序\",{\"1\":{\"70\":1}}],[\"将一个对象拆分成\",{\"1\":{\"191\":1}}],[\"将一个容器中重复的元素删除\",{\"1\":{\"154\":1}}],[\"将一个新的节点x插入下标是k的后面\",{\"1\":{\"135\":1}}],[\"将一个数的各二进制位全部右移若干位\",{\"1\":{\"67\":1}}],[\"将一个运算对象的各二进制位全部左移若干位\",{\"1\":{\"67\":1}}],[\"将前导0置于尾部\",{\"1\":{\"59\":1}}],[\"将上次的余数×10再加上当前位的数字\",{\"1\":{\"59\":1}}],[\"将问题转变成统计数列中\",{\"1\":{\"53\":1}}],[\"将模板\",{\"1\":{\"51\":1}}],[\"将临时序列放入原序列中\",{\"1\":{\"47\":1}}],[\"将小的放入一个临时序列\",{\"1\":{\"47\":1}}],[\"将整个序列均分为两部分\",{\"1\":{\"47\":1}}],[\"将\",{\"1\":{\"34\":1,\"67\":2,\"112\":1,\"186\":1,\"196\":1}}],[\"将字符串看成p进制数\",{\"1\":{\"153\":1}}],[\"将字符串\",{\"1\":{\"34\":2}}],[\"替换\",{\"1\":{\"34\":1}}],[\"替换掉第一个大于或等于这个数字的那个数\",{\"1\":{\"30\":1}}],[\"在服务安装后\",{\"1\":{\"191\":1}}],[\"在很早的时候就采用了\",{\"1\":{\"191\":1}}],[\"在标准硬件上\",{\"1\":{\"191\":1}}],[\"在这种情况下\",{\"1\":{\"190\":1}}],[\"在同目录下创建\",{\"1\":{\"186\":1}}],[\"在浏览器输入\",{\"1\":{\"185\":1}}],[\"在\",{\"1\":{\"183\":1,\"186\":1,\"196\":1}}],[\"在递归的方法中\",{\"1\":{\"173\":1}}],[\"在有序\",{\"1\":{\"155\":2}}],[\"在有向图游戏中\",{\"1\":{\"129\":1}}],[\"在两个迭代器\",{\"1\":{\"155\":1}}],[\"在哈希表中查询某个数是否存在\",{\"1\":{\"151\":1}}],[\"在满足\",{\"1\":{\"143\":1}}],[\"在节点k的右边插入一个数x\",{\"1\":{\"136\":1}}],[\"在算法竞赛中一般不需要考虑删除的那个节点该如何处理\",{\"1\":{\"135\":1}}],[\"在链表头插入一个数a\",{\"1\":{\"135\":1}}],[\"在起点上放有一枚棋子\",{\"1\":{\"127\":1}}],[\"在游戏进程的任意时刻\",{\"1\":{\"126\":1}}],[\"在图论中\",{\"1\":{\"89\":1,\"93\":1}}],[\"在图中选择若干条边把图中的所有节点连接起来\",{\"1\":{\"89\":1}}],[\"在保存最短路径的数组中\",{\"1\":{\"85\":1}}],[\"在还未确定最短路的点中\",{\"1\":{\"82\":1}}],[\"在所有子节点更新后再更新\",{\"1\":{\"42\":1}}],[\"在字符串\",{\"1\":{\"34\":1}}],[\"在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点\",{\"1\":{\"29\":1}}],[\"中配置\",{\"1\":{\"196\":1}}],[\"中文文档地址\",{\"1\":{\"191\":1}}],[\"中文官网\",{\"1\":{\"189\":1}}],[\"中序遍历\",{\"1\":{\"171\":1}}],[\"中序\",{\"1\":{\"171\":1}}],[\"中查找小于等于\",{\"1\":{\"155\":1}}],[\"中查找大于等于\",{\"1\":{\"155\":1}}],[\"中能整除\",{\"1\":{\"123\":1}}],[\"中能被\",{\"1\":{\"123\":1}}],[\"中至少一个数整除的整数有多少个\",{\"1\":{\"123\":1}}],[\"中p的次数是\",{\"1\":{\"121\":1}}],[\"中国剩余定理\",{\"0\":{\"115\":1}}],[\"中计算过了\",{\"1\":{\"111\":1}}],[\"中与\",{\"1\":{\"110\":1}}],[\"中最多只包含一个大于\",{\"1\":{\"99\":1}}],[\"中找到\",{\"1\":{\"53\":2}}],[\"中的次数\",{\"1\":{\"121\":1}}],[\"中的所有质数\",{\"1\":{\"102\":1}}],[\"中的每个数加上c\",{\"1\":{\"63\":1}}],[\"中的\",{\"1\":{\"51\":2,\"196\":1}}],[\"中的某个字符替换为另一个字符\",{\"1\":{\"34\":1}}],[\"中的某个字符删除\",{\"1\":{\"34\":1}}],[\"中\",{\"1\":{\"47\":1,\"49\":1,\"178\":1}}],[\"中间件解决了异构网络环境下软件互联和互操作等共性问题\",{\"1\":{\"13\":1}}],[\"中间件与操作系统和数据库共同构成基础软件三大支柱\",{\"1\":{\"13\":1}}],[\"中间件不仅仅实现互连\",{\"1\":{\"13\":1}}],[\"中间件是一类软件统称\",{\"1\":{\"13\":1}}],[\"中间件在客户服务器的操作系统\",{\"1\":{\"13\":1}}],[\"中间件\",{\"0\":{\"13\":1},\"1\":{\"13\":1},\"2\":{\"187\":1,\"192\":1,\"200\":1}}],[\"删除失败会抛出异常\",{\"1\":{\"198\":1}}],[\"删除这个迭代器\",{\"1\":{\"154\":1}}],[\"删除所有x\",{\"1\":{\"154\":1}}],[\"删除任意一个元素\",{\"1\":{\"149\":1}}],[\"删除最小值\",{\"1\":{\"149\":1}}],[\"删除第k个点\",{\"1\":{\"136\":1}}],[\"删除前导0\",{\"1\":{\"57\":1,\"58\":1,\"59\":1}}],[\"删除\",{\"1\":{\"34\":1}}],[\"删除或替换算作一次操作\",{\"1\":{\"33\":1}}],[\"经过若干操作变为\",{\"1\":{\"34\":1}}],[\"现在给定一个正整数\",{\"1\":{\"36\":1}}],[\"现在请你求出\",{\"1\":{\"34\":1}}],[\"现在要将\",{\"1\":{\"34\":1}}],[\"现在又让他们研究最长公共上升子序列了\",{\"1\":{\"32\":1}}],[\"das\",{\"1\":{\"191\":1}}],[\"data\",{\"1\":{\"183\":7,\"184\":1,\"185\":2,\"186\":1,\"196\":1}}],[\"dl\",{\"1\":{\"183\":1,\"185\":1}}],[\"dependency>\",{\"1\":{\"195\":1}}],[\"description>\",{\"1\":{\"186\":1}}],[\"dev\",{\"1\":{\"185\":2}}],[\"deque\",{\"1\":{\"154\":1}}],[\"define\",{\"1\":{\"53\":1,\"83\":1,\"90\":1,\"103\":1,\"115\":1,\"123\":1,\"164\":1}}],[\"dijkstra\",{\"1\":{\"82\":2,\"83\":1}}],[\"dijkstra算法\",{\"0\":{\"82\":1}}],[\"dist\",{\"1\":{\"75\":7,\"82\":11,\"83\":9,\"84\":19,\"85\":10,\"86\":6,\"90\":10}}],[\"distance\",{\"1\":{\"33\":2,\"75\":3,\"83\":3,\"148\":1}}],[\"divisors\",{\"1\":{\"106\":1}}],[\"divisor\",{\"1\":{\"100\":1}}],[\"divide\",{\"1\":{\"99\":1}}],[\"div\",{\"1\":{\"59\":2}}],[\"docs\",{\"1\":{\"191\":1}}],[\"docker\",{\"0\":{\"15\":1,\"184\":1},\"1\":{\"184\":4}}],[\"docker等等\",{\"1\":{\"8\":1}}],[\"download\",{\"1\":{\"182\":1}}],[\"down和up只会执行其中一个\",{\"1\":{\"149\":1}}],[\"down\",{\"1\":{\"149\":6}}],[\"double\",{\"1\":{\"54\":6}}],[\"do\",{\"1\":{\"46\":2}}],[\"dfs思路\",{\"1\":{\"92\":1}}],[\"dfs\",{\"1\":{\"42\":3,\"75\":4,\"77\":2,\"92\":4}}],[\"d\",{\"1\":{\"37\":1,\"42\":4,\"56\":1,\"57\":2,\"58\":1,\"75\":4,\"79\":3,\"88\":7,\"90\":1,\"114\":5,\"115\":7,\"143\":1,\"148\":6,\"154\":1,\"185\":2,\"199\":3}}],[\"dp\",{\"1\":{\"35\":6,\"37\":3,\"42\":14}}],[\"再返回处理上一层找到的节点\",{\"1\":{\"173\":1}}],[\"再处理这个节点\",{\"1\":{\"172\":1}}],[\"再次继续匹配\",{\"1\":{\"143\":1}}],[\"再进行更新生成树\",{\"1\":{\"90\":1}}],[\"再更新\",{\"1\":{\"90\":1}}],[\"再把\",{\"1\":{\"90\":1}}],[\"再建立一个数组\",{\"1\":{\"85\":1}}],[\"再建立一个数组记录起始点到所有点的最短路径\",{\"1\":{\"85\":1}}],[\"再看个位是几\",{\"1\":{\"68\":1}}],[\"再按\",{\"1\":{\"67\":1}}],[\"再枚举左端点\",{\"1\":{\"35\":1}}],[\"再接下来\",{\"1\":{\"33\":1}}],[\"再让他们研究了最长公共子序列\",{\"1\":{\"32\":1}}],[\"行row\",{\"1\":{\"116\":1}}],[\"行包含两个整数\",{\"1\":{\"115\":1}}],[\"行包含整数\",{\"1\":{\"115\":1}}],[\"行\",{\"1\":{\"33\":3,\"115\":1}}],[\"编辑距离\",{\"0\":{\"33\":1}}],[\"编程语言\",{\"0\":{\"10\":1}}],[\"序列中的数字均不超过\",{\"1\":{\"32\":1}}],[\"输入的参数是pair或者迭代器\",{\"1\":{\"154\":1}}],[\"输入一个迭代器\",{\"1\":{\"154\":1}}],[\"输入是一个数x\",{\"1\":{\"154\":1}}],[\"输入\",{\"1\":{\"121\":1}}],[\"输入样例\",{\"1\":{\"32\":1}}],[\"输入格式\",{\"1\":{\"32\":1,\"33\":1,\"68\":1,\"115\":1}}],[\"输出选择的点的最小数量\",{\"1\":{\"160\":1}}],[\"输出以0开始的匹配子串的首字母下标\",{\"1\":{\"143\":1}}],[\"输出最小非负整数\",{\"1\":{\"115\":1}}],[\"输出i的s次幂\",{\"1\":{\"99\":1}}],[\"输出即可\",{\"1\":{\"99\":1}}],[\"输出如下\",{\"1\":{\"68\":1}}],[\"输出共\",{\"1\":{\"33\":1}}],[\"输出样例\",{\"1\":{\"32\":1}}],[\"输出一个整数\",{\"1\":{\"32\":1}}],[\"输出格式\",{\"1\":{\"32\":1,\"33\":1,\"68\":1,\"115\":1}}],[\"个奇偶校验块\",{\"1\":{\"191\":1}}],[\"个闭区间\",{\"1\":{\"163\":1}}],[\"个不同的质数\",{\"1\":{\"123\":1}}],[\"个未知数的多元线性方程组\",{\"1\":{\"116\":1}}],[\"个未知数的线性方程组\",{\"1\":{\"116\":1}}],[\"个方程\",{\"1\":{\"116\":2}}],[\"个式子合并\",{\"1\":{\"115\":1}}],[\"个质数\",{\"1\":{\"102\":1}}],[\"个顶点的连通块筛选出来\",{\"1\":{\"91\":1}}],[\"个顶点\",{\"1\":{\"89\":1}}],[\"个点\",{\"1\":{\"81\":1}}],[\"个点的带权无向图\",{\"1\":{\"40\":1}}],[\"个数据块\",{\"1\":{\"191\":1}}],[\"个数字\",{\"1\":{\"177\":1}}],[\"个数来组合\",{\"1\":{\"112\":1}}],[\"个数\",{\"1\":{\"112\":1}}],[\"个数的二进制表示中\",{\"1\":{\"68\":1}}],[\"个数表示数列中的第\",{\"1\":{\"68\":1}}],[\"个位\",{\"1\":{\"56\":1,\"57\":1}}],[\"个人来\",{\"1\":{\"42\":1}}],[\"个人不来\",{\"1\":{\"42\":1}}],[\"个人介绍和档案放置在此\",{\"1\":{\"0\":1}}],[\"个物品全不选也是一种方案\",{\"1\":{\"36\":2}}],[\"个\",{\"1\":{\"36\":2}}],[\"个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串\",{\"1\":{\"33\":1}}],[\"个长度不超过\",{\"1\":{\"33\":1}}],[\"个整数\",{\"1\":{\"32\":2,\"36\":1,\"68\":2,\"115\":1}}],[\"表示存储桶是否存在\",{\"1\":{\"198\":1}}],[\"表示祖宗节点所在集合中的点的数量\",{\"1\":{\"147\":1}}],[\"表示队头\",{\"1\":{\"141\":1}}],[\"表示节点的右指针\",{\"1\":{\"136\":1}}],[\"表示节点的左指针\",{\"1\":{\"136\":1}}],[\"表示节点的值\",{\"1\":{\"136\":1}}],[\"表示第二个集合中的每个点是否已经被遍历过\",{\"1\":{\"93\":1}}],[\"表示每个点的颜色\",{\"1\":{\"92\":1}}],[\"表示a到b的距离\",{\"1\":{\"88\":1}}],[\"表示1号点已经被遍历过\",{\"1\":{\"78\":1}}],[\"表示点j已经被遍历过\",{\"1\":{\"78\":1}}],[\"表示点u已经被遍历过\",{\"1\":{\"77\":1}}],[\"表示点数\",{\"1\":{\"76\":1,\"79\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1}}],[\"表示边数\",{\"1\":{\"76\":1,\"79\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"90\":1,\"91\":1,\"92\":1,\"93\":1}}],[\"表示补码\",{\"1\":{\"68\":1}}],[\"表示整个数列\",{\"1\":{\"68\":1}}],[\"表示\",{\"1\":{\"58\":1,\"59\":1,\"92\":1,\"119\":1}}],[\"表示精度\",{\"1\":{\"54\":1}}],[\"表示所有点都走过了\",{\"1\":{\"40\":1}}],[\"表示从a个苹果中选b个的方案数\",{\"1\":{\"118\":1}}],[\"表示从\",{\"1\":{\"40\":1}}],[\"表示当前摆到第\",{\"1\":{\"39\":1}}],[\"表示前\",{\"1\":{\"36\":1}}],[\"表示一次询问中满足条件的字符串个数\",{\"1\":{\"33\":1}}],[\"表示一次询问\",{\"1\":{\"33\":1}}],[\"表示给定的字符串\",{\"1\":{\"33\":1}}],[\"表示最长公共上升子序列的长度\",{\"1\":{\"32\":1}}],[\"表示数列\",{\"1\":{\"32\":3}}],[\"表示总体积是i的情况下\",{\"1\":{\"24\":1,\"25\":1}}],[\"只去掉\",{\"1\":{\"155\":1}}],[\"只是\",{\"1\":{\"111\":1}}],[\"只需将基数\",{\"1\":{\"111\":1}}],[\"只需要创建\",{\"1\":{\"196\":1}}],[\"只需要在最后面加上\",{\"1\":{\"183\":1}}],[\"只需要跟一个父亲比较大小就行\",{\"1\":{\"149\":1}}],[\"只需要判断\",{\"1\":{\"102\":1}}],[\"只需要另找一个数\",{\"1\":{\"67\":3}}],[\"只可能是此时\",{\"1\":{\"104\":1}}],[\"只判断能否被小于\",{\"1\":{\"98\":1}}],[\"只出现在集合之间\",{\"1\":{\"92\":1}}],[\"只有祖宗节点的有意义\",{\"1\":{\"147\":1}}],[\"只有先手必胜和先手必败两种情况\",{\"1\":{\"125\":1}}],[\"只有当\",{\"1\":{\"91\":1}}],[\"只有a\",{\"1\":{\"30\":1}}],[\"只考虑正数的情况\",{\"1\":{\"57\":1}}],[\"只要它不是\",{\"1\":{\"102\":1}}],[\"只要根据最未位是\",{\"1\":{\"67\":1}}],[\"只要\",{\"1\":{\"67\":1}}],[\"只要找到这个连续段的左端点和右端点即可\",{\"1\":{\"53\":1}}],[\"只要告诉奶牛它的长度就可以了\",{\"1\":{\"32\":1}}],[\"不管其是存放的数据块还是奇偶校验块\",{\"1\":{\"191\":1}}],[\"不支持\",{\"1\":{\"154\":1}}],[\"不满足条件\",{\"1\":{\"126\":1}}],[\"不能行动的玩家判负\",{\"1\":{\"126\":1}}],[\"不存在\",{\"1\":{\"115\":1}}],[\"不一定是\",{\"1\":{\"92\":1}}],[\"不是\",{\"1\":{\"104\":1,\"111\":1,\"119\":1}}],[\"不是起点\",{\"1\":{\"90\":1}}],[\"不是一定\",{\"1\":{\"84\":1}}],[\"不包括自己\",{\"1\":{\"86\":1}}],[\"不包含前导零\",{\"1\":{\"37\":1}}],[\"不需要创建\",{\"1\":{\"198\":1}}],[\"不需要初始化dist数组\",{\"1\":{\"86\":1}}],[\"不需要借位\",{\"1\":{\"57\":1}}],[\"不为空\",{\"1\":{\"85\":1}}],[\"不同\",{\"1\":{\"191\":1}}],[\"不同颜色\",{\"1\":{\"92\":1}}],[\"不同为\",{\"1\":{\"67\":1}}],[\"不同为1\",{\"1\":{\"66\":1}}],[\"不同位置的数字一样的数对算不同的数对\",{\"1\":{\"53\":1}}],[\"不用全部遍历\",{\"1\":{\"56\":1,\"57\":1}}],[\"不含前导0\",{\"1\":{\"56\":1,\"57\":1,\"58\":1,\"59\":1}}],[\"不重不漏地经过每个点恰好一次\",{\"1\":{\"40\":1}}],[\"不过\",{\"1\":{\"32\":1}}],[\"不连续\",{\"0\":{\"31\":1}}],[\"奶牛半懂不懂\",{\"1\":{\"32\":1}}],[\"而非对某个数的余数时\",{\"1\":{\"121\":1}}],[\"而非一种软件\",{\"1\":{\"13\":1}}],[\"而整数\",{\"1\":{\"119\":1}}],[\"而此时另一个数即为所求答案\",{\"1\":{\"108\":1}}],[\"而并非是\",{\"1\":{\"84\":1}}],[\"而另一部分还有剩余\",{\"1\":{\"47\":1}}],[\"而所有的公共上升子序列中最长的就是最长公共上升子序列了\",{\"1\":{\"32\":1}}],[\"且x不属于s\",{\"1\":{\"128\":1}}],[\"且原来匹配的点能找到另一个点\",{\"1\":{\"93\":1}}],[\"且到树的距离最短\",{\"1\":{\"90\":1}}],[\"且使权值最小的一种结构\",{\"1\":{\"89\":1}}],[\"且\",{\"1\":{\"46\":1,\"114\":1}}],[\"且终点是n\",{\"1\":{\"40\":1}}],[\"且保证右端点不会超范围\",{\"1\":{\"35\":1}}],[\"且长度均不超过\",{\"1\":{\"33\":1}}],[\"且数值是严格递增的\",{\"1\":{\"32\":1}}],[\"且总价值最大\",{\"1\":{\"27\":1}}],[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目\",{\"1\":{\"32\":1}}],[\"和校验和\",{\"1\":{\"191\":1}}],[\"和传统对象存储相比\",{\"1\":{\"191\":1}}],[\"和上面类似\",{\"1\":{\"154\":1}}],[\"和条件\",{\"1\":{\"126\":1}}],[\"和\",{\"1\":{\"31\":2,\"32\":2,\"33\":1,\"34\":1,\"37\":2,\"46\":1,\"47\":1,\"50\":1,\"51\":1,\"52\":1,\"58\":1,\"59\":1,\"81\":1,\"92\":1,\"103\":2,\"114\":1,\"115\":2,\"123\":1,\"154\":1,\"186\":1,\"191\":2}}],[\"否则不更新\",{\"1\":{\"178\":1}}],[\"否则不存在拓扑序列\",{\"1\":{\"79\":1}}],[\"否则返回最小生成树的树边权重之和\",{\"1\":{\"90\":1}}],[\"否则返回\",{\"1\":{\"57\":1}}],[\"否则返回flase\",{\"1\":{\"57\":1}}],[\"否则返回false\",{\"1\":{\"57\":1,\"86\":1}}],[\"否则\",{\"1\":{\"30\":1}}],[\"模拟堆栈\",{\"1\":{\"30\":1}}],[\"模板代码如下\",{\"1\":{\"35\":1}}],[\"模板代码\",{\"1\":{\"33\":1}}],[\"模板\",{\"0\":{\"3\":1}}],[\"三重循环\",{\"1\":{\"88\":1}}],[\"三\",{\"1\":{\"30\":1}}],[\"effect\",{\"1\":{\"198\":1}}],[\"erasure\",{\"1\":{\"191\":1}}],[\"erase\",{\"1\":{\"70\":1,\"154\":3}}],[\"expiry\",{\"1\":{\"199\":1}}],[\"exception\",{\"1\":{\"198\":4,\"199\":7}}],[\"executable>\",{\"1\":{\"186\":1}}],[\"exe<\",{\"1\":{\"186\":1}}],[\"exe\",{\"1\":{\"185\":3,\"186\":6}}],[\"exgcd\",{\"1\":{\"114\":2,\"115\":3}}],[\"empty\",{\"1\":{\"138\":2,\"141\":2,\"154\":7,\"162\":1}}],[\"eulers\",{\"1\":{\"111\":1}}],[\"euler\",{\"1\":{\"111\":7}}],[\"e\",{\"1\":{\"75\":2,\"77\":1,\"78\":1,\"79\":1,\"83\":3,\"85\":3,\"86\":2,\"92\":2,\"93\":2,\"135\":4,\"136\":3,\"151\":3,\"199\":2}}],[\"edges\",{\"1\":{\"84\":4,\"91\":6}}],[\"edge\",{\"1\":{\"75\":1,\"84\":1,\"91\":2}}],[\"edit\",{\"1\":{\"33\":2}}],[\"eps\",{\"1\":{\"54\":3,\"116\":4}}],[\"endpoint\",{\"1\":{\"196\":3}}],[\"end\",{\"1\":{\"30\":1,\"53\":4,\"59\":1,\"70\":3,\"71\":1,\"106\":1,\"154\":5,\"155\":5,\"164\":1}}],[\"endl\",{\"1\":{\"24\":2,\"25\":2,\"26\":4,\"27\":2,\"29\":2,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":2,\"39\":1,\"40\":1,\"53\":1,\"59\":2,\"82\":1,\"99\":3,\"107\":1,\"120\":1,\"123\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"else\",{\"1\":{\"30\":2,\"33\":1,\"34\":2,\"39\":1,\"47\":1,\"50\":1,\"51\":1,\"52\":1,\"54\":1,\"57\":2,\"70\":1,\"71\":1,\"88\":1,\"90\":1,\"91\":1,\"92\":1,\"118\":1,\"123\":1,\"125\":1,\"138\":1,\"141\":1,\"146\":1,\"161\":1,\"162\":1,\"164\":1,\"198\":1}}],[\"roll\",{\"1\":{\"186\":1}}],[\"root\",{\"1\":{\"42\":5,\"171\":1,\"183\":4}}],[\"runtimeexception\",{\"1\":{\"199\":1}}],[\"run\",{\"1\":{\"184\":1}}],[\"rayshinehub\",{\"1\":{\"167\":1}}],[\"range\",{\"1\":{\"162\":8,\"163\":9}}],[\"random\",{\"1\":{\"155\":1}}],[\"rank\",{\"1\":{\"91\":7,\"146\":8}}],[\"r代表区间右端点\",{\"1\":{\"164\":1}}],[\"r表示上一连续区间的最右端的点\",{\"1\":{\"160\":1}}],[\"r时\",{\"1\":{\"49\":1}}],[\"reed\",{\"1\":{\"191\":1}}],[\"releases\",{\"1\":{\"186\":1}}],[\"release\",{\"1\":{\"183\":1,\"185\":1}}],[\"removeobjectargs\",{\"1\":{\"199\":1}}],[\"removeobject\",{\"1\":{\"199\":2}}],[\"removebucketargs\",{\"1\":{\"198\":1}}],[\"removebucket\",{\"1\":{\"198\":2}}],[\"remove\",{\"1\":{\"135\":2,\"136\":1}}],[\"reverse\",{\"1\":{\"59\":1,\"155\":4}}],[\"resource\",{\"1\":{\"196\":1,\"198\":1}}],[\"reset\",{\"1\":{\"154\":1}}],[\"res++\",{\"1\":{\"33\":1,\"68\":1,\"93\":1,\"161\":1,\"163\":1}}],[\"res\",{\"1\":{\"32\":4,\"33\":2,\"68\":2,\"69\":2,\"71\":4,\"90\":3,\"91\":3,\"93\":1,\"100\":7,\"106\":6,\"107\":4,\"110\":6,\"112\":4,\"119\":4,\"120\":4,\"121\":7,\"123\":4,\"125\":3,\"161\":2,\"163\":4}}],[\"return\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":2,\"34\":1,\"35\":1,\"37\":6,\"39\":1,\"40\":1,\"42\":2,\"46\":1,\"47\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"56\":2,\"57\":5,\"58\":2,\"59\":2,\"68\":3,\"70\":1,\"75\":1,\"79\":1,\"82\":3,\"83\":2,\"84\":2,\"85\":2,\"86\":2,\"90\":2,\"91\":5,\"92\":5,\"93\":2,\"98\":3,\"100\":4,\"106\":1,\"107\":1,\"108\":2,\"110\":1,\"112\":1,\"114\":2,\"115\":5,\"116\":3,\"119\":1,\"120\":6,\"121\":2,\"123\":1,\"125\":1,\"143\":1,\"144\":2,\"146\":1,\"147\":1,\"148\":1,\"151\":2,\"152\":1,\"153\":1,\"155\":2,\"160\":2,\"161\":2,\"162\":2,\"163\":2,\"164\":1,\"178\":1,\"196\":1}}],[\"r\",{\"1\":{\"30\":6,\"46\":8,\"47\":8,\"49\":1,\"50\":7,\"51\":7,\"52\":6,\"54\":4,\"59\":1,\"61\":2,\"63\":2,\"70\":5,\"71\":7,\"116\":12,\"136\":10,\"153\":4,\"160\":8,\"161\":10,\"162\":4,\"163\":12,\"164\":10}}],[\"qmi\",{\"1\":{\"112\":1,\"119\":2,\"120\":2}}],[\"query\",{\"1\":{\"144\":1}}],[\"queue\",{\"1\":{\"85\":2,\"154\":2}}],[\"queue<pair<int\",{\"1\":{\"178\":1}}],[\"queue<pii\",{\"1\":{\"83\":1}}],[\"queue<int\",{\"1\":{\"154\":1,\"162\":1}}],[\"queue<int>\",{\"1\":{\"78\":1,\"85\":1,\"86\":1}}],[\"quick\",{\"1\":{\"46\":3}}],[\"q\",{\"1\":{\"30\":4,\"46\":8,\"78\":6,\"79\":3,\"85\":8,\"86\":6,\"141\":4,\"142\":3,\"154\":1,\"178\":7}}],[\"严格递增的子序列的最大长度\",{\"1\":{\"30\":1}}],[\"最简单的\",{\"1\":{\"183\":1}}],[\"最多有26个\",{\"1\":{\"144\":1}}],[\"最终结果为\",{\"1\":{\"111\":1}}],[\"最初最小生成树的边数为\",{\"1\":{\"91\":1}}],[\"最小值\",{\"1\":{\"142\":1}}],[\"最小生成树所有边的长度之和\",{\"1\":{\"90\":1}}],[\"最小生成树就是将\",{\"1\":{\"89\":1}}],[\"最小生成树问题\",{\"0\":{\"89\":1}}],[\"最小的最大\",{\"1\":{\"52\":1}}],[\"最坏情况下的时间复杂度为\",{\"1\":{\"108\":1}}],[\"最坏情况下\",{\"1\":{\"85\":1}}],[\"最坏情况为\",{\"1\":{\"81\":1}}],[\"最低位一定为\",{\"1\":{\"67\":1}}],[\"最后返回上一层\",{\"1\":{\"173\":1}}],[\"最后返回c数组\",{\"1\":{\"56\":1,\"57\":1}}],[\"最后找到的节点处理完后\",{\"1\":{\"173\":1}}],[\"最后处理这个节点的右子树\",{\"1\":{\"172\":1}}],[\"最后遍历左子节点的右子树\",{\"1\":{\"171\":1}}],[\"最后访问右子树\",{\"1\":{\"171\":1}}],[\"最后剩下的式子就满足我们的答案\",{\"1\":{\"115\":1}}],[\"最后剩下的就是区间\",{\"1\":{\"103\":1}}],[\"最后将整个图连通起来\",{\"1\":{\"90\":1}}],[\"最后一层节点从左向右排列\",{\"1\":{\"149\":1}}],[\"最后一次出现的位置的\",{\"1\":{\"53\":1}}],[\"最后一个访问到的一定是根\",{\"1\":{\"42\":1}}],[\"最后根据分界点分别递归左右两部分\",{\"1\":{\"46\":1}}],[\"最短路问题\",{\"0\":{\"80\":1}}],[\"最短hamilton路径\",{\"0\":{\"40\":1}}],[\"最短编辑距离\",{\"0\":{\"34\":1}}],[\"最长公共上升子序列\",{\"0\":{\"32\":1}}],[\"最长公共子序列\",{\"0\":{\"31\":1}}],[\"最长上升子序列\",{\"0\":{\"30\":1}}],[\"最大不相交区间数量\",{\"0\":{\"161\":1}}],[\"最大公约数与最小公倍数\",{\"0\":{\"108\":1}}],[\"最大匹配\",{\"1\":{\"93\":1}}],[\"最大的最小\",{\"1\":{\"52\":1}}],[\"最大的总价值\",{\"1\":{\"24\":1}}],[\"最大价值是多少\",{\"1\":{\"24\":1,\"25\":1}}],[\"从而提高系统的可靠性和容错能力\",{\"1\":{\"191\":1}}],[\"从而便于删除前导0\",{\"1\":{\"59\":1}}],[\"从根节点开始\",{\"1\":{\"171\":1}}],[\"从大到小排序需要加入第三个参数\",{\"1\":{\"155\":1}}],[\"从大到小排序\",{\"1\":{\"155\":1}}],[\"从0开始\",{\"1\":{\"143\":1}}],[\"从00\",{\"1\":{\"37\":1}}],[\"从队头弹出一个数\",{\"1\":{\"141\":1}}],[\"从栈顶弹出一个数\",{\"1\":{\"138\":1}}],[\"从\",{\"1\":{\"102\":1}}],[\"从一个未匹配路出发\",{\"1\":{\"93\":1}}],[\"从一个未匹配点出发\",{\"1\":{\"93\":1}}],[\"从高位到低位运算\",{\"1\":{\"59\":1}}],[\"从小到大枚举n的所有约数对里面比较小的那一个\",{\"1\":{\"106\":1}}],[\"从小到大枚举所有的质数\",{\"1\":{\"102\":1}}],[\"从小到大判断\",{\"1\":{\"106\":1}}],[\"从小到大尝试\",{\"1\":{\"99\":1}}],[\"从小到大遍历\",{\"1\":{\"98\":1,\"104\":1}}],[\"从小到大依次枚举每组边\",{\"1\":{\"91\":1}}],[\"从小到大\",{\"1\":{\"56\":1,\"57\":1}}],[\"从头开始遍历\",{\"1\":{\"47\":1}}],[\"从1\",{\"1\":{\"37\":1}}],[\"从下往上遍历\",{\"1\":{\"29\":1}}],[\"从上往下遍历\",{\"1\":{\"29\":1}}],[\"从顶部出发\",{\"1\":{\"29\":1}}],[\"64\",{\"1\":{\"115\":1}}],[\"6010\",{\"1\":{\"42\":4}}],[\"6\",{\"0\":{\"34\":1,\"38\":1,\"39\":1,\"40\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"92\":1,\"115\":1,\"130\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":1},\"1\":{\"29\":1,\"54\":1,\"56\":1,\"57\":1,\"67\":1,\"84\":1,\"116\":1,\"191\":3}}],[\"5个基本操作\",{\"1\":{\"149\":1}}],[\"510\",{\"1\":{\"29\":1,\"82\":1}}],[\"5\",{\"0\":{\"33\":1,\"37\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"86\":1,\"89\":1,\"90\":1,\"91\":1,\"113\":1,\"122\":1,\"129\":1,\"144\":1,\"164\":1},\"1\":{\"29\":2,\"56\":1,\"57\":1,\"67\":1,\"84\":1,\"155\":1,\"164\":1,\"195\":1}}],[\"8\",{\"0\":{\"70\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"150\":1,\"151\":1,\"152\":1,\"153\":1},\"1\":{\"29\":2}}],[\"7\",{\"0\":{\"41\":1,\"42\":1,\"69\":1,\"93\":1,\"116\":1,\"149\":1},\"1\":{\"29\":2,\"36\":2,\"107\":1}}],[\"二叉树的\",{\"1\":{\"171\":1}}],[\"二叉树的中序遍历\",{\"0\":{\"170\":1},\"1\":{\"170\":1}}],[\"二叉树\",{\"1\":{\"149\":1},\"2\":{\"175\":1}}],[\"二进制中1的个数\",{\"1\":{\"68\":1}}],[\"二分\",{\"1\":{\"155\":1}}],[\"二分图\",{\"1\":{\"92\":2}}],[\"二分求出x对应的离散化的值\",{\"1\":{\"70\":1}}],[\"二分答案可以用来处理\",{\"1\":{\"52\":1}}],[\"二分答案模板\",{\"0\":{\"52\":1}}],[\"二分模板一共有两个\",{\"1\":{\"49\":1}}],[\"二分查找算法模板\",{\"0\":{\"49\":1}}],[\"二分算法\",{\"0\":{\"48\":1}}],[\"二分写法\",{\"1\":{\"30\":1}}],[\"二\",{\"1\":{\"27\":1,\"30\":1}}],[\"二维差分\",{\"0\":{\"64\":1}}],[\"二维前缀和\",{\"0\":{\"62\":1}}],[\"二维\",{\"1\":{\"24\":1,\"25\":1}}],[\"可选\",{\"1\":{\"196\":1}}],[\"可视化管理界面\",{\"1\":{\"191\":1}}],[\"可拓展\",{\"1\":{\"191\":1}}],[\"可拓展性的特点\",{\"1\":{\"190\":1}}],[\"可修改\",{\"1\":{\"183\":1}}],[\"可计算出去重后的元素个数\",{\"1\":{\"155\":1}}],[\"可把一堆取光\",{\"1\":{\"125\":1}}],[\"可能为负数\",{\"1\":{\"115\":1}}],[\"可能包含长度为偶数的环\",{\"1\":{\"92\":1}}],[\"可能的\",{\"1\":{\"52\":1}}],[\"可理解为\",{\"1\":{\"90\":1,\"91\":1}}],[\"可以多个线程共同使用一个\",{\"1\":{\"196\":1}}],[\"可以丢失任意\",{\"1\":{\"191\":1}}],[\"可以直接通过浏览器登录系统\",{\"1\":{\"191\":1}}],[\"可以使用\",{\"1\":{\"191\":1}}],[\"可以使用各种公有云提供的\",{\"1\":{\"190\":1}}],[\"可以自定义修改\",{\"1\":{\"183\":1}}],[\"可以在第三个参数传入定义大小比较的函数\",{\"1\":{\"155\":1}}],[\"可以在区间\",{\"1\":{\"53\":2}}],[\"可以删掉\",{\"1\":{\"139\":1}}],[\"可以执行的合法行动与轮到哪名玩家无关\",{\"1\":{\"126\":1}}],[\"可以用费马小定理求逆元\",{\"1\":{\"119\":1}}],[\"可以用结构体存储点和边\",{\"1\":{\"84\":1}}],[\"可以缩小问题规模而保持最大公约数不变\",{\"1\":{\"108\":1}}],[\"可以对其进行优化\",{\"1\":{\"99\":1}}],[\"可以生成最小生成树\",{\"1\":{\"91\":1}}],[\"可以不需要考虑重边\",{\"1\":{\"83\":1}}],[\"可以表示为\",{\"1\":{\"67\":1}}],[\"可以表示成若干个正整数之和\",{\"1\":{\"36\":1}}],[\"可以将模板\",{\"1\":{\"51\":1}}],[\"可以任选\",{\"1\":{\"46\":1}}],[\"可以理解为\",{\"1\":{\"13\":1}}],[\"可进行的操作有\",{\"1\":{\"34\":1}}],[\"可使物品总体积不超过背包容量\",{\"1\":{\"27\":1}}],[\"求分成的最小组数\",{\"1\":{\"162\":1}}],[\"求集合当中的最小值\",{\"1\":{\"149\":1}}],[\"求滑动窗口里的最大值和最小值\",{\"1\":{\"142\":1}}],[\"求每个质因数的次数\",{\"1\":{\"121\":1}}],[\"求每个质数的次数\",{\"1\":{\"121\":1}}],[\"求next\",{\"1\":{\"143\":1}}],[\"求next数组时\",{\"1\":{\"143\":1}}],[\"求n\",{\"1\":{\"121\":1}}],[\"求组合数\",{\"0\":{\"117\":1}}],[\"求一个最小的非负整数\",{\"1\":{\"115\":1}}],[\"求一个序列中\",{\"1\":{\"30\":1}}],[\"求x\",{\"1\":{\"114\":1}}],[\"求x的欧拉函数\",{\"1\":{\"110\":1}}],[\"求整数\",{\"1\":{\"114\":1}}],[\"求欧拉函数\",{\"0\":{\"110\":1}}],[\"求最大匹配数\",{\"1\":{\"93\":1}}],[\"求最大权值和\",{\"1\":{\"42\":1}}],[\"求1到n的最短路距离\",{\"1\":{\"84\":1}}],[\"求1号点到n号点的最短距离\",{\"1\":{\"83\":1}}],[\"求1号点到n号点的最短路距离\",{\"1\":{\"85\":1}}],[\"求1号点到n号点的最短路\",{\"1\":{\"82\":1}}],[\"求从一个点到其他所有点的最短距离\",{\"1\":{\"81\":1}}],[\"求起点\",{\"1\":{\"40\":1}}],[\"求\",{\"1\":{\"37\":1,\"112\":1,\"118\":1,\"121\":1,\"143\":1}}],[\"求方案数\",{\"1\":{\"36\":1}}],[\"求既是\",{\"1\":{\"31\":1}}],[\"求解将哪些物品装入背包\",{\"1\":{\"27\":1}}],[\"求所选物品的总体积不超过背包容量的条件下\",{\"1\":{\"24\":1}}],[\"同样首先遍历左子节点的左子树\",{\"1\":{\"171\":1}}],[\"同时\",{\"1\":{\"125\":1}}],[\"同时还能够为该应用程序提供相关的服务的软件\",{\"1\":{\"13\":1}}],[\"同加法一样处理进位\",{\"1\":{\"58\":1}}],[\"同理再处理该节点和该节点的右子节点\",{\"1\":{\"173\":1}}],[\"同理队尾\",{\"1\":{\"141\":1}}],[\"同理\",{\"1\":{\"56\":1,\"57\":1}}],[\"同一组内的物品最多只能选一个\",{\"1\":{\"27\":1}}],[\"每组询问给定三个整数\",{\"1\":{\"120\":1}}],[\"每组物品有若干个\",{\"1\":{\"27\":1}}],[\"每\",{\"1\":{\"115\":1}}],[\"每次可以移动一步\",{\"1\":{\"127\":1}}],[\"每次可以任选一堆\",{\"1\":{\"125\":1}}],[\"每次异或操作\",{\"1\":{\"125\":1}}],[\"每次都让较大的数对较小数取模\",{\"1\":{\"108\":1}}],[\"每次将\",{\"1\":{\"92\":1}}],[\"每次将区间长度缩小一半\",{\"1\":{\"49\":1}}],[\"每次迭代选择一条不在集合内的权值最短的边\",{\"1\":{\"91\":1}}],[\"每次迭代找到不在连通块中的距离最近的点\",{\"1\":{\"90\":1}}],[\"每次循环遍历所有边\",{\"1\":{\"84\":1}}],[\"每次循环都先将\",{\"1\":{\"46\":1}}],[\"每次备份一下\",{\"1\":{\"84\":1}}],[\"每次只需判断答案是否需要更新\",{\"1\":{\"52\":1}}],[\"每次比较\",{\"1\":{\"47\":1}}],[\"每次询问给出一个字符串和一个操作次数上限\",{\"1\":{\"33\":1}}],[\"每个\",{\"1\":{\"196\":1}}],[\"每个对象都包含了数据本身以及元数据\",{\"1\":{\"190\":1}}],[\"每个对字符串进行的单个字符的插入\",{\"1\":{\"33\":1}}],[\"每个正整数都能够以唯一的方式表示成它的质因数的乘积\",{\"1\":{\"99\":1}}],[\"每个人只有两种状态\",{\"1\":{\"42\":1}}],[\"每行输出一个整数作为结果\",{\"1\":{\"33\":1}}],[\"每行包含一个字符串和一个整数\",{\"1\":{\"33\":1}}],[\"每行包含一个字符串\",{\"1\":{\"33\":1}}],[\"每件物品有\",{\"1\":{\"26\":1}}],[\"每件物品只能使用\",{\"1\":{\"24\":1,\"25\":1}}],[\"的签名url\",{\"1\":{\"199\":1}}],[\"的状态\",{\"1\":{\"199\":1}}],[\"的常用\",{\"0\":{\"197\":1}}],[\"的操作\",{\"1\":{\"196\":1}}],[\"的操作方式\",{\"1\":{\"34\":1}}],[\"的基本对象\",{\"1\":{\"196\":1}}],[\"的逻辑空间\",{\"1\":{\"196\":1}}],[\"的存储机制使用纠删码\",{\"1\":{\"191\":1}}],[\"的产品\",{\"1\":{\"191\":1}}],[\"的编排\",{\"1\":{\"191\":1}}],[\"的替代品\",{\"1\":{\"191\":1}}],[\"的滑动窗口从数组的最左侧移动到数组的最右侧\",{\"1\":{\"177\":1}}],[\"的元素\",{\"1\":{\"155\":1}}],[\"的元素的位置的迭代器\",{\"1\":{\"155\":1}}],[\"的用法和\",{\"1\":{\"155\":1}}],[\"的第三个参数传入一个元素\",{\"1\":{\"155\":1}}],[\"的第一个元素\",{\"1\":{\"51\":1}}],[\"的减法\",{\"1\":{\"155\":1}}],[\"的相同元素\",{\"1\":{\"155\":1}}],[\"的哈希值\",{\"1\":{\"153\":1}}],[\"的右儿子为\",{\"1\":{\"149\":1}}],[\"的左儿子为\",{\"1\":{\"149\":1}}],[\"的偏移量\",{\"1\":{\"148\":1}}],[\"的距离\",{\"1\":{\"148\":1}}],[\"的前提下\",{\"1\":{\"143\":1}}],[\"的sg函数值构成的集合再执行mex\",{\"1\":{\"129\":1}}],[\"的每一个集合状态\",{\"1\":{\"123\":1}}],[\"的集合\",{\"1\":{\"123\":1}}],[\"的乘法逆元为\",{\"1\":{\"119\":1}}],[\"的乘法逆元\",{\"1\":{\"119\":1}}],[\"的模\",{\"1\":{\"119\":1}}],[\"的逆元不存在\",{\"1\":{\"119\":1}}],[\"的逆元\",{\"1\":{\"119\":1}}],[\"的解\",{\"1\":{\"114\":1}}],[\"的倍数时\",{\"1\":{\"119\":1}}],[\"的倍数\",{\"1\":{\"114\":1,\"119\":1}}],[\"的欧拉函数即为\",{\"1\":{\"111\":1}}],[\"的质因子\",{\"1\":{\"104\":1,\"111\":1}}],[\"的表中划去\",{\"1\":{\"103\":1}}],[\"的表中筛得素数的同时\",{\"1\":{\"103\":1}}],[\"的素数表\",{\"1\":{\"103\":1}}],[\"的约数\",{\"1\":{\"102\":1}}],[\"的唯一质因子\",{\"1\":{\"99\":1}}],[\"的因子\",{\"1\":{\"99\":3}}],[\"的更新方式为\",{\"1\":{\"84\":1}}],[\"的形式存储\",{\"1\":{\"83\":1}}],[\"的点\",{\"1\":{\"79\":1}}],[\"的个数\",{\"1\":{\"68\":2}}],[\"的数整除\",{\"1\":{\"98\":1}}],[\"的数列\",{\"1\":{\"68\":1}}],[\"的数对的个数\",{\"1\":{\"53\":1}}],[\"的二进制表示\",{\"1\":{\"68\":1}}],[\"的二进制表示中第\",{\"1\":{\"68\":1,\"112\":1}}],[\"的二进制位右移\",{\"1\":{\"67\":1}}],[\"的二进制位\",{\"1\":{\"67\":1}}],[\"的指定位\",{\"1\":{\"67\":1}}],[\"的低\",{\"1\":{\"67\":6}}],[\"的商和余数\",{\"1\":{\"59\":1}}],[\"的值为\",{\"1\":{\"67\":1}}],[\"的值\",{\"1\":{\"58\":1,\"120\":1,\"121\":1}}],[\"的问题\",{\"1\":{\"52\":1}}],[\"的最大整数\",{\"1\":{\"155\":1}}],[\"的最大值\",{\"1\":{\"143\":1}}],[\"的最小整数的下标\",{\"1\":{\"155\":1}}],[\"的最小质因子也就是\",{\"1\":{\"104\":1}}],[\"的最小质因子就是\",{\"1\":{\"104\":1}}],[\"的最小质因子\",{\"1\":{\"104\":2,\"111\":3}}],[\"的最后一位\",{\"1\":{\"68\":1}}],[\"的最后一个元素\",{\"1\":{\"51\":1}}],[\"的最低位为\",{\"1\":{\"67\":1}}],[\"的最短hamilton路径\",{\"1\":{\"40\":1}}],[\"的所有因数\",{\"1\":{\"99\":1}}],[\"的所有出边\",{\"1\":{\"85\":1}}],[\"的所有路径\",{\"1\":{\"40\":1}}],[\"的所有方案\",{\"1\":{\"39\":1}}],[\"的棋盘可以摆放不同的\",{\"1\":{\"39\":1}}],[\"的树里各个数字有多少个\",{\"1\":{\"37\":1}}],[\"的各位数字有多少个\",{\"1\":{\"37\":2}}],[\"的出现次数\",{\"1\":{\"37\":1}}],[\"的方案数\",{\"1\":{\"36\":1}}],[\"的一种划分\",{\"1\":{\"36\":1}}],[\"的某个位置插入某个字符\",{\"1\":{\"34\":1}}],[\"的长度\",{\"1\":{\"32\":1}}],[\"的长度均不超过\",{\"1\":{\"32\":1}}],[\"的子序列的字符串长度最长是多少\",{\"1\":{\"31\":1}}],[\"的子序列又是\",{\"1\":{\"31\":1}}],[\"的字符串以及\",{\"1\":{\"33\":1}}],[\"的字符串\",{\"1\":{\"31\":1}}],[\"的背包\",{\"1\":{\"27\":1}}],[\"的写法\",{\"1\":{\"26\":1}}],[\"分别到达节点y1\",{\"1\":{\"129\":1}}],[\"分别适用于不同情况\",{\"1\":{\"49\":1}}],[\"分为两种情况\",{\"1\":{\"111\":1}}],[\"分为两大类\",{\"1\":{\"81\":1}}],[\"分解质因数的方式比较好用\",{\"1\":{\"121\":1}}],[\"分解质因数法求组合数\",{\"0\":{\"121\":1}}],[\"分解质因数\",{\"1\":{\"110\":1}}],[\"分成子问题\",{\"1\":{\"46\":2}}],[\"分治算法都有三步\",{\"1\":{\"46\":1}}],[\"分组背包\",{\"0\":{\"27\":1}}],[\"分布式计算中间件等\",{\"1\":{\"13\":1}}],[\"分布式应用软件借助这种软件在不同的技术之间共享资源\",{\"1\":{\"13\":1}}],[\"404\",{\"1\":{\"202\":1}}],[\"4\",{\"0\":{\"27\":1,\"32\":1,\"36\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":2,\"64\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":2,\"86\":1,\"87\":1,\"88\":1,\"112\":1,\"121\":1,\"128\":1,\"143\":1,\"163\":1},\"1\":{\"29\":3,\"32\":1,\"56\":1,\"57\":1,\"67\":7,\"84\":1,\"85\":1,\"102\":1,\"135\":1,\"149\":1,\"155\":1}}],[\"groupid>\",{\"1\":{\"195\":1}}],[\"greater<int>\",{\"1\":{\"155\":1}}],[\"greater<int>>\",{\"1\":{\"154\":1,\"162\":1}}],[\"greater<pii>>\",{\"1\":{\"83\":1}}],[\"go\",{\"1\":{\"191\":2}}],[\"google\",{\"1\":{\"191\":1}}],[\"goods\",{\"1\":{\"26\":4}}],[\"good\",{\"1\":{\"26\":5}}],[\"golang\",{\"1\":{\"191\":1}}],[\"g1\",{\"1\":{\"130\":1}}],[\"g被称为有向图游戏g1\",{\"1\":{\"130\":1}}],[\"gm的和\",{\"1\":{\"130\":1}}],[\"gm\",{\"1\":{\"130\":2}}],[\"g2\",{\"1\":{\"130\":3}}],[\"gauss\",{\"1\":{\"116\":1}}],[\"gcd\",{\"1\":{\"108\":3,\"114\":5}}],[\"getpresignedobjecturlargs\",{\"1\":{\"199\":1}}],[\"getpresignedobjecturl\",{\"1\":{\"199\":2}}],[\"getobjectargs\",{\"1\":{\"199\":1}}],[\"getobjectresponse\",{\"1\":{\"199\":3}}],[\"getobject\",{\"1\":{\"198\":1,\"199\":2}}],[\"getsecretkey\",{\"1\":{\"196\":1}}],[\"getaccesskey\",{\"1\":{\"196\":1}}],[\"getendpoint\",{\"1\":{\"196\":1}}],[\"get\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"106\":1,\"111\":1,\"121\":6,\"153\":1,\"199\":2}}],[\"g\",{\"1\":{\"37\":7,\"75\":1,\"82\":9,\"90\":7,\"129\":1,\"130\":1}}],[\"gitee\",{\"1\":{\"182\":1}}],[\"gitee镜像\",{\"1\":{\"182\":1}}],[\"github\",{\"1\":{\"167\":1,\"182\":2,\"186\":1,\"191\":3}}],[\"git\",{\"0\":{\"14\":1},\"1\":{\"8\":1}}],[\"build\",{\"0\":{\"205\":1},\"1\":{\"196\":1,\"198\":5,\"199\":7}}],[\"builder\",{\"1\":{\"196\":1,\"198\":5,\"199\":7}}],[\"bucketlist\",{\"1\":{\"198\":2}}],[\"bucket已经存在\",{\"1\":{\"198\":1}}],[\"bucketname\",{\"1\":{\"198\":5}}],[\"bucketexistsargs\",{\"1\":{\"198\":2}}],[\"bucketexists\",{\"1\":{\"198\":3}}],[\"bucket\",{\"0\":{\"198\":1},\"1\":{\"190\":2,\"196\":6,\"198\":10,\"199\":7}}],[\"blob\",{\"1\":{\"191\":1}}],[\"blog\",{\"2\":{\"169\":1}}],[\"b∗x\",{\"1\":{\"119\":1}}],[\"bm−2\",{\"1\":{\"119\":2}}],[\"b−1\",{\"1\":{\"119\":1}}],[\"b=0\",{\"1\":{\"114\":1}}],[\"b=0\",{\"1\":{\"114\":1}}],[\"by\",{\"1\":{\"114\":3,\"186\":1}}],[\"b是否连通的方法为\",{\"1\":{\"91\":1}}],[\"b不连通\",{\"1\":{\"91\":1}}],[\"b表示入点\",{\"1\":{\"84\":1}}],[\"bean\",{\"1\":{\"196\":2}}],[\"bellman\",{\"0\":{\"84\":1},\"1\":{\"81\":1,\"84\":2}}],[\"begin\",{\"1\":{\"30\":1,\"53\":4,\"59\":1,\"70\":2,\"71\":1,\"106\":1,\"154\":4,\"155\":6,\"164\":1}}],[\"bitset<10000>\",{\"1\":{\"154\":1}}],[\"bitset\",{\"1\":{\"154\":1}}],[\"bit\",{\"1\":{\"67\":1}}],[\"bsearch\",{\"1\":{\"50\":1,\"51\":1,\"54\":1}}],[\"break\",{\"1\":{\"39\":1,\"92\":2,\"104\":1,\"111\":1,\"121\":1,\"123\":1,\"163\":2}}],[\"boolean\",{\"1\":{\"198\":2}}],[\"bool\",{\"1\":{\"37\":1,\"39\":2,\"54\":1,\"57\":1,\"79\":1,\"82\":1,\"83\":1,\"85\":1,\"86\":2,\"90\":1,\"91\":1,\"92\":3,\"93\":2,\"98\":1,\"100\":1,\"102\":1,\"103\":2,\"104\":1,\"111\":1,\"121\":1,\"151\":1,\"155\":2,\"160\":1,\"161\":1,\"162\":1,\"163\":2}}],[\"bound\",{\"1\":{\"30\":1,\"53\":6,\"154\":8,\"155\":7}}],[\"base\",{\"1\":{\"37\":8,\"186\":3}}],[\"backup\",{\"1\":{\"84\":2}}],[\"back\",{\"1\":{\"26\":2,\"30\":3,\"37\":2,\"39\":1,\"56\":4,\"57\":5,\"58\":4,\"59\":4,\"71\":2,\"75\":2,\"100\":2,\"106\":2,\"121\":3,\"154\":7,\"164\":3,\"178\":1}}],[\"b​\",{\"1\":{\"34\":1,\"103\":4}}],[\"b\",{\"1\":{\"26\":4,\"31\":5,\"32\":8,\"33\":3,\"34\":6,\"37\":8,\"42\":4,\"53\":4,\"56\":14,\"57\":28,\"58\":11,\"59\":11,\"63\":2,\"67\":5,\"75\":12,\"82\":8,\"83\":2,\"84\":9,\"85\":3,\"88\":1,\"90\":5,\"91\":6,\"103\":13,\"107\":2,\"108\":7,\"112\":2,\"114\":17,\"115\":9,\"118\":2,\"119\":13,\"120\":16,\"121\":8,\"147\":2,\"148\":1,\"149\":4,\"155\":6}}],[\"aws\",{\"1\":{\"191\":2,\"198\":2}}],[\"amazon\",{\"1\":{\"191\":2}}],[\"amd64\",{\"1\":{\"183\":1,\"185\":1}}],[\"azure\",{\"1\":{\"191\":1}}],[\"ai\",{\"1\":{\"191\":1}}],[\"ai​\",{\"1\":{\"115\":1}}],[\"action\",{\"1\":{\"198\":1}}],[\"accesskey\",{\"1\":{\"196\":2}}],[\"account\",{\"1\":{\"190\":1}}],[\"acm\",{\"2\":{\"44\":1,\"73\":1,\"95\":1,\"132\":1,\"157\":1,\"166\":1}}],[\"application\",{\"1\":{\"196\":1}}],[\"api\",{\"0\":{\"197\":1},\"1\":{\"190\":2,\"191\":2,\"196\":1}}],[\"apache\",{\"1\":{\"189\":1}}],[\"ap−1≡1\",{\"1\":{\"119\":1}}],[\"arn\",{\"1\":{\"198\":1}}],[\"artifactid>\",{\"1\":{\"195\":1}}],[\"arguments>\",{\"1\":{\"186\":1}}],[\"arr\",{\"1\":{\"30\":7,\"160\":7,\"161\":9}}],[\"a5\",{\"1\":{\"139\":1}}],[\"a3\",{\"1\":{\"139\":2}}],[\"ay\",{\"1\":{\"139\":1}}],[\"a−2\",{\"1\":{\"120\":2}}],[\"a−1\",{\"1\":{\"120\":2}}],[\"a−b+1\",{\"1\":{\"120\":2}}],[\"a−b−1\",{\"1\":{\"120\":1}}],[\"a−b\",{\"1\":{\"119\":2,\"120\":3}}],[\"a∗\",{\"1\":{\"120\":2}}],[\"a1\",{\"1\":{\"115\":6,\"125\":1}}],[\"a1​\",{\"1\":{\"115\":1}}],[\"any\",{\"1\":{\"154\":1}}],[\"an\",{\"1\":{\"125\":1}}],[\"an​\",{\"1\":{\"115\":1}}],[\"ans++\",{\"1\":{\"160\":1}}],[\"ans\",{\"1\":{\"29\":4,\"30\":4,\"37\":13,\"52\":3,\"160\":2,\"164\":4,\"178\":4}}],[\"ax\",{\"1\":{\"114\":2,\"139\":2}}],[\"ax+by=1\",{\"1\":{\"114\":1}}],[\"ax+by=a\",{\"1\":{\"114\":1}}],[\"ax+by=gcd\",{\"1\":{\"114\":2}}],[\"ax+by\",{\"1\":{\"114\":1}}],[\"ak\",{\"1\":{\"112\":1}}],[\"abs\",{\"1\":{\"115\":2,\"116\":3}}],[\"ab=a2x1​×a2x2​×\",{\"1\":{\"112\":1}}],[\"ab\",{\"1\":{\"112\":1}}],[\"a2\",{\"1\":{\"115\":5,\"125\":1}}],[\"a2​\",{\"1\":{\"115\":1}}],[\"a2logk\",{\"1\":{\"112\":2}}],[\"a22\",{\"1\":{\"112\":2}}],[\"a21\",{\"1\":{\"112\":2}}],[\"a20\",{\"1\":{\"112\":2}}],[\"a表示出点\",{\"1\":{\"84\":1}}],[\"allow\",{\"1\":{\"198\":1}}],[\"alls\",{\"1\":{\"70\":9}}],[\"algorithm\",{\"1\":{\"53\":1},\"2\":{\"20\":1,\"43\":1,\"72\":1,\"94\":1,\"131\":1,\"156\":1,\"165\":1}}],[\"a的这一位数\",{\"1\":{\"57\":1}}],[\"a长度不等于b\",{\"1\":{\"57\":1}}],[\"address\",{\"1\":{\"183\":3,\"184\":1,\"185\":1}}],[\"add\",{\"1\":{\"56\":2,\"75\":3,\"83\":1,\"85\":1,\"135\":1}}],[\"a>b\",{\"1\":{\"37\":1}}],[\"a||b\",{\"1\":{\"37\":1}}],[\"ask\",{\"1\":{\"37\":3}}],[\"autorollattime>\",{\"1\":{\"186\":1}}],[\"auto\",{\"1\":{\"26\":1,\"37\":5,\"39\":1,\"56\":1,\"57\":2,\"58\":1,\"59\":1,\"71\":1,\"75\":1,\"83\":1,\"85\":1,\"86\":1,\"107\":1,\"162\":1,\"164\":1}}],[\"a\",{\"1\":{\"26\":4,\"29\":5,\"30\":10,\"31\":6,\"32\":8,\"33\":3,\"34\":10,\"35\":3,\"37\":8,\"42\":3,\"46\":7,\"47\":12,\"50\":1,\"51\":2,\"53\":13,\"56\":15,\"57\":27,\"58\":17,\"59\":15,\"61\":5,\"67\":17,\"75\":13,\"82\":9,\"83\":3,\"84\":9,\"85\":3,\"88\":1,\"90\":5,\"91\":8,\"103\":13,\"107\":2,\"108\":6,\"112\":5,\"114\":15,\"115\":6,\"116\":17,\"118\":2,\"119\":13,\"120\":22,\"121\":10,\"135\":2,\"144\":2,\"147\":2,\"148\":3,\"149\":4,\"155\":29}}],[\"k8s\",{\"1\":{\"191\":1}}],[\"kmp\",{\"0\":{\"143\":1}}],[\"k指向的下一节点指向新节点\",{\"1\":{\"135\":1}}],[\"k2\",{\"1\":{\"115\":2}}],[\"k1\",{\"1\":{\"115\":7}}],[\"kruskal\",{\"0\":{\"91\":1},\"1\":{\"91\":1}}],[\"k表示走到j这个点之前\",{\"1\":{\"40\":1}}],[\"k++\",{\"1\":{\"26\":2,\"27\":2,\"35\":2,\"37\":3,\"40\":1,\"47\":4,\"88\":1,\"152\":1}}],[\"k\",{\"1\":{\"26\":22,\"27\":10,\"35\":8,\"37\":12,\"39\":2,\"40\":7,\"47\":1,\"51\":1,\"67\":2,\"68\":9,\"75\":1,\"88\":4,\"104\":1,\"112\":9,\"119\":4,\"120\":4,\"135\":6,\"136\":11,\"149\":8,\"151\":5,\"152\":6,\"153\":2,\"154\":3,\"177\":2,\"178\":4}}],[\"system\",{\"1\":{\"198\":3,\"199\":6}}],[\"sdk\",{\"1\":{\"191\":7}}],[\"springboot\",{\"0\":{\"194\":1},\"1\":{\"196\":1}}],[\"spark\",{\"1\":{\"191\":1}}],[\"spfa求最短路\",{\"1\":{\"85\":1}}],[\"spfa算法判断图中是否存在负环\",{\"0\":{\"86\":1}}],[\"spfa算法\",{\"0\":{\"85\":1}}],[\"spfa\",{\"1\":{\"81\":1,\"85\":1,\"86\":1}}],[\"s3\",{\"1\":{\"189\":1,\"191\":5,\"198\":2}}],[\"shell\",{\"1\":{\"183\":1}}],[\"shtml\",{\"1\":{\"182\":1}}],[\"shuffle\",{\"1\":{\"155\":1}}],[\"solomon\",{\"1\":{\"191\":1}}],[\"solution\",{\"1\":{\"178\":1}}],[\"son\",{\"1\":{\"144\":7}}],[\"sort\",{\"1\":{\"46\":3,\"47\":3,\"53\":1,\"70\":1,\"71\":1,\"91\":1,\"106\":1,\"155\":4,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"s+1\",{\"1\":{\"143\":1}}],[\"s++\",{\"1\":{\"99\":1,\"123\":1}}],[\"s为模式串\",{\"1\":{\"143\":1}}],[\"sg\",{\"1\":{\"129\":5,\"130\":4}}],[\"sg游戏\",{\"0\":{\"129\":1}}],[\"sid\",{\"1\":{\"198\":1}}],[\"si​\",{\"1\":{\"123\":1}}],[\"sizethreshold>\",{\"1\":{\"186\":1}}],[\"size表示大小\",{\"1\":{\"149\":1}}],[\"sizeof\",{\"1\":{\"39\":1,\"40\":1,\"75\":1,\"82\":2,\"83\":1,\"84\":1,\"85\":1,\"90\":2,\"92\":1,\"93\":1}}],[\"size\",{\"1\":{\"30\":1,\"37\":3,\"56\":7,\"57\":12,\"58\":5,\"59\":4,\"70\":1,\"78\":1,\"83\":1,\"85\":1,\"86\":1,\"121\":1,\"147\":5,\"149\":8,\"154\":7,\"155\":1,\"162\":1,\"164\":1,\"178\":1,\"186\":1}}],[\"sum\",{\"1\":{\"121\":3}}],[\"substr\",{\"1\":{\"154\":1}}],[\"sub\",{\"1\":{\"57\":3}}],[\"s表示次幂\",{\"1\":{\"99\":1}}],[\"sqrt\",{\"1\":{\"98\":2,\"99\":5}}],[\"secretkey\",{\"1\":{\"196\":2}}],[\"second存储节点编号\",{\"1\":{\"83\":1}}],[\"second\",{\"1\":{\"71\":2,\"83\":1,\"107\":1,\"154\":2,\"164\":2,\"178\":1}}],[\"select\",{\"1\":{\"191\":1}}],[\"service>\",{\"1\":{\"186\":1}}],[\"server<\",{\"1\":{\"186\":2}}],[\"server\",{\"1\":{\"183\":4,\"184\":1,\"185\":2,\"186\":5}}],[\"search\",{\"1\":{\"184\":1}}],[\"setbucketpolicyargs\",{\"1\":{\"198\":1}}],[\"setbucketpolicy\",{\"1\":{\"198\":1}}],[\"set\",{\"1\":{\"154\":5}}],[\"seg\",{\"1\":{\"71\":5}}],[\"segs\",{\"1\":{\"71\":5}}],[\"scanf\",{\"1\":{\"42\":2,\"75\":2,\"115\":3}}],[\"swap\",{\"1\":{\"37\":1,\"46\":1,\"67\":1,\"116\":1,\"149\":6}}],[\"storage\",{\"1\":{\"190\":1}}],[\"statobjectargs\",{\"1\":{\"199\":1}}],[\"statobjectresponse\",{\"1\":{\"199\":3}}],[\"statobject\",{\"1\":{\"199\":2}}],[\"statement\",{\"1\":{\"198\":1}}],[\"state\",{\"1\":{\"39\":4}}],[\"stack\",{\"1\":{\"154\":1}}],[\"stl简介\",{\"0\":{\"154\":1}}],[\"st\",{\"1\":{\"39\":3,\"71\":1,\"77\":3,\"78\":3,\"82\":3,\"83\":3,\"85\":5,\"86\":5,\"90\":3,\"93\":5,\"102\":4,\"104\":5,\"111\":4,\"121\":3}}],[\"stream\",{\"1\":{\"199\":1}}],[\"string\",{\"1\":{\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"154\":1,\"196\":4,\"198\":2,\"199\":1}}],[\"strlen\",{\"1\":{\"33\":2}}],[\"str\",{\"1\":{\"33\":3,\"144\":6,\"153\":2,\"154\":1}}],[\"struct\",{\"1\":{\"26\":1,\"75\":1,\"84\":1,\"91\":1,\"155\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1}}],[\"stk\",{\"1\":{\"30\":7,\"138\":3,\"139\":2}}],[\"stderr\",{\"1\":{\"183\":1}}],[\"stdout\",{\"1\":{\"183\":2}}],[\"stdc++\",{\"1\":{\"37\":1,\"42\":1,\"90\":1,\"91\":1}}],[\"std\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"42\":1,\"53\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"82\":1,\"90\":1,\"91\":1,\"107\":1,\"115\":1,\"123\":1,\"125\":1,\"143\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"s\",{\"1\":{\"26\":18,\"27\":8,\"33\":3,\"35\":5,\"61\":3,\"62\":5,\"64\":4,\"75\":4,\"99\":2,\"123\":2,\"128\":2,\"129\":2,\"143\":5,\"154\":4,\"191\":2}}],[\"≤100\",{\"1\":{\"26\":1}}],[\"310\",{\"1\":{\"35\":1}}],[\"3010\",{\"1\":{\"32\":1}}],[\"3000\",{\"1\":{\"32\":1}}],[\"3\",{\"0\":{\"26\":1,\"31\":1,\"35\":1,\"48\":1,\"49\":1,\"52\":1,\"53\":2,\"54\":1,\"58\":1,\"63\":1,\"68\":1,\"79\":1,\"84\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":2,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"120\":1,\"127\":1,\"140\":1,\"141\":1,\"142\":1,\"148\":1,\"153\":1,\"162\":1},\"1\":{\"29\":1,\"32\":2,\"54\":1,\"56\":1,\"57\":1,\"67\":3,\"68\":1,\"75\":1,\"84\":1,\"85\":1,\"91\":1,\"102\":2,\"116\":1,\"121\":1,\"126\":1,\"135\":1,\"149\":1,\"154\":1,\"155\":1,\"199\":1}}],[\"2>\",{\"1\":{\"183\":2}}],[\"239\",{\"1\":{\"176\":1}}],[\"231−1\",{\"1\":{\"32\":1}}],[\"2^64\",{\"1\":{\"153\":1}}],[\"2x\",{\"1\":{\"149\":2}}],[\"26\",{\"1\":{\"144\":1}}],[\"2n\",{\"1\":{\"115\":1,\"122\":1}}],[\"2ll\",{\"1\":{\"103\":1}}],[\"2k\",{\"1\":{\"67\":2}}],[\"2e5\",{\"1\":{\"53\":1,\"91\":1}}],[\"2e9\",{\"1\":{\"30\":1,\"71\":4,\"160\":1,\"163\":1,\"164\":4}}],[\"2012\",{\"1\":{\"198\":1}}],[\"2010\",{\"1\":{\"26\":2}}],[\"20\",{\"1\":{\"40\":1,\"123\":1}}],[\"2\",{\"0\":{\"25\":1,\"28\":1,\"29\":1,\"30\":2,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"40\":1,\"47\":1,\"52\":1,\"57\":1,\"62\":1,\"67\":1,\"76\":1,\"83\":1,\"87\":1,\"88\":1,\"91\":1,\"99\":1,\"103\":1,\"105\":1,\"106\":1,\"107\":2,\"108\":1,\"111\":1,\"119\":1,\"126\":1,\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"142\":1,\"147\":1,\"152\":1,\"161\":1},\"1\":{\"26\":2,\"29\":3,\"32\":5,\"35\":2,\"36\":4,\"37\":2,\"42\":2,\"46\":2,\"47\":1,\"51\":2,\"54\":1,\"56\":1,\"57\":2,\"61\":1,\"67\":9,\"69\":1,\"70\":1,\"75\":2,\"79\":1,\"81\":1,\"82\":1,\"84\":3,\"85\":1,\"88\":1,\"90\":2,\"91\":1,\"92\":2,\"98\":2,\"99\":1,\"100\":2,\"102\":5,\"103\":2,\"104\":1,\"107\":1,\"110\":1,\"111\":1,\"115\":1,\"116\":2,\"119\":1,\"120\":1,\"121\":2,\"123\":1,\"126\":1,\"135\":1,\"136\":1,\"143\":1,\"149\":12,\"154\":1,\"155\":1,\"161\":1,\"191\":2}}],[\">1\",{\"1\":{\"99\":1}}],[\">b\",{\"1\":{\"75\":1,\"84\":1}}],[\">\",{\"1\":{\"26\":1,\"30\":1,\"32\":1,\"46\":2,\"54\":1,\"57\":5,\"58\":1,\"59\":2,\"75\":3,\"82\":1,\"83\":1,\"84\":3,\"85\":2,\"86\":1,\"90\":1,\"99\":1,\"107\":1,\"110\":1,\"116\":3,\"123\":1,\"138\":1,\"155\":1,\"160\":1,\"183\":2,\"186\":1,\"198\":1,\"199\":1}}],[\">=0\",{\"1\":{\"37\":1}}],[\">=\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":3,\"29\":2,\"36\":1,\"46\":1,\"47\":1,\"50\":1,\"51\":1,\"56\":5,\"57\":12,\"58\":4,\"59\":4,\"68\":1,\"70\":1,\"86\":1,\"116\":3,\"139\":2,\"162\":1,\"163\":1}}],[\">>=\",{\"1\":{\"112\":1,\"119\":1,\"120\":1,\"149\":1}}],[\">>\",{\"1\":{\"24\":4,\"25\":4,\"26\":15,\"27\":10,\"29\":2,\"30\":7,\"31\":4,\"32\":3,\"33\":5,\"34\":4,\"35\":2,\"36\":1,\"37\":2,\"39\":3,\"40\":3,\"42\":1,\"47\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":3,\"56\":2,\"57\":2,\"58\":2,\"59\":2,\"66\":1,\"67\":2,\"68\":5,\"70\":1,\"75\":2,\"82\":5,\"90\":5,\"107\":2,\"120\":4,\"123\":4,\"125\":2,\"143\":4,\"154\":1,\"160\":3,\"161\":3,\"162\":3,\"163\":5,\"164\":3}}],[\"一直递归寻找最下层的左节点\",{\"1\":{\"173\":1}}],[\"一直走到底层\",{\"1\":{\"29\":1}}],[\"一定等于\",{\"1\":{\"119\":1}}],[\"一定在\",{\"1\":{\"115\":1}}],[\"一定存在整数对\",{\"1\":{\"114\":1}}],[\"一定存在整数\",{\"1\":{\"114\":1}}],[\"一定不含有奇数环\",{\"1\":{\"92\":1}}],[\"一定要先累加\",{\"1\":{\"90\":1}}],[\"一定满足\",{\"1\":{\"84\":1}}],[\"一定至少存在一个入度为\",{\"1\":{\"79\":1}}],[\"一般是\",{\"1\":{\"58\":1,\"59\":1}}],[\"一般来说\",{\"1\":{\"52\":1}}],[\"一个对象会被分成\",{\"1\":{\"191\":1}}],[\"一个指向后\",{\"1\":{\"136\":1}}],[\"一个指向前\",{\"1\":{\"136\":1}}],[\"一个图所有匹配中\",{\"1\":{\"93\":1}}],[\"一个\",{\"1\":{\"93\":1}}],[\"一个有向无环图\",{\"1\":{\"79\":1}}],[\"一个正整数\",{\"1\":{\"36\":1}}],[\"一个数的倍数一定是合数\",{\"1\":{\"102\":1}}],[\"一个数\",{\"1\":{\"30\":1}}],[\"一\",{\"1\":{\"27\":1,\"30\":1}}],[\"一维差分\",{\"0\":{\"63\":1}}],[\"一维前缀和\",{\"0\":{\"61\":1}}],[\"一维优化\",{\"1\":{\"36\":1}}],[\"一维优化写法\",{\"1\":{\"26\":1}}],[\"一维\",{\"1\":{\"24\":1,\"25\":1}}],[\"一次\",{\"1\":{\"24\":1}}],[\"+x\",{\"1\":{\"183\":1}}],[\"+2xt​​\",{\"1\":{\"112\":1}}],[\"+inf\",{\"1\":{\"90\":1}}],[\"+happy\",{\"1\":{\"42\":1}}],[\"++size\",{\"1\":{\"149\":1}}],[\"++res\",{\"1\":{\"100\":1}}],[\"++tt\",{\"1\":{\"79\":2,\"138\":1,\"139\":1,\"141\":1,\"142\":1}}],[\"++\",{\"1\":{\"36\":5,\"37\":2,\"39\":6,\"42\":1,\"75\":4,\"82\":3,\"84\":2,\"86\":1,\"91\":1,\"92\":1,\"93\":1,\"107\":3,\"111\":3,\"116\":7,\"119\":1,\"120\":1,\"121\":7,\"135\":1,\"144\":4,\"147\":1,\"148\":1,\"151\":1,\"153\":1,\"154\":1}}],[\"+f\",{\"1\":{\"36\":1}}],[\"+1\",{\"1\":{\"31\":1}}],[\"+=\",{\"1\":{\"26\":4,\"37\":4,\"39\":1,\"42\":2,\"53\":1,\"56\":2,\"58\":1,\"63\":1,\"64\":2,\"90\":1,\"91\":1,\"102\":1,\"103\":2,\"121\":2,\"123\":1,\"146\":2,\"147\":1,\"148\":1}}],[\"+\",{\"1\":{\"24\":2,\"25\":2,\"26\":4,\"27\":2,\"29\":6,\"30\":6,\"31\":3,\"32\":1,\"33\":7,\"34\":8,\"35\":12,\"36\":10,\"37\":4,\"40\":2,\"42\":2,\"46\":5,\"47\":4,\"50\":4,\"51\":2,\"52\":2,\"53\":8,\"54\":1,\"56\":3,\"57\":2,\"59\":1,\"61\":4,\"62\":1,\"63\":1,\"64\":4,\"68\":1,\"69\":1,\"70\":3,\"75\":3,\"76\":1,\"81\":1,\"82\":2,\"83\":2,\"84\":4,\"85\":2,\"86\":3,\"88\":1,\"90\":2,\"91\":2,\"92\":1,\"102\":5,\"103\":1,\"104\":1,\"107\":11,\"114\":3,\"115\":2,\"116\":2,\"118\":1,\"120\":1,\"121\":3,\"122\":1,\"143\":4,\"149\":5,\"151\":2,\"152\":1,\"153\":2,\"154\":1,\"155\":13,\"160\":4,\"161\":4,\"162\":2,\"163\":2,\"164\":1,\"198\":5}}],[\"00<\",{\"1\":{\"186\":1}}],[\"00\",{\"1\":{\"186\":1}}],[\"0001\",{\"1\":{\"67\":1}}],[\"0000\",{\"1\":{\"67\":6}}],[\"0号点既是根节点\",{\"1\":{\"144\":1}}],[\"0和1都被占用了\",{\"1\":{\"136\":1}}],[\"0是左端点\",{\"1\":{\"136\":1}}],[\"0表示白色\",{\"1\":{\"92\":1}}],[\"0变1\",{\"1\":{\"66\":1}}],[\"0x3f3f3f3f\",{\"1\":{\"82\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"0x3f\",{\"1\":{\"40\":1,\"82\":2,\"83\":1,\"84\":1,\"85\":1,\"90\":2}}],[\"0个\",{\"1\":{\"36\":1}}],[\"0\",{\"1\":{\"24\":2,\"25\":2,\"26\":8,\"27\":9,\"29\":4,\"30\":11,\"31\":1,\"32\":2,\"33\":8,\"34\":5,\"35\":1,\"36\":6,\"37\":19,\"39\":13,\"40\":13,\"42\":16,\"47\":2,\"53\":4,\"56\":10,\"57\":19,\"58\":9,\"59\":9,\"67\":39,\"68\":4,\"69\":2,\"70\":1,\"75\":6,\"79\":3,\"82\":3,\"83\":2,\"84\":3,\"85\":1,\"88\":1,\"90\":3,\"91\":5,\"92\":2,\"93\":2,\"98\":1,\"99\":3,\"100\":3,\"103\":2,\"104\":4,\"106\":1,\"107\":2,\"110\":2,\"111\":4,\"112\":1,\"114\":1,\"115\":3,\"116\":5,\"118\":2,\"119\":3,\"120\":2,\"121\":8,\"123\":6,\"125\":3,\"135\":1,\"136\":2,\"138\":2,\"139\":1,\"141\":1,\"142\":2,\"143\":4,\"144\":6,\"146\":1,\"148\":1,\"152\":1,\"153\":1,\"160\":2,\"161\":1,\"162\":3,\"163\":4,\"164\":2,\"178\":1,\"189\":1}}],[\"01\",{\"0\":{\"24\":1}}],[\"jpg\",{\"1\":{\"199\":9}}],[\"json串\",{\"1\":{\"198\":1}}],[\"jbods\",{\"1\":{\"191\":1}}],[\"j表示第几个区间\",{\"1\":{\"163\":1}}],[\"j表示走到哪一个点\",{\"1\":{\"40\":1}}],[\"j走到哪了呀\",{\"1\":{\"143\":1}}],[\"j+1\",{\"1\":{\"143\":1}}],[\"j++\",{\"1\":{\"24\":1,\"25\":2,\"26\":1,\"27\":2,\"29\":3,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"37\":3,\"40\":2,\"47\":3,\"69\":1,\"88\":2,\"90\":2,\"104\":1,\"118\":1,\"123\":1,\"143\":2,\"163\":1}}],[\"j−i\",{\"1\":{\"36\":1}}],[\"j\",{\"1\":{\"24\":14,\"25\":13,\"26\":25,\"27\":22,\"29\":19,\"30\":6,\"31\":16,\"32\":9,\"33\":16,\"34\":27,\"35\":16,\"36\":28,\"37\":12,\"39\":18,\"40\":14,\"46\":14,\"47\":8,\"62\":1,\"69\":4,\"77\":3,\"78\":4,\"79\":3,\"82\":12,\"83\":5,\"84\":6,\"85\":6,\"86\":8,\"88\":10,\"90\":10,\"92\":4,\"93\":6,\"102\":4,\"103\":9,\"104\":15,\"111\":20,\"116\":10,\"118\":7,\"120\":4,\"121\":8,\"123\":5,\"143\":20,\"163\":5}}],[\"java\",{\"1\":{\"7\":1,\"191\":2}}],[\"item\",{\"1\":{\"199\":3}}],[\"itemresult\",{\"1\":{\"199\":2}}],[\"iterable<result<item>>\",{\"1\":{\"199\":1}}],[\"io\",{\"0\":{\"208\":1},\"1\":{\"167\":1,\"185\":1,\"189\":1}}],[\"i+1\",{\"1\":{\"115\":1}}],[\"i++\",{\"1\":{\"24\":3,\"25\":3,\"26\":6,\"27\":3,\"29\":4,\"30\":7,\"31\":1,\"32\":4,\"33\":4,\"34\":2,\"35\":3,\"37\":8,\"40\":2,\"42\":3,\"46\":1,\"47\":3,\"53\":2,\"56\":1,\"57\":1,\"58\":1,\"69\":1,\"75\":1,\"79\":1,\"88\":2,\"90\":3,\"91\":2,\"98\":1,\"99\":1,\"100\":3,\"102\":1,\"103\":3,\"104\":1,\"106\":1,\"110\":1,\"115\":1,\"118\":1,\"123\":2,\"139\":1,\"142\":1,\"143\":2,\"146\":1,\"160\":2,\"161\":2,\"162\":2,\"163\":1,\"164\":1,\"178\":2}}],[\"i的最小质因子\",{\"1\":{\"104\":1}}],[\"i是素数\",{\"1\":{\"103\":1}}],[\"impossible\",{\"1\":{\"90\":1}}],[\"id>\",{\"1\":{\"186\":1}}],[\"idx表示当前用到了哪个节点\",{\"1\":{\"135\":1,\"136\":1}}],[\"idx++\",{\"1\":{\"83\":1,\"85\":1,\"135\":1,\"136\":1}}],[\"idx\",{\"1\":{\"75\":5,\"83\":4,\"85\":4,\"86\":1,\"92\":1,\"93\":1,\"135\":8,\"136\":6,\"144\":2,\"151\":4}}],[\"id\",{\"1\":{\"75\":3,\"155\":1}}],[\"i表示所有的情况\",{\"1\":{\"40\":1}}],[\"isbucketexists\",{\"1\":{\"198\":4}}],[\"is\",{\"1\":{\"39\":4,\"98\":1,\"100\":1,\"103\":8}}],[\"i==nums\",{\"1\":{\"37\":1}}],[\"i−1个\",{\"1\":{\"111\":1}}],[\"i−1均与\",{\"1\":{\"111\":1}}],[\"i−1\",{\"1\":{\"36\":1}}],[\"if\",{\"1\":{\"24\":1,\"25\":1,\"26\":2,\"27\":2,\"30\":4,\"31\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":1,\"36\":1,\"37\":4,\"39\":4,\"40\":2,\"42\":3,\"46\":2,\"47\":2,\"50\":1,\"51\":1,\"52\":1,\"54\":1,\"56\":3,\"57\":5,\"58\":1,\"67\":3,\"70\":1,\"71\":3,\"75\":3,\"77\":1,\"78\":1,\"79\":2,\"82\":2,\"83\":3,\"84\":4,\"85\":3,\"86\":3,\"88\":1,\"90\":4,\"91\":6,\"92\":5,\"93\":3,\"98\":2,\"99\":2,\"100\":4,\"102\":1,\"103\":1,\"104\":2,\"106\":2,\"107\":1,\"110\":2,\"111\":2,\"112\":1,\"114\":1,\"115\":2,\"116\":5,\"118\":1,\"119\":1,\"120\":3,\"121\":2,\"123\":4,\"125\":1,\"138\":1,\"141\":1,\"142\":2,\"143\":3,\"144\":2,\"146\":2,\"147\":1,\"148\":1,\"149\":3,\"151\":1,\"152\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":3,\"164\":3,\"198\":1}}],[\"i\",{\"1\":{\"24\":20,\"25\":19,\"26\":30,\"27\":14,\"29\":25,\"30\":32,\"31\":16,\"32\":18,\"33\":22,\"34\":27,\"35\":26,\"36\":44,\"37\":44,\"39\":19,\"40\":15,\"42\":17,\"46\":11,\"47\":9,\"53\":7,\"56\":19,\"57\":29,\"58\":12,\"59\":12,\"61\":2,\"62\":1,\"68\":2,\"69\":5,\"75\":15,\"77\":5,\"78\":5,\"79\":10,\"82\":3,\"83\":7,\"84\":3,\"85\":7,\"86\":12,\"88\":10,\"90\":9,\"91\":10,\"92\":10,\"93\":9,\"98\":4,\"99\":7,\"100\":18,\"102\":6,\"103\":17,\"104\":15,\"106\":8,\"107\":7,\"110\":8,\"111\":26,\"115\":2,\"116\":30,\"118\":7,\"119\":9,\"120\":3,\"121\":22,\"123\":6,\"139\":4,\"142\":4,\"143\":14,\"144\":9,\"146\":5,\"147\":6,\"148\":6,\"149\":4,\"151\":5,\"153\":8,\"155\":1,\"160\":8,\"161\":9,\"162\":7,\"163\":8,\"164\":2,\"178\":9}}],[\"install\",{\"1\":{\"186\":1}}],[\"insert\",{\"1\":{\"135\":1,\"136\":1,\"144\":1,\"151\":1,\"154\":2}}],[\"inline\",{\"1\":{\"115\":1}}],[\"index\",{\"1\":{\"190\":1}}],[\"index指向下一个指针\",{\"1\":{\"135\":1}}],[\"ind\",{\"1\":{\"42\":5}}],[\"init\",{\"1\":{\"37\":2,\"91\":2,\"135\":1,\"136\":1,\"146\":1}}],[\"infact\",{\"1\":{\"119\":4}}],[\"inf\",{\"1\":{\"29\":3,\"84\":3,\"88\":1,\"90\":3,\"91\":1}}],[\"int>>\",{\"1\":{\"178\":1}}],[\"int>\",{\"1\":{\"83\":1,\"100\":2,\"107\":1,\"154\":1,\"164\":1}}],[\"int\",{\"1\":{\"24\":10,\"25\":10,\"26\":32,\"27\":19,\"29\":15,\"30\":25,\"31\":6,\"32\":12,\"33\":14,\"34\":8,\"35\":14,\"36\":9,\"37\":25,\"39\":10,\"40\":9,\"42\":12,\"46\":4,\"47\":6,\"50\":4,\"51\":4,\"52\":5,\"53\":5,\"56\":7,\"57\":8,\"58\":7,\"59\":8,\"67\":2,\"68\":10,\"69\":1,\"70\":4,\"71\":1,\"75\":19,\"77\":4,\"78\":3,\"79\":5,\"82\":11,\"83\":10,\"84\":7,\"85\":10,\"86\":7,\"88\":5,\"90\":15,\"91\":17,\"92\":8,\"93\":8,\"98\":2,\"99\":3,\"100\":6,\"102\":4,\"103\":4,\"104\":5,\"106\":2,\"107\":5,\"108\":6,\"110\":4,\"111\":6,\"112\":5,\"114\":6,\"115\":1,\"116\":13,\"118\":2,\"119\":6,\"120\":14,\"121\":16,\"123\":9,\"125\":4,\"135\":5,\"136\":4,\"138\":2,\"139\":2,\"141\":1,\"142\":2,\"143\":6,\"144\":10,\"146\":9,\"147\":4,\"148\":5,\"149\":7,\"151\":6,\"152\":4,\"153\":3,\"155\":10,\"160\":8,\"161\":7,\"162\":6,\"163\":9,\"164\":6,\"178\":4}}],[\"include<algorithm>\",{\"1\":{\"40\":1}}],[\"include<cstring>\",{\"1\":{\"40\":1}}],[\"include<iostream>\",{\"1\":{\"40\":1,\"123\":1}}],[\"include\",{\"1\":{\"24\":3,\"25\":3,\"26\":10,\"27\":6,\"29\":2,\"30\":9,\"31\":3,\"32\":3,\"33\":3,\"34\":3,\"35\":3,\"36\":1,\"37\":1,\"39\":4,\"42\":1,\"53\":2,\"56\":2,\"57\":2,\"58\":2,\"59\":3,\"68\":2,\"82\":3,\"90\":1,\"91\":1,\"107\":4,\"115\":2,\"125\":2,\"143\":1,\"160\":2,\"161\":2,\"162\":3,\"163\":2,\"164\":4}}],[\"creationdate\",{\"1\":{\"198\":1}}],[\"credentials\",{\"1\":{\"196\":1}}],[\"cmd\",{\"1\":{\"185\":1,\"186\":1}}],[\"cmp\",{\"1\":{\"57\":2,\"155\":2}}],[\"cn\",{\"1\":{\"182\":1,\"183\":1,\"189\":1,\"191\":1}}],[\"cnt记录素数个数\",{\"1\":{\"102\":1}}],[\"cnt++\",{\"1\":{\"26\":2,\"39\":1,\"91\":1,\"102\":1,\"104\":1}}],[\"cnt\",{\"1\":{\"26\":6,\"37\":3,\"39\":4,\"86\":5,\"91\":3,\"102\":1,\"104\":1,\"111\":2,\"121\":4,\"144\":4}}],[\"cli\",{\"1\":{\"191\":1}}],[\"client\",{\"1\":{\"191\":1}}],[\"class\",{\"1\":{\"178\":1,\"196\":2}}],[\"clear\",{\"1\":{\"39\":1,\"154\":4}}],[\"c++\",{\"0\":{\"154\":1}}],[\"c++代码模板\",{\"1\":{\"50\":1,\"51\":1}}],[\"catch\",{\"1\":{\"199\":1}}],[\"cat\",{\"1\":{\"122\":1}}],[\"cab​\",{\"1\":{\"121\":1}}],[\"cab​≡ca\",{\"1\":{\"120\":1}}],[\"cab​=b\",{\"1\":{\"119\":1}}],[\"cab​=ca−1b−1​+ca−1b​\",{\"1\":{\"118\":1}}],[\"cab​modp\",{\"1\":{\"120\":1}}],[\"cab​mod\",{\"1\":{\"118\":1}}],[\"cba​=\",{\"1\":{\"120\":1}}],[\"ck\",{\"1\":{\"107\":1}}],[\"c2\",{\"1\":{\"107\":1}}],[\"c1\",{\"1\":{\"107\":1}}],[\"c表示当前点的颜色\",{\"1\":{\"92\":1}}],[\"c\",{\"1\":{\"53\":8,\"56\":9,\"57\":14,\"58\":11,\"59\":12,\"63\":2,\"64\":4,\"75\":4,\"82\":5,\"83\":2,\"85\":2,\"90\":3,\"91\":1,\"92\":4,\"102\":1,\"116\":13,\"118\":5,\"120\":6,\"121\":5,\"122\":1,\"154\":1}}],[\"chmod\",{\"1\":{\"183\":1}}],[\"checksum\",{\"1\":{\"191\":1}}],[\"check\",{\"1\":{\"37\":1,\"51\":2,\"52\":1,\"54\":2,\"69\":1,\"92\":1,\"139\":1,\"142\":2}}],[\"char\",{\"1\":{\"31\":1,\"33\":4,\"34\":1,\"143\":1,\"144\":2}}],[\"code\",{\"1\":{\"191\":1}}],[\"cos\",{\"1\":{\"190\":1}}],[\"component\",{\"1\":{\"196\":1}}],[\"com\",{\"1\":{\"182\":2,\"186\":1,\"191\":3}}],[\"count\",{\"1\":{\"154\":2}}],[\"cout\",{\"1\":{\"24\":2,\"25\":2,\"26\":4,\"27\":2,\"29\":2,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":2,\"39\":1,\"40\":1,\"53\":1,\"59\":2,\"68\":2,\"82\":1,\"99\":3,\"107\":1,\"120\":1,\"123\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"color\",{\"1\":{\"92\":7}}],[\"config\",{\"1\":{\"196\":1,\"198\":1}}],[\"configuration\",{\"1\":{\"196\":1}}],[\"configurationproperties\",{\"1\":{\"196\":1}}],[\"console\",{\"1\":{\"183\":3,\"184\":1,\"185\":1}}],[\"const\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"39\":1,\"40\":1,\"53\":1,\"54\":1,\"56\":1,\"68\":1,\"82\":1,\"90\":1,\"91\":3,\"107\":1,\"116\":1,\"123\":1,\"143\":1,\"155\":2,\"160\":3,\"161\":3,\"162\":3,\"163\":3,\"164\":1}}],[\"continue\",{\"1\":{\"35\":1,\"83\":1,\"102\":1,\"116\":1}}],[\"cin>>n\",{\"1\":{\"40\":1}}],[\"cin\",{\"1\":{\"24\":2,\"25\":2,\"26\":6,\"27\":6,\"29\":2,\"30\":6,\"31\":1,\"32\":3,\"33\":3,\"34\":2,\"35\":2,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"42\":1,\"53\":2,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"75\":1,\"82\":2,\"90\":2,\"107\":2,\"120\":2,\"123\":2,\"125\":2,\"143\":2,\"160\":2,\"161\":2,\"162\":2,\"163\":3,\"164\":2}}],[\"found\",{\"1\":{\"202\":1}}],[\"foreach\",{\"1\":{\"198\":1,\"199\":1}}],[\"ford算法擅长解决有边数限制的最短路问题\",{\"1\":{\"84\":1}}],[\"ford算法\",{\"0\":{\"84\":1}}],[\"ford算法的优化\",{\"1\":{\"81\":1}}],[\"ford\",{\"1\":{\"81\":1,\"84\":1}}],[\"for\",{\"0\":{\"203\":1},\"1\":{\"24\":5,\"25\":5,\"26\":14,\"27\":9,\"29\":9,\"30\":8,\"31\":2,\"32\":5,\"33\":6,\"34\":4,\"35\":7,\"36\":5,\"37\":16,\"39\":7,\"40\":5,\"42\":3,\"47\":1,\"53\":2,\"56\":4,\"57\":6,\"58\":3,\"59\":3,\"68\":1,\"69\":1,\"71\":1,\"75\":5,\"77\":1,\"78\":1,\"79\":2,\"82\":3,\"83\":1,\"84\":5,\"85\":1,\"86\":2,\"88\":5,\"90\":5,\"91\":2,\"92\":2,\"93\":2,\"98\":1,\"99\":1,\"100\":3,\"102\":2,\"103\":5,\"104\":2,\"106\":1,\"107\":2,\"110\":1,\"111\":2,\"115\":1,\"116\":9,\"118\":2,\"119\":1,\"120\":1,\"121\":6,\"123\":3,\"139\":1,\"142\":1,\"143\":2,\"144\":2,\"146\":1,\"147\":1,\"148\":1,\"149\":1,\"151\":1,\"153\":1,\"160\":2,\"161\":2,\"162\":2,\"163\":2,\"164\":2,\"178\":2}}],[\"flip\",{\"1\":{\"154\":2}}],[\"flag\",{\"1\":{\"92\":3}}],[\"floyd算法\",{\"0\":{\"88\":1}}],[\"front\",{\"1\":{\"78\":1,\"85\":2,\"86\":1,\"154\":5}}],[\"fact\",{\"1\":{\"119\":3}}],[\"factor\",{\"1\":{\"100\":1}}],[\"fabs\",{\"1\":{\"116\":2}}],[\"father\",{\"1\":{\"75\":2}}],[\"false\",{\"1\":{\"37\":1,\"39\":2,\"85\":1,\"86\":2,\"92\":3,\"93\":2,\"98\":2,\"100\":1,\"103\":1,\"112\":2,\"151\":1,\"163\":1}}],[\"fileoutputstream\",{\"1\":{\"199\":1}}],[\"filename\",{\"1\":{\"199\":1}}],[\"fileinputstream\",{\"1\":{\"199\":1}}],[\"file\",{\"1\":{\"199\":5}}],[\"first存储距离\",{\"1\":{\"83\":1}}],[\"first\",{\"1\":{\"71\":2,\"83\":1,\"107\":1,\"154\":2,\"164\":2,\"178\":2}}],[\"find\",{\"1\":{\"52\":1,\"70\":1,\"91\":6,\"93\":3,\"146\":4,\"147\":6,\"148\":5,\"151\":1,\"152\":1,\"154\":2}}],[\"f\",{\"1\":{\"24\":12,\"25\":11,\"26\":19,\"27\":10,\"29\":11,\"30\":9,\"31\":14,\"32\":7,\"33\":13,\"34\":22,\"35\":7,\"36\":25,\"37\":7,\"39\":8,\"40\":12,\"42\":12,\"163\":3}}],[\"winsw\",{\"1\":{\"186\":4}}],[\"windows\",{\"0\":{\"185\":1,\"186\":1},\"1\":{\"185\":2,\"186\":3}}],[\"web\",{\"1\":{\"185\":1}}],[\"web中间件\",{\"1\":{\"13\":1}}],[\"wget\",{\"1\":{\"183\":1}}],[\"www\",{\"1\":{\"182\":1,\"191\":1}}],[\"w表示边的权重\",{\"1\":{\"84\":1}}],[\"w表示的是无权图\",{\"1\":{\"40\":1}}],[\"while\",{\"1\":{\"26\":1,\"30\":1,\"33\":1,\"37\":3,\"39\":1,\"46\":3,\"47\":3,\"50\":1,\"51\":1,\"52\":1,\"54\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"69\":1,\"70\":1,\"78\":1,\"79\":1,\"82\":1,\"83\":1,\"85\":2,\"86\":1,\"99\":1,\"100\":1,\"107\":3,\"110\":1,\"112\":1,\"119\":1,\"120\":2,\"121\":2,\"125\":1,\"139\":1,\"142\":1,\"143\":2,\"149\":1,\"152\":1,\"163\":1,\"178\":1}}],[\"w\",{\"1\":{\"24\":4,\"25\":4,\"26\":14,\"27\":6,\"35\":1,\"40\":4,\"75\":2,\"83\":4,\"84\":8,\"85\":4,\"86\":3,\"91\":8,\"160\":2,\"161\":2,\"162\":2,\"163\":2}}],[\"v4\",{\"1\":{\"191\":1}}],[\"v2\",{\"1\":{\"189\":1,\"191\":1}}],[\"vuepress\",{\"1\":{\"167\":3}}],[\"vector\",{\"1\":{\"154\":1,\"155\":3,\"164\":1}}],[\"vector<node>\",{\"1\":{\"155\":1}}],[\"vector<edge>\",{\"1\":{\"75\":1}}],[\"vector<pii>\",{\"1\":{\"71\":2,\"83\":1,\"164\":1}}],[\"vector<int>\",{\"1\":{\"30\":2,\"37\":8,\"39\":1,\"56\":5,\"57\":7,\"58\":4,\"59\":4,\"70\":1,\"100\":2,\"106\":2,\"121\":4,\"154\":1,\"155\":1,\"162\":1,\"178\":3}}],[\"vector<good>\",{\"1\":{\"26\":1}}],[\"version\",{\"1\":{\"198\":1}}],[\"version>\",{\"1\":{\"195\":1}}],[\"ver\",{\"1\":{\"83\":4}}],[\"val\",{\"1\":{\"53\":4}}],[\"valid\",{\"1\":{\"39\":4}}],[\"vis\",{\"1\":{\"42\":3}}],[\"void\",{\"1\":{\"37\":2,\"42\":1,\"46\":1,\"47\":1,\"67\":1,\"71\":1,\"75\":2,\"83\":1,\"91\":2,\"99\":1,\"102\":1,\"103\":1,\"104\":1,\"111\":1,\"121\":1,\"135\":5,\"136\":3,\"144\":1,\"146\":2,\"149\":3,\"151\":1,\"164\":1,\"198\":4,\"199\":6}}],[\"v\",{\"1\":{\"24\":6,\"25\":6,\"26\":19,\"27\":8,\"154\":1}}],[\"=p\",{\"1\":{\"143\":1}}],[\"=1\",{\"1\":{\"114\":1}}],[\"=10\",{\"1\":{\"37\":2}}],[\"=n×p1​p1​−1​×p2​p2​−1​×\",{\"1\":{\"110\":1}}],[\"=>\",{\"1\":{\"103\":1}}],[\"=∑u=sonsdp\",{\"1\":{\"42\":1}}],[\"=∑u=sonsmax\",{\"1\":{\"42\":1}}],[\"=0\",{\"1\":{\"40\":1}}],[\"=f\",{\"1\":{\"36\":1}}],[\"==\",{\"1\":{\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"39\":1,\"57\":1,\"58\":1,\"59\":1,\"67\":3,\"79\":2,\"82\":2,\"83\":1,\"84\":1,\"85\":1,\"88\":1,\"90\":3,\"91\":3,\"92\":3,\"93\":1,\"98\":1,\"99\":2,\"100\":3,\"104\":2,\"106\":1,\"107\":1,\"110\":2,\"111\":2,\"121\":1,\"143\":3,\"151\":1,\"152\":1,\"154\":1,\"155\":1}}],[\"==b\",{\"1\":{\"31\":1}}],[\"=max\",{\"1\":{\"31\":2}}],[\"=\",{\"1\":{\"24\":9,\"25\":9,\"26\":28,\"27\":13,\"29\":17,\"30\":26,\"31\":5,\"32\":12,\"33\":16,\"34\":13,\"35\":18,\"36\":16,\"37\":29,\"39\":15,\"40\":10,\"42\":6,\"46\":5,\"47\":12,\"49\":1,\"50\":5,\"51\":5,\"52\":4,\"53\":5,\"54\":4,\"56\":12,\"57\":20,\"58\":8,\"59\":8,\"61\":2,\"62\":1,\"63\":1,\"64\":2,\"67\":31,\"68\":10,\"69\":3,\"70\":5,\"71\":8,\"75\":14,\"77\":5,\"78\":7,\"79\":10,\"82\":12,\"83\":14,\"84\":8,\"85\":15,\"86\":11,\"88\":8,\"90\":17,\"91\":19,\"92\":8,\"93\":8,\"98\":1,\"99\":3,\"100\":8,\"102\":5,\"103\":10,\"104\":6,\"106\":2,\"107\":11,\"110\":5,\"111\":11,\"112\":5,\"114\":9,\"115\":10,\"116\":16,\"118\":4,\"119\":8,\"120\":10,\"121\":17,\"122\":1,\"123\":12,\"125\":2,\"128\":1,\"129\":2,\"130\":1,\"135\":10,\"136\":10,\"138\":2,\"139\":3,\"141\":3,\"142\":4,\"143\":12,\"144\":9,\"146\":9,\"147\":6,\"148\":8,\"149\":10,\"151\":8,\"152\":4,\"153\":4,\"154\":1,\"155\":4,\"160\":6,\"161\":7,\"162\":4,\"163\":13,\"164\":9,\"178\":4,\"196\":1,\"198\":5,\"199\":8}}],[\"<version>8\",{\"1\":{\"195\":1}}],[\"<vector>\",{\"1\":{\"26\":1,\"30\":1,\"39\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"107\":1,\"164\":1}}],[\"<groupid>io\",{\"1\":{\"195\":1}}],[\"<dependency>\",{\"1\":{\"195\":1}}],[\"<description>minio文件存储服务<\",{\"1\":{\"186\":1}}],[\"<zipdateformat>yyyymmdd<\",{\"1\":{\"186\":1}}],[\"<zipolderthannumdays>5<zipolderthannumdays>\",{\"1\":{\"186\":1}}],[\"<pattern>yyyymmdd<\",{\"1\":{\"186\":1}}],[\"<pii>\",{\"1\":{\"164\":1}}],[\"<sizethreshold>10240<\",{\"1\":{\"186\":1}}],[\"<service>\",{\"1\":{\"186\":1}}],[\"<log\",{\"1\":{\"186\":1}}],[\"<logpath>\",{\"1\":{\"186\":1}}],[\"<artifactid>minio<\",{\"1\":{\"195\":1}}],[\"<arguments>server\",{\"1\":{\"186\":1}}],[\"<autorollattime>00\",{\"1\":{\"186\":1}}],[\"<algortihm>\",{\"1\":{\"82\":1}}],[\"<algorithm>\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"39\":1,\"53\":1,\"59\":1,\"107\":1,\"115\":1,\"125\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"<executable>\",{\"1\":{\"186\":1}}],[\"<name>minio\",{\"1\":{\"186\":1}}],[\"<id>minio\",{\"1\":{\"186\":1}}],[\"<iostream>\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"39\":1,\"53\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"82\":1,\"107\":1,\"115\":1,\"125\":1,\"143\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"<queue>\",{\"1\":{\"162\":1}}],[\"<unordered\",{\"1\":{\"107\":1}}],[\"<bit\",{\"1\":{\"42\":1}}],[\"<bits\",{\"1\":{\"37\":1,\"90\":1,\"91\":1}}],[\"<\",{\"1\":{\"26\":2,\"27\":5,\"30\":8,\"33\":2,\"35\":1,\"37\":1,\"39\":5,\"40\":5,\"42\":1,\"46\":4,\"47\":1,\"50\":1,\"51\":1,\"53\":2,\"56\":4,\"57\":5,\"58\":2,\"69\":2,\"70\":1,\"71\":1,\"75\":2,\"82\":1,\"84\":2,\"90\":3,\"91\":4,\"98\":1,\"103\":5,\"115\":1,\"116\":7,\"118\":1,\"119\":1,\"120\":3,\"121\":4,\"123\":3,\"139\":1,\"142\":1,\"146\":1,\"149\":3,\"155\":3,\"160\":2,\"161\":2,\"162\":4,\"163\":6,\"164\":2,\"178\":2,\"186\":3,\"195\":1}}],[\"<cstring>\",{\"1\":{\"26\":2,\"27\":2,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"39\":1,\"82\":1}}],[\"<cstdio>\",{\"1\":{\"24\":1,\"25\":1,\"26\":1,\"30\":2,\"164\":1}}],[\"<<\",{\"1\":{\"24\":4,\"25\":4,\"26\":8,\"27\":4,\"29\":4,\"30\":6,\"31\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":4,\"39\":7,\"40\":4,\"53\":2,\"59\":4,\"66\":1,\"67\":2,\"68\":3,\"82\":2,\"99\":9,\"107\":2,\"120\":2,\"123\":3,\"154\":1,\"160\":2,\"161\":2,\"162\":2,\"163\":2,\"164\":2}}],[\"<=\",{\"1\":{\"24\":5,\"25\":5,\"26\":11,\"27\":3,\"29\":7,\"30\":4,\"31\":2,\"32\":5,\"33\":5,\"34\":4,\"35\":6,\"36\":5,\"37\":13,\"39\":1,\"42\":2,\"47\":5,\"51\":2,\"52\":1,\"75\":2,\"79\":2,\"82\":2,\"84\":1,\"86\":1,\"88\":5,\"90\":3,\"91\":1,\"92\":1,\"93\":1,\"98\":1,\"99\":1,\"100\":3,\"102\":2,\"104\":2,\"106\":1,\"107\":1,\"110\":1,\"111\":2,\"116\":1,\"118\":1,\"120\":3,\"121\":2,\"139\":1,\"141\":1,\"142\":2,\"143\":2,\"146\":1,\"147\":1,\"148\":1,\"149\":2,\"153\":1,\"160\":2,\"161\":3,\"163\":1,\"178\":1}}],[\"myfile2\",{\"1\":{\"198\":2}}],[\"myfile目录是否存在\",{\"1\":{\"198\":1}}],[\"myfile\",{\"1\":{\"198\":1,\"199\":7}}],[\"mnt\",{\"1\":{\"183\":3,\"184\":1}}],[\"mn​\",{\"1\":{\"115\":1}}],[\"m匹配串长度\",{\"1\":{\"143\":1}}],[\"m个1\",{\"1\":{\"123\":1}}],[\"m==0\",{\"1\":{\"119\":1}}],[\"m2\",{\"1\":{\"115\":4}}],[\"m2​\",{\"1\":{\"115\":1}}],[\"m1\",{\"1\":{\"115\":7}}],[\"m1​\",{\"1\":{\"115\":1}}],[\"m是边数\",{\"1\":{\"91\":1}}],[\"mlogm\",{\"1\":{\"91\":1}}],[\"mlogn\",{\"1\":{\"81\":1,\"83\":1}}],[\"m表示边数\",{\"1\":{\"84\":1,\"90\":1,\"92\":1}}],[\"m代表边数\",{\"1\":{\"75\":1}}],[\"multimap\",{\"1\":{\"154\":3}}],[\"multiset\",{\"1\":{\"154\":3}}],[\"mul\",{\"1\":{\"58\":2,\"121\":2}}],[\"method\",{\"1\":{\"199\":2}}],[\"mex\",{\"1\":{\"128\":1,\"129\":1}}],[\"mex运算\",{\"0\":{\"128\":1}}],[\"merge\",{\"1\":{\"47\":3,\"71\":1,\"164\":2}}],[\"memset\",{\"1\":{\"39\":1,\"40\":1,\"75\":1,\"82\":2,\"83\":1,\"84\":1,\"85\":1,\"90\":2,\"92\":1,\"93\":1}}],[\"mode=\",{\"1\":{\"186\":1}}],[\"modm\",{\"1\":{\"119\":1}}],[\"modp\",{\"1\":{\"119\":1,\"120\":1}}],[\"modai​\",{\"1\":{\"115\":1}}],[\"mod\",{\"1\":{\"36\":4,\"107\":3,\"112\":1,\"115\":2,\"118\":1,\"119\":5,\"120\":1,\"153\":1}}],[\"mirrors\",{\"1\":{\"182\":1}}],[\"mi​\",{\"1\":{\"115\":1}}],[\"minutes\",{\"1\":{\"199\":1}}],[\"minioinfo\",{\"1\":{\"196\":6}}],[\"minio密码\",{\"1\":{\"196\":1}}],[\"minio用户名\",{\"1\":{\"196\":1}}],[\"minioclient\",{\"0\":{\"197\":1},\"1\":{\"196\":8,\"198\":6,\"199\":9}}],[\"minio<\",{\"1\":{\"195\":1}}],[\"minio官网\",{\"1\":{\"189\":1}}],[\"minioadmin\",{\"1\":{\"183\":1,\"185\":1,\"196\":2}}],[\"minio\",{\"0\":{\"182\":1,\"189\":1,\"194\":1},\"1\":{\"182\":3,\"183\":24,\"184\":8,\"185\":10,\"186\":8,\"189\":2,\"190\":4,\"191\":22,\"196\":10,\"199\":3},\"2\":{\"188\":1,\"193\":1,\"201\":1}}],[\"min\",{\"0\":{\"208\":1},\"1\":{\"33\":3,\"34\":6,\"35\":2,\"40\":2,\"82\":4,\"84\":1,\"88\":1,\"90\":2,\"128\":1,\"161\":1,\"185\":1,\"189\":1}}],[\"mid\",{\"1\":{\"30\":4,\"47\":7,\"50\":9,\"51\":13,\"52\":5,\"54\":4,\"70\":4}}],[\"middleware\",{\"0\":{\"209\":1},\"1\":{\"13\":1}}],[\"m​\",{\"1\":{\"33\":1}}],[\"mx\",{\"1\":{\"32\":4}}],[\"makebucketargs\",{\"1\":{\"198\":1}}],[\"makebucket\",{\"1\":{\"198\":2}}],[\"map\",{\"1\":{\"154\":3}}],[\"map>\",{\"1\":{\"107\":1}}],[\"map<int\",{\"1\":{\"100\":2,\"107\":1}}],[\"match\",{\"1\":{\"93\":4}}],[\"maxslidingwindow\",{\"1\":{\"178\":1}}],[\"max\",{\"1\":{\"24\":2,\"25\":2,\"26\":4,\"27\":2,\"29\":3,\"30\":4,\"31\":2,\"32\":3,\"42\":2,\"69\":1,\"71\":1,\"103\":1,\"108\":1,\"155\":1,\"163\":1,\"164\":1}}],[\"main\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"42\":1,\"53\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"75\":1,\"82\":1,\"90\":1,\"107\":1,\"115\":1,\"120\":1,\"123\":1,\"125\":1,\"143\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"m\",{\"1\":{\"24\":7,\"25\":7,\"26\":17,\"27\":9,\"31\":5,\"33\":8,\"34\":5,\"39\":9,\"40\":2,\"75\":1,\"76\":2,\"79\":1,\"81\":4,\"82\":5,\"83\":1,\"84\":4,\"85\":6,\"86\":1,\"90\":6,\"91\":5,\"92\":5,\"93\":3,\"119\":8,\"120\":4,\"123\":6,\"143\":8,\"155\":2}}],[\"件物品\",{\"1\":{\"24\":1,\"25\":1,\"26\":1}}],[\"nas\",{\"1\":{\"191\":1}}],[\"name\",{\"1\":{\"198\":1}}],[\"name>\",{\"1\":{\"186\":1}}],[\"namespace\",{\"1\":{\"24\":1,\"25\":1,\"26\":3,\"27\":2,\"29\":1,\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"42\":1,\"53\":1,\"56\":1,\"57\":1,\"58\":1,\"59\":1,\"68\":2,\"82\":1,\"90\":1,\"91\":1,\"107\":1,\"115\":1,\"123\":1,\"125\":1,\"143\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"n个闭区间\",{\"1\":{\"160\":1,\"162\":1}}],[\"n个链表\",{\"1\":{\"135\":1}}],[\"num\",{\"1\":{\"164\":5}}],[\"nums\",{\"1\":{\"37\":5,\"164\":7,\"177\":1,\"178\":4}}],[\"null\",{\"1\":{\"152\":1}}],[\"n为模式串长度\",{\"1\":{\"143\":1}}],[\"nohup\",{\"1\":{\"183\":1}}],[\"nohub\",{\"1\":{\"183\":1}}],[\"none\",{\"1\":{\"154\":1}}],[\"not\",{\"1\":{\"138\":1,\"141\":1,\"202\":1}}],[\"no\",{\"1\":{\"125\":1}}],[\"node\",{\"1\":{\"75\":4,\"155\":3,\"160\":2,\"161\":2}}],[\"nim博弈属于公平组合游戏\",{\"1\":{\"126\":1}}],[\"nim博弈先手必胜\",{\"1\":{\"125\":1}}],[\"nim博弈不存在平局\",{\"1\":{\"125\":1}}],[\"nim游戏\",{\"0\":{\"125\":1}}],[\"n+1\",{\"1\":{\"115\":1}}],[\"n+m\",{\"1\":{\"79\":1}}],[\"n=p1a1​​p2a2​​\",{\"1\":{\"110\":1}}],[\"n1表示第一个集合中的点数\",{\"1\":{\"93\":1}}],[\"n1\",{\"1\":{\"93\":2}}],[\"n是点数\",{\"1\":{\"91\":1}}],[\"n次迭代\",{\"1\":{\"90\":1}}],[\"n^3\",{\"1\":{\"88\":1,\"116\":1}}],[\"n表示点数\",{\"1\":{\"84\":1,\"90\":1,\"92\":1}}],[\"nm\",{\"1\":{\"81\":2,\"84\":1,\"85\":1,\"86\":1,\"93\":1}}],[\"n2表示第二个集合中的点数\",{\"1\":{\"93\":1}}],[\"n2\",{\"1\":{\"81\":1,\"82\":1,\"90\":1,\"93\":1}}],[\"new\",{\"1\":{\"199\":4}}],[\"next\",{\"1\":{\"143\":3}}],[\"ne\",{\"1\":{\"75\":2,\"77\":1,\"78\":1,\"79\":1,\"83\":3,\"85\":3,\"86\":2,\"92\":2,\"93\":2,\"135\":10,\"143\":5,\"151\":3}}],[\"n代表点数\",{\"1\":{\"75\":1}}],[\"nlogn\",{\"1\":{\"53\":1}}],[\"n−1\",{\"1\":{\"40\":3}}],[\"n×m\",{\"1\":{\"39\":1}}],[\"n<=0\",{\"1\":{\"37\":1}}],[\"n共有多少种不同的划分方法\",{\"1\":{\"36\":1}}],[\"n\",{\"1\":{\"24\":11,\"25\":11,\"26\":26,\"27\":19,\"29\":14,\"30\":21,\"31\":10,\"32\":16,\"33\":13,\"34\":10,\"35\":13,\"36\":16,\"37\":6,\"39\":11,\"40\":13,\"42\":6,\"53\":9,\"56\":1,\"68\":14,\"69\":1,\"70\":1,\"75\":13,\"76\":2,\"79\":3,\"81\":2,\"82\":13,\"83\":10,\"84\":13,\"85\":7,\"86\":11,\"88\":5,\"89\":2,\"90\":14,\"91\":14,\"92\":6,\"93\":4,\"98\":1,\"99\":10,\"100\":15,\"102\":16,\"103\":2,\"104\":5,\"107\":5,\"110\":3,\"111\":8,\"115\":8,\"116\":21,\"118\":1,\"119\":3,\"120\":8,\"121\":14,\"122\":3,\"123\":11,\"125\":3,\"135\":2,\"136\":3,\"138\":1,\"139\":1,\"141\":1,\"142\":1,\"143\":5,\"144\":2,\"146\":4,\"147\":3,\"148\":3,\"149\":6,\"151\":9,\"152\":5,\"153\":3,\"155\":8,\"160\":7,\"161\":7,\"162\":7,\"163\":9,\"164\":4,\"178\":2,\"191\":2}}],[\"有十分完善的官方文档\",{\"1\":{\"191\":1}}],[\"有一个大小为\",{\"1\":{\"177\":1}}],[\"有一个1\",{\"1\":{\"123\":1}}],[\"有两个指针\",{\"1\":{\"136\":1}}],[\"有唯一解\",{\"1\":{\"116\":1}}],[\"有无穷多组解\",{\"1\":{\"116\":1}}],[\"有向图游戏的某个局面必败\",{\"1\":{\"130\":1}}],[\"有向图游戏的某个局面必胜\",{\"1\":{\"130\":1}}],[\"有向图游戏的和的sg函数值等于它包含的各个子游戏sg函数值的异或和\",{\"1\":{\"130\":1}}],[\"有向图游戏的和\",{\"0\":{\"130\":1}}],[\"有向图游戏\",{\"0\":{\"127\":1}}],[\"有向图\",{\"1\":{\"82\":1}}],[\"有向无环图被称为拓扑图\",{\"1\":{\"79\":1}}],[\"有的补0\",{\"1\":{\"66\":1}}],[\"有的补符号位\",{\"1\":{\"66\":1}}],[\"有符号数\",{\"1\":{\"66\":1}}],[\"有限个\",{\"1\":{\"26\":1}}],[\"有\",{\"1\":{\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"120\":1}}],[\"背包容量为\",{\"1\":{\"24\":1,\"25\":1,\"26\":1}}],[\"背包\",{\"0\":{\"24\":1}}],[\"背包问题常用枚举方法\",{\"1\":{\"23\":1}}],[\"背包问题\",{\"0\":{\"23\":1}}],[\"第i堆物品有ai个\",{\"1\":{\"125\":1}}],[\"第i行j列格子左上部分所有元素的和\",{\"1\":{\"62\":1}}],[\"第\",{\"1\":{\"115\":2}}],[\"第三步\",{\"1\":{\"46\":1}}],[\"第三行包含\",{\"1\":{\"32\":1}}],[\"第三维枚举决策\",{\"1\":{\"23\":1}}],[\"第二个元素\",{\"1\":{\"154\":1}}],[\"第二个行动的称为后手\",{\"1\":{\"125\":1}}],[\"第二行输出所求余数\",{\"1\":{\"59\":1}}],[\"第二行包含\",{\"1\":{\"32\":1,\"68\":1}}],[\"第二步\",{\"1\":{\"46\":1}}],[\"第二维枚举起点\",{\"1\":{\"35\":1}}],[\"第二维枚举体积\",{\"1\":{\"23\":1}}],[\"第二种写法\",{\"1\":{\"26\":1,\"27\":1}}],[\"第一个元素\",{\"1\":{\"154\":1}}],[\"第一行输出所求的商\",{\"1\":{\"59\":1}}],[\"第一行包含整数\",{\"1\":{\"68\":1}}],[\"第一行包含两个整数\",{\"1\":{\"33\":1}}],[\"第一行包含一个整数\",{\"1\":{\"32\":1}}],[\"第一次出现的位置\",{\"1\":{\"53\":1}}],[\"第一次循环不能有0\",{\"1\":{\"37\":1}}],[\"第一步\",{\"1\":{\"46\":1}}],[\"第一维通常是枚举区间长度\",{\"1\":{\"35\":1}}],[\"第一维枚举物品\",{\"1\":{\"23\":1}}],[\"第一种写法\",{\"1\":{\"26\":1,\"27\":1}}],[\"17\",{\"1\":{\"198\":1}}],[\"171gb\",{\"1\":{\"191\":1}}],[\"183gb\",{\"1\":{\"191\":1}}],[\"1是右端点\",{\"1\":{\"136\":1}}],[\"1∼n\",{\"1\":{\"110\":1}}],[\"1~n\",{\"1\":{\"102\":1}}],[\"1表示不存在\",{\"1\":{\"135\":1}}],[\"1表示黑色\",{\"1\":{\"92\":1}}],[\"1表示未染色\",{\"1\":{\"92\":1}}],[\"1ll\",{\"1\":{\"75\":1}}],[\"11\",{\"1\":{\"116\":1}}],[\"1111\",{\"1\":{\"67\":7,\"123\":1}}],[\"1110\",{\"1\":{\"67\":8}}],[\"110\",{\"1\":{\"26\":1,\"27\":2,\"107\":1}}],[\"1100\",{\"1\":{\"25\":1}}],[\"1变0\",{\"1\":{\"66\":1}}],[\"1<<n\",{\"1\":{\"40\":1}}],[\"1<<j\",{\"1\":{\"40\":2}}],[\"1的最短距离\",{\"1\":{\"40\":1}}],[\"123\",{\"1\":{\"199\":1}}],[\"123456\",{\"1\":{\"56\":1,\"57\":1}}],[\"12\",{\"1\":{\"39\":1,\"191\":1}}],[\"12010\",{\"1\":{\"26\":1}}],[\"1×2\",{\"1\":{\"39\":1}}],[\"1个0\",{\"1\":{\"37\":1}}],[\"1个9\",{\"1\":{\"37\":1}}],[\"1e5\",{\"1\":{\"90\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1}}],[\"1e6\",{\"1\":{\"56\":1}}],[\"1e\",{\"1\":{\"54\":1,\"116\":1}}],[\"1e3\",{\"1\":{\"36\":1}}],[\"1e9+7\",{\"1\":{\"118\":1}}],[\"1e9\",{\"1\":{\"29\":1,\"35\":1,\"36\":1,\"107\":1}}],[\"15\",{\"1\":{\"33\":1}}],[\"1≤n≤3000\",{\"1\":{\"32\":1}}],[\"100\",{\"0\":{\"206\":1},\"1\":{\"190\":1}}],[\"10010\",{\"1\":{\"143\":1}}],[\"1000\",{\"1\":{\"67\":1,\"68\":1}}],[\"100010\",{\"1\":{\"30\":2,\"68\":1,\"143\":1}}],[\"10的二进制表示为4位数\",{\"1\":{\"68\":1}}],[\"1011\",{\"1\":{\"67\":1}}],[\"101000\",{\"1\":{\"68\":1}}],[\"1010\",{\"1\":{\"24\":1,\"30\":1,\"31\":1,\"33\":1,\"34\":1,\"67\":8,\"68\":2}}],[\"10\",{\"0\":{\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"155\":1},\"1\":{\"33\":2,\"37\":12,\"53\":1,\"56\":3,\"57\":3,\"58\":2,\"59\":1,\"68\":3,\"75\":1,\"90\":1,\"91\":1,\"121\":4,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"198\":1}}],[\"1\",{\"0\":{\"23\":1,\"24\":2,\"25\":1,\"26\":1,\"27\":1,\"29\":1,\"39\":1,\"42\":1,\"46\":1,\"49\":1,\"56\":1,\"61\":1,\"66\":1,\"75\":1,\"81\":1,\"82\":2,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"88\":1,\"90\":1,\"97\":1,\"98\":2,\"99\":1,\"101\":1,\"102\":2,\"103\":1,\"104\":1,\"106\":1,\"110\":1,\"118\":1,\"125\":1,\"134\":1,\"135\":2,\"136\":1,\"138\":1,\"139\":1,\"141\":1,\"146\":1,\"151\":1,\"159\":1,\"160\":2,\"161\":1,\"162\":1,\"163\":1,\"164\":1},\"1\":{\"24\":5,\"25\":4,\"26\":9,\"27\":2,\"29\":20,\"30\":14,\"31\":13,\"32\":11,\"33\":15,\"34\":22,\"35\":17,\"36\":15,\"37\":20,\"39\":11,\"40\":8,\"42\":14,\"46\":5,\"47\":3,\"50\":6,\"51\":7,\"52\":3,\"56\":4,\"57\":7,\"58\":3,\"59\":4,\"61\":2,\"62\":4,\"63\":1,\"64\":4,\"67\":38,\"68\":9,\"69\":2,\"70\":4,\"75\":9,\"77\":1,\"78\":3,\"79\":5,\"81\":1,\"82\":9,\"83\":5,\"84\":6,\"85\":7,\"86\":3,\"88\":6,\"89\":1,\"90\":6,\"91\":5,\"92\":7,\"93\":2,\"99\":2,\"100\":4,\"102\":6,\"103\":1,\"104\":1,\"106\":1,\"107\":7,\"110\":3,\"111\":11,\"112\":9,\"114\":2,\"115\":7,\"116\":5,\"118\":4,\"119\":7,\"120\":8,\"121\":2,\"122\":1,\"123\":9,\"135\":2,\"136\":2,\"139\":1,\"141\":1,\"142\":1,\"143\":5,\"146\":1,\"147\":2,\"148\":1,\"149\":11,\"151\":1,\"153\":6,\"154\":2,\"155\":14,\"160\":4,\"161\":5,\"163\":2,\"183\":2,\"199\":1}}],[\"资料等等\",{\"1\":{\"18\":1}}],[\"资源共享\",{\"1\":{\"13\":1}}],[\"程序人生\",{\"0\":{\"18\":1}}],[\"帮助学习\",{\"1\":{\"17\":1}}],[\"帮助用户灵活\",{\"1\":{\"13\":1}}],[\"常见的有阿里云对象存储服务\",{\"1\":{\"190\":1}}],[\"常见模型\",{\"1\":{\"139\":1,\"142\":1}}],[\"常见问题分类\",{\"1\":{\"69\":1}}],[\"常见中间件主要分为\",{\"1\":{\"13\":1}}],[\"常用语言的\",{\"1\":{\"191\":1}}],[\"常用库函数\",{\"0\":{\"155\":1}}],[\"常用来对一个数据的某些位设置为1\",{\"1\":{\"67\":1}}],[\"常用模版\",{\"1\":{\"35\":1}}],[\"常用框架\",{\"0\":{\"16\":1}}],[\"消息中间件\",{\"1\":{\"13\":1}}],[\"为x的后继节点y1\",{\"1\":{\"129\":1}}],[\"为求出不属于集合s的最小非负整数的运算\",{\"1\":{\"128\":1}}],[\"为质数时\",{\"1\":{\"119\":1}}],[\"为避免这种情况\",{\"1\":{\"67\":1}}],[\"为\",{\"1\":{\"67\":2,\"119\":2,\"123\":1}}],[\"为右下角的子矩阵中的所有元素加上c\",{\"1\":{\"64\":1}}],[\"为右下角的子矩阵的和为\",{\"1\":{\"62\":1}}],[\"为左上角\",{\"1\":{\"62\":1,\"64\":1}}],[\"为高兴值\",{\"1\":{\"42\":1}}],[\"为父亲\",{\"1\":{\"42\":1}}],[\"为第\",{\"1\":{\"42\":2}}],[\"为应用软件间共享资源提供了可复用的\",{\"1\":{\"13\":1}}],[\"为上层应用软件提供开发\",{\"1\":{\"13\":1}}],[\"协议的\",{\"1\":{\"190\":1}}],[\"协议\",{\"1\":{\"13\":1}}],[\"网络和数据库之上\",{\"1\":{\"13\":1}}],[\"英语\",{\"1\":{\"13\":1}}],[\"l代表区间左端点\",{\"1\":{\"164\":1}}],[\"lucas\",{\"0\":{\"120\":1},\"1\":{\"120\":4}}],[\"lcm\",{\"1\":{\"108\":1}}],[\"ln\",{\"1\":{\"102\":4}}],[\"lld\",{\"1\":{\"75\":1,\"115\":6}}],[\"ll\",{\"1\":{\"39\":2,\"53\":3,\"90\":1,\"103\":7,\"107\":4,\"115\":15,\"119\":4,\"120\":10,\"123\":2}}],[\"localhost\",{\"1\":{\"185\":1,\"196\":1}}],[\"log>\",{\"1\":{\"186\":1}}],[\"logpath>\",{\"1\":{\"186\":1}}],[\"logs<\",{\"1\":{\"186\":1}}],[\"logn\",{\"1\":{\"154\":3}}],[\"logk\",{\"1\":{\"112\":1}}],[\"log\",{\"1\":{\"91\":1,\"99\":1,\"108\":1,\"183\":4}}],[\"lowbit\",{\"1\":{\"68\":5}}],[\"lower\",{\"1\":{\"30\":1,\"53\":3,\"154\":4,\"155\":4}}],[\"long存储\",{\"1\":{\"153\":1}}],[\"long\",{\"1\":{\"39\":2,\"53\":2,\"90\":2,\"103\":2,\"107\":2,\"115\":2,\"123\":2,\"153\":3}}],[\"listobjectsargs\",{\"1\":{\"199\":1}}],[\"listobjects\",{\"1\":{\"199\":4}}],[\"list<bucket>\",{\"1\":{\"198\":1}}],[\"listbuckets\",{\"1\":{\"198\":2}}],[\"license\",{\"1\":{\"189\":1}}],[\"limit\",{\"1\":{\"33\":3}}],[\"linux\",{\"0\":{\"183\":1},\"1\":{\"8\":1,\"183\":1}}],[\"lb\",{\"1\":{\"33\":4}}],[\"last\",{\"1\":{\"37\":4}}],[\"la\",{\"1\":{\"33\":4}}],[\"l\",{\"1\":{\"30\":4,\"46\":8,\"47\":7,\"49\":2,\"50\":8,\"51\":8,\"52\":6,\"54\":5,\"61\":2,\"63\":2,\"70\":4,\"71\":5,\"136\":8,\"153\":4,\"160\":3,\"161\":5,\"162\":5,\"163\":10,\"164\":9}}],[\"length\",{\"1\":{\"154\":1,\"199\":1}}],[\"len++\",{\"1\":{\"35\":2}}],[\"len\",{\"1\":{\"30\":5,\"35\":12}}],[\"leetcode\",{\"0\":{\"6\":1,\"207\":1}}],[\"架构以及系统架构方面的笔记知识点\",{\"1\":{\"7\":1}}],[\"架构设计\",{\"0\":{\"7\":1}}],[\"剑指offer\",{\"0\":{\"19\":1}}],[\"剑指\",{\"0\":{\"5\":1}}],[\"笔记\",{\"0\":{\"4\":1}}],[\"笔试题和面试题等\",{\"1\":{\"1\":1}}],[\"贪心\",{\"0\":{\"158\":1},\"1\":{\"3\":1}}],[\"数之间用空格隔开\",{\"1\":{\"115\":1}}],[\"数组\",{\"1\":{\"143\":2,\"155\":2}}],[\"数组时\",{\"1\":{\"143\":1}}],[\"数组和匹配的操作类似\",{\"1\":{\"143\":1}}],[\"数组模拟链表\",{\"0\":{\"134\":1}}],[\"数组进行备份\",{\"1\":{\"84\":1}}],[\"数组的备份\",{\"1\":{\"84\":1}}],[\"数组是上一次迭代后\",{\"1\":{\"84\":1}}],[\"数组b也是从低位\",{\"1\":{\"56\":1,\"57\":1}}],[\"数组a\",{\"1\":{\"56\":1,\"57\":1}}],[\"数对\",{\"1\":{\"53\":1}}],[\"数位统计类dp\",{\"0\":{\"37\":1}}],[\"数列\",{\"1\":{\"32\":1}}],[\"数字三角形\",{\"0\":{\"29\":1}}],[\"数据存储高容错\",{\"1\":{\"191\":1}}],[\"数据范围较大时\",{\"1\":{\"26\":1}}],[\"数据范围\",{\"1\":{\"26\":1,\"32\":1}}],[\"数据库中间件\",{\"1\":{\"13\":1}}],[\"数据库之间\",{\"1\":{\"13\":1}}],[\"数据库\",{\"1\":{\"8\":1}}],[\"数据结构\",{\"0\":{\"133\":1},\"1\":{\"3\":1}}],[\"数学知识\",{\"0\":{\"96\":1},\"1\":{\"3\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
