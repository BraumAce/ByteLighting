const{entries:V}=Object,{fromEntries:et}=Object,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":1547,\"nextId\":1547,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"3\",\"3\":\"3#模板\",\"4\":\"3#笔记\",\"5\":\"3#剑指-offer\",\"6\":\"3#leetcode\",\"7\":\"4\",\"8\":\"4#目录\",\"9\":\"4#编程语言\",\"10\":\"4#计算机网络\",\"11\":\"4#数据库\",\"12\":\"4#操作系统\",\"13\":\"4#设计模式\",\"14\":\"4#中间件\",\"15\":\"4#git\",\"16\":\"4#docker\",\"17\":\"5\",\"18\":\"6\",\"19\":\"7\",\"20\":\"8\",\"21\":\"8#_01-背景\",\"22\":\"8#_02-基础功能模块\",\"23\":\"8#_03-架构设计\",\"24\":\"8#_3-1-架构设计-概览\",\"25\":\"8#_3-2-架构设计-reply-interface\",\"26\":\"8#_3-3-架构设计-reply-admin\",\"27\":\"8#_3-4-架构设计-reply-service\",\"28\":\"8#_3-5-架构设计-reply-job\",\"29\":\"8#_04-存储设计\",\"30\":\"8#_4-1-数据库设计\",\"31\":\"8#_4-2-缓存设计\",\"32\":\"8#_05-可用性设计\",\"33\":\"8#_5-1-写热点与读热点\",\"34\":\"8#_5-2-冗余与降级\",\"35\":\"8#_06-安全性设计\",\"36\":\"8#_6-1-数据安全\",\"37\":\"8#_6-2-舆论安全\",\"38\":\"8#_07-热评设计\",\"39\":\"8#_7-1-什么是热评\",\"40\":\"8#_7-2-挑战与应对\",\"41\":\"8#_7-3-愿景与规划\",\"42\":\"8@0\",\"43\":\"8@1\",\"44\":\"9\",\"45\":\"9#功能模块\",\"46\":\"9#架构设计\",\"47\":\"9#comment-service\",\"48\":\"9#读的核心逻辑\",\"49\":\"9#写的核心逻辑\",\"50\":\"9#comment-admin\",\"51\":\"9#bff-comment\",\"52\":\"9@0\",\"53\":\"9@1\",\"54\":\"10\",\"55\":\"10#存储设计\",\"56\":\"10#数据表设计\",\"57\":\"10#总结\",\"58\":\"10#缓存设计\",\"59\":\"10#可用性设计\",\"60\":\"10#缓存穿透\",\"61\":\"10#热点\",\"62\":\"10@0\",\"63\":\"10@1\",\"64\":\"11\",\"65\":\"11#第一题\",\"66\":\"11#第二题\",\"67\":\"11@0\",\"68\":\"11@1\",\"69\":\"12\",\"70\":\"12#第一题\",\"71\":\"12#第二题\",\"72\":\"12#第三题\",\"73\":\"12@0\",\"74\":\"12@1\",\"75\":\"13\",\"76\":\"13#一百倍\",\"77\":\"13#网络板\",\"78\":\"13#三角形\",\"79\":\"13@0\",\"80\":\"13@1\",\"81\":\"14\",\"82\":\"14#简单的字符串压缩\",\"83\":\"14#简单的数学表达式计算\",\"84\":\"14@0\",\"85\":\"14@1\",\"86\":\"15\",\"87\":\"15#小红的方案数\",\"88\":\"15#小红的密码\",\"89\":\"15@0\",\"90\":\"15@1\",\"91\":\"16\",\"92\":\"16#合并数组\",\"93\":\"16#有效字符串\",\"94\":\"16@0\",\"95\":\"16@1\",\"96\":\"17\",\"97\":\"17#第一题\",\"98\":\"17#第二题\",\"99\":\"17#第三题\",\"100\":\"17@0\",\"101\":\"17@1\",\"102\":\"18\",\"103\":\"18#宝石项链\",\"104\":\"18#均衡\",\"105\":\"18@0\",\"106\":\"18@1\",\"107\":\"19\",\"108\":\"19#第一题\",\"109\":\"19#第二题\",\"110\":\"19#第三题\",\"111\":\"19@0\",\"112\":\"19@1\",\"113\":\"20\",\"114\":\"20#缺失的订单号\",\"115\":\"20#完全平方数\",\"116\":\"20@0\",\"117\":\"20@1\",\"118\":\"21\",\"119\":\"21#第一题\",\"120\":\"21#第二题\",\"121\":\"21#第三题\",\"122\":\"21#第四题\",\"123\":\"21@0\",\"124\":\"21@1\",\"125\":\"22\",\"126\":\"22#求和方式\",\"127\":\"22#实现简单的正则表达式匹配\",\"128\":\"22#野猪骑士\",\"129\":\"22#过生日\",\"130\":\"22@0\",\"131\":\"22@1\",\"132\":\"23\",\"133\":\"23#二叉树的层序遍历\",\"134\":\"23#链表排序\",\"135\":\"23#数字组合\",\"136\":\"23@0\",\"137\":\"23@1\",\"138\":\"24\",\"139\":\"24#第一题\",\"140\":\"24#第二题\",\"141\":\"24#第三题\",\"142\":\"24#第四题\",\"143\":\"24@0\",\"144\":\"24@1\",\"145\":\"25\",\"146\":\"25#最佳速通时间\",\"147\":\"25#对比之美\",\"148\":\"25@0\",\"149\":\"25@1\",\"150\":\"26\",\"151\":\"26#场景题\",\"152\":\"26#算法题\",\"153\":\"26@0\",\"154\":\"26@1\",\"155\":\"27\",\"156\":\"27#最大的乘积\",\"157\":\"27#前缀染色\",\"158\":\"27@0\",\"159\":\"27@1\",\"160\":\"28\",\"161\":\"28#小乐的数字\",\"162\":\"28#餐馆\",\"163\":\"28@0\",\"164\":\"28@1\",\"165\":\"29\",\"166\":\"29#放瓶子\",\"167\":\"29#最大乘积\",\"168\":\"29#牛牛商店\",\"169\":\"29@0\",\"170\":\"29@1\",\"171\":\"30\",\"172\":\"30#小美的姓名统计\",\"173\":\"30#小美种树\",\"174\":\"30#小美和小团的游戏\",\"175\":\"30@0\",\"176\":\"30@1\",\"177\":\"31\",\"178\":\"31#第一题\",\"179\":\"31#第二题\",\"180\":\"31#第三题\",\"181\":\"31#第四题\",\"182\":\"31#第五题\",\"183\":\"31@0\",\"184\":\"31@1\",\"185\":\"32\",\"186\":\"32#题意\",\"187\":\"32#思路一\",\"188\":\"32#思路二-优化\",\"189\":\"32@0\",\"190\":\"32@1\",\"191\":\"33\",\"192\":\"33#vc1-牛牛吃草\",\"193\":\"33#描述\",\"194\":\"33#题解\",\"195\":\"33#vc2-棋盘\",\"196\":\"33#描述-1\",\"197\":\"33#题解-1\",\"198\":\"33#vc28-染色\",\"199\":\"33#描述-2\",\"200\":\"33#题解-2\",\"201\":\"33#vc35-正则匹配\",\"202\":\"33#描述-3\",\"203\":\"33#题解-3\",\"204\":\"33#vc40-购物\",\"205\":\"33#描述-4\",\"206\":\"33#题解-4\",\"207\":\"33@0\",\"208\":\"33@1\",\"209\":\"34\",\"210\":\"34#_1-介绍\",\"211\":\"34#_2-搜索\",\"212\":\"34#_2-1-广度优先搜索\",\"213\":\"34#_2-2-dijkstra-算法\",\"214\":\"34#_2-3-最佳优先搜索\",\"215\":\"34#_3-a\",\"216\":\"34#_4-启发函数\",\"217\":\"34#_5-关于距离\",\"218\":\"34#_5-1-曼哈顿距离\",\"219\":\"34#_5-2-对角距离\",\"220\":\"34#_5-3-欧几里得距离\",\"221\":\"34#_6-补充\",\"222\":\"34#_7-例题\",\"223\":\"34#_7-1-第k短路\",\"224\":\"34#_7-2-八数码\",\"225\":\"34@0\",\"226\":\"34@1\",\"227\":\"35\",\"228\":\"35#岛屿数量\",\"229\":\"35#封闭岛屿数量\",\"230\":\"35#岛屿的最大面积\",\"231\":\"35#小结\",\"232\":\"35@0\",\"233\":\"35@1\",\"234\":\"36\",\"235\":\"36#能否逃出迷宫\",\"236\":\"36#逃出迷宫的最短路径\",\"237\":\"36#缺口迷宫\",\"238\":\"36#小结\",\"239\":\"36@0\",\"240\":\"36@1\",\"241\":\"37\",\"242\":\"37#_1-vector-维护一个动态数组\",\"243\":\"37#_2-字符串\",\"244\":\"37#_3-在一个数组中查找最长的相同连续子序列\",\"245\":\"37#_4-秦九韶算法\",\"246\":\"37#_5-开栈空间代码\",\"247\":\"37#_6-求-a-除以-b-的正余数\",\"248\":\"37#_7-裴蜀定理\",\"249\":\"37#_8-交互题\",\"250\":\"37#_9-mex函数\",\"251\":\"37#_10-string-与-int-之间的转化\",\"252\":\"37#_11-string-npos\",\"253\":\"37#_12-x-i-1\",\"254\":\"37#_13-assign\",\"255\":\"37#_14-lambda表达式\",\"256\":\"37#_15-max-element-与-min-element\",\"257\":\"37#_16-tuple\",\"258\":\"37@0\",\"259\":\"37@1\",\"260\":\"38\",\"261\":\"38#_1、1230-k倍区间\",\"262\":\"38#_2、3956-截断数组\",\"263\":\"38#_3、99-激光炸弹\",\"264\":\"38@0\",\"265\":\"38@1\",\"266\":\"39\",\"267\":\"39#简介\",\"268\":\"39#基本模板\",\"269\":\"39#_1-初始化\",\"270\":\"39#_2-查询-已路径压缩\",\"271\":\"39#_3-合并\",\"272\":\"39#典例分析\",\"273\":\"39#例一-亲戚关系\",\"274\":\"39#例二-洛谷-p3367-【模板】并查集\",\"275\":\"39@0\",\"276\":\"39@1\",\"277\":\"40\",\"278\":\"40#_1-844-走迷宫-bfs\",\"279\":\"40#_2-845-八数码-bfs\",\"280\":\"40#_3-1233-全球变暖\",\"281\":\"40#_4-842-排列数字-dfs\",\"282\":\"40#_4\",\"283\":\"40#_5\",\"284\":\"40@0\",\"285\":\"40@1\",\"286\":\"41\",\"287\":\"41#_1-92-递归实现指数型枚举\",\"288\":\"41#_2-94-递归实现排列型枚举\",\"289\":\"41#_3-93-递归实现组合型枚举\",\"290\":\"41#_4-165-小猫爬山\",\"291\":\"41#_5-1209-带分数\",\"292\":\"41@0\",\"293\":\"41@1\",\"294\":\"42\",\"295\":\"42#_1-背包问题\",\"296\":\"42#_1-1-01-背包\",\"297\":\"42#_1-2-完全背包\",\"298\":\"42#_1-3-多重背包\",\"299\":\"42#_1-4-分组背包\",\"300\":\"42#_2-线性dp\",\"301\":\"42#_2-1-数字三角形\",\"302\":\"42#_2-2-最长上升子序列\",\"303\":\"42#_2-3-最长公共子序列-不连续\",\"304\":\"42#_2-4-最长公共上升子序列\",\"305\":\"42#_2-5-编辑距离\",\"306\":\"42#_2-6-最短编辑距离\",\"307\":\"42#_3-区间dp\",\"308\":\"42#_4-计数类dp\",\"309\":\"42#_5-数位统计类dp\",\"310\":\"42#_6-状态压缩类dp\",\"311\":\"42#_6-1-蒙德里安的梦想\",\"312\":\"42#_6-2-最短hamilton路径\",\"313\":\"42#_7-树形dp\",\"314\":\"42#_7-1-没有上司的舞会\",\"315\":\"42@0\",\"316\":\"43\",\"317\":\"43#_1-快速排序\",\"318\":\"43#_2-归并排序\",\"319\":\"43#_3-二分算法\",\"320\":\"43#_3-1-二分查找算法模板\",\"321\":\"43#版本1\",\"322\":\"43#版本2\",\"323\":\"43#_3-2-二分答案模板\",\"324\":\"43#_3-3-整数二分\",\"325\":\"43#_3-4-浮点数二分\",\"326\":\"43#_4-高精度算法\",\"327\":\"43#_4-1-高精度加法\",\"328\":\"43#_4-2-高精度减法\",\"329\":\"43#_4-3-高精度整数乘法\",\"330\":\"43#_4-4-高精度整数除法\",\"331\":\"43#_5-前缀和与差分\",\"332\":\"43#_5-1-一维前缀和\",\"333\":\"43#_5-2-二维前缀和\",\"334\":\"43#_5-3-一维差分\",\"335\":\"43#_5-4-二维差分\",\"336\":\"43#_6-位运算\",\"337\":\"43#_6-1-位运算符\",\"338\":\"43#_6-2-用途\",\"339\":\"43#_6-3-例题\",\"340\":\"43#_7-双指针算法\",\"341\":\"43#_8-离散化\",\"342\":\"43#_9-区间合并\",\"343\":\"43@0\",\"344\":\"44\",\"345\":\"44#_1-树与图的存储\",\"346\":\"44#_2-树与图的遍历\",\"347\":\"44#深度优先遍历\",\"348\":\"44#宽度优先遍历\",\"349\":\"44#_3-拓扑排序\",\"350\":\"44#_4-最短路问题\",\"351\":\"44#_4-1-单源最短路\",\"352\":\"44#_4-1-1-朴素版-dijkstra算法\",\"353\":\"44#_4-1-2-堆优化版的dijkstra算法\",\"354\":\"44#_4-1-3-bellman-ford算法-存在负权边\",\"355\":\"44#_4-1-4-spfa算法-存在负权边\",\"356\":\"44#_4-1-5-spfa算法判断图中是否存在负环\",\"357\":\"44#_4-2-多源汇最短路\",\"358\":\"44#_4-2-1-floyd算法\",\"359\":\"44#_5-最小生成树问题\",\"360\":\"44#_5-1-朴素prim算法\",\"361\":\"44#_5-2-kruskal-算法\",\"362\":\"44#_6-染色法判别二分图\",\"363\":\"44#_7-匈牙利算法\",\"364\":\"44@0\",\"365\":\"45\",\"366\":\"45#_1-质数\",\"367\":\"45#_1-1-试除法判定质数\",\"368\":\"45#_1-2-试除法分解质因数\",\"369\":\"45#汇总\",\"370\":\"45#_1-3-筛法求素数\",\"371\":\"45#_1-3-1-朴素筛法-埃氏筛\",\"372\":\"45#_1-3-2-区间筛法\",\"373\":\"45#_1-3-3-线性筛-欧拉筛\",\"374\":\"45#_2-约数\",\"375\":\"45#_2-1-试除法求所有约数\",\"376\":\"45#_2-2-约数个数和约数之和\",\"377\":\"45#_2-3-最大公约数与最小公倍数\",\"378\":\"45#_3-欧拉函数\",\"379\":\"45#_3-1-求欧拉函数\",\"380\":\"45#_3-2-筛法求欧拉函数\",\"381\":\"45#_4-快速幂\",\"382\":\"45#_5-扩展欧几里得算法\",\"383\":\"45#裴蜀定理\",\"384\":\"45#_6-中国剩余定理\",\"385\":\"45#_7-高斯消元\",\"386\":\"45#_8-求组合数\",\"387\":\"45#_8-1-递推法求组合数\",\"388\":\"45#_8-2-通过预处理逆元的方式求组和数\",\"389\":\"45#_8-3-卢卡斯-lucas-定理求组合数\",\"390\":\"45#_8-4-分解质因数法求组合数\",\"391\":\"45#_8-5-卡特兰数\",\"392\":\"45#_9-容斥原理\",\"393\":\"45#_10-博弈论\",\"394\":\"45#_10-1-nim游戏\",\"395\":\"45#_10-2-公平组合游戏icg\",\"396\":\"45#_10-3-有向图游戏\",\"397\":\"45#_10-4-mex运算\",\"398\":\"45#_10-5-sg游戏\",\"399\":\"45#_10-6-有向图游戏的和\",\"400\":\"45@0\",\"401\":\"46\",\"402\":\"46#_1-数组模拟链表\",\"403\":\"46#_1-1-单链表\",\"404\":\"46#_1-2-双链表\",\"405\":\"46#_2-栈\",\"406\":\"46#_2-1-普通栈\",\"407\":\"46#_2-1-单调栈\",\"408\":\"46#_3-队列\",\"409\":\"46#_3-1-普通队列\",\"410\":\"46#_3-2-单调队列\",\"411\":\"46#_4-kmp\",\"412\":\"46#_5-trie树\",\"413\":\"46#_6-并查集\",\"414\":\"46#_6-1-朴素并查集\",\"415\":\"46#_6-2-维护size的并查集\",\"416\":\"46#_6-3-维护到祖宗节点距离的并查集\",\"417\":\"46#_7-堆\",\"418\":\"46#_8-哈希表\",\"419\":\"46#_8-1-拉链法\",\"420\":\"46#_8-2-开放寻址法\",\"421\":\"46#_8-3-字符串哈希\",\"422\":\"46#_9-c-stl简介\",\"423\":\"46#_10-常用库函数\",\"424\":\"46@0\",\"425\":\"47\",\"426\":\"47#_1-区间问题\",\"427\":\"47#_1-1-区间选点\",\"428\":\"47#_1-2-最大不相交区间数量\",\"429\":\"47#_1-3-区间分组\",\"430\":\"47#_1-4-区间覆盖\",\"431\":\"47#_1-5-区间合并\",\"432\":\"47@0\",\"433\":\"48\",\"434\":\"48#_1-大数据概述\",\"435\":\"48#_2-相关概念\",\"436\":\"48#_2-1-数据仓库\",\"437\":\"48#_2-2-数据湖\",\"438\":\"48#_2-3-湖仓一体\",\"439\":\"48#_2-4-oltp-与-olap\",\"440\":\"48#_2-5-rp-关系投影\",\"441\":\"48#_2-6-物化视图\",\"442\":\"48@0\",\"443\":\"48@1\",\"444\":\"49\",\"445\":\"49#_1-springsecurity-介绍\",\"446\":\"49#_2-springsecurity-配置\",\"447\":\"49#_3-用户登录流程\",\"448\":\"49#_3-1-前端\",\"449\":\"49#_3-2-后端\",\"450\":\"49#syslogincontroller\",\"451\":\"49#sysloginservice\",\"452\":\"49#_4-获取用户角色和权限\",\"453\":\"49#_4-1-前端\",\"454\":\"49#_4-2-后端\",\"455\":\"49#syslogincontroller-1\",\"456\":\"49#syspermissionservice\",\"457\":\"49#_4-3-页面权限\",\"458\":\"49#_5-获取动态菜单路由\",\"459\":\"49#_5-1-前端\",\"460\":\"49#_5-2-后端\",\"461\":\"49#syslogincontroller-2\",\"462\":\"49#isysmenuservice\",\"463\":\"49#_5-3-路由菜单加载\",\"464\":\"49#_6-权限注解\",\"465\":\"49#_6-1-源码分析\",\"466\":\"49#_6-2-权限方法\",\"467\":\"49#_6-3-使用示例\",\"468\":\"49#_6-4-公开接口\",\"469\":\"49#_7-数据权限\",\"470\":\"49#_7-1-数据权限介绍\",\"471\":\"49#_7-2-源码实现\",\"472\":\"49@0\",\"473\":\"49@1\",\"474\":\"50\",\"475\":\"50#_1-源码分析\",\"476\":\"50#_1-1-表结构说明\",\"477\":\"50#_1-2-目录结构\",\"478\":\"50#_1-3-quartz-体系结构\",\"479\":\"50#_1-4-quartz-核心-api\",\"480\":\"50#_1-5-定时任务执行\",\"481\":\"50#_1-6-添加定时任务\",\"482\":\"50#_1-7-定时任务状态修改\",\"483\":\"50#_2-集群模式\",\"484\":\"50#_2-1-集群介绍\",\"485\":\"50#_2-2-实现\",\"486\":\"50#_2-2-1-导入sql\",\"487\":\"50#_2-2-2-开启配置\",\"488\":\"50#_2-2-3-节点复制\",\"489\":\"50#_2-2-4-观察数据库\",\"490\":\"50@0\",\"491\":\"50@1\",\"492\":\"51\",\"493\":\"51#_1-项目介绍\",\"494\":\"51#_2-核心业务流程\",\"495\":\"51#_3-项目功能\",\"496\":\"51#_3-1-基础功能\",\"497\":\"51#_3-2-高级功能\",\"498\":\"51#_4-技术选型\",\"499\":\"51#_4-1-前端\",\"500\":\"51#_4-2-后端\",\"501\":\"51#_6-架构设计\",\"502\":\"51#_7-环境准备\",\"503\":\"51@0\",\"504\":\"51@1\",\"505\":\"52\",\"506\":\"52#_1-需求分析\",\"507\":\"52#_1-1-基础功能-均为-p0\",\"508\":\"52#_1-2-高级功能-均为-p1-p2\",\"509\":\"52#_2-库表设计\",\"510\":\"52#_2-1用户表\",\"511\":\"52#_2-2-题库表\",\"512\":\"52#_2-3-题目表\",\"513\":\"52#_2-4-题库题目关联表\",\"514\":\"52#_3-后端基础开发\",\"515\":\"52#_3-1-数据实体层\",\"516\":\"52#_3-2-业务逻辑层\",\"517\":\"52#_3-3-数据模型层\",\"518\":\"52#_3-4-接口开发\",\"519\":\"52#_3-5-服务开发\",\"520\":\"52#_3-6-swagger-接口文档测试\",\"521\":\"52#_4-后端核心业务开发\",\"522\":\"52#_4-1-题库模块\",\"523\":\"52#_4-1-1-获取题库详情\",\"524\":\"52#_4-2-题目模块\",\"525\":\"52#_4-2-1-获取题目列表\",\"526\":\"52#_4-2-2-修改题目所属题库\",\"527\":\"52@0\",\"528\":\"52@1\",\"529\":\"53\",\"530\":\"53#_1-服务端渲染\",\"531\":\"53#_1-1-什么是客户端和服务端渲染\",\"532\":\"53#_1-2-客户端渲染\",\"533\":\"53#_1-3-服务端渲染\",\"534\":\"53#_1-4-其他渲染方式-静态网站生成\",\"535\":\"53#_1-5-结合使用-推荐\",\"536\":\"53#_2-开发-next-js-前端万用模板\",\"537\":\"53#_2-1-确认环境\",\"538\":\"53#_2-2-创建项目\",\"539\":\"53#_2-3-前端工程化配置\",\"540\":\"53#_2-4-引入组件库\",\"541\":\"53#_2-5-next-js-开发规范\",\"542\":\"53#_2-5-1-约定式路由\",\"543\":\"53#_2-5-2-静态资源\",\"544\":\"53#_2-5-3-文件组织形式\",\"545\":\"53#_2-5-4-页面开发规范\",\"546\":\"53#_2-5-5-其他注意事项\",\"547\":\"53#_2-6-全局通用布局\",\"548\":\"53#_2-6-1-基础布局结构\",\"549\":\"53#_2-6-2-全局底部栏\",\"550\":\"53#_2-6-3-全局顶部导航栏\",\"551\":\"53#_2-6-4-导航菜单配置\",\"552\":\"53@0\",\"553\":\"53@1\",\"554\":\"54\",\"555\":\"54#_1、企业做项目流程\",\"556\":\"54#_2、需求分析\",\"557\":\"54#_3、技术选型\",\"558\":\"54#_4、初始化项目\",\"559\":\"54#_4-1-前端初始化\",\"560\":\"54#_4-2-后端初始化-3种初始化-java-项目的方式\",\"561\":\"54@0\",\"562\":\"54@1\",\"563\":\"55\",\"564\":\"55#_1、数据库设计\",\"565\":\"55#_1-1-什么是设计数据库表\",\"566\":\"55#_1-2-用户表设计\",\"567\":\"55#_1-3-自动生成器的使用\",\"568\":\"55#_2、注册逻辑设计\",\"569\":\"55@0\",\"570\":\"55@1\",\"571\":\"56\",\"572\":\"56#_1、登录功能\",\"573\":\"56#_1-1-接口设计\",\"574\":\"56#_1-2-登录逻辑\",\"575\":\"56#_1-3-如何知道是哪个用户登录了\",\"576\":\"56#_1-4-登录接口\",\"577\":\"56#_2、用户管理\",\"578\":\"56#_2-1-查询用户\",\"579\":\"56#_2-2-删除用户\",\"580\":\"56#_2-3-用户状态优化\",\"581\":\"56@0\",\"582\":\"56@1\",\"583\":\"57\",\"584\":\"57#_1、前后端交互\",\"585\":\"57#_1-1-前端请求\",\"586\":\"57#_1-2-代理的位置\",\"587\":\"57#_2、注册页面\",\"588\":\"57#_3、登录页面\",\"589\":\"57#_4、获取当前登录用户\",\"590\":\"57#_5、后台管理页面\",\"591\":\"57#设置登录后自动跳转\",\"592\":\"57#添加后台管理页面\",\"593\":\"57@0\",\"594\":\"57@1\",\"595\":\"58\",\"596\":\"58#用户注销\",\"597\":\"58#后端优化\",\"598\":\"58#通用返回对象\",\"599\":\"58#封装全局异常处理器\",\"600\":\"58#前端优化\",\"601\":\"58@0\",\"602\":\"58@1\",\"603\":\"59\",\"604\":\"59#多环境\",\"605\":\"59#项目部署\",\"606\":\"59#原始部署\",\"607\":\"59#宝塔-linux-部署\",\"608\":\"59#docker-容器部署\",\"609\":\"59#绑定域名\",\"610\":\"59#跨域问题\",\"611\":\"59@0\",\"612\":\"59@1\",\"613\":\"60\",\"614\":\"60@0\",\"615\":\"60@1\",\"616\":\"61\",\"617\":\"61#_11-30\",\"618\":\"61#_11-29\",\"619\":\"61#_11-28\",\"620\":\"61#_11-27\",\"621\":\"61#_11-26\",\"622\":\"61#_11-25\",\"623\":\"61#_11-23\",\"624\":\"61#_11-21\",\"625\":\"61#_11-20\",\"626\":\"61#_11-18\",\"627\":\"61#_11-16\",\"628\":\"61#_11-13\",\"629\":\"61#_11-12\",\"630\":\"61#_11-11\",\"631\":\"61#_11-9\",\"632\":\"61#_11-8\",\"633\":\"61#_11-7\",\"634\":\"61#_11-6\",\"635\":\"61#_11-4\",\"636\":\"61#_11-1\",\"637\":\"61@0\",\"638\":\"62\",\"639\":\"62#_12-11\",\"640\":\"62#_12-10\",\"641\":\"62#_12-9\",\"642\":\"62#_12-8\",\"643\":\"62#_12-7\",\"644\":\"62#_12-6\",\"645\":\"62#_12-5\",\"646\":\"62#_12-4\",\"647\":\"62#_12-3\",\"648\":\"62#_12-2\",\"649\":\"62#_12-1\",\"650\":\"62@0\",\"651\":\"63\",\"652\":\"63#往期回顾\",\"653\":\"63#_10-30\",\"654\":\"63@0\",\"655\":\"64\",\"656\":\"64@0\",\"657\":\"64@1\",\"658\":\"65\",\"659\":\"65@0\",\"660\":\"65@1\",\"661\":\"66\",\"662\":\"66#如何自建代理服务\",\"663\":\"66#放行端口的步骤\",\"664\":\"66#保护你的代理服务器\",\"665\":\"66#本地代理客户端\",\"666\":\"66@0\",\"667\":\"66@1\",\"668\":\"67\",\"669\":\"67#什么是-cloudreve\",\"670\":\"67#搭建过程\",\"671\":\"67#配置进程守护\",\"672\":\"67#配置站点-url-及免费-https\",\"673\":\"67#配置-webdav\",\"674\":\"67#什么是-webdav\",\"675\":\"67#cloudreve-使用-webdav\",\"676\":\"67#windows-使用-webdav\",\"677\":\"67@0\",\"678\":\"67@1\",\"679\":\"68\",\"680\":\"68#题意\",\"681\":\"68#思路\",\"682\":\"68#代码\",\"683\":\"68@0\",\"684\":\"68@1\",\"685\":\"69\",\"686\":\"69#题意\",\"687\":\"69#思路一-手搓-lru\",\"688\":\"69#思路二-继承-linkedhashmap\",\"689\":\"69@0\",\"690\":\"69@1\",\"691\":\"70\",\"692\":\"70#题意\",\"693\":\"70#思路\",\"694\":\"70#代码\",\"695\":\"70@0\",\"696\":\"70@1\",\"697\":\"71\",\"698\":\"71#题意\",\"699\":\"71#思路\",\"700\":\"71#代码\",\"701\":\"71@0\",\"702\":\"71@1\",\"703\":\"72\",\"704\":\"72#题意\",\"705\":\"72#思路\",\"706\":\"72@0\",\"707\":\"72@1\",\"708\":\"73\",\"709\":\"73#题意\",\"710\":\"73#思路\",\"711\":\"73#进阶\",\"712\":\"73#思路-1\",\"713\":\"73#代码\",\"714\":\"73@0\",\"715\":\"73@1\",\"716\":\"74\",\"717\":\"74#题意\",\"718\":\"74#思路\",\"719\":\"74#代码\",\"720\":\"74@0\",\"721\":\"74@1\",\"722\":\"75\",\"723\":\"75#题意\",\"724\":\"75#思路一-先序遍历\",\"725\":\"75#思路二-递归\",\"726\":\"75@0\",\"727\":\"75@1\",\"728\":\"76\",\"729\":\"76#题意\",\"730\":\"76#思路一-递归\",\"731\":\"76#思路二-迭代\",\"732\":\"76@0\",\"733\":\"76@1\",\"734\":\"77\",\"735\":\"77#题意\",\"736\":\"77#思路一-递归遍历\",\"737\":\"77#思路二-层序遍历\",\"738\":\"77@0\",\"739\":\"77@1\",\"740\":\"78\",\"741\":\"78#题意\",\"742\":\"78#思路\",\"743\":\"78#代码\",\"744\":\"78@0\",\"745\":\"78@1\",\"746\":\"79\",\"747\":\"79#题意\",\"748\":\"79#思路一-后序遍历-递归\",\"749\":\"79#思路二-层序遍历-迭代\",\"750\":\"79@0\",\"751\":\"79@1\",\"752\":\"80\",\"753\":\"80#题意\",\"754\":\"80#思路\",\"755\":\"80#代码\",\"756\":\"80@0\",\"757\":\"80@1\",\"758\":\"81\",\"759\":\"81#题意\",\"760\":\"81#思路\",\"761\":\"81#代码\",\"762\":\"81@0\",\"763\":\"81@1\",\"764\":\"82\",\"765\":\"82#题意\",\"766\":\"82#思路\",\"767\":\"82#代码\",\"768\":\"82@0\",\"769\":\"82@1\",\"770\":\"83\",\"771\":\"83#题意\",\"772\":\"83#思路\",\"773\":\"83@0\",\"774\":\"83@1\",\"775\":\"84\",\"776\":\"84#题意\",\"777\":\"84#思路\",\"778\":\"84#代码\",\"779\":\"84@0\",\"780\":\"84@1\",\"781\":\"85\",\"782\":\"85#题意\",\"783\":\"85#思路一-动态规划\",\"784\":\"85#思路二-记忆化搜索\",\"785\":\"85@0\",\"786\":\"85@1\",\"787\":\"86\",\"788\":\"86#题意\",\"789\":\"86#思路一-优先队列\",\"790\":\"86#思路二-分治\",\"791\":\"86@0\",\"792\":\"86@1\",\"793\":\"87\",\"794\":\"87#题意\",\"795\":\"87#思路一-记忆化搜索\",\"796\":\"87#思路二-递推\",\"797\":\"87#空间优化\",\"798\":\"87@0\",\"799\":\"87@1\",\"800\":\"88\",\"801\":\"88#题意\",\"802\":\"88#思路\",\"803\":\"88#代码\",\"804\":\"88@0\",\"805\":\"88@1\",\"806\":\"89\",\"807\":\"89#题意\",\"808\":\"89#思路\",\"809\":\"89#代码\",\"810\":\"89@0\",\"811\":\"89@1\",\"812\":\"90\",\"813\":\"90#题意\",\"814\":\"90#思路\",\"815\":\"90#代码\",\"816\":\"90@0\",\"817\":\"90@1\",\"818\":\"91\",\"819\":\"91#题意\",\"820\":\"91#思路一-dfs\",\"821\":\"91#思路二-bfs\",\"822\":\"91#思路三-并查集\",\"823\":\"91@0\",\"824\":\"91@1\",\"825\":\"92\",\"826\":\"92#题意\",\"827\":\"92#思路一-记忆化搜索\",\"828\":\"92#思路二-递推\",\"829\":\"92@0\",\"830\":\"92@1\",\"831\":\"93\",\"832\":\"93#题意\",\"833\":\"93#思路\",\"834\":\"93#代码\",\"835\":\"93@0\",\"836\":\"93@1\",\"837\":\"94\",\"838\":\"94#题意\",\"839\":\"94#思路\",\"840\":\"94#代码\",\"841\":\"94@0\",\"842\":\"94@1\",\"843\":\"95\",\"844\":\"95#题意\",\"845\":\"95#思路一-栈模拟\",\"846\":\"95#思路二-动态规划\",\"847\":\"95@0\",\"848\":\"95@1\",\"849\":\"96\",\"850\":\"96#题意\",\"851\":\"96#思路\",\"852\":\"96#二分优化\",\"853\":\"96@0\",\"854\":\"96@1\",\"855\":\"97\",\"856\":\"97#题意\",\"857\":\"97#思路一-优先队列\",\"858\":\"97#思路二-单调队列\",\"859\":\"97@0\",\"860\":\"97@1\",\"861\":\"98\",\"862\":\"98#题意\",\"863\":\"98#思路\",\"864\":\"98#代码\",\"865\":\"98@0\",\"866\":\"98@1\",\"867\":\"99\",\"868\":\"99#题意\",\"869\":\"99#思路\",\"870\":\"99#代码\",\"871\":\"99@0\",\"872\":\"99@1\",\"873\":\"100\",\"874\":\"100#题意\",\"875\":\"100#思路\",\"876\":\"100#代码\",\"877\":\"100@0\",\"878\":\"100@1\",\"879\":\"101\",\"880\":\"101#题意\",\"881\":\"101#思路\",\"882\":\"101#代码\",\"883\":\"101@0\",\"884\":\"101@1\",\"885\":\"102\",\"886\":\"102#题意\",\"887\":\"102#思路一-哈希表\",\"888\":\"102#思路二-拼接-拆分\",\"889\":\"102@0\",\"890\":\"102@1\",\"891\":\"103\",\"892\":\"103#题意\",\"893\":\"103#思路一-完全背包\",\"894\":\"103#思路二-空间优化\",\"895\":\"103@0\",\"896\":\"103@1\",\"897\":\"104\",\"898\":\"104#题意\",\"899\":\"104#思路一-前序遍历\",\"900\":\"104#思路二-中序遍历\",\"901\":\"104#思路三-后序遍历\",\"902\":\"104@0\",\"903\":\"104@1\",\"904\":\"105\",\"905\":\"105#_1-基础\",\"906\":\"105#_1-1-连接\",\"907\":\"105#_1-2-sql-简介\",\"908\":\"105#_1-2-1-sql-通用语法\",\"909\":\"105#_1-2-2-分类\",\"910\":\"105#_2-数据库设计-ddl\",\"911\":\"105#_2-1-数据库操作\",\"912\":\"105#_2-1-1-查询数据库\",\"913\":\"105#_2-1-2-创建数据库\",\"914\":\"105#_2-1-3-使用数据库\",\"915\":\"105#_2-1-4-删除数据库\",\"916\":\"105#_2-2-表操作\",\"917\":\"105#_2-2-1-创建\",\"918\":\"105#_2-2-1-1-语法\",\"919\":\"105#_2-2-1-2-约束\",\"920\":\"105#_2-2-1-3-数据类型\",\"921\":\"105#_2-2-2-查询\",\"922\":\"105#_2-2-3-修改\",\"923\":\"105#_2-2-4-删除\",\"924\":\"105#_3-数据库操作-dml\",\"925\":\"105#_3-1-增加-insert\",\"926\":\"105#_3-2-修改-update\",\"927\":\"105#_3-3-删除-delete\",\"928\":\"105#_4-数据库操作-dql\",\"929\":\"105#_4-1-语法\",\"930\":\"105#_4-2-基本查询\",\"931\":\"105#_4-3-条件查询\",\"932\":\"105#_4-4-聚合函数\",\"933\":\"105#_4-5-分组查询\",\"934\":\"105#_4-6-排序查询\",\"935\":\"105#_4-7-分页查询\",\"936\":\"105#_5-多表设计\",\"937\":\"105#_5-1-一对多-外键约束\",\"938\":\"105#_5-2-一对一\",\"939\":\"105#_5-3-多对多\",\"940\":\"105#_6-多表查询\",\"941\":\"105#_6-1-概述\",\"942\":\"105#_6-1-1-介绍\",\"943\":\"105#_6-1-2-分类\",\"944\":\"105#_6-3-内连接\",\"945\":\"105#_6-3-外连接\",\"946\":\"105#_6-4-子查询\",\"947\":\"105#_6-4-1-介绍\",\"948\":\"105#_6-4-2-标量子查询\",\"949\":\"105#_6-4-3-列子查询\",\"950\":\"105#_6-4-4-行子查询\",\"951\":\"105#_6-4-5-表子查询\",\"952\":\"105#_7-事务\",\"953\":\"105#_7-1-介绍\",\"954\":\"105#_7-2-操作\",\"955\":\"105#_7-3-四大特性\",\"956\":\"105#_8-索引\",\"957\":\"105#_8-1-介绍\",\"958\":\"105#_8-2-结构\",\"959\":\"105#_8-3-语法\",\"960\":\"105@0\",\"961\":\"105@1\",\"962\":\"106\",\"963\":\"106#_1-单例模式的定义\",\"964\":\"106@0\",\"965\":\"106@1\",\"966\":\"107\",\"967\":\"107#_1-工厂方法模式的定义\",\"968\":\"107@0\",\"969\":\"107@1\",\"970\":\"108\",\"971\":\"108#哈希表的工作原理\",\"972\":\"108#优点\",\"973\":\"108#缺点\",\"974\":\"108@0\",\"975\":\"108@1\",\"976\":\"109\",\"977\":\"109#一、语法基础\",\"978\":\"109#_1-1-变量\",\"979\":\"109#_1-2-运算符\",\"980\":\"109#_1-3-表达式\",\"981\":\"109#_1-4-输入\",\"982\":\"109#_1-5-输出\",\"983\":\"109#二、判断语句\",\"984\":\"109#_2-1-if-语句\",\"985\":\"109#_2-2-条件表达式\",\"986\":\"109#_2-3-switch-语句\",\"987\":\"109#三、循环语句\",\"988\":\"109#_3-1-while-循环\",\"989\":\"109#_3-2-do-while-循环\",\"990\":\"109#_3-3-for-循环\",\"991\":\"109#_3-4-跳转语句\",\"992\":\"109#_3-4-1-break\",\"993\":\"109#_3-4-2-continue\",\"994\":\"109#_3-5-多层循环\",\"995\":\"109#四、数组\",\"996\":\"109#_4-1-一维数组\",\"997\":\"109#_4-1-1-数组的定义\",\"998\":\"109#_4-1-2-数组的初始化\",\"999\":\"109#_4-1-3-访问数组元素\",\"1000\":\"109#_4-2-多维数组\",\"1001\":\"109#_4-3-数组的范围遍历\",\"1002\":\"109#_4-3-常用api\",\"1003\":\"109#五、字符串\",\"1004\":\"109#_5-1-字符与整数的联系——ascii码\",\"1005\":\"109#_5-2-string-类\",\"1006\":\"109#_5-3-输入与输出\",\"1007\":\"109#_5-4-stringbuilder、stringbuffer\",\"1008\":\"109#六、函数\",\"1009\":\"109#_6-1-函数基础\",\"1010\":\"109#_6-1-1-编写函数\",\"1011\":\"109#_6-1-2-调用函数\",\"1012\":\"109#_6-1-3-形参和实参\",\"1013\":\"109#_6-1-4-函数的形参列表\",\"1014\":\"109#_6-1-5-函数返回类型\",\"1015\":\"109#_6-1-6-变量的作用域\",\"1016\":\"109#_6-2-参数传递\",\"1017\":\"109#_6-2-1-值传递\",\"1018\":\"109#_6-2-2-引用传递\",\"1019\":\"109#_6-3-返回类型和-return-语句\",\"1020\":\"109#_6-3-1-无返回值函数\",\"1021\":\"109#_6-3-2-有返回值的函数\",\"1022\":\"109#_6-4-函数重载\",\"1023\":\"109#_6-5-函数递归\",\"1024\":\"109#七、类与接口\",\"1025\":\"109#_7-1-类与对象\",\"1026\":\"109#_7-1-1-源文件声明规则\",\"1027\":\"109#_7-1-2-类的定义\",\"1028\":\"109#_7-1-3-类的继承\",\"1029\":\"109#_7-1-4-类的多态\",\"1030\":\"109#_7-2-接口\",\"1031\":\"109#_7-2-1-接口的定义\",\"1032\":\"109#_7-2-2-接口的继承\",\"1033\":\"109#_7-2-3-接口的实现\",\"1034\":\"109#_7-2-4-接口的多态\",\"1035\":\"109#八、常用容器\",\"1036\":\"109#_8-1-list\",\"1037\":\"109#_8-2-栈\",\"1038\":\"109#_8-3-队列\",\"1039\":\"109#_8-4-set\",\"1040\":\"109#_8-5-map\",\"1041\":\"109#九、异常处理\",\"1042\":\"109#_9-1-error-与-exception-的区别\",\"1043\":\"109#_9-2-exception类的继承关系\",\"1044\":\"109#_9-3-运行时异常和非运行时异常的区别\",\"1045\":\"109#_9-4-内置异常类\",\"1046\":\"109#_9-5-内置异常方法\",\"1047\":\"109#_9-6-捕获异常\",\"1048\":\"109#_9-7-抛出异常\",\"1049\":\"109#_9-8-try-with-resources\",\"1050\":\"109#十、注解与反射\",\"1051\":\"109#_10-1-注解\",\"1052\":\"109#_10-1-1-常用注解\",\"1053\":\"109#_10-1-2-元注解\",\"1054\":\"109#_10-2-反射\",\"1055\":\"109#_10-2-1-常用api\",\"1056\":\"109#_10-2-2-优缺点\",\"1057\":\"109#十一、多线程与锁\",\"1058\":\"109#_11-1-多线程\",\"1059\":\"109#_11-1-1-实现多线程\",\"1060\":\"109#_11-1-2-常用api\",\"1061\":\"109#_11-2-锁\",\"1062\":\"109#_11-3-同步-synchronized\",\"1063\":\"109#_11-3-1-wait-与-notify\",\"1064\":\"109@0\",\"1065\":\"109@1\",\"1066\":\"110\",\"1067\":\"110#数组\",\"1068\":\"110#字符串\",\"1069\":\"110#string\",\"1070\":\"110#stringbuilder\",\"1071\":\"110#集合\",\"1072\":\"110#list-列表\",\"1073\":\"110#set-集合\",\"1074\":\"110#map-映射\",\"1075\":\"110#栈\",\"1076\":\"110#queue-队列\",\"1077\":\"110#deque-双端队列\",\"1078\":\"110#priorityqueue-优先队列\",\"1079\":\"110#工具类\",\"1080\":\"110#java-util-math\",\"1081\":\"110#java-util-collections\",\"1082\":\"110#javafx-util-pair-k-v\",\"1083\":\"110#基本类型的最大值和最小值\",\"1084\":\"110@0\",\"1085\":\"110@1\",\"1086\":\"111\",\"1087\":\"111#linux-安装启动\",\"1088\":\"111#docker-安装启动\",\"1089\":\"111#windows-安装启动\",\"1090\":\"111#windows-后台服务安装\",\"1091\":\"111@0\",\"1092\":\"111@1\",\"1093\":\"112\",\"1094\":\"112#什么是对象存储\",\"1095\":\"112#特点\",\"1096\":\"112@0\",\"1097\":\"112@1\",\"1098\":\"113\",\"1099\":\"113#引入依赖\",\"1100\":\"113#配置文件\",\"1101\":\"113#minioclient-的常用-api\",\"1102\":\"113#bucket-操作\",\"1103\":\"113#object-操作\",\"1104\":\"113@0\",\"1105\":\"113@1\",\"1106\":\"114\",\"1107\":\"114#概论\",\"1108\":\"114#_1-注释\",\"1109\":\"114#_1-1-单行注释\",\"1110\":\"114#_1-2-多行注释\",\"1111\":\"114#_2-变量\",\"1112\":\"114#_2-1-定义变量\",\"1113\":\"114#_2-2-使用变量\",\"1114\":\"114#_2-3-只读变量\",\"1115\":\"114#_2-4-删除变量\",\"1116\":\"114#_2-5-变量类型\",\"1117\":\"114#_2-6-字符串\",\"1118\":\"114#_3-默认变量\",\"1119\":\"114#_3-1-文件参数变量\",\"1120\":\"114#_3-2-其它参数相关变量\",\"1121\":\"114#_4-数组\",\"1122\":\"114#_4-1-定义\",\"1123\":\"114#_4-2-读取数组中某个元素的值\",\"1124\":\"114#_4-3-读取整个数组\",\"1125\":\"114#_4-4-数组长度\",\"1126\":\"114@0\",\"1127\":\"114@1\",\"1128\":\"115\",\"1129\":\"115#_1-ioc-理论\",\"1130\":\"115#_2-bromon-的-blog-上对-ioc-与-di-浅显易懂的讲解\",\"1131\":\"115#_2-1-ioc\",\"1132\":\"115#_2-2-di\",\"1133\":\"115#_3-注入形式\",\"1134\":\"115#_4-各个组件\",\"1135\":\"115#_4-1-resource-体系\",\"1136\":\"115#_4-2-resourceloader-体系\",\"1137\":\"115#_4-3-beanfactory-体系\",\"1138\":\"115#_4-4-beandefinition-体系\",\"1139\":\"115#_4-5-beandefinitionreader-体系\",\"1140\":\"115#_4-6-applicationcontext-体系\",\"1141\":\"115#_4-7-小结\",\"1142\":\"115@0\",\"1143\":\"115@1\",\"1144\":\"116\",\"1145\":\"116#一、初始化环境\",\"1146\":\"116#二、初始化上下文\",\"1147\":\"116#_2-1-加载-eureka-server-配置文件\",\"1148\":\"116#_2-1-1-创建默认的-eureka-server-配置\",\"1149\":\"116#_2-2-2-加载配置文件\",\"1150\":\"116#_2-1-3-真正的配置项在哪\",\"1151\":\"116#_2-1-4-加载配置文件小结\",\"1152\":\"116#_2-2-构造实例信息管理器\",\"1153\":\"116#_2-2-1-初始化服务实例的配置-instanceconfig\",\"1154\":\"116#_2-2-2-构造服务实例-instanceinfo\",\"1155\":\"116#_2-2-3-小结\",\"1156\":\"116#_2-3-初始化-eureka-client\",\"1157\":\"116#_2-3-1-初始化-eureka-client-配置\",\"1158\":\"116#_2-3-2-初始化-eurekaclient\",\"1159\":\"116#_2-4-处理注册相关的流程\",\"1160\":\"116#_2-4-1-注册对象\",\"1161\":\"116#_2-5-初始化上下文\",\"1162\":\"116#_2-5-1-集群节点帮助类\",\"1163\":\"116#_2-5-2-默认上下文\",\"1164\":\"116#_2-5-3-创建上下文的持有者\",\"1165\":\"116#_2-5-4-初始化上下文\",\"1166\":\"116#_2-6-其他\",\"1167\":\"116#_2-6-1-从相邻节点拷贝注册信息\",\"1168\":\"116#_2-6-2-eureka-监控\",\"1169\":\"116#_2-7-编译报错的解决方案\",\"1170\":\"116#_1、异常1\",\"1171\":\"116#_2、异常2\",\"1172\":\"116#三、总结\",\"1173\":\"116@0\",\"1174\":\"116@1\",\"1175\":\"117\",\"1176\":\"117#一、初始化配置\",\"1177\":\"117#_1-1-初始化变量\",\"1178\":\"117#_1-2-获取配置文件配置\",\"1179\":\"117#_1-3-初始化实例信息\",\"1180\":\"117#_1-4-初始化实例信息管理器\",\"1181\":\"117#二、构造-eurekaclient\",\"1182\":\"117#_2-1-构造流程\",\"1183\":\"117#三、eureka-client-注册\",\"1184\":\"117#_3-1-注册流程\",\"1185\":\"117#四、总结\",\"1186\":\"117#留个问题\",\"1187\":\"117@0\",\"1188\":\"117@1\",\"1189\":\"118\",\"1190\":\"118#系统状态\",\"1191\":\"118#自我保护机制\",\"1192\":\"118#集群信息\",\"1193\":\"118#已注册的实例列表\",\"1194\":\"118#通用信息\",\"1195\":\"118#服务实例信息\",\"1196\":\"118#最近-1000-个取消的租约\",\"1197\":\"118@0\",\"1198\":\"118@1\",\"1199\":\"119\",\"1200\":\"119#_1-概念\",\"1201\":\"119#_2-手写本地缓存\",\"1202\":\"119#_3-基于-guava-cache-实现本地缓存\",\"1203\":\"119#_3-1-添加-gugva-的依赖\",\"1204\":\"119#_3-2-测试\",\"1205\":\"119#_4-基于-caffeine-实现本地缓存\",\"1206\":\"119#_4-1-引入caffeine\",\"1207\":\"119#_4-2-测试\",\"1208\":\"119#_5-基于-encache-实现本地缓存\",\"1209\":\"119#_5-1-引入-ehcache-依赖\",\"1210\":\"119#_5-2-自定义过期策略实现\",\"1211\":\"119#_5-3-测试\",\"1212\":\"119@0\",\"1213\":\"119@1\",\"1214\":\"120\",\"1215\":\"120@0\",\"1216\":\"120@1\",\"1217\":\"121\",\"1218\":\"121#_1-为什么要用到并发\",\"1219\":\"121#_2-并发编程有哪些缺点\",\"1220\":\"121#_2-1-频繁的上下文切换\",\"1221\":\"121#_2-2-线程安全\",\"1222\":\"121#_3-应该了解的概念\",\"1223\":\"121#_3-1-同步vs异步\",\"1224\":\"121#_3-2-并发与并行\",\"1225\":\"121#_3-3-阻塞和非阻塞\",\"1226\":\"121#_3-4-临界区\",\"1227\":\"121#_4-java-并发知识图谱\",\"1228\":\"121@0\",\"1229\":\"121@1\",\"1230\":\"122\",\"1231\":\"122#_1-基本介绍\",\"1232\":\"122#_2-重入性的实现原理\",\"1233\":\"122#_3-公平锁与公平锁\",\"1234\":\"122@0\",\"1235\":\"122@1\",\"1236\":\"123\",\"1237\":\"123#_1-读写锁介绍\",\"1238\":\"123#_2-写锁详解\",\"1239\":\"123#_2-1-写锁的获取\",\"1240\":\"123#_2-2-写锁的释放\",\"1241\":\"123#_3-读锁详解\",\"1242\":\"123#_3-1-读锁的获取\",\"1243\":\"123#_3-2-读锁的释放\",\"1244\":\"123#_4-锁降级\",\"1245\":\"123@0\",\"1246\":\"123@1\",\"1247\":\"124\",\"1248\":\"124#_1-condition-简介\",\"1249\":\"124#_2-condition-实现原理分析\",\"1250\":\"124#_2-1-等待队列\",\"1251\":\"124#_2-2-await-实现原理\",\"1252\":\"124#_2-3-signal-signalall-实现原理\",\"1253\":\"124#_3-await-与-signal-signalall-的结合思考\",\"1254\":\"124#_4-一个例子\",\"1255\":\"124@0\",\"1256\":\"124@1\",\"1257\":\"125\",\"1258\":\"125#_1-locksupport-简介\",\"1259\":\"125#_2-locksupport方法介绍\",\"1260\":\"125#_3-一个例子\",\"1261\":\"125@0\",\"1262\":\"125@1\",\"1263\":\"126\",\"1264\":\"126#_1-concurrenthashmap-简介\",\"1265\":\"126#_2-concurrenthashmap-关键属性及类\",\"1266\":\"126#_2-1-关键属性\",\"1267\":\"126#_2-2-关键内部类\",\"1268\":\"126#_2-3-cas-关键操作\",\"1269\":\"126#_3-重点方法讲解\",\"1270\":\"126#_3-1-实例构造器方法\",\"1271\":\"126#_3-2-inittable-方法\",\"1272\":\"126#_3-3-put-方法\",\"1273\":\"126#_3-4-get-方法\",\"1274\":\"126#_3-5-transfer-方法\",\"1275\":\"126#_3-6-与-size-相关的一些方法\",\"1276\":\"126#_4-总结\",\"1277\":\"126@0\",\"1278\":\"126@1\",\"1279\":\"127\",\"1280\":\"127#_1-concurrentlinkedqueue-简介\",\"1281\":\"127#_1-1-node\",\"1282\":\"127#_1-2-操作-node-的几个-cas-操作\",\"1283\":\"127#_2-offer-方法\",\"1284\":\"127#_3-poll-方法\",\"1285\":\"127#_4-offer-方法中部分线程-offer-部分线程-poll\",\"1286\":\"127#_5-hops-的设计\",\"1287\":\"127@0\",\"1288\":\"127@1\",\"1289\":\"128\",\"1290\":\"128#_1-copyonwritearraylist-简介\",\"1291\":\"128#_2-cow-的设计思想\",\"1292\":\"128#_3-copyonwritearraylist-的实现原理\",\"1293\":\"128#_3-1-get-方法实现原理\",\"1294\":\"128#_3-2-add-方法实现原理\",\"1295\":\"128#_4-总结\",\"1296\":\"128@0\",\"1297\":\"128@1\",\"1298\":\"129\",\"1299\":\"129#_1-threadlocal-简介\",\"1300\":\"129#_2-threadlocal-的实现原理\",\"1301\":\"129#_2-1-set-方法\",\"1302\":\"129#_2-2-get-方法\",\"1303\":\"129#_2-3-remove-方法\",\"1304\":\"129#_3-threadlocalmap-详解\",\"1305\":\"129#_3-1-entry-数据结构\",\"1306\":\"129#_3-2-set-方法\",\"1307\":\"129#_3-3-getentry-方法\",\"1308\":\"129#_3-4-remove-方法\",\"1309\":\"129#_4-threadlocal-的使用场景\",\"1310\":\"129@0\",\"1311\":\"129@1\",\"1312\":\"130\",\"1313\":\"130#_1-造成内存泄露的原因\",\"1314\":\"130#_2-已经做出了哪些改进\",\"1315\":\"130#_2-1-cleansomeslots\",\"1316\":\"130#_2-2-expungestaleentry\",\"1317\":\"130#_2-3-replacestaleentry\",\"1318\":\"130#_2-4-为什么使用弱引用\",\"1319\":\"130#_2-5-thread-exit\",\"1320\":\"130#_3-threadlocal-最佳实践\",\"1321\":\"130@0\",\"1322\":\"130@1\",\"1323\":\"131\",\"1324\":\"131#_1-blockingqueue-简介\",\"1325\":\"131#_2-基本操作\",\"1326\":\"131#_3-常用的-blockingqueue\",\"1327\":\"131@0\",\"1328\":\"131@1\",\"1329\":\"132\",\"1330\":\"132#_1-新建线程\",\"1331\":\"132#_2-可运行线程\",\"1332\":\"132#_3-阻塞和等待线程\",\"1333\":\"132#_4-终止线程\",\"1334\":\"132#_5-线程状态转换\",\"1335\":\"132#_6-线程的基本操作\",\"1336\":\"132#_6-1-interrupted\",\"1337\":\"132#_6-2-join\",\"1338\":\"132#_6-3-sleep\",\"1339\":\"132#_6-4-yield\",\"1340\":\"132#_7-守护线程-daemon\",\"1341\":\"132@0\",\"1342\":\"132@1\",\"1343\":\"133\",\"1344\":\"133#_1-arrayblockingqueue-简介\",\"1345\":\"133#_2-arrayblockingqueue-实现原理\",\"1346\":\"133#_2-1-arrayblockingqueue-的主要属性\",\"1347\":\"133#_2-2-put-方法详解\",\"1348\":\"133#_2-3-take-方法详解\",\"1349\":\"133#_3-linkedblockingqueue-实现原理\",\"1350\":\"133#_3-1-linkedblockingqueue-的主要属性\",\"1351\":\"133#_3-2-put-方法详解\",\"1352\":\"133#_3-3-take-方法详解\",\"1353\":\"133#_4-arrayblockingqueue-与-linkedblockingqueue-比较\",\"1354\":\"133@0\",\"1355\":\"133@1\",\"1356\":\"134\",\"1357\":\"134#_1-为什么要使用线程池\",\"1358\":\"134#_2-线程池的工作原理\",\"1359\":\"134#_3-线程池的创建\",\"1360\":\"134#_4-线程池的关闭\",\"1361\":\"134#_5-如何合理配置线程池参数\",\"1362\":\"134@0\",\"1363\":\"134@1\",\"1364\":\"135\",\"1365\":\"135#_1-scheduledthreadpoolexecutor-简介\",\"1366\":\"135#_1-1-构造方法\",\"1367\":\"135#_1-2-特有方法\",\"1368\":\"135#_2-可周期性执行的任务-——-scheduledfuturetask\",\"1369\":\"135#_3-delayedworkqueue\",\"1370\":\"135#_4-scheduledthreadpoolexecutor-执行过程\",\"1371\":\"135#_5-总结\",\"1372\":\"135@0\",\"1373\":\"135@1\",\"1374\":\"136\",\"1375\":\"136#_1-futuretask-简介\",\"1376\":\"136#_2-futuretask-的基本使用\",\"1377\":\"136@0\",\"1378\":\"136@1\",\"1379\":\"137\",\"1380\":\"137#_1-原子操作类介绍\",\"1381\":\"137#_2-cas-操作\",\"1382\":\"137#_2-1-什么是-cas\",\"1383\":\"137#_2-2-cas的操作过程\",\"1384\":\"137#_2-3-synchronized-vs-cas\",\"1385\":\"137#_3-原子更新基本类型\",\"1386\":\"137#_4-原子更新数组类型\",\"1387\":\"137#_5-原子更新引用类型\",\"1388\":\"137#_6-原子更新字段类型\",\"1389\":\"137@0\",\"1390\":\"137@1\",\"1391\":\"138\",\"1392\":\"138#_1-倒计时器-countdownlatch\",\"1393\":\"138#_2-循环栅栏-cyclicbarrier\",\"1394\":\"138#_3-countdownlatch-与-cyclicbarrier-比较\",\"1395\":\"138@0\",\"1396\":\"138@1\",\"1397\":\"139\",\"1398\":\"139#_1-控制资源并发访问-——-semaphore\",\"1399\":\"139#_2-线程间交换数据的工具-——-exchanger\",\"1400\":\"139@0\",\"1401\":\"139@1\",\"1402\":\"140\",\"1403\":\"140#_1-wait-notify-的消息通知机制\",\"1404\":\"140#_1-1-预备知识\",\"1405\":\"140#_1-2-wait-notify-消息通知潜在的一些问题\",\"1406\":\"140#_1-2-1-notify-早期通知\",\"1407\":\"140#_1-2-2-等待-wait-的条件发生变化\",\"1408\":\"140#_1-2-3-假死-状态\",\"1409\":\"140#_1-3-wait-notifyall-实现生产者-消费者\",\"1410\":\"140#_2-使用-lock-中-condition-的-await-signalall-实现生产者-消费者\",\"1411\":\"140#_3-使用-blockingqueue-实现生产者-消费者\",\"1412\":\"140@0\",\"1413\":\"140@1\",\"1414\":\"141\",\"1415\":\"141#_1-jmm-介绍\",\"1416\":\"141#_2-线程通信\",\"1417\":\"141#_3-jmm-抽象结构模型\",\"1418\":\"141#_4-重排序\",\"1419\":\"141#_5-happens-before-规则\",\"1420\":\"141#_5-1-happens-before-定义\",\"1421\":\"141#_5-2-具体规则\",\"1422\":\"141#_6-总结\",\"1423\":\"141#_6-1-jmm-的设计\",\"1424\":\"141#_6-2-happens-before-与-jmm-的关系\",\"1425\":\"141#_6-3-今后可能需要关注的问题\",\"1426\":\"141@0\",\"1427\":\"141@1\",\"1428\":\"142\",\"1429\":\"142#_1-synchronized-简介\",\"1430\":\"142#_2-synchronized-实现原理\",\"1431\":\"142#_2-1-对象锁-monitor-机制\",\"1432\":\"142#_2-2-synchronized-的-happens-before-关系\",\"1433\":\"142#_2-3-锁获取和锁释放的内存语义\",\"1434\":\"142#_3-synchronized优化\",\"1435\":\"142#_3-1-cas-操作\",\"1436\":\"142#_3-1-1-什么是-cas\",\"1437\":\"142#_3-1-2-cas-的操作过程\",\"1438\":\"142#_3-1-3-cas-的应用场景\",\"1439\":\"142#_3-1-4-cas-的问题\",\"1440\":\"142#_3-2-java-对象头\",\"1441\":\"142#_3-3-偏向锁\",\"1442\":\"142#_3-3-1-偏向锁的获取\",\"1443\":\"142#_3-3-2-偏向锁的撤销\",\"1444\":\"142#_3-3-3-如何关闭偏向锁\",\"1445\":\"142#_3-4-轻量级锁\",\"1446\":\"142#_3-4-1-加锁\",\"1447\":\"142#_3-4-2-解锁\",\"1448\":\"142#_3-5-各种锁的比较\",\"1449\":\"142#_4-一个例子\",\"1450\":\"142@0\",\"1451\":\"142@1\",\"1452\":\"143\",\"1453\":\"143#_1-volatile-简介\",\"1454\":\"143#_2-volatile-实现原理\",\"1455\":\"143#_3-volatile-的-happens-before-关系\",\"1456\":\"143#_4-volatile-的内存语义\",\"1457\":\"143#_5-volatile-的内存语义实现\",\"1458\":\"143#_6-一个例子\",\"1459\":\"143@0\",\"1460\":\"143@1\",\"1461\":\"144\",\"1462\":\"144#_1-final-简介\",\"1463\":\"144#_2-final-的具体使用场景\",\"1464\":\"144#_2-1-变量\",\"1465\":\"144#_2-1-1-final-成员变量\",\"1466\":\"144#_2-1-2-final-局部变量\",\"1467\":\"144#_2-1-2-final-基本数据类型-vs-final-引用数据类型\",\"1468\":\"144#_2-2-方法\",\"1469\":\"144#_2-2-1-重写\",\"1470\":\"144#_2-2-2-重载\",\"1471\":\"144#_2-3-类\",\"1472\":\"144#_3-final-的例子\",\"1473\":\"144#_4-多线程中你真的了解-final-吗\",\"1474\":\"144#_4-1-final-域重排序规则\",\"1475\":\"144#_4-1-1-final-域为基本类型\",\"1476\":\"144#_4-1-2-final-域为引用类型\",\"1477\":\"144#_5-final-的实现原理\",\"1478\":\"144#_6-为什么-final-引用不能从构造函数中-溢出\",\"1479\":\"144@0\",\"1480\":\"144@1\",\"1481\":\"145\",\"1482\":\"145#_1-原子性\",\"1483\":\"145#_2-有序性\",\"1484\":\"145#_2-1-synchronized\",\"1485\":\"145#_2-2-volatile\",\"1486\":\"145#_3-可见性\",\"1487\":\"145#_4-总结\",\"1488\":\"145@0\",\"1489\":\"145@1\",\"1490\":\"146\",\"1491\":\"146#_1-concurrent-包的结构层次\",\"1492\":\"146#_2-lock-简介\",\"1493\":\"146#_2-1-lock-接口-api\",\"1494\":\"146#_2-2-初识-aqs\",\"1495\":\"146#_2-3-aqs-的模板方法设计模式\",\"1496\":\"146#_3-一个例子\",\"1497\":\"146@0\",\"1498\":\"146@1\",\"1499\":\"147\",\"1500\":\"147#_1-aqs-简介\",\"1501\":\"147#_2-同步队列\",\"1502\":\"147#_3-独占锁\",\"1503\":\"147#_3-1-独占锁的获取-acquire\",\"1504\":\"147#_3-1-1-获取同步状态失败-入队操作\",\"1505\":\"147#_3-1-2-获取锁成功-出队操作\",\"1506\":\"147#_3-2-独占锁的释放-release\",\"1507\":\"147#_3-3-可中断式获取锁-acquireinterruptibly\",\"1508\":\"147#_3-4-超时等待式获取锁-tryacquirenanos\",\"1509\":\"147#_4-共享锁\",\"1510\":\"147#_4-1-共享锁的获取-acquireshared\",\"1511\":\"147#_4-2-共享锁的释放-releaseshared\",\"1512\":\"147#_4-3-可中断-acquiresharedinterruptibly-超时等待-tryacquiresharednanos\",\"1513\":\"147@0\",\"1514\":\"147@1\",\"1515\":\"148\",\"1516\":\"149\",\"1517\":\"150\",\"1518\":\"151\",\"1519\":\"152\",\"1520\":\"153\",\"1521\":\"154\",\"1522\":\"155\",\"1523\":\"156\",\"1524\":\"157\",\"1525\":\"158\",\"1526\":\"159\",\"1527\":\"160\",\"1528\":\"161\",\"1529\":\"162\",\"1530\":\"163\",\"1531\":\"164\",\"1532\":\"165\",\"1533\":\"166\",\"1534\":\"167\",\"1535\":\"168\",\"1536\":\"169\",\"1537\":\"170\",\"1538\":\"171\",\"1539\":\"172\",\"1540\":\"173\",\"1541\":\"174\",\"1542\":\"175\",\"1543\":\"176\",\"1544\":\"177\",\"1545\":\"178\",\"1546\":\"179\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1,4],\"2\":[1,4],\"3\":[1,6],\"4\":[1,5],\"5\":[2],\"6\":[1,2],\"7\":[1,9],\"8\":[1],\"9\":[1],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[1],\"14\":[1,44],\"15\":[1],\"16\":[1],\"17\":[1,2],\"18\":[1,3],\"19\":[1,5],\"20\":[1,3],\"21\":[2,44],\"22\":[2,43],\"23\":[2,3],\"24\":[4],\"25\":[5,48],\"26\":[4,22],\"27\":[5,14],\"28\":[5,86],\"29\":[2],\"30\":[3,119],\"31\":[3,80],\"32\":[2],\"33\":[3,70],\"34\":[3,29],\"35\":[2,5],\"36\":[3,38],\"37\":[3,79],\"38\":[2],\"39\":[3,52],\"40\":[3,207],\"41\":[3,92],\"42\":[null,null,1],\"43\":[null,null,1],\"44\":[1,13],\"45\":[1,45],\"46\":[1,82],\"47\":[2,16],\"48\":[1,53],\"49\":[1,46],\"50\":[2,48],\"51\":[2,25],\"52\":[null,null,1],\"53\":[null,null,1],\"54\":[1,3],\"55\":[1],\"56\":[1,163],\"57\":[1,14],\"58\":[1,71],\"59\":[1],\"60\":[1,74],\"61\":[1,46],\"62\":[null,null,1],\"63\":[null,null,1],\"64\":[2],\"65\":[1,99],\"66\":[1,109],\"67\":[null,null,2],\"68\":[null,null,1],\"69\":[2],\"70\":[1,73],\"71\":[1,88],\"72\":[1,112],\"73\":[null,null,2],\"74\":[null,null,1],\"75\":[2,4],\"76\":[1,46],\"77\":[1,108],\"78\":[1,33],\"79\":[null,null,2],\"80\":[null,null,1],\"81\":[2],\"82\":[1,70],\"83\":[1,99],\"84\":[null,null,2],\"85\":[null,null,1],\"86\":[2,8],\"87\":[1,101],\"88\":[1,90],\"89\":[null,null,2],\"90\":[null,null,1],\"91\":[2],\"92\":[1,44],\"93\":[1,58],\"94\":[null,null,2],\"95\":[null,null,1],\"96\":[2],\"97\":[1,95],\"98\":[1,76],\"99\":[1,114],\"100\":[null,null,2],\"101\":[null,null,1],\"102\":[2],\"103\":[1,105],\"104\":[1,106],\"105\":[null,null,2],\"106\":[null,null,1],\"107\":[2],\"108\":[1,87],\"109\":[1,106],\"110\":[1,109],\"111\":[null,null,2],\"112\":[null,null,1],\"113\":[2],\"114\":[1,34],\"115\":[1,68],\"116\":[null,null,2],\"117\":[null,null,1],\"118\":[2],\"119\":[1,57],\"120\":[1,84],\"121\":[1,91],\"122\":[1,94],\"123\":[null,null,2],\"124\":[null,null,1],\"125\":[2,4],\"126\":[1,100],\"127\":[1,116],\"128\":[1,151],\"129\":[1,194],\"130\":[null,null,2],\"131\":[null,null,1],\"132\":[2],\"133\":[1,63],\"134\":[1,70],\"135\":[1,70],\"136\":[null,null,2],\"137\":[null,null,1],\"138\":[2],\"139\":[1,75],\"140\":[1,94],\"141\":[1,127],\"142\":[1,96],\"143\":[null,null,2],\"144\":[null,null,1],\"145\":[2],\"146\":[1,127],\"147\":[1,92],\"148\":[null,null,2],\"149\":[null,null,1],\"150\":[2],\"151\":[1,60],\"152\":[1,86],\"153\":[null,null,2],\"154\":[null,null,1],\"155\":[2],\"156\":[1,41],\"157\":[1,124],\"158\":[null,null,2],\"159\":[null,null,1],\"160\":[2],\"161\":[1,68],\"162\":[1,119],\"163\":[null,null,2],\"164\":[null,null,1],\"165\":[2,3],\"166\":[1,67],\"167\":[1,91],\"168\":[1,88],\"169\":[null,null,2],\"170\":[null,null,1],\"171\":[2,3],\"172\":[1,52],\"173\":[1,98],\"174\":[1,156],\"175\":[null,null,2],\"176\":[null,null,1],\"177\":[2],\"178\":[1,106],\"179\":[1,83],\"180\":[1,141],\"181\":[1,49],\"182\":[1,100],\"183\":[null,null,2],\"184\":[null,null,1],\"185\":[1,2],\"186\":[1,18],\"187\":[1,39],\"188\":[3,1],\"189\":[null,null,1],\"190\":[null,null,2],\"191\":[1],\"192\":[2],\"193\":[1,52],\"194\":[1,53],\"195\":[2],\"196\":[1,82],\"197\":[1,56],\"198\":[2],\"199\":[1,38],\"200\":[1,86],\"201\":[2],\"202\":[1,40],\"203\":[1,60],\"204\":[2],\"205\":[1,34],\"206\":[1,68],\"207\":[null,null,2],\"208\":[null,null,2],\"209\":[2],\"210\":[2,7],\"211\":[2],\"212\":[3,22],\"213\":[3,25],\"214\":[3,20],\"215\":[3,74],\"216\":[2,59],\"217\":[2],\"218\":[3,21],\"219\":[3,27],\"220\":[3,21],\"221\":[2,86],\"222\":[2],\"223\":[1,183],\"224\":[1,172],\"225\":[null,null,1],\"226\":[null,null,1],\"227\":[1,14],\"228\":[1,110],\"229\":[1,90],\"230\":[1,68],\"231\":[1,7],\"232\":[null,null,2],\"233\":[null,null,1],\"234\":[1,20],\"235\":[1,129],\"236\":[1,92],\"237\":[1,103],\"238\":[1,8],\"239\":[null,null,2],\"240\":[null,null,1],\"241\":[1],\"242\":[3,14],\"243\":[2,88],\"244\":[2,19],\"245\":[2,23],\"246\":[2,21],\"247\":[6,7],\"248\":[2,25],\"249\":[2,27],\"250\":[2,20],\"251\":[5,39],\"252\":[3,31],\"253\":[5,7],\"254\":[3,44],\"255\":[2,74],\"256\":[6,36],\"257\":[2,32],\"258\":[null,null,1],\"259\":[null,null,1],\"260\":[1],\"261\":[1,138],\"262\":[1,101],\"263\":[1,109],\"264\":[null,null,1],\"265\":[null,null,1],\"266\":[1],\"267\":[1,18],\"268\":[1],\"269\":[2,24],\"270\":[4,21],\"271\":[2,22],\"272\":[1],\"273\":[2,109],\"274\":[5,127],\"275\":[null,null,2],\"276\":[null,null,1],\"277\":[1],\"278\":[2,105],\"279\":[2,126],\"280\":[1,50],\"281\":[2,61],\"282\":[2],\"283\":[2],\"284\":[null,null,1],\"285\":[null,null,2],\"286\":[1],\"287\":[1,65],\"288\":[1,71],\"289\":[1,83],\"290\":[1,107],\"291\":[1,143],\"292\":[null,null,1],\"293\":[null,null,1],\"294\":[1],\"295\":[2,4],\"296\":[3,48],\"297\":[3,45],\"298\":[3,74],\"299\":[3,53],\"300\":[2],\"301\":[3,53],\"302\":[2,73],\"303\":[5,47],\"304\":[3,79],\"305\":[3,83],\"306\":[3,64],\"307\":[2,75],\"308\":[2,60],\"309\":[2,101],\"310\":[2],\"311\":[3,74],\"312\":[3,74],\"313\":[2],\"314\":[3,76],\"315\":[null,null,2],\"316\":[1],\"317\":[2,54],\"318\":[2,58],\"319\":[2],\"320\":[3,13],\"321\":[1,30],\"322\":[1,45],\"323\":[3,36],\"324\":[2,72],\"325\":[3,25],\"326\":[2],\"327\":[3,77],\"328\":[3,106],\"329\":[3,60],\"330\":[2,72],\"331\":[2],\"332\":[3,10],\"333\":[3,15],\"334\":[3,10],\"335\":[3,13],\"336\":[2],\"337\":[3,37],\"338\":[3,138],\"339\":[3,81],\"340\":[2,25],\"341\":[2,34],\"342\":[2,27],\"343\":[null,null,1],\"344\":[1],\"345\":[2,73],\"346\":[2,7],\"347\":[1,16],\"348\":[1,23],\"349\":[2,49],\"350\":[2],\"351\":[3,34],\"352\":[4,84],\"353\":[4,76],\"354\":[7,103],\"355\":[5,88],\"356\":[4,62],\"357\":[3],\"358\":[4,31],\"359\":[2,14],\"360\":[3,106],\"361\":[4,114],\"362\":[2,80],\"363\":[2,94],\"364\":[null,null,2],\"365\":[1],\"366\":[2],\"367\":[2,26],\"368\":[3,47],\"369\":[1,34],\"370\":[3],\"371\":[5,63],\"372\":[4,53],\"373\":[5,65],\"374\":[2],\"375\":[3,27],\"376\":[2,67],\"377\":[3,27],\"378\":[2],\"379\":[3,35],\"380\":[3,60],\"381\":[2,49],\"382\":[2],\"383\":[1,64],\"384\":[2,94],\"385\":[2,83],\"386\":[2],\"387\":[3,29],\"388\":[3,86],\"389\":[5,79],\"390\":[3,73],\"391\":[3,11],\"392\":[2,81],\"393\":[2],\"394\":[3,74],\"395\":[3,17],\"396\":[3,12],\"397\":[3,11],\"398\":[3,23],\"399\":[3,22],\"400\":[null,null,2],\"401\":[1],\"402\":[2],\"403\":[2,49],\"404\":[3,35],\"405\":[2,1],\"406\":[3,20],\"407\":[3,31],\"408\":[2,2],\"409\":[3,24],\"410\":[3,38],\"411\":[2,86],\"412\":[2,41],\"413\":[2],\"414\":[3,32],\"415\":[3,26],\"416\":[3,32],\"417\":[2,90],\"418\":[2],\"419\":[3,27],\"420\":[3,23],\"421\":[3,46],\"422\":[3,144],\"423\":[2,100],\"424\":[null,null,2],\"425\":[1],\"426\":[2],\"427\":[2,54],\"428\":[3,45],\"429\":[3,62],\"430\":[3,65],\"431\":[3,64],\"432\":[null,null,2],\"433\":[1],\"434\":[2,73],\"435\":[2],\"436\":[3,37],\"437\":[2,53],\"438\":[3,97],\"439\":[5,5],\"440\":[4],\"441\":[3],\"442\":[null,null,1],\"443\":[null,null,1],\"444\":[2],\"445\":[3,29],\"446\":[3,200],\"447\":[2,25],\"448\":[3,28],\"449\":[3],\"450\":[1,12],\"451\":[1,32],\"452\":[2,4],\"453\":[3,19],\"454\":[3],\"455\":[1,12],\"456\":[1,17],\"457\":[3,29],\"458\":[2,23],\"459\":[3,18],\"460\":[3],\"461\":[1,12],\"462\":[1,19],\"463\":[3,23],\"464\":[2],\"465\":[3,71],\"466\":[3,24],\"467\":[3,42],\"468\":[3,20],\"469\":[2],\"470\":[3,45],\"471\":[3,128],\"472\":[null,null,1],\"473\":[null,null,1],\"474\":[1],\"475\":[2,26],\"476\":[2,16],\"477\":[3,21],\"478\":[4],\"479\":[5,31],\"480\":[3,4],\"481\":[3,78],\"482\":[3,46],\"483\":[2],\"484\":[3,90],\"485\":[2],\"486\":[3,7],\"487\":[2,7],\"488\":[3,9],\"489\":[3,8],\"490\":[null,null,1],\"491\":[null,null,1],\"492\":[2,2],\"493\":[2,39],\"494\":[2,2],\"495\":[2],\"496\":[3,20],\"497\":[3,14],\"498\":[2],\"499\":[3,19],\"500\":[3,38],\"501\":[2],\"502\":[2,19],\"503\":[null,null,1],\"504\":[null,null,1],\"505\":[2,4],\"506\":[2,20],\"507\":[5,20],\"508\":[8,16],\"509\":[2],\"510\":[2,85],\"511\":[2,68],\"512\":[3,81],\"513\":[3,75],\"514\":[2,8],\"515\":[3,44],\"516\":[3,21],\"517\":[2,68],\"518\":[3,8],\"519\":[3,8],\"520\":[4,12],\"521\":[2,31],\"522\":[3],\"523\":[3,107],\"524\":[3],\"525\":[4,177],\"526\":[3,201],\"527\":[null,null,1],\"528\":[null,null,1],\"529\":[2,7],\"530\":[2],\"531\":[2,47],\"532\":[3,68],\"533\":[3,69],\"534\":[4,89],\"535\":[5,41],\"536\":[5,2],\"537\":[3,42],\"538\":[2,63],\"539\":[3,90],\"540\":[3,110],\"541\":[5,14],\"542\":[4,69],\"543\":[3,72],\"544\":[4,22],\"545\":[4,20],\"546\":[3,18],\"547\":[3,14],\"548\":[4,53],\"549\":[3,76],\"550\":[4],\"551\":[4],\"552\":[null,null,1],\"553\":[null,null,1],\"554\":[2,2],\"555\":[2,18],\"556\":[2,9],\"557\":[2,52],\"558\":[2],\"559\":[3,115],\"560\":[6,26],\"561\":[null,null,1],\"562\":[null,null,1],\"563\":[2,2],\"564\":[2,10],\"565\":[3,9],\"566\":[3,84],\"567\":[3,89],\"568\":[2,190],\"569\":[null,null,1],\"570\":[null,null,1],\"571\":[2,2],\"572\":[2],\"573\":[2,14],\"574\":[3,42],\"575\":[4,194],\"576\":[3,156],\"577\":[2,12],\"578\":[3,64],\"579\":[2,25],\"580\":[3,38],\"581\":[null,null,1],\"582\":[null,null,1],\"583\":[2,5],\"584\":[2],\"585\":[2,20],\"586\":[3,38],\"587\":[2,171],\"588\":[2,41],\"589\":[2,126],\"590\":[2],\"591\":[1,59],\"592\":[1,240],\"593\":[null,null,1],\"594\":[null,null,1],\"595\":[2,2],\"596\":[1,63],\"597\":[1],\"598\":[1,18],\"599\":[1,24],\"600\":[1],\"601\":[null,null,1],\"602\":[null,null,1],\"603\":[2,2],\"604\":[1],\"605\":[1],\"606\":[1],\"607\":[3],\"608\":[2],\"609\":[1],\"610\":[1],\"611\":[null,null,1],\"612\":[null,null,1],\"613\":[1,154],\"614\":[null,null,1],\"615\":[null,null,2],\"616\":[3],\"617\":[2,9],\"618\":[2,7],\"619\":[2,6],\"620\":[2,2],\"621\":[2,8],\"622\":[2,7],\"623\":[2,4],\"624\":[2,2],\"625\":[2,4],\"626\":[2,3],\"627\":[2,2],\"628\":[2,4],\"629\":[2,3],\"630\":[1,2],\"631\":[2,3],\"632\":[2,13],\"633\":[2,3],\"634\":[2,60],\"635\":[2,5],\"636\":[2,3],\"637\":[null,null,1],\"638\":[3,4],\"639\":[2,13],\"640\":[2,4],\"641\":[2,3],\"642\":[2,2],\"643\":[2,7],\"644\":[2,3],\"645\":[2,5],\"646\":[2,5],\"647\":[2,6],\"648\":[2,4],\"649\":[2,5],\"650\":[null,null,1],\"651\":[1],\"652\":[1,4],\"653\":[2],\"654\":[null,null,1],\"655\":[1,5],\"656\":[null,null,1],\"657\":[null,null,1],\"658\":[1,19],\"659\":[null,null,1],\"660\":[null,null,1],\"661\":[1,23],\"662\":[1,49],\"663\":[1,96],\"664\":[1,88],\"665\":[1,60],\"666\":[null,null,1],\"667\":[null,null,1],\"668\":[1,54],\"669\":[2,23],\"670\":[1,104],\"671\":[1,118],\"672\":[4,147],\"673\":[2],\"674\":[2,16],\"675\":[3,24],\"676\":[3,28],\"677\":[null,null,1],\"678\":[null,null,1],\"679\":[2,2],\"680\":[1,14],\"681\":[1,18],\"682\":[1,42],\"683\":[null,null,2],\"684\":[null,null,2],\"685\":[2,2],\"686\":[1,38],\"687\":[3,65],\"688\":[2,60],\"689\":[null,null,2],\"690\":[null,null,1],\"691\":[1,2],\"692\":[1,7],\"693\":[1,7],\"694\":[1,23],\"695\":[null,null,2],\"696\":[null,null,1],\"697\":[1,2],\"698\":[1,18],\"699\":[1,28],\"700\":[1,32],\"701\":[null,null,2],\"702\":[null,null,1],\"703\":[1,2],\"704\":[1,14],\"705\":[1,40],\"706\":[null,null,2],\"707\":[null,null,1],\"708\":[1,2],\"709\":[1,10],\"710\":[1,34],\"711\":[1,8],\"712\":[1,31],\"713\":[1,30],\"714\":[null,null,2],\"715\":[null,null,2],\"716\":[1,2],\"717\":[1,17],\"718\":[1],\"719\":[1],\"720\":[null,null,2],\"721\":[null,null,3],\"722\":[1,2],\"723\":[1,20],\"724\":[2,39],\"725\":[2,41],\"726\":[null,null,2],\"727\":[null,null,1],\"728\":[1,2],\"729\":[1,16],\"730\":[3,13],\"731\":[3,21],\"732\":[null,null,2],\"733\":[null,null,3],\"734\":[1,2],\"735\":[1,6],\"736\":[2,42],\"737\":[2,42],\"738\":[null,null,2],\"739\":[null,null,3],\"740\":[1,2],\"741\":[1,7],\"742\":[1,9],\"743\":[1,38],\"744\":[null,null,2],\"745\":[null,null,2],\"746\":[1,2],\"747\":[1,7],\"748\":[4,32],\"749\":[4,35],\"750\":[null,null,2],\"751\":[null,null,3],\"752\":[1,2],\"753\":[1,16],\"754\":[1,3],\"755\":[1,30],\"756\":[null,null,2],\"757\":[null,null,2],\"758\":[1,2],\"759\":[1,11],\"760\":[1,9],\"761\":[1,26],\"762\":[null,null,2],\"763\":[null,null,2],\"764\":[1,2],\"765\":[1,9],\"766\":[1,74],\"767\":[1,62],\"768\":[null,null,2],\"769\":[null,null,3],\"770\":[1,2],\"771\":[1,9],\"772\":[1,114],\"773\":[null,null,2],\"774\":[null,null,1],\"775\":[1,2],\"776\":[1,6],\"777\":[1,55],\"778\":[1,27],\"779\":[null,null,2],\"780\":[null,null,2],\"781\":[1,2],\"782\":[1,12],\"783\":[2,55],\"784\":[2,60],\"785\":[null,null,2],\"786\":[null,null,1],\"787\":[3,2],\"788\":[1,5],\"789\":[2,84],\"790\":[2],\"791\":[null,null,2],\"792\":[null,null,2],\"793\":[1,2],\"794\":[1,21],\"795\":[2,103],\"796\":[2,72],\"797\":[1,56],\"798\":[null,null,2],\"799\":[null,null,1],\"800\":[4,4],\"801\":[1,32],\"802\":[1,54],\"803\":[1,56],\"804\":[null,null,2],\"805\":[null,null,1],\"806\":[1,2],\"807\":[1,4],\"808\":[1,21],\"809\":[1,22],\"810\":[null,null,2],\"811\":[null,null,2],\"812\":[1,2],\"813\":[1,12],\"814\":[1,8],\"815\":[1,28],\"816\":[null,null,2],\"817\":[null,null,1],\"818\":[1,2],\"819\":[1,14],\"820\":[3,66],\"821\":[3,70],\"822\":[3,59],\"823\":[null,null,2],\"824\":[null,null,3],\"825\":[1,2],\"826\":[1,11],\"827\":[2,52],\"828\":[2,38],\"829\":[null,null,2],\"830\":[null,null,1],\"831\":[1,2],\"832\":[1,7],\"833\":[1,45],\"834\":[1,34],\"835\":[null,null,2],\"836\":[null,null,1],\"837\":[1,2],\"838\":[1,22],\"839\":[1,23],\"840\":[1,46],\"841\":[null,null,2],\"842\":[null,null,1],\"843\":[1,2],\"844\":[1,9],\"845\":[2,54],\"846\":[2,85],\"847\":[null,null,2],\"848\":[null,null,2],\"849\":[1,2],\"850\":[1,26],\"851\":[1,80],\"852\":[1,104],\"853\":[null,null,2],\"854\":[null,null,1],\"855\":[1,2],\"856\":[1,11],\"857\":[3,41],\"858\":[3],\"859\":[null,null,2],\"860\":[null,null,3],\"861\":[1,2],\"862\":[1,5],\"863\":[1,6],\"864\":[1,27],\"865\":[null,null,2],\"866\":[null,null,2],\"867\":[1,2],\"868\":[1,25],\"869\":[1,49],\"870\":[1,91],\"871\":[null,null,2],\"872\":[null,null,1],\"873\":[1,2],\"874\":[1,32],\"875\":[1,71],\"876\":[1,53],\"877\":[null,null,2],\"878\":[null,null,1],\"879\":[2,3],\"880\":[1,13],\"881\":[1,28],\"882\":[1,36],\"883\":[null,null,2],\"884\":[null,null,4],\"885\":[1,2],\"886\":[1,56],\"887\":[2,75],\"888\":[4,53],\"889\":[null,null,2],\"890\":[null,null,1],\"891\":[1,2],\"892\":[1,13],\"893\":[2,72],\"894\":[2,49],\"895\":[null,null,2],\"896\":[null,null,1],\"897\":[1,2],\"898\":[1,12],\"899\":[2,80],\"900\":[2,37],\"901\":[2,42],\"902\":[null,null,2],\"903\":[null,null,2],\"904\":[2],\"905\":[2],\"906\":[2,32],\"907\":[4,5],\"908\":[4,19],\"909\":[3,27],\"910\":[3,13],\"911\":[3,15],\"912\":[3,11],\"913\":[3,19],\"914\":[4,9],\"915\":[4,28],\"916\":[2,6],\"917\":[3],\"918\":[3,18],\"919\":[3,55],\"920\":[4,156],\"921\":[2,14],\"922\":[3,39],\"923\":[3,13],\"924\":[3,15],\"925\":[5,22],\"926\":[5,37],\"927\":[4,23],\"928\":[3],\"929\":[3,31],\"930\":[3,22],\"931\":[3,52],\"932\":[2,40],\"933\":[3,39],\"934\":[3,27],\"935\":[3,65],\"936\":[2,11],\"937\":[4,52],\"938\":[3,45],\"939\":[3,17],\"940\":[2],\"941\":[3],\"942\":[3,34],\"943\":[4,14],\"944\":[3,29],\"945\":[3,31],\"946\":[3],\"947\":[4,36],\"948\":[4,8],\"949\":[4,11],\"950\":[3,8],\"951\":[4,4],\"952\":[2],\"953\":[3,24],\"954\":[3,32],\"955\":[3,41],\"956\":[2],\"957\":[3,24],\"958\":[3,161],\"959\":[3,19],\"960\":[null,null,1],\"961\":[null,null,1],\"962\":[3],\"963\":[2,9],\"964\":[null,null,1],\"965\":[null,null,1],\"966\":[4],\"967\":[2],\"968\":[null,null,1],\"969\":[null,null,1],\"970\":[1],\"971\":[1,50],\"972\":[1,18],\"973\":[1,27],\"974\":[null,null,1],\"975\":[null,null,1],\"976\":[2],\"977\":[2],\"978\":[2,57],\"979\":[3,37],\"980\":[3,38],\"981\":[3,52],\"982\":[3,67],\"983\":[2,4],\"984\":[4,102],\"985\":[2,51],\"986\":[4,52],\"987\":[2,8],\"988\":[4,69],\"989\":[5,27],\"990\":[3,82],\"991\":[3],\"992\":[4,46],\"993\":[4,34],\"994\":[3,43],\"995\":[2,7],\"996\":[3],\"997\":[3,25],\"998\":[4,25],\"999\":[4,58],\"1000\":[3,52],\"1001\":[3,37],\"1002\":[3,19],\"1003\":[2,2],\"1004\":[4,48],\"1005\":[4,101],\"1006\":[3,37],\"1007\":[4,33],\"1008\":[2,3],\"1009\":[3,6],\"1010\":[3,26],\"1011\":[4,34],\"1012\":[4,20],\"1013\":[4,16],\"1014\":[4,34],\"1015\":[3,32],\"1016\":[3],\"1017\":[4,24],\"1018\":[3,53],\"1019\":[5,5],\"1020\":[4,48],\"1021\":[4,38],\"1022\":[3,33],\"1023\":[3,34],\"1024\":[2,3],\"1025\":[3,14],\"1026\":[3,14],\"1027\":[4,43],\"1028\":[4,25],\"1029\":[4,28],\"1030\":[3,8],\"1031\":[4,11],\"1032\":[3,9],\"1033\":[4,27],\"1034\":[4,35],\"1035\":[2],\"1036\":[3,24],\"1037\":[3,18],\"1038\":[3,27],\"1039\":[3,29],\"1040\":[3,42],\"1041\":[2,2],\"1042\":[6,18],\"1043\":[3,2],\"1044\":[3,27],\"1045\":[3,86],\"1046\":[3,29],\"1047\":[3,42],\"1048\":[3,43],\"1049\":[5,54],\"1050\":[2],\"1051\":[3,28],\"1052\":[3,20],\"1053\":[4,16],\"1054\":[3,5],\"1055\":[4,69],\"1056\":[3,5],\"1057\":[2],\"1058\":[3],\"1059\":[3,55],\"1060\":[4,14],\"1061\":[3,50],\"1062\":[5,51],\"1063\":[6,59],\"1064\":[null,null,1],\"1065\":[null,null,1],\"1066\":[1,4],\"1067\":[1,28],\"1068\":[1,25],\"1069\":[1,156],\"1070\":[1,21],\"1071\":[1],\"1072\":[2,70],\"1073\":[2,43],\"1074\":[2,113],\"1075\":[1,60],\"1076\":[2,42],\"1077\":[2,33],\"1078\":[2,69],\"1079\":[1],\"1080\":[3,35],\"1081\":[3,44],\"1082\":[4,32],\"1083\":[1,28],\"1084\":[null,null,1],\"1085\":[null,null,1],\"1086\":[2,16],\"1087\":[2,85],\"1088\":[2,20],\"1089\":[2,42],\"1090\":[2,78],\"1091\":[null,null,1],\"1092\":[null,null,1],\"1093\":[2,40],\"1094\":[2,56],\"1095\":[1,143],\"1096\":[null,null,1],\"1097\":[null,null,1],\"1098\":[3],\"1099\":[1,12],\"1100\":[1,85],\"1101\":[3],\"1102\":[2,76],\"1103\":[2,95],\"1104\":[null,null,1],\"1105\":[null,null,1],\"1106\":[2],\"1107\":[1,60],\"1108\":[2],\"1109\":[2,7],\"1110\":[3,13],\"1111\":[2],\"1112\":[3,13],\"1113\":[2,14],\"1114\":[3,12],\"1115\":[3,7],\"1116\":[3,22],\"1117\":[3,28],\"1118\":[2],\"1119\":[3,37],\"1120\":[3,27],\"1121\":[2,6],\"1122\":[3,17],\"1123\":[3,15],\"1124\":[3,12],\"1125\":[2,12],\"1126\":[null,null,1],\"1127\":[null,null,1],\"1128\":[2],\"1129\":[3,71],\"1130\":[9],\"1131\":[3,90],\"1132\":[2,55],\"1133\":[2,60],\"1134\":[2,9],\"1135\":[4,13],\"1136\":[4,12],\"1137\":[4,29],\"1138\":[3,12],\"1139\":[4,14],\"1140\":[4,45],\"1141\":[3,30],\"1142\":[null,null,1],\"1143\":[null,null,1],\"1144\":[5,7],\"1145\":[2,67],\"1146\":[2,14],\"1147\":[6,43],\"1148\":[6,10],\"1149\":[2,103],\"1150\":[5,67],\"1151\":[4,47],\"1152\":[2,2],\"1153\":[4,30],\"1154\":[3,23],\"1155\":[3,13],\"1156\":[5],\"1157\":[7,43],\"1158\":[4,115],\"1159\":[3],\"1160\":[4,57],\"1161\":[3],\"1162\":[4,14],\"1163\":[3,12],\"1164\":[4,32],\"1165\":[4,33],\"1166\":[3],\"1167\":[4,6],\"1168\":[4,3],\"1169\":[3],\"1170\":[2,18],\"1171\":[2,20],\"1172\":[2,4],\"1173\":[null,null,1],\"1174\":[null,null,1],\"1175\":[7,68],\"1176\":[2],\"1177\":[2,29],\"1178\":[3,45],\"1179\":[3,12],\"1180\":[3,10],\"1181\":[3],\"1182\":[3,51],\"1183\":[4],\"1184\":[3,119],\"1185\":[2,28],\"1186\":[1,22],\"1187\":[null,null,1],\"1188\":[null,null,1],\"1189\":[4,9],\"1190\":[1,53],\"1191\":[1,89],\"1192\":[1,14],\"1193\":[1,16],\"1194\":[1,48],\"1195\":[1,7],\"1196\":[3,14],\"1197\":[null,null,1],\"1198\":[null,null,1],\"1199\":[2],\"1200\":[2,12],\"1201\":[2,119],\"1202\":[5,12],\"1203\":[5,15],\"1204\":[3,50],\"1205\":[4,19],\"1206\":[3,17],\"1207\":[3,52],\"1208\":[4],\"1209\":[5,14],\"1210\":[3,45],\"1211\":[3,72],\"1212\":[null,null,1],\"1213\":[null,null,1],\"1214\":[6],\"1215\":[null,null,1],\"1216\":[null,null,1],\"1217\":[1],\"1218\":[2,86],\"1219\":[2,5],\"1220\":[3,47],\"1221\":[2,120],\"1222\":[2],\"1223\":[3,23],\"1224\":[3,14],\"1225\":[2,9],\"1226\":[3,6],\"1227\":[3],\"1228\":[null,null,1],\"1229\":[null,null,1],\"1230\":[2],\"1231\":[2,26],\"1232\":[2,105],\"1233\":[2,95],\"1234\":[null,null,1],\"1235\":[null,null,1],\"1236\":[2],\"1237\":[2,62],\"1238\":[2],\"1239\":[3,156],\"1240\":[2,47],\"1241\":[2],\"1242\":[3,153],\"1243\":[3,72],\"1244\":[2,47],\"1245\":[null,null,1],\"1246\":[null,null,1],\"1247\":[7],\"1248\":[3,81],\"1249\":[3],\"1250\":[3,143],\"1251\":[3,221],\"1252\":[5,147],\"1253\":[6,47],\"1254\":[2,67],\"1255\":[null,null,1],\"1256\":[null,null,1],\"1257\":[2],\"1258\":[3,45],\"1259\":[2,122],\"1260\":[2,46],\"1261\":[null,null,1],\"1262\":[null,null,1],\"1263\":[2],\"1264\":[3,108],\"1265\":[3,4],\"1266\":[3,113],\"1267\":[2,110],\"1268\":[4,48],\"1269\":[2,3],\"1270\":[3,132],\"1271\":[4,99],\"1272\":[3,371],\"1273\":[4,76],\"1274\":[4,244],\"1275\":[5,208],\"1276\":[2,86],\"1277\":[null,null,1],\"1278\":[null,null,1],\"1279\":[2],\"1280\":[3,36],\"1281\":[2,50],\"1282\":[6,48],\"1283\":[3,370],\"1284\":[3,287],\"1285\":[5,87],\"1286\":[3,77],\"1287\":[null,null,1],\"1288\":[null,null,1],\"1289\":[2],\"1290\":[3,77],\"1291\":[3,40],\"1292\":[3,32],\"1293\":[4,38],\"1294\":[4,60],\"1295\":[2,135],\"1296\":[null,null,1],\"1297\":[null,null,1],\"1298\":[2],\"1299\":[3,42],\"1300\":[3,7],\"1301\":[4,104],\"1302\":[3,88],\"1303\":[4,32],\"1304\":[3,17],\"1305\":[4,124],\"1306\":[4,364],\"1307\":[3,70],\"1308\":[4,45],\"1309\":[3,117],\"1310\":[null,null,1],\"1311\":[null,null,1],\"1312\":[3],\"1313\":[3,104],\"1314\":[3,101],\"1315\":[3,166],\"1316\":[2,240],\"1317\":[3,313],\"1318\":[4,49],\"1319\":[5,44],\"1320\":[3,21],\"1321\":[null,null,1],\"1322\":[null,null,1],\"1323\":[2],\"1324\":[3,48],\"1325\":[2,73],\"1326\":[3,181],\"1327\":[null,null,1],\"1328\":[null,null,1],\"1329\":[1,20],\"1330\":[2,119],\"1331\":[2,32],\"1332\":[2,14],\"1333\":[2,9],\"1334\":[2,70],\"1335\":[2],\"1336\":[3,87],\"1337\":[3,113],\"1338\":[3,44],\"1339\":[3,65],\"1340\":[3,106],\"1341\":[null,null,1],\"1342\":[null,null,1],\"1343\":[5],\"1344\":[3,23],\"1345\":[3,22],\"1346\":[4,82],\"1347\":[3,60],\"1348\":[4,73],\"1349\":[3,11],\"1350\":[4,81],\"1351\":[4,111],\"1352\":[3,46],\"1353\":[5,24],\"1354\":[null,null,1],\"1355\":[null,null,1],\"1356\":[3],\"1357\":[2,19],\"1358\":[2,21],\"1359\":[2,223],\"1360\":[2,32],\"1361\":[3,69],\"1362\":[null,null,1],\"1363\":[null,null,1],\"1364\":[2],\"1365\":[3,42],\"1366\":[2,34],\"1367\":[3,48],\"1368\":[3,94],\"1369\":[2,58],\"1370\":[3,113],\"1371\":[2,80],\"1372\":[null,null,1],\"1373\":[null,null,1],\"1374\":[2],\"1375\":[3,96],\"1376\":[3,33],\"1377\":[null,null,1],\"1378\":[null,null,1],\"1379\":[2],\"1380\":[2,31],\"1381\":[3,7],\"1382\":[5,22],\"1383\":[2,43],\"1384\":[5,52],\"1385\":[2,138],\"1386\":[2,65],\"1387\":[2,69],\"1388\":[2,75],\"1389\":[null,null,1],\"1390\":[null,null,1],\"1391\":[3],\"1392\":[3,190],\"1393\":[3,153],\"1394\":[5,45],\"1395\":[null,null,1],\"1396\":[null,null,1],\"1397\":[3],\"1398\":[3,166],\"1399\":[3,99],\"1400\":[null,null,1],\"1401\":[null,null,1],\"1402\":[2,39],\"1403\":[4],\"1404\":[2,68],\"1405\":[5],\"1406\":[4,126],\"1407\":[5,162],\"1408\":[6,73],\"1409\":[6,101],\"1410\":[10,161],\"1411\":[5,137],\"1412\":[null,null,1],\"1413\":[null,null,1],\"1414\":[4],\"1415\":[3,23],\"1416\":[2,48],\"1417\":[3,47],\"1418\":[2,107],\"1419\":[4,12],\"1420\":[5,95],\"1421\":[3,71],\"1422\":[2,13],\"1423\":[4,75],\"1424\":[7,13],\"1425\":[3,19],\"1426\":[null,null,1],\"1427\":[null,null,1],\"1428\":[2],\"1429\":[3,83],\"1430\":[3,21],\"1431\":[5,87],\"1432\":[6,64],\"1433\":[3,60],\"1434\":[2,41],\"1435\":[4],\"1436\":[5,22],\"1437\":[5,55],\"1438\":[4,19],\"1439\":[5,61],\"1440\":[4,41],\"1441\":[2,7],\"1442\":[3,24],\"1443\":[3,28],\"1444\":[2,21],\"1445\":[3],\"1446\":[4,19],\"1447\":[4,27],\"1448\":[3],\"1449\":[2,68],\"1450\":[null,null,1],\"1451\":[null,null,1],\"1452\":[2],\"1453\":[3,30],\"1454\":[3,60],\"1455\":[6,87],\"1456\":[3,49],\"1457\":[3,52],\"1458\":[2,51],\"1459\":[null,null,1],\"1460\":[null,null,1],\"1461\":[3],\"1462\":[3,10],\"1463\":[3],\"1464\":[3,5],\"1465\":[4,23],\"1466\":[4,13],\"1467\":[6,67],\"1468\":[2],\"1469\":[4,35],\"1470\":[3,14],\"1471\":[3,20],\"1472\":[3,50],\"1473\":[5,16],\"1474\":[4],\"1475\":[4,127],\"1476\":[5,95],\"1477\":[3,33],\"1478\":[6,57],\"1479\":[null,null,1],\"1480\":[null,null,1],\"1481\":[4],\"1482\":[2,187],\"1483\":[2],\"1484\":[3,11],\"1485\":[2,64],\"1486\":[2,19],\"1487\":[2,6],\"1488\":[null,null,1],\"1489\":[null,null,1],\"1490\":[4],\"1491\":[3,27],\"1492\":[3,40],\"1493\":[5,52],\"1494\":[3,40],\"1495\":[4,88],\"1496\":[2,232],\"1497\":[null,null,1],\"1498\":[null,null,1],\"1499\":[2],\"1500\":[3,55],\"1501\":[2,71],\"1502\":[2],\"1503\":[5,35],\"1504\":[4,148],\"1505\":[5,142],\"1506\":[5,138],\"1507\":[4,69],\"1508\":[5,119],\"1509\":[2],\"1510\":[5,61],\"1511\":[5,109],\"1512\":[7,4],\"1513\":[null,null,1],\"1514\":[null,null,1],\"1515\":[1,3],\"1516\":[2],\"1517\":[2],\"1518\":[1],\"1519\":[1],\"1520\":[1],\"1521\":[2],\"1522\":[1],\"1523\":[1],\"1524\":[2],\"1525\":[2],\"1526\":[1],\"1527\":[1],\"1528\":[2],\"1529\":[1],\"1530\":[1],\"1531\":[1],\"1532\":[1],\"1533\":[2],\"1534\":[1],\"1535\":[1],\"1536\":[2],\"1537\":[1],\"1538\":[1],\"1539\":[2],\"1540\":[1],\"1541\":[1],\"1542\":[1],\"1543\":[2],\"1544\":[2],\"1545\":[1],\"1546\":[2]},\"averageFieldLength\":[2.346125794239482,48.71991244705129,0.7734672510393938],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"个人介绍和档案放置在此。\"]},\"1\":{\"h\":\"架构设计\",\"t\":[\"此处存放一些关于 Java 架构以及系统架构方面的笔记知识点。\"]},\"2\":{\"h\":\"算法笔记\",\"t\":[\"此处存放刷题时的思路和笔记，包括算法题、笔试题和面试题等。\"]},\"3\":{\"h\":\"模板\",\"t\":[\"基础算法\",\"数据结构\",\"搜索与图论\",\"数学知识\",\"动态规划\",\"贪心\"]},\"4\":{\"h\":\"笔记\",\"t\":[\"并查集\",\"递归相关题型\",\"前缀和相关题型\",\"搜索\",\"一些经验和技巧\"]},\"5\":{\"h\":\"剑指 offer\"},\"6\":{\"h\":\"LeetCode\",\"t\":[\"热题 100\"]},\"7\":{\"h\":\"计算机\",\"t\":[\"此处存放一些计算机大类的笔记，包括编程语言、计算机网络、操作系统、数据库、Linux、Git、Docker等等。\"]},\"8\":{\"h\":\"目录\"},\"9\":{\"h\":\"编程语言\"},\"10\":{\"h\":\"计算机网络\"},\"11\":{\"h\":\"数据库\"},\"12\":{\"h\":\"操作系统\"},\"13\":{\"h\":\"设计模式\"},\"14\":{\"h\":\"中间件\",\"t\":[\"中间件（英语：Middleware）：是一种在系统软件和用户应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件在客户服务器的操作系统、网络和数据库之上，管理计算资源和网络通信。总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。\",\"也就是说，关于中间件，可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。中间件是一类软件统称，而非一种软件；中间件不仅仅实现互连，还要实现应用之间的互操作。\",\"中间件与操作系统和数据库共同构成基础软件三大支柱，是一种应用于分布式系统的基础软件，位于应用与操作系统、数据库之间，为上层应用软件提供开发、运行和集成的平台。中间件解决了异构网络环境下软件互联和互操作等共性问题，并提供标准接口、协议，为应用软件间共享资源提供了可复用的“标准件”。\",\"常见中间件主要分为：Web中间件、数据库中间件、消息中间件、安全中间件、事务中间件、应用程序服务器中间件、分布式计算中间件等。\"]},\"15\":{\"h\":\"Git\"},\"16\":{\"h\":\"Docker\"},\"17\":{\"h\":\"常用框架\",\"t\":[\"此处存放前后端常用框架的笔记。\"]},\"18\":{\"h\":\"开源项目\",\"t\":[\"此处存放自己写和一些优秀的开源项目，帮助学习。\"]},\"19\":{\"h\":\"程序人生\",\"t\":[\"此处存放一些程序员相关的资源文件，包括但不限于书籍、文章、资料等等。\"]},\"20\":{\"h\":\"B站评论系统架构设计\",\"t\":[\"转载自哔哩哔哩技术，原文链接：B站评论系统架构设计\"]},\"21\":{\"h\":\"01 背景\",\"t\":[\"维基百科对「评论」的定义是：评论是人们对出版物、服务或公司的评估，例如电影（电影评论）、电子游戏（视频游戏评论）、音乐制作（对作品录音作品的音乐评论）、图书（书评）、硬件，如汽车、家用电器或电子计算机、商业软件、活动或表演，例如音乐会、戏剧、音乐剧、舞蹈或艺术展览。除了批判性评论之外，评论的作者还可以对作品进行内容分级以表明其相对价值。\",\"在B站，UP主每天都会发布海量的视频、动态、专栏等内容，随之而来的是弹幕和评论区的各种讨论。播放器中直接滚动播放的弹幕，如同调味剂，重在提升视频观看体验；而点进评论区，相对而言评论文本更长，内容的观点、形式都更丰富，更像是饭后甜点。\",\"随着业务不断发展，B站的评论系统逐渐组件化、平台化；通过持续演进架构设计，管理不断上升的系统复杂度，从而更好地满足各类用户的需求。\"]},\"22\":{\"h\":\"02 基础功能模块\",\"t\":[\"评论的基础功能模块是相对稳定的。\",\"1. 发布评论：支持无限盖楼回复。\",\"2. 读取评论：按照时间、热度排序；显示评论数、楼中楼等。\",\"3. 删除评论：用户删除、UP主删除等。\",\"4. 评论互动：点赞、点踩、举报等。\",\"5. 管理评论：置顶、精选、后台运营管理（搜索、删除、审核等）。\",\"结合B站以及其他互联网平台的评论产品特点，评论一般还包括一些更高阶的基础功能：\",\"1. 评论富文本展示：例如表情、@、分享链接、广告等。\",\"2. 评论标签：例如UP主点赞、UP主回复、好友点赞等。\",\"3. 评论装扮：一般用于凸显发评人的身份等。\",\"4. 热评管理：结合AI和人工，为用户营造更好的评论区氛围。\"]},\"23\":{\"h\":\"03 架构设计\",\"t\":[\"评论是主体内容的外延。因此一般会作为一个独立系统拆分设计。\"]},\"24\":{\"h\":\"3.1 架构设计 - 概览\"},\"25\":{\"h\":\"3.2 架构设计 - reply-interface\",\"t\":[\"reply-interface 是评论系统的接入层，主要服务于两种调用者：一是客户端的评论组件，二是基于评论系统做二次开发或存在业务关联的其他业务后端。\",\"面向移动端/WEB场景，设计一套基于视图模型的API，利用客户端提供的布局能力，BFF层负责组织业务数据模型，并转换为视图模型，编排后下发给客户端。\",\"面向服务端场景，设计的API需要体现清晰的系统边界，最小可用原则对外提供数据，同时做好安全校验和流量控制。\",\"对评论业务来说，业务数据模型是最为复杂的。B站评论系统历史悠久，承载的功能模块相当之多，其中最核心的是发布类接口以及列表类接口，一写一读，数据字段多、依赖服务多、调用关系复杂，特别是一些依赖的变更，容易造成整个系统的腐化。\",\"因此，我们将整个业务数据模型组装，分为两个步骤，一是服务编排，二是数据组装。服务编排拆分为若干个层级，同一层级的可以并发调用，前置依赖较多的可以流水线调用，结构性提升了复杂调用场景下的接口性能下限；针对不同依赖服务所提供的 SLA 不同，设置不同的降级处理、超时控制和服务限流方案，保证少数弱依赖抖动甚至完全不可用情况下评论服务可用。数据组装在服务编排之后执行，例如在批量查询评论发布人的粉丝勋章数据之后，将其转换、组装到各个评论卡片之中。\"]},\"26\":{\"h\":\"3.3 架构设计 - reply-admin\",\"t\":[\"评论管理服务层，为多个内部管理后台提供服务。运营人员的数据查询具有：\",\"1. 组合、关联查询条件复杂；\",\"2. 刚需关键词检索能力；\",\"3. 写后读的可靠性与实时性要求高等特征。\",\"此类查询需求，ES 几乎是不二选择。但是由于业务数据量较大，需要为多个不同的查询场景建立多种索引分片，且数据更新实时性不高。因此，我们基于 ES 做了一层封装，提供统一化的数据检索能力，并结合在线数据库刷新部分实时性要求较高的字段。\"]},\"27\":{\"h\":\"3.4 架构设计 - reply-service\",\"t\":[\"评论基础服务层，专注于评论功能的原子化实现，例如查询评论列表、删除评论等。一般来说，这一层是较少做业务逻辑变更的，但是需要提供极高的可用性与性能吞吐。因此，reply-service 集成了多级缓存、布隆过滤器、热点探测等性能优化手段。\"]},\"28\":{\"h\":\"3.5 架构设计 - reply-job\",\"t\":[\"评论异步处理层，主要有两个职责：\",\"1. 与 reply-service 协同，为评论基础功能的原子化实现，做架构上的补充。\",\"为什么基础功能的原子化实现需要架构的补充呢？最典型的案例就是缓存的更新。一般采用 Cache Aside 模式，先读缓存，再读DB；缓存的重建，就是读请求未命中缓存穿透到DB，从DB读取到内容之后反写缓存。这一套流程对外提供了一个原子化的数据读取功能。但由于部分缓存数据项的重建代价较高，比如评论列表（由于列表是分页的，重建时会启用预加载），如果短时间内多个服务节点的大量请求缓存未命中，容易造成DB抖动。解决方案是利用消息队列，实现「单个评论列表，只重建一次缓存」。归纳而言，所谓架构上的补充，即是「用单线程解决分布式无状态服务的共性问题」。另一方面，reply-job 还作为数据库 binlog 的消费者，执行缓存的更新操作。\",\"2. 与 reply-interface 协同，为一些长耗时/高吞吐的调用做异步化/削峰处理。\",\"诸如评论发布等操作，基于安全/策略考量，会有非常重的前置调用逻辑。对于用户来说，这个长耗时几乎是不可接受的。同时，时事热点容易造成发评论的瞬间峰值流量。因此，reply-interface 在处理完一些必要校验逻辑之后，会通过消息队列送至 reply-job 异步处理，包括送审、写DB、发通知等。同时，这里也利用了消息队列的「有序」特性，将单个评论区内的发评串行处理，避免了并行处理导致的一些数据错乱风险。那么异步处理后用户体验是如何保证的呢？首先是C端的发评接口会返回展示新评论所需的数据内容，客户端据此展示新评论，完成一次用户交互。若用户重新刷新页面，因为发评的异步处理端到端延迟基本在2s以内，此时所有数据已准备好，不会影响用户体验。\",\"一个有趣的问题是，早年间评论显示楼层号，楼层号实际是计数器，且在一个评论区范围内不能出现重复。因此，这个楼层发号操作必须是在一个评论区范围内串行的（或者用更复杂的锁实现），否则两条同时发布的评论，获取的楼层号就是重复的。而分布式部署+负载均衡的网关，处理发评论请求是无法实现这种串行的，因此需要放到消息队列中处理。\"]},\"29\":{\"h\":\"04 存储设计\"},\"30\":{\"h\":\"4.1 数据库设计\",\"t\":[\"结合评论的产品功能要求，评论需要至少两张表：首先是评论表，主键是评论 id，关键索引是评论区 id；其次是评论区表，主键是评论区 id，平台化之后增加一个评论区 type 字段，与评论区 id 组成一个“联合主键”。\",\"由于评论内容是大字段，且相对独立、很少修改，因此独立设计第3张表。主键也是评论 id。\",\"评论表和评论区表的字段主要包括4种：\",\"1. 关系类，包括发布人、父评论等，这些关系型数据是发布时已经确定的，基本不会修改。\",\"2. 计数类，包括总评论数、根评论数、子评论数等，一般会在有评论发布或者删除时修改。\",\"3. 状态类，包括评论/评论区状态、评论/评论区属性等，评论/评论区状态是一个枚举值，描述的是正常、审核、删除等可见性状态；评论/评论区属性是一个整型的 bitmap，可用于描述评论/评论区的一些关键属性，例如UP主点赞等。\",\"4. 其他，包括 meta 等，可用于存储一些关键的附属信息。\",\"评论回复的树形关系，如下图所示：\",\"以评论列表的访问为例，我们的查询SQL可能是（已简化）：\",\"1. 查询评论区基础信息：\",\"SELECT * FROM subject WHERE obj_id=? AND obj_type=?\",\"2. 查询时间序一级评论列表：\",\"SELECT id FROM reply_index WHERE obj_id=? AND obj_type=? AND root=0 AND state=0 ORDER BY floor=? LIMIT 0,20\",\"3. 批量查询根评论基础信息：\",\"SELECT * FROM reply_index,reply_content WHERE rpid in (?,?,...)\",\"4. 并发查询楼中楼评论列表：\",\"SELECT id FROM reply_index WHERE obj_id=? AND obj_type=? AND root=? ORDER BY like_count LIMIT 0,3\",\"5. 批量查询楼中楼评论基础信息：\",\"SELECT * FROM reply_index,reply_content WHERE rpid in (?,?,...)\",\"产品形态上，单个页面只有二级列表（更多嵌套层次，对应嵌套多次点击），且评论计数也只有两级。若回复数也要无限套娃，则一条子评论的发布，需要级联更新所有的父评论的回复数，当前的数据库设计不能满足该需求。\",\"再者，产品侧定义是，若一级评论被删除，其回复也等价于全部删除，若直接删除，此时也可能出现写放大。因此结合查询逻辑，可以不对回复做更新操作，但是评论区的计数更新操作，需要多减去该一级评论的回复数。\",\"评论系统对数据库的选型要求，有两个基本且重要的特征：\",\"1. 必须有事务；\",\"2. 必须容量大。\",\"一开始，我们采用的是MySQL分表来满足这两个需求。但随着B站社区破圈起量，原来的MySQL分表架构很快到达存储瓶颈。于是从2020年起，我们逐步迁移到TiDB，从而具备了水平扩容能力。\"]},\"31\":{\"h\":\"4.2 缓存设计\",\"t\":[\"我们基于数据库设计进行缓存设计，选用 redis 作为主力缓存。主要有3项缓存：\",\"1. subject，对应于「查询评论区基础信息」，redis string 类型，value 使用JSON序列化方式存入。\",\"2. reply_index，对应于「查询xxx评论列表」，redis sorted set 类型。member 是评论 id，score 对应于 ORDER BY 的字段，如 floor、like_count 等。\",\"3. reply_content，对应于「查询xxx评论基础信息」，存储内容包括同一个评论 id 对应的 reply_index 表和 reply_content 表的两部分字段。\",\"reply_index 是一个 sorted set，为了保证数据完整性，必须要判定 key 存在才能增量追加。由于存在性判定和增量追加不是原子化的，判定存在后、增量追加前可能出现缓存过期，因此选用 redis 的 EXPIRE 命令来执行存在性判定，避免此类极端情况导致的数据缺失。此外，缓存的一致性依赖 binlog 刷新，主要有几个关键细节：\",\"1. binlog 投递到消息队列，分片 key 选择的是评论区，保证单个评论区和单个评论的更新操作是串行的，消费者顺序执行，保证对同一个 member 的 zadd 和 zrem 操作不会顺序错乱。\",\"2. 数据库更新后，程序主动写缓存和 binlog 刷缓存，都采用删除缓存而非直接更新的方式，避免并发写操作时，特别是诸如 binlog 延迟、网络抖动等异常场景下的数据错乱。那大量写操作后读操作缓存命中率低的问题如何解决呢？此时可以利用 singleflight 进行控制，防止缓存击穿。\"]},\"32\":{\"h\":\"05 可用性设计\"},\"33\":{\"h\":\"5.1 写热点与读热点\",\"t\":[\"2020年的腾讯的辣椒酱不香了[1]，引发一场评论区的狂欢。由于上文所述各类「评论区维度的串行」，当时评论发布的吞吐较低，面对如此大的流量出现了严重延迟。\",\"痛定思痛，我们剖析瓶颈并做了如下优化：\",\"1. 评论区评论计数的更新，先做内存合并再更新，可以减少热点场景下的SQL执行条数；评论表的插入，改成批量写入。\",\"2. 非数据库写操作的其他业务逻辑，拆分为前置和后置两部分，从数据写入主线程中剥离，交由其他的线程池并发执行。\",\"改造后，系统的并发处理能力有了极大提升，同时支持配置并行度/聚合粒度，在吞吐方面具备更大的弹性，热点评论区发评论的TPS提升了10倍以上。\",\"除了写热点，评论的读热点也有一些典型的特征：\",\"1. 由于大量接口都需要读取评论区基础信息，存在读放大，因此该操作是最先感知到读热点存在的。\",\"2. 由于评论业务的下游依赖较多，且多是批量查询，对下游来说也是读放大。此外，很多依赖是体量相对小的业务单元，数据稀疏，难以承载评论的大流量。\",\"3. 评论的读热点集中在评论列表的第一页，以及热评的热评。\",\"4. 评论列表的业务数据模型也包含部分个性化信息。\",\"因此，我们利用 《直播场景下 高并发的热点处理实践》[5] 一文所使用的SDK，在读取评论区基础信息阶段探测热点，并将热点标识传递至BFF层；BFF层实现了页面请求级的热点本地缓存，感知到热点后即读取本地缓存，然后再加载个性化信息。\",\"热点探测的实现基于单机的滑动窗口+LFU，那么如何定义、计算相应的热点条件阈值呢？\",\"首先，我们进行系统容量设计，列出容量计算的数学公式，主要包括各接口QPS的关系、服务集群总QPS与节点数的关系、接口QPS与CPU/网络吞吐的关系等；然后，收集系统内部以及相应依赖方的一些的热点相关统计信息，通过前面列出的公式，计算出探测数据项的单机QPS热点阈值。最后通过热点压测，来验证相应的热点配置与代码实现是符合预期的。\"]},\"34\":{\"h\":\"5.2 冗余与降级\",\"t\":[\"上文提到，评论基础服务层集成了多级缓存，在上一级缓存未命中或者出现网络错误后，可以视具体场景要求降级至下一级缓存。各级缓存可能有功能上的略微差异，但都能保障用户的基础体验。\",\"此外，评论系统是一个同城读双活的架构。数据库与缓存均是双机房独立部署的，均支持多副本，具备水平扩容的弹性。针对双机房架构下特有的副机房数据延迟故障，支持入口层切流/跨机房重试/应用层补偿，尽可能保证极端情况下用户无感。\",\"在功能层面，我们做了重要级别划分，把相应的依赖划分为强依赖（如审核）、弱依赖（如粉丝勋章）。对于弱依赖，我们一方面在异常情况下坚决限流熔断，另一方面也通过超时控制、请求预过滤、优化调用编排甚至技术方案重构等方式持续优化提升非核心功能的可用性，为业务在评论区获得更好的曝光展现。\"]},\"35\":{\"h\":\"06 安全性设计\",\"t\":[\"评论系统的安全性设计可以分为「数据安全」与「舆论安全」。\"]},\"36\":{\"h\":\"6.1 数据安全\",\"t\":[\"除了数据安全法所要求的以外，评论系统的数据安全还包括「合规性要求」。评论数据合规，一方面是审核和风控，另一方面对工程侧的要求主要是「状态一致性」。例如，有害评论被删除后，在客户端不能展现，也不能通过API等对外暴露。这就对数据一致性，包括缓存，提出了较高要求。在设计层面主要有两方面实践：\",\"1. 数据读写阶段均考虑了一致性风险，严格保证时序性。\",\"2. 对各类数据写操作，定义了优先级，避免高优先级操作被低优先级操作覆盖，例如审核删除的有害评论，不能被其他普通运营人员/自动化策略放出。\",\"3. 通过冗余校验，避免风险数据外泄。例如评论列表的露出，读取 sorted set 中的 id 列表后，还需要校验对应评论的状态，是可见态才允许下发。\"]},\"37\":{\"h\":\"6.2 舆论安全\",\"t\":[\"舆论安全问题更为泛化。接口错误导致用户操作失败、关闭评论区、评论计数不准，甚至新功能上线、用户不满意的评论被顶到热评前排等问题均可能引发舆情问题。\",\"1. 不对用户暴露用户无法处理和不值得处理的错误。 例如评论点赞点踩、某个数据项读取失败这一类的轻量级操作，不值得用户重试，此时告知用户操作失败也没有意义。系统可以考虑自行重试，甚至直接忽略。\",\"2. 优化产品功能及其技术实现，例如评论计数、热评排序等。\",\"计数不一致的根源，是数据冗余造成的。 一般出于性能考虑，会在评论列表以外，给这个列表记录一个长度。也就是用 SELECT count FROM subject，代替 SELECT count(*) FROM reply_index。基于这种冗余设计，count 字段大部分都是增量更新，即+1、-1，是容易出现误差累积的。\",\"1. 并发事务导致的「写倾斜（write skew）」，例如依据评论的状态来做评论区的计数更新。在A事务中读取的评论状态，可能在B事务中被修改，此时A事务计数更新的前提被破坏，也就造成了错误的增量更新。此时计数可能偏大或偏小。\",\"2. 运行时异常、脏数据或者非常规的展示侧控制，导致部分数据被过滤。此时计数可能偏大。\",\"3. 计数冗余同步至其他系统，例如视频表的评论数，延迟导致了过程不一致，同步失败则直接导致最终不一致。\",\"1. 事务加锁。综合评估而言，对性能的影响较大，特别是存在“锁放大”，越需要加锁的场景，越容易出现“锁冲突”。\",\"2. 串行化。将评论区的所有操作，抽象为一个排队的 Domain Events，串行处理，不容易出错。那为什么不能按照评论维度进行拆分，更加不容易出现评论区维度的热点？因为上文提到，删除一级评论时，实际也会从计数上删除其回复；删除二级评论时，也会更新其根评论的计数。多个评论的操作相互影响，因此按照评论维度进行拆分仍然存在并发事务问题。\"]},\"38\":{\"h\":\"07 热评设计\"},\"39\":{\"h\":\"7.1 什么是热评\",\"t\":[\"早期的热评，实际就是按照评论点赞数降序。后来衍生了更为复杂的热评：既包括类似「妙评」这种用户推荐、运营精选且带 logo 突出展示的产品形态，也包括各类热评排序算法，且热评排序算法应用场景也不仅局限于评论主列表的热度序，还包括楼中楼（外露子评论）、动态外露评论等。\",\"热评排序逻辑一般包括点赞数、回复数、内容相关、负反馈数、“时间衰退因子”、字数加权、用户等级加权等等。如何在B站评论区脱颖而出？[7]一文从内容运营层面，介绍了什么样的评论更容易上热评前排。\",\"咬文嚼字来说，我们对「热」的理解，大致分为几个阶段：\",\"1. 点赞高，就代表热度高。→ 解决热评的有无问题\",\"2. 基于用户正负样本投票的，加权平均高，就代表热度高。→ 解决高赞高踩的负面热评问题\",\"3. 短时间内点赞率高，就代表热度高。→ 解决高赞永远高赞的马太效应\",\"4. 热评用户流量大，社区影响也大。要权衡社会价值观引导、公司战略导向、商业利益、UP主与用户的「情绪」等。→ 追求用户价值平衡\"]},\"40\":{\"h\":\"7.2 挑战与应对\",\"t\":[\"显然，我们在不同阶段对热评的理解，在系统设计上也提出了不同层面的要求：\",\"1. 按照点赞绝对值排序，即要实现 ORDER BY like_count 的分页排序。点赞数是一个频繁更新的值，MySQL，特别是TiDB，由于扫描行数约等于 OFFSET，因此在 OFFSET 较大时查询性能特别差，很难找到一个完美的优化方案。此外，由于 like_count 的分布可能出现同一个值堆叠多个元素，比如评论区所有的评论都没有赞，我们更多依赖 redis 的 sorted set 来执行分页查询，这就要求缓存命中率要非常高。\",\"2. 按照正负样本加权平均的，即Reddit：威尔逊排序[6]，到这个阶段，数据库已经无法实现这样复杂的 ORDER BY，热评开始几乎完全依赖 sorted set 这样的数据结构，预先计算好排序分数并写入。于是在架构设计上，新增了 feed-service 和 feed-job 来支撑热评列表的读写。\",\"3. 按照点赞率排序，需要实现点赞率的近实时计算。点赞率=点赞数/曝光数，曝光的数据来源是客户端上报的展现日志，量级非常大，可以说是一个写多读少的场景：只有重算排序的时候才会读取曝光数。\",\"4. 追求用户价值平衡，需要处理各种细分场景下的差异化需求。热评排序与 feed 排序很像，但也有一点根本性差异：feed 排序我们往往都希望是个性化的，每个人看到的都不相同，但评论往往不会如此激进，一般来说会希望大家看到的评论排序都大致相同。由于排序问题的解决方案是探索型的，因此系统设计层面需要提供更多元、更易扩展的工程化能力，包括算法和策略的快速迭代、实验能力等，并提升整个热评模块的可观测水平，监控完善、数据报表丰富、排序过程可解释等等。在架构上，新增了 strategy-service 和 strategy-job 来承担这部分策略探索型业务。\",\"此外，数据量级规模的增加，也对系统的吞吐能力提出了更高要求：不管热评的算法如何变化，一般来说，热评列表都需要能够访问到全部评论，且基本维持相同的热评排序逻辑。在评论数过百万甚至千万的评论区，热评排序的挑战点主要在于：\",\"1. 大 key 问题：例如单个 sorted set 过大，读写性能都受影响（时间复杂度的基数可以认为都是O(logN)）；全量更新时，还可能遇到 redis pipeline 的瓶颈。\",\"2. 实时性放大存储压力：多样化的数据源，对特征的导入与更新都提出了挑战，需要支持较丰富的数据结构，和尽可能高的写吞吐（想象一下曝光数作为排序特征的变态要求）；与推荐排序不同，热评排序是全排序，此时需要读取全部评论的全部特征，查询压力也会非常大。\",\"这一阶段，我们仍然在持续优化，在工程落地层面尽可能还原理想的排序算法设计，保障用户的热评浏览体验。目前形成的系统架构总体如下图所示：\",\"图示的「评论策略层」，负责建立一套热评调控体系化能力，通过召回机制来实现想要的“balance“。即先通过策略工程，召回一批应该沉底的不良评论或者应该进前排的优秀评论，然后在排序分计算阶段根据召回结果实现这样的效果。\",\"这样做的好处是，可以保留一套通用的底层排序算法，然后通过迭代细分场景下的召回策略，来实现差异化评论排序的平衡。\",\"召回策略的工程设计，按照分层设计的原则拆分为3个部分：\",\"1. 因子机。主要职责是维护策略所需的全部「因子」，包括一些已有的在线/离线数据，也包括为了策略迭代而需要新开发的流式的窗口聚合数据。因子机的重难点是需要管理各种数据获取的拓扑关系，以及通过缓存来保护下游（数据提供方很难也不应该承受热评业务的巨大流量）。所有的因子可以构成一个有向无环图，通过梳理依赖关系和推导计算，实现并发提效、减少冗余。\",\"2. 规则机。实现了一套声明式规则语法，可以直接引用因子机预定义的因子，结合各种逻辑算子构成一个规则表达式。规则机执行命中后，会向下游传递预先声明的召回决策，例如排序提权。\",\"3. 召回处理中心。这一层的职责就是接收规则机返回的各种决策并执行，需要处理不同决策的优先级PK、不同规则的决策叠加作用、决策豁免等。\",\"热评排序涉及的特征，是多数据源的，数据更新方式、更新频率、查询性能也天差万别。因此我们针对数据源的特点做了多级缓存，通过多级冗余与跨级合并，提升了特征读取的稳定性与性能上限。当然，其中的数据实时性、一致性、可用性，仍然处于一个动态权衡取舍的过程。举个例子，曝光数使用 redis 计数器维护，受限于成本并未持久化；各类静态模型分存在4到5层冗余。此外，还应用了内部稀疏数据的 bloom-filter 查询、数据局部性集中与散列相结合、近实时大窗口聚合计数等多种性能优化手段。需要指出的是，召回和排序两阶段都需要查询因子/特征，得以复用「因子机」，完成各个特征的差异化实现与维护。\",\"热评排序最关键的计算模块，首先是引入了自适应的冷却算法，根据评论区的评论数、活跃程度等，对重算排序的收益进行预估，拦截了大部分低价值重排请求。其次在全量打分排序阶段，「排序策略」贯穿上下文，既支持传统的静态的经验算分公式，也支持动态的模型打分，支撑AI模型的快速部署快速迭代。通过组合与继承，支持排序策略的叠加、微调，结合评论网关层的排序策略路由，可实现各类定制化排序，完成热评排序系统的平台化。\",\"除了大家点开评论区看到的“热评”，在楼中楼、动态外露评论、评论详情页等类似场景，我们同样应用了这套热评系统，在工程上实现了架构的统一。\"]},\"41\":{\"h\":\"7.3 愿景与规划\",\"t\":[\"评论区作为B站社区的重要组成部分，致力于为中文互联网提供一个和谐、有趣的交流环境。另一方面，B站评论区流量巨大，所具备的商业化价值也是需要持续探索的。不管是氛围还是商业，都具有非常强的头部效应。因此，热评，尤其是热评的头部，我们会持续优化产品功能，持续探索排序策略，期望能为用户带来更好的体验：用户可以在这里看到自己喜欢的评论内容，有知识、有温度，也可以看到一些多元化的观点；可以炫一下自己的装扮，也可以守护新人UP主成长；可以倾诉自己的故事，也可以发一条友善的评论，更可以来一个段子，逗乐每一个在互联网里冲浪的有缘人。\",\"参考资料：\",\"[1] https://t.bilibili.com/406920470238773354?spm_id_from=333.999.0.0\",\"[2] 维基百科：评论 (https://zh.wikipedia.org/wiki/評論)\",\"[3] 百度评论中台的设计与探索 (https://juejin.cn/post/7108973163333025805)\",\"[4] 腾讯老干妈大瓜背后，B站竟成为最大赢家 (https://36kr.com/p/783469249310599)\",\"[5] 直播场景下 高并发的热点处理实践 (https://www.bilibili.com/read/cv15278397?from=search&spm_id_from=333.337.0.0)\",\"[6] Evan Miller: How Not To Sort By Average Rating (https://www.evanmiller.org/how-not-to-sort-by-average-rating.html)\",\"[7] 如何在B站评论区脱颖而出？\",\"[8] 如何对文章下面的评论做排序（2019年版）(https://zhuanlan.zhihu.com/p/57021517)\"]},\"42\":{\"c\":[\"架构设计\"]},\"43\":{\"c\":[\"评论系统\"]},\"44\":{\"h\":\"评论系统功能和架构设计\",\"t\":[\"转载自stormspirit，原文链接：评论系统功能和架构设计\",\"本周会以 B 站的评论系统为样本，来介绍该系统的功能、架构、存储、可用性设计等。\",\"首先在设计一个评论系统之前，我们必须要对这个系统的功能以及定位有一个清晰的了解。\"]},\"45\":{\"h\":\"功能模块\",\"t\":[\"架构设计最重要的就是 「理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。」 深入到业务里面，了解业务本身的本质。成为某个业务领域的专家，对这个业务的系统有比较深的理解，才能设计出一个全面的架构。\",\"评论系统，我们往小里做就是视频评论系统，往大了做就是评论平台，可以接入各种业务形态，比如在漫画、文章等业务下也能接入一样的评论系统。再往大做可以是一个评论中台，只需要设置不同的评论策略，比方说先审后发或者先发后审，或者高于多少等级的用户才能发表评论，这样不同的业务只需要设计自己的策略接入评论系统即可。\",\"评论系统可能有的功能：\",\"发布评论: 支持回复楼层、楼中楼。\",\"读取评论: 按照时间、热度排序。\",\"删除评论: 用户删除、作者删除。\",\"管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。\",\"在前期花足够时间去反复思考设计，会减少之后大量的返工。「在动手设计前，反复思考，真正编码的时间只有5%。」\"]},\"46\":{\"h\":\"架构设计\",\"t\":[\"如上图，一共有以下模块：\",\"网关层：api gateway，可能是 nginx 、kong 等。\",\"BFF 层：comment 模块。\",\"复杂评论业务的服务编排，比如访问账号服务进行等级判定，同时需要在 BFF 面向移动端/WEB场景来设计 API，「这一层抽象把评论的本身的内容列表处理(加载、分页、排序等)进行了隔离，关注在业务平台化逻辑上」。\",\"服务层：comment-service。\",\"服务层，去平台业务的逻辑，专注在评论功能的 API 实现上，比如发布、读取、删除等，「关注在稳定性、可用性上，这样让上游可以灵活组织逻辑，从而把基础能力和业务能力剥离」。\",\"Job：comment-job。\",\"消息队列的最大用途是**「削峰处理」**。\",\"Admin: comment-admin。\",\"管理平台，「按照安全等级划分服务」，尤其划分运营平台，他们会共享服务层的存储层(MySQL、Redis)。运营体系的数据大量都是检索，我们使用 canal 订阅 MySQL 的 binlog 进行同步到 ES 中，整个数据的展示都是通过 ES，再通过业务主键更新业务数据层，这样运营端的查询压力就下方给了独立的 fulltext search 系统。\",\"Dependency: account-service、filter-service。\",\"整个评论服务还会依赖一些外部 gRPC 服务，统一的平台业务逻辑在 comment BFF 层收敛，这里 account-service 主要是账号服务，filter-service 是敏感词过滤服务。\",\"架构设计等同于数据设计，梳理清楚数据的走向和逻辑。尽量避免**「环形依赖」**、数据双向请求等（比如两个服务互相调用）。\"]},\"47\":{\"h\":\"comment-service\",\"t\":[\"comment-service，专注在评论数据处理（Separation of Concerns）。\",\"注意\",\"我们一开始是 comment-service 和 comment 是一层，业务耦合和功能耦合在一起，非常不利于迭代，当然在设计层面可以考虑目录结构进行拆分，但是架构层次来说，迭代隔离也是好的。\"]},\"48\":{\"h\":\"读的核心逻辑\",\"t\":[\"Cache-Aside 模式，先读取缓存，再读取存储。\",\"早期 cache rebuild 是做到服务里的，对于重建逻辑，一般会使用 read ahead 的思路，即 「预读」，用户访问了第一页，很有可能访问第二页，所以缓存会超前加载，避免频繁 cache miss。当缓存抖动时候，特别容易引起集群 thundering herd 现象（惊群问题）。大量的请求会在 「comment 服务内部」 触发 cache rebuild，容易导致服务 OOM。\",\"所以在回源的逻辑里，我们使用了消息队列来进行逻辑异步化。发生缓存 miss 时，服务去 db 把数据拿出来返回，然后发送一条消息给 kafka，说明哪个 topic 或者 key cache miss 了，之后再在 comment-job 里消费消息，从 db 里拿出对应的数据再更新到缓存里。\"]},\"49\":{\"h\":\"写的核心逻辑\",\"t\":[\"写可以认为是 「透穿到存储层」 的，系统的瓶颈往往就来自于存储层，或者有状态层。\",\"对于写的设计上，把对存储的直接冲击 「下放到消息队列」，按照消息反压的思路，即如果存储 mysql 延迟升高，消费能力就下降，然后消息堆积，系统始终以最大化方式消费。意思就是把消息都暂存在 kafka 中，而不会一下发到 mysql ，这就是做一个削峰的处理。\",\"Kafka 是存在 partition 概念的，可以认为是物理上的一个小队列，一个 topic 是由一组 partition 组成的，所以 Kafka 的吞吐模型理解为: 「全局并行，局部串行的生产消费方式」。对于入队的消息，可以按照 hash(comment_subject) % N(partitions) 的方式进行分发。即某个评论主题的数据都在一个分区里，这样方便我们串行消费，顺序不会乱。\",\"处理之前的回源消息也是类似的思路。\"]},\"50\":{\"h\":\"comment-admin\",\"t\":[\"mysql binlog 中的数据被 canal 中间件流式消费，获取到业务的原始 CRUD 操作，需要回放录入到 es 中，但是 es 中的数据最终是面向运营体系提供服务能力，需要检索的数据维度比较多，在入 es 前需要做一个异构的 joiner，把单表变宽预处理好 join 逻辑，然后导入到 es 中。 一般来说，运营后台的检索条件都是组合的，使用 es 的好处是 「避免依赖 mysql 来做多条件组合检索」（索引越多写入速度会越慢），同时 mysql 毕竟是 OLTP 面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。\",\"es 一般会存储检索、展示、primary key 等数据，当我们操作编辑的时候，找到记录的 primary key，最后交由 comment-admin 进行运营测的 CRUD 操作。\",\"内部运营体系基本都是基于 es 来完成的。\"]},\"51\":{\"h\":\"BFF-comment\",\"t\":[\"comment 作为 BFF，是面向端，面向平台，面向业务组合的服务。所以平台扩展的能力，我们都在 comment 服务来实现，方便统一和准入平台，以统一的接口形式提供平台化的能力。\",\"依赖其他 gRPC 服务，整合统一平台测的逻辑(比如发布评论用户等级限定)。\",\"直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上 SDK。\",\"需要对非核心依赖的 gRPC 服务进行降级，当这些服务不稳定时。\"]},\"52\":{\"c\":[\"架构设计\"]},\"53\":{\"c\":[\"评论系统\"]},\"54\":{\"h\":\"评论系统和可用性设计\",\"t\":[\"转载自stormspirit，原文链接：评论系统和可用性设计\"]},\"55\":{\"h\":\"存储设计\"},\"56\":{\"h\":\"数据表设计\",\"t\":[\"先看一张 b 站的评论图：\",\"如上图所示，主评论下面有子评论，子评论之间也可以互相评论，并且评论之间是通过赞数进行排序的。\",\"数据表设计：\",\"如上图，评论系统分为三张表。\",\"comment_subject\",\"评论主题表。一个主题可能是一个视频稿件、一篇文章等。分成了 50 张表。自增 id 做主键。\",\"obj_id 是主题 id， obj_type 是主题类型。\",\"另外还保存了一些计数字段，比如评论总数等。这样做是为了避免每次需要统计总数时都要做一次 select count(*) ，这样效率很低，所以直接每次新增评论的时候就把相应字段 +1 即可。\",\"comment_index\",\"评论索引表。主要存的是评论的 id 与评论主题的对应关系，以及该评论的一些相关信息，比如是不是根评论、评论楼层，评论总数等。分成了 200 张表。使用自增 id 做主键，主键 id 就是评论 id。\",\"root 是该评论的根评论 id，比如上面评论图红框里的就是根评论。不为 0 就是回复的评论，为 0 就是根评论。\",\"parent 是这个评论的父评论，也就是它是回复哪条评论的，如果为 0 那这个评论就是根评论。\",\"其他的都是一些统计信息等等。\",\"comment_content\",\"评论内容表。主要存的是评论实际内容。分成了 200 张表。\",\"它直接使用 comment_id（对应的就是 comment_index 表的 id ）作为主键，这样的好处是：\",\"表都有主键，即 cluster index，是物理组织形式存放的，comment_content 没有 id，是为了减少一次二级索引查找，直接基于主键检索，同时 comment_id 在写入要尽可能的顺序自增。\",\"意思是从 comment_index 表里捞出来一堆 comment_id ，那就可以直接通过这些 comment_id 作为主键去查询 comment_content 表了。如果 content 表还有自己的自增主键的话，那么通过 comment_id 去查必然需要先查到自己的主键 id ，然后再通过 id 去查到这一行数据，多了一步操作。\",\"索引、内容分离，方便 mysql datapage 缓存更多的 row，如果和 content 耦合，会导致更大的 IO。长远来看 content 信息可以直接使用 KV storage 存储。比如 Rocks DB 等。\",\"这也是一种 「索引内容分离」 的设计思想。\",\"写数据\",\"事务更新 comment_subject，comment_index，comment_content 三张表，其中 content 属于非强制需要一致性考虑的。可以先写入 content，之后事务更新其他表。即便 content 先成功，后续失败仅仅存在一条 ghost 数据。\",\"读数据\",\"基于 obj_id + obj_type 在 comment_index 表找到根评论列表，比如：\",\"select id from comment_index where obj_id = 'x' and obj_type = 'y' and root = 0 ORDER BY floor;\",\"对于二级的子楼层，由于一般只查询 3 层子楼层：\",\"select id from comment_index where parent/root in (上面查询出来的 id) and floor <= 3 order by floor;\",\"之后根据 comment_index 的 id 字段捞出 comment_content 的评论内容。\",\"因为产品形态上只存在 「二级列表」，因此只需要迭代查询两次即可。对于嵌套层次多的，产品上，可以通过二次点击支持。\",\"这种迭代查询的方式也可以直接用图数据库来实现，可能更好，比如 DGraph、HugeGraph 类似的图存储思路。\"]},\"57\":{\"h\":\"总结\",\"t\":[\"主题一张表，评论索引与评论内容分开两张表来存，表里有一些统计字段，避免每次都重新统计。内容表的主键直接使用评论 id，避免使用评论 id 查询还需要回表。评论内容可以使用 kv 数据库。写入时可以先写评论内容表，评论索引表和主题表用一个事务更新。\"]},\"58\":{\"h\":\"缓存设计\",\"t\":[\"comment_subject_cache\",\"对应主题的缓存，value 使用 protobuf 序列化的方式存入。\",\"comment_index_cache\",\"使用 redis sortedset 进行索引的缓存。key 是主题 id + 主题 type + 排序方式， member 就是评论 id，score 就是根据各种要素排序的得分。这样就可以根据某个主题查询，得到排序过后的评论 id 列表。然后就可以通过评论 id 列表去批量查询评论内容了。\",\"提示\",\"索引即数据的组织顺序，而非数据内容。参考过百度的贴吧，他们使用自己研发的拉链存储来组织索引，我认为 mysql 作为主力存储，利用 redis 来做加速完全足够，因为 cache miss 的构建，我们前面讲过使用 kafka 的消费者中处理，预加载少量数据，通过增量加载的方式逐渐预热填充缓存，而 redis sortedset skiplist 的实现，可以做到 O(logN) + O(M) 的时间复杂度，效率很高。\",\"sorted set 是要增量追加的，因此必须判定 key 存在，才能 zdd。\",\"comment_content_cache\",\"对应评论内容数据，使用 protobuf 序列化的方式存入。\",\"缓存使用增量加载 + lazy 加载模式，也就是在查询第一页的时候会将后两页评论数据也一起加载进缓存。可以使用 kafka 进行缓存的异步构建。\"]},\"59\":{\"h\":\"可用性设计\"},\"60\":{\"h\":\"缓存穿透\",\"t\":[\"singleflight\",\"对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储？\",\"使用归并回源的思路 singleflight，singleflight 的原理可以看这篇文章 Go并发编程(十二) Singleflight。\",\"同进程只交给一个人去获取 mysql 数据，然后批量返回。\",\"同时这个租约 owner 投递一个 kafka 消息，做该 key 的 cache build 的操作。这样可以大大减少查询 mysql 的压力，以及大量透穿导致的密集写 kafka 的问题（如果不这么做那么会有很多的进程向 kafka 发送 cache rebuild 的指令，然后它们都会去 mysql 里查询数据写缓存）。\",\"更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个过期时间为 5 秒的 short-lived flag，标记最近有一个人投递了同一个 key 的 cache rebuild 的消息，如果有这个 flag ，那么相同的 kafka 消息直接 drop 而不会再去查 mysql 构建缓存，这样 mysql 的压力更小。\",\"再进一步，可以在 comment-job 内存里设置一个过期时间很短的比如 5 秒的 LRU cache， 有一个线程去 mysql 里查到了数据就更新这个缓存，然后其他的线程直接从这个缓存里拿数据即可，这样就不用重复去 mysql 里查了，同样减少了对 mysql 的查询压力。\",\"一般不需要使用分布式锁，实现起来太复杂而且很容易出错。\"]},\"61\":{\"h\":\"热点\",\"t\":[\"流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此做 cache 的升级 local cache 是有必要的，我们一般使用**「单进程自适应发现热点」**的思路，附加一个短时的 ttl local cache，可以在进程内吞掉大量的读请求。\",\"在内存中使用 hashmap 统计每个 key 的访问频次，这里可以使用滑动窗口统计（如下图），即每个窗口中，维护一个 hashmap，之后统计所有未过期的 bucket，汇总所有 key 的数据。\",\"之后使用小顶堆计算 TopK 的数据，自动进行热点识别。把 TopK 的 key 统一 load 到本地缓存。\"]},\"62\":{\"c\":[\"架构设计\"]},\"63\":{\"c\":[\"评论系统\"]},\"64\":{\"h\":\"360笔试 - 0914\"},\"65\":{\"h\":\"第一题\",\"t\":[\"题面\",\"某个公司的共享单车单次骑行 1 元，但可购买VIP卡免去骑行费用，有以下几种VIP卡：\",\"日卡 a 元，1 天不收费；\",\"月卡 b 元，30 天不收费；\",\"年卡 c 元，365 天不收费；\",\"十年卡 d 元，3650 天不收费。\",\"每天都允许购入任意张VIP卡，生效时间可累加。\",\"小A在未来 n 天都需要骑共享单车，第 i 天需要骑行 r[i] 次，现在小A想知道，他最少以要花多少钱。\",\"输入描述： 第一行一正整数 n(1≤n≤105)。 第二行四个正整数 a,b,c,d(1≤a,b,c,d≤107)，表示四种卡的价格。 第三行 n 个正整数 ri​，表示每天骑行次数。\",\"输出描述: 输出一个整数 x，表示最小花费。\",\"思路与代码\",\"动态规划。\",\"定义一个长度为 n 的 DP数组，dp[i] 表示第 i 天的最小花费。\",\"遍历每一天，维护办卡和不办卡的情况下每天的最小花费。\",\"dp[i]=min(dp[i]+dp[i−1]+r[i])\",\"#include <iostream> #include <vector> #include <algorithm> #define ll long long using namespace std; int main() { int n; cin >> n; vector<int> prices(4); for (int i = 0; i < 4; ++i) cin >> prices[i]; vector<int> rides(n); for (int i = 0; i < n; ++i) cin >> rides[i]; vector<ll> dp(n + 1, 1e18); dp[0] = 0; for (int i = 0; i < n; ++i) { dp[i + 1] = min(dp[i + 1], dp[i] + rides[i]); for (int j = 0; j < 4; ++j) { // 考虑每种情况 int days = (j == 0 ? 1 : (j == 1 ? 30 : (j == 2 ? 365 : 3650))); if (i + days <= n) { dp[i + days] = min(dp[i + days], dp[i] + prices[j]); } } } cout << dp[n] << endl; return 0; }\"]},\"66\":{\"h\":\"第二题\",\"t\":[\"题面\",\"在盘古开天辟地之前，他需要对当前所处的地形进行调查。\",\"盘古的面前一共有 n 座山，从左往右第 i 座山的高度为 hi​。盘古会选择一段连续的山进行开辟，记他选择的区间为 [l,r]，盘古选择的山必须满足 hl​<hl+1​<...<hr​，也就是从左往右对应山的高度严格单调递增。\",\"盘古在开山之前，可以选择任意一座山，将其高度修改为任意非负整数值。由于种种限制，该操作最多进行一次。盘古想知道：他能够选择的区间最长是多少？\",\"输入描述： 第一行一个正整数 T，表示数据组数。 对于每一组数据，第一行一个正整数 n，表示一共有 n 座山，第二行输入 n 个正整数 h1​,h2​,...,hn​。(1≤n≤105,1≤T≤5,1≤hi​≤105)\",\"输出描述： 对于每一组数据，输出一行一个正整数，表示盘古能够选择的最长的区间对应的长度。\",\"思路与代码\",\"首先，需要找到不在进行任何修改的情况下，最长的严格单调递增子序列的长度。\",\"然后，尝试通过修改一次任意一座山的高度，来最大化这个子序列的长度。\",\"预处理最长递增子序列：\",\"计算从左到右和从右到左的最长递增子序列的长度。\",\"具体来说，维护两个数组 l 和 r，其中 l[i] 表示从左到右以第 i 座山结尾的最长递增子序列的长度，r[i] 表示从右到左以第 i 座山结尾的最长递增子序列的长度。\",\"计算修改一次后的最长递增子序列：\",\"遍历每一座山 i，假设我们修改第 i 座山的高度，使得它能够连接 l[i - 1] 和 r[i + 1] 的子序列。\",\"具体来说，我们需要检查 h[i - 1] < (h[i + 1] - 1) 是否成立（因为是严格递增，所以还需要 −1），如果成立，则可以通过修改 h[i] 使得 l[i - 1] 和 r[i + 1] 的子序列连接起来。\",\"计算通过修改第 i 座山高度所能得到的最长递增子序列的长度，并更新全局最大值。\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; int main() { int T; cin >> T; while (T--) { int n; cin >> n; vector<int> h(n); for (int i = 0; i < n; ++i) cin >> h[i]; vector<int> l(n, 1), r(n, 1); for (int i = 1; i < n; ++i) { if (h[i] > h[i - 1]) l[i] = l[i - 1] + 1; } for (int i = n - 2; i >= 0; --i) { if (h[i] < h[i + 1]) r[i] = r[i + 1] + 1; } int mx = 1; for (int i = 0; i < n; ++i) { mx = max(mx, l[i]); } for (int i = 1; i < n - 1; ++i) { if (h[i - 1] < (h[i + 1] + 1)) { mx = max(mx, l[i - 1] + r[i + 1]); } } // 最后要加上中间修改的山 cout << mx + 1 << endl; } return 0; }\"]},\"67\":{\"c\":[\"For-Offer\"]},\"68\":{\"c\":[\"笔试题\"]},\"69\":{\"h\":\"58同城笔试 - 0920\"},\"70\":{\"h\":\"第一题\",\"t\":[\"题面\",\"我们正在为一个日程安排管理系统开发一个关键功能，在这个系统中，有两个不同的用户群体，分别有他们各自的空闲日程区间列表。 第一个用户群体的空闲日程区间列表记为 firstList，其中 firstList[i] = [start_i, end_i]； 同样地，第二个用户群体的日程区间列表记为 secondList，secondList[j] = [start_j, end_j]。 每个用户群体的日程区间都是成对出现且不相交的，并且两个列表都已经按照时间顺序排好序。\",\"现在，为了找到两个用户群体都有空闲时间可以进行共同活动的时间段，需要设计一个算法来返回这两个日程区间列表的交集，将其找出来以便系统可以安排共同的活动。\",\"请你设计一个高效的算法来解决这个问题。\",\"补充说明： 输入中的每个日程区间为：[start_i, end_i] 题目确保：0<starti​<endi​<starti+1​<10000\",\"示例：\",\"输入：[[0,3],[5,9],[11,13]],[[2,6],[8,10]] 输出：[[2,3],[5,6],[8,9]]\",\"思路与代码\",\"双指针遍历两个列表，找到它们的共同交集。\",\"import java.util.*; public class Solution { public List<int[]> findFreeTimeIntersections(int[][] firstList, int[][] secondList) { List<int[]> res = new ArrayList<>(); int i = 0, j = 0; while (i < firstList.length && j < secondList.length) { int s_i = firstList[i][0], e_i = firstList[i][1]; int s_j = secondList[j][0], e_j = secondList[j][1]; if (e_i < s_j) { i++; } else if (e_j < s_i) { j++; } else { int start = Math.max(s_i, s_j); int end = Math.min(e_i, e_j); result.add(new int[]{start, end}); if (e_i < e_j) { i++; } else { j++; } } } return res; } }\"]},\"71\":{\"h\":\"第二题\",\"t\":[\"题面\",\"给你一个由若干 a 和 b 组成的字符串 s，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。\",\"「分割字符串的得分」为左子字符串中 a 的数量加上右子字符串中 b 的数量。\",\"补充说明：2≤s.length≤500 字符串 s 仅由字符 a 和 b 组成。\",\"示例：\",\"输入：abbbab 输出：5 说明：将字符串 s 划分为两个非空子字符串的可行方案： 左子字符串 = \\\"a\\\" 且 右子字符串 = \\\"bbbab\\\"，得分 = 1 + 4 = 5 左子字符串 = \\\"ab\\\" 且 右子字符串 = \\\"bbab\\\"，得分 = 1 + 3 = 4 左子字符串 = \\\"abb\\\" 且 右子字符串 = \\\"bab\\\"，得分 = 1 + 2 = 3 左子字符串 = \\\"abbb\\\" 且 右子字符串 = \\\"ab\\\"，得分 = 1 + 1 = 2 左子字符串 = \\\"abbba\\\" 且 右子字符串 = \\\"b\\\"，得分 = 2 + 1 = 3 最大得分为5\",\"思路与代码\",\"直接遍历即可。\",\"public class Solution { public int maxScore(String str) { int sumA = 0, sumB = 0; for (char c : str.toCharArray()) { if (c == 'a') sumA++; else sumB++; } int ans = 0; int leftA = 0, leftB = 0; for (int i = 0; i < str.length() - 1; i++) { if (str.charAt(i) == 'a') leftA++; else leftB++; int rightB = sumB - leftB; int res = leftA + rightB; ans = Math.max(ans, res); } return ans; } }\"]},\"72\":{\"h\":\"第三题\",\"t\":[\"题面\",\"最初，你站在 无限 数轴上位置 startPos 处。 给你两个正整数 startPos 和 endPos 。 在一次移动中，你可以向左或者向右移动一个位置。 给你一个正整数 k ，返回从 startPos 出发，恰好移动 k 步并到达 endPos 的 不同 方法数目。\",\"答案可能会很大，返回对 109+7 取余的结果。 如果所执行移动的顺序不完全相同，则认为两种方法不同。 注意：数轴包含负整数。\",\"补充说明：1≤startPos,endPos,k≤1000\",\"示例：\",\"输入：1,2,3 输出：3 说明：存在 3 种从 1 到 2 且恰好移动 3 步的方法： 1 -> 2 -> 3 -> 2. 1 -> 2 -> 1 -> 2. 1 -> 0 -> 1 -> 2.\",\"思路与代码\",\"尝试用数学的方法，通过计算 Cnm​ 求解，但只能过 54.44%。\",\"于是采用动态规划求解。\",\"定义一个二维DP数组，其中 dp[i][j] 表示从起点移动 i 步到达位置 j 的不同方法数。通过分析每一步的移动情况，我们可以得出状态转移方程，然后逐步计算出最终结果。\",\"步骤：\",\"初始化DP数组 dp[k + 1][maxPos - minPos + 1]，其中 maxPos 和 minPos 是可能达到的最远和最近的位置。\",\"设置初始状态：dp[0][startPos - minPos] = 1，表示一开始在起点的方法数为 1。\",\"遍历步数 i 从 1 到 k： \",\"对于每个可能的位置 j，计算 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]，表示到达 j 的方法数等于从 j−1 向右移动和从 j+1 向左移动的方法数之和\",\"最终结果为 dp[k][endPos - minPos]\",\"所有计算过程中都需要对 109+7 取模，防止溢出\",\"class Solution { public int numberOfWays(int startPos, int endPos, int k) { final int mod = 1000000007; int maxPos = Math.max(startPos, endPos) + k; int minPos = Math.min(startPos, endPos) - k; int offset = -minPos; long[][] dp = new long[k + 1][maxPos - minPos + 1]; dp[0][startPos + offset] = 1; for (int i = 1; i <= k; i++) { for (int j = 0; j < dp[i].length; j++) { if (j > 0) { dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % mod; } if (j < dp[i].length - 1) { dp[i][j] = (dp[i][j] + dp[i-1][j+1]) % mod; } } } return (int) dp[k][endPos + offset]; } }\"]},\"73\":{\"c\":[\"For-Offer\"]},\"74\":{\"c\":[\"笔试题\"]},\"75\":{\"h\":\"京东笔试 - 0824\",\"t\":[\"JDS-2025届秋招-后端开发工程师-第3批\"]},\"76\":{\"h\":\"一百倍\",\"t\":[\"题面\",\"给你一个整数，请你判断 0 ~ N 之间有多少个数是 100 的正整数倍。\",\"输入描述： 输入的第一行给出一个整数 N.−100100≤N≤<=10100\",\"输出描述: 输出 0 ~ N 之间有多少个数是 100 的整数倍。\",\"数字范围非常大，转化为字符串解决，除去低两位即可。\",\"#include <iostream> using namespace std; int main(){ string s; cin >> s; int len = s.length(); if (s[0] == '-' || len < 3){ cout << 0 << endl; } else { string str = s.substr(0, len - 2); cout << str << endl; } retrun 0; }\"]},\"77\":{\"h\":\"网络板\",\"t\":[\"题面\",\"给定一个小为 n×m 的网格板, 网格板是由 n×m 个 1×1 的单元格组成, 最初所有的单元格是白色的。\",\"现在给出k个操作:\",\"cxy 将位置为 (x,y) 的单元格涂成黑色lxy 从位置为 (x,y) 的单元格向左寻找最先出现的白色单元格 (不包含(x,y)) , 并输出其坐标;rxy 从位置为 (x,y) 的单元格向右寻找最先出现的白色单元格 (不包含(x,y)) , 并输出其坐标;uxy 从位置为 (x,y) 的单元格向上寻找最先出现的白色单元格 (不包含(x,y)) , 并输出其坐标;dxy 从位置为 (x,y) 的单元格向下寻找最先出现的白色单元格 (不包含(x,y)) , 并输出其坐标; 注: 网格板的左上角的单元格坐标为 (1,1)\",\"输入描述： 第一行给出正整数 n,m,k 代表网格板的大小以及操作的次数; 随后 k 行, 每行一个操作命令 s,x,y。1<n,m<1001≤k≤1041≤xi​≤n1≤yi​≤msi​ 中仅包含 lrudc\",\"输出描述： 对于 lrud 的命令, 每行输出对应的操作后的坐标。\",\"四个方向模拟即可。\",\"用一个二维布尔数组来表示网格，其中 true 表示黑色单元格，false 表示白色单元格。对于每个查找操作，在指定方向上遍历网格，直到找到一个白色单元格或到达边界。\",\"#include <iostream> #include <vector> using namespace std; int main() { int n, m, k; cin >> n >> m >> k; // 初始化网格，所有单元格都是白色（false） vector<vector<bool>> grid(n, vector<bool>(m, false)); while (k--) { char op; int x, y; cin >> op >> x >> y; x--; y--; // 将坐标转换为0-based if (op == 'c') { // 将单元格涂黑 grid[x][y] = true; } else { int res_x = -1, res_y = -1; if (op == 'l') { // 向左寻找 for (int j = y - 1; j >= 0; j--) { if (!grid[x][j]) { res_x = x + 1; res_y = j + 1; break; } } } else if (op == 'r') { // 向右寻找 for (int j = y + 1; j < m; j++) { if (!grid[x][j]) { res_x = x + 1; res_y = j + 1; break; } } } else if (op == 'u') { // 向上寻找 for (int i = x - 1; i >= 0; i--) { if (!grid[i][y]) { res_x = i + 1; res_y = y + 1; break; } } } else if (op == 'd') { // 向下寻找 for (int i = x + 1; i < n; i++) { if (!grid[i][y]) { res_x = i + 1; res_y = y + 1; break; } } } // 输出结果 if (res_x == -1 && res_y == -1) { cout << -1 << endl; } else { cout << res_x << \\\" \\\" << res_y << endl; } } } return 0; }\"]},\"78\":{\"h\":\"三角形\",\"t\":[\"题面\",\"有 n 根木桩排成一列，第 i 根木桩的长度为 ai​ 。\",\"请你从中选出一个最长的子区间，使得区间内任意三根木桩都能构成三角形。只需要输出选出的区间端点即可。\",\"输入描述: 第一行一个整数 n(3≤n≤106)，表示木桩数量。 第二行 n 个整数，第 i 个整数 ai​(1≤ai​≤109) 表示第 i 根木桩的长度。\",\"输出描述: 输出一行两个整数，表示最长的满足条件的区间的两个端点。如果有多个满足条件的区间，输出左端点最小的区间。保证答案存在。\",\"三角形的成立条件：任意两边之和大于第三边。\",\"对于一个区间内的木桩，如果我们能保证最短的两根木桩之和大于最长的木桩，那么这个区间内任意三根木桩都能构成三角形。我们可以使用滑动窗口和单调队列的思想来解决这个问题。\"]},\"79\":{\"c\":[\"For-Offer\"]},\"80\":{\"c\":[\"笔试题\"]},\"81\":{\"h\":\"华宇信息笔试 - 1016\"},\"82\":{\"h\":\"简单的字符串压缩\",\"t\":[\"题面\",\"对输入的文本字符串进行简单的压缩，输出压缩后的字符串。\",\"输入描述： 输入为一个简单的文本字符串，里面只包含 26 个大小写英文字符，字符可重复，比如 \\\"aaabbbcccddd\\\"。\",\"输出描述： 将相同的字符进行压缩，计算相同字符的个数，然后得到压缩结果，比如 \\\"aaabbbcccddd\\\" 压缩后的结果为 \\\"a3b3c3d3\\\"，最后输出结果就为 \\\"a3b3c3d3\\\"。\",\"示例\",\"输入：aaabbbcccddd 输出：a3b3c3d3\",\"思路与代码：\",\"遍历一次字符串，通过维护一个计数器来跟踪当前连续字符的数量，当字符变化时更新计数器结果。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); int n = s.length(); if (s == null || n == 0) { System.out.println(\\\"\\\"); return; } StringBuilder res = new StringBuilder(); int cnt = 1; for (int i = 1; i < n; i++) { if (s.charAt(i) == s.charAt(i - 1)) { cnt++; } else { res.append(s.charAt(i - 1)); res.append(cnt); cnt = 1; } } // 加上剩余的字符 res.append(s.charAt(n - 1)); res.append(cnt); System.out.println(res.toString()); } }\"]},\"83\":{\"h\":\"简单的数学表达式计算\",\"t\":[\"题面\",\"输入为一个简单的数学表达式字符串，字符串只包含若干一位的正整数和若干计算符号，计算符号只有 \\\"+\\\"、\\\"-\\\"、\\\"*\\\" 三种，求该表达式的计算结果。计算结果范围为 −263 至 263 之间。\",\"输入描述： 输入为简单的数学表达式字符串，字符串只包含若干一位的正整数和若干计算符号，计算符号只有 \\\"+\\\"、-、\\\"*\\\" 三种。例如 \\\"1+2+34−56\\\"、\\\"22−33+44\\\"、\\\"9−8−76+5+43\\\" 等。\",\"输出描述： 输出为输入数学表达式计算结果，计算结果范围为 −263 至 263 之间。比如输入为 \\\"1+2+34−56\\\" 时，输出为 \\\"−15\\\"。输入为 \\\"22−33+4∗4\\\" 时，输出为 \\\"11\\\"。\",\"示例\",\"输入：1+2-34+56 输出：21\",\"思路与代码：\",\"类似于逆波兰表达式的计算，使用两个栈分别存数字和符号来实现。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); int n = s.length(); Stack<Long> nums = new Stack<>(); Stack<Character> op = new Stack<>(); int i = 0; while (i < n){ char c = s.charAt(i); if (Character.isDigit(c)){ long num = s.charAt(i) - '0'; nums.push(num); i++; continue; } /* 多位数字的写法： if (Character.isDigit(c)) { long num = 0; while (i < n && Character.isDigit(s.charAt(i))) { num = num * 10 + (s.charAt(i) - '0'); i++; } nums.push(num); continue; } */ while (!op.isEmpty() && check(op.peek()) >= check(c)){ long b = nums.pop(); long a = nums.pop(); nums.push(fun(op.pop(), a, b)); } op.push(c); i++; } while (!op.isEmpty()){ long b = nums.pop(); long a = nums.pop(); nums.push(fun(op.pop(), a, b)); } long res = nums.pop(); System.out.println(res); } public static int check(char op){ if (op == '+' || op == '-'){ return 1; } else if (op == '*'){ return 2; } return 0; } public static long fun(char op, long a, long b){ if (op == '+'){ return a + b; } else if (op == '-'){ return a - b; } else if (op == '*'){ return a * b; } return 0; } }\"]},\"84\":{\"c\":[\"For-Offer\"]},\"85\":{\"c\":[\"笔试题\"]},\"86\":{\"h\":\"同程旅行笔试 - 0924\",\"t\":[\"两道编程题 50 分，都非常简单，但前面的选择题有一定难度，考了很多多线程和操作系统方面的知识，希望能进面。🤗\"]},\"87\":{\"h\":\"小红的方案数\",\"t\":[\"题面\",\"小红想构造一个大小为 n 的数组，满足第奇数个元素都是奇数，第偶数个元素都是偶数（即和它的序偶性相同，数组下标从 1 开始计算）。且每个元素都在区间 [1, m] 内。\",\"小红想知道一共有多少种不同的方案？答案请对 109+7 取模。\",\"输入描述： 第一行两个正整数 n,m1≤n,m≤106\",\"输出描述： 输出一个数，代表构造的方案数对 109+7 取模的值。\",\"示例：\",\"输入：3 3 输出：4\",\"思路与代码\",\"先确定奇数和偶数的数量：\",\"如果 n 是奇数，则数组中有 2n+1​ 个奇数和 2n−1​ 个偶数。\",\"如果 n 是偶数，则数组中有 2n​ 个奇数和 2n​ 个偶数。\",\"再计算奇数和偶数的可选数量：\",\"在区间 [1, m] 内，奇数的数量为 2m+1​。\",\"在区间 [1, m] 内，偶数的数量为 2m​。\",\"最后计算总的方案数：\",\"对于每个奇数位置，有 2m+1​ 种选择。\",\"对于每个偶数位置，有 2m​ 种选择。\",\"总的方案数为 (2m+1​) ^ 奇数数量 ×(2m​) ^ 偶数数量。\",\"注意每次运算都需要取模。\",\"import java.util.*; public class Main { private static final long mod = 1000000007; private static long qmi(long x, int n) { long res = 1; while (n > 0) { if ((n & 1) == 1) { res = res * x % mod; } x = x * x % mod; n >>= 1; } return res; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int oddCount = (n + 1) / 2; int evenCount = n / 2; long oddChoices = (m + 1) / 2; long evenChoices = m / 2; long res = qmi(oddChoices, oddCount) * qmi(evenChoices, evenCount) % mod; System.out.println(res); } }\"]},\"88\":{\"h\":\"小红的密码\",\"t\":[\"题面\",\"小红准备在一个网站注册一批账号和密码。已知当小红进行注册时，该网站会给出以下提示：\",\"用户名为 6 ~ 12 的字符串，且必须全部由英文字母（大小写均可）组成。\",\"用户名必须没有被注册过。\",\"小红想知道，自己每次操作会得到什么样的返回？\",\"输入描述： 第一行输入一个正整数 t，代表小红的注册次数。 之后每行输入一个长度不超过 20 的字符串(字符串不含空格)，代表小红的操作。 数据范围：1≤t≤105\",\"输出描述： 对于每次注册： 若账号长度不合法，则输出 \\\"illegal length\\\" 若账号长度合法但出现了英文字母以外的字符，则输出 \\\"illegal character\\\" 若该账号合法但已经被注册过，则输出 \\\"account existed\\\" 若注册成功，则输出 \\\"registration complete\\\"\",\"示例：\",\"输入：4 abcdef abc abcdef abcd2f 输出：registration complete illegal length account existed illegal character\",\"思路与代码\",\"直接模拟即可。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); sc.nextLine(); Set<String> registeredAccounts = new HashSet<>(); for (int i = 0; i < t; i++) { String account = sc.nextLine(); if (account.length() < 6 || account.length() > 12) { System.out.println(\\\"illegal length\\\"); } else if (!account.matches(\\\"[a-zA-Z]+\\\")) { System.out.println(\\\"illegal character\\\"); } else if (registeredAccounts.contains(account)) { System.out.println(\\\"account existed\\\"); } else { registeredAccounts.add(account); System.out.println(\\\"registration complete\\\"); } } } }\"]},\"89\":{\"c\":[\"For-Offer\"]},\"90\":{\"c\":[\"笔试题\"]},\"91\":{\"h\":\"好未来笔试 - 0906\"},\"92\":{\"h\":\"合并数组\",\"t\":[\"题面\",\"已知两个有序整形数组 a 和 b，请将两个数组合并成一个新的有序数组;\",\"示例：\",\"输入：[1,2,3],[-1,1,3,6] 输出：[-1,1,1,2,3,3,6]\",\"思路与代码\",\"合并数组一般使用双指针实现。\",\"使用两个指针分别指向数组 a 和 b 的起始位置，然后比较两个指针所指向的元素，将较小的元素放入结果数组中，并将对应指针向后移动一位。重复这个过程，直到其中一个数组的所有元素都被处理完毕。最后，将另一个数组中剩余的元素直接添加到结果数组中。\",\"vector<int> merge(vector<int>& a, vector<int>& b) { vector<int> res; int i = 0, j = 0; while (i < a.size() && j < b.size()) { if (a[i] < b[j]) { res.push_back(a[i++]); } else if (a[i] > b[j]) { res.push_back(b[j++]); } else { res.push_back(a[i++]); res.push_back(b[j++]); } } while (i < a.size()) { res.push_back(a[i++]); } while (j < b.size()) { res.push_back(b[j++]); } return res; }\"]},\"93\":{\"h\":\"有效字符串\",\"t\":[\"题面\",\"给定一个只包括 '('，')'，'{'，'}'，'[' 和 ']' 的字符串，判断字符串是否有效。\",\"有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。\",\"示例：\",\"输入：\\\"()[]{}\\\" 输出：true\",\"思路与代码\",\"字符串的括号匹配问题，使用栈解决。\",\"初始化一个空栈 stack。\",\"遍历输入字符串 s 中的每个字符 c： \",\"如果 c 是左括号 '('、'[' 或 '{'，我们将它压入栈中。\",\"如果 c 是右括号 ')'、']' 或 '}'，我们检查栈是否为空。如果为空，说明右括号无法匹配，返回 false。\",\"如果栈不为空，我们检查栈顶元素是否与 c 匹配。如果不匹配，返回 false。否则，我们将栈顶元素弹出。\",\"最终，如果栈为空，说明所有括号都已正确匹配，返回 true。否则，返回 false。\",\"bool isValid(string s) { stack<char> st; for (char c : s) { if (c == '(' || c == '[' || c == '{') { st.push(c); } else { if (st.empty()) { return false; } char top = st.top(); st.pop(); if ((c == ')' && top != '(') || (c == ']' && top != '[') || (c == '}' && top != '{')) { return false; } } } return st.empty(); }\"]},\"94\":{\"c\":[\"For-Offer\"]},\"95\":{\"c\":[\"笔试题\"]},\"96\":{\"h\":\"宇信科技笔试 - 1012\"},\"97\":{\"h\":\"第一题\",\"t\":[\"题面\",\"小红和小紫在玩一个游戏，在这个游戏中，小红坐标为 (0,h)，小紫坐标为 (0,0)，游戏开始时，小紫以 v1​ 的速度沿 x 轴方向向右行走，小红向坐标 (x0​​,0) 发射了一个速度为 v2​ 的魔法水晶箭，魔法水晶箭到达坐标 (x0​​,0) 时会爆炸，对以落点为圆心、半径为 r 的区域造成范围伤害。\",\"如果小紫中途不更改行进方向和速度，请你计算小紫是否会被魔法水晶箭攻击到？\",\"输入描述： 本题为多组测试数据，第一行输入一个正整数 T(1≤T≤1000)，代表测试数据组数。 对于每组测试数据，一行输入五个正整数 h,r,x0​,v1​,v2​(1≤h,x0​≤1000,1≤v1​,v2​≤100, 1≤r≤10)，含义如题所述。\",\"输出描述： 对于每组测试数据输出一行答案，如果小紫会被魔法水晶箭攻击到，则输出 \\\"Yes\\\"，否则输出 \\\"No\\\"。\",\"示例：\",\"输入：1 1 1 1 1 1 输出：Yes\",\"思路与代码：\",\"计算魔法水晶箭从发射到落地的时间，判断小紫在落地的时刻是否在魔法水晶箭的爆炸范围内即可。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int i = 0; i < T; i++) { int h = scanner.nextInt(); int r = scanner.nextInt(); int x0 = scanner.nextInt(); int v1 = scanner.nextInt(); int v2 = scanner.nextInt(); double t = Math.sqrt(x0 * x0 + h * h) / v2; double d = v1 * t; if (d >= x0 - r && d <= x0 + r) { System.out.println(\\\"Yes\\\"); } else { System.out.println(\\\"No\\\"); } } } }\"]},\"98\":{\"h\":\"第二题\",\"t\":[\"题面\",\"从 C/C++ 转到 Java 的程序员，一开始最不习惯的就是变量命名方式的改变。C 语言风格使用下划线分隔多个单词，例如 \\\"hello_world\\\"；而 Java 则采用一种叫骆驼命名法的规则：除首个单词以外，所有单词的首字母大写，例如 \\\"helloWorld\\\"。\",\"请你帮 C 程序员们自动转换变量名。\",\"输入描述: 每组数据一行，包含一个 C 语言风格的变量名。每个变量名长度不超过 100。\",\"输出描述: 输出变量名相应的骆驼命名法。\",\"示例：\",\"输入：hello_world 输出：helloWorld\",\"思路与代码：\",\"遍历变量名中的每一个字符：\",\"如果当前字符是下划线 _，则跳过该字符，并将下一个字符转换为大写。\",\"如果当前字符不是下划线，则直接添加到结果字符串中。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); StringBuilder res = new StringBuilder(); boolean next = false; for (char c : str.toCharArray()) { if (c == '_') { next = true; } else { if (next) { res.append(Character.toUpperCase(c)); next = false; } else { res.append(c); } } } System.out.println(res.toString()); } }\"]},\"99\":{\"h\":\"第三题\",\"t\":[\"题面\",\"将自然数 1 ~ n 写成一排，还有另一个自然数 k。 删数游戏每一轮删除位置编号为 k 的倍数上的数字，删掉后空出来的地方由后面的数字递补，一直删到剩余的数字个数少于 k 个，这样就不能再继续下去了。 请问在第几轮的时候数字 n 被删除？\",\"例如对于 n=13,k=2 的时候，删除情况如下： 第一轮删除了 2,4,6,8,10,12，剩下 1,3,5,7,9,11,13。 第二轮删除了 3,7,11，剩下 1,5,9,13。 第三轮删除了 5,13，剩下 1,9。 第四轮删除了 9，剩下 1。 剩余数字个数小于 k 个，游戏结束，共进行了 4 轮，数字 13 在第三轮被删除。\",\"输入描述： 在两行中给出两个正整数 n,k，含义如题所示3≤n≤10182≤k≤100\",\"输出描述： 在一行中输出数字 n 在第几轮被删除，如果数字 n 不会被删除则输出 0\",\"示例：\",\"输入：13 2 输出：3\",\"思路与代码：\",\"约瑟夫环的变种问题。\",\"为了确定数字 n 在第几轮被删除，可以跟踪 n 在每一轮中的位置。在每一轮中，每隔 k−1 个数删除第 k 个数。如果 n 的位置是 k 的倍数，则它将在当前轮被删除。否则，更新 n 的新位置为原位置减去被删除的数的数量，然后进入下一轮。\",\"重复此过程，直到剩余的数字少于 k 个。如果在所有轮次中 n 未被删除，则输出 0。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); long n = sc.nextLong(); int k = sc.nextInt(); long round = 1; long pos = n; while (true) { if (pos % k == 0) { System.out.println(round); return; } long del = pos / k; pos = pos - del; if (pos < k) { break; } round++; } System.out.println(0); } }\"]},\"100\":{\"c\":[\"For-Offer\"]},\"101\":{\"c\":[\"笔试题\"]},\"102\":{\"h\":\"小米笔试 - 1012\"},\"103\":{\"h\":\"宝石项链\",\"t\":[\"题面\",\"小明正在玩弄他的一串宝石项链。这个项链还没有封口，是一条链，初始的从左到右宝石分别编号 1,2,3,...,n。然而经过一段时间操作，小明觉得他应该把项链左右翻转一下了，将某个宝石调到其整条项链的前面或者后面去。小明在正式进行调整前，希望你能告诉他经过这个操作后宝石项链的样子。\",\"输入描述： 第一行 2 个空格隔开的整数 n 和 q，表示宝石数量和操作次数。 第二行 3q 个空格隔开的整数 a1​,b1​,op1​,a2​,b2​,op2​,...,aq​,bq​,opq​，对第 i 次操作，表示将编号为 ai​ 的宝石取下，放到编号为 bi​ 的宝石旁边，如 opi​=0时放到其前，否则放到其后。1≤n,q≤50000,1≤ai​,bi​≤n,opi∈0,1。保证 ai​=bi​。\",\"输出描述： 输出一行 n 个整数，表示调整后，从左到右宝石的编号。\",\"思路与代码：\",\"使用双向链表来模拟项链的所有操作。\",\"import java.util.*; public class Main { static class Node { int val; Node prev, next; Node(int val) { this.val = val; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int q = sc.nextInt(); Node[] nodes = new Node[n + 1]; Node head = new Node(0); Node tail = head; for (int i = 1; i <= n; i++) { Node node = new Node(i); nodes[i] = node; tail.next = node; node.prev = tail; tail = node; } for (int i = 0; i < q; i++) { int a = sc.nextInt(); int b = sc.nextInt(); int op = sc.nextInt(); Node nodeA = nodes[a]; Node nodeB = nodes[b]; nodeA.prev.next = nodeA.next; if (nodeA.next != null) { nodeA.next.prev = nodeA.prev; } if (op == 0) { nodeA.prev = nodeB.prev; nodeA.next = nodeB; if (nodeB.prev != null) { nodeB.prev.next = nodeA; } else { head.next = nodeA; } nodeB.prev = nodeA; } else { nodeA.prev = nodeB; nodeA.next = nodeB.next; if (nodeB.next != null) { nodeB.next.prev = nodeA; } nodeB.next = nodeA; } } int[] res = new int[n]; Node cur = head.next; for (int i = 0; i < n; i++) { res[i] = cur.val; cur = cur.next; } for (int i = 0; i < n; i++) { System.out.print(res[i] + \\\" \\\"); } } }\"]},\"104\":{\"h\":\"均衡\",\"t\":[\"题面\",\"小明在研究一个有趣的数组翻转操作问题，其中为了考虑均衡，他会同时翻转相邻两个数，他有一个长度为 N 的数组 a，并可以进行任意次操作: 选择相邻的两个数，翻转这两个数的符号，即将 a[i] 和 a[i + 1](0<i<n−1) 的符号翻转。符号翻转的意思是正数变负数，负数变正数，在程序中即 num=−num，也即数学中的取相反数；当然 0 翻转后还是 0。 小牛的任务是找到经过任意次数（可以为 0 次）这些操作后，能够获得的最大数组和。当然，只要小明觉得有必要，同一个数也可以被反复选择。\",\"输入描述： 第一行包含一个整数 N，表示数组的长度。 第二行包含 N 个整数，a[1],a[2],…a[N]。(1<N<30000,−1000000000<a[i]<10000000000)\",\"输出描述： 输出一个整数，表示经过任意次操作后数组的最大和。\",\"示例：\",\"输入：5 1 -2 3 -4 5 输出：15\",\"思路与代码：\",\"有两种解法。\",\"第一种，贪心，找结论：\",\"只要有偶数个负数，则通过若干次操作一定能都变成正数。\",\"只要有奇数个负数，则通过若干次操作一定变成，只有一个负数其他都是正数，因此贪心选个绝对值最小的数字当最后那个负数即可。\",\"第二种，动态规划：\",\"定义 DP 数组 dp[2][n]： \",\"dp[0][i] 表示 [i - 1, i] 这一对没有发生反转的前 i 个数的最大和\",\"dp[1][i] 表示 [i - 1, i] 这一对有发生反转的前 i 个数的最大和。\",\"转移方程根据 dp[0][i - 1] 和 dp[1][i - 1] 分别来转移即可。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i++) { a[i] = sc.nextInt(); } int[][] dp = new int[2][n]; dp[0][0] = a[0]; dp[1][0] = -a[0]; if (n > 1) { dp[0][1] = a[0] + a[1]; dp[1][1] = -a[0] - a[1]; } for (int i = 2; i < n; i++) { dp[0][i] = Math.max(dp[0][i - 1] + a[i], dp[1][i - 1] + a[i]); dp[1][i] = Math.max(dp[0][i - 1] - a[i] - 2 * a[i - 1], dp[1][i - 1] + 2 * a[i - 1] - a[i]); } int res = Math.max(dp[0][n - 1], dp[1][n - 1]); System.out.println(res); } }\"]},\"105\":{\"c\":[\"For-Offer\"]},\"106\":{\"c\":[\"笔试题\"]},\"107\":{\"h\":\"小黑盒笔试 - 0907\"},\"108\":{\"h\":\"第一题\",\"t\":[\"题面\",\"有一条街，街里有 n 个房子，房子的编号按顺序为 0,...,n−1\",\"你需要寻找这里的有且仅有一个的网吧。你在这条街里询问每一个房子询问\\\"哪个房子是网吧\\\"，每次询问时房子的主人都会回答 “网吧离我距离为 x”\",\"输入为一个整型数组 house[]，数组长度为 n，数组元素为每个房子的主人回答的数字 x， 如果 house[i] == -1 表示这个房子的主人不想回答问题，否则 house[i] 是非负整数，表示第 i个房间的主人回答的数字 x。\",\"假设所有的房主回答都是正确的情况下，返回一个整型数组 int[]，包含所有可能是网吧的房间的编号集合。(按数字递增排序返回)\",\"示例：\",\"输入：[-1,-1,-1,-1,-1] 输出：[0,1,2,3,4,5] 说明：因为所有房主都没有回答，所以所有房间都可能为网吧\",\"思路与代码\",\"模拟。遍历每个房子，根据房主的回答来验证每个可能的网吧位置是否符合已知的距离信息。\",\"使用一个 bool 数组 st[] 作为标记，初始化全为 true，表示所有位置都可能是网吧。\",\"遍历，如果 house[i] != -1，说明房主提供了有效信息：\",\"计算可能的网吧距离 ∣i−j∣，如果这个距离不等于 house[i]，将 st[i] 置为 false\",\"最后将遍历后的 st[] 数组中结果为 true 的索引 i 加入到结果数组中即可。\",\"class Solution { public: vector<int> findPossibleCafe(vector<int>& house) { int n = house.size(); vector<bool> possibleCafe(n, true); for (int i = 0; i < n; i++) { if (house[i] != -1) { for (int j = 0; j < n; j++) { if (abs(i - j) != house[i]) { possibleCafe[j] = false; } } } } vector<int> res; for (int i = 0; i < n; i++) { if (possibleCafe[i]) { res.push_back(i); } } return res; } };\"]},\"109\":{\"h\":\"第二题\",\"t\":[\"题面\",\"你喜欢的一个商店开始了促销活动。 每次你在商店里花费了 S 元，你就能够获得一个随机的优惠券。比如，S=10 时如果你在商店里花费了 27 元，你可以获得 2个优惠券（10+10+7，最后的 7 不到 8 所以被当作无效）。\",\"现在给你列出一个商品的价格集合 prices[]，你需要购买这里的所有商品且每个只买一份。你可以同时购买其中若干子集（根据价格之和），并获得一次对应的优惠券，然后在剩下的商品里再购买若干子集，获得优惠券，依此不断的做，直到所有的商品都购买为止。\",\"请返回一个数组，数组大小为 2， 第一个数字为 A，表示你采取最优策略的情况下获得的最多的优惠券个数， 第二个数字为 B，表示你采取最优策略的情况下获得的最少的优惠券个数。\",\"示例：\",\"输入: 7 [10, 21, 98, 19] 输出: [21,20] 说明: 先购买第二个商品价格为21，获得3个优惠券 然后购买剩下的3个商品价格为(10+98+19) = 127，127/7 = 18，获得18个优惠券， 这种情况下最多能获得21个优惠券\",\"思路与代码\",\"动态规划：计算出所有可能的子集购买方案，找出能获得最多和最少优惠券的方案。\",\"定义商品的选择状态，1表示选中，0表示未选中。\",\"创建两个DP数组：dp_max 和 dp_min，分别用于存储最大和最少优惠券数。\",\"对于每个状态，将其拆分为两个子状态，计算分别购买这两部分能获得的优惠券总数。\",\"更新 dp_max 和 dp_min 数组，记录每个状态下的最优解。\",\"最终返回全选状态下的最大和最小优惠券数。\",\"代码不完全正确，只通过了 60%\",\"class Solution { public: vector<int> calc(int S, vector<int>& prices) { int n = prices.size(); int total = 1 << n; vector<int> sum(total, 0); vector<int> dp_max(total, 0); vector<int> dp_min(total, INT_MAX); for (int i = 1; i < total; i++) { for (int j = 0; j < n; j++) { if (i & (1 << j)) { sum[i] = sum[i - (1 << j)] + prices[j]; break; } } dp_min[i] = sum[i] / S; } for (int i = 1; i < total; i++) { for (int j = i; j > 0; j = (j - 1) & i) { int coupons = dp_max[j] + dp_max[i - j]; dp_max[i] = max(dp_max[i], coupons); dp_min[i] = min(dp_min[i], dp_min[j] + dp_min[i - j]); } } return {dp_max[total - 1], dp_min[total - 1]}; } };\"]},\"110\":{\"h\":\"第三题\",\"t\":[\"题面\",\"你在玩一个横版游戏。\",\"横版游戏由 N+1 个连续的格子组成。编号 0 的格子为起始点，编号 N 的格子为终点。\",\"从起点开始, 每次你最多可以往右移动 x 步（1～x 任意步都可以）。比如你在位置 1, 如果往右移动 x 步，下一个位置为 x+1。当你每次移动到某个格子的时候, 会收到伤害为 Ti​\",\"请计算从格子 0 走到 N，能够受到的最少总伤害。\",\"T[i] 的计算方式如下：\",\"T[0] = 0 state = seed for i = 1 to N: state = (state * 1103515245 + 12345) % 2^31 T[i] = 1 + (state % M)\",\"补充说明，参数取值范围:1≤N≤5000001≤x≤5000000≤seed≤231−11≤M≤109\",\"思路与代码\",\"动态规划：需要找到从起点到中电的路径，使得受到的总伤害最小。\",\"先根据给定的公式计算出所有位置的伤害值 T[i]。\",\"定义DP数组，dp[i] 表示到达位置i时的最小总伤害。\",\"初始化 dp[0] = 0，因为起点不受伤害。\",\"对于每个位置 i（从 1 到 N），考虑从 i−x 到 i−1 的所有可能的前一个位置，选择使得总伤害最小的那个。\",\"得到状态转移方程：dp[i] = min(dp[k] + T[i])，其中 k 范围是 max(0,i−x) 到 i−1。最后 dp[N] 即为所求。\",\"#include <iostream> #include <vector> #include <deque> #include <climits> #define ll long long using namespace std; const int MOD = 1 << 31; int main() { int N, x, M; ll seed; cin >> N >> x >> seed >> M; vector<int> T(N + 1); T[0] = 0; ll state = seed; for (int i = 1; i <= N; ++i) { state = (state * 1103515245 + 12345) % MOD; T[i] = 1 + (state % M); } vector<ll> dp(N + 1, LLONG_MAX); dp[0] = 0; deque<int> dq; dq.push_back(0); for (int i = 1; i <= N; ++i) { if (!dq.empty() && dq.front() < i - x) { dq.pop_front(); } dp[i] = dp[dq.front()] + T[i]; while (!dq.empty() && dp[dq.back()] >= dp[i]) { dq.pop_back(); } dq.push_back(i); } cout << dp[N] << endl; return 0; }\"]},\"111\":{\"c\":[\"For-Offer\"]},\"112\":{\"c\":[\"笔试题\"]},\"113\":{\"h\":\"慧策笔试 - 1002\"},\"114\":{\"h\":\"缺失的订单号\",\"t\":[\"题面\",\"找出缺失的订单号：假设有若干个订单号（orderId）, 它们的类型为 int, 且每个订单号在数组或列表中是唯一的。现在一个数组（大小为 n）经过某个流程处理后，缺失了一个订单号（数组大小变为 n−1），请通过算法尽可能快地找出缺失的订单号，并且写出算法的复杂度。\",\"注: 0<orderId<65536,0<n<30000\",\"思路与代码：\",\"计算两个数组的元素总和，两者之差即为缺失的订单号。\",\"public int findLostOrderId(int[] originalList, int[] lostList) { int sum1 = 0; int sum2 = 0; for (int orderId : originalList) { sum1 += orderId; } for (int orderId : lostList) { sum2 += orderId; } return sum1 - sum2; }\"]},\"115\":{\"h\":\"完全平方数\",\"t\":[\"题面\",\"将一个数拆为完全平方数之和：输入一个整数 n, 返回和为 n 的完全平方数的最少数量。\",\"注: 完全平方数是一个整数, 值等于另一个整数的平方。如 1、4、9 和 16 都是完全平方数，而 3 和 11 不是。0<n<=10000。\",\"如: 8=4+4，输出为 2；16=16，输出为 1\",\"思路与代码：\",\"转化为背包问题。其中每个完全平方数是一个物品，目标是找到最少的物品数量使得它们的和等于 n。\",\"步骤：\",\"定义 DP 数组：dp[n + 1]，其中 dp[i] 表示和为 i 的完全平方数的最少数量。\",\"初始化：dp[0] = 0，其余 dp[i] 初始化为一个较大的值。\",\"状态转移：对于每个 i(1≤i≤n)，尝试用所有小于等于 i 的完全平方数来更新 dp[i]\",\"对于每个完全平方数 j2（j2<=i），更新 dp[i] = min(dp[i], dp[i - j^2] + 1)。\",\"结果：dp[n] 即为所求的最少完全平方数的数量。\",\"public int numSquares(int n) { int[] dp = new int[n + 1]; for (int i = 1; i <= n; i++) { dp[i] = n + 1; } dp[0] = 0; for (int i = 1; i <= n; i++) { for (int j = 1; j * j <= i; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; }\"]},\"116\":{\"c\":[\"For-Offer\"]},\"117\":{\"c\":[\"笔试题\"]},\"118\":{\"h\":\"携程笔试 - 0905\"},\"119\":{\"h\":\"第一题\",\"t\":[\"题面\",\"游游有两个整数 n,k， 他希望构造出一个 1 ~ n 的排列 p, 需要 p 的最长上升子序列长度为 k，并且 p 是所有满足要求的排列中字典序最小的。最长上升子序列是一个序列中最长的严格单调递增的子序列。\",\"输入描述： 两个正整数 n,k，用空格隔开。\",\"输出描述： 输出 n 个正整数，代表构造的排列。\",\"示例：\",\"输入：5 3 输出：1 2 5 4 3\",\"思路与代码\",\"由于字典序要求最小，因此要贪心的考虑。容易想到首先构造出 1,2,3,...,k−1,n,n−1,...,k 是字典序最小的，因此直接模拟即可。\",\"#include<iostream> #include<vector> using namespace std; int main() { int n, k; cin >> n >> k; vector<int> a(n); for (int i = 0; i < k - 1; i++) { a[i] = i + 1; } a[k - 1] = n; for (int i = k, x = n - 1; i < n; i++, x--) { a[i] = x; } for (int x : a) { cout << x << \\\" \\\"; } cout << \\\"\\\\n\\\"; }\"]},\"120\":{\"h\":\"第二题\",\"t\":[\"题面\",\"一个长度为 k 的二进制字符串 (下标从 1 开始) 的权值定义如下：每次操作可以选择一个下标 i(1≤i≤k)，将 [1, i] 中的字符全部取反 (0 变成 1，1 变成 0)，字符串的权值为将字符串变成全 1 所需要的最小操作次数。\",\"即：给定一个长度为 n 的 01 字符串，问：有多少个长度为奇数并且权值为奇数的子字符串？\",\"输入描述： 第一行输入一个正整数 n ，代表字符串的长度。 第二行输入字符串 S\",\"输出描述： 输出包含一行一个整数，表示长度和权值都是奇数的非空子串数量。\",\"示例：\",\"输入：5 01010 输出：6\",\"思路与代码\",\"定义三维 dp 数组，第一个维度表示下标，第二个维度表示长度是奇数还是偶数，第三个维度表示权值是奇数还是偶数。\",\"例如：\",\"dp[i][0][0] 就表示以下标 i 结尾的长度为偶数并且权值为偶数的子字符串的数量；\",\"dp[i][0][1] 表示以下标 i 结尾的长度为偶数的权值为奇数的子字符串的数量，以此类推。\",\"dp数组的转移如代码所示：\",\"#include<iostream> #include<string> #include<vector> using namespace std; int main() { int n; cin >> n; string s; cin >> s; vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(2, 0))); long long ans = 0; for (int i = 0; i < n; i++) { if (s[i] == '1') { dp[i][1][0]++; if (i > 0) { dp[i][0][0] += dp[i - 1][1][0]; dp[i][0][1] += dp[i - 1][1][1]; dp[i][1][0] += dp[i - 1][0][0]; dp[i][1][1] += dp[i - 1][0][1]; } }else { dp[i][1][1]++; if (i > 0) { if (s[i - 1] == s[i]) { dp[i][0][0] += dp[i - 1][1][0]; dp[i][0][1] += dp[i - 1][1][1]; dp[i][1][0] += dp[i - 1][0][0]; dp[i][1][1] += dp[i - 1][0][1]; } else { dp[i][0][0] += dp[i - 1][1][0]; dp[i][0][1] += dp[i - 1][1][1]; dp[i][1][0] += dp[i - 1][0][0]; dp[i][1][1] += dp[i - 1][0][1]; } } } ans += dp[i][1][1]; } cout << ans << \\\"\\\\n\\\"; }\"]},\"121\":{\"h\":\"第三题\",\"t\":[\"题面\",\"游游喜欢数数，他想知道由 0−n 这些数字组成的 m 位数中（每个数最多使用一次），有多少个是大于 k 的。\",\"输入描述： 第一行，输入 n,m,k(1≤n≤7,1≤m≤n+1,0≤k≤108)\",\"输出描述： 输出大于 k 的数量\",\"示例：\",\"输入：5 1 0 输出：5 解释：大于 0 的是 1,2,3,4,5 这 5 个数\",\"思路与代码\",\"首先选择 m 个数位，然后求这些数位的全排列，组合在一起。要注意 0 在有多个数位的情况下不能开头。\",\"#include<iostream> #include<vector> using namespace std; vector<vector<int>> permute(vector<int>& nums) { vector<vector<int>> ans; int n = nums.size(); auto dfs = [&](auto self, vector<int> cur, int mask) { if(mask == (1 << n) - 1) { vector<int> add = cur; ans.push_back(add); return; } for(int i = 0;i < n;i++) { if((mask >> i & 1) == 0) { mask ^= (1 << i); cur.push_back(nums[i]); self(self,cur,mask); cur.pop_back(); mask ^= (1 << i); } } }; dfs(dfs,{},0); return ans; } int main() { int n, m, k; cin >> n >> m >> k; n++; int ans = 0; for (int i = 0; i < (1 << n); i++) { if (__builtin_popcount(i) == m) { vector<int> nums; for (int j = 0; j < n; j++) { if (i >> j & 1) { nums.push_back(j); } } vector<vector<int>> pers = permute(nums); for (vector<int> p : pers) { int sum = 0; if (p.size() > 1 && p[0] == 0) { continue; } for (int x : p) { sum = sum * 10 + x; } if (sum > k) { ans++; } } } } cout << ans << \\\"\\\\n\\\"; }\"]},\"122\":{\"h\":\"第四题\",\"t\":[\"题面\",\"游游有一个长度为 n 的数组 a，下标从 1 开始，一个好数组要求任意连续的 k 个元素的总和不超过 sum。 现在可以执行任意次修改，每次修改选择一个下标 i(1≤i≤n)，令 ai​=ai​−1，注意 ai​ 不能为负数。最少执行多少次操作可以满足 a 是一个好数组？\",\"输入描述： 第一行，输入 n,k,sum(1≤k≤n≤2×105,1≤sum≤1013) 第二行输入 n 个数 ai​(0≤ai​≤109)\",\"输出描述： 输出最少操作次数\",\"示例：\",\"输入：5 3 10 9 7 3 6 5 输出：10 解释：修改为 [9,1,0,5,5]，只需要操作 10 次\",\"思路与代码\",\"可以想到每次贪心的对窗口中的最后一个数进行操作，可以使得答案最优。\",\"#include<iostream> #include<vector> #include<deque> using namespace std; #define ll long long int main() { int n, k; ll sum; cin >> n >> k >> sum; vector<int> a(n); for (int i = 0; i < n; i++) { cin >> a[i]; } deque<pair<int, int>> dq; ll cur = 0; ll ans = 0; for (int i = 0; i < n; i++) { while (!dq.empty() && dq.front().first < i - k + 1) { pair<int, int> p = dq.front(); cur -= p.second; dq.pop_front(); } cur += a[i]; dq.push_back({i, a[i]}); while (cur > sum) { ll diff = cur - sum; int sub = min((ll)dq.back().second, diff); cur -= sub; dq.back().second -= sub; ans += sub; if (dq.back().second == 0) { dq.pop_back(); } } } cout << ans << \\\"\\\\n\\\"; }\"]},\"123\":{\"c\":[\"For-Offer\"]},\"124\":{\"c\":[\"笔试题\"]},\"125\":{\"h\":\"柠檬微趣笔试 - 0819\",\"t\":[\"服务器开发--随机抽题0819（Java）\"]},\"126\":{\"h\":\"求和方式\",\"t\":[\"题面\",\"给定一个正整数 s 和 n 个正整数，求有多少种组合的和为 s ？ 数值相同的两个数视为不同的两个数。\",\"输入描述: 第一行两个整数 n,s，含义如题所述； 第二行 n 个整数，1≤n≤30，1≤s≤900，1≤w≤s。\",\"输出描述: 输出一个整数表示答案。特别地，如果没有合法方案，输出 0。\",\"组合数问题，使用动态规划（DP）解决。\",\"我们需要计算从给定的 n 个数中选择若干个数，使它们的和等于 s 的方案数。由于数值相同的两个数被视为不同的数，这实际上是一个带重复元素的组合问题。\",\"创建一个 DP 数组 dp[i][j]，其中 i 表示考虑前 i 个数，j 表示当前和。dp[i][j] 的值表示使用前 i 个数得到和为 j 的方案数。\",\"初始化：dp[0][0] = 1，表示一个数都不选，和为 0 的方案数为 1。\",\"对于每个数 nums[i-1]（i 从 1 到 n）：\",\"对于每个可能的和 j（从 0 到 s）： \",\"如果不选择当前数：dp[i][j] = dp[i-1][j]\",\"如果选择当前数（前提是 j >= nums[i-1]）：dp[i][j] += dp[i-1][j - nums[i-1]]\",\"最终结果为 dp[n][s]。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取输入 int n = scanner.nextInt(); // 数字的个数 int s = scanner.nextInt(); // 目标和 int[] nums = new int[n]; for (int i = 0; i < n; i++) { nums[i] = scanner.nextInt(); } // 创建DP数组 long[][] dp = new long[n + 1][s + 1]; // 初始化：不选任何数，和为0的方案数为1 dp[0][0] = 1; // 填充DP表 for (int i = 1; i <= n; i++) { for (int j = 0; j <= s; j++) { // 不选当前数 dp[i][j] = dp[i-1][j]; // 选择当前数（如果可以） if (j >= nums[i-1]) { dp[i][j] += dp[i-1][j - nums[i-1]]; } } } // 输出结果 System.out.println(dp[n][s]); } }\"]},\"127\":{\"h\":\"实现简单的正则表达式匹配\",\"t\":[\"题面\",\"本题中模式字符串包含的字符的范围为字母，\\\".\\\", \\\"*\\\", \\\"?\\\"\",\"\\\".\\\" 匹配任何单个字符 \\\"*\\\" 与括式字符串前一个字符组成一组，匹配零个或多个前面的字符 \\\"?\\\" 与括式字符串前一个字符组成一组，匹配一个或多个前面的字符\",\"匹配应该覆盖到整个输入的字符串（而不是局部的），测试用例中不会出现超出匹配字符范围之外的字符，也不会出现非法的模式字符串。\",\"输入描述： 输入的第一行为需要检测匹配的用例数。 接下来的每一行包括两个字符串，前一个字符串为待匹配的字符串，后一个字符串为模式字符串。待匹配字符串的长度不超过 10。\",\"输出描述： 对于每一个测试用例，如果匹配则输出一行 true，如果不匹配则输出一行 false。\",\"创建一个二维布尔数组 dp，其中 dp[i][j] 表示字符串 s 的前 i 个字符是否能匹配模式串 p 的前 j 个字符。通过填充这个数组，我们可以得到最终的匹配结果。\",\"创建一个二维布尔数组 dp[m+1][n+1]，其中 m 和 n 分别是字符串 s 和模式串 p 的长度。\",\"初始化 dp[0][0] = true，表示空字符串匹配空模式。\",\"处理模式串 p 以 '*' 或 '?' 开头的特殊情况。\",\"遍历填充 dp 数组：\",\"如果 p[j-1] 是普通字符，则 dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1])\",\"如果 p[j-1] 是 '.'，则 dp[i][j] = dp[i-1][j-1]\",\"如果 p[j-1] 是 '*'，则 dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))\",\"如果 p[j-1] 是 '?'，则 dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-2] || p[j-2] == '.')\",\"返回 dp[m][n] 作为最终结果。\",\"import java.util.Scanner; public class RegexMatcher { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = Integer.parseInt(scanner.nextLine()); // 读取测试用例数量 for (int i = 0; i < n; i++) { String line = scanner.nextLine(); String[] parts = line.split(\\\" \\\"); String s = parts[0]; // 待匹配的字符串 String p = parts[1]; // 模式字符串 System.out.println(isMatch(s, p)); } } public static boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] dp = new boolean[m + 1][n + 1]; // 初始化 dp[0][0] = true; // 空字符串匹配空模式 // 处理模式 p 以 '*' 或 '?' 开头的特殊情况 for (int j = 1; j <= n; j++) { if (p.charAt(j - 1) == '*') { dp[0][j] = dp[0][j - 2]; } } // 填充 dp 数组 for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) { // 当前字符匹配 dp[i][j] = dp[i - 1][j - 1]; } else if (p.charAt(j - 1) == '*') { // '*' 可以匹配零个或多个前面的字符 dp[i][j] = dp[i][j - 2]; // 匹配零个 if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) { dp[i][j] |= dp[i - 1][j]; // 匹配一个或多个 } } else if (p.charAt(j - 1) == '?') { // '?' 必须匹配一个或多个前面的字符 if (j > 1 && (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1))) { dp[i][j] = dp[i - 1][j - 1]; } } } } return dp[m][n]; } }\"]},\"128\":{\"h\":\"野猪骑士\",\"t\":[\"题面\",\"野猪骑士要在在一条路上狩猎，整条路可以被分作 n 块地块，每个地块有自己的高度 hi​，i∈{1,2,3,…,n}。野猪骑士在地块 i 时，会看见下一块高大且离得远的集合中，高度是小于等于 hi​ 的地块，且高度最小的地块。\",\"野猪骑士要想知道自己在每个地块上的下一块的目标的高度。如果下一块不存在的话，则记为 -1。但这次野猪骑士并没有上路，他希望你来帮他狩猎。\",\"更形式化地说，给定一个数列 a，求一个数列 di​，其中如果 {hj​∣j>i&hj​>hi​} 不为空，则 di​:=min{hj​∣j>i&hj​>hi​}，否则 di​:=−1 (其中 := 表示赋值)。\",\"输入描述： 第一行包含一个正整数 n，第二行包含 n 个正整数 h1​,h2​,…,hn​。\",\"输出描述： 一行，包括 n 个正整数 d1​,d2​,…,dn​。\",\"补充说明：3≤n≤1e5,1<hi​<1e9\",\"PS:\",\"由于本题输出较多，使用 java 的同学尽量使用 StringBuilder，一次性输出答案，否则容易超时；\",\"由于本题输出较多，使用 C++ 的同学尽量使用 printf，或者关闭同步流，否则容易超时；\",\"本质上是求每个元素右侧第一个比它大的元素。\",\"我们可以使用单调栈来解决。从右往左遍历数组，维护一个单调递减的栈，栈中存储元素的下标。对于每个元素，我们弹出栈中所有比它小的元素，然后将当前元素的下标入栈。这样，栈顶元素就是当前元素右侧第一个比它大的元素。\",\"初始化一个结果数组 result，长度为 n，所有元素初始化为 −1。\",\"创建一个栈 stack，用于存储元素的下标。\",\"从右往左遍历数组（从 n−1 到 0）：\",\"当栈不为空且栈顶元素对应的高度小于等于当前元素高度时，弹出栈顶元素。\",\"如果栈不为空，栈顶元素就是右侧第一个比当前元素高的地块，将其高度赋值给 result[i]。\",\"将当前元素的下标入栈。\",\"返回结果数组。\",\"import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] heights = new int[n]; String[] input = br.readLine().split(\\\" \\\"); for (int i = 0; i < n; i++) { heights[i] = Integer.parseInt(input[i]); } int[] result = findNextHigherGround(heights); // 使用 StringBuilder 一次性输出结果 StringBuilder sb = new StringBuilder(); for (int i = 0; i < n; i++) { sb.append(result[i]).append(\\\" \\\"); } System.out.println(sb.toString().trim()); } public static int[] findNextHigherGround(int[] heights) { int n = heights.length; int[] result = new int[n]; Arrays.fill(result, -1); // 初始化结果数组为-1 Stack<Integer> stack = new Stack<>(); // 从右向左遍历 for (int i = n - 1; i >= 0; i--) { // 弹出栈中所有高度小于等于当前高度的元素 while (!stack.isEmpty() && heights[stack.peek()] <= heights[i]) { stack.pop(); } // 如果栈不为空，栈顶元素就是右侧第一个比当前元素高的地块 if (!stack.isEmpty()) { result[i] = heights[stack.peek()]; } // 将当前元素入栈 stack.push(i); } return result; } }\"]},\"129\":{\"h\":\"过生日\",\"t\":[\"题面\",\"今天是 Lemon 的生日，生日会上有游戏活动，为此需要一个游戏的排行榜。 Lemon 不想手动修改排行榜，所以想请你实现排行榜主要业务逻辑：包括加人、踢人、更新积分、查询排名 要求如下：\",\"加人、踢人、更新至少 O(n) 的最差时间复杂度\",\"查询排名至少 O(logn) 的最差时间复杂度\",\"其中输入输出部分已经实现，你只需考虑业务逻辑如何实现即可（不允许直接使用 sort, upper_bound, lower_bound）。\",\"特别说明：\",\"当玩家存在相分相同时，他们排名也相同，例如分数和排名情况为 姓名 积分 排名 Alice 100 1 Bob 80 2 Carol 80 2 Dave 70 4\",\"输入描述： 第 1 行为一个整数 N，表示总共有 N 次操作。 第 2 到第 N+1 行，每行代表一次操作，一共有四种操作：\",\"ADD role score，表示将 role以 score 的积分插入到排行榜中。\",\"DELETE role，表示将 role 从排行榜中删除。\",\"UPDATE role delta，表示将 role 的积分更新为 score+delta。\",\"SEARCH role，查询 role 的排名。\",\"输出描述： 对于每个 search，输出一个正整数表示所查的排名。\",\"这道题要求实现一个游戏排行榜系统，需要支持添加玩家、删除玩家、更新积分和查询排名等操作，且对时间复杂度有严格要求。\",\"考虑到查询排名需要 O(logn) 的复杂度，我们可以使用平衡二叉搜索树来实现。\",\"在 Java 中，我们可以使用 TreeMap 来维护玩家积分，同时使用另一个 TreeMap 来维护积分到玩家的映射，这样可以高效地处理相同积分的情况。\",\"创建两个 TreeMap：\",\"scoreMap: 用于存储玩家名称到积分的映射\",\"rankMap: 用于存储积分到玩家列表的映射\",\"实现 ADD 操作：\",\"将玩家和积分加入 scoreMap\",\"将玩家加入 rankMap 对应积分的列表中\",\"实现 DELETE 操作：\",\"从 scoreMap 中获取玩家积分并删除玩家\",\"从 rankMap 中对应积分的列表中删除该玩家\",\"实现 UPDATE 操作：\",\"从 scoreMap 中获取玩家原积分\",\"从 rankMap 中对应原积分的列表中删除该玩家\",\"更新 scoreMap 中玩家的积分\",\"将玩家加入 rankMap 中新积分对应的列表\",\"实现 SEARCH 操作：\",\"从 scoreMap 中获取玩家积分\",\"使用 rankMap 的 headMap 方法获取所有大于该积分的玩家数量\",\"计算并返回排名\",\"import java.util.*; public class LeaderBoard { // 存储玩家名称到积分的映射 private TreeMap<String, Integer> scoreMap; // 存储积分到玩家列表的映射 private TreeMap<Integer, Set<String>> rankMap; public LeaderBoard() { scoreMap = new TreeMap<>(); rankMap = new TreeMap<>(Collections.reverseOrder()); // 使用降序排列 } public void add(String role, int score) { // 将玩家和积分加入 scoreMap scoreMap.put(role, score); // 将玩家加入 rankMap 对应积分的列表中 rankMap.computeIfAbsent(score, k -> new HashSet<>()).add(role); } public void delete(String role) { // 从 scoreMap 中获取玩家积分并删除玩家 Integer score = scoreMap.remove(role); if (score != null) { // 从 rankMap 中对应积分的列表中删除该玩家 Set<String> players = rankMap.get(score); players.remove(role); if (players.isEmpty()) { rankMap.remove(score); } } } public void update(String role, int delta) { // 从 scoreMap 中获取玩家原积分 Integer oldScore = scoreMap.get(role); if (oldScore != null) { // 从 rankMap 中对应原积分的列表中删除该玩家 Set<String> players = rankMap.get(oldScore); players.remove(role); if (players.isEmpty()) { rankMap.remove(oldScore); } // 更新 scoreMap 中玩家的积分 int newScore = oldScore + delta; scoreMap.put(role, newScore); // 将玩家加入 rankMap 中新积分对应的列表 rankMap.computeIfAbsent(newScore, k -> new HashSet<>()).add(role); } } public int search(String role) { // 从 scoreMap 中获取玩家积分 Integer score = scoreMap.get(role); if (score == null) { return -1; // 玩家不存在 } // 使用 rankMap 的 headMap 方法获取所有大于该积分的玩家数量 int rank = 1; for (Map.Entry<Integer, Set<String>> entry : rankMap.headMap(score, false).entrySet()) { rank += entry.getValue().size(); } return rank; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); scanner.nextLine(); // 消耗换行符 LeaderBoard leaderBoard = new LeaderBoard(); for (int i = 0; i < N; i++) { String[] operation = scanner.nextLine().split(\\\" \\\"); switch (operation[0]) { case \\\"ADD\\\": leaderBoard.add(operation[1], Integer.parseInt(operation[2])); break; case \\\"DELETE\\\": leaderBoard.delete(operation[1]); break; case \\\"UPDATE\\\": leaderBoard.update(operation[1], Integer.parseInt(operation[2])); break; case \\\"SEARCH\\\": System.out.println(leaderBoard.search(operation[1])); break; } } scanner.close(); } }\"]},\"130\":{\"c\":[\"For-Offer\"]},\"131\":{\"c\":[\"笔试题\"]},\"132\":{\"h\":\"水滴笔试 - 0912\"},\"133\":{\"h\":\"二叉树的层序遍历\",\"t\":[\"题面\",\"给定一个二叉树，返回该二叉树层序遍历的结果，(从左到右，一层一层地遍历)\",\"例如： 给定的二叉树是 {3,9,20,#,#,15,7}，该二叉树层序遍历的结果是 [ [3],[9,20],[15,7] ]\",\"提示: $0 \\\\leq $ 二叉树的结点数 $ \\\\leq 1500$\",\"思路与代码\",\"使用队列实现层序遍历二叉树\",\"从根节点开始，将每一层的节点依次加入队列，然后逐层处理队列中的节点，直到队列为空。每一层的节点处理时，将它们的子节点加入队列，以便在下一轮处理。\",\"class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { vector<vector<int>> res; if (!root) return res; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int len = q.size(); vector<int> cur; for (int i = 0; i < len; i++) { TreeNode* node = q.front(); q.pop(); cur.push_back(node->val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } res.push_back(cur); } return res; } };\"]},\"134\":{\"h\":\"链表排序\",\"t\":[\"题面\",\"给定一个节点数为 n 的无序单链表，对其按升序排序。\",\"数据范围：0<n≤100000，保证节点权值在 [−109,109]之内。 要求：空间复杂度 O(n)，时间复杂度 O(nlogn)\",\"示例：\",\"输入：[-1,0,-2] 输出：{-2,-1,0}\",\"思路与代码\",\"归并排序模板题。\",\"归并排序在链表上实现时可以保持时间复杂度为 O(nlogn)，且空间复杂度为 O(1)\",\"步骤：\",\"分割链表：使用递归的方法将链表分割成两个子链表，直到每个子链表只有一个节点。\",\"合并链表：将两个有序的子链表合并成一个有序的链表。合并时，比较两个链表的头节点，选择较小的节点作为合并后的链表的头节点，并继续比较后续节点。\",\"递归合并：递归地合并所有子链表，直到整个链表有序。\",\"class Solution { public: ListNode* sortInList(ListNode* head) { if (!head || !head->next) return head; // 找到链表的中点 ListNode *slow = head, *fast = head->next; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } // 分割链表 ListNode *mid = slow->next; slow->next = nullptr; // 递归排序左右两部分 ListNode *left = sortInList(head); ListNode *right = sortInList(mid); // 合并两个有序链表 return merge(left, right); } ListNode* merge(ListNode* l1, ListNode* l2) { ListNode dummy(0); ListNode *tail = &dummy; while (l1 && l2) { if (l1->val < l2->val) { tail->next = l1; l1 = l1->next; } else { tail->next = l2; l2 = l2->next; } tail = tail->next; } if (l1) tail->next = l1; if (l2) tail->next = l2; return dummy.next; } };\"]},\"135\":{\"h\":\"数字组合\",\"t\":[\"题面\",\"给定一个数字 n,可以选择若干个数字，使得他们的和为 n。 其中选择的数字只能为1,5,10,25。 请问有多少种选择方式。\",\"补充说明：\",\"1≤n≤105\",\"请注意选择方案 {1,5} 等价于 {5,1}，他们只算一种方案。\",\"由于答案过大所以你需要返回答案对 109+7 取模之后的值。\",\"示例：\",\"输入：6 输出：2 说明：可以分解为六个1相加或者一个1和一个5。\",\"思路与代码\",\"动态规划：需要找到所有可能的组合方式，使得这些组合的和等于给定的数字 n。\",\"定义一个DP数组，其中 dp[i] 表示和为 i 的组合方式的数量。\",\"初始化： dp[0] = 1，因为和为 0 的组合方式只有一种，即什么都不选。\",\"状态转移： 对于每个数字 1,5,10,25，我们遍历从当前数字 x 到给定数字 n 的所有可能的和 i，更新 dp[i] 的值。\",\"即 dp[i] += dp[i - x]，表示当前的组合方式数量等于不使用当前数字时的组合方式数量加上使用当前数字时的组合方式数量。\",\"class Solution { public: int countWays(int n) { const int mod = 1e9 + 7; int a[] = {1, 5, 10, 25}; vector<int> dp(n + 1, 0); dp[0] = 1; for (int x : a) { for (int i = x; i <= n; ++i) { dp[i] = (dp[i] + dp[i - x]) % mod; } } return dp[n]; } };\"]},\"136\":{\"c\":[\"For-Offer\"]},\"137\":{\"c\":[\"笔试题\"]},\"138\":{\"h\":\"深信服笔试 - 0910\"},\"139\":{\"h\":\"第一题\",\"t\":[\"题面\",\"x,y 为正整数, 求 x 的 y 次方的个位数是多少？\",\"输入描述: 依次输入两个数（每行一个）， 第一个为 x，第二个为 y\",\"输出描述: 输出个位数\",\"示例：\",\"输入：8 198 输出：4\",\"思路与代码\",\"核心在于找出幂运算结果个位数的循环规律。对于任何正整数 x，其幂次运算的个位数都会呈现周期性变化。所以只需要计算出这个周期，然后利用模运算快速得到结果，而不需要真正计算出 x 的 y 次方这个可能非常大的数。\",\"循环周期：\",\"对于尾数为 0、1、5、6 的数，周期为 1\",\"对于尾数为 4、9 的数，周期为 2\",\"对于尾数为 2、3、7、8 的数，周期为 4\",\"根据 x 的个位数确定周期 length。\",\"计算 y%length，得到在循环中的位置。\",\"用快速幂方法计算 xy%length 的个位数，返回即可。\",\"#include <iostream> using namespace std; int quickPow(int x, int y) { int result = 1; x %= 10; while (y > 0) { if (y & 1) result = (result * x) % 10; x = (x * x) % 10; y >>= 1; } return result; } int lastDigit(int x, int y) { if (y == 0) return 1; x %= 10; int length; if (x == 0 || x == 1 || x == 5 || x == 6) length = 1; else if (x == 4 || x == 9) length = 2; else length = 4; y = y % length; if (y == 0) y = length; return quickPow(x, y); } int main() { int x, y; cin >> x >> y; cout << lastDigit(x, y) << endl; return 0; }\"]},\"140\":{\"h\":\"第二题\",\"t\":[\"题面\",\"给定存在 N 个元组的集合，每个元组里面的值为（等级，价格），等级和价格都是非负整数。在集合中选取数量大于 0 小于等于 N 的元组，要求这些元组的等级差不能超过 x，并且它们的价格之和最大。最后输出最大的价格。\",\"输入描述： 第一行包含两个整数 N 和 x(1≤n≤105,1≤x≤1010)，分别是给定的元组集合的数量和等级差。 接下来的 N 行是元组的具体数值，每一行为一个元组的两个值，等级和价格，数字之间用空格隔开。\",\"输出描述： 输出选取的元组最大的价格之和\",\"示例：\",\"输入：4 2 0 14 3 16 8 9 10 18 输出：27\",\"思路与代码\",\"排序 + 滑动窗口。\",\"核心思路是先按照等级对元组进行排序，然后使用滑动窗口来找到满足等级差不超过 x 的最大连续区间，同时维护这个区间内的价格和。\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; struct Tuple { long long level; long long price; }; int main() { int N; long long x; cin >> N >> x; vector<Tuple> tuples(N); for (int i = 0; i < N; ++i) { cin >> tuples[i].level >> tuples[i].price; } sort(tuples.begin(), tuples.end(), [](const Tuple& a, const Tuple& b) { return a.level < b.level; }); long long maxSum = 0; long long currentSum = 0; int left = 0; for (int right = 0; right < N; ++right) { currentSum += tuples[right].price; while (tuples[right].level - tuples[left].level > x) { currentSum -= tuples[left].price; left++; } maxSum = max(maxSum, currentSum); } cout << maxSum << endl; return 0; }\"]},\"141\":{\"h\":\"第三题\",\"t\":[\"题面\",\"公司新大楼要设计一片花坛，现购买了 w 种不同的花卉品种，第 i 种（1≤i≤w）花卉的花朵数量为 ai​。为设计漂亮美观的花坛，现将花坛被划分成有 n∗m 个单元格组成的网格，每个单元格中最多只能有一种花卉，并且每种花卉只能种在一个单元格里。\",\"花坛的美观度等于花坛中所有边长为 k 个单元格的正方形子网格的美观度之和，而一个子网格的美观度等于种植其中花朵数量的总和。在所有可能的情况下，请选择美观度最大的种植方案。\",\"输入描述: 第一行包含整数 n、m、k(1≤n,m≤2∗105,1≤n∗m≤2∗105,1≤k≤min(n,m))，n、m 代表行列数，k 代表子网格的边长。 第二行包含一个整数 w(1≤w≤n∗m)，表示花卉品种的数量。 第三行包含 w 个整数 a1​,a2​,...,aw​(1≤ai≤109)，表示各种花卉花朵的数量。\",\"输出描述： 最大的美观度\",\"示例：\",\"输入：3 3 2 5 1 1 1 1 1 输出：12\",\"思路与代码\",\"贪心。\",\"我们需要将花朵数量最多的花卉放在能够被最多子网格覆盖的位置，以此最大化美观度。由于每个单元格只能放置一种花卉，且每种花卉只能种在一个单元格里，我们实际上是在寻找一种最优的花卉分配方案。\",\"先计算每个单元格被覆盖的次数\",\"将子网格按被覆盖的次数从大到小排序\",\"同时，将花卉按数量从大到小排序\",\"按照排序后的顺序，将花卉依次放置到对应的单元格中，保证花朵数量最多的花卉被放置到最多覆盖的位置\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; typedef long long ll; struct Cell { int x, y, count; }; int main() { int n, m, k, w; cin >> n >> m >> k >> w; vector<ll> flowers(w); for (int i = 0; i < w; i++) { cin >> flowers[i]; } vector<vector<int>> coverage(n, vector<int>(m, 0)); for (int i = 0; i < n - k + 1; i++) { for (int j = 0; j < m - k + 1; j++) { for (int x = i; x < i + k; x++) { for (int y = j; y < j + k; y++) { coverage[x][y]++; } } } } vector<Cell> cells; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { cells.push_back({i, j, coverage[i][j]}); } } sort(cells.begin(), cells.end(), [](const Cell& a, const Cell& b) { return a.count > b.count; }); sort(flowers.rbegin(), flowers.rend()); vector<vector<ll>> garden(n, vector<ll>(m, 0)); for (int i = 0; i < min(w, (int)cells.size()); i++) { garden[cells[i].x][cells[i].y] = flowers[i]; } ll beauty = 0; for (int i = 0; i < n - k + 1; i++) { for (int j = 0; j < m - k + 1; j++) { ll subgrid_beauty = 0; for (int x = i; x < i + k; x++) { for (int y = j; y < j + k; y++) { subgrid_beauty += garden[x][y]; } } beauty += subgrid_beauty; } } cout << beauty << endl; return 0; }\"]},\"142\":{\"h\":\"第四题\",\"t\":[\"题面\",\"一个游戏玩家有 k 点体力，在一个 m∗n 的表格中，其中（k，m，n都为正整数），玩家位于 (0,0)，需要达到终点 (m,n)。玩家只能上下左右移动，且每次只能移动 1 的长度并消耗 1 的体力。当体力耗尽的时候玩家无法移动。\",\"给定 k，m，n，问玩家能否移动到终点，如能，则给出能到达终点的最短路径的走法数目。\",\"其中：0<m≤300<n≤30\",\"输入描述： 依次输入三个数（每行一个），第一个为 k，第二个为 m，第三个为 n\",\"输出描述： 如能达到终点，则输出所有路径的数目；如不能，则输出 0\",\"示例：\",\"输入：4 1 1 输出：2\",\"思路与代码\",\"动态规划。\",\"由于体力限制和路径最短的要求，我们需要考虑两个维度：位置和剩余体力。\",\"对于每个位置，我们只需要记录到达该位置时的最小体力消耗，因为这决定了是否能到达终点以及路径是否最短。\",\"维护一个DP数组 dp[i][j][k]，表示到达位置 (i,j) 时剩余体力为 k 的路径数。\",\"初始化：dp[0][0][k]=1，表示起点有一条路径。\",\"#include <iostream> #include <vector> using namespace std; long long pathCount(int k, int m, int n) { vector<vector<vector<long long>>> dp(m + 1, vector<vector<long long>>(n + 1, vector<long long>(k + 1, 0))); dp[0][0][k] = 1; for (int i = 0; i <= m; ++i) { for (int j = 0; j <= n; ++j) { for (int l = 0; l <= k; ++l) { if (i > 0 && l < k) { dp[i][j][l] += dp[i - 1][j][l + 1]; } if (j > 0 && l < k) { dp[i][j][l] += dp[i][j - 1][l + 1]; } } } } long long total = 0; for (int l = 0; l <= k; ++l) { total += dp[m][n][l]; } return total; } int main() { int k, m, n; cin >> k >> m >> n; long long result = pathCount(k, m, n); cout << result << endl; return 0; }\"]},\"143\":{\"c\":[\"For-Offer\"]},\"144\":{\"c\":[\"笔试题\"]},\"145\":{\"h\":\"滴滴笔试 - 0913\"},\"146\":{\"h\":\"最佳速通时间\",\"t\":[\"题面\",\"小C准备参加某个游戏的速通比赛，为此他对该游戏速通了 n 次，每次速通记录可以用一个数组 A={a1​,a2​,……am​} 表示，其中 ai​ 表示小C从游戏开始到第 i 个游戏节点所花赛的时间，m 为游戏节点的个数。\",\"请根据小C的速通记录计算出他的理论最佳速通时间，理论最佳速通时问指：小C在每两个相邻的游戏节点之间所花费的时间均达到了历史最佳记录，在此情况下所花费的总时间。\",\"输入描述： 第一行两个正整数 n,m，表示有 n 个速通记录，每个速通记录有 m 个游戏节点。 接下来 n 行，每行 m 个正整数，第 i 行的第 j 个数 ai,j​ 表示在第 i 次速通记录中，从游戏开始到第 j 个游戏节点所花费的时间。 对于第 i 行数据 ai,1​,ai,2​,…,ai,m​,满足 0<ai,1​<ai,2​<...<ai,m​ 数据保证：1≤n≤300,1≤m≤300,1≤ai,j​≤10000000\",\"输出描述： 一行一个整数，表示理论的最佳速通时间。\",\"示例：\",\"输入：3 5 1 4 7 9 13 2 3 8 11 14 1 3 7 12 13 输出：8\",\"思路与代码\",\"初始化一个长度为 m 的数组 a，用于存储每个游戏节点之间的最小时间差。初始值设为无穷大。\",\"初始化变量 s 用于累加理论最佳速通时间。 遍历每次速通记录：对于每次速通记录，遍历每个游戏节点。计算当前游戏节点与前一个游戏节点之间的时间差，并与 a 数组中对应位置的值进行比较，取最小值。如果当前是最后一次速通记录，则将 a 数组中的值累加到 s 中。\",\"#include <iostream> #include <vector> #include <algorithm> #include <climits> using namespace std; int main() { int m, n; cin >> m >> n; vector<int> a(n, INT_MAX); int s = 0; vector<vector<int>> nums(m, vector<int>(n)); for (int i = 0; i < m; ++i) { for (int j = 0; j < n; ++j) { cin >> nums[i][j]; } } for (int i = 0; i < m; ++i) { int pre = 0; for (int j = 0; j < n; ++j) { int cur = nums[i][j]; a[j] = min(a[j], cur - pre); pre = cur; } } for (int j = 0; j < n; ++j) { s += a[j]; } cout << s << endl; return 0; }\"]},\"147\":{\"h\":\"对比之美\",\"t\":[\"题面\",\"小美正在摆放她的收藏品。小美有一个漂亮的收藏架，有着一排 n个格子，从左到右分别编号为 1,2,…n。小美打算把她的 m 个收藏品放进这 n 个格子之中，并且尽可能摆放地好看。\",\"怎样才算好看呢？小美认为有对比才有美感，相邻两个格子收藏品数量之差越大就越美。形式化地讲，我们认为如果第 i 个格子里摆放了 ai​ 个收藏品，那么美观度为 ∑i=2n​∣ai​−ai−1​∣。小美觉得有些格子不放藏品也可以接受，即要求 ai​≥0,∑i=1n​ai​=m。请帮小美想出最美观的摆放方案！注意，∣x∣表示 x 的绝对值，∣−5∣=5,∣3∣=3。\",\"输入描述： 第一行一个整数 T 表示数据组数。 对于每组数据：一行 2 个整数分别为 n 和m，表示格子数量和收藏品数量。1≤n,m≤1000000000,1≤T≤20\",\"输出描述： 输出一行 T 个整数，表示最大的美观度，数字间有空格隔开。\",\"示例：\",\"输入：3 1 50 2 2 3 1 输出：0 2 2 提示：对于第二组，摆放为 0 2 获得美观度 2； 对于第三组，摆放为 0 1 0 获得美观度2。 可以证明没有更优方案。\",\"思路与代码\",\"思维题。\",\"显然题目把三种情况都告诉了：\",\"只有一个格子，直接输出 0\",\"两个格子，直接输出 m\",\"大于两个格子的时候，直接输出 2×m\",\"#include <iostream> using namespace std; int main() { int T; cin >> T; while (T--) { int n, m; cin >> n >> m; if (n == 1) { cout << 0 << \\\" \\\"; } else if (n == 2) { cout << m << \\\" \\\"; } else if (n > 2) { cout << 2 * m << \\\" \\\"; } } return 0; }\"]},\"148\":{\"c\":[\"For-Offer\"]},\"149\":{\"c\":[\"笔试题\"]},\"150\":{\"h\":\"瑞幸笔试 - 1010\"},\"151\":{\"h\":\"场景题\",\"t\":[\"描述\",\"你需要设计一个广告信息回传系统，需要处理用户的广告点击数据，并在后续将点击信息异步回传给外部广告平台。由于广告点击量大，系统需要在高并发下处理广告点击数据，并保证数据的及时性和准确性。同时，系统需要避免重复回传数据，以防止外部广告平台的计费重复。\",\"如何设计广告点击信息的处理流程，确保点击数据能够实时高效地被处理？\",\"思路：\",\"系统需求分析\",\"高并发处理：系统需要处理大量的广告点击数据，因此需要具备高并发处理能力。\",\"实时性：点击数据需要实时处理并回传给外部广告平台。\",\"准确性：确保数据的准确性，避免重复回传数据。\",\"避免重复计费：防止外部广告平台的计费重复。\",\"系统架构设计\",\"消息队列：使用消息队列（如Kafka）来缓冲和异步处理广告点击数据，以应对高并发场景。\",\"分布式数据库：使用分布式数据库（如Cassandra）来存储点击数据，确保数据的持久性和高可用性。\",\"去重机制：在数据处理流程中引入去重机制，确保同一点击数据不会被重复处理。\",\"处理流程设计\",\"数据采集： \",\"用户点击广告后，前端将点击数据发送到后端服务器。\",\"后端服务器将点击数据写入消息队列（如Kafka）。\",\"数据处理： \",\"消费者从消息队列中读取点击数据。\",\"消费者对点击数据进行去重处理，确保同一数据不会被重复处理。\",\"去重机制可以通过在分布式数据库中存储每个点击数据的唯一标识（如UUID）来实现。\",\"数据存储： \",\"将去重后的点击数据存储到分布式数据库中。\",\"数据库中可以设计一个字段来标记数据是否已经回传，以避免重复回传。\",\"数据回传： \",\"定时任务或事件驱动机制从数据库中读取未回传的点击数据。\",\"将数据异步回传给外部广告平台。\",\"回传成功后，更新数据库中的标记字段，表示该数据已回传\"]},\"152\":{\"h\":\"算法题\",\"t\":[\"题面\",\"假设你是瑞幸咖啡的一名运营人员，瑞幸有各种不同价格的咖啡饮品，用数组 prices 表示，其中 prices[i] 表示第 i 种咖啡饮品的价格。现在你要搭配一些咖啡套餐，每个套餐里必须包含 k 种不同的咖啡饮品。\",\"我们把咖啡套餐的 \\\"风味差异度\\\" 定义为：套餐里任意两种咖啡饮品价格差的最小值。也就是说，咖啡套餐里价格最接近的两种咖啡饮品的价格差就是这个套餐的风味差异度。\",\"你的任务是：找出所有可能的咖啡套餐中，\\\"风味差异度\\\" 最大的那个。\",\"例子：\",\"假设有四种咖啡饮品，价格分别是 1 元、3 元、5 元和 7 元。现在你要搭配 2 种咖啡饮品的套餐（也就是 k=2）。 套餐 1：1 元和 3 元的咖啡，风味差异度是 3−1=2。 套餐 2：1 元和 5 元的咖啡，风味差异度是 5−1=4。 套餐 3：1 元和 7 元的咖啡，风味差异度是 7−1=6。...（其他组合类似）\",\"从上面的例子可以看出，包含 1 元和 7 元的咖啡饮品的套餐 \\\"风味差异度\\\" 最大，为 6。所以，对于这个例子来说，答案就是 6。\",\"思路与代码：\",\"先骗分。\",\"import java.util.*; public class Solution { public int maxFlavor(int[] price, int k) { Arrays.sort(price); int n = price.length; int maxDiff = 0; for (int i = 0; i <= n - k; i++) { maxDiff = Math.max(maxDiff, price[i + k - 1] - price[i]); } return maxDiff; } }\",\"只能过 40%，总共的笔试时间只有 1 个小时，时间不够没 A 出来。\"]},\"153\":{\"c\":[\"For-Offer\"]},\"154\":{\"c\":[\"笔试题\"]},\"155\":{\"h\":\"百度笔试 - 1015\"},\"156\":{\"h\":\"最大的乘积\",\"t\":[\"题面\",\"给定四个正整数 a,b,c,d，你可以进行至多 k 次操作，每次操作可以从 a,b,c,d 中选择一个数，然后令这个数加 1，求操作后这四个正整数的乘积 a∗b∗c∗d 的最大值。\",\"输入描述： 输入包含多组测试数据。 输入第一行包含一个正整数 T(1≤T≤100)，表示测试数据组数。 接下来 T 行，每行描述一组测试数据，包含 a,b,c,d,k(1≤a,b,c,d,k≤20) 五个整数。\",\"输出描述： 输出包含 T 行。 对于每组测试数据输出一行一个整数，表示操作后这四个正整数的乘积 a∗b∗c∗d 的最大值。\",\"思路与代码：\",\"数据量小，直接模拟。\",\"先排序，每次操作将最小的数 +1，再重新排序进行下一次操作即可。\"]},\"157\":{\"h\":\"前缀染色\",\"t\":[\"题面\",\"李华有一块很长的画布，上面有 n 个位置，位置从左至右编号为 1 到 n，有 m+1 种颜色，颜色编号为 0 到 m，初始时画布上所有位置均为 0 号颜色。\",\"现在李华要对这块画布进行 m 次染色，第 i(1≤i≤m) 次染色将会把编号不大于 xi​ 的位置染成 i 号颜色，若某些位置被多次染色，则编号较大的颜色能完全覆盖编号较小的颜色。求出李华每完成一次染色后画布上的颜色种类数（包括 0 号颜色）。\",\"输入描述： 输入第一行包含两个正整数 n(1≤n≤109) 和 m(1≤m≤105)。 输入第二行包含 m 个正整数，第 i 个整数是 xi(1≤xi≤n)。\",\"输出描述： 输出包含一行 m 个整数，第 i 个整数表示第 i 次染色结束后画布上的颜色种类数。\",\"示例：\",\"输入：10 5 5 3 2 4 7 输出：2 3 4 3 2\",\"思路与代码：\",\"线段树，只能过 36%，不知道哪错了。\",\"import java.util.*; import java.io.*; public class Main { static class SegmentTree { int[] lazy; int[] tree; int n; SegmentTree(int n) { this.n = n; int size = 4 * n; lazy = new int[size]; tree = new int[size]; } void update(int node, int start, int end, int l, int r, int color) { if (lazy[node] != 0) { tree[node] = lazy[node]; if (start != end) { lazy[node * 2] = lazy[node]; lazy[node * 2 + 1] = lazy[node]; } lazy[node] = 0; } if (start > r || end < l) return; if (l <= start && end <= r) { tree[node] = color; if (start != end) { lazy[node * 2] = color; lazy[node * 2 + 1] = color; } return; } int mid = (start + end) / 2; update(node * 2, start, mid, l, r, color); update(node * 2 + 1, mid + 1, end, l, r, color); tree[node] = tree[node * 2] != 0 ? tree[node * 2] : tree[node * 2 + 1]; } void query(int node, int start, int end, Set<Integer> colors) { if (lazy[node] != 0) { tree[node] = lazy[node]; if (start != end) { lazy[node * 2] = lazy[node]; lazy[node * 2 + 1] = lazy[node]; } lazy[node] = 0; } if (start == end) { colors.add(tree[node]); return; } int mid = (start + end) / 2; query(node * 2, start, mid, colors); query(node * 2 + 1, mid + 1, end, colors); } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] nm = br.readLine().split(\\\" \\\"); int n = Integer.parseInt(nm[0]); int m = Integer.parseInt(nm[1]); String[] xStr = br.readLine().split(\\\" \\\"); int[] x = new int[m]; for (int i = 0; i < m; i++) { x[i] = Integer.parseInt(xStr[i]); } SegmentTree st = new SegmentTree(n); StringBuilder sb = new StringBuilder(); Set<Integer> colors = new HashSet<>(); for (int i = 0; i < m; i++) { st.update(1, 1, n, 1, x[i], i + 1); colors.clear(); st.query(1, 1, n, colors); sb.append(colors.size()).append(\\\" \\\"); } System.out.println(sb.toString().trim()); } }\"]},\"158\":{\"c\":[\"For-Offer\"]},\"159\":{\"c\":[\"笔试题\"]},\"160\":{\"h\":\"神州信息笔试 - 1009\"},\"161\":{\"h\":\"小乐的数字\",\"t\":[\"题面\",\"小乐乐喜欢数字，尤其喜欢 0 和 1。他现在得到了一个数，想把每位的数变成 0 或 1。如果某一位是奇数，就把它变成 1，如果是偶数，那么就把它变成 0。请你回答他最后得到的数是多少。\",\"输入描述: 输入包含一个整数 n(0≤n≤109)\",\"输出描述: 输出一个整数，表示小乐乐改后得到的数字。\",\"示例：\",\"输入：222222 输出：0\",\"思路与代码：\",\"将一个整数的每一位数字进行转换，如果某一位是奇数，则将其变为 1，如果是偶数，则将其变为 0。最终将这些转换后的数字重新组合成一个新的整数。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String str = String.valueOf(n); StringBuilder res = new StringBuilder(); for (char c : str.toCharArray()) { int x = c - '0'; if (x % 2 == 0) { res.append('0'); } else { res.append('1'); } } System.out.println(Integer.parseInt(res.toString())); } }\"]},\"162\":{\"h\":\"餐馆\",\"t\":[\"题面\",\"某餐馆有 n 张桌子，每张桌子可以最多容纳 ai​ 个人。有 m 批客人，每批客人人数为 bi​, 预计消费金额为 ci​。在不允许拼桌的情况下，请问该预订消费金额最大是多少？\",\"输入描述: 第一行两个整数 n,m(1≤n≤50000,1≤m≤50000)，分别代表桌子数和客人的批次。 第二行为 n 个整数 ai​，即每个桌子可容纳的最大人数，以空格分隔。 接下来 m 行，每行两个整数 bi​,ci​，分别表示第 i 批客人的人数和预计消费金额以空格分隔，范围均在 32 位 int 范围内。\",\"输出描述: 输出一个整数，表示最大的总预计消费金额。\",\"思路与代码：\",\"先对所有桌子按容纳人数从小到大排序，再对所有客人按消费金额从大到小排序。优先安排消费金额高的客人。\",\"对于每批客人，找到能容纳他们的最小桌子，这样就可以最大程度地利用桌子资源。即最小值最大问题，典型的二分。\",\"如果可以分配，则记录该批客人的消费金额，并标记该桌子已被占用。最后累加所有成功分配的客人的消费金额，即为最大总预计消费金额。\",\"理论上来说，这个思路是没有问题的，实际上超时了，只过了 60%。 不理解，怀疑是数据有问题。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] table= new int[n]; for (int i = 0; i < n; i++) { table[i] = sc.nextInt(); } int[][] guests = new int[m][2]; for (int i = 0; i < m; i++) { guests[i][0] = sc.nextInt(); guests[i][1] = sc.nextInt(); } Arrays.sort(table); Arrays.sort(guests, (a, b) -> b[1] - a[1]); boolean[] tableUsed = new boolean[n]; long maxTotalMoney = 0; for (int i = 0; i < m; i++) { int numGuests = guests[i][0]; int money = guests[i][1]; int index = binarySearch(tableCapacity, numGuests); if (index != -1 && !tableUsed[index]) { maxTotalMoney += money; tableUsed[index] = true; } } System.out.println(maxTotalMoney); } private static int binarySearch(int[] table, int numGuests) { int l = 0, r = table.length - 1; int res = -1; while (l <= r) { int mid = l + (r - l) / 2; if (table[mid] >= numGuests) { res = mid; r = mid - 1; } else { l = mid + 1; } } return res; } }\"]},\"163\":{\"c\":[\"For-Offer\"]},\"164\":{\"c\":[\"笔试题\"]},\"165\":{\"h\":\"美团笔试 - 0824\",\"t\":[\"24年秋招【技术】第三场\"]},\"166\":{\"h\":\"放瓶子\",\"t\":[\"题面\",\"小美初始位于 (a,b) 位置，一维平面上有 n 个瓶子，每个瓶子的位置为 (xi​,yi​)。小美每次可以向上、下、左、右移动一格，每次移动的代价为 1，小美需要移动到第一个瓶子的位置上，然后拿起瓶子把它放到 (c,d) 位置，每次最多只能拿一个瓶子，请问最少需要多少代价才能把所有瓶子都放到 (c,d) 位置上。\",\"输入描述: 第一行四个整数 a,b,c,d(−109≤a,b,c,d≤109)，表示小美初始位置和瓶子需要放置的位置。 接下来一行一个整数 n(1≤n≤105)，表示瓶子的数量。 接下来 n 行，每行两个整数 xi​,yi​(−109≤xi​,yi​≤109)，表示第 i 个瓶子的位置。\",\"输出描述: 输出一个整数，表示最少需要多少代价。\",\"贪心。\",\"我们需要计算小美从初始位置到每个瓶子的距离，然后从每个瓶子到目标位置的距离，最后将所有瓶子移动到目标位置的总距离。关键是要找出一个最优的瓶子访问顺序，以最小化总移动距离。\",\"最有访问顺序：找一个 离 (a,b) 点距离 + (c,d) 点距离最大 的点作为第一个点，其他点的移动距离都是 到 (c,d) 点距离*2\",\"计算每个瓶子到位置 (a,b) 和 (c,d) 的距离之和，取最大。\",\"计算剩余瓶子到位置 (c,d) 的距离。\",\"累加所有移动的距离即可。\"]},\"167\":{\"h\":\"最大乘积\",\"t\":[\"题面\",\"小美有三个数字 a,b,c，他每次操作可以选择一个数字将其 +1，最多可以操作 k 次，小美想知道 a×b×c 的最大值是多少？\",\"由于这个数字可能很大，因此你需要输出答案对 109+7 取模后的结果。\",\"输入描述： 第一行四个正整数 a,b,c,k(1≤a,b,c,k≤1018) 表示数字和操作次数。\",\"输出描述： 输出一个整数表示答案。\",\"贪心。\",\"应该将所有的操作次数用在最小的数字上，直到它等于或超过第二小的数字，然后再考虑第二小的数字，以此类推。这样可以最大化三个数字的乘积。\",\"将三个数字排序，使 a≤b≤c。\",\"计算将 a 增加到 b 所需的操作次数，如果 k 足够，就执行这些操作。\",\"如果还有剩余操作次数，尝试将 a 和 b 同时增加到 c。\",\"如果还有剩余操作次数，平均分配到 a、b、c 上。\",\"计算最终的 a×b×c，并对 109+7 取模。\",\"def max_product(a, b, c, k): MOD = 10**9 + 7 # 步骤1：排序确保 a <= b <= c nums = sorted([a, b, c]) a, b, c = nums # 步骤2：将 a 增加到 b diff = b - a if k >= diff: a = b k -= diff else: a += k return (a * b * c) % MOD # 步骤3：将 a 和 b 增加到 c diff = (c - a) * 2 if k >= diff: a = c b = c k -= diff else: increase = k // 2 a += increase b += increase if k % 2 == 1: a += 1 return (a * b * c) % MOD # 步骤4：平均分配剩余的操作次数 increase = k // 3 a += increase b += increase c += increase # 处理剩余的1或2次操作 if k % 3 == 1: a += 1 elif k % 3 == 2: a += 1 b += 1 # 步骤5：计算最终结果并取模 return (a * b * c) % MOD # 读取输入 a, b, c, k = map(int, input().split()) # 计算并输出结果 result = max_product(a, b, c, k) print(result)\"]},\"168\":{\"h\":\"牛牛商店\",\"t\":[\"题面\",\"牛牛商店里只卖两种商品，\\\"牛可乐\\\"和\\\"牛马克\\\"。\",\"现在有 n 个人来到商店购物，第 i 个人有喜好区间 [li​,ri​] 和购买目标商品，他只看货架上位于区间里的商品，并从中挑选 ki​ 个保质期最长的牛可乐或者牛马克走（如果有多个商品保质期相同，他会拿走区间中靠前的那个）。你能告诉牛牛每个人买走的商品编号吗？\",\"输入描述： 第一行输入两个整数 n 和 m(1≤n,m≤105) 代表来牛牛商店购物的人数和商品数量。 第二行输入 m 个整数 a1​,a2​…am​(1≤ai​<109) 代表商品的保质期。 第三行输入 m 个整数 b1​,b2​…,bm​(0≤bi​≤1) 代表商品的种类，其中，bi​=0 代表\\\"牛可乐\\\"，bi​=1 代表\\\"牛马克\\\"。 此后 n 行，第 i 行输入四个整数 li​,ri​,ti​ 和 ki​(1≤li​≤ri​≤m;0≤ti​≤1;1≤ki​≤m) 代表第 i个人的喜好区间、购买商品种类和购买数量。其中，ti​=0 代表他想要买\\\"牛可乐\\\"，ti​=1 代表他想要买\\\"牛马克\\\"。\",\"输出描述： 输出 n 行，第 i 行输出至多 ki​ 个整数，代表第 i 个人购买的商品编号（如果有多个商品保质期相同，输出编号较小的那个）。你需要按照从小到大的顺序依次输出；如果没有买到足够的商品，使用一个 −1 替代。\",\"核心是高效地在指定区间内找出保质期最长的特定类型商品。考虑到数据规模 (n,m≤105)，我们需要一个能够在 O(logn) 时间内查询区间最大值的数据结构。即线段树。\",\"构建两个线段树，分别用于存储牛可乐和牛马茶的保质期信息。\",\"在线段树中，每个节点存储该区间内的最大保质期和对应的最小商品编号。\",\"对于每个顾客的查询：\",\"在对应类型的线段树上查询指定区间 [li​,ri​] 内的最大保质期商品。\",\"如果找到符合条件的商品，记录其编号，并在线段树中将该商品的保质期设为 −1（表示已售出）。\",\"重复上述过程 ki​ 次或直到无法找到更多符合条件的商品。\"]},\"169\":{\"c\":[\"For-Offer\"]},\"170\":{\"c\":[\"笔试题\"]},\"171\":{\"h\":\"美团笔试 - 0831\",\"t\":[\"24年秋招【技术】第四场\"]},\"172\":{\"h\":\"小美的姓名统计\",\"t\":[\"题面\",\"小美写单词喜欢横着写，她记录了若干个人的名字，但是不小心加进去了一些无关的单词。 一个名字单词以大写字母开头，请你帮助她统计共有多少个人的名字.\",\"输入描述： 在一行上输入一个长度为 n(1≤n≤105)、且由大小写字母和空格混合构成的字符串 s 代表小美的全部单词，每个单词之间使用空格间隔。 除此之外，保证字符串的开头与结尾字符不为空格。\",\"输出描述： 在一行上输出一个整数，代表人名的个数。\",\"简单模拟。判断每一个字符的首字母是否为大写即可，注意空格。\",\"#include <iostream> #include <string> using namespace std; int main() { string s; getline(cin, s); int count = 0; int n = s.length(); for (int i = 0; i < n; i++) { if (isupper(s[i]) && (i == 0 || s[i-1] == ' ')) { count++; } } cout << count << endl; return 0; }\"]},\"173\":{\"h\":\"小美种树\",\"t\":[\"题面\",\"长度无限长的公路上，小美雇佣了 n 位工人来种树，每个点最多种一棵树。 从左向右数，工人所站的位置为 a1​,a2​,…,an​ 。已知每位工人会将自己所在位置的右侧一段长度的区间种满树，且每位工人的种树区间长度相同。 现在小美希望公路上至少有 k 棵树，为了节约成本，他希望位工人种树的区间长度可能短，请你帮他求出，工人们的种树区间至少多长，才能使得公路被种上至少 k 棵树。\",\"输入描述： 第一行输入两个正整数 n,k(1≤n,k≤2×105)，分别表示工人的数量，以及小美要求的最少数量。 第二行输入 n 个正整数 a1​,a2​,…,an​(1≤ai​≤2×105)，表示每名工人的位置。\",\"输出描述： 在一行上输出一个整数，代表工人们最短的种树区间长度。\",\"二分答案。\",\"先对工人的位置进行排序。\",\"二分枚举种树区间，初始化左边界 l = 0，右边界 r = a_n。\",\"每次二分后判断：当前种树区间为 x 的情况下，是否可以种 k 棵树？超过则缩小，不够则增加。\",\"判断逻辑：end 记录的是上一次种到的边界，当前可以种的边界应该是 pos + x - 1，只要保证不会超过边界即可。\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; bool check(vector<int>& pos, int x, int k) { int n = pos.size(); int cnt = 0; int end = 0; for (int i = 0; i < n; i++){ int p = pos[i] + x - 1; if (pos[i] > end){ cnt += p - pos[i] + 1; end = p; } else { cnt += p - end; end = p; } } return cnt >= k; } int main() { int n, k; cin >> n >> k; vector<int> v(n); for (int i = 0; i < n; ++i) { cin >> v[i]; } sort(v.begin(), v.end()); int l = 1, r = v.back(); while (l < r) { int mid = l + (r - l) / 2; if (check(v, mid, k)) { r = mid; } else { l = mid + 1; } } cout << l << endl; return 0; }\"]},\"174\":{\"h\":\"小美和小团的游戏\",\"t\":[\"题面\",\"小美和小团在玩一个游戏，游戏中有一个长度为 n 的数组 a，她们会玩 q 轮游戏，每轮游戏都是独立的。\",\"游戏规则如下，双方都会执行最优策略：\",\"第一步，游戏给出一个区间 [l, r]。\",\"第二步，小团在 [l, r] 区间中选择一个数。\",\"第三步，小美将区间扩展为 [L, R]（[L, R] 必须包含 [l,r]），然后在 [L, R] 区间中选择一个数，但不能跟小团选择同一个数。\",\"第四步，小美和小团选择的数字较大的一方获胜，若相同则平局。\",\"小美想知道自她每一轮的输赢状态，并且她想知道要达到输赢状态所需的 [L,R] 区间长度最小是多少。\",\"输入描述： 第一行输入两个整数 n,q(2≤n,q≤2×105)，表示数组长度和询问次数。 第二行输入 n 个整数 a(1≤ai≤109)，表示数组。 接下来 q 行，每行输入两个整数 (1≤l≤r≤n)，表示询问。\",\"输出描述： 对于每个询问输出一行，若小美以获胜输出 \\\"win\\\"，若平局则输出 \\\"draw\\\"，失败则输出 \\\"lose\\\"。 第二行输出达到最终状态所需的区间长度的最小值。\",\"ST表 + 单调栈 + 二分\",\"使用ST表预处理，便于后续求出 [l, r] 区间的最大值的下标。\",\"对于每一个元素使用单调栈处理，方便求每一个元素下一个更大的元素的下标。\",\"如果 [l, r] 的区间的最大值已经是整个数组的最大值，那么此时的判断就非常清晰：\",\"最大值的数量超过 2 个，那么必然是平局，我们只需要搜索距离区间最近的最大值即可。\",\"否则一定是输的，此时需要特判一下，如果区间大小只有 1，那么最少需要扩大一个才可以选择。\",\"否则，应该使用ST表找到当前区间的最大值的下标 mx_index，并且使用单调栈找到 mx_index 的下一个更大的元素/前一个更大的元素，比较哪个更接近即可。\",\"#include <iostream> #include <vector> #include <cmath> #include <algorithm> #include <map> #include <climits> using namespace std; int n, q; vector<int> arr; vector<int> log; vector<vector<int>> table; void init() { log.resize(n + 1, 0); for (int i = 2; i <= n; ++i) { log[i] = log[i / 2] + 1; } table = vector<vector<int>>(n, vector<int>(log[n] + 1, 0)); for (int i = 0; i < n; ++i) { table[i][0] = i; } for (int j = 1; (1 << j) <= n; ++j) { for (int i = 0; i <= n - (1 << j); ++i) { int left_idx = table[i][j - 1]; int right_idx = table[i + (1 << (j - 1))][j - 1]; table[i][j] = (arr[left_idx] >= arr[right_idx]) ? left_idx : right_idx; } } } int rmq(int l, int r) { int s = log[r - l + 1]; int left_idx = table[l][s]; int right_idx = table[r - (1 << s) + 1][s]; return (arr[left_idx] >= arr[right_idx]) ? left_idx : right_idx; } int main() { cin >> n >> q; arr.resize(n); log.resize(n + 1, 0); for (int &a : arr) { cin >> a; } init(); vector<int> sk; vector<int> rights(n, -1); for (int i = 0; i < n; ++i) { while (!sk.empty() && arr[sk.back()] <= arr[i]) { rights[sk.back()] = i; sk.pop_back(); } sk.push_back(i); } sk.clear(); vector<int> lefts(n, -1); for (int i = n - 1; i >= 0; --i) { while (!sk.empty() && arr[sk.back()] <= arr[i]) { lefts[sk.back()] = i; sk.pop_back(); } sk.push_back(i); } int MAX = *max_element(arr.begin(), arr.end()); int cnt = count(arr.begin(), arr.end(), MAX); vector<int> max_indexs; for (int i = 0; i < n; ++i) { if (arr[i] == MAX) { max_indexs.push_back(i); } } while (q--) { int l, r; cin >> l >> r; --l; --r; int mx_index = rmq(l, r); if (arr[mx_index] == MAX) { if (cnt >= 2) { cout << \\\"draw\\\" << endl; int left = lower_bound(max_indexs.begin(), max_indexs.end(), l) - max_indexs.begin(); int right = upper_bound(max_indexs.begin(), max_indexs.end(), r) - max_indexs.begin() - 1; if (left < right) { cout << r - l + 1 << endl; } else { int ans = INT_MAX; if (left > 0) { ans = min(ans, max_indexs[left] - l); } if (right < max_indexs.size() - 1) { ans = min(ans, r - max_indexs[right]); } cout << r - l + 1 + ans << endl; } } else { cout << \\\"lose\\\" << endl; cout << (l == r ? 2 : r - l + 1) << endl; } } else { int L = (lefts[mx_index] != -1) ? lefts[mx_index] : INT_MIN; int R = (rights[mx_index] != -1) ? rights[mx_index] : INT_MAX; cout << \\\"win\\\" << endl; cout << min(R - r, l - L) + (r - l + 1) << endl; } } return 0; }\"]},\"175\":{\"c\":[\"For-Offer\"]},\"176\":{\"c\":[\"笔试题\"]},\"177\":{\"h\":\"飞鱼科技笔试 - 1013\"},\"178\":{\"h\":\"第一题\",\"t\":[\"题面\",\"给定一个长度为 n 的仅包含正整数的数组，另外有一些操作，每次操作你可以选择数组中的任意一个元素 ai​ ，同时数组中所有等于 ai​−1 和 ai​+1 的元素会被全部移除，同时你可以得到 ai​ 分，直到所有的元素都被选择或者删除。\",\"请你计算最多能得到多少分。\",\"数据范围：数组长度满足 1≤n≤105 ，数组中的元素大小都满足 1≤ai​≤104\",\"输入描述： 第一行输入一个正整数 n 表示数组的长度； 第二行输入 n 个数字表示数组的各个元素值。\",\"输出描述： 输出所得到的最大分数。\",\"示例：\",\"输入：3 1 2 3 输出：4\",\"思路与代码：\",\"动态规划。\",\"将问题转化为一个选择问题，即在数组中选择一些元素，使得得分最大化。每次选择一个元素 ai​ 时，所有等于 ai​−1 和 ai​+1 的元素会被移除，因此可以将问题转化为在一个数组中选择不相邻的元素，使得得分最大化。\",\"步骤：\",\"预处理：统计数组中每个元素出现的频率。由于数组中的元素大小都满足 1≤ai​≤104，我们可以使用一个大小为 104+1 的数组 cnt 来存储每个元素的频率。\",\"定义 DP 数组：dp[i] 表示选择元素 i 时的最大得分。\",\"状态转移：对于每个元素 i，有两种选择： \",\"不选择元素 i，则 dp[i] = dp[i - 1]\",\"选择元素 i，则 dp[i] = dp[i - 2] + i * cnt[i]\",\"初始化：dp[0] = 0，dp[1] = cnt[1]\",\"最终结果为 dp[10000]，即选择元素 10000 时的最大得分。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i++) { a[i] = sc.nextInt(); } int mx = 10000; int[] cnt = new int[mx + 1]; for (int x : arr) { cnt[x]++; } int[] dp = new int[mx + 1]; dp[1] = cnt[1]; for (int i = 2; i <= mx; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * cnt[i]); } System.out.println(dp[mx]); } }\"]},\"179\":{\"h\":\"第二题\",\"t\":[\"题面\",\"有一个长度为 n 的数组，请你找到出现次数大于等于数组长度一半的数。\",\"输入描述: 第一行一个正整数 n，表示数组的长度，长度不超过 100。 第二行 n 个正整数，表示数组的元素。保证仅有一个数满足要求。\",\"输出描述: 输出出现次数大于等于数组长度一半的数。\",\"示例：\",\"输入：12 3 9 3 2 5 6 7 3 2 3 3 3 输出：3\",\"思路与代码：\",\"遍历数组，使用一个 HashMap 统计每个元素出现的次数。\",\"再次遍历哈希表，找到出现次数大于等于 2n+1​ 的元素。因为题目保证有解。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i++) { a[i] = sc.nextInt(); } Map<Integer, Integer> map = new HashMap<>(); for (int x : arr) { map.put(x, map.getOrDefault(x, 0) + 1); } for (Map.Entry<Integer, Integer> entry : map.entrySet()) { if (entry.getValue() >= (n + 1) / 2) { System.out.println(entry.getKey()); return; } } } }\"]},\"180\":{\"h\":\"第三题\",\"t\":[\"题面\",\"小红正在玩一个游戏。游戏的地图是一个 n × m 的迷宫，迷宫有墙和道路，道路上可能会有一些怪物。 小红初始的血量是 h ，每当小红经过一个有怪物的道路时，小红就会和怪物战斗，击杀怪物并且消耗自己的血量。小红消耗的血量等同于该怪物的战斗力。 请注意，如果小红血量为 0 则死亡。因此只有当小红当前血量大于怪物的战斗力时才可经过该点。\",\"地图其有以下几种标识:'.' 代表道路，小红可以经过。'#' 代表墙体，小红不能经过。'1'-'9' 数字，代表该位置是个道路，且上面有一个战斗力为该数字的怪物。 小红只可以上下左右四个方向移动。\",\"小红想知道，自己从左上角到右下角的最短行走路径的距离是多少？\",\"输入描述： 第一行三个正整数 n，m 和 h，用空格隔开。 接下来的 n 行，每行一个长度为 m 的字符串，用来表示地图，保证输入是合法的。 数据范围：2≤n,m,h≤50，且怪物的数量不超过 10 个。保证左上角和右下角都是道路且没有怪物。\",\"输出描述： 如果小红无法到达右下角，则输出 −1，否则输出一个正整数，代表小红走的路径长度最小值。\",\"示例：\",\"输入：3 3 3 . 1 1 . * . 2 2 . 输出：4 解释：先向右走两步，再向下走两步，到达右下角时血量为1； 如果先向下走两步，小红不可能击杀掉所有怪物。\",\"思路与代码：\",\"BFS。\",\"我们需要找到从左上角到右下角的最短路径，同时要考虑路径上的怪物对小红血量的影响。由于地图规模较小，可以使用 BFS 来解决这个问题。BFS 能够保证在找到路径时是最短的，同时我们需要在 BFS 的过程中维护小红的血量状态。\",\"import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int h = sc.nextInt(); sc.nextLine(); char[][] g = new char[n][m]; for (int i = 0; i < n; i++) { g[i] = sc.nextLine().toCharArray(); } System.out.println(bfs(g, n, m, h)); } private static int bfs(char[][] g, int n, int m, int h) { Queue<int[]> q = new LinkedList<>(); boolean[][][] vis = new boolean[n][m][h + 1]; int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; q.offer(new int[]{0, 0, 0, h}); vis[0][0][h] = true; while (!q.isEmpty()) { int[] cur = queue.poll(); int x = cur[0], y = cur[1], dist = cur[2], health = cur[3]; if (x == n - 1 && y == m - 1) return dist; for (int[] d : dir) { int xx = x + d[0], yy = y + d[1]; if (xx >= 0 && xx < n && yy >= 0 && yy < m && g[xx][yy] != '#') { int newHealth = health; if (g[xx][yy] >= '1' && g[xx][yy] <= '9') { int num = grid[xx][yy] - '0'; if (health <= num) continue; newHealth -= num; } if (!vis[xx][yy][newHealth]) { vis[xx][yy][newHealth] = true; q.offer(new int[]{xx, yy, dist + 1, newHealth}); } } } } return -1; } }\"]},\"181\":{\"h\":\"第四题\",\"t\":[\"题面\",\"编写 SQL 语句，组合 Products 表中的产品名称（prod_name）和 Customers 表中的顾客名称（cust_name）并返回，然后按产品名称对结果进行升序排序。\",\"【示例】 Products 表含有字段 prod_name 代表产品名称\",\"prod_name\",\"flower\",\"rice\",\"ring\",\"umbrella\",\"Customers 表代表顾客信息，cust_name 代表顾客名称\",\"cust_name\",\"andy\",\"ben\",\"tony\",\"tom\",\"an\",\"lee\",\"hex\",\"【示例结果】\",\"prod_name\",\"an\",\"andy\",\"ben\",\"flower\",\"hex\",\"lee\",\"rice\",\"ring\",\"tom\",\"tony\",\"umbrella\",\"【示例解析】 拼接 cust_name 和 prod_name 并根据结果升序排序\",\"思路与代码：\",\"从 Products 表中选择 prod_name，从 Customers 表中选择 cust_name，将 prod_name 和 cust_name 合并到一个结果集中。\",\"最后按 prod_name 对合并后的结果进行升序排序。\",\"SELECT prod_name FROM Products UNION SELECT cust_name FROM Customers ORDER BY prod_name ASC;\"]},\"182\":{\"h\":\"第五题\",\"t\":[\"题面\",\"假设农场中成熟的母牛每年只会生 1 头小母牛，并且永远不会死。第一年农场中有一只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟，可以生小母牛。\",\"给定整数 n，求出 n 年后牛的数量。\",\"输入描述： 输入一个整数 n(1≤n≤1018)\",\"输出描述： 输出 n 年后牛的数量对 109+7 取模的值。\",\"示例：\",\"输入：6 输出：9\",\"思路与代码：\",\"动态规划。\",\"定义 DP 数组：设 dp[i] 表示第 i 年牛的数量。\",\"初始状态：dp[1] = 1，因为第一年只有一头成熟的母牛。\",\"状态转移： \",\"第 i 年的牛的数量由以下几部分组成：\",\"第 i−1 年的所有牛（因为牛不会死）。\",\"第 i−3 年的所有牛（因为这些牛在第 i 年已经成熟并且可以生小母牛）。\",\"因此，状态转移方程为：dp[i] = dp[i - 1] + dp[i - 3]。\",\"边界条件： 由于 dp[i - 3] 在 i<4 时会越界，所以我们需要特别处理 i<4 的情况： \",\"dp[2] = 2\",\"dp[3] = 3\",\"取模操作： 由于结果可能非常大，我们需要对结果取模 109+7。\",\"public class Main { public static void main(String[] args) { long n = Long.parseLong(System.console().readLine()); if (n == 1) { System.out.println(1); return; } long mod = 1_000_000_007; long[] dp = new long[(int) (n + 1)]; dp[1] = 1; dp[2] = 2; dp[3] = 3; for (int i = 4; i <= n; i++) { dp[i] = (dp[i - 1] + dp[i - 3]) % mod; } System.out.println(dp[(int) n]); } }\",\"上述写法会报栈溢出错误，只能过 10%\",\"写不出来了，待更新...\",\"解析：矩阵快速幂技巧练习——母牛问题\"]},\"183\":{\"c\":[\"For-Offer\"]},\"184\":{\"c\":[\"笔试题\"]},\"185\":{\"h\":\"另一棵树的子树\",\"t\":[\"572.另一棵树的子树\"]},\"186\":{\"h\":\"题意\",\"t\":[\"给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。\",\"二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。\"]},\"187\":{\"h\":\"思路一\",\"t\":[\"直接递归判断:\",\"如果 subRoot 为空，则和叶节点的空子节点匹配，返回 true\",\"如果当前节点是空节点，无法与 subRoot 匹配，返回 false。\",\"如果当前节点与 subRoot 根节点相同，则递归往下判断，如果是相同的树，返回 true。\",\"否则，递归左右子树，看是否能找到匹配的，如果找到则返回 true。\",\"代码:\",\"class Solution { boolean isSametree(TreeNode p, TreeNode q) { if (p == null || q == null) return p == q; return p.val == q.val && isSametree(p.left, q.left) && isSametree(p.right, q.right); } public boolean isSubtree(TreeNode root, TreeNode subRoot) { if (subRoot == null) return true; if (root == null) return false; return isSametree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); } }\"]},\"188\":{\"h\":\"思路二（优化）\",\"t\":[\"只在高度相同时匹配\"]},\"189\":{\"c\":[\"数据结构\"]},\"190\":{\"c\":[\"二叉树\",\"递归\"]},\"191\":{\"h\":\"牛客模考题\"},\"192\":{\"h\":\"VC1 牛牛吃草\"},\"193\":{\"h\":\"描述\",\"t\":[\"现在有一排 n 块草地，第 i 块草地上有 wi​ 斤草，以及一个数字 ai​。当牛牛在第 i 块草地上时，他可以吃掉这个草地上所有的草，并且向右走到另一块草地。但是牛牛有强迫症，他向右走的距离必须是 ai​ 的整数倍。例如：当牛牛在第 3 块草地，并且 a3​=2 时，他下一步就只能前往第 5,7,9,…, 块草地。\",\"牛牛可以从任意一块草地开始不断的吃草并移动到下一个草地，并且可以在任意一块草地结束它的吃草之旅。\",\"现在请问，牛牛在一次吃草之旅中，最多可以吃掉多少斤草？\",\"输入描述：\",\"第一行一个整数 n(1≤n≤103)\",\"接下来一行 n 个整数表示 wi​(1≤wi​≤100)\",\"最后一行 n 个整数表示 ai​(1≤ai​≤10)\",\"输出描述：\",\"一个整数，表示答案。\",\"示例\",\"输入：5 3 5 20 7 5 1 2 5 1 3 输出：23 说明：从第1块草地走到第3块，总草数为3+20=23\"]},\"194\":{\"h\":\"题解\",\"t\":[\"简单的线性DP，可以理解为背包问题：每块草地，满足条件就吃，不满足就吃不了。\",\"状态转移方程：f[i] 表示到达第 i 块草地能吃的最大值，第 i 块能吃的量 = 前面任意一块能到达 i 位置的量 + 第 i 块的量，即：\",\"f[i] = max(f[前1块能到达草地的最大值], f[i - 1] + w[i])\",\"#include <iostream> #include <cmath> using namespace std; const int N = 1010; int n; int w[N], a[N]; int f[N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> w[i]; f[i] = w[i]; } for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++){ for (int j = 1; j < i; j++){ if ((i - j) % a[j] == 0){ f[i] = max(f[i], f[j] + w[i]); } } } int res = 0; for (int i = 1; i <= n; i++){ if (f[i] > res) res = f[i]; } cout << res << endl; return 0; }\"]},\"195\":{\"h\":\"VC2 棋盘\"},\"196\":{\"h\":\"描述\",\"t\":[\"现在有一个 n×m 的棋盘，每一个格子中有一个数字，其中第 i 行第 j 列的格子中的数字为 ai,j​，并且这个格子的权重为 bi,j​​，当你在一个格子时，你可以选择一个与他相临的格子到达，但是那个格子上面的数字 x 不能小于当前所在格子的数字与权值之和（两个格子相临当且仅当他们有一条公共的边）。例如：当前所在格子上面的数字为 3，权重为 5，则你下一步能够到达的格子上面的数字至少为 8。\",\"现在给你 q 次询问，每次询问给定一个格子 (x,y)，要求你回答：从任意一个格子出发，最后到达这个格子的方案有多少种。两种方案不同，当且仅当这两种方案经过的格子序列不同。\",\"输入描述：\",\"第一行两个整数 n,m(1≤n,m≤1000)\",\"接下来 n 行每行 m 个整数，表示 ai,j​(1≤ai​,j≤105)\",\"接下来 n 行每行 m 个整数，表示 bi,j​(1≤bi​,j≤103)\",\"接下来一行一个整数 q(1≤q≤105)\",\"之后 q 行每行两个整数 x,y(1≤x≤n,1≤y≤m)\",\"输出描述：\",\"输出包含 q 行，每行一个整数表示对应询问的答案。由于答案可能很大，你只需要输出它对 100007 取模的值即可。\",\"示例\",\"输入：3 3 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1 1 1 1 3 1 2 2 2 3 3 输出：2 5 19 说明：对于第一个询问，合法路径共有[(1,1),(1,2)],[(2,2)]两条 对于第二个询问，合法路径共有[(1,1),(1,2),(2,2)],[(1,1),(2,1),(2,2)],[(1,2),(2,2)],[(2,1),(2,2)],[(2,2)]五条。\"]},\"197\":{\"h\":\"题解\",\"t\":[\"DFS 的倒序遍历，以给定的 (x,y) 为起点，查找符合条件的格子即可。\",\"#include <iostream> #include <vector> #include <cmath> using namespace std; const int N = 1010; const int mod = 100007; int n, m; int a[N][N], b[N][N]; int q; int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1}; int st[N][N]; int dfs(int x, int y) { if (st[x][y]) return st[x][y]; st[x][y] = 1; int cnt = 0; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && a[xx][yy] + b[xx][yy] <= a[x][y]){ st[x][y] += dfs(xx, yy); } } st[x][y] %= mod; return st[x][y]; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++){ for (int j = 1; j <= m; j++) cin >> a[i][j]; } for (int i = 1; i <= n; i++){ for (int j = 1; j <= m; j++) cin >> b[i][j]; } cin >> q; while (q--){ int x, y; cin >> x >> y; cout << dfs(x, y) << endl; } return 0; }\"]},\"198\":{\"h\":\"VC28 染色\"},\"199\":{\"h\":\"描述\",\"t\":[\"给你一个长度为 n 的数组 {an​}，以及 q 次操作。每次操作给定两个数 x,y 表示将原数组中所有的 x 变为 y。请问 q 次操作后数组变成了什么样子？\",\"输入描述：\",\"第一行一个整数 n(1≤n≤2∗105)\",\"接下来一行 n 个整数 ai​(1≤ai​≤n)\",\"第三行一个整数 q(1≤q≤2∗105)\",\"接下来 q 行每行两个整数 x,y(1≤x,y≤n)\",\"输出描述：\",\"一行 n 个整数，表示答案。\",\"示例\",\"输入：5 1 2 3 4 5 4 1 4 2 3 3 5 5 1 输出：4 1 1 4 1\"]},\"200\":{\"h\":\"题解\",\"t\":[\"涉及到链表的操作，本质上是一种并查集的思想。\",\"list::splice\",\"list::splice 实现 list 拼接的功能。将原 list 的内容部分或全部元素删除，拼插入到目的 list。\",\"函数有以下三种声明：\",\"一：void splice ( iterator position, list<T,Allocator>& x ); 二：void splice ( iterator position, list<T,Allocator>& x, iterator it ); 三：void splice ( iterator position, list<T,Allocator>& x, iterator first, iterator last );\",\"解释：\",\"position 是要操作的 list 对象的迭代器list&x 被剪的对象\",\"对于一：会在 position 后把 list&x 所有的元素到剪接到要操作的 list 对象 对于二：只会把 it 的值剪接到要操作的 list 对象中 对于三：把 first 到 last 剪接到要操作的 list 对象中\",\"#include <iostream> #include <unordered_map> #include <list> using namespace std; const int N = 2e5 + 10; int n; int a[N]; int q; int main() { cin >> n; unordered_map<int, list<int>> cnt; for (int i = 1; i <= n; i++){ cin >> a[i]; cnt[a[i]].push_back(i); } cin >> q; while (q--){ int x, y; cin >> x >> y; if (x == y) continue; // 归并 cnt[y].splice(cnt[y].end(), cnt[x]); } for (auto [x, idx] : cnt){ for (auto i : idx){ a[i] = x; // 更新操作 } } for (int i = 1; i <= n; i++) cout << a[i] << ' '; return 0; }\"]},\"201\":{\"h\":\"VC35 正则匹配\"},\"202\":{\"h\":\"描述\",\"t\":[\"给你 n 个字符串 a1​,a2​,a3​,…,an​，现在有 q 次询问，每次询问给你一个字符串 t，请你计算出他是原来 n 个字符串中多少字符串的前缀。\",\"输入描述：\",\"第一行一个整数 n(1≤n≤1000)\",\"接下来 n 行每行一个仅包含小写字母的字符串表示 ai​(∣ai​∣≤100)\",\"之后一个整数 q(1≤q≤1000)\",\"接下来 q 行每行一个仅包含小写字母的字符串 t(∣t∣≤100)\",\"输出描述：\",\"对于每次询问，输出一个整数表示答案。\",\"示例\",\"输入：3 abaab aabab abbbb 3 ab abb a 输出：2 1 3\"]},\"203\":{\"h\":\"题解\",\"t\":[\"字典树解法。\",\"#include <iostream> #include <vector> using namespace std; const int N = 1e6 + 10; int n, q; vector<vector<int>> nodes; vector<int> end_idx; int id = 0; // 构建字典树，遍历添加字符串 void build_tree(string& s) { int node_id = 0; for (auto c : s){ int idx = c - 'a'; if (nodes[node_id][idx] == 0){ id++; nodes[node_id][idx] = id; } node_id = nodes[node_id][idx]; } end_idx[node_id]++; } int dfs(int id) { if (id == 0) return 0; int sum = end_idx[id]; for (int i = 0; i < 26; i++){ sum += dfs(nodes[id][i]); } return sum; } // 获取叶子节点的个数 int count(string& t) { int node_id = 0; for (auto c : t){ int idx = c - 'a'; node_id = nodes[node_id][idx]; if (node_id == 0) return 0; } return dfs(node_id); } int main() { cin >> n; nodes = vector<vector<int>>(N, vector<int>(26, 0)); end_idx = vector<int>(N, 0); for (int i = 1; i <= n; i++){ string s; cin >> s; build_tree(s); } cin >> q; while (q--){ string t; cin >> t; cout << count(t) << endl; } return 0; }\"]},\"204\":{\"h\":\"VC40 购物\"},\"205\":{\"h\":\"描述\",\"t\":[\"有 n 个人，m 个队列，第 i 个人在 ai​ 时到达，需要 si​ 时间购买商品。 第 i 个人到达后会选择当前等待时间最少的队伍，如果有多个队伍则会选择编号最小的队伍。 请求出 n 个人需要多长时间购买完成。 保证到达时间互不相同。\",\"输入描述：\",\"第一行两个整数 n,m(n,m≤105) 随后 n 行每行两个整数，ai​ 和 si​(ai​,si​≤109)\",\"输出描述：\",\"输出 n 个人需要多长时间购买完成。\",\"示例\",\"输入：4 3 1 2 2 3 3 4 4 1 输出：7\"]},\"206\":{\"h\":\"题解\",\"t\":[\"线段树。\",\"使用线段树维护每个队列的等待时间即可。\",\"#include <iostream> #include <vector> #include <algorithm> #define ll long long using namespace std; const int N = 1e6 + 10; int n, m; pair<ll, ll> nums[N]; vector<ll> seg(N), seg2(N); // 两个线段树 ll ret(0); void pushup(int node) { if (seg[node << 1] <= seg[node << 1 | 1]) { seg[node] = seg[node << 1]; seg2[node] = seg2[node << 1]; } else { seg[node] = seg[node << 1 | 1]; seg2[node] = seg2[node << 1 | 1]; } } void build(int l, int r, int node) { if (l == r) { seg[node] = 0; seg2[node] = l; return ; } int mid = (l + r) >> 1; build(l, mid, node << 1); // 左孩子 build(mid + 1, r, node << 1 | 1); // 右孩子! pushup(node); } void update(int l, int r, int pos, int node, ll ai, ll c) { if (l == r) { seg[node] = max(seg[node], ai) + c; ret = max(ret, seg[node]); return ; } int mid = (l + r) >> 1; if (pos <= mid) { update(l, mid, pos, node << 1, ai, c); } else { update(mid + 1, r, pos, node << 1 | 1, ai, c); } pushup(node); } int main() { cin >> n >> m; build(1, m, 1); vector<ll> a(n + 1), s(n + 1); for (int i = 1; i <= n; i++) { cin >> a[i] >> s[i]; nums[i] = make_pair(a[i], s[i]); } sort(nums + 1, nums + n + 1); for (int i = 1; i <= n; i++) { int pos = seg2[1]; update(1, m, pos, 1, nums[i].first, nums[i].second); } cout << ret << endl; return 0; }\"]},\"207\":{\"c\":[\"数据结构\",\"动态规划\"]},\"208\":{\"c\":[\"背包问题\",\"DFS\"]},\"209\":{\"h\":\"A* 算法\"},\"210\":{\"h\":\"1. 介绍\",\"t\":[\"A∗（念做：A Star）算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。\"]},\"211\":{\"h\":\"2. 搜索\"},\"212\":{\"h\":\"2.1 广度优先搜索\",\"t\":[\"广度优先搜索以广度做为优先级进行搜索。\",\"从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。\",\"这种算法就像洪水（Floodfill）一样向外扩张。\",\"对于有明确终点的问题来说，一旦到达终点便可以提前终止算法，下面这幅图对比了这种情况：\",\"搜索\",\"在执行算法的过程中，每个点需要记录达到该点的前一个点的位置 -- 可以称之为父节点。这样做之后，一旦到达终点，便可以从终点开始，反过来顺着父节点的顺序找到起点，由此就构成了一条路径。\"]},\"213\":{\"h\":\"2.2 Dijkstra 算法\",\"t\":[\"Dijkstra 算法用来寻找图形中节点之间的最短路径。\",\"考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。\",\"在 Dijkstra 算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。\",\"在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。\",\"注意\",\"当图形为网格图，并且每个节点之间的移动代价是相等的，那么 Dijkstra 算法将和广度优先算法变得一样。\"]},\"214\":{\"h\":\"2.3 最佳优先搜索\",\"t\":[\"在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。\",\"其原理也很简单。与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（BestFirst）算法。可以大大加快路径的搜索速度。\",\"但是算法也有缺点，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径。\"]},\"215\":{\"h\":\"3. A*\",\"t\":[\"A∗ 算法通过下面这个函数来计算每个节点的优先级。\",\"A*函数\",\"其中：\",\"f(n) 是节点 n 的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。\",\"g(n) 是节点 n 距离起点的代价。\",\"h(n) 是节点 n 距离终点的预计代价，即 A∗ 算法的启发函数。\",\"A∗ 算法在运算过程中，每次从优先队列中选取 f(n) 值最小（优先级最高）的节点作为下一个待遍历的节点。\",\"另外，A∗ 算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为 open_set 和 close_set。\",\"完整的 A∗ 算法描述如下：\",\"* 初始化 open_set 和 close_set； * 将起点加入 open_set 中，并设置优先级为 0（优先级最高）； * 如果 open_set 不为空，则从 open_set 中选取优先级最高的节点 n： * 如果节点 n 为终点，则： * 从终点开始逐步追踪 parent 节点，一直达到起点； * 返回找到的结果路径，算法结束； * 如果节点 n 不是终点，则： * 将节点 n 从 open_set 中删除，并加入 close_set 中； * 遍历节点 n 所有的邻近节点： * 如果邻近节点 m 在 close_set 中，则： * 跳过，选取下一个邻近节点 * 如果邻近节点 m 在 open_set 中，则： * 比较 gcost 是否比原来更小 * 如果更小则更新 parent * 如果邻近节点 m 也不在 open_set 中，则： * 设置节点 m 的 parent 为节点 n * 计算节点 m 的优先级 * 将节点 m 加入 open_set 中\"]},\"216\":{\"h\":\"4. 启发函数\",\"t\":[\"启发函数会影响 A∗ 算法的行为。\",\"在极端情况下，当启发函数 h(n) 始终为0，则将由 g(n) 决定节点的优先级，此时算法就退化成了 Dijkstra 算法。\",\"如果 h(n) 始终小于等于节点 n 到终点的代价，则 A∗ 算法保证一定能够找到最短路径。但是当 h(n) 的值越小，算法将遍历越多的节点，也就导致算法越慢。\",\"如果 h(n) 完全等于节点 n 到终点的代价，则 A∗ 算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。\",\"如果 h(n) 的值比节点 n 到终点的代价要大，则 A∗ 算法不能保证找到最短路径，不过此时会很快。\",\"在另外一个极端情况下，如果 h(n) 相较于 g(n) 大很多，则此时只有 h(n) 产生效果，这也就变成了最佳优先搜索。\",\"由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是 A∗ 算法比较灵活的地方。\",\"对于网格形式的图，有以下这些启发函数可以使用：\",\"如果图形中只允许朝上下左右四个方向移动，则可以使用 曼哈顿距离 （Manhattandistance）。\",\"如果图形中允许朝八个方向移动，则可以使用 对角距离。\",\"如果图形中允许朝任何方向移动，则可以使用 欧几里得距离（Euclideandistance）。\"]},\"217\":{\"h\":\"5. 关于距离\"},\"218\":{\"h\":\"5.1 曼哈顿距离\",\"t\":[\"如果图形中只允许朝上下左右四个方向移动，则启发函数可以使用曼哈顿距离，它的计算方法如下图所示：\",\"曼哈顿距离\",\"计算曼哈顿距离的函数如下，这里的D是指两个相邻节点之间的移动代价，通常是一个固定的常数。\",\"function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * (dx + dy)\"]},\"219\":{\"h\":\"5.2 对角距离\",\"t\":[\"如果图形中允许斜着朝邻近的节点移动，则启发函数可以使用对角距离。它的计算方法如下：\",\"对角距离\",\"计算对角距离的函数如下，这里的 D2 指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就是\",\"对角公式\",\"function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\"]},\"220\":{\"h\":\"5.3 欧几里得距离\",\"t\":[\"如果图形中允许朝任意方向移动，则可以使用欧几里得距离。\",\"欧几里得距离是指两个节点之间的直线距离，因此其计算方法也是我们比较熟悉的：\",\"欧几里得公式\",\"其函数表示如下：\",\"function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * sqrt(dx * dx + dy * dy)\"]},\"221\":{\"h\":\"6.补充\",\"t\":[\"1. A* 应用场景: 起点 → 终点的最短距离 状态空间 >> 1e10 启发函数减小搜索空间 2. A* 算法: while(q.size()) t ← 优先队列的队头 小根堆 当终点第一次出队时 break; 从起点到当前点的真实距离 d_real 从当前点到终点的估计距离 d_estimate 选择一个估计距离最小的点 min(d_estimate) for j in ne[t]: 将邻边入队 3. A* 算法条件: 估计距离 <= 真实距离 d[state] + f[state] = 起点到state的真实距离 + state到终点的估计距离=估计距离 ^ d[state] + g[state] = 起点到state的真实距离 + state到终点的真实距离=真实距离 一定是有解才有 d[i] >= d[最优] = d[u]+f[u] f[u] >= 0 4. 证明终点第一次出队列即最优解 (1)假设终点第一次出队列时不是最优 则说明当前队列中存在点u 有 d[估计]< d[真实] d[u] + f[u] <= d[u] + g[u] = d[队头终点] 即队列中存在比d[终点]小的值 (2)但我们维护的是一个小根堆, 没有比d[队头终点]小的d[u], 矛盾, 证毕. 5. A* 不用判重 以边权都为1为例 A o→o→o ↑ ↓ S o→o→o→o→o→o→o T B dist[A] = dist[S]+1 + f[A] = 7 dist[B] = dist[S]+1 + f[B] = 5 则会优先从B这条路走到T B走到T后再从A这条路走到T\"]},\"222\":{\"h\":\"7. 例题\"},\"223\":{\"h\":\"\",\"t\":[\"给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。\",\"注意： 每条最短路中至少要包含一条边。\",\"输入格式\",\"第一行包含两个整数 N 和 M。 接下来 M 行，每行包含三个整数 A,B 和 L，表示点 A 与点 B 之间存在有向边，且边长为 L。 最后一行包含三个整数 S,T 和 K，分别表示起点 S，终点 T 和第 K 短路。\",\"输出格式\",\"输出占一行，包含一个整数，表示第 K 短路的长度，如果第 K 短路不存在，则输出 −1。\",\"数据范围\",\"1≤S,T≤N≤1000,0≤M≤104,1≤K≤1000,1≤L≤100\",\"输入样例：\",\"2 2 1 2 5 2 1 4 1 2 2\",\"输出样例：\",\"14\",\"注意\",\"本题估价函数使用 dijkstra 反向建边求终点到各点的距离作为估计值 f[u].\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #define PII pair<int, int> #define PIII pair<int, PII> #define x first #define y second using namespace std; const int N = 1010, M = 2e5 + 10; int n, m, S, T, K; int h[N], rh[N], e[M], w[M], ne[M], idx; int dist[N], cnt[N]; bool st[N]; void add(int h[], int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } void dijkstra() { // 存储距离和起点 // 反向搜索，从终点开始，小根堆 priority_queue<PII, vector<PII>, greater<PII>> heap; heap.push({0, T}); memset(dist, 0x3f, sizeof dist); dist[T] = 0; while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y; if (st[ver]) continue; st[ver] = true; for (int i = rh[ver]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] > dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int astar() { // {当前距离+估计到终点的距离, {当前距离, 当前节点}} priority_queue<PIII, vector<PIII>, greater<PIII>> heap; heap.push({dist[S], {0, S}}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y.y, distance = t.y.x; cnt[ver]++; //如果终点已经被访问过k次了, 则此时的ver就是终点T, 返回答案 if (cnt[T] == K) return distance; for (int i = h[ver]; ~i; i = ne[i]) { int j = e[i]; /* 如果走到一个中间点都cnt[j]>=K, 则说明j已经出队k次了, 且astar()并没有return distance, 说明从j出发找不到第k短路(让终点出队k次)， 即继续让j入队的话依然无解， 那么就没必要让j继续入队了 */ if (cnt[j] < K) { // 按 真实值+估计值 = d[j]+f[j] = dist[S->t] + w[t->j] + dist[j->T] 堆排 // 真实值 dist[S->t] = distance+w[i] heap.push({distance + w[i] + dist[j], {distance + w[i], j}}); } } } return -1; } int main() { cin >> m >> n; memset(h, -1, sizeof h); memset(rh, -1, sizeof rh); for (int i = 0; i < n; i++){ int a, b, c; cin >> a >> b >> c; add(h, a, b, c); add(rh, b, a, c); } cin >> S >> T >> K; // 起点==终点时 则d[S→S] = 0这种情况就要舍去, 总共第K大变为总共第K+1大 if (S == T) K++; // 从各点到终点的最短路距离 作为估计函数f[u] dijkstra(); cout << astar() << endl; return 0; }\"]},\"224\":{\"h\":\"\",\"t\":[\"在一个 3×3 的网格中，1∼8 这 8 个数字和一个 X 恰好不重不漏地分布在这 3×3 的网格中。\",\"例如：\",\"1 2 3 X 4 6 7 5 8\",\"在游戏过程中，可以把 X 与其上、下、左、右四个方向之一的数字交换（如果存在）。\",\"我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：\",\"1 2 3 4 5 6 7 8 X\",\"例如，示例中图形就可以通过让 X 先后与右、下、右三个方向的数字交换成功得到正确排列。\",\"交换过程如下：\",\"1 2 3 1 2 3 1 2 3 1 2 3 X 4 6 4 X 6 4 5 6 4 5 6 7 5 8 7 5 8 7 X 8 7 8 X\",\"把 X 与上下左右方向数字交换的行动记录为 u、d、l、r。\",\"现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。\",\"输入格式\",\"输入占一行，将 3×3 的初始网格描绘出来。 例如，如果初始网格如下所示：\",\"1 2 3 x 4 6 7 5 8\",\"则输入为：1 2 3 x 4 6 7 5 8\",\"输出格式\",\"输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。 如果答案不唯一，输出任意一种合法方案即可。 如果不存在解决方案，则输出 unsolvable。\",\"输入样例：\",\"2 3 4 1 5 x 7 6 8\",\"输出样例：\",\"ullddrurdllurdruldr\",\"八数码 A*高级解法\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #include <unordered_map> #define PIS pair<int, string> using namespace std; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; char op[5] = \\\"urdl\\\"; // 从该状态到达目标状态的估价函数 // 计算各个点与目标状态的曼哈顿距离之和 int f(string state) { int res = 0; for (int i = 0; i < state.size(); i++){ if (state[i] != 'x') { int t = state[i] - '1'; res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3); } } return res; } string bfs(string start) { string end = \\\"12345678x\\\"; unordered_map<string, int> dist; unordered_map<string, pair<string, char>> prev; // 记录到达此状态的操作和上一步状态 // 初始化小根堆 // 第一元素：从起点到该状态的真实距离+该状态到目标状态的估价距离 // 第二元素：存储该状态 priority_queue<PIS, vector<PIS>, greater<PIS>> heap; heap.push({f(start), start}); dist[start] = 0; while (heap.size()) { auto t = heap.top(); heap.pop(); string state = t.second; if (state == end) break; // 求'x'的坐标 int x, y; for (int i = 0; i < state.size(); i++){ if (state[i] == 'x'){ x = i / 3, y = i % 3; break; } } int step = dist[state]; // 记录原来到达该状态的距离 string source = state; // 存储备份该状态 for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; if (xx >= 0 && xx < 3 && yy >= 0 && yy < 3){ swap(state[x * 3 + y], state[xx * 3 + yy]); // 交换 if (!dist.count(state) || dist[state] > step + 1) { dist[state] = step + 1; prev[state] = {source, op[i]}; heap.push({dist[state] + f(state), state}); } swap(state[x * 3 + y], state[xx * 3 + yy]); // 恢复 } } } // 回推路径 string res; while (end != start) { res += prev[end].second; end = prev[end].first; } reverse(res.begin(), res.end()); return res; } int main() { string g, c, seq; while (cin >> c) { g += c; if (c != \\\"x\\\") seq += c; } // 记录逆序对的对数 // 如果逆序对的数量是偶数，那就一定有解 int cnt = 0; for (int i = 0; i < seq.size(); i++){ for (int j = i + 1; j < seq.size(); j++){ if (seq[i] > seq[j]) cnt++; } } if (cnt % 2) puts(\\\"unsolvable\\\"); else cout << bfs(g) << endl; return 0; }\"]},\"225\":{\"c\":[\"笔记\"]},\"226\":{\"c\":[\"图论\"]},\"227\":{\"h\":\"DFS之岛屿问题\",\"t\":[\"三种岛屿问题的 DFS 模板：1.岛屿数量，2.封闭岛屿的树木，3.岛屿的最大面积\",\"本文主要针对常见的岛屿问题，总结出相应的 DFS 模板，在面对具体题目时，只需要稍加修改即可。\"]},\"228\":{\"h\":\"岛屿数量\",\"t\":[\"输入一个二维数组，其中 0 代表海水，1 代表陆地，且每座岛屿只能由上下左右四个方向相连的陆地组成。为搜索方便，可定义方向数组来进行遍历，如下所示：\",\"int dx[4] = {1, 0, -1, 0}; //横轴x方向 int dy[4] = {0, 1, 0, -1}; //纵轴y方向\",\"通常来说，都是上下左右四个方向，但某些题目会描述为“四周环绕”或“水平、垂直、对角线上相邻”，那么就需要搜索八个方向。那么对应的方向数组也需要做出改变：\",\"int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1}; int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\",\"大多数 DFS 中会使用一个标记数组 vis[][]（初始化数组元素为 0 ，将走过的元素标记为 1 ）来记录搜索过的元素，但对于 “岛屿数量” 这种单纯的题型，一种更简洁的写法是将走过的陆地都给 “淹” 了，将其赋值为海水，避免维护 vis 数组，更省事。\",\"以 200.岛屿数量 为例，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> #define N 1010 //定义地图范围，为防止数组越界，通常比所给数据范围大一点 using namespace std; int n, m, cnt; //定义行、列、岛屿数量 char mp[N][N]; //题中所给数据大多都是字符，所以常常定义字符数组 void dfs(int x, int y){ if (x < 0 || y < 0 || x >= n || y >= m ){ //若超出地图边界，则返回 return; } if (mp[x][y] == '0'){ //若已经是海水了，则也返回 return; } //将搜索过的mp[x][y]淹了变成海水 mp[x][y] = '0'; //定义方向数组，用来遍历上下左右四个方向 int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; dfs(xx, yy); //递归 } } int main(){ cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } //初始化岛屿数量为0 cnt = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == '1'){ cnt++; dfs(i, j); } } } //最后输出岛屿的数量 cout << cnt << endl; return 0;\"]},\"229\":{\"h\":\"封闭岛屿数量\",\"t\":[\"与上题类似，同理输入一个二维数组，其中 0 代表海水，1 代表陆地，且每座岛屿只能由上下左右四个方向相连的陆地组成。\",\"所谓 “封闭岛屿” ，就是上下左右全部被海水包围，靠边的陆地不算作封闭岛屿，所以我们可以先将地图边界的陆地 “淹” 了，搜索并将其赋值为海水。\",\"以 1254.统计封闭岛屿的数目 为例，不同的是它是⽤ 0 表示陆地，⽤ 1 表示海⽔。这里我们仍然用 0 代表海水，1 代表陆地，完整 C++ 代码如下（重复的注释就不再赘述了）：\",\"#include <bits/stdc++.h> using namespace std; #define N 1010 int n, m, cnt; char mp[N][N]; void dfs(int x, int y){ if (x < 0 || y < 0 || x >= n || y >= m || mp[x][y] == '0'){ //越界，或已经是海水了则返回 return; } //从（i，j）开始，将与之相邻的陆地都变成海水 mp[x][y] = '0'; //定义方向数组，用来遍历上下左右四个方向 int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; dfs(xx, yy); //递归 } } int main(){ cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } for (int i = 0; i < n; i++){ dfs(i, 0); //把靠左边的岛屿淹掉 dfs(i, m - 1); //把靠右边的岛屿淹掉 } for (int j = 0; j < m; j++){ dfs(0, j); //把上边的岛屿淹掉 dfs(n - 1, j); //把下边的岛屿淹掉 } //初始化岛屿数量为0 cnt = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == '1'){ cnt++; //每找到一个数量加一 dfs(i, j); } } } //最后输出岛屿的数目 cout << cnt << endl; return 0; }\"]},\"230\":{\"h\":\"岛屿的最大面积\",\"t\":[\"这种题的⼤体思路和之前完全⼀样，只不过 DFS 函数淹没岛屿的同时，还应该想办法记录这个岛屿的⾯积。 以 695.岛屿的最大面积 为例，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> using namespace std; #define N 1010 int n, m; char mp[N][N]; //淹没与（i，j）相邻的陆地，并返回淹没的陆地面积 int dfs(int x, int y){ if (x < 0 || y < 0 || x >= n || y >= m || mp[x][y] == '0'){ //超出地图边界，或已经是海水了 return 0; } //每次都将面积加一 //sum++; //将（i，j）变为海水 mp[x][y] = '0'; return dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1) + 1; //记得加上它本身 } int main(){ cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } //记录岛屿的最大面积 int res = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == '1'){ //淹没岛屿，并更新最大岛屿面积 res = max(res, dfs(i, j)); } } } //最后输出岛屿的最大面积 cout << res << endl; return 0; }\"]},\"231\":{\"h\":\"小结\",\"t\":[\"以上就是本文的内容，三种常见的岛屿问题，当然还会有很多相关的岛屿变型题，但都是大同小异，大体的思路都是一样的，理解了本质就可以傻瓜式地套用模板。\"]},\"232\":{\"c\":[\"笔记\",\"图论\"]},\"233\":{\"c\":[\"DFS\"]},\"234\":{\"h\":\"DFS之迷宫问题\",\"t\":[\"DFS 之迷宫问题：1.能否逃出迷宫，2.逃出迷宫的最短路径，3.缺口迷宫\",\"本文仅使用 DFS 算法不断回溯来解决迷宫问题，不涉及利用 “栈” 、“队列” 等数据结构来解决问题。 针对于最普通的也是最常见的迷宫问题，总结出相应的模板，不过具体问题还得具体分析，理解之后方才能从容不迫，游刃有余。\"]},\"235\":{\"h\":\"能否逃出迷宫\",\"t\":[\"最朴素的迷宫问题，通常给定一个 n × m 的二维字符数组作为迷宫，其中 S 表示起点，# 表示墙，无法通过，. 表示可走的路，T 表示出口，每次只能向上下左右四个方向移动。能逃出迷宫输出 yes ，否则输出 no.\",\"逃出这种迷宫，有两个关键点：\",\"一是：在 DFS 函数中判断能否找到出口，用一个布尔变量记录下来，找到则为真，找不到为假\",\"二是：每次递归之后都要回溯，将标记数组重置为 0，如果没有重置，那等于说走过一次就不能走了，但实际上后面的搜索中可能还是要走这条路的。\",\"这种题对于已访问的元素，我们不能像 “岛屿问题” 一样简单的把它给 “淹” 了，需要考虑回溯的问题，所以需要使用标记数组 vis[][] ，将已访问标记为 1，递归后再回溯，重置标记数组即可。\",\"下面以 计蒜客-T1595 为例，判断能否逃出迷宫，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> //万能头文件 using namespace std; const int N = 110; //定义地图范围，范围开大一点防止数组越界 //#define N 1010 //用define定义的话后面不用加分号 int n, m, ans; //ans用来标记是否找到出口 char mp[N][N]; //迷宫地图数组 int vis[N][N]; //标记数组 void dfs(int x, int y){ if (mp[x][y] == 'T'){ //如果找到了出口，标记为1，再返回 ans = 1; return; } //定义方向数组 int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; //如果未越界，可走且未访问 if (xx >= 0 && yy >= 0 && xx < n && yy < m && (mp[xx][yy] == '.' || mp[xx][yy] == 'T') && !vis[xx][yy]){ vis[xx][yy] = 1; //标记为已访问 dfs(xx, yy); //递归继续搜索 vis[xx][yy] = 0; //递归搜索完成后回退，将已访问状态重置为未访问 } } } int main(){ //初始化输入数据 cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } //标记默认为0 ans = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == 'S'){ //找到了起点，开始搜索 dfs(i, j); } } } //若ans为1，则为真，输出yes；若为0，则为假，输出no if (ans) cout << \\\"yes\\\" << endl; else cout << \\\"no\\\" << endl; return 0; }\"]},\"236\":{\"h\":\"逃出迷宫的最短路径\",\"t\":[\"与上题一样，唯一不同的是需要计算出每次逃出迷宫的路径，再进行比较得出最短路径。若无法逃出，则输出 -1.\",\"以 计蒜客-T1596 为例，题中 * 为墙，. 为路，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> using namespace std; const int N = 110; int n, m; int sx, sy; //定义起点坐标 int tx, ty; //定义终点坐标 char mp[N][N]; //迷宫数组 int vis[N][N]; //标记数组 int minx; //记录最短路径 void dfs(int x, int y, int step){ //减枝，用来将之后多余的步数去掉 if (step >= minx) return; //找到了终点，比较路径是否最短 if (x == tx && y == ty){ if (step < minx){ minx = step; } return; } int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; //若可走且未访问 if (xx >= 0 && yy >= 0 && xx < n && yy < m && (mp[xx][yy] == '.' || mp[xx][yy] == 'T') && vis[xx][yy] == 0){ vis[xx][yy] = 1; //标记为已访问 dfs(xx, yy, step + 1); vis[xx][yy] = 0; //递归搜索完成后回退，重置为未访问 } } } int main(){ minx = 9999; //保证初始值足够大 cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; vis[i][j] = 0; //找到入口 if (mp[i][j] == 'S'){ sx = i; sy = j; } //找到出口 if (mp[i][j] == 'T'){ tx = i; ty = j; } } } //标记入口已走过 vis[sx][sy] = 1; //开始搜索，初始步数为0 dfs(sx, sy, 0); //输出结果 if (minx == 9999) cout << \\\"-1\\\" << endl; else cout << minx << endl; return 0;\"]},\"237\":{\"h\":\"缺口迷宫\",\"t\":[\"所谓缺口迷宫，是指迷宫的出口在地图的边界，出口处不一定有像 T这样的出口符号，而是只有像 . 这样的路。\",\"有些题只需要判断能不能逃出迷宫，有些题则在判断的同时需要计算出最短路径。\",\"这里我们计算下最短路径，与第二种迷宫差不多，只需要将 DFS 函数中迷宫出口的判断条件稍加修改即可。\",\"即将 return 条件由 mp[x][y] == 'T' 改为 mp[x][y] == '.' && (x == 0 || y == 0 || x == n - 1 || y == m - 1).\",\"以 计蒜客-T1597 为例，题中 @ 为起点，# 为墙，. 为路，若无法逃出，则输出 −1，完整的 C++ 代码如下：\",\"#include <bits/stdc++.h> using namespace std; const int N = 110; int sx, sy; //定义起点坐标 int n, m, minx; //定义行、列、最短路径 char mp[N][N]; //迷宫数组 int vis[N][N]; //标记数组 void dfs(int x, int y, int step){ //找到了位于边界上的出口，比较路径是否最短 if (mp[x][y] == '.' && (x == 0 || y == 0 || x == n - 1 || y == m - 1)){ if (step < minx){ minx = step; } return; } int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; //若可走且未访问 if (xx >= 0 && yy >= 0 && xx < n && yy < m && mp[xx][yy] == '.' && vis[xx][yy] == 0){ vis[xx][yy] = 1; //标记为已访问 dfs(xx, yy, step + 1); vis[xx][yy] = 0; //递归搜索完成后回退，重置为未访问 } } } int main(){ //初始化 minx = 99999999;//保证初始值足够大 cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; //找到入口 if (mp[i][j] == '@'){ sx = i; sy = j; } } } //标记入口已走过 vis[sx][sy] = 1; //开始搜索，初始步数为0 dfs(sx, sy, 0); //输出结果 if (minx == 99999999) cout << \\\"-1\\\" << endl; else cout << minx << endl; return 0; }\"]},\"238\":{\"h\":\"小结\",\"t\":[\"当然，像这种迷宫问题，有很多种解法，这里展示的只是我个人总结下来的一些使用 DFS 递归解题的模板，多多少少也会有点不足。\"]},\"239\":{\"c\":[\"笔记\",\"图论\"]},\"240\":{\"c\":[\"DFS\"]},\"241\":{\"h\":\"一些经验和技巧\"},\"242\":{\"h\":\"1. vector 维护一个动态数组\",\"t\":[\"定义时初始化(一般 +1 防止数组越界) vector<int> a(n + 1, 0); 定义一个二维动态数组 vector<vector<int>> g(n + 1, vector<int>(n + 1));\"]},\"243\":{\"h\":\"2. 字符串\",\"t\":[\"size() 和 length()：这两个函数会返回 string 类型对象中的字符个数，且它们的执行效果相同\",\"strlen() ：是C语言标准库中的函数\",\"// 返回 string 长度，单位字节 size_t length() const noexcept; // 返回 string 长度，单位字节。作用等同于 length() size_t size() const noexcept; // C 标准库函数，返回C风格字符串长度，单位字节 size_t strlen ( const char * str );\",\"（1）当 string 中含有空字符’\\\\0’，使用 strlen() 获取 string 的长度时会被截断，使用成员函数 length() 和 size() 可以返回 string 的真实长度。\",\"（2）cout 对 string 输出时，会过滤掉空字符，输出不会被截断。\",\"（3）在构造或者拼接 string 时，建议同时指定 string 的长度，比如：\",\"如果字符串长度很大（例如超过 1e9）的时候，要使用 s.length() 获取字符串长度，使用 s.size() 会爆掉\",\"max_size()：返回 string 类型对象最多包含的字符数。一旦程序使用长度超过 max_size() 的 string 操作，编译器会拋出 length_error 异常。\",\"resize() ： 修改字符串的长度\",\"str.resize(5); // 长度修改为5\",\"capacity() ：该函数返回在重新分配内存之前，string 类型对象所能包含的最大字符数。\",\"使用 printf() 输出 string 类型\",\"① printf 函数输出字符串是针对 char * 的，即 printf 只能输出c语言的内置数据类型，而 string 不是c语言的内置数据类型。\",\"② string 类型的对象不止包含字符串，还包含了许多用于操作的函数，所以 &str 并非字符串的首地址。\",\"③ 如需输出string对象中的字符串，可以使用 string 的成员函数c_str()，该函数返回字符串的首字符的地址。\",\"string s = \\\"hello\\\"; printf(\\\"%s\\\", s.c_str()); //输出：hello\"]},\"244\":{\"h\":\"3. 在一个数组中查找最长的相同连续子序列\",\"t\":[\"// 在由 0、1 组成的字符串中查找最长的‘1’ for (int i = 0; i < n; i++) { if (s[i] == '1') len++; if (s[i] == '0'){ res = max(res, len); len = 0; } }\"]},\"245\":{\"h\":\"4. 秦九韶算法\",\"t\":[\"int res = 0; for (int i = 1; i <= n; i++) res = res * b + a[i]; //b代表进制位数\",\"将一个 i 进制的数转化为十进制\",\"int get(string s, int i) { int res = 0; for (auto c : s) res = res * i + c - '0'; return res; }\"]},\"246\":{\"h\":\"5. 开栈空间代码\",\"t\":[\"备份，以防爆栈风险\",\"int main() { int size(512<<20); // 512M __asm__ ( \\\"movq %0, %%rsp\\\\n\\\"::\\\"r\\\"((char*)malloc(size)+size)); // YOUR CODE ... exit(0); return 0; }\"]},\"247\":{\"h\":\"6. 求 a 除以 b 的正余数\",\"t\":[\"int get_mod(int a, int mod) { return (a % mod + mod) % mod; }\"]},\"248\":{\"h\":\"7. 裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\"]},\"249\":{\"h\":\"8. 交互题\",\"t\":[\"若要提问，请打印 “ ？+ 问题 ” ，然后从标准输入中输入响应\",\"如果你的程序问了一个无效的问题，或者问题用完了，交互器将立即终止，你的程序将得到一个判断错误的答案。\",\"要给出最终答案，请打印 “ ! + 答案 ”\",\"问完一个问题后，要输出行的末尾并刷新输出，否则将会得到超过限制限制的结果。\",\"C中的 fflush(stdout) 或者C++中的 cout.flush()； Java中的 System.out.flush()； Pascal中的 flush(output)； Python中的 stdout.flush().\"]},\"250\":{\"h\":\"9. mex函数\",\"t\":[\"auto mex = [](vector<int> w) { sort(w.begin(), w.end()); int mx = 0; for (int x : w) if (x == mx) ++mx; return mx; }; int z = mex(v);\"]},\"251\":{\"h\":\"10. string 与 int 之间的转化\",\"t\":[\"（1）int 转 string\",\"通过 to_string() 函数转换\",\"int num = 123; string s = to_string(num); cout << s << endl; // s = \\\"123\\\"\",\"通过 sprintf 转换\",\"int num = 123; char str[256]; sprintf(str, \\\"%d\\\", num); printf(\\\"%s\\\", str);\",\"这是一种C语言中的转换方式，sprintf 也可以换成更安全的 snprintf 函数\",\"（2）string 转 int\",\"通过 sscnaf 转换\",\"string str = \\\"123\\\"; int num = 0; sscanf(str.c_str(), \\\"%d\\\", &num); cout << num << endl; // num = 123\",\"sscanf 函数的第一个参数类型是 const char *，string类型的参数需要转换一下\",\"使用 atoi 转换\",\"string str = \\\"123\\\"; cout << atoi(str.c_str()); // 123\",\"atoi 函数的头文件是 stdlib.h\"]},\"252\":{\"h\":\"11. string::npos\",\"t\":[\"string::npos是一个静态成员常量，表示size_t的最大值（Maximum value for size_t）。该值表示“直到字符串结尾”**，**作为返回值它通常被用作表明没有匹配。\",\"string::npos是这样定义的：\",\"static const size_type npos = -1;\",\"常用于配合 find() 函数使用，该函数有唯一的返回类型，即 string::size_type , 即一个无符号整型类型，可能是整数，也可能是长整数。\",\"如果查找成功，返回按照查找规则找到的第一个字符或者子串的位置；\",\"如果查找失败，返回 string::npos , 即 -1\"]},\"253\":{\"h\":\"12. x >> i & 1\",\"t\":[\"x >> i & 1 用来判断 x 的二进制表示下的每一位是不是 1 .\"]},\"254\":{\"h\":\"13. assign()\",\"t\":[\"C++ 函数 std::vector::assign() 通过替换旧值为向量元素分配新值。 如有必要，它会修改矢量的大小。\",\"assign(n, val) 有两个参数，n — 容器大小，val — 重新赋给每个元素的值；\",\"assign(first, last) 区间，左闭右开\",\"功能：\",\"①将区间 [first,last) 的元素赋值到当前的 vector 容器中；\",\"②赋 n 个值为 x 的元素到 vector 容器中，会覆盖掉 vector 容器中以前的内容。\",\"1.第一种用法 vector<int> v1, v2; v2.assign(v1,begin(), v1.end()); 2.第二种用法 vector<int> a(n + 1); vector<vector<int>> g(n + 1); 一维：a.assign(n + 1, 0); 二维：g.assign(n + 1, vector<int>());\"]},\"255\":{\"h\":\"14. lambda表达式\",\"t\":[\"lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：\",\"[ capture ] ( params ) opt -> ret { body; };\",\"其中\",\"capture 是捕获列表，空表示不捕获任何变量；\",\"& 表示捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）；\",\"= 表示捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）；\",\"=，&foo 表示按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。\",\"bar 按值捕获 bar 变量，同时不捕获其他变量；\",\"this 表示捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。\",\"params 是参数表， opt 是函数选项， ret 是返回值类型， body是函数体\",\"写法示例：\",\"// 计算两个数的和 auto plus = [] (int v1, int v2) -> int { return v1 + v2; } int sum = plus(1, 2);\",\"递归 Lambda 表达式：\",\"//d vector<int> cnt(n); auto dfs = [&](auto self, int u, int p) -> void { for (auto v : adj[u]) { if (v != p) { self(self, v, u); cnt[u] += cnt[v]; } } if (cnt[u] == 0) { cnt[u] = 1; } }; dfs(dfs, 0, -1); //树的根节点从0开始，初始化为-1\"]},\"256\":{\"h\":\"15. max_element() 与 min_element()\",\"t\":[\"max_element() 与min_element() 分别用来求最大元素和最小元素的位置。\",\"接收参数：容器的首尾地址（迭代器）（可以是一个区间）\",\"返回：最值元素的地址（迭代器），需要减去序列头以转换为下标\",\"vector<int> v; int maxPos = max_element(v.begin(), v.end()) - v.begin(); //最大值下标 int minPos = min_element(v.begin(), v.end()) - v.begin();//最小值下标 2）普通数组 int a[] = {1,2,3,4}; int maxPos = max_element(a, a + 2) - a; //最大值下标 int minPos = min_element(a, a + 2) - a;//最小值下标\",\"max_element() 与 min_element() 分别用来求最大元素和最小元素的值。\",\"接收参数：容器的首尾地址（迭代器）（可以是一个区间）\",\"返回：最值元素的值\",\"int maxValue = *max_element(v.begin(), v.end()); //最大值 int minValue = *min_element(v.begin(), v.end()); //最小值 int maxValue = *max_element(a, a + 2); //最大值 int minValue = *min_element(a, a + 2); //最小值\"]},\"257\":{\"h\":\"16. tuple\",\"t\":[\"tuple 是泛化的 std::pair，我们通常是把它当作一个结构体使用，比如我们可以将多个参数整合为一个结构体传递到函数内部，实现一些简洁的操作。\",\"创建\",\"tuple<int,float,int,float> tu = make_tuple(1,2.f,3,4.f);//创建方式一 tuple<int,float,int,float> tu(1,2.f,3,4.f);//创建方式二 //相当于结构体： struct tu { int a; float b; int c; float d; }\",\"同 pair<first, second> 一样\"]},\"258\":{\"c\":[\"笔记\"]},\"259\":{\"c\":[\"经验\"]},\"260\":{\"h\":\"前缀和相关题型\"},\"261\":{\"h\":\"\",\"t\":[\"题目描述\",\"给定一个长度为 N 的数列，A1​,A2​,…AN​，如果其中一段连续的子序列 Ai​,Ai+1​,…Aj​ 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？\",\"输入格式\",\"第一行包含两个整数 N 和 K。 以下 N 行每行包含一个整数 Ai​。\",\"输出格式\",\"输出一个整数，代表 K 倍区间的数目。\",\"数据范围\",\"1⩽N,K⩽1000001⩽Ai​⩽100000\",\"输入样例：\",\"5 2 1 2 3 4 5\",\"输出样例：\",\"6\",\"思路\",\"翻译：求区间 [l,r] 的和是 k 的倍数的个数。\",\"求区间和，我们可以通过 前缀和 来求出。 定义 sum[i] 表示第 1 个元素到第 i 个元素的和，那么 s[r] - s[l-1] 就是区间 [l,r] 的和。 若满足条件：区间 [l,r] 的和是k的倍数，即 (s[r] - s[l-1]) % k == 0 ，等价于 s[r] % k == s[l-1] % k 。\",\"说人话，这也就意味着：\",\"如果 s[r] mod k 和 s[l - 1] mod k 的余数相等，那么 s[r] - s[l - 1] 的差值必然是 k 的倍数。\",\"比如：13 % 7 == 20 % 7，则 (20 - 7) % 7 == 0\",\"那么题目就是要我们求 前缀和%k==0 的组合有多少种。\",\"用 cnt[i] 存储目前为止前缀和相同的个数，i 表示这个前缀和的值。 每次用 res 来递加 cnt[i] 相同的个数，前面有几个 前缀和的值 和 当前前缀和 相等，那么这个前缀和就能和前面每一个组成一个组合，所以要 res += cnt[s[i]] ，然后再加上现在的前缀和，即 cnt[s[i]]++ 。 初始化 cnt[0] = 1 ，因为当 s[i] == 0 时，这个前缀和本身就是 k 的倍数，不需要再跟别的前缀和组合，计算结果时就要加上这一个。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 1e5 + 10; int n, k; ll s[N]; ll cnt[N]; int main() { cin >> n >> k; ll res = 0; cnt[0] = 1; for (int i = 1; i <= n; i++){ cin >> s[i]; s[i] = (s[i] + s[i - 1]) % k; // 每次前缀和都取模 res += cnt[s[i]]; // 和前面每一个都组合一下 cnt[s[i]]++; // 现在又多了一个 } cout << res << endl; return 0; }\"]},\"262\":{\"h\":\"\",\"t\":[\"题目描述\",\"给定一个长度为 n 的数组 a1​,a2​,…,an​ 。 现在，要将该数组从中间截断，得到三个非空子数组。 要求，三个子数组内各元素之和都相等。 请问，共有多少种不同的截断方法？\",\"输入格式\",\"第一行包含整数 n。 第二行包含 n 个整数 a1​,a2​,…,an​ 。\",\"输出格式\",\"输出一个整数，表示截断方法数量。\",\"数据范围\",\"前六个测试点满足 1⩽n⩽10。\",\"所有测试点满足 1⩽n⩽105,−10000⩽ai​⩽10000。\",\"输入样例1：\",\"4 1 2 3 3\",\"输出样例1：\",\"1\",\"输入样例2：\",\"5 1 2 3 4 5\",\"输出样例2：\",\"0\",\"输入样例3：\",\"2 0 0\",\"输出样例3：\",\"0\",\"思路\",\"先预处理前缀和，先判断如果 s[n] % 3 != 0，则不能被均分为三份，输出 0.\",\"然后从 i = 3 开始枚举前缀和数组，以 i 作为切割点，s[i - 2] 为第一段，s[n] - s[i - 1] 为第三段，如果 第一段 = 第三段 = 3s[n]​​，则第二段也一定相等，都符合条件。\",\"先判断第一段是否符合，记录个数，如果第三段不符合，则表示该切割点不行，继续后移，每次当第三段符合时，都加上第一段符合的个数即可。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 1e5 + 10; int n; ll s[N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> s[i]; s[i] += s[i - 1]; } if (s[n] % 3){ cout << 0 << endl; return 0; } ll cnt = 0, res = 0; for (int i = 3; i <= n; i++){ if (s[i - 2] == s[n] / 3) cnt++; if (s[n] - s[i - 1] == s[n] / 3) res += cnt; } cout << res << endl; return 0; }\"]},\"263\":{\"h\":\"\",\"t\":[\"题目描述\",\"地图上有 N 个目标，用整数 Xi​,Yi​ 表示目标在地图上的位置，每个目标都有一个价值 Wi​ 。\",\"注意：不同目标可能在同一位置。\",\"现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x,y 轴平行。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。\",\"输入格式\",\"第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。 接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi​,Yi​,Wi​ ，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。\",\"输出格式\",\"输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。\",\"数据范围\",\"0⩽R⩽1090<N⩽100000⩽Xi​,Yi​⩽50000⩽Wi​⩽1000\",\"输入样例：\",\"2 1 0 0 1 1 1 1\",\"输出样例：\",\"1\",\"思路\",\"递推求出二维前缀和 。\",\"因为题目的内存限制，我们直接用二维数组读入数据，边读边加。 然后我们再求其前缀和，再从地图右下角枚举边长为 R​ 的正方形，通过下式\",\"s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]\",\"即可计算出该正方形内所有目标的价值之和。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 5e3 + 10; // 不能开到 1e5 + 10，二维会爆栈 int n, r; int s[N][N]; int main() { cin >> n >> r; r = min(5001, r); // 因为r最大可取到10^9,但地图没有这么大 for (int i = 1; i <= n; i++){ int x, y, w; cin >> x >> y >> w; s[++x][++y] += w; // 因为数据范围是从0开始的 } //如果i从0开始那么i-1会导致数组越界 for (int i = 1; i <= 5001; i++){ for (int j = 1; j <= 5001; j++){ s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } } int res = 0; for (int i = r; i <= 5001; i++){ for (int j = r; j <= 5001; j++){ res = max(res, s[i][j] - s[i - r][j] - s[i][j - r] + s[i - r][j - r]); } } cout << res << endl; return 0; }\"]},\"264\":{\"c\":[\"笔记\"]},\"265\":{\"c\":[\"前缀和\"]},\"266\":{\"h\":\"并查集\"},\"267\":{\"h\":\"简介\",\"t\":[\"1.并查集是一种非常精巧实用的数据结构，它主要用于处理一些不相交集合的合并问题。一些常见的用途有求连通子图，求最小生成树的 Kruskal 算法和求最近公共祖先（LCA）等。\",\"2.基本操作主要有：\",\"（1）初始化 init\",\"（2）查询 find\",\"（3）合并 union\"]},\"268\":{\"h\":\"基本模板\"},\"269\":{\"h\":\"1.初始化\",\"t\":[\"int fa[N]; void init(int n){ for (int i = 1; i <= n; i++) fa[i] = i; // 一开始都是独立的，父节点设置为自己 }\",\"假如有编号为 1，2，3，...，n 的 n 个元素，我们用一个数组 fa[N] 来存储每个元素的父节点。一开始，我们先将它们的父节点设为自己。\"]},\"270\":{\"h\":\"2.查询（已路径压缩）\",\"t\":[\"查询一定要进行路径压缩，不然大概率会超时。\",\"int find(int x){ //递归出口，当达到了祖先位置，就返回祖先 if (fa[x] == x) return x; else { //不断往上查找祖先，并进行路径压缩，一直找到祖先的祖先 fa[x] = find(fa[x]); return fa[x]; //返回父亲节点 } }\",\"也可以简写成这样：\",\"int fond(int x){ return fa[x] == x ? x : find(fa[x]); }\"]},\"271\":{\"h\":\"3.合并\",\"t\":[\"最简单的合并就是像下面这样，粗暴的把 i 所在树的根节点接到 j 所在树的根节点下面，但是有可能出现 “头重脚轻” 的不平衡状况，后面例二中将会给出解决方法。\",\"void union(int i, int j){ int x = find(i); // 找到i的根节点 int y = find(j); // 找到j的根节点 fa[x] = y; // i的根节点指向j的根节点 }\"]},\"272\":{\"h\":\"典例分析\"},\"273\":{\"h\":\"例一：亲戚关系\",\"t\":[\"现在有若干家族图谱关系，给出了一些亲戚关系，如 A 和 B 是亲戚，B 和 C 是亲戚，那么 A和 B 也是亲戚。请写一个程序，对于我们的关于亲戚关系的提问，以最快的速度给出答案。\",\"【输入格式】\",\"第一部分是以 N，M 开始。N 为人数（1⩽N⩽20000），这些人的编号为 1，2，3，...，N。 下面有 M行（1⩽M⩽1000000），每行有两个数 a，b，表示 a 和 b 是亲戚。\",\"第二部分是以 Q 开始。以下 Q 行有 Q 行询问（1⩽Q⩽1000000），每行为 c, d, 表示询问 c 和 d 是否为亲戚。\",\"【输出格式】\",\"对于询问 c, d, 输出一行：若 c, d 为亲戚，则输出 “YES” ，否则输出 “NO”。\",\"【输入样例】\",\"10 7 2 4 5 7 1 3 8 9 1 2 5 6 2 3 3 3 4 7 10 8 9\",\"【输出样例】\",\"YES NO YES\",\"【示例代码】\",\"#include <iostream> #include <cstdio> #include <cstdlib> using namespace std; const int N = 20005; int fa[N]; // 父亲数组 // 初始化父亲为它自己 void init (int n){ for (int i = 1; i <= n; i++) fa[i] = i; } // 查找根节点 int find(int x){ if (fa[x] == x) return x; else { // 压缩路径，不断向上寻找最初的根节点 fa[x] = find(fa[x]); return fa[x]; } } // 合并，子节点依附在根节点上 void union(int i, int j){ int x= find(i); int y = find(j); fa[x] = y; } int main(){ int n, m, x, y, q; cin >> n >> m; init(n); for (int i = 1; i <= m; i++){ cin >> x >> y; union(x, y); // 构建依附关系 } scanf(\\\"%d\\\", &q); for (int i = 1; i <= q; i++){ cin >> x >> y; // 询问是否存在依附关系 if (find(x) == find(y)) put(\\\"YES\\\"); else put(\\\"NO\\\"); } return 0; }\"]},\"274\":{\"h\":\"例二：洛谷 P3367 【模板】并查集\",\"t\":[\"find 的主要功能就是从某个节点向上遍历到根节点，其时间复杂度就是树的高度，我们可能习惯性地认为树的高度就是 logN ， 但是不一定。logN 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得 “树” 几乎退化成 “链表'，树的高度最坏情况下可能变成 N。\",\"问题的关键在于，该如何想办法避免树的不平衡呢？\",\"其实关键在于 union 过程。\",\"我们其实是希望，高度小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些。\",\"解决方法是额外使用一个 size 数组，记录每棵树包含的节点数，不妨称为 高度。\",\"如下所示：\",\"void union(int i, int j){ int x = find(i), y = find(j); if (x == y) return; // 小树接在大树下面，较平衡 if (size[x] >= size[y]){ fa[y] = x; size[x] += size[y]; } else { fa[x] = y; size[y] += size[x]; } return; }\",\"下面看题中完整的写法（题是比较简单的一道模板题，用这种写法不过是略微优化了一下）:\",\"【题目描述】\",\"如题，现在有一个并查集，你需要完成合并和查询操作。\",\"【输入格式】\",\"第一行包含两个整数 N, M, 表示共有 N 个元素和 M 个操作。 接下来 M 行，每行包含三个整数 Zi​,Xi​,Yi​。 当 Zi​=1 时，将 Xi​ 与 Yi​ 所在的集合合并。 当 Zi​=2 时，输出 Xi​ 与 Yi​ 是否在同一集合内，是的输出 Y；否则输出 N。\",\"【输出格式】\",\"对于每一个 Zi​=2 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。\",\"【输入样例】\",\"4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4\",\"【输出样例】\",\"N Y N Y\",\"【示例代码】\",\"#include <iostream> #include <cstdio> using namespace std; const int N = 2e5+5; // 父亲数组，高度数组 int fa[N], size[N]; // 初始化 int init(int n) { for (int i = 1; i <= n; i++){ fa[i] = i; // 初始根节点为它自己 size[i] = 1; // 初始高度为1 } } // 查找父节点 int find(int x) { if (fa[x] == x) return x; else fa[x] = find(fa[x]); // 扁平化处理，压缩路径 return fa[x]; } // 合并 void union(int i, int j) { int x = find(i), y = find(j); if (x == y) return; // 比较高度，高度小的接在高的下面，节省查找时间 if (size[x] >= size[y]){ fa[y] = x; size[x] += size[y]; } else { fa[x] = y; size[y] += size[x]; } } int main() { int n, m, z, x, y; cin >> n >> m; init(n);//初始化 for (int i = 1; i <= m; i++){ cin >> z >> x >> y; if (z == 1) union(x, y); if (z == 2){ if (find(x) == find(y)) cout << \\\"Y\\\" << endl; else cout << \\\"N\\\" << endl; } } return 0; }\"]},\"275\":{\"c\":[\"笔记\",\"数据结构\"]},\"276\":{\"c\":[\"并查集\"]},\"277\":{\"h\":\"搜索\"},\"278\":{\"h\":\"（BFS）\",\"t\":[\"题目描述\",\"给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1 ，其中 0 表示可以走的路，1 表示不可通过的墙壁。 最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。 数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。\",\"输入格式\",\"第一行包含两个整数 n 和 m。 接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。\",\"输出格式\",\"输出一个整数，表示从左上角移动至右下角的最少移动次数。\",\"数据范围\",\"1⩽n,m⩽100\",\"输入样例：\",\"5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0\",\"输出样例：\",\"8\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #define PII pair<int, int> using namespace std; const int N = 110; int n, m; int g[N][N]; int d[N][N]; int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; int bfs() { memset(d, -1, sizeof d); queue<PII> q; q.push({1, 1}); d[1][1] = 0; while (q.size()) { auto t = q.front(); q.pop(); for (int i = 0; i < 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x >= 1 && x <= n && y >= 1 && y <= m && g[x][y] == 0 && d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x, y}); } } } return d[n][m]; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; cout << bfs() << endl; return 0; }\"]},\"279\":{\"h\":\"（BFS）\",\"t\":[\"题目描述\",\"在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3 的网格中。\",\"例如：\",\"1 2 3 x 4 6 7 5 8\",\"在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。\",\"我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：\",\"1 2 3 4 5 6 7 8 x\",\"例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。\",\"交换过程如下：\",\"1 2 3 1 2 3 1 2 3 1 2 3 x 4 6 4 x 6 4 5 6 4 5 6 7 5 8 7 5 8 7 x 8 7 8 x\",\"现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。\",\"输入格式\",\"输入占一行，将 3×3 的初始网格描绘出来。\",\"例如，如果初始网格如下所示：\",\"1 2 3 x 4 6 7 5 8\",\"则输入为：1 2 3 x 4 6 7 5 8\",\"输出格式\",\"输出占一行，包含一个整数，表示最少交换次数。\",\"如果不存在解决方案，则输出 −1。\",\"输入样例：\",\"2 3 4 1 5 x 7 6 8\",\"输出样例\",\"19\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #include <unordered_map> using namespace std; int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; int bfs(string a) { string b = \\\"12345678x\\\"; queue<string> q; // 存储变换后的字符串 unordered_map<string, int> d; // 表示变换到某个字符串时需要的交换次数 q.push(a); d[a] = 0; while (!q.empty()) { auto t = q.front(); q.pop(); int dist = d[t]; // 判断是否变成了目标串 if (t == b) return dist; // 状态转移，变换串 int k = t.find('x'); // 'x'在字符串中的位置 int x = k / 3, y = k % 3; // 'x'在网格中的位置 for (int i = 0; i < 4; i++) { int xx = x + dx[i], yy = y + dy[i]; if (xx >= 0 && xx < 3 && yy >= 0 && yy < 3) { swap(t[k], t[xx * 3 + yy]); // 交换位置 if (!d.count(t)) { d[t] = dist + 1; q.push(t); } swap(t[k], t[xx * 3 + yy]); // 还原，恢复现场 } } } // 找不到解决方案则输出-1 return -1; } int main() { string a; // 将a串变为b串 for (int i = 0; i < 9; i++) { char c; cin >> c; a += c; } cout << bfs(a) << endl; return 0; }\"]},\"280\":{\"h\":\"\",\"t\":[\"题目描述\",\"你有一张某海域 N×N 像素的照片，\\\".\\\" 表示海洋、\\\"#\\\" 表示陆地，如下所示：\",\"....... .##.... .##.... ....##. ..####. ...###. .......\",\"其中 “上下左右” 四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2 座岛屿。 由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。 具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。 例如上图中的海域未来会变成如下样子：\",\"....... ....... ....... ....... ....#.. ....... .......\",\"请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。\",\"输入格式\",\"第一行包含一个整数 N。 以下 N 行 N 列，包含一个由字符 \\\"#\\\" 和 \\\".\\\" 构成的 N×N 字符矩阵，代表一张海域照片，\\\"#\\\" 表示陆地，\\\".\\\" 表示海洋。 照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。\",\"输出格式\",\"一个整数表示答案。\",\"数据范围\",\"1⩽N⩽1000\",\"输入样例1：\",\"7 ....... .##.... .##.... ....##. ..####. ...###. .......\",\"输出样例1：\",\"1\",\"输入样例2：\",\"9 ......... .##.##... .#####... .##.##... ......... .##.#.... .#.###... .#..#.... .........\",\"输出样例2：\",\"1\",\"思路\",\"代码\"]},\"281\":{\"h\":\"（DFS）\",\"t\":[\"题目描述\",\"给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。\",\"现在，请你按照字典序将所有的排列方法输出。\",\"输入格式\",\"共一行，包含一个整数 n。\",\"输出格式\",\"按字典序输出所有排列方案，每个方案占一行。\",\"数据范围\",\"1⩽n⩽7\",\"输入样例：\",\"3\",\"输出样例：\",\"1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 10; int n; int path[N]; bool st[N]; void dfs(int u) { if (u == n){ for (int i = 0; i < n; i++){ printf(\\\"%d \\\", path[i]); } puts(\\\"\\\"); return; } for (int i = 1; i <= n; i++){ if (!st[i]) { path[u] = i; st[i] = true; dfs(u + 1); st[i] = false; } } } int main() { cin >> n; dfs(0); return 0; }\"]},\"282\":{\"h\":\"4.\"},\"283\":{\"h\":\"5.\"},\"284\":{\"c\":[\"笔记\"]},\"285\":{\"c\":[\"BFS\",\"DFS\"]},\"286\":{\"h\":\"递归相关题型\"},\"287\":{\"h\":\"\",\"t\":[\"题目描述\",\"从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。\",\"输入格式\",\"输入一个整数 n。\",\"输出格式\",\"每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。\",\"数据范围\",\"1⩽n⩽15\",\"输入样例：\",\"3\",\"输出样例：\",\"3 2 2 3 1 1 3 1 2 1 2 3\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n; int st[N]; // 0表示还没考虑，1表示已选，2表示未选 void dfs(int u) { if (u == n) { for (int i = 0; i < n; i++) if (st[i] == 1) cout << i + 1 << ' '; cout << endl; return; } st[u] = 2; dfs(u + 1); st[u] = 0; st[u] = 1; dfs(u + 1); st[u] = 0; } int main() { cin >> n; dfs(0); return 0; }\"]},\"288\":{\"h\":\"\",\"t\":[\"题目描述\",\"把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。\",\"输入格式\",\"一个整数 n。\",\"输出格式\",\"按照从小到大的顺序输出所有方案，每行 1 个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。\",\"数据范围\",\"1⩽n⩽9\",\"输入样例：\",\"3\",\"输出样例：\",\"1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 10; int n; int st[N]; // 0表示还没放数，1~n表示放的哪些数 bool vis[N]; // 标记是否使用过 void dfs(int u) { if (u > n) { for (int i = 1; i <= n; i++) // 输出方案 cout << st[i] << ' '; puts(\\\"\\\"); return; } // 依次枚举每个分支，即当前位置能填哪些数 for (int i = 1; i <= n; i++){ if (!vis[i]){ st[u] = i; vis[i] = true; dfs(u + 1); // 恢复现场 st[u] = 0; vis[i] = false; } } } int main() { cin >> n; dfs(1); return 0; }\"]},\"289\":{\"h\":\"\",\"t\":[\"题目描述\",\"从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。\",\"输入格式\",\"两个整数 n,m，在同一行用空格隔开。\",\"输出格式\",\"按照从小到大的顺序输出所有方案，每行 1 个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。\",\"数据范围\",\"n>0 ,0⩽m⩽n ,n+(n−m)⩽25\",\"输入样例：\",\"5 3\",\"输出样例：\",\"1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 30; int n, m; int way[N]; void dfs(int u, int start) // u表示第几位，i表示从哪个数开始 { if (u + n - start < m) return; // 剪枝，若剩下可选的数字不能填满剩下的空位则回退 if (u > m) { for (int i = 1; i <= m; i++) cout << way[i] << ' '; puts(\\\"\\\"); return; } for (int i = start; i <= n; i++) // 从start开始枚举剩下的可选数字 { way[u] = i; dfs(u + 1, i + 1); way[u] = 0; // 恢复现场 } } int main() { cin >> n >> m; dfs(1, 1); return 0; }\"]},\"290\":{\"h\":\"\",\"t\":[\"题目描述\",\"翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。 经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕>_<）。 翰翰和达达只好花钱让它们坐索道下山。 索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1​、C2​……CN​。 当然，每辆缆车上的小猫的重量之和不能超过 W。 每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？\",\"输入格式\",\"第 1 行：包含两个用空格隔开的整数，N 和 W。 第 2∼N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci​。\",\"输出格式\",\"输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。\",\"数据范围\",\"1⩽N⩽18 ,1⩽Ci​⩽W⩽108\",\"输入样例：\",\"5 1996 1 2 1994 12 29\",\"输出样例：\",\"2\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n, m; int c[N]; // 每只猫的重量 int s[N]; // 每辆车所搭载的重量 int res = N; // 初始最坏情况下一只猫一辆车 void dfs(int u, int k) // u只猫，k辆车 { if (k >= res) return; if (u == n){ res = k; return; } for (int i = 0; i < k; i++) // 对每辆车进行枚举 { if (s[i] + c[u] <= m) // 若不超过最大载重 { s[i] += c[u]; dfs(u + 1, k); s[i] -= c[u]; } } // 否则需要再加一辆车 s[k] = c[u]; dfs(u + 1, k + 1); s[k] = 0; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> c[i]; sort(c, c + n, greater()); dfs(0, 0); // 0只猫，0辆车 cout << res << endl; return 0; }\"]},\"291\":{\"h\":\"\",\"t\":[\"题目描述\",\"100 可以表示为带分数的形式：100=3+71469258​\",\"还可以表示为：100=82+1973546​\",\"注意特征：带分数中，数字 1∼9 分别出现且只出现一次（不包含 0）。\",\"类似这样的带分数，100 有 11 种表示法。\",\"输入格式\",\"一个正整数。\",\"输出格式\",\"输出输入数字用数码 1∼9 不重复不遗漏地组成带分数表示的全部种数。\",\"数据范围\",\"1⩽N<106\",\"输入样例1：\",\"100\",\"输出样例1：\",\"11\",\"输入样例2：\",\"105\",\"输出样例2：\",\"6\",\"思路\",\"题目意思是说，用 1∼9 的 9 个数，构造成一个整数和一个分数，每个数都要用到且只出现一次，分数不考虑约分的情况。可以理解为，构造成 n=a+cb​ 的形式，要求将 9 个数划分给 a,b,c 三个数，9​ 个数必须不重不漏。\",\"步骤：\",\"枚举全排列\",\"枚举位数，a,b,c 三个数的位数可能都不一样\",\"将 a,b,c 转化为数字，带入等式中看是否成立\",\"将 n=a+cb​ 转化为 cn=ca+b ，只需要枚举 a 和 c 即可，最后判断 b=cn−ca 是否成立。从 a 开递递归枚举，每次递归的同时也对 c 枚举，然后每次都 check(a,c) 是否满足条件，若满足则答案 +1 。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n; bool st[N], backup[N]; int ans; bool check(int a, int c) { int b = c * n - c * a; if (!a || !b || !c) return false; memcpy(backup, st, sizeof st); // 备份 while (b) { int x = b % 10; // 取出b的每一位 b /= 10; if (!x || backup[x]) // 判断每一位上的数字是否用过 return false; // 用过则不合法 backup[x] = true; // 没用过则标记 } for (int i = 1; i <= 9; i++) if (!backup[i]) // 如果有一位没用上，则不合法 return false; return true; } void dfs_c(int u, int a, int c) { if (u >= n) return; // 判断当前a和c是否满足条件，若满足则答案+1 if (check(a, c)) ans++; // 继续枚举 for (int i = 1; i <= 9; i++){ if (!st[i]) { st[i] = true; dfs_c(u + 1, a, c * 10 + i); // a不变，更新c st[i] = false; } } } void dfs_a(int u, int a) { if (u >= n) return; // 对a提前判断一下，能更快一点点 if (a) dfs_c(u, a, 0); // 枚举c：用了几个数，a是几，当前加入的数字是几 for (int i = 1; i <= 9; i++){ if (!st[i]) { st[i] = true; dfs_a(u + 1, a * 10 + i); // 用的数字个数+1，加入i后更新当前a的值 st[i] = false; } } } int main() { cin >> n; dfs_a(0, 0); // 枚举a：用了几个数，当前的值 cout << ans << endl; return 0; }\"]},\"292\":{\"c\":[\"笔记\"]},\"293\":{\"c\":[\"递归\"]},\"294\":{\"h\":\"动态规划\"},\"295\":{\"h\":\"1. 背包问题\",\"t\":[\"背包问题常用枚举方法\",\"第一维枚举物品\",\"第二维枚举体积\",\"第三维枚举决策\"]},\"296\":{\"h\":\"1.1 01 背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用一次。\",\"求所选物品的总体积不超过背包容量的条件下，最大的总价值。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++){ for (int j = 0; j <= m; j++){ f[i][j] = f[i - 1][j]; //左半边的子集 if (v[i] <= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } cout << f[n][m] << endl; */ //一维 //f[i] 表示总体积是i的情况下，最大价值是多少 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\"]},\"297\":{\"h\":\"1.2 完全背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用无限次。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1100; int n, m; int v[N], w[N]; int f[N]; //表示总体积是i的情况下，最大价值是多少 int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++) for (int j = 0; j <= m; j++) { f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout << f[n][m] << endl; */ //一维 for (int i = 1; i <= n; i++) for (int j = v[i]; j <= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout << f[m] << endl; return 0; }\"]},\"298\":{\"h\":\"1.3 多重背包\",\"t\":[\"有 n 件物品，背包容量为 m，每件物品有有限个。\",\"数据范围 ≤100 的写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); cout << f[n][m] << endl; /* 一维优化写法 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[j] = max(f[j], f[j - k * v[i]] + w[i] * k); } } cout << f[m] << endl; */ return 0; }\",\"数据范围较大时，需要用多重背包的二进制优化方法：\",\"第一种写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; int f[M]; int main() { cin >> n >> m; int cnt = 0; for (int i = 1; i <= n; i++){ int a, b, s; cin >> a >> b >> s; int k = 1; while (k < s){ cnt++; v[cnt] += a * k; w[cnt] += b * k; s -= k; k *= 2; } if (s){ cnt++; v[cnt] += a * s; w[cnt] += b * s; } } n = cnt; for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\",\"第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <vector> using namespace std; const int N = 2010; int n, m; int f[N]; struct Good { int v, w; }; int main() { vector<Good> goods; cin >> n >> m; for (int i = 0; i < n; i++){ int v, w, s; cin >> v >> w >> s; for (int k = 1; k <= s; k *= 2){ s -= k; goods.push_back({v * k, w * k}); } if (s > 0) goods.push_back({v * s, w * s}); } for (auto good : goods){ for (int j = m; j >= good.v; j--){ f[j] = max(f[j], f[j - good.v] + good.w); } } cout << f[m] << endl; return 0; }\"]},\"299\":{\"h\":\"1.4 分组背包\",\"t\":[\"有 n 组物品和一个容量是 m 的背包。\",\"每组物品有若干个，同一组内的物品最多只能选一个。\",\"求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\",\"（一）第一种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++){ cin >> s[i]; for (int j = 0; j < s[i]; j++){ cin >> v[i][j] >> w[i][j]; } } for (int i = 1; i <= n; i++){ for (int j = m; j >= 0; j--){ for (int k = 0; k < s[i]; k++){ if (v[i][k] <= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } } cout << f[m] << endl; return 0; }\",\"（二）第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int f[N], v[N], w[N]; int main() { cin >> n >> m; for (int i = 0; i < n; i++) { int s; cin >> s; for (int j = 0; j < s; j++) cin >> v[j] >> w[j]; for (int j = m; j >= 0; j--) for (int k = 0; k < s; k++) if (j >= v[k]) f[j] = max(f[j], f[j - v[k]] + w[k]); } cout << f[m] << endl; return 0; }\"]},\"300\":{\"h\":\"2. 线性DP\"},\"301\":{\"h\":\"2.1 数字三角形\",\"t\":[\"给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。\",\" 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5\",\"线性DP写法：\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 510, INF = 1e9; int n; int a[N][N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= i; j++) cin >> a[i][j]; for (int i = 0; i <= n; i++) for (int j = 0; j <= i + 1; j++) f[i][j] = -INF; //从上往下遍历 f[1][1] = a[1][1]; for (int i = 2; i <= n; i++) for (int j = 1; j <= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; // 状态转移方程 int ans = -INF; for (int i = 1; i <= n; i++) ans = max(ans, f[n][i]); cout << ans << endl; /*从下往上遍历 for (int i = n; i >= 1; i--) for (int j = n; j >= 1; j--) f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; cout << f[1][1] << endl; */ return 0; }\"]},\"302\":{\"h\":\"2.2 最长上升子序列\",\"t\":[\"求一个序列中严格递增的子序列的最大长度。\",\"（一）朴素DP写法：\",\"状态转移方程：if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1010; int n; int a[N]; int f[N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) { f[i] = 1; // 只有a[1]一个数 for (int j = 1; j <= i; j++) if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1); } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f[i]); cout << ans << endl; return 0; }\",\"（二）二分写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 100010; int n; int q[N]; int a[N]; int main() { cin >> n; for (int i = 0; i < n; i++) cin >> a[i]; int len = 0; q[0] = -2e9; for (int i = 0; i < n; i++) { int l = 0, r = len; while (l < r) { int mid = l + r + 1 >> 1; if (q[mid] < a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } cout << len << endl; return 0; }\",\"（三）单调队列写法：\",\"#include <iostream> #include <cstdio> #include <vector> #include <algorithm> using namespace std; const int N = 100010; int n; int main() { cin >> n; vector<int> arr(n); for (int i = 0; i < n; i++) cin >> arr[i]; vector<int> stk; //模拟堆栈 stk.push_back(arr[0]); for (int i = 1; i < n; i++) //单调队列思维 { if (arr[i] > stk.back()) //如果该元素大于栈顶元素，则将该元素入栈 stk.push_back(arr[i]); else //否则，替换掉第一个大于或等于这个数字的那个数 *lower_bound(stk.begin(), stk.end(), arr[i]) = arr[i]; } cout << stk.size() << endl; return 0; }\"]},\"303\":{\"h\":\"2.3 最长公共子序列（不连续）\",\"t\":[\"给定两个长度分别为 n 和 m 的字符串 A 和 B，\",\"求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\",\"状态转移方程：\",\"f[i][j] = max(f[i-1][j], f[i][j-1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin >> n >> m >> a + 1 >> b + 1; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"304\":{\"h\":\"2.4 最长公共上升子序列\",\"t\":[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\",\"小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\",\"小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。\",\"奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\",\"不过，只要告诉奶牛它的长度就可以了。\",\"数列 A 和 B 的长度均不超过 3000。\",\"输入格式\",\"第一行包含一个整数 N，表示数列 A,B 的长度。 第二行包含 N 个整数，表示数列 A。 第三行包含 N 个整数，表示数列 B。\",\"输出格式\",\"输出一个整数，表示最长公共上升子序列的长度。\",\"数据范围\",\"1≤N≤3000 , 序列中的数字均不超过 231−1 。\",\"输入样例：\",\"4 2 2 1 3 2 1 2 3\",\"输出样例：\",\"2\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 3010; int n; int a[N], b[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; for (int i = 1; i <= n; i++){ int mx = 1; for (int j = 1; j <= n; j++){ f[i][j] = f[i - 1][j]; if (a[i] == b[j]) f[i][j] = max(f[i][j], mx); if (a[i] > b[j]) mx = max(mx, f[i - 1][j] + 1); } } int res = 0; for (int i = 1; i <= n; i++) res = max(res, f[n][i]); cout << res << endl; return 0; }\"]},\"305\":{\"h\":\"2.5 编辑距离\",\"t\":[\"给定 n 个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。\",\"对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。\",\"每个对字符串进行的单个字符的插入、删除或替换算作一次操作。\",\"输入格式\",\"第一行包含两个整数 n 和 m。 接下来 n 行，每行包含一个字符串，表示给定的字符串。 再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。 字符串中只包含小写字母，且长度均不超过 10。\",\"输出格式\",\"输出共 m​ 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。\",\"模板代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 15, M = 1010; int n, m; int f[N][N]; char str[M][N]; int edit_distance(char a[], char b[]) { int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i <= la; i++) f[i][0] = i; for (int j = 0; j <= lb; j++) f[0][j] = j; for (int i = 1; i <= la; i++) for (int j = 1; j <= lb; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } return f[la][lb]; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> str[i] + 1; //下标从1开始存 while (m--){ char s[N]; int limit; cin >> s + 1 >> limit; int res = 0; for (int i = 0; i < n; i++) if (edit_distance(str[i], s) <= limit) res++; cout << res << endl; } return 0; }\"]},\"306\":{\"h\":\"2.6 最短编辑距离\",\"t\":[\"给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：\",\"删除 – 将字符串 A 中的某个字符删除。\",\"插入 – 在字符串 A 的某个位置插入某个字符。\",\"替换 – 将字符串 A 中的某个字符替换为另一个字符。\",\"现在请你求出，将 A 变为 B​ 至少需要进行多少次操作。\",\"状态转移方程：\",\"f[i][j] = min(f[i-1][j] + 1, f[i][j-1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i-1][j-1]); else f[i][j] = min(f[i][j], f[i-1][j-1] + 1); //状态转移方程\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; //所有将a[i]变成b[j]的操作方式 int main() { cin >> n >> a + 1; cin >> m >> b + 1; for (int i = 0; i <= n; i++) f[i][0] = i; for (int j = 0; j <= m; j++) f[0][j] = j; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"307\":{\"h\":\"3. 区间DP\",\"t\":[\"区间 DP 常用模版\",\"所有的区间 dp 问题枚举时，\",\"第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；\",\"第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）\",\"模板代码如下：\",\"for (int len = 1; len <= n; len++) { // 区间长度 for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点 int j = i + len - 1; // 区间终点 if (len == 1) { dp[i][j] = 初始值 continue; } for (int k = i; k < j; k++) { // 枚举分割点，构造状态转移方程 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); } } }\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 310; int n; int a[N], s[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> a[i]; s[i] = s[i - 1] + a[i]; } //区间DP枚举套路：长度+左端点 for (int len = 2; len <= n; len++) //先枚举长度 { for (int i = 1; i + len - 1 <= n; i++) //再枚举左端点，且保证右端点不会超范围 { int j = i + len - 1; //自动得到右端点 f[i][j] = 1e9; //初始化大于1的区间为最大，长度为1的区间为0 for (int k = i; k <= j - 1; k++) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]); } } //得到总区间的最小代价 cout << f[1][n] << endl; return 0; }\"]},\"308\":{\"h\":\"4. 计数类DP\",\"t\":[\"一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。\",\"表示前 i 个整数（1,2…,i）恰好拼成 j 的方案数 求方案数：把集合选 0 个 i，1 个 i，2 个 i，…全部加起来\",\"f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"因此 f[i][j]=f[i−1][j]+f[i][j−i] （这一步类似完全背包的推导）\",\"朴素做法：\",\"// f[i][j] = f[i - 1][j] + f[i][j - i] #include <iostream> using namespace std; const int N = 1e3 + 7, mod = 1e9 + 7; int f[N][N]; int main() { int n; cin >> n; for (int i = 0; i <= n; i ++) { f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 } for (int i = 1; i <= n; i ++) { for (int j = 0; j <= n; j ++) { f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1 if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod; } } cout << f[n][n] << endl; }\",\"一维优化：\",\" f[0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 for (int i = 1; i <= n; i ++) { for (int j = i; j <= n; j ++) { f[j] = (f[j] + f[j - i]) % mod; } } cout << f[n] << endl;\"]},\"309\":{\"h\":\"5. 数位统计类DP\",\"t\":[\"给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0 ~ 9 的出现次数。\",\"#include <bits/stdc++.h> using namespace std; int base[10]; int f[10][10]; int g[10][10]; void init() { base[0] = 1; for(int i = 1 ; i <= 9 ; i++) base[i] = base[i-1]*10; //从00……0 - 99……9 的各位数字有多少个，其中i为数字个数（包含前导零） for(int i = 0 ; i <= 9 ; i++) f[1][i] = 1; for(int i = 2 ; i <= 9 ; i++) for(int j = 0 ; j <= 9 ; j++) f[i][j] = f[i-1][j]*10 + base[i-1]; //从1 - 99……9 的各位数字有多少个，其中i为数字个数（不包含前导零） for(int i = 1 ; i <= 9 ; i++) g[1][i] = 1;//循环从1开始 for(int i = 2 ; i <= 9 ; i++) { g[i][0] = g[i-1][0] + f[i-1][0]*9; for(int j = 1 ; j <= 9 ; j++) g[i][j] = g[i-1][j] + f[i-1][j]*9 + base[i-1]; } } vector<int> dp(int n) { vector<int> ans(10,0); //记录答案 if(n<=0) return ans; //边界条件 vector<int> nums; while(n) nums.push_back(n%10), n/=10; vector<int> last(10,0); //记录前缀中各个数字个数 //统计1 - 99……9(n-1个9)里面各个数字有多少个 for(int i = 0 ; i <= 9 ; i++) ans[i] = g[nums.size()-1][i]; //统计大于10……0(n-1个0) 的树里各个数字有多少个 for(int i = nums.size()-1 ; i >=0 ; i--) { //循环变量i可以表示剩下的数字有多少个 int x = nums[i]; for(int j = i==nums.size()-1 ; j < x ; j++) { //第一次循环不能有0 //前缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k] * base[i]; //当前位置部分 ans[j] += base[i]; //后缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += f[i][k]; } //更新前缀计数器 last[x] ++; //统计叶子节点（这个数本身） if(!i) for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k]; } return ans; } vector<int> ask(int a, int b) { auto x = dp(b); auto y = dp(a-1); vector<int> ans; for(int i = 0 ; i <= 9 ; i++) ans.push_back(x[i]-y[i]); return ans; } void print(vector<int> ans) { for(auto x:ans) printf(\\\"%d \\\",x); puts(\\\"\\\"); } bool check(int x) { auto t = ask(x,x); vector<int> cnt(10,0); while(x) cnt[x%10]++,x/=10; for(int i = 0 ; i <= 9 ; i++) if(cnt[i] != t[i]) return false; return true; } int main() { init(); int a,b; while(cin >> a >> b, a||b) { if(a>b) swap(a,b); auto t = ask(a,b); print(t); } return 0; }\"]},\"310\":{\"h\":\"6. 状态压缩类DP\"},\"311\":{\"h\":\"6.1 蒙德里安的梦想\",\"t\":[\"n×m 的棋盘可以摆放不同的 1×2 小方格的种类数。\",\"状态表示：f[i][j] 表示当前摆到第 i 列的状态是 j 的所有方案。\",\"(其中 j 是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。)\",\"去除无效状态的优化写法：\",\"#include <cstring> #include <iostream> #include <algorithm> #include <vector> using namespace std; typedef long long LL; const int N = 12, M = 1 << N; int n, m; LL f[N][M]; vector<int> state[M]; bool st[M]; int main() { while (cin >> n >> m, n || m) { for (int i = 0; i < 1 << n; i ++ ) { int cnt = 0; bool is_valid = true; for (int j = 0; j < n; j ++ ) if (i >> j & 1) { if (cnt & 1) { is_valid = false; break; } cnt = 0; } else cnt++; if (cnt & 1) is_valid = false; st[i] = is_valid; } for (int i = 0; i < 1 << n; i ++ ) { state[i].clear(); for (int j = 0; j < 1 << n; j ++ ) if ((i & j) == 0 && st[i | j]) state[i].push_back(j); } memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i <= m; i ++ ) for (int j = 0; j < 1 << n; j ++ ) for (auto k : state[j]) f[i][j] += f[i - 1][k]; cout << f[m][0] << endl; } return 0; }\"]},\"312\":{\"h\":\"6.2 最短Hamilton路径\",\"t\":[\"给定一张 n 个点的带权无向图，点从 0 ~ n−1 标号，求起点 0 到终点 n−1 的最短Hamilton路径。\",\"Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。\",\"f[i][j] 表示从 0 走到 j ，走过的所有点的情况是 i 的所有路径。\",\"状态转移方程：f[i][j] = min(f[i][j], f[i-(1<<j)][k] + w[k][j]);\",\"#include<iostream> #include<cstring> #include<algorithm> using namespace std; const int N = 20, M = 1 << N; int n; int f[M][N], w[N][N];//w表示的是无权图 int main() { cin>>n; for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) cin >> w[i][j]; memset(f, 0x3f, sizeof(f)); // 因为要求最小值，所以初始化为无穷大 f[1][0] = 0; // 因为零是起点,所以f[1][0]=0; for (int i = 0; i < 1 << n; i++) // i表示所有的情况 for (int j = 0; j < n; j++) // j表示走到哪一个点 if (i >> j & 1) for (int k = 0; k < n; k++) // k表示走到j这个点之前,以k为终点的最短距离 if (i >> k & 1) // 更新最短距离 f[i][j] = min(f[i][j], f[i - (1<<j)][k] + w[k][j]); // 表示所有点都走过了,且终点是n-1的最短距离 cout << f[(1<<n) - 1][n - 1] << endl; return 0; }\"]},\"313\":{\"h\":\"7. 树形DP\"},\"314\":{\"h\":\"7.1 没有上司的舞会\",\"t\":[\"选了某个节点就不能选父节点和子节点。求最大权值和。\",\"每个人只有两种状态，则设 dp[0][i] 为第 i 个人不来，他的下属所能获得的最大快乐值；\",\"dp[1][i] 为第 i 个人来，他的下属所能获得的最大快乐值。\",\"状态转移方程：\",\"dp[0][i]=∑u=sons​max(dp[1][u],dp[0][u]) 当前节点不选，那么子节点随意\",\"dp[1][i]=∑u=sons​dp[0][u]+happy[i] 当前节点选，子节点不能选\",\"#include <bit/stdc++.h> using namespace std; int n; int dp[2][6010]; int f[2][6010]; // f[0]为父亲，f[1]为高兴值 int ind[6010]; // 入度 int vis[6010]; // 访问标记 int root; // 树的根 void dfs(int u) // 递归从后往前更新 { if (!u) return; vis[u] = 1; // 已访问 root = u; // 最后一个访问到的一定是根，所以一直更新根就行了 dp[0][f[0][u]] += max(dp[1][u] + f[1][u], dp[0][u]); // 给父亲更新 dp[1][f[0][u]] += dp[0][u]; ind[f[0][u]]--; // 更新完一个子节点 if(!ind[f[0][u]]) dfs(f[0][u]); // 在所有子节点更新后再更新（入度为0） } int main() { cin >> n; for (int i = 1; i <= n; i++) scanf(\\\"%d\\\", &f[1][i]); int a,b; for (int i = 1; i < n; i++){ scanf(\\\"%d%d\\\", &a, &b); f[0][a] = b; // 保存节点信息 ind[b]++; } for (int i = 1; i <= n; i++) if(!vis[i] && !ind[i]) // 没有被访问过，没有入度，说明是叶子节点 dfs(i); // 取根节点两种方案的最大值 printf(\\\"%d\\\\n\\\", max(dp[0][root], dp[1][root] + f[1][root])); return 0; }\"]},\"315\":{\"c\":[\"模板\",\"动态规划\"]},\"316\":{\"h\":\"基础算法\"},\"317\":{\"h\":\"1. 快速排序\",\"t\":[\"快排属于分治算法，分治算法都有三步：\",\"分成子问题\",\"递归处理子问题\",\"子问题合并\",\"主要步骤：\",\"确定分界点，可以任选 a[l]，a[r]，a[(l + r) / 2] 其中一个作为分界点。\",\"设置两个头尾指针 i, j，初始化 i = l - 1, j = r + 1 (避免发生边界问题导致死循环) ，向中间移动。每次循环都先将 i 右移和 j 左移，然后判断，如果 a[i] > a[j] 且 i < j，就交换 a[i] 和 a[j].\",\"最后根据分界点分别递归左右两部分。\",\"快排的一般写法如下：\",\"void quick_sort(int q[], int l, int r) { //递归的终止情况 if(l >= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[(l + r) / 2]; while(i < j) { do i++; while(q[i] < x); do j--; while(q[j] > x); if(i < j) swap(q[i], q[j]); } //第二步：递归处理子问题 quick_sort(q, l, j); quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤 }\"]},\"318\":{\"h\":\"2. 归并排序\",\"t\":[\"运用双指针的思想，先递归再合并。\",\"主要步骤：\",\"确定分界点。与快排不同，归并每次都将中点作为分界点，将整个序列均分为两部分。mid = (l + r) / 2\",\"递归排序。对两个子序列分别设置个指针 i, j，从头开始遍历，每次比较 a[i] 和 a[j]，将小的放入一个临时序列 temp[] 中。如果有一部分遍历完了，而另一部分还有剩余，则将剩余那一部分直接接在临时序列的后面，因为剩下的这部分一定是大于前面的。\",\"归并，合二为一。将临时序列放入原序列中。\",\"归并的一般写法如下：\",\"void merge_sort(int a[], int l, int r) { if (l >= r) return; //确定中间分界点 int mid = (l + r) >> 1; //两边递归 merge_sort(a, l, mid); merge_sort(a, mid + 1, r); int k = 0; int i = l, j = mid + 1; //比较左右两半边 while (i <= mid && j <= r) if (a[i] < a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; while (i <= mid)//左半边剩下的 temp[k++] = a[i++]; while (j <= r)//右半边剩下的 temp[k++] = a[j++]; //合并区间 for (i = l, j = 0; i <= r; i++, j++) a[i] = temp[j]; }\"]},\"319\":{\"h\":\"3. 二分算法\"},\"320\":{\"h\":\"3.1 二分查找算法模板\",\"t\":[\"二分模板一共有两个，分别适用于不同情况。\",\"算法思路：假设目标值在闭区间 [l, r]中， 每次将区间长度缩小一半，当 l = r时，我们就找到了目标值。\"]},\"321\":{\"h\":\"版本1\",\"t\":[\"当我们将区间 [l, r]划分成 [l, mid] 和 [mid + 1, r] 时，其更新操作是 r = mid 或者 l = mid + 1; ，计算 mid 时不需要加 1。\",\"C++代码模板：\",\"int bsearch_1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (a[mid] >= x) r = mid; //答案在左边界，要向下取整 else l = mid + 1; //找左端点 } return l; }\"]},\"322\":{\"h\":\"版本2\",\"t\":[\"当我们将区间 [l, r] 划分成 [l, mid - 1] 和 [mid, r] 时，其更新操作是 r = mid - 1 或者 l = mid; ，此时为了防止死循环，计算 mid 时需要加 1。\",\"C++代码模板：\",\"int bsearch_2(int l, int r) { while (l < r) { int mid = l + r + 1 >> 1; if (a[mid] <= k) l = mid; //答案在右边界，要上取整 else r = mid - 1; //找右端点 } return l; }\",\"简单来说就是：\",\"可以将模板 1 中的 check[mid] 换成a[mid] >= x ，用来查找大于等于 x 的第一个元素；\",\"将模板 2 中的 check[mid] 换成 a[mid] <= x ，用来查找小于等于 x 的最后一个元素。\"]},\"323\":{\"h\":\"3.2 二分答案模板\",\"t\":[\"一般来说，二分答案可以用来处理 “最大的最小” 或 “最小的最大” 的问题。\",\"定义区间为闭区间 [l, r] ，每次只需判断答案是否需要更新（是否记下ans）和（可能的）答案在哪一侧（改 L 还是 R ）即可。\",\"int ans; int find(int l, int r) { while (l <= r) { int mid = l + r >> 1; if (check(mid)){ ans = mid; //如果条件成立则记下答案 r = mid - 1; //判断可能的答案更新区间 } else l = mid + 1; } return ans; }\"]},\"324\":{\"h\":\"3.3 整数二分\",\"t\":[\"【例二】A-B 数对\",\"题目描述：给出一串数以及一个数字 C ，要求计算出所有 A - B = C 的数对的个数（不同位置的数字一样的数对算不同的数对）。\",\"这里使用库函数二分的写法：\",\"依次枚举 A ，将问题转变成统计数列中 B + C 出现了多少次。先对数列排序，那么 B + C 会对应这个数列的连续一段，只要找到这个连续段的左端点和右端点即可。(需使用头文件 algorithm )\",\"① lower_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 第一次出现的位置；\",\"② upper_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 最后一次出现的位置的__后面一位__ 。\",\"则这个数出现的次数就可以表示为 upper_bound() - lower_bound() ，时间复杂度为 O(nlogn).\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; const int N = 2e5 + 10; int n, c; ll a[N]; int main() { cin >> n >> c; for (int i = 0; i < n; i++) cin >> a[i]; sort(a, a + n); ll tot = 0; for (int i = 0; i < n; i++) tot += upper_bound(a, a + n, a[i] + c) - lower_bound(a, a + n, a[i] + c); cout << tot << endl; return 0; }\"]},\"325\":{\"h\":\"3.4 浮点数二分\",\"t\":[\"bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l > eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; }\"]},\"326\":{\"h\":\"4. 高精度算法\"},\"327\":{\"h\":\"4.1 高精度加法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的和。 （C = A + B，A >= 0， B >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; const int N = 1e6 + 10; // C = A + B vector<int> add(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; int t = 0; //进位，低位满10向高位进位，低位变为0 for (int i = 0; i < A.size() || i < B.size(); i++){ //两个if把两个数组相同位上的数相加 if (i < A.size()) t += A[i]; if (i < B.size()) t += B[i]; //把相加后的结果除以10求余，压入C数组中 C.push_back(t % 10); //t再除以10，放入高位 t /= 10; } //如果最高位有数，则压入C数组中 if (t) C.push_back(t); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //使用auto编译器会自动判断数据是什么类型 auto C = add(A, B); for (int i = C.size() - 1; i >= 0; i--) printf(\\\"%d\\\", C[i]); return 0; }\"]},\"328\":{\"h\":\"4.2 高精度减法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的差，计算结果可能为负数。\",\"1、前提： C = A - B，满足 A >= B，A >= 0，B >= 0 （如果 B >= A，则将其转化为 -(B - A) ）\",\"2、代码段：(只考虑正数的情况)\",\"#include <iostream> #include <vector> using namespace std; //判断是否有 A >= B bool cmp(vector<int> &A, vector<int> &B) { //A长度不等于B，若A大于B，返回true，否则返回false if (A.size() != B.size()) return A.size() > B.size(); //因为是倒序数组，高位在后面，所以从后遍历 //如果A > B, 返回true，否则返回flase for (int i = A.size() - 1; i >= 0; i--){ if (A[i] != B[i]) return A[i] > B[i]; } return true; } // C = A - B vector<int> sub(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; //定义一个借位的情况 int t = 0; for (int i = 0; i < A.size(); i++){ //t = A的这一位数 t = A[i] - t; //判断B在这一位上有没有数，如果有，则减去B[i] if (i < B.size()) t -= B[i]; //这种写法包含了两种情况：如果t >= 0, 则直接减；若t < 0, 则向高位借位(即t + 10)后再减 //将这一位相减后的结果压入C中 C.push_back((t + 10) % 10); if (t < 0) //t < 0，需要借位，标记为1 t = 1; else //t >= 0，不需要借位，标记为0 t = 0; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //如果A > B，返回A - B if (cmp(A, B)){ auto C = sub(A, B); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", C[i]); } //否则返回 -(B - A) else { auto C = sub(B, A); printf(\\\"-\\\"); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", c[i]); } return 0; }\"]},\"329\":{\"h\":\"4.3 高精度整数乘法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A × B 的值\",\"一般是 高精 × 低精，用 A × b 表示 （C = A * b，A >= 0，b >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; //C = A * b vector<int> mul(vector<int> &A, int b) { vector<int> C; int t = 0; for (int i = 0; i < A.size() || t; i++) { if (i < A.size()) t += A[i] * b; //同加法一样处理进位，逐位压入数组中 C.push_back(t % 10); t /= 10; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int b; cin >> a >> b; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) //倒序插入 A.push_back(a[i] - '0'); auto C = mul(A, b); for (int i = C.size() - 1; i >= 0; i--) //倒序输出 printf(\\\"%d\\\", C[i]); return 0; }\"]},\"330\":{\"h\":\"4.4 高精度整数除法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A / B 的商和余数 (第一行输出所求的商，第二行输出所求余数)\",\"一般是 高精 ÷ 低精，用 A ÷ b 表示 （A / b = C ··· r，A >= 0，b > 0）\",\"代码如下：\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; vector<int> div(vector<int> &A, int b, int &t) //传入t的地址，便于直接对余数进行处理 { vector<int> C; t = 0; for (int i = A.size() - 1; i >= 0; i--) { //将上次的余数×10再加上当前位的数字，得到该位的被除数 t = t * 10 + A[i]; //所得即为商在这一位的数字 C.push_back(t / b); t %= b; } //由于在除法运算中，从高位到低位运算，因此前导0在数组前面，所以需要将其翻转，将前导0置于尾部，从而便于删除前导0 reverse(C.begin(), C.end()); //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int B; cin >> a >> B; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); int t; //t为余数 auto C = div(A, B, t); for (int i = C.size() - 1; i >= 0; i--) cout << C[i]; cout << endl << t << endl; return 0; }\"]},\"331\":{\"h\":\"5. 前缀和与差分\"},\"332\":{\"h\":\"5.1 一维前缀和\",\"t\":[\"S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1]\"]},\"333\":{\"h\":\"5.2 二维前缀和\",\"t\":[\"S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\"]},\"334\":{\"h\":\"5.3 一维差分\",\"t\":[\"给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\"]},\"335\":{\"h\":\"5.4 二维差分\",\"t\":[\"给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\"]},\"336\":{\"h\":\"6. 位运算\"},\"337\":{\"h\":\"6.1 位运算符\",\"t\":[\"位运算符作用于位，并逐位执行操作。\",\"符号\",\"描述\",\"运算规则\",\"&\",\"与\",\"两个位都为1时，结果才为1\",\"|\",\"或\",\"两个位都为0时，结果才为0\",\"^\",\"异或\",\"两个位相同为0，不同为1\",\"~\",\"取反\",\"0变1，1变0\",\"<<\",\"左移\",\"各二进位全部左移若干位，高位丢弃，低位补0\",\">>\",\"右移\",\"各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）\"]},\"338\":{\"h\":\"6.2 用途\",\"t\":[\"1、按位与 (&)\",\"运算规则（全为 1，才为1）\",\"0 & 0 = 0\",\"0 & 1 = 0\",\"1 & 0 = 0\",\"1 & 1 = 1\",\"注意：负数按补码形式参加按位与运算。\",\"（1）清零\",\"如果想将一个单元清零，使其全部二进制位为 0，只要__与一个各位都为零的数值相与__，结果为零。\",\"（2）取一个数的指定位\",\"比如取数 X = 1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位与运算（X & Y = 0000 1110）即可得到 X 的指定位。\",\"（3）判断奇偶\",\"只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a & 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。\",\"2、按位或 (|)\",\"运算规则（全为 0，才为 0）\",\"0 | 0 = 0\",\"0 | 1 = 1\",\"1 | 0 = 1\",\"1 | 1 = 1\",\"（1）常用来对一个数据的某些位设置为1\",\"比如将数 X = 1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位或运算（X | Y = 1010 1111）即可得到。\",\"3、按位异或 (^)\",\"运算规则（相同为 0，不同为 1）\",\"0 ^ 0 = 0\",\"0 ^ 1 = 1\",\"1 ^ 0 = 1\",\"1 ^ 1 = 0\",\"（1）翻转指定位\",\"比如将数 X = 1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行异或运算（X ^ Y = 1010 0001）即可得到。\",\"（2）与 0 相异或值不变\",\"例如：1010 1110 ^ 0000 0000 = 1010 1110\",\"（3）交换两个数\",\"当 x == y 时，直接异或运算进行整数交换后，会导致 x = 0, y = x.\",\"为避免这种情况，必须首先判断两个数是否相等。\",\"void swap(int &a, int &b){ if (a != b){ a ^= b; b ^= a; a ^= b; } }\",\"4、按位取反 (~)\",\"运算规则（0 变 1，1 变 0）\",\"~1 = 0\",\"~0 = 1\",\"（1）使一个数的最低位为 0\",\"使 x 的最低位为 0，可以表示为：a & ~1 。~1 的值为 1111 1111 1111 1110 ，再按 与 运算，最低位一定为 0。因为 ~ 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。\",\"5、左移 (<<)\",\"定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\",\"设 a = 1010 1110，a = a << 2 将 a 的二进制位 左移2位、右补0，即得 a = 1011 1000。\",\"若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2 。比如 左移 k 位，即乘上 2k .\",\"6、右移 (>>)\",\"定义：将一个数的各二进制位全部右移若干位，正数左补 0 ，负数左补 1 ，右边丢弃。\",\"例如：a = a >> 2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。\",\"操作数每右移一位，相当于该数除以 2。比如 右移 k 位，即除以 2k .\",\"bit_operation\"]},\"339\":{\"h\":\"6.3 例题\",\"t\":[\"【例题一】n 的二进制表示中第 k 位数\",\"思路：先把第 k 位数字移动到最后一位，n 右移 k 位，即 n >> k ，再看个位是几，用 n & 1 ，合并两步后，即 n >> k & 1 .\",\"例如求 10 的二进制表示，代码如下：\",\"#include <iostream> using namespace std; int main() { int n = 10; //10的二进制表示为4位数 for (int k = 3; k >= 0; k--) cout << (n >> k & 1); return 0; }\",\"输出如下：\",\"1010\",\"【例题二】二进制中1的个数\",\"给定一个长度为 1 的数列，请你求出数列中每个数的二进制表示中 1 的个数。\",\"输入格式\",\"第一行包含整数 n .\",\"第二行包含 n 个整数，表示整个数列\",\"输出格式\",\"共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。\",\"思路：使用 lowbit(x) 来解决，其表达式为 x & -x ，其中 -x 表示补码，即源码取反加 1 ，-x = (~x + 1)。 作用：返回 x 的最后一位 1，比如 x = 1010, 则 lowbit(x) = 10 ，x = 101000, 则 lowbit(x) = 1000 .\",\"代码如下：\",\"#include <iostream> using namespace std; const int N = 100010; int lowbit(int x) { return x & -x; } int main() { int n; cin >> n; while (n--){ int x; cin >> x; int res = 0; while (x){ x -= lowbit(x); res++; } cout << res << \\\" \\\"; } return 0; }\"]},\"340\":{\"h\":\"7. 双指针算法\",\"t\":[\"for (int i = 0, j = 0; i < n; i++) { while (j < i && check(i, j)) j++; // 具体问题的逻辑 // 例如求长度 res = max(res, i - j + 1); } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\"]},\"341\":{\"h\":\"8. 离散化\",\"t\":[\"vector<int> alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l < r) { int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n }\"]},\"342\":{\"h\":\"9. 区间合并\",\"t\":[\"// 将所有存在交集的区间合并 void merge(vector<PII> &segs) { vector<PII> res; sort(segs.begin(), segs.end()); int L = -2e9, R = -2e9; for (auto seg : segs) if (R < seg.first) { if (st != -2e9) res.push_back({L, R}); L = seg.first, R = seg.second; } else R = max(R, seg.second); if (L != -2e9) res.push_back({L, R}); segs = res; }\"]},\"343\":{\"c\":[\"模板\"]},\"344\":{\"h\":\"搜索与图论\"},\"345\":{\"h\":\"1. 树与图的存储\",\"t\":[\"(1) 邻接矩阵：g [a] [b] 存储边 a -> b\",\"(2) 动态邻接矩阵：\",\"int n; struct Edge { int id, w; }; vector<Edge> h[N]; int dist[N]; void dfs(int u, int father, int distance) { dist[u] = distance; for (auto node : h[u]) if (node.id != father) dfs(node.id, u, distance + node.w); } int main() { scanf(\\\"%d\\\", &n); for (int i = 0; i < n - 1; i ++ ) { int a, b, c; scanf(\\\"%d%d%d\\\", &a, &b, &c); h[a].push_back({b, c}); h[b].push_back({a, c}); } dfs(1, -1, 0); // 寻找两点之间的最大距离 int u = 1; for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; dfs(u, -1, 0); for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; int s = dist[u]; printf(\\\"%lld\\\\n\\\", s * 10 + s * (s + 1ll) / 2); return 0; }\",\"(3) 邻接表：\",\"int n, m; //n代表点数，m代表边数 // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a->b void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } // 初始化 idx = 0; memset(h, -1, sizeof h); //存边 for (int i = 0; i < n; i++){ int a, b; cin >> a >> b; add(a, b); //无向图就再写一遍 add(b, a) }\"]},\"346\":{\"h\":\"2. 树与图的遍历\",\"t\":[\"时间复杂度 O(n + m), n 表示点数， m 表示边数\"]},\"347\":{\"h\":\"深度优先遍历\",\"t\":[\"int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } }\"]},\"348\":{\"h\":\"宽度优先遍历\",\"t\":[\"queue<int> q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } }\"]},\"349\":{\"h\":\"3. 拓扑排序\",\"t\":[\"时间复杂度 O(n+m), n 表示点数，m 表示边数\",\"1、图的拓扑序列是针对于有向图而言的，无向图是没有拓扑序列的。有向无环图被称为拓扑图。\",\"2、结论：一个有向无环图，一定至少存在一个入度为 0 的点。\",\"bool topsort() { //采用数组模拟队列的写法，头尾指针 int hh = 0, tt = -1; // d[i] 存储点i的入度，起点的入度为0 for (int i = 1; i <= n; i++) if (!d[i]) //如果不是起点 q[++tt] = i; while (hh <= tt) { int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (--d[j] == 0) q[++tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; }\"]},\"350\":{\"h\":\"4. 最短路问题\"},\"351\":{\"h\":\"4.1 单源最短路\",\"t\":[\"求从一个点到其他所有点的最短距离。\",\"分为两大类：\",\"1、所有边权都是正数（n 个点，m 条边）\",\"朴素版的Dijkstra算法，时间复杂度为 O(n2 + m) ，适合稠密图（边多，点少边比较多）\",\"堆优化版的Dijkstra算法，时间复杂度为 O(mlogn)，适合稀疏图（点多，指边相对于点不多，m 和 n 是同一个级别的类型）\",\"2、存在负权边\",\"Bellman-Ford 算法，时间复杂度为 O(nm)\",\"SPFA 算法，时间复杂度一般为 O(m)，最坏情况为 O(nm)，是Bellman-Ford算法的优化\"]},\"352\":{\"h\":\"4.1.1 朴素版 Dijkstra算法\",\"t\":[\"稠密图用邻接矩阵，稀疏图用邻接表\",\"1.逐个遍历，找到与起点最近的且未确定最短路径的点，访问加入集合并标记。\",\"2.更新第一个点到起点的最短距离，直到第n个点。\",\"__时间复杂度是 O(n2 + m)， n 表示点数，m 表示边数 __\",\"#include <iostream> #include <cstring> #include <algortihm> using namespace std; const int N = 510; int n, m; //点数和边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { //距离都初始化为无穷大 memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i < n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 //遍历n个点，找到一个未加入集合且距离最近的点 for (int j = 1; j <= n; j ++ ) if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; st[t] = true; //标记为已加入到集合中 // 用t更新其他点的距离 for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); } //如果为无穷大，说明不连通，无法形成最短路 if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { cin >> n >> m; //邻接矩阵初始化为无穷大 memset(g, 0x3f, sizeof(g)); while (m--){ int a, b, c; cin >> a >> b >> c; //存入a和b两点之间的距离（有向图） g[a][b] = min(g[a][b], c); //无向图 //g[a][b] = min(g[a][b], c); //g[b][a] = min(a[a][b], c); } cout << dijkstra() << endl; return 0; }\"]},\"353\":{\"h\":\"4.1.2 堆优化版的Dijkstra算法\",\"t\":[\"稀疏图改用__邻接表__的形式存储，可以不需要考虑重边\",\"时间复杂度是 O(mlogn)， n 表示点数，m 表示边数\",\"#define PII pair<int, int> int n; //点的数量 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //存储所有点到1号点的距离 bool st[N]; //存储每个点的最短距离是否已确定 void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; //定义一个小根堆 priority_queue<PII, vector<PII>, greater<PII>> heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"354\":{\"h\":\"4.1.3 Bellman-ford算法（存在负权边）\",\"t\":[\"1.可以用结构体存储点和边，包括负权边。\",\"2.具体步骤：两重 for 循环，迭代 n-1 次，每次备份一下，每次循环遍历所有边，更新两点之间的最短距离，如点 a->b 的更新方式为（松弛操作）\",\"for n 次 for 所有边 a, b, w (松弛操作) dist[b] = min(dist[b], backup[a] + w);\",\"backup[ ] 数组是上一次迭代后 dist[ ] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[ ] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点。\",\"3.循环 n-1 次之后，对于所有的点都 一定满足 dist[b] <= dist[a] + w，该式被称为三角不等式。\",\"4.如果图中存在负权回路，那么最短路可能为负无穷。（不是一定）\",\"5.是否能到达 n 号点的判断中需要进行 if(dist[n] > INF/2) 判断，而并非是 if(dist[n] == INF) 判断，原因是 INF 是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，``dist[n]大于某个与INF` 相同数量级的数即可。\",\"6.bellman-ford算法擅长解决有边数限制的最短路问题。\",\"时间复杂度 O(nm)， n 表示点数，m 表示边数\",\"int n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i < n; i ++ ) { for (int j = 0; j < m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] > dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] > 0x3f3f3f3f / 2) return -1; return dist[n]; }\"]},\"355\":{\"h\":\"4.1.4 SPFA算法 （存在负权边）\",\"t\":[\"1.用队列来存储\",\"2.while queue 不为空，\",\"取出作为 t ，t = q.front; q.pop();\",\"更新 t 的所有出边，如：t -> b, 把b加入 queue\",\"3.基本步骤\",\"建立一个队列，初始时队列里只有起始点\",\"再建立一个数组记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到它本身的路径赋为0）\",\"再建立一个数组，标记点是否在队列中\",\"队头不断出队，计算起始点经过队头到其他点的距离是否变短，如果变短且该点不在队列中，则把该点加入到队尾\",\"重复执行直到队列为空\",\"在保存最短路径的数组中，就得到了最短路径\",\"4.SPFA求最短路\",\"时间复杂度 平均情况下 O(m)， 最坏情况下 O(nm)， n 表示点数， m 表示边数\",\"int n, m; // 总点数和总边数 int h[N], e[M], w[M], ne[M], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 int add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue<int> q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"356\":{\"h\":\"4.1.5 SPFA算法判断图中是否存在负环\",\"t\":[\"时间复杂度 O(nm)， n 表示点数， m 表示边数\",\"int n; //总点数 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //dist[x]存储1号点到x的最短距离， int cnt[N]; //cnt[x]存储1到x的最短路中经过的点数 bool st[N]; //存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue<int> q; for (int i = 1; i <= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (cnt[j] >= n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; }\"]},\"357\":{\"h\":\"4.2 多源汇最短路\"},\"358\":{\"h\":\"4.2.1 Floyd算法\",\"t\":[\"1.使用邻接矩阵存图\",\"2.三重循环，时间复杂度O(n^3)\",\"初始化： for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (i == j) d[i][j] = 0; else d[i][j] = INF; //算法结束后，d[a][b]表示a到b的距离 for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\"]},\"359\":{\"h\":\"5. 最小生成树问题\",\"t\":[\"最小生成树就是将 n 个顶点， n - 1 条边，通过一个连接起来，且使权值最小的一种结构。\",\"换句话来说，就是给定一个无向图，在图中选择若干条边把图中的所有节点连接起来，要求边长之和最小。在图论中，叫做求最小生成树。\"]},\"360\":{\"h\":\"5.1 朴素Prim算法\",\"t\":[\"可理解为 “加点法”， 每次迭代找到不在连通块中的距离最近的点，加入到连通块中，将连通块逐渐扩大，最后将整个图连通起来，并且边长之和最小。\",\"1、先把所有距离初始化为正无穷\",\"dist[i] = +INF;\",\"2、n次迭代，找到不在集合当中的最小的点，这个集合指当前已经在连通块中的所有点，找到该点赋给 t ，用 t 更新其他点到集合的距离，再把 t 加到集合当中去\",\"先累加，再更新\",\"for (int i = 0; i < n; i++) t <- 距离最近的点; t = ture;更新t\",\"时间复杂度为 O(n2 + m)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> #define ll long long using namespace std; const int N = 1e5 + 10, M = N * 2; int n, m; // n表示点数，m表示边数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; //最小生成树所有边的长度之和 for (int i = 0; i < n; i++) { int t = -1; for (int j = 1; j <= n; j++) //如果没有在树中，且到树的距离最短，则选择该点 if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; //一定要先累加，再进行更新生成树 if (i && dist[t] == INF) return INF; if (i) //(不是起点)把找到的符合条件的点的长度加上 res += dist[t]; st[t] = true; for (int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { cin >> n >> m; memset(g, 0x3f, sizeof g); for (int i = 1; i <= m; i++){ int a, b, c; cin >> a >> b >> c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(\\\"impossible\\\"); else printf(\\\"%d\\\\n\\\", t); }\"]},\"361\":{\"h\":\"5.2 Kruskal 算法\",\"t\":[\"可理解为 “加边法”，最初最小生成树的边数为 0，每次迭代选择一条不在集合内的权值最短的边，加入到集合中，组成最小生成树。\",\"1、使用快排将所有边按权值从小到大排序。时间复杂度为 O(log n).\",\"2、从小到大依次枚举每组边 a 、b，权重 c ，如果 a、b不连通，就将这条边加入集合中，直到具有 n 个顶点的连通块筛选出来 n-1 条边为止。时间复杂度为 O(n) .\",\"3、判断 a、b是否连通的方法为：使用并查集。\",\"初始化各个顶点在不同的集合中，父节点为它自己。\",\"按快排的从小到大的顺序遍历每条边，判断这条边的两个顶点是否有相同的父节点，如果有那就使在同一个集合中。\",\"如果该条边上的两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则加入这条边到集合中，连通这两个顶点。\",\"时间复杂度是 O(mlogm)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> using namespace std; const int N = 2e5 + 10; int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 int rank[N]; // 树的高度 //结构体存储 两点及其权值 struct Edge { int a, b, w; //重载小于号，因为再给边排序的时候是按照边的权重进行排序的，这样当两个边进行比较的时候就会使用他们的权重进行比较了 bool operator< (const Edge &W)const { return w < W.w; } }edges[M]; void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int x, int y) { int px = find(x), py = find(y); if (px == py) return; if (rank[px] < rank[py]){ p[px] = py; } else { p[py] = px; if (rank[px] == rank[py]) rank[px]++; } } int kruskal() { sort(edges, edges + m); init(n); int res = 0; //存的是最小生成树的所有边的权值 int cnt = 0; //存的是当前加入的边数 for (int i = 0; i < m; i++) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; pa = find(a), pb = find(b); if (pa != pb) // 如果两个连通块不连通，则将这两个连通块合并 { union(a, b); res += w; cnt++; } } //只有当 cnt == n - 1 时才能表示已经将所有点加入到集合中，可以生成最小生成树 if (cnt < n - 1) return INF; return res; }\"]},\"362\":{\"h\":\"6. 染色法判别二分图\",\"t\":[\"二分图： 将所有点分成__两个集合__，使得__所有边__只出现在集合之间，就是 二分图\",\"性质： 一定不含有奇数环，可能包含长度为偶数的环，不一定是__连通图__。\",\"DFS思路：\",\"染色可以使用 1 和 2 区分__不同颜色__，用 0 表示 未染色\",\"遍历所有点，每次将__未染色的点__进行 dfs，默认染成 1 或 2\",\"由于某个点染色成功并不代表整个图就是二分图，因此只有某个点染色失败才能立刻 break/return，__染色失败__相当于存在两个相邻的点染成了相同的颜色\",\"时间复杂度 O(n + m)， n 表示点数，m 表示边数\",\"int n, m; //n表示点数，m表示边数 int h[N], e[M], ne[M], idx; //邻接表存储图 int color[N]; //表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 //参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i <= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; }\"]},\"363\":{\"h\":\"7. 匈牙利算法\",\"t\":[\"相关概念：\",\"匹配：在图论中，一个 [匹配] 是一个边的集合，其中任意两条边都不依附于同一个顶点。\",\"最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。\",\"完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。\",\"交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边...形成的路径叫交替路。\",\"增广路：从一个未匹配路出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。\",\"算法描述：\",\"如果你想找的妹子已经有了男朋友，\",\"你就去问问她男朋友，\",\"你有没有备胎，\",\"把这个让给我好吧\",\"多么真实而实用的算法\",\"tips：因为你要去问的都是男孩子，所以存边的时候，都是由男孩子指向女孩子\",\"时间复杂度是 O(nm)， n 表示点数，m 表示边数\",\"int n1, n2; //n1表示第一个集合中的点数，n2表示第二个集合中的点数 // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int h[N], e[M], ne[M], idx; int match[N]; //存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; //表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { //遍历所有点 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) //如果在这一轮的匹配中，这个点还未被匹配 { st[j] = true; //那就匹配并标记 //如果这个点未被匹配，且原来匹配的点能找到另一个点(下家)匹配，则匹配成功 if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i <= n1; i ++ ) { //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化 memset(st, false, sizeof st); if (find(i)) res++; }\"]},\"364\":{\"c\":[\"模板\",\"图论\"]},\"365\":{\"h\":\"数学知识\"},\"366\":{\"h\":\"1. 质数\"},\"367\":{\"h\":\"1.1 试除法判定质数\",\"t\":[\"从小到大遍历，只判断能否被小于 sqrt(x) 的数整除。\",\"时间复杂度为 O(sqrt(n)).\",\"bool is_prime(int x) { if (x < 2) return false; for (int i = 2; i <= x / i; i++) if (x % i == 0) return false; return true; }\"]},\"368\":{\"h\":\"1.2 试除法分解质因数\",\"t\":[\"从小到大尝试 n 的所有因数，每个正整数都能够以唯一的方式表示成它的质因数的乘积。\",\"结论：n 中最多只包含一个大于 sqrt(n) 的因子。\",\"反证法证明：如果有两个大于 sqrt(n) 的因子，那么相乘会大于 n。于是我们发现只有一个大于 sqrt(n) 的因子，可以对其进行优化。如果最后 n 还是 >1，说明这就是大于 sqrt(n) 的唯一质因子，输出即可。\",\"时间复杂度为 O(log n) ~ O(sqrt(n)).\",\"void divide(int x) { for (int i = 2; i <= x / i; i++) if (x % i == 0) { int s = 0; //s表示次幂 while (x % i == 0) { x /= i; s++; } cout << i << ' ' << s << endl; //输出i的s次幂 } if (x > 1) cout << x << ' ' << 1 << endl; cout << endl; }\"]},\"369\":{\"h\":\"汇总\",\"t\":[\"// 假设输入都是正数 // 素数测试 O(√n) bool is_prime(int n) { for (int i = 2; i <= n / i; i++){ if (n % i == 0) return false; } return n != 1; } // 约数枚举 O(√n) vector<int> divisor(int n) { vector<int> res; for (int i = 1; i <= n / i; i++){ if (n % i == 0){ res.push_back(i); if (i != n / i) res.push_back(n / i); } } return res; } // 整数分解 O(√n) map<int, int> prime_factor(int n) { map<int, int> res; for (int i = 2; i <= n / i; i++){ while (n % i == 0){ ++res[i]; n /= i; } } if (n != 1) res[n] = 1; return res; }\"]},\"370\":{\"h\":\"1.3 筛法求素数\"},\"371\":{\"h\":\"1.3.1 朴素筛法（埃氏筛）\",\"t\":[\"从 2 到 n 枚举，（一个数的倍数一定是合数）筛掉它的倍数，如果该数没有被筛掉，那它就是一个质数。\",\"（1）调和级数：当 n 趋于无穷大时，1 + 1/2 + 1/3 + … + 1/n = ln n + C.\",\"（2）对朴素筛法的优化：任何一个合数都能写成几个质数相乘的形式。只需要判断 2 ~ n-1 中的所有质数，只要它不是 n 的约数，那么 n 就是一个质因数。\",\"（3）质数定理：1~n 当中有 n/ln n 个质数。\",\"（4）思路：从小到大枚举所有的质数，然后删去它们的所有的倍数，就删去了所有的合数，剩下的就是质数。\",\"时间复杂度为 O(n ln ln n).\",\"int primes[N], cnt; // primes[]存储所有素数，cnt记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (st[i]) continue; primes[cnt++] = i; for (int j = i; j <= n; j += i) //用质数把其所有的倍数都筛掉 st[j] = true; } }\"]},\"372\":{\"h\":\"1.3.2 区间筛法\",\"t\":[\"给定整数 a 和 b ，问区间 [a,b) 内有多少个素数。\",\"解法：\",\"因为 b 以内的合数的最小质因数一定不超过 b​ ，如果有 b​ 以内的素数表的话，就可以把埃氏筛法运用在 [a,b) 上了。\",\"所以先预处理好 [a,b​) 和 [a,b) 的素数表，然后从 [a,b​) 的表中筛得素数的同时，也将其倍数从 [a,b) 的表中划去，最后剩下的就是区间 [a,b) 内的素数了。\",\"#define ll long long bool is_primes[N]; bool is_primes2[N]; void get_prime(ll a, ll b) { for (int i = 0; (ll)i * i < b; i++) is_primes2[i] = true; for (int i = 0; i < b - a; i++) is_prime[i] = true; // is_primes[i - a] = true => i是素数 for (int i = 2; (ll)i * i < b; i++){ if (is_primes2[i]){ for (int j = 2 * i; (ll)j * j < b; j += i) is_primes2[j] = true; for (ll j = max(2LL, (a + i - 1) / i; j < b; j += i) is_primes[j - a] = false; } } }\"]},\"373\":{\"h\":\"1.3.3 线性筛（欧拉筛）\",\"t\":[\"核心思路：用最小质因子去筛合数。\",\"当 i % primes[j] != 0 时， 说明此时遍历到的 primes[j] 不是 i 的质因子，只可能是此时 primes[j] 的最小质因子， 所以 primes[j] * i 的最小质因子就是 primes[j].\",\"当有 i % primes[j] == 0 时， 因为我们是从小到大遍历的，说明此时的 prime[j] 是满足条件的第一个数，即找到了 primes[j] 就是 i 的最小质因子， 因此 primes[j] * i 的最小质因子也就是 primes[j]， 之后用 st[primes[j + 1] * i] = true 去筛合数时，就不是用最小质因子去更新了， 所以此时应该退出循环，避免重复筛选。\",\"时间复杂度为 O(k)\",\"int primes[N]; // primes[]存储所有素数 int cnt; //记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] <= n / i; j++) { //标记，pj一定是pj*i的最小质因子 st[primes[j] * i] = true; //从小到大遍历，如果 i%pj=0，则pj一定是i的最小公因子 if (i % primes[j] == 0) break; } } }\"]},\"374\":{\"h\":\"2. 约数\"},\"375\":{\"h\":\"2.1 试除法求所有约数\",\"t\":[\"从小到大判断，如果当前数能整除目标数，说明这个数是它的一个约数。\",\"vector<int> get_divisors(int x) { vector<int> res; //从小到大枚举n的所有约数对里面比较小的那一个 for (int i = 1; i <= x / i; i++) if (x % i == 0) { res.push_back(i); //特判最中间的数 if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; }\"]},\"376\":{\"h\":\"2.2 约数个数和约数之和\",\"t\":[\"如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\",\"约数之和\",\"#include <iostream> #include <algorithm> #include <unordered_map> #include <vector> using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin >> n; unordered_map<int, int> primes; while (n -- ) { int x; cin >> x; for (int i = 2; i <= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x > 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; } cout << res << endl; return 0; }\"]},\"377\":{\"h\":\"2.3 最大公约数与最小公倍数\",\"t\":[\"欧几里得算法（辗转相除法)：\",\"每次都让较大的数对较小数取模，可以缩小问题规模而保持最大公约数不变，然后重复(递归)这个步骤。递归边界使某数变成了0，而此时另一个数即为所求答案.\",\"最坏情况下的时间复杂度为 O(log max(x, y))。\",\"对于大多数情况，辗转相除法时间可以忽略不计。\",\"int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\",\"用两数之积除以他们的最大公约数可得最小公倍数：\",\"int lcm(int a, int b) { return a * gcd(a, b) / b; //注意乘除的先后顺序，防止溢出 }\"]},\"378\":{\"h\":\"3. 欧拉函数\"},\"379\":{\"h\":\"3.1 求欧拉函数\",\"t\":[\"欧拉函数的定义\",\"1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)。 若在算数基本定理中，N=p1a1​​p2a2​​...pmam​​ ，则：ϕ(N)=N×p1​p1​−1​×p2​p2​−1​×…×pm​pm​−1​\",\"//求x的欧拉函数 int phi(int x) { int res = x; for (int i = 2; i <= x / i; i++) //分解质因数 if (x % i == 0) { res = res / i * (i - 1); //用上面的公式定义求，先整除再乘 while (x % i == 0) x /= i; } if (x > 1) res = res / x * (x - 1); return res; }\"]},\"380\":{\"h\":\"3.2 筛法求欧拉函数\",\"t\":[\"思路：质数 i 的欧拉函数即为 phi[i] = i - 1：1 ~ i−1均与 i 互质，共 i−1个。phi[primes[j] * i] 分为两种情况： ① i % primes[j] == 0 时：primes[j] 是 i 的最小质因子，也是 primes[j] * i 的最小质因子，因此 1 - 1 / primes[j] 这一项在 phi[i] 中计算过了，只需将基数 N 修正为 primes[j] 倍，最终结果为 phi[i] * primes[j] 。 ② i % primes[j] != 0：primes[j] 不是 i 的质因子，只是 primes[j] * i 的最小质因子，因此不仅需要将基数 N 修正为 primes[j] 倍，还需要补上 1 - 1 / primes[j] 这一项，因此最终结果 phi[i] * (primes[j] - 1) 。\",\"int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i <= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] <= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } }\"]},\"381\":{\"h\":\"4. 快速幂\",\"t\":[\"基本思路：\",\"预处理出 a20,a21,a22,...,a2logk 这 k 个数\",\"将 ab 用 a20,a21,a22,...,a2logk 这 k 个数来组合，即组合成 ab=a2x1​×a2x2​×...×a2xt​=a2x1​+2x2​+...+2xt​​\",\"即用二进制来表示\",\"k&1 就是判断 k 的二进制表示中第 0 位上的数是否为 1，若为 1，则为 true，反之为 false.\",\"k&1 也可以用来判断奇数和偶数，b&1 = true 时为奇数，b&1 = false 时为偶数。\",\"求 ak mod p， 时间复杂度为 O(logk)\",\"int qmi(int a, int k, int p) { int res = 1 % p; while (k) { if (k&1) res = res * a % p; k >>= 1; a = a * a % p; } return res; }\"]},\"382\":{\"h\":\"5. 扩展欧几里得算法\"},\"383\":{\"h\":\"裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\",\"用于求解方程 ax+by=gcd(a,b)​ 的解\",\"当 b=0 时，ax+by=a 所以有 x=1,y=0\",\"当 b=0 时 ，因为 $gcd(a, b) = gcd(b, a % b) $\",\"​ 所以 x=y′,y=x′−[a/b]∗y′\",\"求整数 x 和 y 使得 ax+by=1\",\"如果 gcd(a,b)=1，显然无解。反之，若 gcd(a,b)=1 ，则可以通过扩展欧几里得来求解。\",\"事实上，一定存在整数对 (x,y) 使得 ax+by=gcd(a,b) .\",\"// 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; }\"]},\"384\":{\"h\":\"6. 中国剩余定理\",\"t\":[\"给定 2n 个整数 a1​,a2​,...,an​ 和 m1​,m2​,...,mn​ ，求一个最小的非负整数 x ，满足 ∀i∈[1,n],x≡mi​(modai​) .\",\"输入格式\",\"第 1 行包含整数 n。\",\"第 2...n+1 行：每 i+1 行包含两个整数 ai​ 和 mi​ ，数之间用空格隔开。\",\"输出格式\",\"输出最小非负整数 x ，如果 x 不存在，则输出 -1.\",\"如果存在 x ，则数据保证 x 一定在 64 位整数范围内。\",\"思路\",\"对于每两个式子，将其等价转换\",\"用扩展欧几里得算法找出一组解\",\"并且判断是否有解\",\"找到最小整数解\",\"等效替代\",\"相当于是每次考虑合并两个式子，将这 n 个式子合并 n - 1 次后变为一个式子。最后剩下的式子就满足我们的答案。\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; //扩展欧几里得 ll exgcd(ll a, ll b, ll &x, ll &y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } //可能为负数，取模加模再取模 ll inline mod(ll a, ll b) { return ((a % b) + b) % b; } int main() { ll n; scanf(\\\"%lld\\\", &n); ll a1, m1; scanf(\\\"%lld%lld\\\", &a1, &m1); for (ll i = 1; i < n; i++) { ll a2, m2, k1, k2; scanf(\\\"%lld%lld\\\", &a2, &m2); ll d = exgcd(a1, -a2, k1, k2); if ((m2 - m1) % d) { puts(\\\"-1\\\"); return 0; } k1 = k1 * (m2 - m1) / d; k1 = mod(k1, abs(a2 / d)); m1 = m1 + k1 * a1; a1 = abs(a1 / d * a2); } printf(\\\"%lld\\\\n\\\", m1); return 0; }\"]},\"385\":{\"h\":\"7. 高斯消元\",\"t\":[\"给定一个包含 n 个方程 n 个未知数的线性方程组。方程组中的系数为实数。\",\"要求求解这个方程组。\",\"（线性代数方法解非齐次线性方程组）\",\"前置知识：初等行（列）变换\",\"把某一行乘一个非00的数 (方程的两边同时乘上一个非00数不改变方程的解)\",\"交换某两行 (交换两个方程的位置)\",\"把某行的若干倍加到另一行上去 （把一个方程的若干倍加到另一个方程上去）\",\"高斯消元适用解法\",\"通过初等行变换把 增广矩阵 化为 阶梯型矩阵 并回代得到方程的解\",\"适用于求解包含 n 个方程，n 个未知数的多元线性方程组\",\"算法步骤\",\"枚举每一列c,\",\"找到当前列绝对值最大的一行\",\"用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）\",\"用初等行变换(1) 将该行的第一个数变成 11 （其余所有的数字依次跟着变化）\",\"用初等行变换(3) 将下面所有行的当且列的值变成 0\",\"时间复杂度为 O(n^3)\",\"const int eps = 1e-6; //控制精度，小于eps视为0 int a[N][N]; // a[N][N]是增广矩阵 int gauss() { int r, c; //行row,列col for (r = 0, c = 0; c < n; c ++ ) { int t = r; // 找到绝对值最大的行 for (int i = r; i < n; i ++ ) if (abs(a[i][c]) > abs(a[t][c])) t = i; if (abs(a[t][c]) < eps) continue; // 将绝对值最大的行换到最顶端 for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); // 将当前行的首位变成1 for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; // 用当前行将下面所有的列消成0 for (int i = r + 1; i < n; i ++ ) if (fabs(a[i][c]) > eps) for (int j = n; j >= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r < n) { for (int i = r; i < n; i ++ ) if (fabs(a[i][n]) > eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i >= 0; i -- ) for (int j = i + 1; j < n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 }\"]},\"386\":{\"h\":\"8. 求组合数\"},\"387\":{\"h\":\"8.1 递推法求组合数\",\"t\":[\"适用题型：\",\"给定两个正整数 a 与 b ，求 Cab​mod(1e9+7)\",\"递推式：\",\"Cab​=Ca−1b−1​+Ca−1b​\",\"// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i < N; i++) for (int j = 0; j <= i; j++) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\"]},\"388\":{\"h\":\"8.2 通过预处理逆元的方式求组和数\",\"t\":[\"用 infact(a!) 表示 a! 的逆元\",\"Cab​=b!∗(a−b)!a!​=a!∗infact(b!)∗infact((a−b)!)\",\"快速幂求逆元\",\"费马小定理：如果 p 是一个质数，而整数 a 不是 p 的倍数，则有 ap−1≡1(modp) .\",\"乘法逆元的定义\",\"若整数 b, m 互质，并且对于任意的整数 a，如果满足 b | a，则存在一个整数 x，使得 a / b ≡ a * x (mod m) ，则称 x 为 b 的模 m 乘法逆元，记为 b−1(modm) .\",\"b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，bm−2 即为 b 的乘法逆元。\",\"结论：当 b 与 m 互质时，b 的乘法逆元为 bm−2.\",\"​ 当 b 为 m 的倍数时，b 的逆元不存在。b∗x%m==0 ，b 乘任意一个 x % m 一定等于 0.\",\"首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i < N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; }\"]},\"389\":{\"h\":\"8.3 卢卡斯(Lucas)定理求组合数\",\"t\":[\"给定 n 组询问，每组询问给定三个整数 a,b,p，其中 p 是质数，请你输出 Cab​modp 的值。\",\"Lucas 定理：Cab​≡Ca%pb%p​∗Cpa​pb​​(modp)\",\"Cba​=(a−b!)∗b!a!​=(a−b)∗(a−b−1)∗…∗1∗b!a∗(a−1)∗(a−2)∗…∗(a−b+1)∗(a−b)∗…∗1​=b!a∗(a−1)∗(a−2)∗…(a−b+1)​\",\"因此可以递推的每次乘 a 然后 除以 b ，因为从 a 到 a - b + 1，所以是乘 b 次。\",\"若p是质数，则对于任意整数 1 <= m <= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k, int p) // 快速幂模板 { int res = 1 % p; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a < b) return 0; LL x = 1, y = 1; // x是分子，y是分母 for (int i = a, j = 1; j <= b; i --, j ++ ) { x = (LL)x * i % p; y = (LL)y * j % p; } return x * (LL)qmi(y, p - 2, p) % p; } int lucas(LL a, LL b, int p) { if (a < p && b < p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } int main() { int n; cin >> n; while (n--) { ll a, b, p; cin >> a >> b >> p; cout << lucas(a, b, p) << endl; } return 0; }\"]},\"390\":{\"h\":\"8.4 分解质因数法求组合数\",\"t\":[\"输入 a, b，求 Cab​ 的值。\",\"方法：对阶乘分解质因数之后，用高精度相乘即可。\",\"步骤：\",\"筛素数\",\"求每个质数的次数\",\"用高精度乘法把所有质因子乘上\",\"当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i <= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] <= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n!中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector<int> mul(vector<int> a, int b) // 高精度乘低精度模板 { vector<int> c; int t = 0; for (int i = 0; i < a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i < cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector<int> res; res.push_back(1); for (int i = 0; i < cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j < sum[i]; j ++ ) res = mul(res, primes[i]);\"]},\"391\":{\"h\":\"8.5 卡特兰数\",\"t\":[\"给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\"]},\"392\":{\"h\":\"9. 容斥原理\",\"t\":[\"给定一个整数 n 和 m 个不同的质数 p1​,p2​,...,pm​ .\",\"请你求出 1 ~ n 中能被 p1​,p2​,...,pm​​ 中至少一个数整除的整数有多少个。\",\"记 Si​ 为 1 ~ n 中能整除 pi​​ 的集合，根据容斥原理，所有数的个数为各个集合的并集，计算公式如下\",\"#include<iostream> using namespace std; #define ll long long const int N = 20; int p[N], n, m; int main() { cin >> n >> m; for(int i = 0; i < m; i++) cin >> p[i]; int res = 0; //枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合) for(int i = 1; i < 1 << m; i++) { int t = 1; //选中集合对应质数的乘积 int s = 0; //选中的集合数量 //枚举当前状态的每一位 for(int j = 0; j < m; j++){ //选中一个集合 if(i >> j & 1){ //乘积大于n, 则n/t = 0, 跳出这轮循环 if((LL)t * p[j] > n){ t = -1; break; } s++; //有一个1，集合数量+1 t *= p[j]; } } if(t != -1) { if (s % 2) //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量 res += n / t; else //反之则为 -1 res -= n / t; } } cout << res << endl; return 0; }\"]},\"393\":{\"h\":\"10. 博弈论\"},\"394\":{\"h\":\"10.1 NIM游戏\",\"t\":[\"必胜状态和必败状态\",\"必胜状态，先手进行__某一个操作__，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即__先手可以走到某一个必败状态__。\",\"必败状态，先手__无论如何操作__，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即__先手走不到任何一个必败状态__。\",\"给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\",\"我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\",\"定理： NIM博弈先手必胜，当且仅当 a1 ^ a2 ^ … ^ an != 0\",\"#include <iostream> #include <algorithm> using namespace std; int main() { int n; cin >> n; int res = 0; while (n--) { int x; cin >> x; res ^= x; //每次异或操作 } if (res) puts(\\\"Yes\\\"); else puts(\\\"No\\\"); return 0; }\"]},\"395\":{\"h\":\"10.2 公平组合游戏ICG\",\"t\":[\"若一个游戏满足：\",\"由两名玩家交替行动；\",\"在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\",\"不能行动的玩家判负；\",\"则称该游戏为一个公平组合游戏。\",\"NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件 2 和条件 3 。\"]},\"396\":{\"h\":\"10.3 有向图游戏\",\"t\":[\"给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\"]},\"397\":{\"h\":\"10.4 Mex运算\",\"t\":[\"设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\"]},\"398\":{\"h\":\"10.5 SG游戏\",\"t\":[\"在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\"]},\"399\":{\"h\":\"10.6 有向图游戏的和\",\"t\":[\"设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\",\"定理\",\"有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\"]},\"400\":{\"c\":[\"模板\",\"数学\"]},\"401\":{\"h\":\"数据结构\"},\"402\":{\"h\":\"1. 数组模拟链表\"},\"403\":{\"h\":\"1.1 单链表\",\"t\":[\"也称静态链表（邻接表：n 个链表，主要应用：存储图和树）单链表只能存储当前节点的值和指向下一节点的指针，无法存储上一节点\",\"// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; //-1表示不存在， idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a,; ne[idx] = head,; head = idx ++ ; } // 将一个新的节点x插入下标是k的后面 void add(int k, int x){ e[idx] = x; // 1.先存值 ne[idx] = ne[k]; // 2.新节点的下一节点指向 k 指向的下一节点 ne[k] = idx; // 3.k指向的下一节点指向新节点 idx++; // 4.index指向下一个指针 } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将下标是k的点后面的点删掉 void remove(int x){ // 直接将其指向下下个节点，在算法竞赛中一般不需要考虑删除的那个节点该如何处理 ne[k] = ne[ne[k]]; }\"]},\"404\":{\"h\":\"1.2 双链表\",\"t\":[\"（主要用来优化某些问题）有两个指针，一个指向前，一个指向后。\",\"// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { // 0是左端点，1是右端点 r[0] = 1; l[1] = 0; idx = 2; // 0和1都被占用了，所以idx从2开始 } // 在节点k的右边插入一个数x // 如果要插在k的左边，就把k改为l[k] void insert(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx++; } // 删除第k个点 void remove(int k) { l[r[k]] = l[k]; r[l[k]] = r[k]; }\"]},\"405\":{\"h\":\"2. 栈\",\"t\":[\"先进后出\"]},\"406\":{\"h\":\"2.1 普通栈\",\"t\":[\"// tt表示栈顶 int stk[N]; //栈数组从0开始 int tt = 0; // 向栈顶插入一个数 stk[++tt] = x; // 从栈顶弹出一个数 tt--; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt > 0) not empty { } else empty\"]},\"407\":{\"h\":\"2.1 单调栈\",\"t\":[\"给定一个序列，找到每一个数左边离他最近的比它小的数。\",\"性质：如果 ax​≥ay​,x<y，那么 ax​ 永远不会被输出，可以删掉。比如 a3​≥a5​，那么 a3​ 永远不会被输出。\",\"常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i <= n; i++) { while (tt && check(stk[tt], i)) tt--; stk[++tt] = i; }\"]},\"408\":{\"h\":\"3. 队列\",\"t\":[\"先进先出，后进后出\"]},\"409\":{\"h\":\"3.1 普通队列\",\"t\":[\"// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[++tt] = x; // 从队头弹出一个数 hh++; // 队头的值 q[hh]; //同理队尾 q[tt] // 判断队列是否为空 if (hh <= tt) not empty { } else empty\"]},\"410\":{\"h\":\"3.2 单调队列\",\"t\":[\"求滑动窗口里的最大值和最小值。用单调队列来优化。\",\"步骤：\",\"判断队头是否已经滑出窗口\",\"判断当前元素与队尾元素是否满足单调性问题\",\"若满足条件，弹出队尾元素，将当前元素加入队尾\",\"如果窗口满足条件，则输出结果\",\"【注意】队列里面存的是下标\",\"常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i < n; i++) { //判断队头是否滑出窗口 if (hh <= tt && check_out(q[hh])) hh++; //判断当前元素与队尾元素是否满足单调性问题 while (hh <= tt && check(q[tt], i)) tt--; q[++tt] = i; //将当前元素加入到队尾 //如果满足条件再输出结果 if() }\"]},\"411\":{\"h\":\"4. KMP\",\"t\":[\"关于为什么求 next 数组和匹配的操作类似： 因为本质是一样的：对于 S 串每一个特定的下标 i，在满足 s[i-j+1，i]=p[0，j] 的前提下，我们需要找出 j 的最大值。 唯一不同的在于，求 next 数组时，我们关心对于每个不同的下标 i,j 能走多远；匹配时，我们只关心 j 是否走到末尾.\",\"非常有意思的说法是： 求 next 数组时，对于每个 i：\\\"j走到哪了呀？我用数组记录一下你的位置\\\" 匹配时，对于每个 i：\\\"到终点和我说声，匹配完我输出一下，没事别叫我。\\\"\",\"#include <iostream> using namespace std; const int N = 100010, M = 10010; // N为模式串长度，M匹配串长度 int n, m; int ne[M]; // next[]数组，避免和头文件next冲突 char s[N], p[M]; // s为模式串， p为匹配串 int main() { cin >> n >> s+1; cin >> m >> p+1; //下标从1开始 // 求next[]数组 for (int i = 2, j = 0; i <= m; i++) { while (j && p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } // 匹配操作 for (int i = 1, j = 0; i <= n; i++) { while (j && s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == m) // 满足匹配条件，打印开头下标, 从0开始 { // 匹配完成后的具体操作 // 如：输出以0开始的匹配子串的首字母下标 // printf(\\\"%d \\\", i - m); (若从1开始，加1) j = ne[j]; // 再次继续匹配 } } return 0; }\"]},\"412\":{\"h\":\"5. Trie树\",\"t\":[\"Trie 树又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构。\",\"存储形式如下：\",\"Trie树存储形式\",\"// son[][]存储树中每个节点的子节点，因为存的都是英文字母，最多有26个 int son[N][26]; int cnt[N]; // cnt[]存储以每个节点结尾的单词数量 int idx; // 存储当前用到的下标，0号点既是根节点，又是空节点 // 插入一个字符串 void insert(char *str) { int p = 0; // 字符串以'0'结尾，所以可以用str[i]结束 for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; }\"]},\"413\":{\"h\":\"6. 并查集\"},\"414\":{\"h\":\"6.1 朴素并查集\",\"t\":[\" int p[N]; // 存储每个点的祖宗节点 int rank[N]; // 树的高度 // 初始化，假定节点编号是1~n void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 合并x和y所在的两个集合： void union(int x, int y) { int px = find(x), py = find(y); if (rank[px] < rank[py]){ p[px] = py; rank[py] += rank[px]; } else { p[py] = px; rank[px] += rank[py]; } }\"]},\"415\":{\"h\":\"6.2 维护size的并查集\",\"t\":[\" int p[N], size[N]; // p[]存储每个点的祖宗节点 // size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);\"]},\"416\":{\"h\":\"6.3 维护到祖宗节点距离的并查集\",\"t\":[\" int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\"]},\"417\":{\"h\":\"7. 堆\",\"t\":[\"1、作用：维护一个数组集合\",\"2、堆是一棵（完全）二叉树，长得非常平衡，除最后一层节点，所有节点均不为空，最后一层节点从左向右排列，根节点小于等于左右两个子节点，即小根堆。\",\"3、存储：用一个一维数组存储树，下标从 1 开始。其中元素 x 的左儿子为 2x，x 的右儿子为 2x+1.\",\"4、5个基本操作\",\"heap 表示堆，size 表示大小\",\"1. 插入一个数 heap[++size] = x; up(size); 2. 求集合当中的最小值 heap[1]; 3. 删除最小值 heap[1] = heap[size]; size--; down(1); 4. 删除任意一个元素 heap[k] = heap[size]; size--; down(k); up(k); //down和up只会执行其中一个 5. 修改任意一个元素 heap[K] = x; down(k); up(k);\",\"// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) // 跟两个儿子比较大小 { // t表示该元素与它的左、右儿子相比最小的元素，初始化为它自身 int t = u; // 若左二子小于它，则最小的数为左二子 if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2; // 若右儿子小于它，则最小的数为右儿子 if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1; // 如果它本身不是最小的数，则往下沉，继续down()操作 if (u != t) { heap_swap(u, t); down(t); } } void up(int u) //只需要跟一个父亲比较大小就行 { // 如果比父节点大，就交换位置，上浮 while (u / 2 && h[u] < h[u / 2]) { heap_swap(u, u / 2); u >>= 1; //x /= 2 } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i);\"]},\"418\":{\"h\":\"8. 哈希表\"},\"419\":{\"h\":\"8.1 拉链法\",\"t\":[\"int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { //哈希函数离散化 int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; }\"]},\"420\":{\"h\":\"8.2 开放寻址法\",\"t\":[\"int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { // 哈希函数 int k = (x % N + N) % N; while (h[k] != null && h[k] != x) { k++; // 如果到了末尾，那么再从头开始查找 if (k == N) k = 0; } return k; }\"]},\"421\":{\"h\":\"8.3 字符串哈希\",\"t\":[\"核心思想：将字符串看成 P 进制数，P 的经验值是 131 或 13331，取这两个值的冲突概率低 小技巧：取模的数用 2^64，这样直接用 unsigned long long 存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N]; // h[k]存储字符串前k个字母的哈希值 ULL p[N]; // p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i <= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }\"]},\"422\":{\"h\":\"9. C++ STL简介\",\"t\":[\"vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair<int, int> first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string, 字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列，本身就是有序的，默认按 key 排序 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 没找到则返回end() count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 (3) 例如：s.erase(unique(s.begin(), d.end()), s,end()) 将一个容器中重复的元素删除，对字符串也适用 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() 用 first 和 second 查找每个键值对的元素 [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 都可以是‘哈希表’ 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset<10000> s; ~, &, |, ^ >>, << ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反\"]},\"423\":{\"h\":\"10. 常用库函数\",\"t\":[\"1. reverse 翻转\",\"翻转一个 vector ：\",\"reverse(a.begin(), a.end());\",\"翻转一个数组，元素存放在下标 1 ~ n ：\",\"reverse(a + 1, a + n + 1);\",\"2. unique 去重\",\"返回去重（只去掉相邻的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。\",\"把一个 vector 去重：\",\"int m = unique(a.begin(), a.end()) – a.begin();\",\"把一个数组去重，元素存放在下标 1 ~ n：\",\"int m = unique(a + 1, a + n + 1) – (a + 1);\",\"3. random_shuffle 随机打乱： 用法与 reverse 相同。\",\"4. sort 排序：\",\"对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载 “小于号” 运算符。\",\"把一个 int 数组（元素存放在下标 1 ~ n ）从大到小排序，传入比较函数：\",\"int a[MAX_SIZE]; bool cmp(int a, int b) { return a > b; } sort(a + 1, a + n + 1, cmp);\",\"从大到小排序需要加入第三个参数：\",\"sort(a.begin(), a.end(), greater<int>());\",\"对自定义的结构体 vector 排序，重载 \\\"小于号\\\" 运算符：\",\"struct node { int id, x, y; }; vector<node> a; bool operator < (const node &a, const node &b) { return a.x < b.x || a.x == b.x && a.y < b.y; } sort(a.begin(), a.end());\",\"5. lower_bound / upper_bound 二分：\",\"lower_bound 的第三个参数传入一个元素 x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于 x 的元素的位置的迭代器（指针）。\",\"upper_bound 的用法和 lower_bound 大致相同，唯一的区别是查找第一个大于 x 的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。\",\"在有序 int 数组（元素存放在下标 1 ~ n ）中查找大于等于 x 的最小整数的下标：\",\"int i = lower_bound(a + 1, a + 1 + n, x) - a;\",\"在有序 vector<int> 中查找小于等于 x 的最大整数（假设一定存在）：\",\"int y = *--upper_bound(a.begin(), a.end(), x);\",\"找不到则返回最后一个元素的下标+1，是越界的。\"]},\"424\":{\"c\":[\"模板\",\"数据结构\"]},\"425\":{\"h\":\"贪心\"},\"426\":{\"h\":\"1. 区间问题\"},\"427\":{\"h\":\"1.1 区间选点\",\"t\":[\"给定 N个闭区间 ，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node &W) const { return r < W.r; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; //按右端点从小到大排序 sort(arr + 1, arr + 1 + n); int ans = 0; int R = -2e9; //R表示上一连续区间的最右端的点 for (int i = 1; i <= n; i++) { if (arr[i].l > R) //如果不能覆盖掉右端点，则点数+1，更新右端点 { ans++; R = arr[i].r; } } cout << ans << endl; return 0; }\"]},\"428\":{\"h\":\"1.2 最大不相交区间数量\",\"t\":[\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node & W) const { return l < W.l; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; sort(arr + 1, arr + 1 + n); int res = 1, R = arr[1].r; for (int i = 2; i <= n; i++){ if (arr[i].l <= R) R = min(R, arr[i].r); else { res++; R = arr[i].r; } } cout << res << endl; return 0; }\"]},\"429\":{\"h\":\"1.3 区间分组\",\"t\":[\"给定 N个闭区间 ，要求分成若干组，使得每组内部区间两两之间没有交集，求分成的最小组数。\",\"#include <iostream> #include <algorithm> #include <queue> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; //重载小于运算符，按左端点从小到大排序 bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); //用一个小根堆来维护所有组的右端点 priority_queue<int, vector<int>, greater<int>> heap; for (int i = 0; i < n; i++){ auto t = Range[i]; if (heap.empty() || heap.top() >= t.l) //放不进去则新开一组 heap.push(t.r); else { heap.pop(); heap.push(t.r); //放进去并更新右端点 } } cout << heap.size() << endl; return 0; }\"]},\"430\":{\"h\":\"1.4 区间覆盖\",\"t\":[\"给定 N 个闭区间，以及一个线段区间，请你选择尽量少的区间，将指定线段区间完全覆盖。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; int L, R; cin >> L >> R; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); int res = 0; bool f = false; for (int i = 0; i < n; ){ //依次遍历每个区间 int j = i, r = -2e9; //j表示第几个区间 //遍历所有左端点在L的左边的区间，选出右端点最大的 while (j < n && Range[j].l <= L){ r = max(r, Range[j].r); j++; } if (r < L){ //如果所有右端点都小于L，则无解 res = -1; break; } res++; if (r >= R){ //循环出口 f = true; break; } //更新端点和遍历的区间 L = r; i = j; } if (!f) res = -1; cout << res << endl; return 0; }\"]},\"431\":{\"h\":\"1.5 区间合并\",\"t\":[\"#include <iostream> #include <cstdio> #include <algorithm> #include <vector> #define PII pair<int, int> using namespace std; const int N = 1e5 + 5; int n; vector <PII> nums, ans; void merge(vector<PII> &nums){ //按左端点排序 sort(nums.begin(), nums.end()); //l代表区间左端点，r代表区间右端点 int l = -2e9, r = -2e9; for (auto num : nums){ //如果两区间无法合并 if (r < num.first){ if (l != -2e9) ans.push_back({l, r});//将新的区间放入ans数组中 l = num.first, r = num.second;//更新区间 } //若两区间部分存在交集，小的合并到大的中 else r = max(r, num.second); } if (l != -2e9) ans.push_back({l, r}); } int main() { cin >> n; for (int i = 0; i < n; i++){ int l, r; cin >> l >> r; nums.push_back({l, r}); } merge(nums); cout << ans.size() << endl; return 0; }\"]},\"432\":{\"c\":[\"模板\",\"贪心\"]},\"433\":{\"h\":\"初识大数据\"},\"434\":{\"h\":\"1. 大数据概述\",\"t\":[\"大数据（Big Data）：是指规模巨大、类型复杂多样，在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合，也可以理解为是涉及到数据的采集、存储、处理、分析和可视化等多个方面的复杂系统。\",\"通常包括以下四个特征（4V）：\",\"Volume（体量大）：数据的规模非常大，从 TB（太字节）到 PB（拍字节）甚至更多。\",\"Velocity（速度快）：数据的生成和处理速度非常快，需要实时或近实时的处理能力。\",\"Variety（种类多）：数据类型繁多，包括结构化数据、半结构化数据和非结构化数据（如文本、图片、视频等）。\",\"Veracity（真实性）：数据的质量和准确性，确保数据的真实性和可信度。\",\"基于大数据的发展，也衍生出了很多大数据处理技术。\",\"大数据技术：是通过获取、存储、分析，从大容量数据中挖掘价值的一种全新的技术架构。\",\"相关的处理技术包括：\",\"分布式存储：如 Hadoop 的 HDFS，用于存储大规模数据集。\",\"分布式计算：如 MapReduce、Spark 和 Flink，用于处理大规模数据集。\",\"数据挖掘和机器学习：使用算法和技术从数据中发现模式和洞察。\",\"实时处理：如 Apache Storm 和 Apache Samza，用于实时数据流的处理。\",\"目前，大数据已经成为推动技术创新和业务发展的关键因素，它的影响遍及各个行业和领域。随着技术的进步，大数据的处理和分析能力也在不断提升，为解决复杂的业务问题提供了新的解决方案。\"]},\"435\":{\"h\":\"2. 相关概念\"},\"436\":{\"h\":\"2.1 数据仓库\",\"t\":[\"数据库主要用于「事务处理」，特别强调每秒能干多少事儿：QPS（每秒查询数）、TPS（每秒事务数）、IOPS（每秒读写数）等等。\",\"而当业务发展到一定规模后，希望从大量的应用系统、业务数据中，进行关联分析，帮助业务更好地发展。但是数据库擅长事务性工作，不擅长分析性工作，于是就产生了「数据仓库」。\",\"数据仓库相当于一个集成化数据管理的平台，从多个数据源抽取有价值的数据，在仓库内转换和流动，并提供给 BI 等分析工具进行处理。\",\"因为分析型业务需要大量的 “读” 操作，所以数据仓库通过 “Denormalized” 化的方式优化表结构，减少表间联接，牺牲空间来换取读性能。并使用列式存储优化，来进一步提高查询速度、降低开销。\"]},\"437\":{\"h\":\"2.2 数据湖\",\"t\":[\"企业在持续发展过程中，数据也在不断堆积，重要的关键数据可以存储在数据库、数据仓库中。但是企业中还存在大量的与业务没有直接关联的辅助型数据，希望都能够完整保存下来，这时候就需要「数据湖」来做。\",\"数据湖，本质上是由 “数据存储架构 + 数据处理工具” 组成的解决方案，而不是某个单一产品。\",\"数据存储架构，要有足够的扩展性和可靠性，要满足企业能把所有原始数据都 “囤” 起来，存得下、存得久。\",\"数据处理工具，分为两大类：\",\"治理工具，解决的问题是如何把数据 “搬到” 湖里，包括定义数据源、制定数据访问策略和安全策略，并移动数据、编制数据目录等等。\",\"分析工具，解决的问题是如何对数据进行分析、挖掘和利用，包括对数据进行查询，应用数据解决实际问题等。\",\"数据库 VS 数据仓库\",\"数据上： \",\"数据仓库里的数据精挑细选，价值密度更高，含金量更高；\",\"数据湖将数据照单全收，更有一种 “兜底” 的感觉，一股脑全部接收。\",\"产品上： \",\"数据仓库可以是独立的标准化产品；\",\"数据湖则是一种架构，通常以对象存储为基础，结合一系列数据管理工具。\"]},\"438\":{\"h\":\"2.3 湖仓一体\",\"t\":[\"数据湖起步成本很低，但随着数据体量增大，TCO 成本会加速飙升；数仓则恰恰相反，前期建设开支很大。一个后期成本高，一个前期成本高，对于既想修湖、又想建仓的用户来说，难以抉择。\",\"所以，根据两者的特点，都是拿数据为业务服务，数据湖和数仓作为两大“数据集散地”，人们尝试着将彼此整合一下，让数据流动起来，少点重复建设。\",\"于是，为推动数仓和数据湖的打通融合，诞生了「Lake House」，即湖仓一体。\",\"Lake House 架构最重要的一点，是实现 “湖里” 和 “仓里” 的数据/元数据能够无缝打通，并且 “自由” 流动。湖里的 “新鲜” 数据可以流到仓里，甚至可以直接被数仓使用，而仓里的 “不新鲜” 数据，也可以流到湖里，低成本长久保存，供未来的数据挖掘使用。\",\"通常需要满足以下要求：\",\"可以将数据湖中最近几个月的 “热数据” 摄取到数仓中；\",\"反过来，也可以轻松将大量冷门历史数据从数仓转移至成本更低廉的数据湖内，同时这些移到湖里的数据，仍然可以被数仓查询使用;\",\"处理数仓内的热数据与数据湖中的历史数据，生成丰富的数据集，全程无需执行任何数据移动操作；\",\"生成的新数据集可以插入到数仓中的表内，或者直接插入由数据湖托管的外部表中。\",\"不仅如此，把数据湖和数据仓库集成起来只是第一步，还要把湖、仓以及所有其他数据处理服务组成统一且连续的整体，即「智能湖仓」。\",\"智能湖仓并非单一产品，它描述的是一种架构。这套架构，以数据湖为中心，把数据湖作为中央存储库，再围绕数据湖建立专用 “数据服务环”，环上的服务包括了 数仓、机器学习、大数据处理、日志分析，甚至 RDS 和 NoSQL 服务等等。\",\"大家 “环湖而饲”，既可以直接操纵湖内数据，也可以从湖中摄取数据，还可以向湖中回注数据，同时环湖的服务彼此之间也可以轻松交换数据。\",\"任何热门的数据处理服务，都在湖边建好了，任何对口的数据都能召之即来、挥之则去。依靠这种无缝集成和数据移动机制，用户就能从容地用对的工具从对的数据中，挖出干货！\",\"从数据获取到数据应用到完整流程上，AWS 官方给出了智能湖仓的参考架构：\"]},\"439\":{\"h\":\"2.4 OLTP 与 OLAP\",\"t\":[\"事务（OLTP）、分析（OLAP）\"]},\"440\":{\"h\":\"2.5 RP - 关系投影\"},\"441\":{\"h\":\"2.6 物化视图\"},\"442\":{\"c\":[\"大数据\"]},\"443\":{\"c\":[\"基础\"]},\"444\":{\"h\":\"RBAC 权限控制\"},\"445\":{\"h\":\"1. SpringSecurity 介绍\",\"t\":[\"Spring Security 是一个功能强大的 Java 安全框架，提供了全面的安全认证和授权的支持。\",\"与 RBAC 模型结合使用时，Spring Security 能够实现灵活的权限控制。\",\"它有的二大核心概念 —— 认证和授权：\",\"1）认证（Authentication）：认证就像用户登录时提交的用户名和密码，系统通过这些信息来验证 “你是谁”。\",\"Spring Security 不仅支持传统的用户名和密码认证，还支持 OAuth2、JWT 等现代认证方式。\",\"2）授权（Authorization）：授权是确认用户在通过认证之后，是否有权限执行某些操作或访问特定资源。\"]},\"446\":{\"h\":\"2. SpringSecurity 配置\",\"t\":[\"Spring Security 的配置类是实现安全控制的核心部分，用于开启 Spring Security 各种功能，以确保 Web 应用程序的安全性，包括认证、授权、会话管理、过滤器添加等。\",\"package com.dkd.framework.config; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.http.HttpMethod; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.security.web.authentication.logout.LogoutFilter; import org.springframework.web.filter.CorsFilter; import com.dkd.framework.config.properties.PermitAllUrlProperties; import com.dkd.framework.security.filter.JwtAuthenticationTokenFilter; import com.dkd.framework.security.handle.AuthenticationEntryPointImpl; import com.dkd.framework.security.handle.LogoutSuccessHandlerImpl; /** * spring security配置 * * @author ruoyi */ // 开启方法级别的权限控制 ==> @PreAuthorize @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { /** * 自定义用户认证逻辑 */ @Autowired private UserDetailsService userDetailsService; /** * 认证失败处理类 */ @Autowired private AuthenticationEntryPointImpl unauthorizedHandler; /** * 退出处理类 */ @Autowired private LogoutSuccessHandlerImpl logoutSuccessHandler; /** * token认证过滤器 */ @Autowired private JwtAuthenticationTokenFilter authenticationTokenFilter; /** * 跨域过滤器 */ @Autowired private CorsFilter corsFilter; /** * 允许匿名访问的地址 */ @Autowired private PermitAllUrlProperties permitAllUrl; /** * 解决 无法直接注入 AuthenticationManager * * @return * @throws Exception */ @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } /** * anyRequest | 匹配所有请求路径 * access | SpringEl表达式结果为true时可以访问 * anonymous | 匿名可以访问 * denyAll | 用户不能访问 * fullyAuthenticated | 用户完全认证可以访问（非remember-me下自动登录） * hasAnyAuthority | 如果有参数，参数表示权限，则其中任何一个权限可以访问 * hasAnyRole | 如果有参数，参数表示角色，则其中任何一个角色可以访问 * hasAuthority | 如果有参数，参数表示权限，则其权限可以访问 * hasIpAddress | 如果有参数，参数表示IP地址，如果用户IP和参数匹配，则可以访问 * hasRole | 如果有参数，参数表示角色，则其角色可以访问 * permitAll | 用户可以任意访问 * rememberMe | 允许通过remember-me登录的用户访问 * authenticated | 用户登录后可访问 */ @Override protected void configure(HttpSecurity httpSecurity) throws Exception { // 配置URL访问授权规则 ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry registry = httpSecurity.authorizeRequests(); // 遍历无需认证即可访问的URL列表，设置这些URL对所有用户可访问 permitAllUrl.getUrls().forEach(url -> registry.antMatchers(url).permitAll()); // 配置Web应用程序规则 httpSecurity // CSRF（跨站请求伪造）禁用，因为不使用session .csrf().disable() // 禁用HTTP响应标头 .headers().cacheControl().disable().and() // 认证失败处理类 .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and() // 基于token，所以不需要session .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() // 过滤请求 .authorizeRequests() // 对于登录login 注册register 验证码captchaImage 允许匿名访问 .antMatchers(\\\"/login\\\", \\\"/register\\\", \\\"/captchaImage\\\").permitAll() // 静态资源，可匿名访问 .antMatchers(HttpMethod.GET, \\\"/\\\", \\\"/*.html\\\", \\\"/**/*.html\\\", \\\"/**/*.css\\\", \\\"/**/*.js\\\", \\\"/profile/**\\\").permitAll() .antMatchers(\\\"/swagger-ui.html\\\", \\\"/swagger-resources/**\\\", \\\"/webjars/**\\\", \\\"/*/api-docs\\\", \\\"/druid/**\\\").permitAll() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated() .and() .headers().frameOptions().disable(); // 添加Logout filter httpSecurity.logout().logoutUrl(\\\"/logout\\\").logoutSuccessHandler(logoutSuccessHandler); // 添加JWT filter httpSecurity.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); // 添加CORS filter httpSecurity.addFilterBefore(corsFilter, JwtAuthenticationTokenFilter.class); httpSecurity.addFilterBefore(corsFilter, LogoutFilter.class); } /** * 强散列哈希加密实现 */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } /** * 身份认证接口 */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder()); } }\"]},\"447\":{\"h\":\"3. 用户登录流程\",\"t\":[\"管理员在登录页面，输入用户名和密码以及验证码后，点击登录按钮，向后端发送请求，后端通过 springSecurity 认证管理器进行登录校验。\",\"此功能涉及前端相关的代码位于 views/login.vue 组件中，负责实现用户登录界面和交互逻辑。\",\"后端处理逻辑则在 dkd-admin 模块的 SysLoginController 中，负责接收前端的请求，处理登录逻辑，并返回 token 令牌。\"]},\"448\":{\"h\":\"3.1 前端\",\"t\":[\"点击 login.vue 中的登录按钮\",\"调用 login.vue 中的 handleLogin 方法\",\"调用 store/mondles/user.js 中的 login 方法，将返回结果存入 useUserStore 对象中（用于管理用户相关的状态和操作）\",\"调用 api/login.js 中的 login 方法\",\"调用 utils/request.js 中的 service 实例基于 axios 发送 ajax 请求（.env.development文件设置了统一请求路径前缀）\"]},\"449\":{\"h\":\"3.2 后端\"},\"450\":{\"h\":\"SysLoginController\",\"t\":[\"在 ruoyi-admin 模块中 com.ruoyi.web.controller.system.SysLoginController 类的 login 方法接收前端登录请求\"]},\"451\":{\"h\":\"SysLoginService\",\"t\":[\"在 ruoyi-framework 模块中 com.ruoyi.framework.web.service.SysLoginService 类的 login 方法处理登录逻辑：\",\"验证码校验\",\"登录前置校验\",\"SS 认证管理器用户校验，调用执行 UserDetailsServiceImpl.loadUserByUsername\",\"认证通过后，创建登录用户对象 LoginUser 包括用户 ID、部门 ID、用户信息和用户权限信息\",\"登录成功，记录日志\",\"修改用户表更新登录信息\",\"生成 token\",\"具体的执行的流程如下图：\",\"用户登录流程\"]},\"452\":{\"h\":\"4. 获取用户角色和权限\",\"t\":[\"只有超级管理员有所有的权限，实现增删改查操作，其他人员只有部分权限。\"]},\"453\":{\"h\":\"4.1 前端\",\"t\":[\"在全局 permission.js 中的 router.beforeEach 方法用于在用户导航到不同路由之前进行一些预处理\",\"调用 store/mondles/user.js 中的 getInfo 方法，将返回结果存入 useUserStore 对象中（用于管理用户相关的状态和操作）\",\"调用 api/login.js 中的 getInfo 方法\"]},\"454\":{\"h\":\"4.2 后端\"},\"455\":{\"h\":\"SysLoginController\",\"t\":[\"在 ruoyi-admin 模块中 com.ruoyi.web.controller.system.SysLoginController 类的 getInfo 方法接收前端获取用户信息请求\"]},\"456\":{\"h\":\"SysPermissionService\",\"t\":[\"在 ruoyi-framework 模块中 com.ruoyi.framework.web.service.SysPermissionService 类\",\"getRolePermission 查询该用户角色集合\",\"getMenuPermission 查询该用户权限（菜单）集合\",\"具体的执行的流程如下图：\",\"用户授权流程\"]},\"457\":{\"h\":\"4.3 页面权限\",\"t\":[\"前端封装了一个指令权限，能简单快速的实现按钮级别的权限判断。\",\"使用权限字符串 v-hasPermi：@/directive/permission/hasPermi.js\",\"// 单个 <el-button v-hasPermi=\\\"['system:user:add']\\\">存在权限字符串才能看到</el-button> // 多个 <el-button v-hasPermi=\\\"['system:user:add', 'system:user:edit']\\\">包含权限字符串才能看到</el-button>\",\"使用角色字符串 v-hasRole：@/directive/permission/hasRole.js\",\"// 单个 <el-button v-hasRole=\\\"['admin']\\\">管理员才能看到</el-button> // 多个 <el-button v-hasRole=\\\"['role1', 'role2']\\\">包含角色才能看到</el-button>\"]},\"458\":{\"h\":\"5. 获取动态菜单路由\",\"t\":[\"普通用户会分配了特定的角色权限。当其登录系统时，看到的侧边栏菜单将根据他的角色权限而有所不同。而超级管理员可以查看所有菜单的。\",\"实现此功能的前端代码位于 src/permission.js 文件。在登录成功后，会在跳转到新路由之前，去查询当前用户有权访问的动态菜单的路由列表。\",\"后端处理逻辑则在 dkd-admin 模块的 SysLoginController 中，负责接收前端发来的请求，处理查询，并构建起一个完整的菜单树结构，然后返回给前端。\"]},\"459\":{\"h\":\"5.1 前端\",\"t\":[\"在全局 permission.js 中的 router.beforeEach 方法用于在用户导航到不同路由之前进行一些预处理\",\"调用 store/mondles/permission.js 中的 generateRoutes 方法，将返回结果存入 usePermissionStore 对象中\",\"调用 api/menu.js 中的 getRouters 方法\"]},\"460\":{\"h\":\"5.2 后端\"},\"461\":{\"h\":\"SysLoginController\",\"t\":[\"在 ruoyi-admin 模块中 com.ruoyi.web.controller.system.SysLoginController 类的 getRouters 方法接收前端获取路由信息请求\"]},\"462\":{\"h\":\"ISysMenuService\",\"t\":[\"在 ruoyi-system 模块中 com.ruoyi.web.system.service.ISysMenuService 类\",\"selectMenuTreeByUserId 根据用户 ID 查询菜单树信息（递归生成父子菜单）\",\"buildMenus 构建前端路由所需要的菜单路由格式 RouterVo\",\"具体的执行的流程如下图：\"]},\"463\":{\"h\":\"5.3 路由菜单加载\",\"t\":[\"用户登录成功后，通过路由 router/index.js 跳转到首页并加载 layout 布局组件\",\"在 layout/index.vue 中加载 sidbar 侧边栏\",\"在 layout/components/Sidebar/index.vue 中遍历动态路由菜单在页面显示\",\"用户点击菜单后会根据路由的 path 跳转到对应的视图组件在 <app-main /> 显示\"]},\"464\":{\"h\":\"6. 权限注解\"},\"465\":{\"h\":\"6.1 源码分析\",\"t\":[\"在若依框架中，权限的验证最核心的是使用的 Spring Security 的提供的权限注解 @PreAuthorize\",\"@PreAuthorize 是 Spring Security 框架中提供的一个安全注解，用于实现基于注解的访问控制。它允许开发者在 方法级别 上声明特定的安全约束，以确保只有满足指定条件的用户才能调用该方法\",\"当 @PreAuthorize 注解被应用于某个方法时，Spring Security 在 该方法执行前 会先对当前认证的用户进行权限检查。如果检查通过，方法调用得以继续；否则，框架会抛出相应的权限异常（如 AccessDeniedException），阻止方法执行。\",\"若依框架中的权限控制代码，如下：\",\"@PreAuthorize(\\\"@ss.hasPermi('manage:order:list')\\\") public TableDataInfo list(Order order) { startPage(); List<Order> list = orderService.selectOrderList(order); return getDataTable(list); }\",\"@PreAuthorize 是 Spring Security 框架的权限注解，在执行方法前执行\",\"@ss.hasPermi('manage:order:list')\",\"其中的 ss 是指的一个 spring 管理的 bean \",\"位于 ruoyi-framework 模块中的 com.ruoyi.framework.web.service.PermissionService\",\"hasPermi 是 PermissionService 类中的一个方法，判断是否拥有该权限\",\"manage:order:list 为方法的参数\",\"注意：在 SecurityConfig 类中添加 @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) 后 @PreAuthorize 才能生效\",\"权限控制流程：\"]},\"466\":{\"h\":\"6.2 权限方法\",\"t\":[\"@PreAuthorize 注解用于配置接口要求用户拥有某些权限才可访问，它拥有如下方法：\",\"方法\",\"参数\",\"描述\",\"hasPermi\",\"String\",\"验证用户是否具备某权限\",\"lacksPermi\",\"String\",\"验证用户是否不具备某权限，与 hasPermi逻辑相反\",\"hasAnyPermi\",\"String\",\"验证用户是否具有以下任意一个权限\",\"hasRole\",\"String\",\"判断用户是否拥有某个角色\",\"lacksRole\",\"String\",\"验证用户是否不具备某角色，与 hasRole逻辑相反\",\"hasAnyRoles\",\"String\",\"验证用户是否具有以下任意一个角色，多个逗号分隔\"]},\"467\":{\"h\":\"6.3 使用示例\",\"t\":[\"1）数据权限示例\",\"// 符合 system:user:list 权限要求 @PreAuthorize(\\\"@ss.hasPermi('system:user:list')\\\") // 不符合 system:user:list 权限要求 @PreAuthorize(\\\"@ss.lacksPermi('system:user:list')\\\") // 符合 system:user:add 或 system:user:edit 权限要求即可 @PreAuthorize(\\\"@ss.hasAnyPermi('system:user:add,system:user:edit')\\\")\",\"编程式判断是否有资源权限：\",\"if (SecurityUtils.hasPermi(\\\"sys:user:edit\\\")) { System.out.println(\\\"当前用户有编辑用户权限\\\"); }\",\"2）角色权限示例\",\"// 属于 user 角色 @PreAuthorize(\\\"@ss.hasRole('user')\\\") // 不属于 user 角色 @PreAuthorize(\\\"@ss.lacksRole('user')\\\") // 属于 user 或者 admin 之一 @PreAuthorize(\\\"@ss.hasAnyRoles('user,admin')\\\")\",\"编程式判断是否有角色权限：\",\"if (SecurityUtils.hasRole(\\\"admin\\\")) { System.out.println(\\\"当前用户有admin角色权限\\\"); }\",\"权限提示：超级管理员拥有所有权限，不受权限约束。\"]},\"468\":{\"h\":\"6.4 公开接口\",\"t\":[\"如果有些接口是不需要验证权限可以公开访问的，这个时候就需要我们给接口放行。\",\"使用注解方式，只需要在 Controller 的类或方法上加入 @Anonymous 该注解即可。\",\"// @PreAuthorize(\\\"@ss.xxxx('....')\\\") 注释或删除掉原有的权限注解 @Anonymous @GetMapping(\\\"/list\\\") public List<SysXxxx> list(SysXxxx xxxx) { return xxxxList; }\"]},\"469\":{\"h\":\"7. 数据权限\"},\"470\":{\"h\":\"7.1 数据权限介绍\",\"t\":[\"数据权限的作用：确保用户只能访问他们被授权查看的数据。保护敏感信息，防止敏感数据泄露给未授权的人员，确保信息安全。\",\"数据权限的场景：\",\"部门级权限：比如，市场部的员工应该只能访问到销售部的数据，确保他们只能触及自己部门的信息。\",\"公司级权限：子公司的经理可能需要有更广阔的视野，他们需要查看整个子公司的数据，以做出战略决策。\",\"跨部门权限：而对于公司的高级领导或特定角色，他们可能需要有更全面的数据访问权限，以便跨部门或跨公司地进行管理和决策。\",\"通过数据权限控制，不仅能够保护数据安全，还可以确保了数据的合理利用和流程的顺畅。\",\"在 ruoyi 系统中，权限的分配和控制主要依赖于角色。每个角色可以被赋予不同的菜单权限和数据权限，用户则通过他们的角色来继承这些权限，进而决定他们能访问哪些系统资源。\",\"目前，系统支持以下五种数据权限类型：\",\"全部数据权限：无限制访问所有数据，相当于拥有最高权限的通行证。\",\"自定数据权限：用户可以根据自己的需求设定访问特定数据的规则。\",\"部门数据权限：只能访问自己所在部门的数据，限制在本部门范围内。\",\"部门及以下数据权限：可以访问自己部门及下属部门的数据，适用于管理层级。\",\"仅本人数据权限：只能访问和操作自己的数据，保障个人隐私和数据隔离。\"]},\"471\":{\"h\":\"7.2 源码实现\",\"t\":[\"1、ruoyi 系统的数据权限设计主要通过用户、角色、部门表建立关系，实现对数据的访问控制：\",\"2、在需要数据权限控制方法上添加 @DataScope 注解，其中 d 和 u 用来表示表的别名。\",\"部门数据权限注解：\",\"@DataScope(deptAlias = \\\"d\\\") public List<...> select(...) { return mapper.select(...); }\",\"部门及用户权限注解：\",\"@DataScope(deptAlias = \\\"d\\\", userAlias = \\\"u\\\") public List<...> select(...) { return mapper.select(...); }\",\"参数\",\"类型\",\"默认值\",\"描述\",\"deptAlias\",\"String\",\"空\",\"部门表的别名\",\"userAlias\",\"String\",\"空\",\"用户表的别名\",\"3、在 mybatis 查询底部标签添加数据范围过滤\",\"<select id=\\\"select\\\" parameterType=\\\"...\\\" resultMap=\\\"...Result\\\"> <include refid=\\\"select...Vo\\\"/> <!-- 数据范围过滤 --> ${params.dataScope} </select>\",\"其作用就是相当于在一个 select 语句后面拼接一个 and 条件语句，来实现查询限制，例如下面：\",\"-- 用户管理（未过滤数据权限的情况）： select u.user_id, u.dept_id, u.user_name, u.email , u.phonenumber, u.password, u.sex, u.avatar , u.status, u.del_flag, u.login_ip, u.login_date, u.create_by , u.create_time, u.remark, d.dept_name from sys_user u left join sys_dept d on u.dept_id = d.dept_id where u.del_flag = '0';\",\"-- 用户管理（已过滤数据权限的情况）： select u.user_id, u.dept_id, u.user_name, u.email , u.phonenumber, u.password, u.sex, u.avatar , u.status, u.del_flag, u.login_ip, u.login_date, u.create_by , u.create_time, u.remark, d.dept_name from sys_user u left join sys_dept d on u.dept_id = d.dept_id where u.del_flag = '0' and u.dept_id in ( select dept_id from sys_role_dept where role_id = 2 );\",\"结果很明显，通过添加如下语句。通过角色部门表 sys_role_dept 完成了自定义类型的数据权限过滤。\",\"and u.dept_id in ( select dept_id from sys_role_dept where role_id = 2 )\",\"4、若依数据权限底层使用了 自定义注解 + AOP切面 + SQL拼接\",\"com.dkd.common.annotation.DataScope 自定义注解\",\"com.ruoyi.framework.aspectj.DataScopeAspect：切面类 \",\"通过实现 AOP 编程，对目标方法进行拦截（标注 DataScope 注解的方法），实现了构建数据范围 SQL 过滤条件\",\"提示\",\"仅实体继承 BaseEntity 才会进行处理，SQL 语句会存放到 BaseEntity 对象中的 params 属性中，然后在 xml 文件中通过 ${params.dataScope} 获取拼接后的语句。\"]},\"472\":{\"c\":[\"常用框架\"]},\"473\":{\"c\":[\"RuoYi\"]},\"474\":{\"h\":\"定时任务\"},\"475\":{\"h\":\"1. 源码分析\",\"t\":[\"在实际项目开发中 Web 应用有一类不可缺少的，那就是定时任务。 定时任务的场景可以说非常广泛，比如某些视频网站，购买会员后，每天会给会员送成长值，每月会给会员送一些电影券； 比如在保证最终一致性的场景中，往往利用定时任务调度进行一些比对工作；比如一些定时需要生成的报表、邮件；比如一些需要定时清理数据的任务等。 所以我们提供方便友好的 web 界面，实现动态管理任务，可以达到动态控制定时任务启动、暂停、重启、删除、添加、修改等操作，极大地方便了开发过程。\"]},\"476\":{\"h\":\"1.1 表结构说明\",\"t\":[\"sys_job 表：这是核心的定时任务表，用于存储定时任务的配置信息，如任务名称、任务组、执行的类全名、执行的参数、cron 表达式等\",\"sys_job_log 表：用于记录定时任务的执行日志，包括任务的开始执行时间、结束执行时间、执行结果等\"]},\"477\":{\"h\":\"1.2 目录结构\",\"t\":[\"1）后端代码\",\"image-20240817143806315\",\"ScheduleUtils 定时任务工具类\",\"抽象 quartz 调用类 AbstractQuartzJob（实现Job接口）\",\"定时任务处理类（禁止并发执行） 继承抽象类\",\"定时任务处理类（允许并发执行） 继承抽象类\",\"任务执行工具类 JobInvokeUtil\",\"cron 表达式工具类\",\"2）前端代码\"]},\"478\":{\"h\":\"1.3 Quartz 体系结构\"},\"479\":{\"h\":\"1.4 Quartz 核心 API\",\"t\":[\"API\",\"描述\",\"Job\",\"- 实际要执行的任务类- 必须实现Quartz的Job接口。\",\"JobDetail\",\"- 代表一个Job实例- 通过JobBuilder类创建。\",\"JobBuilder\",\"- 用于声明一个任务实例- 可以定义关于该任务的详情，如任务名、组名等。\",\"Trigger\",\"- 触发器，用来触发并执行Job实例的机制。\",\"SimpleTrigger\",\"- 用于简单重复执行作业的触发器- 例如：每隔一定时间执行一次。\",\"CronTrigger\",\"- 使用Cron表达式定义执行计划的触发器- 适用于定义复杂的执行时间。\",\"TriggerBuilder\",\"- 用于创建触发器Trigger实例的构建器。\",\"Scheduler\",\"- Quartz中的核心组件- 负责启动、停止、暂停和恢复任务。\"]},\"480\":{\"h\":\"1.5 定时任务执行\",\"t\":[\"项目在启动时，初始化定时任务\",\"流程图：\"]},\"481\":{\"h\":\"1.6 添加定时任务\",\"t\":[\"在项目启动时，从数据库中查询任务配置列表，然后创建定时任务，并根据状态判断是否执行任务调度，那如果是新添加的定时任务该如何处理呢？为了解答这个问题，我们来对这部分的源码进行分析。\",\"重点关注后端部分，入口在定时任务模块的 sysJobController 中：\",\"/** * 修改定时任务 */ @PreAuthorize(\\\"@ss.hasPermi('monitor:job:edit')\\\") @Log(title = \\\"定时任务\\\", businessType = BusinessType.UPDATE) @PutMapping public AjaxResult edit(@RequestBody SysJob job) throws SchedulerException, TaskException { if (!CronUtils.isValid(job.getCronExpression())) { return error(\\\"修改任务'\\\" + job.getJobName() + \\\"'失败，Cron表达式不正确\\\"); } else if (StringUtils.containsIgnoreCase(job.getInvokeTarget(), Constants.LOOKUP_RMI)) { return error(\\\"修改任务'\\\" + job.getJobName() + \\\"'失败，目标字符串不允许'rmi'调用\\\"); } else if (StringUtils.containsAnyIgnoreCase(job.getInvokeTarget(), new String[] { Constants.LOOKUP_LDAP, Constants.LOOKUP_LDAPS })) { return error(\\\"修改任务'\\\" + job.getJobName() + \\\"'失败，目标字符串不允许'ldap(s)'调用\\\"); } else if (StringUtils.containsAnyIgnoreCase(job.getInvokeTarget(), new String[] { Constants.HTTP, Constants.HTTPS })) { return error(\\\"修改任务'\\\" + job.getJobName() + \\\"'失败，目标字符串不允许'http(s)'调用\\\"); } else if (StringUtils.containsAnyIgnoreCase(job.getInvokeTarget(), Constants.JOB_ERROR_STR)) { return error(\\\"修改任务'\\\" + job.getJobName() + \\\"'失败，目标字符串存在违规\\\"); } else if (!ScheduleUtils.whiteList(job.getInvokeTarget())) { return error(\\\"修改任务'\\\" + job.getJobName() + \\\"'失败，目标字符串不在白名单内\\\"); } job.setUpdateBy(getUsername()); return toAjax(jobService.updateJob(job)); }\",\"代码流程图：\"]},\"482\":{\"h\":\"1.7 定时任务状态修改\",\"t\":[\"通过分析新增定时任务的源码，可以发现，任务在初始化时是处于暂停状态的。\",\"如果要启动任务，可以在页面进行任务状态的开关控制，所以接下来对此功能的源码进行分析。\",\"入口在定时任务模块的 sysJobController 中：\",\"/** * 定时任务状态修改 */ @PreAuthorize(\\\"@ss.hasPermi('monitor:job:changeStatus')\\\") @Log(title = \\\"定时任务\\\", businessType = BusinessType.UPDATE) @PutMapping(\\\"/changeStatus\\\") public AjaxResult changeStatus(@RequestBody SysJob job) throws SchedulerException { // 根据任务ID查询数据库，获取当前任务的配置信息 SysJob newJob = jobService.selectJobById(job.getJobId()); // 将前端的状态设置到任务配置对象中 newJob.setStatus(job.getStatus()); // 调用服务层的方法根据状态启动/暂停任务，并返回操作结果 return toAjax(jobService.changeStatus(newJob)); }\",\"代码流程图：\"]},\"483\":{\"h\":\"2. 集群模式\"},\"484\":{\"h\":\"2.1 集群介绍\",\"t\":[\"为什么需要 Quartz 集群？\",\"在单机模式下，默认所有的 jobDetail 和 trigger 都存储在内存中。这样做的好处是读取速度快，但缺点也很明显：一旦服务器故障，所有的任务数据就会丢失，这就是所谓的单点故障问题。\",\"还有如果在一个高峰时段，比如上午 9 点，需要触发 500 个任务，这将给服务器带来巨大的负载压力。这不仅影响性能，还可能引发服务中断。\",\"缺点：单点故障、负载压力大\",\"为了解决这些问题，我们可以部署多个服务器节点，将任务信息存储到数据库中。这样，多个节点就可以通过共享数据库来协调任务的执行，形成 Quartz 集群模式。\",\"这种方式不仅解决了单点故障问题，还能通过负载均衡提升效率。\",\"集群模式的优势：\",\"高可用性：即使某个节点出现问题，其他节点仍然可以正常运行。\",\"负载均衡：将任务分散到不同的节点执行，避免单个节点过载。\",\"通常在生产环境中，我们会部署多台服务器，所以采用集群模式不会产生额外的成本。\",\"quartz集群所需数据库表：\",\"表名\",\"用途\",\"qrtz_triggers\",\"存储触发器的基本信息，如触发器名称、组、类型等。\",\"qrtz_cron_triggers\",\"存储Cron触发器的额外信息，如Cron表达式。\",\"qrtz_simple_triggers\",\"存储简单触发器的额外信息，如重复次数和间隔。\",\"qrtz_blob_triggers\",\"存储BLOB类型触发器的额外信息，如持久化的数据。\",\"qrtz_simprop_triggers\",\"存储具有单一触发器属性的触发器的详细信息。\",\"qrtz_job_details\",\"存储作业详细信息，如作业名称、组、描述、作业类名等。\",\"qrtz_scheduler_state\",\"存储调度器的状态信息，如当前主节点信息等。\",\"qrtz_locks\",\"存储锁信息，用于控制并发和防止资源冲突。\",\"qrtz_paused_trigger_grps\",\"存储被暂停的触发器组的信息。\",\"qrtz_fired_triggers\",\"存储已触发的触发器的详细信息，包括执行历史。\",\"qrtz_calendars\",\"存储日历信息，定义工作日和非工作日，用于调度时间约束。\"]},\"485\":{\"h\":\"2.2 实现\"},\"486\":{\"h\":\"2.2.1 导入sql\",\"t\":[\"将 ruoyi 提供的 quartz.sql 导入到数据库中：\"]},\"487\":{\"h\":\"2.2.2 开启配置\",\"t\":[\"打开 dkd-quartz 模块中 ScheduleConfig 配置类注释：\"]},\"488\":{\"h\":\"2.2.3 节点复制\",\"t\":[\"首先修改当前 SpringBoot 的启动类的名称\",\"再添加（复制）一个 SpringBoot 的启动配置\",\"-Dserver.port=8081\"]},\"489\":{\"h\":\"2.2.4 观察数据库\",\"t\":[\"重启项目即可，观察数据库，已存入 jobDetail 和 trigger，多个服务器节点可以实现共享。\"]},\"490\":{\"c\":[\"常用框架\"]},\"491\":{\"c\":[\"RuoYi\"]},\"492\":{\"h\":\"第一期 - 项目介绍\",\"t\":[\"面试吧笔记第一期 - 项目介绍\"]},\"493\":{\"h\":\"1. 项目介绍\",\"t\":[\"面试吧是一款基于 Next.js 服务端渲染 + Spring Boot + Redis + MySQL + ElasticSearch 的面试刷题平台，运用 Druid + HotKey + Sa-Token + Sentinel 提高了系统的性能和安全性。\",\"管理员可以创建题库、题目和题解，并批量关联题目到题库；用户可以注册登录、分词检索题目、在线刷题并查看刷题记录日历等。\",\"项目中涉及到大量企业项目开发新技术，比如使用数据库连接池、热 Key 探测、缓存、高级数据结构来提升性能；通过流量控制、熔断、动态 IP 黑白名单过滤、同端登录冲突检测、分级反爬虫策略来提升系统和内容的安全性。\"]},\"494\":{\"h\":\"2. 核心业务流程\",\"t\":[\"如下图所示：\"]},\"495\":{\"h\":\"3. 项目功能\"},\"496\":{\"h\":\"3.1 基础功能\",\"t\":[\"用户模块\",\"用户注册\",\"用户登录（账号密码）\",\"【管理员】管理用户 - 增删改查\",\"题库模块\",\"查看题库列表\",\"查看题库详情（展示题库下的题目）\",\"【管理员】管理题库-增删改查\",\"题目模块\",\"题目搜索\",\"查看题目详情（进入刷题页面）\",\"【管理员】管理题目 - 增删改查（按照题库查询题目、修改题目所属题库等）\"]},\"497\":{\"h\":\"3.2 高级功能\",\"t\":[\"题目批量管理\",\"【管理员】批量向题库添加题目\",\"【管理员】批量从题库移除题目\",\"【管理员】批量删除题目\",\"分词题目搜索\",\"用户刷题记录日历图\",\"自动缓存热门题目\",\"网站流量控制和熔断\",\"动态 IP 黑白名单过滤\",\"同端登录冲突检测\",\"分级题目反爬虫策略\"]},\"498\":{\"h\":\"4. 技术选型\"},\"499\":{\"h\":\"4.1 前端\",\"t\":[\"React 18 框架\",\"Next.js 服务端渲染\",\"Redux 状态管理\",\"Ant Design 组件库\",\"富文本编辑器组件\",\"前端工程化：ESLint + Prettier + TypeScript\",\"OpenAPI 前端代码生成\"]},\"500\":{\"h\":\"4.2 后端\",\"t\":[\"Java Spring Boot 框架 + Maven 多模块构建\",\"MySQL 数据库 + MyBatis-Plus 框架 + MyBatis X\",\"Redis 分布式缓存 + Caffeine 本地缓存\",\"Redission 分布式锁 + BitMap + BloomFilter\",\"Elasticsearch 搜索引擎\",\"Druid 数据库连接池 + 并发编程\",\"Sa-Token 权限控制\",\"HotKey 热点探测\",\"Sentinel 流量控制\",\"Nacos 配置中心\",\"多角度项目优化：性能、安全性、可用性\"]},\"501\":{\"h\":\"6. 架构设计\"},\"502\":{\"h\":\"7. 环境准备\",\"t\":[\"后端 JDK 版本需要使用 8、11 或 17，不能超过 17！\",\"推荐使用 11 版本，因为 Caffeine 缓存要求使用 11 版本。\",\"前端 Node.js 版本 ≥ 18.18。\"]},\"503\":{\"c\":[\"项目\"]},\"504\":{\"c\":[\"面试吧\"]},\"505\":{\"h\":\"第二期 - 后端开发\",\"t\":[\"面试吧笔记第二期 - 后端开发\",\"开发面试吧后端基础功能。\"]},\"506\":{\"h\":\"1. 需求分析\",\"t\":[\"目标：明确要做的需求，并且给需求设置优先级，从而明确开发计划。\",\"根据核心业务业务流程，明确需求开发的优先级：\",\"P0 为核心，非做不可\",\"P1 为重点功能，最好做\",\"P2 为实用功能，有空就做\",\"P3 可做可不做，时间充裕再做\",\"确定优先级的需求列表如下。\"]},\"507\":{\"h\":\"1.1 基础功能（均为 P0）\",\"t\":[\"用户模块\",\"用户注册\",\"用户登录（账号密码）\",\"【管理员】管理用户-增删改查\",\"题库模块\",\"查看题库列表\",\"查看题库详情（展示题库下的题目）\",\"【管理员】管理题库-增删改查\",\"题目模块\",\"题目搜索\",\"查看题目详情（进入刷题页面）\",\"【管理员】管理题目-增删改查（按照题库查询题目、修改题目所属题库等）\"]},\"508\":{\"h\":\"1.2 高级功能（均为 P1 ~ P2）\",\"t\":[\"题目批量管理 P1\",\"【管理员】批量向题库添加题目\",\"【管理员】批量从题库移除题目\",\"【管理员】批量删除题目\",\"分词题目搜索 P1\",\"用户刷题记录日历图 P1\",\"自动缓存热门题目 P2\",\"网站流量控制和熔断 P2\",\"动态 IP 黑白名单过滤 P2\",\"同端登录冲突检测 P2\",\"分级题目反爬虫策略 P2\"]},\"509\":{\"h\":\"2. 库表设计\"},\"510\":{\"h\":\"2.1用户表\",\"t\":[\"用户表的核心是用户登录凭证（账号密码）和个人信息，SQL 如下:\",\"-- 用户表 create table if not exists user ( id bigint auto_increment comment 'id' primary key, userAccount varchar(256) not null comment '账号', userPassword varchar(512) not null comment '密码', unionId varchar(256) null comment '微信开放平台id', mpOpenId varchar(256) null comment '公众号openId', userName varchar(256) null comment '用户昵称', userAvatar varchar(1024) null comment '用户头像', userProfile varchar(512) null comment '用户简介', userRole varchar(256) default 'user' not null comment '用户角色：user/admin/ban', editTime datetime default CURRENT_TIMESTAMP not null comment '编辑时间', createTime datetime default CURRENT_TIMESTAMP not null comment '创建时间', updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间', isDelete tinyint default 0 not null comment '是否删除', index idx_unionId (unionId) ) comment '用户' collate = utf8mb4_unicode_ci;\",\"其中，unionld、mpopenld 是为了实现公众号登录的，也可以省略。每个微信用户在同一家公司(主体)的 unionld 是唯一的，在同一个公众号的 mpOpenld 是唯一的。editTime 和 updateTime 的区别是：editTime 表示用户编辑个人信息的时间(需要业务代码来更新)，而 updateTime 表示这条用户记录任何字段发生修改的时间(由数据库自动更新)。\"]},\"511\":{\"h\":\"2.2 题库表\",\"t\":[\"题库表的核心是题库信息（标题、描述、图片），SQL 如下:\",\"-- 题库表 create table if not exists question_bank ( id bigint auto_increment comment 'id' primary key, title varchar(256) null comment '标题', description text null comment '描述', picture varchar(2048) null comment '图片', userId bigint not null comment '创建用户 id', editTime datetime default CURRENT_TIMESTAMP not null comment '编辑时间', createTime datetime default CURRENT_TIMESTAMP not null comment '创建时间', updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间', isDelete tinyint default 0 not null comment '是否删除', index idx_title (title) ) comment '题库' collate = utf8mb4_unicode_ci;\",\"其中，picture 存储的是图片的 url 地址，而不是完整图片文件。通过 userld 和用户表关联，在本项目中只有管理员才能创建题库。 由于用户很可能按照标题搜索题库，所以给 title 字段增加索引。\"]},\"512\":{\"h\":\"2.3 题目表\",\"t\":[\"题目表的核心是题目信息（标题、详细内容、标签），SQL 如下:\",\"-- 题目表 create table if not exists question ( id bigint auto_increment comment 'id' primary key, title varchar(256) null comment '标题', content text null comment '内容', tags varchar(1024) null comment '标签列表（json 数组）', answer text null comment '推荐答案', userId bigint not null comment '创建用户 id', editTime datetime default CURRENT_TIMESTAMP not null comment '编辑时间', createTime datetime default CURRENT_TIMESTAMP not null comment '创建时间', updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间', isDelete tinyint default 0 not null comment '是否删除', index idx_title (title), index idx_userId (userId) ) comment '题目' collate = utf8mb4_unicode_ci;\",\"几个重点:\",\"题目标题 title 和题目创建人 userld 是常用的题目搜索条件，所以添加索引提升查询性能。\",\"题目可能有多个标签，为了简化设计，没有采用关联表，而是以 JSON 数组字符串的方式存储，比如 [\\\"Java\\\"，\\\"Python\\\"]。\",\"题目内容（详情）和题目答案可能很长，所以使用 text 类型。\"]},\"513\":{\"h\":\"2.4 题库题目关联表\",\"t\":[\"由于一个题库可以有多个题目，一个题目可以属于多个题库，所以需要关联表来实现。\",\"实现基础功能的 SQL 如下:\",\"-- 题库题目表（硬删除） create table if not exists question_bank_question ( id bigint auto_increment comment 'id' primary key, questionBankId bigint not null comment '题库 id', questionId bigint not null comment '题目 id', userId bigint not null comment '创建用户 id', createTime datetime default CURRENT_TIMESTAMP not null comment '创建时间', updateTime datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间', UNIQUE (questionBankId, questionId) ) comment '题库题目' collate = utf8mb4_unicode_ci;\",\"几个重点：\",\"上述代码中的 userld 表示添加题目到题库的用户 id，仅管理员可操作。\",\"由于关联表中的数据记录并没有那么重要（一般由管理员维护），所以直接采用硬删除的方式，如果将题目移出题库，直接删掉对应的数据即可。按照这种设计，createTime 就是题目加入到题库的时间。\",\"通过给题库 id 和题目id 添加联合唯一索引，防止题目被重复添加到同一个题库中。而且要注意，将 questionBankd 放到前面，因为数据库中的查询大多是基于 questiongankId 进行的，比如査找某个题库中的所有问题，或者在一个题库中查找特定问题，将 questionBankId 放在前面符合查询模式，会使得这些查询更加高效（索引的最左前缀原则）。\"]},\"514\":{\"h\":\"3. 后端基础开发\",\"t\":[\"使用 后端万用模板 对后端项目初始化，接着全局替换模块名和包名，移除不必要的模块，执行数据库初始化文件，最后修改配置文件启动项目即可。\"]},\"515\":{\"h\":\"3.1 数据实体层\",\"t\":[\"使用 MyatisX 代码生成插件快速得到 mapper 和数据库实体类，生成后移动到项目对应位置（ mapper 和 model.entity 包），如下图所示：\",\"接着修改生成的数据库实体类的字段配置，指定主键策略为 ASSIGN_ID 雪花算法生成 和 添加逻辑删除注解。\",\"比如题目表的示例代码：\",\"/** * 题目 * * @author BraumAce * @TableName question */ @TableName(value =\\\"question\\\") @Data public class Question implements Serializable { /** * id，指定雪花算法生成 */ @TableId(type = IdType.ASSIGN_ID) private Long id; // ... /** * 是否删除（逻辑删除） */ @TableLogic private Integer isDelete; }\"]},\"516\":{\"h\":\"3.2 业务逻辑层\",\"t\":[\"使用万用模版的代码生成器工具（CodeGenerator）生成代码，包括：Controller、Service 接口和实现类、数据模型包装类。如下所示：\",\"只需要修改生成参数即可。\",\"运行后生成的代码在根目录的 generator 包下，我们根据需要移动到对应的位置，包括 controller、service、model.dto、model.vo，然后再根据实际开发修改部分代码即可使用。\"]},\"517\":{\"h\":\"3.3 数据模型层\",\"t\":[\"需要编写数据模型包装类（dto 包的请求类和 vo 包的视图类）、JSON 结构对应的类、枚举类。\",\"其中，包装类需要根据前端实际传递的请求参数或需要的响应结果自行修改。\",\"以创建题目请求包装类 QuestionAddRequest 为例，需要保留前端需要的字段，并且将 JSON 字符串字段转换为前端更好理解的数据类型（比如 tags 由 String 转为 List），还有一些由后端自动生成的字段（比如 userld、createTime）就不用写到类里了。代码如下：\",\"package com.yuan.mianshiba.model.dto.question; import lombok.Data; import java.io.Serializable; import java.util.List; /** * 创建题目请求 * * @author BraumAce */ @Data public class QuestionAddRequest implements Serializable { /** * 标题 */ private String title; /** * 内容 */ private String content; /** * 标签列表 */ private List<String> tags; /** * 推荐答案 */ private String answer; private static final long serialVersionUID = 1L; }\",\"其他请求包装类同理。\",\"需要结合具体的业务、实体类、创建表的 DDL 语句去编写请求包装类。\"]},\"518\":{\"h\":\"3.4 接口开发\",\"t\":[\"修改生成的 Controller 接口，不需要包含业务逻辑，处理字段不一致的问题、并且将无用的接口移除。\",\"目前能跑通即可。\"]},\"519\":{\"h\":\"3.5 服务开发\",\"t\":[\"修改生成的 Service 接口和实现类，处理字段不一致的问题，略微调整数据校验、查询条件等代码。\",\"目前能跑通即可。\"]},\"520\":{\"h\":\"3.6 Swagger 接口文档测试\",\"t\":[\"运行项目，通过访问 Swagger 接口文档来测试增删改查接口能否正常执行。\",\"地址：http://localhost:8101/api/doc.html#/home\"]},\"521\":{\"h\":\"4. 后端核心业务开发\",\"t\":[\"通过万用模板已完成用户模块的开发，包括用户注册、用户登录、管理用户 - 增删改查。\",\"剩下题库和题目两个模块：\",\"题库模块\",\"查看题库列表：分页获取题库接口（已生成）\",\"查看题库详情（展示题库下的题目）：根据 id 获取题库详情接口（需开发）⭐\",\"【管理员】管理题库 - 增删改查（已生成）\",\"题目模块\",\"题目搜索：分页获取题目接口（已生成）\",\"查看题目详情（进入刷题页面）：根据 id 获取题目详情接口（已生成）\",\"【管理员】管理题目 - 增删改查（已生成）\",\"【管理员】按照题库查询题目：根据题库 id 获取题目列表接口（需开发）⭐\",\"【管理员】修改题目所属题库：修改题目所属题库接口（需开发）⭐\"]},\"522\":{\"h\":\"4.1 题库模块\"},\"523\":{\"h\":\"4.1.1 获取题库详情\",\"t\":[\"需求：根据题库 id 获取题库详情，同时可能需要查询到题库内的题目列表。\",\"分析：考虑到需要适配多种不同的情况，额外用一个字段判断是否要关联查询题目列表。\",\"前端根据不同的场景，给字段传入不同的值。这样的话，对于有些不需要关联查询题目列表的页面，就能够减少性能损耗。\",\"查询时，先从题库表里查询出题库信息，再复用 题目模块中获取题目列表 的服务层接口，获取到题目列表，再封装返回值即可。\",\"具体实现：\",\"给 QuestionBankQueryRequest 增加字段 needQueryQuestionList，用于控制是否要关联查询题目列表。默认为 false，表示不查询。\",\"public class QuestionBankQueryRequest extends PageRequest implements Serializable { // 省略其他字段... /** * 是否要关联查询题目列表 */ private boolean needQueryQuestionList; private static final long serialVersionUID = 1L; }\",\"修改题库响应封装类，补充题目列表分页（也可以是列表，根据实际需求调整）。\",\"public class QuestionBankVO implements Serializable { // 省略其他字段... /** * 题库里的题目列表（分页） */ Page<Question> questionPage; }\",\"在 QuestionBankController 中修改 “根据 id 获取题库” 封装类的接口，代码如下：\",\"/** * 根据 id 获取题库（封装类） * * @param questionBankQueryRequest * @param request * @return */ @GetMapping(\\\"/get/vo\\\") public BaseResponse<QuestionBankVO> getQuestionBankVOById(QuestionBankQueryRequest questionBankQueryRequest, HttpServletRequest request) { ThrowUtils.throwIf(questionBankQueryRequest == null, ErrorCode.PARAMS_ERROR); Long id = questionBankQueryRequest.getId(); ThrowUtils.throwIf(id <= 0, ErrorCode.PARAMS_ERROR); // 查询数据库 QuestionBank questionBank = questionBankService.getById(id); ThrowUtils.throwIf(questionBank == null, ErrorCode.NOT_FOUND_ERROR); // 查询题库封装类 QuestionBankVO questionBankVO = questionBankService.getQuestionBankVO(questionBank, request); // 是否要关联查询题库下的题目列表 boolean needQueryQuestionList = questionBankQueryRequest.isNeedQueryQuestionList(); if (needQueryQuestionList) { QuestionQueryRequest questionQueryRequest = new QuestionQueryRequest(); questionQueryRequest.setQuestionBankId(id); Page<Question> questionPage = questionService.listQuestionByPage(questionQueryRequest); questionBankVO.setQuestionPage(questionPage); } // 获取封装类 return ResultUtils.success(questionBankVO); }\"]},\"524\":{\"h\":\"4.2 题目模块\"},\"525\":{\"h\":\"4.2.1 获取题目列表\",\"t\":[\"需求：根据题库 id 获取该题库所包含的题目列表（仅管理员可用）。\",\"分析：由于同一个题库内的题目不会很多，为了简化实现，可以直接获取全部题目。\",\"注意，该功能要抽象成 service 方法，便于后续的获取题目列表接口复用。\",\"由于题目和题库是通过关联表维护关系的，所以在查询时，要先通过查询关联表得到题目 id，再根据 id 从题目表查询到题目的完整信息。\",\"有 2 种实现方式：\",\"通过 SQL 的 join 联表查询：\",\"SELECT q.id, q.title, q.content, q.tags, q.answer, q.userId, q.createTime, q.updateTime FROM question_bank_question qbq JOIN question q ON qbq.questionId = q.id WHERE qbq.questionBankId = ?; -- 在这里替换 ? 为具体的题库 id\",\"业务层分步查询\",\"先通过查询关联表得到题目 id，再把 id 放到集合中，根据 id 使用 in 查询从题目表查询到题目的完整信息。\",\"此处选择第二种方式，因为关联逻辑并不复杂、数据量也不大，业务层实现更灵活，也便于组合其他条件去过滤题目列表。\",\"注意\",\"如果要对题目题库关联表和题目表同时进行过滤和分页查询，那么考虑使用 SQL 的 join 实现。\",\"因为业务层处理多表分页比较麻烦。\",\"具体实现：\",\"在题目查询请求类 QuestionQueryRequest 中补充 “题库 id” 请求参数 —— questionBankId。\",\"public class QuestionQueryRequest extends PageRequest implements Serializable { // 省略其他字段... /** * 题库 id */ private Long questionBankId; }\",\"该接口本质上还是查询题目列表，可以把题库 id 当做一个过滤题目的查询条件，所以可以在 QuestionService 中编写一个通用的分页获取题目列表的方法。\",\"public Page<Question> listQuestionByPage(QuestionQueryRequest questionQueryRequest) { long current = questionQueryRequest.getCurrent(); long size = questionQueryRequest.getPageSize(); // 题目表查询条件 QueryWrapper<Question> queryWrapper = this.getQueryWrapper(questionQueryRequest); // 根据题库查询题目id列表 Long questionBankId = questionQueryRequest.getQuestionBankId(); if (questionBankId != null) { // 查询题库内的题目列表 LambdaQueryWrapper<QuestionBankQuestion> lambdaQueryWrapper = Wrappers.lambdaQuery(QuestionBankQuestion.class) .select(QuestionBankQuestion::getQuestionId) .eq(QuestionBankQuestion::getQuestionBankId, questionBankId); List<QuestionBankQuestion> questionList = questionBankQuestionService.list(lambdaQueryWrapper); if (CollUtil.isNotEmpty(questionList)){ // 取出题目id集合 Set<Long> questionIdSet = questionList.stream() .map(QuestionBankQuestion::getQuestionId) .collect(Collectors.toSet()); queryWrapper.in(\\\"id\\\", questionIdSet); } } // 查询数据库 Page<Question> questionPage = this.page(new Page<>(current, size), queryWrapper); return questionPage; }\",\"在 QuestionController 种调用接口。\",\"/** * 分页获取题目列表（仅管理员可用） * * @param questionQueryRequest * @return */ @PostMapping(\\\"/list/page\\\") @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse<Page<Question>> listQuestionByPage(@RequestBody QuestionQueryRequest questionQueryRequest) { ThrowUtils.throwIf(questionQueryRequest == null, ErrorCode.PARAMS_ERROR); // 查询数据库 Page<Question> questionPage = questionService.listQuestionByPage(questionQueryRequest); return ResultUtils.success(questionPage); }\",\"提示\",\"查询关联表的时候，不要 select 所有字段，只取 questionId 就够了，可以提升性能。\",\"注意判断通过关联表查询到的题目列表，如果为空，不用再作为查询条件。\",\"从关联表查到的虽然只有一个字段，但返回的还是对象，所以需要使用 Lambda 表达式转换成题目 id 集合。\",\"把题库 id 通过关联表转换为了多个题目 id，巧妙地复用了原有的题目过滤条件（QueryWrapper），可以同时支持按照题库 id 和标题等其他条件来搜索题目。\"]},\"526\":{\"h\":\"4.2.2 修改题目所属题库\",\"t\":[\"需求：根据题库 id 和题目 id，修改题目所属题库。\",\"分析：修改的本质包括添加和删除。\",\"添加：题目未加入该题库，管理员可以添加题目到题库，在题库题目关联表中添加一条记录。\",\"删除：题目已加入该题库，管理员可以从题库中移除题目，将题目题目关联表中已有的记录删除。\",\"所以需要开发 2 个接口：创建题库题目关联，移除题库题目关联。\",\"由于在题库题目关联表中已经添加了 题库id、题目id 的唯一性约束，不用担心重复添加脏数据，做好异常处理即可。\",\"注意\",\"如果没有唯一性约束，要进行 加锁 操作。如果是分布式环境，要用 分布式锁。\",\"而使用唯一性约束的方式，可以大大减少开发时的工作量。\",\"1. 创建题库题目关联：\",\"已有的创建题库题目关联请求类\",\"/** * 创建题库题目关联请求 * * @author BraumAce */ @Data public class QuestionBankQuestionAddRequest implements Serializable { /** * 题库 id */ private Long questionBankId; /** * 题目 id */ private Long questionId; private static final long serialVersionUID = 1L; }\",\"已生成的创建题库题目关联接口，只需要补充数据不存在的校验，修改 QuestionBankQuestionServiceImpl 的 validQuestionBankQuestion 方法即可。\",\"/** * 创建题库题目关联（仅管理员可用） * * @param questionBankQuestionAddRequest * @param request * @return */ @PostMapping(\\\"/add\\\") @AuthCheck(mustRole = UserConstant.ADMIN_ROLE) public BaseResponse<Long> addQuestionBankQuestion(@RequestBody QuestionBankQuestionAddRequest questionBankQuestionAddRequest, HttpServletRequest request) { ThrowUtils.throwIf(questionBankQuestionAddRequest == null, ErrorCode.PARAMS_ERROR); // todo 在此处将实体类和 DTO 进行转换 QuestionBankQuestion questionBankQuestion = new QuestionBankQuestion(); BeanUtils.copyProperties(questionBankQuestionAddRequest, questionBankQuestion); // 数据校验 questionBankQuestionService.validQuestionBankQuestion(questionBankQuestion, true); // todo 填充默认值 User loginUser = userService.getLoginUser(request); questionBankQuestion.setUserId(loginUser.getId()); // 写入数据库 boolean result = questionBankQuestionService.save(questionBankQuestion); ThrowUtils.throwIf(!result, ErrorCode.OPERATION_ERROR); // 返回新写入的数据 id long newQuestionBankQuestionId = questionBankQuestion.getId(); return ResultUtils.success(newQuestionBankQuestionId); }\",\"修改校验逻辑\",\"/** * 校验数据 * * @param questionBankQuestion * @param add 对创建的数据进行校验 */ @Override public void validQuestionBankQuestion(QuestionBankQuestion questionBankQuestion, boolean add) { ThrowUtils.throwIf(questionBankQuestion == null, ErrorCode.PARAMS_ERROR); // 参数校验，题库和题目必须存在 Long questionId = questionBankQuestion.getQuestionId(); if (questionId != null) { Question question = questionService.getById(questionId); ThrowUtils.throwIf(question == null, ErrorCode.NOT_FOUND_ERROR, \\\"题目不存在\\\"); } Long questionBankId = questionBankQuestion.getQuestionBankId(); if (questionBankId != null) { QuestionBank questionBank = questionBankService.getById(questionBankId); ThrowUtils.throwIf(questionBank == null, ErrorCode.NOT_FOUND_ERROR, \\\"题库不存在\\\"); } }\",\"注意：QuestionService 和 QuestionBankQuestionService 存在互相引用，会导致循环依赖问题，让项目无法启动。\",\"解决方法：在 QuestionBankQuestionServicelmpl 中引用 QuestionService 的位置加上 @Lazy 注解解决。\",\"@Resource @Lazy // 懒加载 private QuestionService questionService; @Resource private QuestionBankService questionBankService;\",\"2. 移除题库题目关联：\",\"增加题库题目关联请求类\",\"/** * 移除题库题目关联请求 * * @author BraumAce */ @Data public class QuestionBankQuestionRemoveRequest implements Serializable { /** * 题库 id */ private Long questionBankId; /** * 题目 id */ private Long questionId; private static final long serialVersionUID = 1L; }\",\"编写移除题库题目关联接口\",\"/** * 移除题库题目关联 * * @param questionBankQuestionRemoveRequest * @return */ @PostMapping(\\\"/remove\\\") public BaseResponse<Boolean> removeQuestionBankQuestion(@RequestBody QuestionBankQuestionRemoveRequest questionBankQuestionRemoveRequest) { // 参数校验 ThrowUtils.throwIf(questionBankQuestionRemoveRequest == null, ErrorCode.PARAMS_ERROR); Long questionBankId = questionBankQuestionRemoveRequest.getQuestionBankId(); Long questionId = questionBankQuestionRemoveRequest.getQuestionId(); ThrowUtils.throwIf(questionBankId == null || questionId == null, ErrorCode.PARAMS_ERROR); // 构造查询 LambdaQueryWrapper<QuestionBankQuestion> lambdaQueryWrapper = Wrappers.lambdaQuery(QuestionBankQuestion.class) .eq(QuestionBankQuestion::getQuestionBankId, questionBankId) .eq(QuestionBankQuestion::getQuestionId, questionId); boolean result = questionBankQuestionService.remove(lambdaQueryWrapper); return ResultUtils.success(result); }\",\"提示\",\"一般 Service 层中讲究的是复用性，或者是复杂的业务逻辑。\",\"如果 Controller 层中逻辑非常简单，也不需要复用，可以直接将实现写在 Controller 层中。\",\"扩展\",\"如果用同样的参数多次调用 “创建题库题目关联接口”，会因为数据库的唯一性约束导致 org.springframework.dao.DuplicateKeyException 异常，然后会被全局异常处理器处理返回 “系统错误”。针对这种情况可以进行异常捕获，并优化报错文案，比如 “不能重复加入”。\",\"如果给题库表增加题目总数字段，则修改题目所属题库时，要同时更新题库表的题目总数，涉及多表操作，需要使用事务实现。\"]},\"527\":{\"c\":[\"项目\"]},\"528\":{\"c\":[\"面试吧\"]},\"529\":{\"h\":\"第三期 - 前端模版开发\",\"t\":[\"面试吧笔记第三期 - 前端模板开发\",\"开发前端服务端渲染网站模板，并完成面试吧 Web 前端的部分基础页面。\"]},\"530\":{\"h\":\"1. 服务端渲染\"},\"531\":{\"h\":\"1.1 什么是客户端和服务端渲染\",\"t\":[\"1. 客户端渲染（Client-Side Rendering，CSR）：\",\"在客户端渲染模式下，服务器返回一个基本的 HTML 页面结构和一些必要的 JavaScript 和 CSS 文件。然后，客户端的浏览器通过执行 JavaScript 代码来请求数据，并根据数据动态生成页面内容。\",\"这种模式下，页面的渲染过程主要由客户端的浏览器完成，可以实现更丰富的交互和动态内容。\",\"但是，初始加载时需要下载和执行大量的 JavaScript 代码，页面加载速度相对较慢，对搜索引擎的可访问性较差。\",\"2. 服务端渲染（Server-Side Rendering，SSR）：\",\"在服务端渲染模式下，服务器在接收到客户端请求后，会将页面的初始 HTML 内容生成并发送给客户端。客户端接收到 HTML 后，进行解析和渲染，最终呈现给用户。\",\"在这种模式下，页面的大部分内容在服务器端已经渲染完成，因此页面加载速度相对较快，并且对搜索引擎友好。\",\"但是，交互式的内容和功能需要等待客户端的 JavaScript 代码执行完成后才能实现。\",\"相关信息\",\"客户端渲染和服务端渲染的主要区别在于渲染过程发生的地点。\"]},\"532\":{\"h\":\"1.2 客户端渲染\",\"t\":[\"CSR 的过程如下：\",\"客户端发送请求：客户端浏览器发送页面请求给服务器。\",\"服务器处理请求：服务器接收到请求后，返回一个包含基本 HTML 结构和 JavaScript 的响应。\",\"客户端下载资源：客户端浏览器接收到响应后，开始下载所需的 JavaScript 文件和其他静态资源。\",\"客户端执行 JavaScript：客户端浏览器解析并执行下载的 JavaScript 文件，生成页面的 DOM 结构。\",\"数据获取和处理：客户端通过 JavaScript 发起异步请求，从服务器获取所需的数据。\",\"模板渲染和内容填充：客户端使用获取到的数据，通过 JavaScript 操作 DOM，将数据填充到页面中的相应位置。\",\"页面展示：客户端浏览器根据最终的 DOM 结构和样式，渲染并展示页面给用户。\",\"CSR 的优点包括：\",\"更快的页面切换速度：由于只需要获取基本的 HTML 结构和 JavaScript 文件，页面切换时可以更快地加载和渲染。\",\"减轻服务器压力：服务器只需提供基本的 HTML 结构和 JavaScript 文件，不需要进行页面渲染和数据处理，减轻了服务器的压力。\",\"适用于复杂的交互和动态内容：通过异步请求和前端 JavaScript 处理，可以实现复杂的交互和动态内容，提供更好的用户体验。\",\"CSR 的缺点包括：\",\"首屏加载速度较慢：由于需要下载和执行 JavaScript 文件，页面的首次加载速度相对较慢，用户可能在加载过程中看到空白页面。\",\"不利于搜索引擎优化：由于初次加载的页面内容较少，搜索引擎难以理解和索引页面的全部内容，对搜索引擎优化不友好。\",\"对浏览器兼容性要求较高：CSR 需要客户端浏览器支持 JavaScript，并且不同浏览器对 JavaScript 的解析和执行可能存在差异，对兼容性要求较高。\",\"CSR 通过在客户端浏览器执行 JavaScript，实现了快速的页面切换和复杂交互，但也面临首屏加载速度较慢和搜索引擎优化不友好的问题。在具体项目中，需要综合考虑需求和限制，选择合适的渲染模式。\"]},\"533\":{\"h\":\"1.3 服务端渲染\",\"t\":[\"服务端渲染的过程如下：\",\"客户端发送请求：客户端浏览器发送页面请求给服务器。\",\"服务器处理请求：服务器接收到请求后，根据请求的路由和数据，执行相应的处理逻辑。\",\"数据获取和处理：服务器从数据库或其他数据源中获取所需的数据，并进行必要的处理和转换。\",\"模板渲染：服务器使用获取到的数据和事先定义好的模板引擎，将数据填充到模板中，生成完整的 HTML 页面。\",\"返回渲染结果：服务器将渲染好的 HTML 页面作为响应返回给客户端浏览器。\",\"客户端解析和渲染：客户端浏览器接收到 HTML 响应后，进行解析和渲染，最终呈现给用户。\",\"SSR 的优点包括：\",\"更快的首屏加载速度：由于服务器在渲染过程中已经将页面的大部分内容生成，用户在访问网站时可以快速看到页面的内容，提升了用户体验。\",\"更好的搜索引擎优化：搜索引擎可以直接获取到完整的 HTML 页面，可以更好地理解和索引网页内容，提高网站在搜索结果中的排名。\",\"更好的可访问性：由于服务器端已经生成了完整的 HTML 页面，即使客户端浏览器不支持 JavaScript 或 JavaScript 出错，用户仍然可以正常访问和浏览网页内容。\",\"SSR 的缺点包括：\",\"服务器压力较大：由于页面的渲染逻辑在服务器端执行，需要服务器进行更多的计算和处理，对服务器的性能要求较高。\",\"复杂的交互和动态内容有延迟：复杂的交互和动态内容需要等待客户端的 JavaScript 代码执行完成后才能实现，可能会有一定的延迟。\",\"开发复杂度较高：SSR 需要在服务器端和客户端进行不同的处理和逻辑，开发和维护的复杂度相对较高。\",\"SSR 通过在服务器端生成页面的初始 HTML 内容，提供了更快的加载速度和更好的搜索引擎优化，但也面临服务器压力大和开发复杂度高的挑战。在具体项目中，需要综合考虑需求和限制，选择合适的渲染模式。\",\"在 SSR 模式下，服务器会执行页面的渲染逻辑，包括数据获取、模板渲染和路由处理等。服务器会将渲染好的 HTML 页面发送给客户端，客户端浏览器接收到 HTML 后，进行解析和渲染，最终呈现给用户。\"]},\"534\":{\"h\":\"1.4 其他渲染方式 - 静态网站生成\",\"t\":[\"静态网站生成（Static Site Generation，SSG）是一种在构建阶段生成静态 HTML 文件的技术。与服务端渲染不同，静态网站生成是在构建时（而不是用户请求时）生成页面，所有页面都以静态文件的形式存在。\",\"这种方式本质上也是客户端渲染，但是不需要由客户端再动态地向后端发送请求来获取数据，这些静态文件可以直接由内容分发网络（CDN）或静态服务器提供。\",\"优点：\",\"高性能：由于服务器仅需提供静态文件，性能极高；而且由于数据不变化，特别适合通过 CDN 缓存加速。\",\"SEO 友好:搜索引擎最喜欢的就是静态 HTML 文件，可以轻松索引并提升 SEO 效果。\",\"简化基础设施:无需复杂的前后端交互逻辑，静态文件的部署和维护成本较低。\",\"缺点：\",\"动态内容有限：SSG 适合内容变化不频繁的场景，对于需要实时更新内容的网站，生成静态页面可能不够灵活\",\"构建时间：生成大量静态页面时，构建时间可能较长，特别是数据量大的时候。\",\"基于这些优缺点，静态网站生成适合内容数量有限的、内容基本不变的网站，比如个人博客。像 VuePress、Hugo、Hexo、Astro 都是主流的静态网站生成器。\",\"随着静态网站内容越来越多，每次构建会越来越慢。在这种情况下，可以采用增量静态生成技术。\",\"增量静态生成（Incremental Static Regeneration，ISR）允许部分页面在构建之后进行更新，而无需重新构建整个站点。这种技术适用于那些大多数内容不变、但某些部分需要动态更新的网站。\",\"工作流程：\",\"在构建阶段，生成初始的静态页面。\",\"当页面内容更新时，通过配置的再生成间隔，静态页面可以增量更新，而不是重新生成整个站点，大幅减少构建时间。\",\"用户请求时，如果页面内容过期或更新，则后台自动生成新的静态页面并缓存。\",\"这样一来，可以在既能享受静态网站高性能、SEO 友好特性的同时，又能及时更新网站的内容，并减少构建时间。\",\"不过缺点就是架构更复杂、维护成本更高。但值得一提的是，很多大型网站为了做 SEO 优化，专门把动态网站转为静态 HTML（静态化）。\"]},\"535\":{\"h\":\"1.5 结合使用（推荐）\",\"t\":[\"实际情况下，前面讲到的几种方式可以结合使用。\",\"比如 部分预渲染（Partial Prerendering，PPR）是一种将服务端渲染（或静态生成）与客户端渲染结合的技术。\",\"工作流程：\",\"在构建阶段或请求阶段，页面的静态部分预先渲染（如导航栏、页脚等）。\",\"页面加载时，静态部分直接显示，动态部分由 JavaScript 在客户端加载并渲染。\",\"通过水合（Hydration）过程，客户端的 JavaScript 接管已经渲染的静态内容，并继续处理动态交互。\",\"这样一来，就可以兼具 SSR 的 SEO 友好和快速初始加载、以及 CSR 灵活动态交互的优点。\",\"同构渲染\",\"还有一个跟部分预渲染相似的概念叫 同构渲染，是指同一套代码可以在服务端和客户端运行，并在服务端渲染页面的初始内容，然后在客户端接管渲染和交互。\"]},\"536\":{\"h\":\"2. 开发 Next.js 前端万用模板\",\"t\":[\"自主打造一套前端万用模版。\"]},\"537\":{\"h\":\"2.1 确认环境\",\"t\":[\"Next.js 官方文档：https://nextjs.org/docs/app/getting-started/installation\",\"注意：官方文档才是最新版，国内的中文文档不够新！\",\"本项目我们使用的是 14 版本的 Next.js，可以看到 Node.js 的版本要求必须 ≥ 18.18，一定要注意！\",\"相关信息\",\"Node.js 版本检测命令：\",\"node -v\",\"切换和管理 node 版本的工具：https://github.com/nvm-sh/nvm\",\"npm -V\",\"注意：Next.js 有 2 种开发模式。本项目用的是新的开发模式 App Router。\"]},\"538\":{\"h\":\"2.2 创建项目\",\"t\":[\"直接按照官方文档的指引，使用 Npm 自带的 Npx 脚手架工具 create-next-app 来自动安装 Next.js 初始化项目：https://nextjs.org/docs/getting-started/installation#automatic-installation\",\"执行安装命令：\",\"npx create-next-app@latest # 或者：npx create-next-app@14.2.6\",\"其中，latest 表示当前脚手架的最新版本。本项目中使用的 create-next-app 脚手架版本是 14.2.6，可以在 npm 包管理器网站 查看版本情况，可以直接把命令中的 latest 替换为 14.2.6。\",\"脚手架可以帮我们自动整合 React、Next.js、TypeScript 语法、ESLint 校验等库，如下所示创建前端项目：\",\"脚手架会自动生成代码并安装依赖，如果安装依赖卡住，可能需要更换 Npm 镜像为国内源：\",\"npm config set registry https://registry.npmmirror.com/\",\"接着使用 WebStorm 打开项目，在终端执行 npm run dev 命令，能访问到网页就成功了。\"]},\"539\":{\"h\":\"2.3 前端工程化配置\",\"t\":[\"使用脚手架创建项目后，脚手架已经帮我们配置了 ESLint 自动校验、TypeScript 类型校验，但是我们还需要手动整合代码自动格式化插件 Pretier。\",\"注意\",\"前端整合多个工具时，很容易出现版本冲突的问题，尤其是 ESlint 和 Prettier 整合时，校验规则可能也会存在冲突。\",\"所以，最好按照官方文档的指引来操作。\",\"先去 prettier 官网 安装 prettier，执行命令：\",\"npm install --save-dev --save-exact prettier\",\"接着按照 Next.js 整合 prettier 的官方文档：Next.js With Prettier，通过命令安装整合包 eslint-config-prettier：\",\"npm install --save-dev eslint-config-prettier\",\"再修改项目文件 .eslintrc.json 的配置：\",\"{ \\\"extends\\\": [\\\"next/core-web-vitals\\\", \\\"prettier\\\"] }\",\"最后在 WebStorm 设置中开启代码美化插件：\",\"在任意一个 tsx 文件中执行格式化快捷键（Ctrl + Alt + L），不报错则代表配置工程化成功。\",\"修改 .eslintrc.json 文件可以改变校验规则，一般项目不需要修改，具体可以到 ESLint 和 Prettier 的官方文档中查看。\",\"相关信息\",\"如果不使用脚手架，就需要自己按照下面这些文档整合这些工具:\",\"代码规范：https://eslint.org/docs/latest/use/getting-started\",\"代码美化：https://prettier.io/docs/en/install.html\",\"直接整合：https://github.com/prettier/eslint-plugin-prettier#recommended-configuration（包括了 https://github.com/prettier/eslint-config-prettier#installation）\",\"但不推荐，自己整合很容易出错，使用脚手架可以帮助我们快速构建。\"]},\"540\":{\"h\":\"2.4 引入组件库\",\"t\":[\"Ant Design 是 React 项目主流的组件库，Ant Design Procomponents 是在此基础上进一步封装的高级业务组件库。\",\"参考官方文档在 Next.js 项目中引入 Ant Design 5.x 版本的组件库：https://ant-design.antgroup.com/docs/react/use-with-next-cn\",\"执行安装命令：\",\"npm install antd --save\",\"针对 App Router 模式的 Next.js，需要处理页面闪动的情况：\",\"npm install @ant-design/nextjs-registry --save\",\"修改页面全局布局文件 app/layout.tsx：\",\"import React from \\\"react\\\"; import { AntdRegistry } from \\\"@ant-design/nextjs-registry\\\"; const RootLayout = ({ children }: React.PropsWithChildren) => ( <html lang=\\\"en\\\"> <body> <AntdRegistry>{children}</AntdRegistry> </body> </html> ); export default RootLayout;\",\"此时，在任意 .tsx 文件中引入 Ant Design 即可正常显示。\",\"引入 Ant Design 后，我们还可以引入 Ant Design Procomponents，参考 官方文档 使用下面命令安装：\",\"npm i @ant-design/pro-components --save\",\"由于 ProComponents 基于原始的 Ant Design 组件进行了更高级别的封装，所以每个组件都比较大，因此每一个组件都是一个独立的包，需要在项目中安装对应的 npm 包才能使用。\",\"比如使用 ProTable 表格组件，还需要安装 @ant-design/pro-table。\",\"引入组件库后，可以清理掉 app/globals.css 中的样式，减少样式冲突。\",\"修改为如下样式，减少浏览器默认样式的影响:\",\"* { box-sizing: border-box; padding: 0; margin: 0; } html, body { max-width: 100vw; max-height: 100vh;; }\"]},\"541\":{\"h\":\"2.5 Next.js 开发规范\",\"t\":[\"对于一个新项目，统一的开发规范是至关重要的。\",\"一般可以在官方文档中搜索 “最佳实践” 找到。比如，在 Next.js 官方文档中搜索 “best practices”，如下所示：\"]},\"542\":{\"h\":\"2.5.1 约定式路由\",\"t\":[\"Next.js 使用 约定式路由，根据文件夹的结构和名称，自动将对应的 URL 地址映射到页面文件。\",\"常见的几种路由规则如下：\",\"基础规则：以 app 目录作为根路径，根据文件夹的名称和嵌套层级，自动映射为 URL 地址。\",\"注意\",\"只有目录下直接包含 page 文件（js、jsx、ts、tsx 都支持）才会被识别为路由。\",\"路由组：可以通过 (xxx) 语法，创建一个路由组，不会被转化为路径，可用于对路由进行分组管理。比如同组路由使用同一套布局。\",\"动态路由：可以通过 [xxx] 语法，让多个不同参数的 URL 复用同一个页面。\",\"比如 app/question/[questionId]/page.tsx 中 questionId 就是动态路由参数，可以匹配 /question/1、/question/2 等 URL 地址，在页面中可以获取到 questionId 并加载不同的题目。\",\"export default function Page({ params }: { params: { questionId: string } }) { return <div>我的题目: {params.questionId}</div> }\",\"以上只是 Next.js 的几种常用路由规则，其他规则详见 Next.js 的官方文档：https://nextjs.org/docs/app/building-your-application/routing\"]},\"543\":{\"h\":\"2.5.2 静态资源\",\"t\":[\"Next.js 约定在 /public 目录下存放静态资源。在其下新建 assets 目录，可以在里面存放图片等静态资源文件。\",\"对应官方文档：https://nextjs.org/docs/app/building-your-application/optimizing/static-assets\",\"比如网站的 Logo，可以用 Next.js 的 Image 组件加载静态资源：\",\"<Image src={`/assets/logo.png`} alt={alt} width=\\\"64\\\" height=\\\"64\\\" />\",\"Next.js 会针对该组件进行特定的图像优化，提升性能。\",\"注意\",\"某些特殊的、常用的元信息文件不是放在 public 目录下，而是应该根据特定规则放在 app 目录下！\",\"对应官方文档：https://nextjs.org/docs/app/api-reference/file-conventions/metadata\",\"1）将 favicon.ico 放到 app 的根目录下，可展示站点小图标：\",\"2）将 robots.txt 放到 app 的根目录下，可用于告诉搜索引擎爬虫能否访问特定的页面、以及站点地图的地址，比如：\",\"User-Agent: * Allow: / Disallow: /private/ Sitemap: https://mianshiba.com/sitemap.xml\"]},\"544\":{\"h\":\"2.5.3 文件组织形式\",\"t\":[\"首先，项目中的每个页面和组件都是单独的文件夹。\",\"基于 Next.js 的约定式路由，我们每个页面目录内需要添加 page.tsx 页面文件和 index.css 样式文件；每个组件目录内添加 index.tsx 页面文件和 index.css 样式文件。\",\"对于项目中多页面公用的组件，放在 src/components 目录下；\",\"对于某个页面私有的组件，放在该页面的 components 目录下。\"]},\"545\":{\"h\":\"2.5.4 页面开发规范\",\"t\":[\"Next.js 文持 React 的语法，可以用函数的方式声明页面和组件。每个页面的根元素必须有 id、每个组件根元素必须有 className，用于控制样式和快速定位。\",\"为了区分服务端和客户端渲染，每个页面（或组件）都必须在开头显示编写 use client 或 use server。\"]},\"546\":{\"h\":\"2.5.5 其他注意事项\",\"t\":[\"开发时要严格注意 TypeScript 的类型和编辑器的错误提示，并且定期打包构建。因为 Next.js 的构建要求非常严格，稍有不慎就会报错。构建报错的话，注意查看和处理构建中的报错信息。\",\"在项目中慎用 window 等浏览器环境才支持的对象，服务端无法使用。注意保证客户端渲染页面和服务端渲染页面的一致性，否则会出现水合错误。\"]},\"547\":{\"h\":\"2.6 全局通用布局\",\"t\":[\"所谓的全局通用布局，是指在多个页面间复用的 UI 元素，比如导航栏。\",\"Next.js 支持全局根布局（每个页面都会生效）以及嵌套布局（可以只对部分页面生效），详情可 参考文档。\"]},\"548\":{\"h\":\"2.6.1 基础布局结构\",\"t\":[\"新建 src/layouts 目录，用于存放项目中的各种布局。在该目录下新建一个布局文件夹 BasicLayout，包括 index.tsx 页面和 index.css 样式文件。\",\"直接使用 Ant Design Procomponents 的布局组件 快速实现包含导航栏、内容、底部栏的响应式布局。\",\"以 基础布局示例 为基础模版:\",\"在 app/layout.tsx 全局布局文件中引入 BasicLayout：\",\"export default function RootLayout({ children, }: Readonly<{ children: React.ReactNode; }>) { return ( <html lang=\\\"zh\\\"> <body> <AntdRegistry> <BasicLayout>{children}</BasicLayout> </AntdRegistry> </body> </html> ); }\",\"然后按需精简和修改 BasicLayout 中复制来的布局代码，直到项目可以正常运行并符合预期。\"]},\"549\":{\"h\":\"2.6.2 全局底部栏\",\"t\":[\"新建 src/components 目录，表示全局公用组件。\",\"在该目录下创建 GlobalFooter 文件夹，表示全局底部栏，通常用于展示版权信息。\",\"index.tsx 如下：\",\"\\\"use client\\\"; import React from \\\"react\\\"; import \\\"./index.css\\\"; /** * 全局底部栏 * @constructor */ export default function GlobalFooter() { const currentYear: number = new Date().getFullYear(); return ( <div className={\\\"global-footer\\\"}> <div>© {currentYear} 面试吧</div> <div> <a href={\\\"https://github.com/BraumAce/mianshiba\\\"} target={\\\"_blank\\\"}> 作者：BraumAce </a> </div> </div> ); }\",\"index.css 如下：\",\".global-footer { position: absolute; bottom: 0; width: 100%; background: #efefef; text-align: center; padding: 16px; }\",\"在 src/layouts/BasicLayout/index.tsx 目录下引用：\",\"// 底部栏 footerRender={() => { return <GlobalFooter />; }}\"]},\"550\":{\"h\":\"2.6.3 全局顶部导航栏\"},\"551\":{\"h\":\"2.6.4 导航菜单配置\"},\"552\":{\"c\":[\"项目\"]},\"553\":{\"c\":[\"面试吧\"]},\"554\":{\"h\":\"第一期 - 上\",\"t\":[\"用户中心笔记第一期 - 上\"]},\"555\":{\"h\":\"1、企业做项目流程\",\"t\":[\"需求分析\",\"设计（概要设计、详细设计）\",\"技术选型\",\"初始化 / 引入需要的技术\",\"写 Demo\",\"写代码（实现业务逻辑）\",\"测试（单元测试、系统测试）\",\"代码提交 / 代码评审\",\"部署\",\"发布上线\"]},\"556\":{\"h\":\"2、需求分析\",\"t\":[\"登录 / 注册\",\"用户管理（仅管理员可见）对用户的查询或者修改\",\"用户校验（注册校验，权限校验）\"]},\"557\":{\"h\":\"3、技术选型\",\"t\":[\"前端：\",\"HTML+CSS+JavaScript 三件套\",\"React 开发框架\",\"组件库 Ant Design\",\"Umi 开发框架\",\"Umi Request 开发框架Ant Design Pro（现成的管理系统）\",\"后端：\",\"java\",\"spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）\",\"springmvc（web 框架，提供接口访问、restful接口等能力）\",\"mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）\",\"mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）\",\"springboot（快速启动 / 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）\",\"junit 单元测试库\",\"mysql 数据库\",\"部署：服务器 / 容器（平台）\"]},\"558\":{\"h\":\"4、初始化项目\"},\"559\":{\"h\":\"4.1 前端初始化\",\"t\":[\"按照 Nodejs 版本 16.14 以上\",\"Ant Design Pro 前端框架\",\"先新建一个文件夹 user-center，进入到目录，在地址栏输入 cmd，打开终端，输入以下命令初始化前端：\",\"npm i @ant-design/pro-cli -g pro create user-center-ui\",\"步骤\",\"执行后进入前端框架初始化过程，这里选择使用 umi@3 和 simple 一个简单模式的脚手架，然后通过 webstorm 进入 user-center-ui 文件夹，打开终端，输入 yarn，自动安装相关依赖。安装依赖完成后，找到 package.json。scripts 下有很多脚本，找到 start 并运行。即可启动 ant design pro.\",\"关于 Umi UI 插件的构建，因为我们之前已经选择的是 umi@3，进入 myapp 文件夹的 terminal 是一个 Umi UI 可视化辅助工具，但是区块一直无法显示，挂了梯子以及修改了 hosts 之后还是不行，所以实在不行可以跳过，不影响后续开发。\",\"安装 Umi UI\",\"yarn add @umijs/preset-ui -D\",\"使用该工具可以帮助我们快速生成页面\",\"前端瘦身\",\"删除国际化 \",\"执行 package.json 的 scripts 下的 i18n-remove 脚本，移除国际化\",\"删除前端路径下 src/locales 文件夹\",\"删除项目路径下 src/e2e 文件夹 \",\"e2e 文件夹里面定义的是一系列测试流程\",\"若前面有使用 Umi UI 添加页面，可把该页面删除 \",\"注意：需要在路劲为 config/routes.ts 的文件夹下，删除对应的路由规则\",\"删除项目路径下 src/services/swagger 文件夹 \",\"swagger 文件夹里面定义了一系列后台接口程序\",\"删除项目路径下 config/oneapi.json 文件 \",\"oneapi.json 定义了整个项目用到的一些接口\",\"删除项目根路径下 tests 文件夹 \",\"tests 文件夹主要是和测试相关的\",\"删除项目根路径下 jest.config.js 文件 \",\"jest.config.js 测试相关的配置文件\",\"删除项目根路径下 playwright.config.ts 文件 \",\"playwright.config.ts -> 自动化测试工具，帮你在火狐或谷歌自动测试，不用真实地打开浏览器就能测试\"]},\"560\":{\"h\":\"4.2 后端初始化：3种初始化 Java 项目的方式\",\"t\":[\"GitHub 搜现成的代码\",\"SpringBoot 官方的模板生成器（https://start.spring.io/）\",\"直接在 IDEA 开发工具中生成 （一般都是自己创建工程） 如果要引入 java 的包，可以去 maven 中心仓库寻找（http://mvnrepository.com/）新建好工程，然后整合 MyBatis-Plus 跟着官网来就可以了\"]},\"561\":{\"c\":[\"项目\"]},\"562\":{\"c\":[\"用户中心\"]},\"563\":{\"h\":\"第二期 - 中\",\"t\":[\"用户中心笔记第二期 - 中\"]},\"564\":{\"h\":\"1、数据库设计\",\"t\":[\"什么是数据库？存储数据\",\"数据库里有什么？数据表（理解为 excel 表格）\",\"java 操作数据库？程序代替人工\"]},\"565\":{\"h\":\"1.1 什么是设计数据库表？\",\"t\":[\"有哪些表（模型）？\",\"表中有哪些字段？\",\"字段的类型？\",\"数据库字段添加索引？\",\"表与表之间的关联？\",\"性别是否需要加索引？\",\"不需要.区分度不大的字段没必要加索引\"]},\"566\":{\"h\":\"1.2 用户表设计\",\"t\":[\"可选字段：\",\"字段\",\"说明\",\"类型\",\"id\",\"主键，唯一标识\",\"bigint\",\"username\",\"用户名\",\"varchar\",\"userAccount\",\"用户昵称\",\"varchar\",\"password\",\"密码\",\"varchar\",\"avatar\",\"用户头像\",\"varchar\",\"gender\",\"性别\",\"tinyint\",\"phone\",\"电话\",\"varchar\",\"email\",\"邮箱\",\"varchar\",\"status\",\"账户状态(0 - 正常 1 - 停用)\",\"int\",\"lastTime\",\"上次登录时间\",\"datetime\",\"userRole\",\"用户权限(0 - 普通用户 1 - 管理员)\",\"int\",\"remark\",\"备注\",\"varchar\",\"必要字段\",\"字段\",\"说明\",\"类型\",\"createTime\",\"创建时间(数据插入时间)\",\"datetime\",\"updateTime\",\"更新时间(数据更新时间)\",\"datetime\",\"isDelete\",\"是否删除(逻辑删除)\",\"tinyint\",\"建表语句:\",\"create table user ( userId bigint auto_increment comment '用户ID' primary key, userName varchar(256) not null comment '用户名', nickName varchar(256) null comment '用户昵称', password varchar(256) not null comment '密码', avatar varchar(1024) null comment '用户头像', gender tinyint null comment '性别（0 - 男 1 - 女）', phone varchar(128) null comment '电话', email varchar(256) null comment '邮箱', status int default 0 not null comment '账号状态（0 - 正常 1 - 停用）', isDelete tinyint default 0 not null comment '是否删除（0 - 正常 1 - 删除）', lastTime timestamp default CURRENT_TIMESTAMP null comment '最后登录时间', createTime timestamp default CURRENT_TIMESTAMP null comment '创建时间', updateTime timestamp default CURRENT_TIMESTAMP null comment '更新时间', userRole int default 0 null comment '用户角色（0 - 普通用户 1 - 管理员）', remark varchar(512) null comment '备注', constraint user_userId_uindex unique (userId) ) comment '用户表';\"]},\"567\":{\"h\":\"1.3 自动生成器的使用\",\"t\":[\"使用 MyBatisX 插件，根据数据库表结构自动生成代码：\",\"domain：实体对象\",\"mapper：操作数据库的对象\",\"mapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL\",\"service：包含常用的增删改查\",\"serviceImpl：具体实现 service\",\"第一步\",\"第二步\",\"将生成的代码拖到对应的包路径下之后，编写测试类，测试类如下：\",\"@Test void testInsertUser() { User user = new User(); user.setUserName(\\\"16937\\\"); user.setNickName(\\\"BraumAce\\\"); user.setPassword(\\\"12345678\\\"); user.setAvatar(\\\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\\\"); user.setGender(0); user.setPhone(\\\"12345678900\\\"); user.setEmail(\\\"1693717911@qq.com\\\"); user.setUserRole(1); boolean result = userService.save(user); System.out.println(\\\"新增用户ID：\\\" + user.getUserId()); // 断言，判断是否符合预期结果：assertTrue -- 是否返回为true Assertions.assertTrue(result); }\",\"可能的报错\",\"由于在建表时，字段均为驼峰命名，在生成实体类时用 @TableFiled 指定了字段映射关系，而 Mybatis-Plus 会自动进行驼峰命令转换，会导致找不到属性对应的字段，所以需要在配置文件中关闭：\",\"# 自动转换为驼峰 mybatis-plus: configuration: map-underscore-to-camel-case: false\"]},\"568\":{\"h\":\"2、注册逻辑设计\",\"t\":[\"用户在前端输入账户和密码、以及校验码\",\"校验用户的账户、密码、校验密码，是否符合要求 \",\"非空\",\"账户长度 不小于 4 位\",\"密码 不小于 8 位\",\"账户不能重复\",\"账户不包含特殊字符\",\"密码和校验密码相同\",\"用户编号不得大于15位\",\"对密码进行加密（密码千万不要直接以明文存储到数据库中）\",\"向数据库插入用户数据\",\"引入依赖：\",\"<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --> <dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-lang3</artifactId> <version>3.12.0</version> </dependency>\",\"commons-lang3\",\"Apache Commons Lang3 是 Apache 软件基金会开发的一组 Java 工具类库，提供各种常用字符串 处理、数学运算、数据转换、校验等常用功能实现的工具类\",\"盐值加密\",\"Java 中的盐值和密码混淆都是用来提高密码安全性的防护措施。盐值是一种用于增加密码破解难度的技术，在存储用户密码时，会将用户密码和一个随机生成的字符串（称为盐）进行组合，然后再进行加密存储。每个用户的盐值都是随机生成的，这样可以防止攻击者使用相同的方式对一组用户的密码执行攻击。在验证用户登录时，系统会使用相同的盐和用户输入的密码进行组合，并与存储的加密密码进行比对，以验证密码是否正确。\",\"完整代码如下：\",\"/** * 用户逻辑实现 * @author BraumAce */ @Service @slf4j public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService { @Resource private UserMapper userMapper; // 盐值,将密码进行混淆 private static final String SALT = \\\"braumace\\\"; /** * 用户注册实现 * @param userName 用户名 * @param password 用户密码 * @param checkPassword 校验密码 * @return 用户ID */ @Override public long userRegister(String userName, String password, String checkPassword) { // 1.校验用户的用户名、密码、校验密码，是否符合要求 // 1.1 非空校验 if (StringUtils.isAnyBlank(userName, password, checkPassword)) { return -1; } // 1.2 用户名长度不小于4位 if (userName.length() < 4) { return -1; } // 1.3 密码不小于8位 if (password.length() < 8 || checkPassword.length() < 8) { return -1; } // 1.4 用户名不包含特殊字符 String validPattern = \\\"[`~!@#$%^&*()+=|{}':;',\\\\\\\\\\\\\\\\[\\\\\\\\\\\\\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]\\\"; // 使用正则表达式进行校验 Matcher matcher = Pattern.compile(validPattern).matcher(userName); if (matcher.find()) { return -1; } // 1.5 密码和校验密码是否相同 if (!password.equals(checkPassword)) { return -1; } // 1.6 用户名不能重复，查询数据库当中是否存在相同用户名 QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.eq(\\\"userName\\\", userName); long count = userMapper.selectCount(queryWrapper); if (count > 0) { return -1; } // 2.对密码进行md5盐值加密（密码千万不要直接明文存到数据库中） String encryptPassword = DigestUtils.md5DigestAsHex((SALT + password).getBytes()); // 3.将用户数据插入到数据库 User user = new User(); user.setUserName(userName); user.setPassword(encryptPassword); int result = userMapper.insert(user); if (result < 0) { return -1; } return user.getUserId(); } }\",\"测试注册功能：\",\"/** * 测试出错的情况 */ @Test void testUserRegister() { // 测试非空 String usernName = \\\"zhangsan\\\"; String passward = \\\"\\\"; String checkPassword = \\\"12345678\\\"; long result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试账户长度小于4 usernName = \\\"zhang\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试密码小于6位 usernName = \\\"zhangsan\\\"; passward = \\\"1234\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试特殊字符 usernName = \\\"zhangsan@\\\"; passward = \\\"12345678\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试密码和校验密码不相同 usernName = \\\"zhangsan\\\"; checkPassword = \\\"123457899\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试账号不重复 usernName = \\\"zhangsan\\\"; checkPassword = \\\"12345678\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 插入数据，如果已有则插入失败，返回-1 usernName = \\\"16937\\\"; passward = \\\"12345678\\\"; checkPassword = \\\"12345678\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); }\"]},\"569\":{\"c\":[\"项目\"]},\"570\":{\"c\":[\"用户中心\"]},\"571\":{\"h\":\"第三期 - 下\",\"t\":[\"用户中心笔记第三期 - 下\"]},\"572\":{\"h\":\"1、登录功能\"},\"573\":{\"h\":\"1.1 接口设计\",\"t\":[\"接收参数：用户名、密码 请求类型：POST 请求体：JSON 格式的数据 返回值：用户信息（脱敏）\",\"注意\",\"请求体很长时不建议用 get\"]},\"574\":{\"h\":\"1.2 登录逻辑\",\"t\":[\"校验用户账户和密码是否合法 \",\"非空\",\"账户长度不小于 4 位\",\"密码就不小于 8 位\",\"账户不包含特殊字符\",\"校验密码是否输入正确，要和数据库中的密文密码（注册时加密后的）去对比\",\"用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露\",\"我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录 cookie）\",\"返回脱敏后的用户信息\",\"脱敏\",\"信息脱敏（Data Masking）是一种隐私保护技术，通过对敏感数据进行修改或者替换的方 式，来保护数据的隐私和安全。信息脱敏通常应用于需要处理敏感数据的场景，例如测试、开发、分 析等环境。在信息脱敏技术中，被保护的敏感数据通常会被替换成某种规则定义的非敏感数据或者格 式，以避免敏感数据泄露和数据窃取的风险，主要就是防止信息泄露，隐藏敏感信息\"]},\"575\":{\"h\":\"1.3 如何知道是哪个用户登录了？\",\"t\":[\"连接服务器端后，得到一个 session 状态（匿名会话），返回给前端（用户已经有了会话，但是这个会 在用户登录成功之后才会保存到 Session）\",\"登录成功后，得到了登录成功的 session，并且给该 session 设置一些值（比如用户信息），返回给前端 一个设置 cookie 的 命令session => cookie\",\"前端接收到后端的命令后，设置 cookie，保存到浏览器内\",\"前端再次请求后端的时候（相同的域名），在请求头中带上 cookie 去请求\",\"后端拿到前端传来的 cookie，找到对应的 session\",\"后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）\",\"登录实现代码：\",\"/** * 用户登录实现 * @param userName 用户名 * @param password 用户密码 * @param request 请求对象 * @return 用户信息 */ @Override public User userLogin(String userName, String password, HttpServletRequest request) { // 1.校验用户的用户名、密码、校验密码，是否符合要求 // 1.1 非空校验 if (StringUtils.isAnyBlank(userName, password)) { return null; } // 1.2 用户名长度不小于4位 if (userName.length() < 4) { return null; } // 1.3 密码不小于8位 if (password.length() < 8) { return null; } // 1.4 用户名不包含特殊字符 String validPattern = \\\"[`~!@#$%^&*()+=|{}':;',\\\\\\\\\\\\\\\\[\\\\\\\\\\\\\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]\\\"; // 使用正则表达式进行校验 Matcher matcher = Pattern.compile(validPattern).matcher(userName); if (matcher.find()) { return null; } // 2.对密码进行md5盐值加密（密码千万不要直接明文存到数据库中） String encryptPassword = DigestUtils.md5DigestAsHex((SALT + password).getBytes()); // 查询用户是否存在 // TODO：此处有bug，会将逻辑删除的用户也查找出来，在 application.yml 中配置全局逻辑删除属性 QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.eq(\\\"userAccount\\\", userName); queryWrapper.eq(\\\"userPassword\\\", encryptPassword); User user = userMapper.selectOne(queryWrapper); if (user == null) { log.info(\\\"user login failed, userAccount cannot match userPassword\\\"); return null; } // 3.用户信息脱敏 User safetyUser = getSafetyUser(user); // 4.用户登录成功 // USER_LOGIN_STATE 用于记录用户的登录状态，后面用户状态优化会提到 request.getSession().setAttribute(USER_LOGIN_STATE, safetyUser); return safetyUser; } /** * 用户脱敏 * @param originUser 原始用户信息 * @return 脱敏后用户信息 */ @Override public User getSafetyUser(User originUser) { if (originUser == null) { return null; } User safetyUser = new User(); safetyUser.setUserId(originUser.getUserId()); safetyUser.setUserName(originUser.getUserName()); safetyUser.setNickName(originUser.getNickName()); safetyUser.setAvatar(originUser.getAvatar()); safetyUser.setGender(originUser.getGender()); safetyUser.setPhone(originUser.getPhone()); safetyUser.setEmail(originUser.getEmail()); safetyUser.setStatus(originUser.getStatus()); safetyUser.setLastTime(originUser.getLastTime()); safetyUser.setUserRole(originUser.getUserRole()); safetyUser.setRemark(originUser.getRemark()); return safetyUser; }\",\"逻辑删除\",\"逻辑删除是指在数据库中不是真正删除记录，而是标记为已删除，使得这些记录在系统中看起来像已被删除。这比物理删除更加安全、可靠，也能够满足许多场景下的需求。\",\"MyBatis-Plus 有一个逻辑删除，默认会帮助我们查询出来没有被删的用户，官方文档：https://baomidou.com/guides/logic-delete/\",\"按照文档在 application.yml 中配置全局逻辑删除属性：\",\"mybatis-plus: global-config: db-config: logic-delete-field: isDelete # 全局逻辑删除字段名 logic-delete-value: 1 # 1 - 删除 logic-not-delete-value: 0 # 0 - 正常\",\"并记得要在 User 实体类的 isDelete 字段上加上 @TableLogic 注解。\"]},\"576\":{\"h\":\"1.4 登录接口\",\"t\":[\"控制层 Controller 的主要工作：\",\"接收请求并解析参数\",\"调用 Service 执行具体的业务代码（可能包含参数校验）\",\"捕获业务逻辑异常做出反馈\",\"业务逻辑执行成功做出响应\",\"使用统一的 API 前缀方便管理：\",\"# application.yml 指定接口全局路径前缀 server: servlet: context-path: /api\",\"使用控制器注解：\",\"// 适用于编写 restful 风格的 api，返回值默认为 json 类型 @RestController\",\"RestFul 风格\",\"参考：https://blog.csdn.net/qq_56098191/article/details/129343870\",\"如果使用 JSON 格式参数的话，最好封装一个对象来记录所有的请求参数，这里我们在 model.domain.request 包下新建两个对象，分别记录注册和登录的请求参数。\",\"/** * 用户注册请求体 * @author BraumAce */ @Data public class UserRegisterRequest implements Serializable { // 序列化 private static final long serialVersionUID = 3553317334228624372L; // 用户名 private String userName; // 用户密码 private String password; // 校验密码 private String checkPassword; }\",\"/** * 用户登录请求体 * @author BraumAce */ @Data public class UserLoginRequest implements Serializable { // 序列化 private static final long serialVersionUID = 3553317334228624372L; // 用户名 private String userName; // 用户密码 private String password; }\",\"实现序列化接口\",\"在 implements Serializable 上右键选择 Generate -> serialVersionUID，生成序列化 ID。\",\"不过有可能点击 Generate 后并没有出现 serialVersionUID，于是可以去 settings -> editor -> Inspections，搜索 UID，如下操作：\",\"配置serialVersionUID\",\"光标放在 UserRegisterRequest，按下快捷键 Alt+Enter，选择 add'serialVersionUlD'fileld 即可。\",\"最后写一下校验，实现接口的调用，那么校验写在哪里？\",\"controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）\",\"service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）\",\"前面在 service 层已经写好了注册和登录的业务逻辑，接下来在 controller 层实现业务请求。\",\"使用 @RequestMapping，定义请求的路径，这里设置为 /user。\",\"/** * 用户控制器 * @author BraumAce */ @RestController @RequestMapping(\\\"/user\\\") public class UserController { @Resource private UserService userService; /** * 用户注册 * @param userRegisterRequest 用户注册请求 * @return 用户ID */ @PostMapping(\\\"/register\\\") public Long userRegister(@RequestBody UserRegisterRequest userRegisterRequest) { if (userRegisterRequest == null) { return null; } String userName = userRegisterRequest.getUserName(); String password = userRegisterRequest.getPassword(); String checkPassword = userRegisterRequest.getCheckPassword(); if (StringUtils.isAnyBlank(userName, password, checkPassword)) { return null; } return userService.userRegister(userName, password, checkPassword); } /** * 用户登录 * @param userLoginRequest 用户登录请求 * @param request 请求对象 * @return 用户信息 */ @PostMapping(\\\"/login\\\") public User userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request) { if (userLoginRequest == null) { return null; } String userName = userLoginRequest.getUserName(); String password = userLoginRequest.getPassword(); if (StringUtils.isAnyBlank(userName, password)) { return null; } return userService.userLogin(userName, password, request); } }\"]},\"577\":{\"h\":\"2、用户管理\",\"t\":[\"设置 Session 过期时间为 24 小时\",\"spring: session: timeout: 86400\",\"接口设计关键：必须鉴权！！且只能管理员使用\"]},\"578\":{\"h\":\"2.1 查询用户\",\"t\":[\"在 UserController 类下编写查询用户接口，不过要先进行管理员校验，只有管理员才能管理用户。如果这个接口不进行校验，那么人人都可以调用，这是非常不安全的。\",\"先进行管理员校验：\",\"private boolean isAdmin(HttpServletRequest request) { // 管理员校验 User user = (User) request.getSession().getAttribute(USER_LOGIN_STATE); if (user == null || user.getUserRole() != ADMIN_ROLE) { return false; } return true; }\",\"实现查询用户接口：\",\"/** * 查询用户 * @param userName 用户名 * @param request 请求对象 * @return 用户列表 */ @GetMapping(\\\"/search\\\") public List<User> searchUsers(String userName, HttpServletRequest request) { // 管理员校验 if (isAdmin(request)) { return new ArrayList<>(); } QueryWrapper<User> queryWrapper = new QueryWrapper<>(); if (StringUtils.isNotBlank(userName)) { queryWrapper.like(\\\"userName\\\", userName); } List<User> userList = userService.list(queryWrapper); return userList.stream() .map(userService::getSafetyUser) .collect(Collectors.toList()); }\"]},\"579\":{\"h\":\"2.2 删除用户\",\"t\":[\"实现删除用户接口：\",\"/** * 删除用户 * @param userId 用户ID * @param request 请求对象 * @return 结果 */ @DeleteMapping(\\\"/delete\\\") public boolean deleteUser(@RequestBody long userId, HttpServletRequest request) { if (!isAdmin(request)) { return false; } if (userId < 0 ) { return false; } return userService.removeById(userId); }\"]},\"580\":{\"h\":\"2.3 用户状态优化\",\"t\":[\"为方便前后端联调显示用户的登录状态，有必要在用户登录后记录用户状态。如果将状态直接写在登录逻辑里面，不利于后续维护和拓展，随着后期业务的拓展，其他地方也要调用用户状态，所以需要将用户的各种状态抽出来封装为常量。\",\"我们新建一个 constant 包，用来存储各种常量，新建一个 UserConstant 接口，记录用户的状态，以及再加上两个权限常量，如下：\",\"/** * 用户常量 * @author BraumAce */ public interface UserConstant { // 用户登录态键 String USER_LOGIN_STATE = \\\"登录成功\\\"; // 默认权限 int DEFAULT_ROLE = 0; // 管理员权限 int ADMIN_ROLE = 1; }\"]},\"581\":{\"c\":[\"项目\"]},\"582\":{\"c\":[\"用户中心\"]},\"583\":{\"h\":\"第四期 - 终\",\"t\":[\"用户中心笔记第四期 - 终\",\"先修改前端代码，将框架预生成的样式改成自己想要的样式。\",\"尤其注意参数名的修改\"]},\"584\":{\"h\":\"1、前后端交互\"},\"585\":{\"h\":\"1.1 前端请求\",\"t\":[\"前端需要向后端发送请求才能获取数据 / 执行操作。\",\"怎么发请求：前端使用 ajax 来请求后端\",\"axios 封装了 ajax\",\"request 是 ant design 项目又封装了一次\",\"追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件\"]},\"586\":{\"h\":\"1.2 代理的位置\",\"t\":[\"正向代理：替客户端向服务器发送请求，可以解决跨域问题\",\"反向代理：替服务器统一接收请求。\",\"怎么实现代理？\",\"Nginx 服务器\",\"Node.js 服务器\",\"举例：\",\"原来请求是：http://localhost:8000/api/user/login 通过反向代理到请求：http://localhost:8080/api/user/login\",\"过程如下：\",\"主要区别：\",\"代理的位置：正向代理靠近客户端，反向代理靠近服务器端。\",\"客户端的意识：使用正向代理时，客户端意识到代理的存在；而使用反向代理时，客户端通常不知道代理的存在。\",\"主要目的：正向代理主要用于客户端的访问控制和匿名性；反向代理主要用于服务器端的负载均衡、安全性和高可用性。\",\"配置方式：正向代理需要客户端进行配置；反向代理通常由服务器管理员配置。\"]},\"587\":{\"h\":\"2、注册页面\",\"t\":[\"先注册再登录。\",\"复制框架生成的登录页面，将文件名修改为注册页面\",\"添加路由规则\",\"在添加完组件以及路由之后，输入 http//localhost:8000/user/register ，发现会被强制路由至登录页面。此时想到 Ant Design Pro 框架本身是用来做后台管理系统，初始化框架规定在未登录情况下想操作其它页面，会被强制路由到登录页面。所以需要进行修改。\",\"修改前端项目入口文件 src/app.tsx\",\"取消重定向后并在下面的 layout: RunTimeLayoutConfig 中添加如下重定向配置：\",\"onPageChange: () => { const { location } = history; // 添加白名单，登录页面和注册页面不需要强制路由 if (location.pathname === \\\"/user/Register\\\") { return; } // 如果没有登录，重定向到 login if (!initialState?.currentUser && location.pathname !== loginPath) { history.push(loginPath); } },\",\"修改注册逻辑\",\"const Register: React.FC = () => { const [type, setType] = useState<string>('account'); const { styles } = useStyles(); const handleSubmit = async (values: API.RegisterParams) => { // 校验密码 const { userName, password, checkPassword } = values; if (password !== checkPassword) { message.error('两次密码不一致'); return; } else if (userName?.length < 4) { message.error('账号长度不能小于4') return; } try { // 注册 const id = await register(values); if (id > 0) { const RegisterMessage = '注册成功！'; message.success(RegisterMessage); /** 此方法会跳转到 redirect 参数所在的位置 **/ if (!history) return; const { query } = history.location; history.push({ pathname: '/user/login', query, }); return; } else { throw new Error(`register error id = ${id}`); } } catch (error) { const RegisterMessage = '注册失败，请重试！'; message.error(RegisterMessage); } }; return ( <div className={styles.container}> <Helmet> <title> {'注册'}- {Settings.title} </title> </Helmet> <div style={{ flex: '1', padding: '32px 0', }} > <LoginForm contentStyle={{ minWidth: 280, maxWidth: '75vw', }} logo={<img alt=\\\"logo\\\" src={SYSTEM_LOGO} />} title=\\\"Byte Lighting\\\" subTitle={'字节流光 - 一个很酷的学习交流平台'} submitter={{ searchConfig: { submitText: '注册', } }} onFinish={async (values) => { await handleSubmit(values as API.LoginParams); }} > <Tabs activeKey={type} onChange={setType} centered items={[ { key: 'account', label: '账号密码注册', }, ]} /> {type === 'account' && ( <> <ProFormText name=\\\"userName\\\" fieldProps={{ size: 'large', prefix: placeholder={'请输入账号'} rules={[ { required: true, message: '账号不能为空！', }, ]} /> <ProFormText.Password name=\\\"password\\\" fieldProps={{ size: 'large', prefix: placeholder={'请输入密码'} rules={[ { required: true, message: '密码不能为空！', }, { min: 8, type: 'string', message: '长度不能小于8', } ]} /> <ProFormText.Password name=\\\"checkPassword\\\" fieldProps={{ size: 'large', prefix: placeholder={'请确认密码'} rules={[ { required: true, message: '确认密码不能为空！', }, { min: 8, type: 'string', message: '长度不能小于8', } ]} /> </> )} </LoginForm> </div> <Footer /> </div> ); };\",\"修改后将页面中冗余的代码删除。\"]},\"588\":{\"h\":\"3、登录页面\",\"t\":[\"添加「注册页面」后，要在登录页面添加「注册链接」，以便从登录页跳转至用户注册页。\",\"<ProFormCheckbox noStyle name=\\\"autoLogin\\\"> 自动登录 </ProFormCheckbox> <a style={{ float: 'initial', }} href={DOCS_LINK} target=\\\"_blank\\\" rel=\\\"noreferrer\\\" > 忘记密码 </a> <Link to=\\\"/user/register\\\" style={{ float: 'right', }}>没有账号?点击注册</Link>\",\"在「自动登录」旁边加上「注册」，并调整布局，效果如下：\"]},\"589\":{\"h\":\"4、获取当前登录用户\",\"t\":[\"点击登录后获取到用户信息后跳转到主页，首先要拿到用户的信息，才能够成功跳转。所以先在后端添加获取当前登录用户信息的接口。\",\" /** * 获取当前用户 * @param request 请求对象 * @return 用户信息 */ @GetMapping(\\\"/current\\\") public User getCurrentUser(HttpServletRequest request) { // 获取登录态 User currentUser = (User) request.getSession().getAttribute(USER_LOGIN_STATE); if (currentUser == null) { return null; } // 根据id获取到用户信息，去数据库查询 Long userId = currentUser.getUserId(); // TODO 校验用户是否合法，比如封号等 User user = userService.getById(userId); return userService.getSafetyUser(user); }\",\"直接获取用户信息的方式并不推荐，还应该对状态异常的用户进行筛选。这里后面再调整。\",\"在 Login/index.tsx 中修改前端登录逻辑，设置登录参数 API.LoginParams：\",\" const handleSubmit = async (values: API.LoginParams) => { try { // 登录 const user = await login({ ...values, type, }); if (user) { const loginSuccessMessage = '登录成功！'; message.success(loginSuccessMessage); await fetchUserInfo(); const urlParams = new URL(window.location.href).searchParams; history.push(urlParams.get('redirect') || '/'); return; } console.log(user); // 如果失败去设置用户错误信息 setUserLoginState(user); } catch (error) { const loginFailureMessage = '登录失败，请重试！'; console.log(error); message.error(loginFailureMessage); } };\",\"在 typings.d.ts 中添加登录请求参数 API.LoginParams：\",\" type LoginParams = { userName?: string; password?: string; autoLogin?: boolean; type?: string; };\",\"还要在 api.ts 中添加调用的接口地址 /api/user/current，返回类型为 API.CurrentUser：\",\"/** 获取当前的用户 GET /api/user/currentUser */ export async function currentUser(options?: { [key: string]: any }) { return request<API.CurrentUser>('/api/user/current', { method: 'GET', ...(options || {}), }); }\",\"再到 typings.d.ts 配置返回的用户信息 CurrentUser：\",\"declare namespace API { type CurrentUser = { userId?: number; userName?: string; nickName?: string; avatar?: string; gender?: number; phone?: string; email?: string; status?: number; lastTime?: Date; userRole?: number; remark?: string; }; }\"]},\"590\":{\"h\":\"5、后台管理页面\"},\"591\":{\"h\":\"设置登录后自动跳转\",\"t\":[\"修改 src/app.tsx 下的初始化函数 getInitialState()：\",\"const loginPath = '/user/login'; const NO_NEED_LOGIN_WHITE_LIST = ['/user/register', loginPath]; export async function getInitialState(): Promise<{ settings?: Partial<LayoutSettings>; currentUser?: API.CurrentUser; loading?: boolean; fetchUserInfo?: () => Promise<API.CurrentUser | undefined>; }> { const fetchUserInfo = async () => { try { return await queryCurrentUser({ skipErrorHandler: true, }); } catch (error) { history.push(loginPath); } return undefined; }; // 如果是登录或注册页面，则执行 if (NO_NEED_LOGIN_WHITE_LIST.includes(history.location.pathname)) { return { // @ts-ignore fetchUserInfo, settings: defaultSettings, }; } const currentUser = await fetchUserInfo(); return { // @ts-ignore fetchUserInfo, currentUser, settings: defaultSettings, }; }\",\"点击登录后成功跳转到后台页面，但是可能右上角的头像和用户名一直加载不出来，大概率是因为后端传的变量名和前端没对上，修改后即可显示。\"]},\"592\":{\"h\":\"添加后台管理页面\",\"t\":[\"在 src/pages 下新建用户管理页 Admin/UserManage，再在 config/routes.ts 中添加路由规则：\",\"{ path: '/admin/user-manage', name: '用户管理', component: './Admin/UserManage' },\",\"ProComponents\",\"在 Ant Design 上进一步封装的前端组件：ProComponents\",\"在用户管理页面下引入组件，选择 ProComponents 中的 高级表格 进行构建。\",\"高级表格的属性\",\"通过 columns 定义表格有哪些列\",\"columns 属性：\",\"dataIndex：对应返回数据对象的属性\",\"title：表格列名\",\"copyable：是否允许复制\",\"ellipsis：是否允许缩略\",\"valueType：用于声明这一列的类型（dateTime、select等）\",\"修改后的用户管理界面\",\"import type { ActionType, ProColumns } from '@ant-design/pro-components'; import { ProTable, TableDropdown } from '@ant-design/pro-components'; import { Image } from 'antd'; import { useRef } from 'react'; import { searchUsers } from '@/services/ant-design-pro/api'; export const waitTimePromise = async (time: number = 100) => { return new Promise((resolve) => { setTimeout(() => { resolve(true); }, time); }); }; export const waitTime = async (time: number = 100) => { await waitTimePromise(time); }; // 定义列对应后端字段 const columns: ProColumns<API.CurrentUser>[] = [ { title: '序号', dataIndex: 'id', valueType: 'indexBorder', width: 48, }, { title: '账号', dataIndex: 'userName', copyable: true, }, { title: '昵称', dataIndex: 'nickName', copyable: true, ellipsis: true, }, { title: '头像', dataIndex: 'avatar', render: (_, record) => ( <div> <Image src={record.avatar} width=\\\"80px\\\" height=\\\"80px\\\" /> </div> ), copyable: true, }, { title: '性别', dataIndex: 'gender', valueType: 'select', // 枚举字段 valueEnum: { 0: { text: '男', status: 'Success' }, 1: { text: '女', status: 'Error' }, }, }, { title: '电话', dataIndex: 'phone', copyable: true, }, { title: '邮箱', dataIndex: 'email', copyable: true, }, { title: '状态', dataIndex: 'status', valueType: 'select', // 枚举字段 valueEnum: { 0: { text: '正常', status: 'Success' }, 1: { text: '注销', status: 'Default' }, 2: { text: '封号', status: 'Error' }, }, }, { title: '角色', dataIndex: 'userRole', valueType: 'select', valueEnum: { 0: { text: '普通用户', status: 'Default' }, 1: { text: '管理员', status: 'Success' }, }, }, { title: '创建时间', dataIndex: 'createTime', valueType: 'dateTime', }, { title: '操作', valueType: 'option', key: 'option', render: (text, record, _, action) => [ <a key=\\\"editable\\\" onClick={() => { action?.startEditable?.(record.id); }} > 编辑 </a>, <a href={record.url} target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" key=\\\"view\\\"> 查看 </a>, <TableDropdown key=\\\"actionGroup\\\" onSelect={() => action?.reload()} menus={[ { key: 'copy', name: '复制' }, { key: 'delete', name: '删除' }, ]} />, ], }, ]; export default () => { const actionRef = useRef<ActionType>(); return ( <ProTable<API.CurrentUser> columns={columns} actionRef={actionRef} cardBordered // 获取后端的数据，返回到表格 request={async (params = {}, sort, filter) => { console.log(sort, filter); const userList = await searchUsers(); return { data: userList }; }} editable={{ type: 'multiple', }} columnsState={{ persistenceKey: 'pro-table-singe-demos', persistenceType: 'localStorage', onChange(value) { console.log('value: ', value); }, }} rowKey=\\\"id\\\" search={{ labelWidth: 'auto', }} options={{ setting: { listsHeight: 400, }, }} form={{ // 由于配置了 transform，提交的参与与定义的不同这里需要转化一下 syncToUrl: (values, type) => { if (type === 'get') { return { ...values, created_at: [values.startTime, values.endTime], }; } return values; }, }} pagination={{ pageSize: 5, onChange: (page) => console.log(page), }} dateFormatter=\\\"string\\\" headerTitle=\\\"用户列表\\\" /> ); };\",\"构建完成后使用 http://localhost:8000/admin/user-manage 访问。\",\"会发现无权访问，对比 routes.ts 中上面的 /user 路径，会发现 /admin 多了权限校验 access: 'canAdmin'，只有管理员才能够访问用户管理页。而 access 字段设置在 access.ts 文件中，修改权限校验如下：\",\"再次访问即可：\"]},\"593\":{\"c\":[\"项目\"]},\"594\":{\"c\":[\"用户中心\"]},\"595\":{\"h\":\"第五期 - 末\",\"t\":[\"用户中心笔记第五期 - 末\"]},\"596\":{\"h\":\"用户注销\",\"t\":[\"在 Controller 层 添加用户注销接口 UserController：\",\"/** * 用户注销 * @param request 请求对象 * @return 结果 */ @PostMapping(\\\"/logout\\\") public Integer userLogout(HttpServletRequest request) { if (request == null) { return -1; } return userService.userLogout(request); }\",\"在 Service 层实现接口 UserServiceImpl：\",\"/** * 用户注销实现 * @param request 请求对象 * @return 结果 */ @Override public Integer userLogout(HttpServletRequest request) { request.getSession().removeAttribute(USER_LOGIN_STATE); // TODO: 先暂时返回 1，后期再做修改 return 1; }\",\"前端用户退出，在 /components/RightContent/AvatarDropdown.tsx 文件中找到 loginOut 函数，其中调用了 outLogin 接口，进行修改：\",\"/** 退出登录接口 POST /api/user/logout */ export async function outLogin(options?: { [key: string]: any }) { return request<Record<string, any>>('/api/user/logout', { method: 'POST', ...(options || {}), }); }\"]},\"597\":{\"h\":\"后端优化\"},\"598\":{\"h\":\"通用返回对象\",\"t\":[\"目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败。\",\"自定义错误码（200、404、500、502、503），返回类支持返回正常和错误\",\"为了能够更加精准知道报错的信息，一般格式为：\",\"{ \\\"code\\\": \\\"string\\\", \\\"data\\\": { \\\"id\\\": \\\"\\\", ... }, \\\"msg\\\": \\\"\\\" }\"]},\"599\":{\"h\":\"封装全局异常处理器\",\"t\":[\"定义业务异常类\",\"相对于 java 的异常类，支持更多字段 自定义构造函数，更灵活 / 快捷的设置字段\",\"编写全局异常处理器\",\"作用： 捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 / 信息 同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态） 集中处理，比如记录日志\",\"实现： Spring AOP：在调用方法前后进行额外的处理\",\"todo：全局请求日志和登录校验\"]},\"600\":{\"h\":\"前端优化\"},\"601\":{\"c\":[\"项目\"]},\"602\":{\"c\":[\"用户中心\"]},\"603\":{\"h\":\"第六期 - 线上部署\",\"t\":[\"用户中心笔记第六期 - 线上部署\"]},\"604\":{\"h\":\"多环境\"},\"605\":{\"h\":\"项目部署\"},\"606\":{\"h\":\"原始部署\"},\"607\":{\"h\":\"宝塔 Linux 部署\"},\"608\":{\"h\":\"Docker 容器部署\"},\"609\":{\"h\":\"绑定域名\"},\"610\":{\"h\":\"跨域问题\"},\"611\":{\"c\":[\"项目\"]},\"612\":{\"c\":[\"用户中心\"]},\"613\":{\"h\":\"布隆过滤器在项目中的使用\",\"t\":[\"使用 布隆过滤器 快速判断某个元素是否在集合中出现了，可以用于解决 缓存穿透 的问题。\",\"布隆过滤器提供一组 哈希函数 h1, h2, ..., hk，对需要存储的数据使用哈希函数计算得到 k 个哈希值，将 BitMap 中这 k 个位置都设置为 1，如果这 k 个位置都是 1，则 可能 在集合中，但是如果都不是 1，则 一定不在 集合中。\",\"因此布隆过滤器会出现 误判 问题，可能将不在集合中的元素判断为在集合中，解决方法之一是可以通过 增加数组长度 来降低误判率。\",\"缓存穿透： 请求的数据在数据库中不存在，因此数据也不会在缓存中，每次请求都不会命中缓存，而是打到数据库上，也就是直接穿过缓存打到数据库中，导致数据库压力很大甚至崩溃，这就是缓存穿透。\",\"那么缓存穿透的话，可以使用 Redis 的 布隆过滤器 来解决：下载 RedisBloom 插件，该插件是 Redis 的布隆过滤器模块，下载之后在 Redis 的 conf 文件中配置之后即可使用\",\"具体解决缓存穿透的场景，比如： 用户注册场景 ，如果系统用户量很大，在用户注册的时候，需要判断用户的用户名是否重复，初始将用户名的信息都初始化在布隆过滤器中，那么在用户注册时，先去布隆过滤器中快速进行判断用户名是否已经被使用，如果经过 k 次哈希计算发现这 k 次哈希值的位置上都为 1，说明 该用户名可能已经被使用了 ，用户注册用户名重复的话，大不了就换一个用户名就好了，这种情况是可以容忍的，之后用户注册成功之后，再将注册成功的用户名也放入的布隆过滤器中，这样在 用户注册时可以通过布隆过滤器快速判断用户名是否重复。\",\"上边说了布隆过滤器可能存在 误判 的情况，误判是可以容忍的，但是布隆过滤器解决缓存穿透还存在另外一个缺点：无法删除元素。\",\"无法删除元素 会导致如果用户注销帐号了，那么该用户名是无法从布隆过滤器中删除的，因此会导致其他用户也无法注册这个用户名，可以考虑再添加一层 Redis 缓存 来存储已经注销的用户名，同时如果注销的用户名较多的话，可能存在 大 key 问题 ，可以考虑分片存储来解决。\",\"这里总结一下如何通过 布隆过滤器解决缓存穿透：\",\"首先将用户名都初始化在布隆过滤器中，用户注册的时候通过 布隆过滤器 快速判断该用户名是否已经被使用了，系统可以容忍一定的误判率，对于布隆过滤器无法删除元素这个缺点，添加一层 Redis 缓存，将已经注销的用户名放在这个 Redis 中的 set 里，这样就可以解决布隆过滤器无法删除元素的缺点了，不过如果注销用户名多了，可能会存在大 key 问题，因此要考虑 分片存储 解决大 key 问题，也可以从业务角度上，限制每个用户注销的次数。\",\"最后再说一下布隆过滤器中容量的计算：\",\"先说一下各个参数的含义：\",\"m： 布隆过滤器中二进制 bit 数组的长度\",\"n： 需要对多少个元素进行存储，比如说我们要存储 1000 万个用户名，那么 n=1000 万\",\"p： 期望的误判率，可以设置 p=0.001(0.1%) 或者 p=0.0001(0.01%)\",\"m=(ln2)2n×lnp​\",\"将 n、p 带入上述公式即可计算出来理想情况下布隆过滤器的二进制数组的长度，也可以根据此公式算出来存储这么多元素大概需要占用多少内存空间，比如需要存储 10 亿个用户名，期望误判率为 0.001，也就是将 n=10 亿、p=0.001 带入，得到 m 约为 1.67GB ，因此这个布隆过滤器大约占用 1.67GB 的空间（可以搜索在线布隆过滤器容量计算）\"]},\"614\":{\"c\":[\"项目\"]},\"615\":{\"c\":[\"用户匹配系统\",\"布隆过滤器\"]},\"616\":{\"h\":\"2024.11 期\"},\"617\":{\"h\":\"11.30\",\"t\":[\"更快、更稳、更优，揭秘火山引擎全站加速 DCDN 规模容器化最佳实践\",\"字节跳动基于 Ray 的大规模多模态数据处理框架\"]},\"618\":{\"h\":\"11.29\",\"t\":[\"详解 Apache ShardingSphere 的架构和原理\",\"B站创作端接入自研剪辑引擎\",\"大模型加持下的Linux操作系统开发和自动化维护实践\",\"Prometheus在B端门店回收系统中的应用\"]},\"619\":{\"h\":\"11.28\",\"t\":[\"性能提升 2000%！揭秘 MyBatis-Plus 批量插入的终极优化技巧\"]},\"620\":{\"h\":\"11.27\",\"t\":[\"10 个系统设计中的取舍\"]},\"621\":{\"h\":\"11.26\",\"t\":[\"​B 站基于 Iceberg 的流批一体的探索和实践\",\"10 倍性能提升， GraalVM 应用可观测实践\"]},\"622\":{\"h\":\"11.25\",\"t\":[\"从零开始了解推荐系统全貌\",\"转转度量平台技术建设实践\",\"QCon演讲实录|赵彦奇：HTTPDNS 边缘下沉，性能、成本和稳定性之间的取舍与思考\"]},\"623\":{\"h\":\"11.23\",\"t\":[\"23 种设计模式详解（全23种）\"]},\"624\":{\"h\":\"11.21\",\"t\":[\"vivo 企业云盘服务端实现简介\"]},\"625\":{\"h\":\"11.20\",\"t\":[\"转转技术：亿级高性能通知系统实践\",\"什么才是架构师的真内核？\"]},\"626\":{\"h\":\"11.18\",\"t\":[\"Java方法设计原则与实践：从Effective Java到团队案例\"]},\"627\":{\"h\":\"11.16\",\"t\":[\"B站直播S14保障全解析：高效保障技术实践\"]},\"628\":{\"h\":\"11.13\",\"t\":[\"【提效】docker镜像构建优化-提速10倍\"]},\"629\":{\"h\":\"11.12\",\"t\":[\"被问懵了，加密后的数据如何进行模糊查询？- 芋道源码\"]},\"630\":{\"h\":\"11.11\",\"t\":[\"腾讯文档在线表格卡顿指标探索之路 - 腾讯技术工程\"]},\"631\":{\"h\":\"11.9\",\"t\":[\"没有实际的高并发经验，面试如何吹一波牛？\"]},\"632\":{\"h\":\"11.8\",\"t\":[\"京东面试：亿级黑名单 如何设计？亿级查重 呢？（答案含：布隆过滤器、布谷鸟过滤器）\",\"Java方法设计原则与实践：从Effective Java到团队案例 - 京东云开发者社区\",\"电商库存系统的防超卖和高并发扣减方案 - 京东云开发者社区\"]},\"633\":{\"h\":\"11.7\",\"t\":[\"揭秘JDQ限流架构：实时数据链路的多维动态带宽管控|京东零售技术实践 - 京东技术\"]},\"634\":{\"h\":\"11.6\",\"t\":[\"短链文章：\",\"一个企业级高并发短链接服务项目分享_牛客网\",\"京东短网址高可用提升最佳实践\",\"[万字长文] 系统设计之路：如何设计一个URL短链服务\",\"字节二面：100Wqps短链系统，如何设计？ - 疯狂创客圈 - 博客园\",\"腾讯女后端设计了一套短链系统，当场就想给她 offer！\",\"不错的短链接产品：\",\"小码短连接：支持分析报表、分组管理、自定义域名、API 对接等功能。地址：小码至营官网 - 小码短链接、小码公众号助手\",\"魔众短连接：支持分析报表，短连接有效期设置、API 对接等功能的短链接系统。地址：魔众短链接系统 | 魔众软件 。\",\"相关项目和教程推荐：\",\"马哥的 SaaS 短链接系统，采用最新 JDK17 + SpringBoot3&SpringCloud 微服务架构：shortlink: 🔥 热门推荐 🔥 SaaS 短链接系统，承载高并发和海量存储等场景难题\",\"一个基于 Spring Boot + MyBatis + + Redis + Hutool + Thymeleaf 开发的短链系统：GitHub - Naccl/ShortURL: 🔗 短链接生成器，长网址转短网址\"]},\"635\":{\"h\":\"11.4\",\"t\":[\"再也不用心惊胆战地使用 FastJSON 了 —— 序列化篇 - 阿里云开发者\"]},\"636\":{\"h\":\"11.1\",\"t\":[\"走进京东零售广告研发部：大模型时代下的新一代广告系统 - 京东技术\"]},\"637\":{\"c\":[\"文章\"]},\"638\":{\"h\":\"2024.12 期\",\"t\":[\"数仓建设保姆级5W字教程，离线实时一网打尽（理论+实战）\"]},\"639\":{\"h\":\"12.11\",\"t\":[\"火山引擎 ByteHouse：湖仓一体架构的创新与实践\",\"转转数仓评估体系实践\",\"MQ消息乱序问题解析与实战解决方案\",\"别再自己瞎写工具类了，Spring Boot 内置工具类应有尽有\",\"优雅掌握 SpringBoot 多租户架构，轻松驾驭复杂业务场景\"]},\"640\":{\"h\":\"12.10\",\"t\":[\"【Calcite】Apache Calcite 框架初探及概念详解\"]},\"641\":{\"h\":\"12.9\",\"t\":[\"Presto简介、部署、原理和使用介绍\"]},\"642\":{\"h\":\"12.8\",\"t\":[\"数据仓库之MPP架构&分布式架构\"]},\"643\":{\"h\":\"12.7\",\"t\":[\"奇淫巧技，CompletableFuture 异步多线程是真的优雅\",\"深入 ReentrantLock 内部：公平锁与非公平锁之奥秘\"]},\"644\":{\"h\":\"12.6\",\"t\":[\"漫谈数仓『OLAP』\"]},\"645\":{\"h\":\"12.5\",\"t\":[\"10分钟入门Flink -- 了解Flink\",\"干货｜在抖音集团，存储实时数仓这样建\",\"货拉拉大数据元数据管理体系演进和实践\"]},\"646\":{\"h\":\"12.4\",\"t\":[\"OAuth 2.0 的一个简单解释\",\"OAuth 2.0 的四种方式\"]},\"647\":{\"h\":\"12.3\",\"t\":[\"逻辑数据平台的 NoETL 之道（内含Q&A）\",\"一文详解物化视图改写\"]},\"648\":{\"h\":\"12.2\",\"t\":[\"实战：单点登录（SSO）如此简单\"]},\"649\":{\"h\":\"12.1\",\"t\":[\"【点个赞吧】 - B站千亿级点赞系统服务架构设计\",\"微博架构组面试：类微博点赞系统设计\"]},\"650\":{\"c\":[\"文章\"]},\"651\":{\"h\":\"阅读历史\"},\"652\":{\"h\":\"往期回顾\",\"t\":[\"2024.12 期\",\"2024.11 期\"]},\"653\":{\"h\":\"10.30\"},\"654\":{\"c\":[\"文章\"]},\"655\":{\"h\":\"电子书\",\"t\":[\"剑指 OFFER - 名企面试官精讲典型编程题(第2版)\"]},\"656\":{\"c\":[\"书籍\"]},\"657\":{\"c\":[\"电子书\"]},\"658\":{\"h\":\"相关插件\",\"t\":[\"我做了一款vuepress的音乐可视化播放插件\",\"vuepress-plugin-player\",\"Vuepress 音乐播放器 & 沉浸式 源码：RayShineHub.github.io\",\"搭建 VuePress 博客，你可能会用到的一些插件\",\"博客搭建系列 - 冴羽\",\"Markdown 数学符号大全\"]},\"659\":{\"c\":[\"工具搭建\"]},\"660\":{\"c\":[\"教程\"]},\"661\":{\"h\":\"科学上网与本地代理\",\"t\":[\"为了某些学习目的，访问国外的一些优秀网站速度会很慢，甚至无法访问，无法查阅到想要的“资料”。\",\"在这种时候就可能需要一些代理手段，帮助我们更科学地上网📶。\",\"常见的有 ByWave 和 Clash，都是挺不错的选择，流量包推荐 性价比机场.com，详情请自行了解。\",\"当然，如果比较感兴趣、喜欢动手的朋友，也可以自己搭建一个代理服务（只能自己偷偷用哦，不然要被请去喝茶了）。\"]},\"662\":{\"h\":\"如何自建代理服务\",\"t\":[\"注意\",\"以下方案需要准备两台服务器，一台国内，一台国外，并且需要对 Linux运维 和 采购云服务器 有一定的熟练度。\",\"准备一台 海外服务器，假设名为 服务器A（IP 为 123.123.123.123），并设置安全组开放 10123 端口（开放端口很重要，同时也很危险，详见 放行端口的步骤）。\",\"然后在 服务器A 上搭建 v2ray 服务，跟着说明文档配置，并设置端口为 10123。如果步骤没问题，你将会获得一些配置参数和 v2ray 协议链接。\",\"然后下载一个 代理客户端，并把协议链接录入测试 123.123.123.123.10123 的代理服务是否可用。\",\"相关信息\",\"海外服务器的采购可以使用 阿里云 等国内厂商没有问题，但依然推荐一些国外厂商的云主机，比如 硅云，也可以去找一些小众更便宜的云服务器提供商。\",\"服务器地点一般选择 香港、新加坡 等靠近国内的延迟会比较低。\"]},\"663\":{\"h\":\"放行端口的步骤\",\"t\":[\"以阿里云服务器为例，版本为 CentOS 7.x，首先设置安全组，添加 10123 端口为公开：\",\"然后还要在服务器上，开启防火墙并开放指定端口：\",\"查看防火墙状态并开启\",\"systemctl status firewalld\",\"如果是 active(dead) 就表示停止，需要开启防火墙\",\"systemctl start firewalld\",\"开放指定端口\",\"firewall-cmd --zone=public --add-port=10123/tcp --permanent\",\"参数解释\",\"参数\",\"注释\",\"–zone=public\",\"作用域，公开的\",\"–add-port=10123/tcp\",\"添加端口，格式为：端口/通讯协议\",\"–permanent\",\"永久生效，没有此参数重启后失效\",\"重启防火墙\",\"firewall-cmd --reload\",\"查看端口号命令\",\"查看端口是否放行成功\",\"firewall-cmd --list-all # 查看防火墙规则 或者 firewall-cmd --list-ports # 查看防火墙端口\",\"查看当前所有 tcp 端口信息\",\"netstat -ntlp\",\"查看 10123 端口使用情况\",\"netstat -ntulp | grep 10123\",\"测试端口是否能连接上\",\"打开：https://tcp.ping.pe/\",\"写上 IP 地址和端口，内容为 ip:端口，示例：123.123.123.123:10123，然后点击 Go 或者直接回车\",\"如果显示 successful，证明端口能连接；如果显示 failed，那就是无法连接上端口。\",\"更简单的办法\",\"正常来说，上面这些步骤执行后，端口一般都能连接上，如果使用上述地址测试后仍然无法连接，可能还存在外部防火墙没关或者端口放行方向不正确等问题。\",\"为了更方便地管理防火墙和端口规则，推荐使用宝塔面板来操作。\",\"配置好宝塔后，找到 安全 界面，添加端口规则，输入 10123 端口点击确定，其他保持默认即可。\"]},\"664\":{\"h\":\"保护你的代理服务器\",\"t\":[\"注意\",\"如果你已经自建代理服务并用起来了，但是别开心的太早，因为 123.123.123.123 的 IP 可能过几天就会被 GFW 扫描并封禁。 虽然你可以更换 IP ，但是这毕竟很麻烦，而且并不安全，而且更换 IP 会产生一定的费用。 这个时候你需要采用如下做法来保护你的海外服务器以及 IP。\",\"再准备一台国内的服务器，假设名为 服务器B（IP为 456.456.456.456），并设置安全组开放 20456 端口。\",\"在 服务器B 中安装 Nginx 并添加如下配置：\",\"stream { upstream v2ray { server 123.123.123.123:10123; } server { listen 20456; proxy_pass v2ray; ssl_preread on; } }\",\"配置解释\",\"这一步的意思是：将 国内服务器B 中来自 20456 端口的请求全部转发给 国外服务器A 的 10123 端口。\",\"打开 代理客户端 的设置界面，将 123.123.123.123.10123 代理服务修改为 456.456.456.456.20456。然后测试代理服务是否可用。示例配置在 本地代理客户端\",\"详情\",\"这一步的意思是，在其它设置不变的情况下，将原本的 服务器A 的地址和端口换成 服务器B 的。\",\"到这一步之后，你每次使用代理客户端时，实际上全都是在请求国内的服务器，这时 GFW 的扫描不会发觉任何异常，也无法封禁国内 IP。\",\"修改 服务器A 的安全组，在宝塔上配置，让 10123 端口只允许 IP 为 456.456.456.456 的机器访问。\",\"详情\",\"到这一步之后 GFW 扫描 服务器A 就不会发现任何异常，毕竟这个端口的安全组会阻拦 GFW 的访问，表面看它就是一个平平无奇的服务器而已。 然后国内的 服务器B 本身就在国内，不受 GFW 约束。\",\"日常的代理客户端，只会被抓到它在请求国内服务器，则 IP 地址安全。\",\"当然，两台服务的成本确实会有点点高，实测这种方案最为安全和稳定。\"]},\"665\":{\"h\":\"本地代理客户端\",\"t\":[\"https://github.com/v2rayU/v2rayU\",\"Windows：https://github.com/2dust/v2rayn/releases 下载 v2rayN-With-Core.zip 和 v2rayN.zip 并解压，然后将前者目录中的内容覆盖替换到后者目录中，然后就可以双击 v2rayN.exe 文件进行使用了。\",\"Android：https://github.com/2dust/v2rayNG/releases 下载对应的 apk 文件安装即可。如果打不开或安装失败就多换几个安装包试试。\",\"MacOS：https://github.com/yanue/V2rayU/releases 下载对应的 .dmg 文件安装即可。如果打不开或安装失败就多换几个安装包试试。\",\"Windows 客户端配置如下：\",\"找到「服务器」菜单，点击 添加[VMess]服务器\",\"输入代理的 IP 和端口，像上面我们配置了请求转发，那这里就填 国内服务器B 的配置，然后点击生成用户 ID，最后点击确定。\",\"确定后就会自动开始代理服务了。然后系统代理选择 自动配置系统代理（这样就不用到设置里面配置代理了），路由选择 绕过大陆（这样如果国内能访问就优先用国内线路，访问不了再用代理线路）。\",\"因为我自己有加速器，科学上网的需求也不是很高，所以用的国外服务器配置很一般，网速有点慢🤣.\",\"客户端配置\",\"本地已自动配置\"]},\"666\":{\"c\":[\"工具搭建\"]},\"667\":{\"c\":[\"教程\"]},\"668\":{\"h\":\"自建网盘兼图床\",\"t\":[\"网盘 ByteCloud：https://cloud.braumace.cn\",\"继自建博客之后，需要展示图片，使用了一段时间 七牛云 + CDN 加速，前阵子出现了各大知名博主 CDN 流量被盗刷事件，不禁有点害怕。\",\"再加上文件放在云存储上，毕竟是公家的，文件上传都会被扫描一遍，毫无隐私可言，万一想存点嘿嘿的东西，那怎么办呢？而且公有云存储的存储有限，其次安全性和稳定性也不能一直保证，毕竟是放在别人家里，别人未必会帮你好好保存。\",\"于是利用之前学过的，用 MinIO 在服务器上搭建了一个对象存储服务，可以在网页端上传和下载文件，但很快发现，它仅仅只能用来存储，不能实现外部的访问。比如我想实现一个图床，其自身并不能提供一个外部链接，供所有人访问。\",\"其实解决方法也有，MinIO 提供了 SDK 和 API，可以给第三方调用，配合 Typora 或 PicGo 使用，也有很不错的效果，详情可自行百度。\",\"这里我结合日常使用习惯和需要，选择使用 Cloudreve。\"]},\"669\":{\"h\":\"什么是 Cloudreve\",\"t\":[\"Cloudreve 是一个支持多家云存储驱动的公有云文件系统，可助你即刻构建出兼备自用或公用的网盘服务，以跨平台、多用户、多存储节点、存储无关的方式，通过多种存储策略的支持、虚拟文件系统等特性实现灵活的文件管理体验。\",\"具有非常多的功能，可以分布式部署，集成了多家云存储端，既可以将文件存储在本地，也可以存储在外部，实现无差别存取；可以创建外链分享文件以及目录；支持 WebDAV 协议，可以从多种设备和应用上访问等等，可以说 Cloudreve 完美满足了我所需要的功能。\"]},\"670\":{\"h\":\"搭建过程\",\"t\":[\"根据 官方文档，快速部署。\",\"在 GitHub Release 中下载已构建打包好的压缩包，选择 linux_amd64.tar.gz 版本。\",\"直接放上压缩包（它真的太方便了）：cloudreve_3.8.3_linux_amd64.tar.gz\",\"转到下载的文件夹目录，解压并启动。\",\"#解压获取到的主程序 tar -zxvf cloudreve_3.8.3_linux_amd64.tar.gz # 赋予执行权限 chmod +x ./cloudreve # 启动 Cloudreve ./cloudreve\",\"启动后如下图所示：\",\"Cloudreve 在首次启动时，会创建初始管理员账号（上图黄色部分），请注意保管管理员密码，此密码只会在首次启动时出现。如果忘记了初始管理员密码，需要删除同级目录下的 cloudreve.db，重新启动主程序以初始化新的管理员账户。\",\"启动后 Cloudreve 默认会监听 5212 端口，此时可以在浏览器中访问 http://服务器IP:5212，输入管理员账号密码进入 Cloudreve。\",\"其实到这一步，这个网盘就已经搭建完成可以使用了。下面是一些个人配置。\",\"右上角「个人 - 管理面板」，配置站点信息\",\"配置存储策略\",\"本机存储 即存储在安装 Cloudreve 的机器上，从机存储 用于配置分布式存储，另外也提供了常见的云存储供应商选项，可以将文件存储在第三方，通过 Cloudreve 访问。\",\"配置存储策略：存储目录为 Cloudreve 安装路径下的相对路径，也可以是机器的绝对路径。存储路径和文件名都可以使用 魔法变量，非常方便。\",\"最重要的是配置直链，开启后每个文件都会生成一个链接，允许外部访问，而且长度很短，只要不删除就能一直保留。有需要的话也可以配置 CDN 域名加速访问。\",\"开启直链后的效果如下，任何一个文件都可以拥有一个外链，且不随文件位置的改变而变化，只与文件名有关。\",\"这样就实现了一个图床的效果。\",\"后面配合 WebDAV，在本地保存图片后，云端生成外链使用，并且图片如果有修改，只要文件名不变，外链也不用改。\",\"后面的配置自行设置即可。新添加一个存储策略时采用的是 向导模式编辑，后续可以通过 专家模式 进行更详细的配置。\",\"在用户组里面，可以指定用户使用的存储策略和可用的最大容量，以及下载限速（当然不建议这么做）、创建分享链接等等。默认的下载不限速，下载速度只和机器自身的性能相关。\",\"如果不想用默认创建的管理员账号密码，可以进行修改。\"]},\"671\":{\"h\":\"配置进程守护\",\"t\":[\"什么是守护进程：深入理解守护进程：守护进程干嘛的？\",\"相关信息\",\"守护进程（Daemon）：是一类在后台运行的系统服务进程，而不是在交互式用户界面下运行的进程。它们通常在系统启动时启动，并持续运行以提供某种服务或执行特定任务。守护进程独立于任何终端会话，通常不接受用户输入，而是通过系统的事件驱动或定时器来执行任务。\",\"Linux 系统有很多守护进程，大多数服务都是用守护进程实现的。例如常见的常见的守护进程包括系统日志进程 syslogd、 Web 服务器 httpd、邮件服务器 sendmail 和数据库服务器 mysqld 等。\",\"为什么要配置进程守护呢？\",\"因为我们的 Cloudreve 作为一个网盘，相当于是一个文件服务器，其要求一定是能稳定运行，这样我们才能随时随地使用它。如果不将它注册为一个进程，进行进程守护，万一服务器突然宕机或停电等，我们的网盘服务将变得不可用。\",\"注意\",\"从前面使用 ./cloudreve 命令启动服务可以看出，其实 Cloudreve 默认启动方式是前台启动，好处是可以提供即时的交互体验和日志查看，但坏处是它会占用大量的系统资源，除非关闭否则无法使用其他 Linux 命令、无法使用其他应用程序，且运行不稳定，容易受到干扰而崩溃停止。\",\"所以需要将 Cloudreve 注册为一个进程，设置开机自动启动，当服务器宕机后恢复也能够重启服务。\",\"官方文档中提供了两种配置进程守护的方法，分别是 Systemd 和 Supervisor。\",\"Systemd 是Linux 自带的系统和服务管理器，常见命令以 systemctl 开头。\",\"Supervisor 是一个轻量级的进程管理工具，推荐搭配宝塔面板使用，效果更好。\",\"这里我使用 Systemd 配置进程守护：\",\"创建配置文件\",\"vim /usr/lib/systemd/system/cloudreve.service\",\"将下面代码粘贴到配置文件中，并将下文 PATH_TO_CLOUDREVE 更换为程序所在目录\",\"[Unit] Description=Cloudreve Documentation=https://docs.cloudreve.org After=network.target After=mysqld.service Wants=network.target [Service] WorkingDirectory=/PATH_TO_CLOUDREVE ExecStart=/PATH_TO_CLOUDREVE/cloudreve Restart=on-abnormal RestartSec=5s KillMode=mixed StandardOutput=null StandardError=syslog [Install] WantedBy=multi-user.target\",\"更新配置并设置开机启动\",\"# 更新配置 systemctl daemon-reload # 启动服务 systemctl start cloudreve # 设置开机启动 systemctl enable cloudreve\",\"管理命令：\",\"# 启动服务 systemctl start cloudreve # 停止服务 systemctl stop cloudreve # 重启服务 systemctl restart cloudreve # 查看状态 systemctl status cloudreve\"]},\"672\":{\"h\":\"配置站点 URL 及免费 HTTPS\",\"t\":[\"先去阿里云服务器配置 域名解析DNS，添加记录，填写想配置的「二级域名」，再填写「服务器 IP 地址」即可。\",\"再去 阿里云数字证书管理服务 申请免费的 SSL 证书。\",\"原「免费证书」已经换成了「个人测试证书」，点击「创建证书」。\",\"输入想要配置的域名，勾选「快捷签发」，第一次申请的时候要填个人信息，签发速度会比较慢，大概 1 个小时，后面再申请的时候就很快了，10 分钟左右就能批下来。\",\"得到 SSL 证书后，下载证书，选择服务器类型为 Nginx。\",\"解压后将 pem 和 key 文件上传至 Linux 服务器，建议放在 Nginx 目录下，然后修改 Nginx 的配置文件 nginx.conf。\",\"提示\",\"使用 Linux 命令安装的 Nginx，默认路径在 /usr/nginx/\",\"而使用宝塔面板安装的 Nginx，默认路径在 /www/server/panel/vhost/nginx\",\"可以通过查看 nginx 的运行进程，显示 nginx 的 安装目录\",\"ps -aux | grep nginx\",\"在 nginx.conf 中添加如下配置：\",\"http { server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name cloud.braumace.cn; # 指定域名 root /usr/share/nginx/html; ssl_certificate /etc/pki/nginx/cloud.braumace.cn.pem; # pem存放路径 ssl_certificate_key /etc/pki/nginx/cloud.braumace.cn.key; # key存放路径 ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers PROFILE=SYSTEM; ssl_prefer_server_ciphers on; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://127.0.0.1:5212; # 本地访问端口 # 如果要使用本地存储策略，请将下一行注释符删除，并更改大小为理论最大文件尺寸 client_max_body_size 20000m; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } }\",\"最后在 Cloudreve 管理面板，「站点信息」里面配置站点 URL 为 https://cloud.braumace.cn 即可。\"]},\"673\":{\"h\":\"配置 WebDAV\"},\"674\":{\"h\":\"什么是 WebDAV\",\"t\":[\"WebDAV 是一种基于 HTTP 协议的文件传输协议，如今有许多第三方文件管理器、视频播放器等产品都支持通过 WebDAV 协议访问 Cloudreve 中的文件，可以借此实现跨平台的文件共享与同步。\",\"简单来说，WebDAV 就像一个存储服务，各种应用都可以连接到它，允许应用直接访问我们的云盘内容，对其进行读写操作。\"]},\"675\":{\"h\":\"Cloudreve 使用 WebDAV\",\"t\":[\"Cloudreve 要使用 WebDAV，要先在后台管理面板为对应用户组开启 WebDAV 使用权限。WebDAV 所使用的账号与 Cloudreve 账号并不互通，需要单独创建。\",\"再前往前台 「导航左侧 - 连接 - 创建新账号」 创建供 WebDAV 使用的账号信息。创建完成后系统会为此账号自动生成密码，得到 WebDAV 的连接地址，密码则为系统所生成的密码。\",\"创建 WebDAV 账号时，可以为此账号指定相对根目录，此账号只能通过 WebDAV 访问所指定相对根目录下的目录及文件。\"]},\"676\":{\"h\":\"Windows 使用 WebDAV\",\"t\":[\"在上方菜单中，找到「计算机 - 映射网络驱动器」，点击添加。\",\"指定驱动器号，将 Cloudreve 系统生成的连接地址填入，点击「完成」再填入账号和生成的密码。\",\"连接成功后如下所示：\",\"这样就实现了无感知地调用，可以像操作本地磁盘一样操作网盘了，包括文件的读取、存储，第三方平台对文件的读取保存都和本地一模一样。 （不过存储空间是映射的本地 C 盘的，应该是 Windows 本身的 WebDAV 不支持，获取不到实际的存储大小）\"]},\"677\":{\"c\":[\"工具搭建\"]},\"678\":{\"c\":[\"教程\"]},\"679\":{\"h\":\"K 个一组翻转链表\",\"t\":[\"25.K个一组翻转链表\"]},\"680\":{\"h\":\"题意\",\"t\":[\"给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\",\"k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\",\"你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\"]},\"681\":{\"h\":\"思路\",\"t\":[\"输入 head，reverseKGroup() 能够把以 head 为头的这条链表进行翻转。\",\"我们要充分利用这个递归函数的定义，把原问题分解成规模更小的子问题进行求解。\",\"先反转以 head 开头的 k 个元素\",\"将第 k + 1 个元素作为 head 递归调用 reverseKGroup()\",\"将上述两个过程的结果连接起来，返回头结点即可\"]},\"682\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; // 区间 [a, b) 包含 k 个待反转元素 ListNode a, b; a = b = head; for (int i = 0; i < k; i++) { // 不足 k 个，不需要反转 if (b == null) return head; b = b.next; } // 反转前 k 个元素 ListNode newHead = reverse(a, b); // 递归反转后续链表并连接起来 a.next = reverseKGroup(b, k); return newHead; } // 反转区间 [a, b) 的元素，注意是左闭右开 ListNode reverse(ListNode a, ListNode b) { ListNode pre, cur, nxt; pre = null; cur = a; nxt = a; // while 终止的条件改一下 while (cur != b) { nxt = cur.next; cur.next = pre; pre = cur; cur = nxt; } // 返回反转后的头结点 return pre; } }\"]},\"683\":{\"c\":[\"hot100\",\"数据结构\"]},\"684\":{\"c\":[\"链表\",\"递归\"]},\"685\":{\"h\":\"LRU 缓存\",\"t\":[\"146.LRU缓存\"]},\"686\":{\"h\":\"题意\",\"t\":[\"请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。\",\"实现 LRUCache 类：\",\"LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\",\"int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\",\"void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\",\"函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\"]},\"687\":{\"h\":\"思路一：手搓 LRU\",\"t\":[\"要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：\",\"显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。\",\"我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；\",\"每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。\",\"哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢，所以结合二者的长处，可以形成一种新的数据结构：哈希链表 LinkedHashMap：\",\"至于 put 和 get 的具体逻辑，可以画出这样一个流程图：\",\"根据上述逻辑写代码即可。\",\"代码：\",\"class LRUCache { int cap; LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!cache.containsKey(key)){ return -1; } makeRecently(key); return cache.get(key); } public void put(int key, int value) { if (cache.containsKey(key)){ cache.put(key, value); makeRecently(key); return; } if (cache.size() >= this.cap){ int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } cache.put(key, value); } private void makeRecently(int key) { int val = cache.get(key); cache.remove(key); cache.put(key, val); } }\"]},\"688\":{\"h\":\"思路二：继承\",\"t\":[\"参考题解：源于 LinkedHashMap 源码\",\"主体：继承 LinkedHashMap，然后重写其中的 removeEldestEntry() 函数，就能拥有我们自己的缓存策略。\",\"重写的条件是 map 的大小不超过给定的容量，超过了就得使用 LRU。\",\"put 操作直接继承父类的 put函数即可，因为题目没有特殊要求，故可以不写。\",\"get 操作可以调用 LinkedHashMap 中的 getOrDefault()，符合题目要求，即当 key 不存在时会返回默认值 -1。\",\"综上分析，只要写一个构造函数即可。\",\"代码：\",\"class LRUCache extends LinkedHashMap<Integer, Integer> { private int capacity; public LRUCache(int capacity) { super(capacity, 0.75F, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } // 可写可不写 public void put(int key, int value) { super.put(key, value); } @Override protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) { return size() > capacity; } }\"]},\"689\":{\"c\":[\"hot100\",\"数据结构\"]},\"690\":{\"c\":[\"链表\"]},\"691\":{\"h\":\"两两交换链表中的节点\",\"t\":[\"24.两两交换链表中的节点\"]},\"692\":{\"h\":\"题意\",\"t\":[\"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\"]},\"693\":{\"h\":\"思路\",\"t\":[\"常规方法：维护多个指针，遍历一遍链表顺便把每两个节点翻转。\",\"递归方法：利用已有的函数，每两个一组进行递归处理。\"]},\"694\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode first = head; ListNode second = head.next; ListNode others = head.next.next; // 先把前两个元素翻转 second.next = first; // 利用递归，将剩下的链表节点两两翻转，接到后面 first.next = swapPairs(others); // 现在整个链表都成功翻转了，返回新的头节点 return second; } }\"]},\"695\":{\"c\":[\"hot100\",\"数据结构\"]},\"696\":{\"c\":[\"链表\"]},\"697\":{\"h\":\"两数相加\",\"t\":[\"2.两数相加\"]},\"698\":{\"h\":\"题意\",\"t\":[\"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\",\"请你将两个数相加，并以相同形式返回一个表示和的链表。\",\"你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\"]},\"699\":{\"h\":\"思路\",\"t\":[\"将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，比如 987 + 23 = 987 + 023 = 1010\",\"每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值\",\"如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1\",\"小技巧\",\"对于链表问题，返回结果为头结点时，通常需要先初始化一个虚拟头节点 dummp，该节点的下一个节点指向真正的头结点 head。\",\"使用虚拟头节点的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头节点丢失，无法返回结果。\"]},\"700\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode p1 = l1, p2 = l2; ListNode dummy = new ListNode(-1); // 虚拟头节点 ListNode p = dummy; int carry = 0; while (p1 != null || p2 != null || carry > 0) { // 先加上上次的进位 int val = carry; if (p1 != null) { val += p1.val; p1 = p1.next; } if (p2 != null) { val += p2.val; p2 = p2.next; } // 处理进位情况 carry = val / 10; val = val % 10; // 构建新节点 p.next = new ListNode(val); p = p.next; } return dummy.next; } }\"]},\"701\":{\"c\":[\"hot100\",\"数据结构\"]},\"702\":{\"c\":[\"链表\"]},\"703\":{\"h\":\"乘积最大子数组\",\"t\":[\"152.乘积最大子数组\"]},\"704\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\",\"测试用例的答案是一个 32-位 整数。\",\"子数组\",\"子数组：是数组中连续的 非空 元素序列。\"]},\"705\":{\"h\":\"思路\",\"t\":[\"遍历数组时计算当前最大值，不断更新\",\"令 mx 为当前最大值，则当前最大值为 mx = max(mx * nums[i], nums[i])\",\"由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值 mn = min(mn * nums[i], nums[i])\",\"当负数出现时则 mx 与 mn 进行交换再进行下一步计算\",\"代码：\",\"class Solution { public int maxProduct(int[] nums) { int max = Integer.MIN_VALUE, mx = 1, mn = 1; for (int i = 0; i< nums.length; i++){ if (nums[i] < 0){ int tmp = mx; mx = mn; mn = tmp; } mx = Math.max(mx * nums[i], nums[i]); mn = Math.min(mn * nums[i], nums[i]); max = Math.max(max, mx); } return max; } }\"]},\"706\":{\"c\":[\"hot100\",\"动态规划\"]},\"707\":{\"c\":[\"线性DP\"]},\"708\":{\"h\":\"二叉搜索树中第K小的元素\",\"t\":[\"230.二叉搜索树中第K小的元素\"]},\"709\":{\"h\":\"题意\",\"t\":[\"给定一个二叉搜索树的根节点 root，和一个整数 k，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。\"]},\"710\":{\"h\":\"思路\",\"t\":[\"利用二叉搜索树的重要性质：二叉搜索树的中序遍历为递增序列。\",\"也就是说，本题可被转化为求中序遍历的第 k 个节点。\",\"转化为求中序遍历的第k个节点\",\"使用 ans 记录并更新遍历到的节点，当 k = 0 时，返回即可。\",\"代码：\",\"class Solution { int k; int ans; void dfs(TreeNode root) { if (root == null) return; dfs(root.left); if (k == 0) return; if (--k == 0) ans = root.val; dfs(root.right); } public int kthSmallest(TreeNode root, int k) { this.k = k; dfs(root); return ans; } }\"]},\"711\":{\"h\":\"进阶\",\"t\":[\"如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\"]},\"712\":{\"h\":\"思路\",\"t\":[\"在前面的方法中，我们之所以需要中序遍历前 k 个元素，是因为我们不知道子树的结点数量，不得不通过遍历子树的方式来获知。为了优化算法，我们可以记录每个子树的结点数。对于每个结点，先记录左子树中的结点数 leftNodes，然后缩小查找第 k 小的元素的范围。\",\"判断：\",\"如果 leftNodes = k − 1，则当前结点值即为第 k 小的元素，返回当前结点值。\",\"如果 leftNodes > k − 1，则第 k 小的元素一定在左子树中，因此在左子树中寻找第 k 小的元素。\",\"如果 leftNodes < k − 1，则第 k 小的元素一定在右子树中，由于以当前结点为根结点的子树中的大于右子结点值的结点数等于 leftNodes + 1，因此在右子树中寻找第 k − leftNodes − 1 小的元素。\"]},\"713\":{\"h\":\"代码\",\"t\":[\"class Solution { // 左右子树返回信息只需要节点数，无需额外定义数据结构 public int countNodes(TreeNode root) { if(root == null) return 0; // 递归处理左右子树并接收返回值 int leftNodes = countNodes(root.left); int rightNodes = countNodes(root.right); // 判断分析本层递归返回值的具体值 return leftNodes + rightNodes + 1; } public int kthSmallest(TreeNode root, int k) { int leftNodes = countNodes(root.left); if (leftNodes < k - 1) { // 答案存在右子树中 return kthSmallest(root.right,k - leftNodes - 1); } else if (leftNodes == k - 1) { return root.val; } else { return kthSmallest(root.left,k); } } }\"]},\"714\":{\"c\":[\"hot100\",\"数据结构\"]},\"715\":{\"c\":[\"二叉树\",\"递归\"]},\"716\":{\"h\":\"二叉树中的最大路径和\",\"t\":[\"124.二叉树中的最大路径和\"]},\"717\":{\"h\":\"题意\",\"t\":[\"二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\",\"路径和 是路径中各节点值的总和。\",\"给你一个二叉树的根节点 root ，返回其 最大路径和 。\"]},\"718\":{\"h\":\"思路\"},\"719\":{\"h\":\"代码\"},\"720\":{\"c\":[\"hot100\",\"数据结构\"]},\"721\":{\"c\":[\"二叉树\",\"递归\",\"树形DP\"]},\"722\":{\"h\":\"二叉树展开为链表\",\"t\":[\"114.二叉树展开为链表\"]},\"723\":{\"h\":\"题意\",\"t\":[\"给你二叉树的根结点 root ，请你将它展开为一个单链表：\",\"展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。\",\"进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？\"]},\"724\":{\"h\":\"思路一：先序遍历\",\"t\":[\"如题，展开的顺序其实就是二叉树的先序遍历。先序遍历的访问顺序是 “根、左子树、右子树”，左子树最后一个节点访问完后，接着会访问根节点的右子树节点。\",\"将左子树插入到右子树的地方\",\"将原来的右子树接到左子树的最右边节点\",\"考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null.\",\"时间复杂度 O(n)，其中 n 是树中节点的个数。空间复杂度 O(1)。\",\"代码：\",\"class Solution { public void flatten(TreeNode root) { while (root != null) { if (root.left != null) { // 找到当前节点左子树的最右节点 TreeNode pre = root.left; while (pre.right != null) { pre = pre.right; } // 将左子树的最右节点指向原来的右子树 pre.right = root.right; // 将当前节点指向左子树 root.right = root.left; root.left = null; } root = root.right; } } }\"]},\"725\":{\"h\":\"思路二：递归\",\"t\":[\"尝试直接在原来的节点上改变指向，利用先序遍历的代码，每遍历一个节点，就将上一个节点的右指针更新为当前节点。\",\"发现，如果这样做，原本的右子树就丢失了。\",\"用递归的思维，要解决这个问题的话，可以逆过来进行。逆序遍历，每遍历一个节点就将当前节点的右指针更新为上一个节点。这样就不会有丢失子树的问题了，因为更新当前的右指针的时候，当前节点的右子树已经访问过了。\",\"即使用变形后的后序遍历，遍历顺序是 右子树->左子树->根节点。这里我们不再打印根节点，而是利用一个全局变量 pre，更新当前根节点的右指针为 pre，左指针为 null.\",\"代码：\",\"class Solution { TreeNode pre = null; public void flatten(TreeNode root) { if (root == null) return; flatten(root.right); flatten(root.left); root.right = pre; root.left = null; pre = root; } }\"]},\"726\":{\"c\":[\"hot100\",\"数据结构\"]},\"727\":{\"c\":[\"二叉树\"]},\"728\":{\"h\":\"二叉树的中序遍历\",\"t\":[\"94.二叉树的中序遍历\"]},\"729\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\",\"二叉树的 中序遍历: 从根节点开始，首先遍历左子树，然后访问根节点，最后访问右子树。然后在遍历左子树的时候，同样首先遍历左子节点的左子树，然后访问根节点，最后遍历左子节点的右子树...\"]},\"730\":{\"h\":\"思路一（递归）\",\"t\":[\"按照中序遍历的过程，对每个节点的进行相同的递归处理。先处理这个节点的左子树，再处理这个节点，最后处理这个节点的右子树。\",\"递归终点：当处理的节点是空节点时，说明该节点的子树是空子树，无法继续向下处理了，递归结束，向上返回结果。\",\"代码：\"]},\"731\":{\"h\":\"思路二（迭代）\",\"t\":[\"在递归的方法中，其实隐式地维护了一个栈结构：一直递归寻找最下层的左节点，直到找到并处理完后，再返回处理上一层找到的节点。类似于栈中的先进后出，最后找到的节点处理完后，才会处理之前找到的节点。\",\"因此利用迭代的思想，使用一个栈，迭代地寻找当前节点的左子节点，找到后处理并弹出，同理再处理该节点和该节点的右子节点。全部弹出后，最后返回上一层，即当前节点的父节点。此时父节点相当于当前节点，当前节点相当于左节点，继续上述迭代处理即可。\",\"代码：\"]},\"732\":{\"c\":[\"hot100\",\"数据结构\"]},\"733\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"734\":{\"h\":\"二叉树的右视图\",\"t\":[\"199.二叉树的右视图\"]},\"735\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的 根节点root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\"]},\"736\":{\"h\":\"思路一：递归遍历\",\"t\":[\"其实就是找每一层最右边的节点。\",\"先递归右子树，再递归左子树，保证每往下遍历新一层时，第一个访问的一定是最右边的节点。记录当前层的深度，判断当前深度，对应的节点就在右视图中。\",\"代码：\",\"class Solution { void dfs(TreeNode root, int depth, List<Integer> ans) { if (root == null) return; // 如果这层是首次遍历，将节点加入到右视图中 // 如果不是首次遍历，则depth一定小于ans.size if (depth == ans.size()) ans.add(root.val); // 先递归右子树，保证首次遍历的一定是最右边的节点 dfs(root.right, depth + 1, ans); dfs(root.left, depth + 1, ans); } public List<Integer> rightSideView(TreeNode root) { List<Integer> ans = new ArrayList<>(); dfs(root, 0, ans); return ans; } }\"]},\"737\":{\"h\":\"思路二：层序遍历\",\"t\":[\"对二叉树进行层序遍历，每一层都从左到右遍历，将最后访问到的节点加入到右视图中。最后返回即可。\",\"代码：\",\"class Solution { public List<Integer> rightSideView(TreeNode root) { if (root == null) return List.of(); List<Integer> res = new ArrayList<>(); Queue<TreeNode> q = new LinkedList<>(); q.offer(root); while (!q.isEmpty()){ int n = q.size(); List<Integer> list = new ArrayList<>(n); while (n-- > 0){ TreeNode node = q.poll(); // 将每层最后一个加入到结果中 if (n == 0) res.add(node.val); if (node.left != null) q.offer(node.left); if (node.right != null) q.offer(node.right); } } return res; } }\"]},\"738\":{\"c\":[\"hot100\",\"数据结构\"]},\"739\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"740\":{\"h\":\"二叉树的层序遍历\",\"t\":[\"102.二叉树的层序遍历\"]},\"741\":{\"h\":\"题意\",\"t\":[\"给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\"]},\"742\":{\"h\":\"思路\",\"t\":[\"二叉树层序遍历使用 BFS 实现。\",\"使用队列存储每一层的节点，逐层遍历，取出遍历到的节点，并将该节点的左右子节点继续存到队列中进行下一层遍历，重复上述步骤即可。\"]},\"743\":{\"h\":\"代码\",\"t\":[\"class Solution { public List<List<Integer>> levelOrder(TreeNode root) { if (root == null) return List.of(); List<List<Integer>> ans = new ArrayList<>(); Queue<TreeNode> q = new LinkedList<>(); q.offer(root); while (!q.isEmpty()){ int n = q.size(); List<Integer> list = new ArrayList<>(n); // 预分配空间 while (n-- > 0){ TreeNode node = q.poll(); list.add(node.val); if (node.left != null) q.offer(node.left); if (node.right != null) q.offer(node.right); } ans.add(list); } return ans; } }\"]},\"744\":{\"c\":[\"hot100\",\"数据结构\"]},\"745\":{\"c\":[\"二叉树\",\"BFS\"]},\"746\":{\"h\":\"二叉树的最大深度\",\"t\":[\"104.二叉树的最大深度\"]},\"747\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树 root ，返回其最大深度。\",\"二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\"]},\"748\":{\"h\":\"思路一：后序遍历（递归）\",\"t\":[\"递归实现：树深度 等于 左子树的深度 与 右子树的深度 中的 最大值 +1 。\",\"代码：\",\"class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; int l = maxDepth(root.left); int r = maxDepth(root.right); return Math.max(l, r) + 1; } }\"]},\"749\":{\"h\":\"思路二：层序遍历（迭代）\",\"t\":[\"队列实现：每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。\",\"代码：\",\"class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; List<TreeNode> q = new LinkedList<>(); q.add(root); int res = 0; while (!q.isEmpty()){ List<TreeNode> tmp = new LinkedList<>(); for (TreeNode node : q){ if (node.left != null) tmp.add(node.left); if (node.right != null) tmp.add(node.right); } q = tmp; res++; } return res; } }\"]},\"750\":{\"c\":[\"hot100\",\"数据结构\"]},\"751\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"752\":{\"h\":\"二叉树的最近公共祖先\",\"t\":[\"236.二叉树的最近公共祖先\"]},\"753\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\",\"百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\"]},\"754\":{\"h\":\"思路\",\"t\":[\"递归 + 分类讨论：\",\"分类讨论\"]},\"755\":{\"h\":\"代码\",\"t\":[\"class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 只要当前根节点是p和q中的任意一个，就返回（因为不能比这个更深了，再深p和q中的一个就没了） if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // 如果left 和 right都不为空，说明此时root就是最近公共节点 // 如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之亦然。 if (left == null) return right; if (right == null) return left; return root; } }\"]},\"756\":{\"c\":[\"hot100\",\"数据结构\"]},\"757\":{\"c\":[\"二叉树\",\"递归\"]},\"758\":{\"h\":\"二叉树的直径\",\"t\":[\"543.二叉树的直径\"]},\"759\":{\"h\":\"题意\",\"t\":[\"给你一棵二叉树的根节点，返回该树的 直径 。\",\"二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。\",\"两节点之间路径的 长度 由它们之间边数表示。\"]},\"760\":{\"h\":\"思路\",\"t\":[\"转化一下：\",\"所谓二叉树的直径，就是根节点的左右子树的最大深度之和，即左子树最深节点和右子树最深节点的距离。\",\"那么就是对每个节点计算左右子树的最大高度，得出每个节点的直径，顺便更新最大直径，递归返回即可。\"]},\"761\":{\"h\":\"代码\",\"t\":[\"class Solution { int ans = 0; int dfs(TreeNode root) { if (root == null) return 0; int l = dfs(root.left); int r = dfs(root.right); ans = Math.max(ans, l + r); // 更新最长路径 // 返回该节点的最大深度 return Math.max(l, r) + 1; } public int diameterOfBinaryTree(TreeNode root) { dfs(root); return ans; } }\"]},\"762\":{\"c\":[\"hot100\",\"数据结构\"]},\"763\":{\"c\":[\"二叉树\",\"递归\"]},\"764\":{\"h\":\"从前序与中序遍历序列构造二叉树\",\"t\":[\"105.从前序与中序遍历序列构造二叉树\"]},\"765\":{\"h\":\"题意\",\"t\":[\"给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\"]},\"766\":{\"h\":\"思路\",\"t\":[\"前序遍历性质：节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。 中序遍历性质：节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。\",\"根据以上性质，可得出以下推论：\",\"前序遍历的首元素 为 树的根节点 node 的值。\",\"在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ]。\",\"根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ]。\",\"如下图:\",\"前序 + 中序建树\",\"通过以上三步，可确定 三个节点 ：1.树的根节点、2.左子树根节点、3.右子树根节点。\",\"根据分治思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。\",\"递归建树:\",\"先建立根节点：从前序遍历数组的第一个元素开始，根节点为 preorder[0]\",\"再划分左右子树：确定根节点再中序遍历中的位置 i，划分左子树范围 [left, i - 1]，右子树范围 [i + 1, right]\",\"最后构建左右子树：开始左右子树递归\",\"设前序遍历中根节点的索引为 root，则左子节点索引为 root + 1，右子节点索引为 root + i - left + 1.\",\"由于是根据前序遍历的节点来确定中序遍历中节点的位置，所以使用 Map 存储中序遍历的节点与索引的映射关系。\",\"注意\",\"本文方法只适用于 “无重复节点值” 的二叉树。\",\"如果题目中给定的节点值存在重复的解法：https://doocs.github.io/leetcode/lc/105/#_3\"]},\"767\":{\"h\":\"代码\",\"t\":[\"class Solution { int[] preorder; HashMap<Integer, Integer> mp = new HashMap<>(); TreeNode build(int root, int left, int right) { if (left > right) return null; // 递归终止 TreeNode node = new TreeNode(preorder[root]); // 建立根节点 int i = mp.get(preorder[root]); // 划分根节点、左子树、右子树 node.left = build(root + 1, left, i - 1); // 开启左子树递归 node.right = build(root + i - left + 1, i + 1, right); // 开启右子树递归 return node; // 回溯返回根节点 } public TreeNode buildTree(int[] preorder, int[] inorder) { this.preorder = preorder; for(int i = 0; i < inorder.length; i++){ mp.put(inorder[i], i); } return build(0, 0, inorder.length - 1); } }\",\"另外一种 K 神的写法：\",\"class Solution { // map存节点和对应的下标 Map<Integer, Integer> premap = new HashMap<>(); // 前序 Map<Integer, Integer> inmap = new HashMap<>(); // 中序 // 当left = right时返回 TreeNode build(int rootIndex, int left, int right, int[] preorder, int[] inorder) { if (left > right) return null; if (left == right) return new TreeNode(inorder[left]); int rootPreIndex = premap.get(rootIndex); int rootInIndex = inmap.get(rootIndex); TreeNode root = new TreeNode(rootIndex); // 建立左子树 if (rootPreIndex + 1 > 0 && rootPreIndex < preorder.length){ root.left = build(preorder[rootPreIndex + 1], left, rootInIndex - 1, preorder, inorder); } else { root.left = null; } // 建立右子树 if (rootPreIndex + rootInIndex - left + 1 > 0 && rootPreIndex + rootInIndex - left + 1 < preorder.length){ root.right = build(preorder[rootPreIndex + rootInIndex - left + 1], rootInIndex + 1, right, preorder, inorder); } else { root.right = null; } // 返回根节点 return root; } public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i < preorder.length; i++){ premap.put(preorder[i], i); } for (int i = 0; i < inorder.length; i++){ inmap.put(inorder[i], i); } return build(preorder[0], 0, preorder.length - 1, preorder, inorder); } }\"]},\"768\":{\"c\":[\"hot100\",\"数据结构\"]},\"769\":{\"c\":[\"二叉树\",\"递归\",\"哈希\"]},\"770\":{\"h\":\"分割等和子集\",\"t\":[\"416. 分割等和子集\"]},\"771\":{\"h\":\"题意\",\"t\":[\"给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\"]},\"772\":{\"h\":\"思路\",\"t\":[\"本题是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\",\"那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。\",\"类比于 01 背包问题：有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 w[i]，得到的价值是 v[i]。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\",\"对应到本题中：\",\"背包的体积为 sum / 2\",\"背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值\",\"背包如果正好装满，说明找到了总和为 sum / 2 的子集。\",\"背包中每一个元素是不可重复放入。\",\"动规分析：\",\"本题中每一个元素的数值既是重量，也是价值。 定义 DP 数组：dp[j] 表示背包总容量是 j 的情况下，最大重量为 dp[j]。（注意：已经过状态压缩）\",\"判断条件： 如果背包容量为 target，dp[target] 就是装满背包之后的重量，所以当 dp[target] == target 的时候，背包就装满了。\",\"确定递推公式：01 背包的递推公式为：dp[j] = max(dp[j], dp[j - w[i]] + v[i]) 类似地，本题的递推公式为：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\",\"初始化： 从 dp[j] 的定义来看，首先 dp[0] 一定是 0。 如果题目给的价值都是正整数，那么非 0 下标都初始化为 0 就可以了，如果题目给的价值有负数，那么非 0 下标就要初始化为负无穷。 这样才能让 DP 数组在递推的过程中取得最大的价值，而不是被初始值覆盖了。 所以本题中非 0 下标的元素初始化为 0 就可以了。\",\"确定遍历顺序： 如果是二维 DP 数组，物品遍历和背包遍历的顺序可以颠倒； 但如果是一维 DP 数组，那么物品遍历放在外层，遍历背包放在内层，且内层循环必须倒序遍历！ 这样才能保证前面的状态不会被后面覆盖。\",\"代码：\",\"class Solution { public boolean canPartition(int[] nums) { int n = nums.length; int sum = 0; for (int num : nums) sum += num; // 和为奇数时，不可能划分成两个和相等的集合 if (sum % 2 != 0) return false; int target = sum / 2; int[] dp = new int[target + 1]; Arrays.fill(dp, 0); for (int i = 0; i < n; i++) { for (int j = target; j >= nums[i]; j--){ dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]); } } return dp[target] == target; } }\"]},\"773\":{\"c\":[\"hot100\",\"动态规划\"]},\"774\":{\"c\":[\"背包问题\"]},\"775\":{\"h\":\"删除链表的倒数第N个节点\",\"t\":[\"19.删除链表的倒数第N个节点\"]},\"776\":{\"h\":\"题意\",\"t\":[\"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\"]},\"777\":{\"h\":\"思路\",\"t\":[\"链表无法像数组那样直接通过索引来获取元素，如果是顺数第 n 个结点，那直接循环判断即可。但题目要求倒数第 n 个结点，在不知道链表长度的情况下，如果快速地删除指定结点并返回头结点呢？\",\"答案就是使用双指针中的 快慢指针。\",\"要删除倒数第 n 个结点，就要获得倒数第 n + 1 个结点的引用。\",\"整体思路就是让快指针先移动 n 步，然后两个指针同时移动，当快指针移动到末尾时，慢指针就指向倒数第 n + 1 个结点。这样，只遍历了一次链表，就获得了倒数第 n 个节点 left。\",\"先要在链表头部接一个虚拟结点 dummy，为了避免删除倒数第一个元素时出现空指针异常，在头部加入 dummy 结点并不影响尾部倒数第 n 个元素是什么。\",\"我们先让快指针 right 指向链表的头结点 head，然后走 n 步：\",\"用慢指针指针 right 指向链表头结点 head：\",\"之后 left 和 right 同时向前走，此时二者的距离为 n，到 right 到尾部时，left 的位置恰好是倒数第 n + 1 个结点；\",\"因为要删除该结点，所以要移动到该结点的前一个才能删除，所以循环条件为 right.next != null\",\"删除后返回 dummy.next，保证在 n = 1 的情况下也能正常返回。\"]},\"778\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { // 由于可能会删除链表头部，用哨兵节点简化代码 ListNode dummy = new ListNode(0, head); ListNode left = dummy, right = dummy; while (n-- > 0) { right = right.next; // 右指针先向右走 n 步 } while (right.next != null) { left = left.next; right = right.next; // 左右指针一起走 } left.next = left.next.next; // 左指针的下一个节点就是倒数第 n 个节点 return dummy.next; } }\"]},\"779\":{\"c\":[\"hot100\",\"数据结构\"]},\"780\":{\"c\":[\"链表\",\"双指针\"]},\"781\":{\"h\":\"单词拆分\",\"t\":[\"139.单词拆分\"]},\"782\":{\"h\":\"题意\",\"t\":[\"给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。\",\"注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\"]},\"783\":{\"h\":\"思路一：动态规划\",\"t\":[\"定义 DP 数组，dp[i] 表示 s 的前 i 位是否可以用 wordDict 中的单词表示。\",\"初始化 dp[0] = true，空字符也可以被表示\",\"遍历字符串 s 的每个字符，对于 wordDict 中的每个单词： \",\"若 dp[i] = true，则表示 s 的前 i 位可以用单词表示；\",\"对于后 [i, n] 位，判断 s[i,...,n] 是否出现在 wordDict 中，如果满足条件，则可以表示，更新对应位置的 dp = true。\",\"最后返回 dp[n] 即可。\",\"class Solution { public boolean wordBreak(String s, List<String> wordDict) { int n = s.length(); boolean[] dp = new boolean[n + 1]; dp[0] = true; for (int i = 0; i < n; i++){ for (String word : wordDict){ if (dp[i] && word.length() + i <= n && s.startsWith(word, i)){ dp[i + word.length()] = true; } } } return dp[n]; } }\"]},\"784\":{\"h\":\"思路二：记忆化搜索\",\"t\":[\"使用记忆化函数，保存出现过的 dfs(s)，避免重复计算。\",\"定义递归函数 dfs(s)： \",\"若 s 长度为 0，则返回 true，表示已经使用 wordDict 中的单词完成分割；\",\"初始化当前字符串是否可以被分割 res = false；\",\"遍历剩下区间 [i, n]，若剩下字符串也能够完成分割，则返回 true\",\"最后返回 res。\",\"class Solution { private boolean dfs(String s, List<String> wordDict, Map<String, Boolean> memo){ if (s.isEmpty()) return true; // 这个状态已经被计算过，则直接返回结果 if (memo.containsKey(s)) return memo.get(s); int n = s.length(); boolean res = false; // 如果剩下的子串s[i,...,n]在字典中且可以分割，则返回true for (int i = 1; i <= n; i++){ String pre = s.substring(0, i); if (wordDict.contains(pre)){ res = dfs(s.substring(i), wordDict, memo) || res; } } // 记录当前结果 memo.put(s, res); return res; } public boolean wordBreak(String s, List<String> wordDict) { Map<String, Boolean> memo = new HashMap<>(); // 记录状态 return dfs(s, wordDict, memo); } }\"]},\"785\":{\"c\":[\"hot100\",\"动态规划\"]},\"786\":{\"c\":[\"线性DP\"]},\"787\":{\"h\":\"合并 K 个升序链表\",\"t\":[\"23.合并K个升序链表\"]},\"788\":{\"h\":\"题意\",\"t\":[\"给你一个链表数组，每个链表都已经按升序排列。\",\"请你将所有链表合并到一个升序链表中，返回合并后的链表。\"]},\"789\":{\"h\":\"思路一：优先队列\",\"t\":[\"合并后的第一个节点 first，一定是某个链表的头节点（因为链表已按升序排列）。\",\"合并后的第二个节点，可能是某个链表的头节点，也可能是 first 的下一个节点。\",\"例如有三个链表 1->2->5, 3->4->6, 4->5->6，找到第一个节点 1 之后，第二个节点不是另一个链表的头节点，而是节点 1 的下一个节点 2。\",\"按照这个过程继续思考，每当我们找到一个节点值最小的节点 x，就把节点 x.next 加入「可能是最小节点」的集合中。\",\"因此，我们需要一个数据结构，它支持：\",\"从数据结构中找到并移除最小节点。\",\"插入节点。\",\"这可以用 最小堆 实现。\",\"初始把所有链表的头节点入堆，然后不断弹出堆中最小节点 x，如果 x.next 不为空就加入堆中，循环直到堆为空。把弹出的节点按顺序接在链表后面，返回链表即可。\",\"代码：\",\"class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) return null; // 虚拟头结点 ListNode dummy = new ListNode(-1); ListNode p = dummy; // 优先级队列，最小堆 PriorityQueue<ListNode> pq = new PriorityQueue<>( lists.length, (a, b)->(a.val - b.val)); // 将 k 个链表的头结点加入最小堆 for (ListNode head : lists) { if (head != null) pq.add(head); } while (!pq.isEmpty()) { // 获取最小节点，接到结果链表中 ListNode node = pq.poll(); p.next = node; if (node.next != null) { pq.add(node.next); } // p 指针不断前进 p = p.next; } return dummy.next; } }\"]},\"790\":{\"h\":\"思路二：分治\"},\"791\":{\"c\":[\"hot100\",\"数据结构\"]},\"792\":{\"c\":[\"链表\",\"优先队列\"]},\"793\":{\"h\":\"完全平方数\",\"t\":[\"279.完全平方数\"]},\"794\":{\"h\":\"题意\",\"t\":[\"给你一个整数 n ，返回和为 n 的完全平方数的最少数量。\",\"完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\"]},\"795\":{\"h\":\"思路一：记忆化搜索\",\"t\":[\"把 1,4,9,16,... 这些完全平方数视作物品体积，物品价值都是 1。由于每个数（物品）选的次数没有限制，所以本题是一道标准的完全背包问题。\",\"完全背包模板：完全背包\",\"定义 dfs(i, j) 表示从前 i 个完全平方数中选一些数（可以重复选），满足元素和恰好等于 j，最少要选的数字个数。\",\"考虑第 i 个完全平方数 i2 选或不选：\",\"不选：问题变成从前 i−1 个完全平方数中选一些数（可以重复选），满足元素和恰好等于 j，最少要选的数字个数，即 dfs(i, j) = dfs(i − 1, j)。\",\"选：前提是 j≥i2。问题变成从前 i 个完全平方数中选一些数（可以重复选），满足元素和恰好等于 j−i2，最少要选的数字个数，即 dfs(i, j) = dfs(i, j − i^2) + 1。注意这里是 i 而不是 i−1，因为我们可以继续选第 i 个完全平方数。\",\"这两种情况取最小值，就得到了 dfs(i, j)，即\",\"dfs(i,j)={​dfs(i−1,j),min(dfs(i−1,j),dfs(i,j−i2)+1),​j<i2j≥i2​\",\"递归边界：dfs(0,0) = 0。因为没有数可以选了，且要得到的数等于 0，那么答案为 0。如果 j>0，那么 dfs(0, j) = ∞，这里用 ∞ 表示不合法的状态，从而保证上式中的 min 取到合法的状态。注意本题是一定有解的，因为 1 是完全平方数。\",\"递归入口：由于 i2≤n，所以 i≤⌊n​⌋，所以递归入口为 $ dfs(\\\\lfloor \\\\sqrt{n} \\\\rfloor​, n)$，也就是答案。\",\"代码：\",\"class Solution { static int[][] memo = new int[101][10001]; static { for (int[] row : memo) { Arrays.fill(row, -1); // -1 表示没有计算过 } } int dfs(int i, int j){ if (i == 0){ return j == 0 ? 0 : Integer.MAX_VALUE; } if (memo[i][j] != -1){ return memo[i][j]; } if (j < i * i){ return memo[i][j] = dfs(i - 1, j); // 超过范围，只能不选 } return memo[i][j] = Math.min(dfs(i - 1, j), dfs(i, j - i * i) + 1); } public int numSquares(int n) { return dfs((int)Math.sqrt(n), n); } }\"]},\"796\":{\"h\":\"思路二：递推\",\"t\":[\"记忆化搜索是基于递归来实现的，首先找到最底下的叶子节点，再递归返回结果。在这个过程中，递归向上将结果返回的父节点是可以确定的，这样就可以省去刚开始向下「递」的过程。即自底向上递推计算，从 0 递推结果到 n，返回最后 n 处的结果即可。\",\"具体来说，f[i][j] 的定义和 dfs(i,j) 的定义是一样的，都表示从前 i 个完全平方数中选一些数（可以重复选），满足元素和恰好等于 j，最少要选的数字个数。\",\"相应的递推式（状态转移方程）也和 dfs 一样：\",\"f[i][j]={​f[i−1][j],min(f[i−1][j],f[i][j−i2]+1),​j<i2j≥i2​\",\"初始值 f[0][0] = 0, f[0][j] = ∞，答案为 f[⌊n​⌋][n].\",\"代码：\",\"class Solution { public int numSquares(int n) { int[][] f = new int[101][n + 1]; Arrays.fill(f[0], Integer.MAX_VALUE); // 初始化无穷大 f[0][0] = 0; for (int i = 1; i * i <= n; i++){ for (int j = 0; j <= n; j++){ if (j < i * i){ f[i][j] = f[i - 1][j]; // 超过范围，只能不选 } else { // 比较选与不选方案的最小值 f[i][j] = Math.min(f[i - 1][j], f[i][j - i * i] + 1); } } } return f[(int)Math.sqrt(n)][n]; } }\"]},\"797\":{\"h\":\"空间优化\",\"t\":[\"观察上面的状态转移方程，在计算 f[i] 时，只会用到 f[i − 1]，不会用到比 i−1 更早的状态。\",\"因此可以去掉第一个维度，反复利用同一个长为 n+1 的一维数组。\",\"递推式简化为，当 j≥i2 时，计算\",\"f[j]=min(f[j],f[j−i2]+1)\",\"注意 j<i2 的递推式简化为 f[j] = f[j]，无需计算。\",\"初始值 f[0] = 0, f[j] = ∞ (j > 0)。\",\"答案为 f[n]。\",\"class Solution { public int numSquares(int n) { int[] f = new int[n + 1]; Arrays.fill(f, Integer.MAX_VALUE); // 初始化无穷大 f[0] = 0; for (int i = 1; i * i <= n; i++){ for (int j = i * i; j <= n; j++){ // 比较选与不选方案的最小值 f[j] = Math.min(f[j], f[j - i * i] + 1); } } return f[n]; } }\"]},\"798\":{\"c\":[\"hot100\",\"动态规划\"]},\"799\":{\"c\":[\"背包问题\"]},\"800\":{\"h\":\"实现 Trie（前缀树）\",\"t\":[\"208.实现Trie（前缀树）\"]},\"801\":{\"h\":\"题意\",\"t\":[\"（发音类似 \\\"try\\\"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\",\"请你实现 Trie 类：\",\"Trie() 初始化前缀树对象。\",\"void insert(String word) 向前缀树中插入字符串 word 。\",\"boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\",\"boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\"]},\"802\":{\"h\":\"思路\",\"t\":[\"基于前缀树结构，每一层的节点并不是直接存储了某个字符，而是记录这一层节点对应字符串的位置是否出现了某个字符。比如根节点就是记录了字符串首个位置，第二层节点就是记录了字符串索引 1 的位置。\",\"树的结构\",\"我们可以将每一个字符串存储到树中，并且对于相同前缀只存储一次「从根节点出发到任一个节点都是一个前缀」。对于每个加入的字符串我们一定能在树中找到一条路径还原它。\",\"初始化：\",\"因为字符串中只存在小写字母，因此每个节点最多有 26 个子节点。\",\"使用 children[26] 的列表存储当前节点对应出现过的字符的子节点。\",\"使用布尔字段 isEnd，表示该节点是否为字符串的结尾。\",\"isEnd\",\"如果要查找一个完整的字符串，当我们找到时，我们如何知道找到的这部分是一个完整的字符串还是某个字符串的前缀呢？\",\"因此我们对每个节点引入一个标志 isEnd 标记当前节点对应一个完整字符串，我们在插入字符串的时候将最后一个字符对应的节点的标志位置为 True。\",\"当我们查找一个完整字符串时，既要能找到对应的节点，同时节点的标志位还必须为 true。\",\"插入字符串：\",\"假设当前节点为 node，当前要加入的字符为 ch：\",\"如果当前节点 node 的子节点列表中，ch 位置没有节点，则新建一个节点\",\"然后更新 node 为子节点，加入下一个字符\",\"node 初始为前缀树的根节点 root\",\"查找前缀：\",\"假设当前节点为 node，当前要查找的字符为 ch：\",\"如果当前节点 node 的子节点列表中，ch 位置没有节点，说明这个字符没有匹配上，前缀不存在退出查找\",\"否则更新 node 为子节点，寻找下一个字符\",\"node 初始为前缀树的根节点 root\"]},\"803\":{\"h\":\"代码\",\"t\":[\"class Trie { private Trie[] children; // 子节点列表 private boolean isEnd; // 标记是否尾节点 public Trie() { children = new Trie[26]; isEnd = false; } public void insert(String word) { Trie node = this; // 从根节点开始构造这个word对应的路径节点 int n = word.length(); for (int i = 0; i < n; i++){ // 将当前字符添加到当前节点对应的子节点位置，然后递归更新 int idx = word.charAt(i) - 'a'; if (node.children[idx] == null){ node.children[idx] = new Trie(); } node = node.children[idx]; } node.isEnd = true; // 最后一个节点的isEnd置为true，表示一个完整的字符串 } public boolean search(String word) { Trie node = searchPrefix(word); // 返回不为空且节点标记为尾节点，则包含word这个完整的字符串 return node != null && node.isEnd; } public boolean startsWith(String prefix) { return searchPrefix(prefix) != null; // 返回不为空，则包含了prefix前缀 } // 查找字典树是否包含word前缀 private Trie searchPrefix(String word) { Trie node = this; // 从根节点依次开始匹配每个字符 int n = word.length(); for (int i = 0; i < n; i++){ int idx = word.charAt(i) - 'a'; node = node.children[idx]; // 根据当前字符获取对应的子节点 if (node == null){ return null; // 只要当前节点为空，则不包含这个字符串，直接返回空指针 } } return node; // 否则匹配成功返回node } }\"]},\"804\":{\"c\":[\"hot100\",\"图论\"]},\"805\":{\"c\":[\"字典树\"]},\"806\":{\"h\":\"对称二叉树\",\"t\":[\"101.对称二叉树\"]},\"807\":{\"h\":\"题意\",\"t\":[\"给你一个二叉树的根节点 root ， 检查它是否轴对称。\"]},\"808\":{\"h\":\"思路\",\"t\":[\"递归结束条件：\",\"都为空指针返回 true\",\"只有一个为空返回 false\",\"递归过程：\",\"判断两个指针当前节点值是否相等\",\"判断 A 的右子树与 B 的左子树是否对称\",\"判断 A 的左子树与 B 的右子树是否对称\",\"短路原则：\",\"在递归判断过程中存在短路现象，也就是做 与 操作时，如果前面的值返回 false 则后面的不再进行计算\"]},\"809\":{\"h\":\"代码\",\"t\":[\"class Solution { boolean isSameTree(TreeNode p, TreeNode q) { if (p == null || q == null) return p == q; // 左对右，右对左，判断对应的两个节点是否相等 return p.val == q.val && isSameTree(p.left, q.right) && isSameTree(p.right, q.left); } public boolean isSymmetric(TreeNode root) { return isSameTree(root.left, root.right); } }\"]},\"810\":{\"c\":[\"hot100\",\"数据结构\"]},\"811\":{\"c\":[\"二叉树\",\"递归\"]},\"812\":{\"h\":\"将有序数组转换为二叉搜索树\",\"t\":[\"108.将有序数组转换为二叉搜索树\"]},\"813\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。\",\"平衡二叉树：是指该树所有节点的左右子树的深度相差不超过 1。\"]},\"814\":{\"h\":\"思路\",\"t\":[\"由于 BST 的中序遍历是升序的，所以本题等同于根据中序遍历的序列建立二叉搜索树。\",\"因为本题要求高度平衡，所以选择序列的中间值作为根节点，不断二分递归建立左子树和右子树。\"]},\"815\":{\"h\":\"代码\",\"t\":[\"class Solution { TreeNode dfs(int[] nums, int l, int r) { if (l > r) return null; // 以升序数组的中间元素作为根节点 int mid = l + (r - l) / 2; TreeNode root = new TreeNode(nums[mid]); // 递归的构建左子树与右子树 root.left = dfs(nums, l, mid - 1); root.right = dfs(nums, mid + 1, r); return root; } public TreeNode sortedArrayToBST(int[] nums) { return dfs(nums, 0, nums.length - 1); } }\"]},\"816\":{\"c\":[\"hot100\",\"数据结构\"]},\"817\":{\"c\":[\"二叉树\"]},\"818\":{\"h\":\"岛屿数量\",\"t\":[\"200.岛屿数量\"]},\"819\":{\"h\":\"题意\",\"t\":[\"给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\",\"岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\",\"此外，你可以假设该网格的四条边均被水包围。\"]},\"820\":{\"h\":\"思路一（DFS）\",\"t\":[\"解决岛屿题目最常见的就是 DFS 了，每次遇到一个岛屿中的陆地，就用 DFS 把这个岛屿「淹掉」。\",\"把二维数组中的每个格子看做「图」中的一个节点，这个节点和周围的四个节点连通，这样二维矩阵就被抽象成了一幅网状的「图」。\",\"为什么每次遇到岛屿，都要用 DFS 把岛屿「淹了」呢？主要是为了省事，避免维护 visited 数组。因为遍历图是需要 visited 数组记录遍历过的节点防止走回头路。\",\"由于 dfs 函数遍历到值为 0 的位置会直接返回，所以只要把经过的位置都设置为 0，就可以起到不走回头路的作用。\",\"最终岛屿的数量就是每次发现新岛屿的次数。\",\"代码：\",\"class Solution { void dfs(char[][] g, int i, int j) { int n = g.length, m = g[0].length; // 先判断范围和条件 if (i < 0 || i >= n || j < 0 || j >= m) return; if (g[i][j] == '0') return; // 将遍历过的陆地淹没 g[i][j] = '0'; // 遍历上下左右四个方向 dfs(g, i + 1, j); dfs(g, i, j + 1); dfs(g, i - 1, j); dfs(g, i, j - 1); } public int numIslands(char[][] g) { int res = 0; int n = g.length, m = g[0].length; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ // 每发现一个新岛屿，加入进来 if (g[i][j] == '1'){ res++; // 使用dfs将连通的陆地块淹掉 dfs(g, i, j); } } } return res; } }\"]},\"821\":{\"h\":\"思路二（BFS）\",\"t\":[\"广搜需要通过队列实现，每走过一个节点，就要加入队列并标记为「淹没」。\",\"遍历整个二维数组。如果一个位置为 '1'，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 '1' 都会被重新标记为 '0'。直到队列为空，搜索结束。\",\"最终岛屿的数量就是进行广度优先搜索的次数。\",\"class Solution { int n, m; char[][] g; int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1}; void bfs(int i, int j) { Queue<Pair<Integer, Integer>> q = new LinkedList<>(); q.offer(new Pair<>(i, j)); g[i][j] = '0'; while (!q.isEmpty()){ Pair<Integer, Integer> t = q.poll(); int x = t.getKey(); int y = t.getValue(); for (int k = 0; k < 4; k++){ int xx = x + dx[k], yy = y + dy[k]; if (xx < 0 || xx >= n || yy < 0 || yy >= m || g[xx][yy] == '0') continue; q.offer(new Pair<>(xx, yy)); g[xx][yy] = '0'; } } } public int numIslands(char[][] g) { n = g.length; m = g[0].length; this.g = g; int res = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (g[i][j] == '1'){ bfs(i, j); res++; } } } return res; } }\"]},\"822\":{\"h\":\"思路三（并查集）\",\"t\":[\"遍历整个二维数组。如果一个位置为 '1'，则将其与相邻四个方向上的 '1' 在并查集中进行合并。\",\"因为是从（0,0）往（n，m）按顺序遍历，所以可以优化为每次只搜「右边」和「下边」的位置，因为「左边」和「上边」在之前的搜索中已经加入到集合了，不需要再搜了。\",\"最终岛屿的数量就是并查集中连通分量的数目。\",\"代码：\",\"class Solution { int[] p; int res; int find(int i) { return p[i] == i ? p[i] : find(p[i]); } void union(int i, int j){ if (find(i) == find(j)) return; // 避免重复合并操作 p[find(i)] = p[find(j)]; res--; } public int numIslands(char[][] g) { int n = g.length, m = g[0].length; p = new int[n * m]; res = 0; // 初始化 parent 数组，记录初始岛屿数（也就是 '1' 的数目） for (int i = 0; i < n; i++){ for(int j = 0; j < m; j++){ int idx = i * m + j; p[idx] = idx; if(g[i][j] == '1') res++; } } for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { int idx = i * m + j; if (g[i][j] == '1') { // 合并岛屿 if (i + 1 < n && g[i + 1][j] == '1') { union(idx, (i + 1) * m + j); } if (j + 1 < m && g[i][j + 1] == '1') { union(idx, i * m + j + 1); } } } } return res; } }\"]},\"823\":{\"c\":[\"hot100\",\"图论\"]},\"824\":{\"c\":[\"DFS\",\"BFS\",\"并查集\"]},\"825\":{\"h\":\"打家劫舍\",\"t\":[\"198.打家劫舍\"]},\"826\":{\"h\":\"题意\",\"t\":[\"你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\",\"给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\"]},\"827\":{\"h\":\"思路一：记忆化搜索\",\"t\":[\"假设你就是这个强盗，从左到右走过这一排房子，在每间房子前都有两种选择：抢或者不抢。\",\"当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（base case）。\",\"以上已经明确了「状态」和「选择」：你面前房子的索引就是状态，抢和不抢就是选择。\",\"代码：\",\"class Solution { // 备忘录 private int[] memo; // 主函数 public int rob(int[] nums) { // 初始化备忘录 memo = new int[nums.length]; Arrays.fill(memo, -1); // 强盗从第 0 间房子开始抢劫 return dp(nums, 0); } // 返回 dp[start..] 能抢到的最大值 private int dp(int[] nums, int start) { if (start >= nums.length) { return 0; } // 避免重复计算 if (memo[start] != -1) return memo[start]; int res = Math.max(dp(nums, start + 1), nums[start] + dp(nums, start + 2)); // 记忆化：保存计算结果 memo[start] = res; return res; } }\"]},\"828\":{\"h\":\"思路二：递推\",\"t\":[\"转化为递推，每个状态都由前面抢与不抢来决定。\",\"当遍历到最后一间房子即 nums[n - 1] 时，推出来的状态为 f[n + 1]，所以 f[] 的长度要 +2，避免下标越界。\",\"代码：\",\"class Solution { public int rob(int[] nums) { int n = nums.length; int f[] = new int[n + 2]; for (int i = 0; i < n; i++){ f[i + 2] = Math.max(f[i + 1], f[i] + nums[i]); } return f[n + 1]; } }\",\"进一步空间优化：\",\"class Solution { public int rob(int[] nums) { int f0 = 0; int f1 = 0; for (int x : nums) { int newF = Math.max(f1, f0 + x); f0 = f1; f1 = newF; } return f1; } }\"]},\"829\":{\"c\":[\"hot100\",\"动态规划\"]},\"830\":{\"c\":[\"递推\"]},\"831\":{\"h\":\"排序链表\",\"t\":[\"148.排序链表\"]},\"832\":{\"h\":\"题意\",\"t\":[\"给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\"]},\"833\":{\"h\":\"思路\",\"t\":[\"题目要求时间空间复杂度分别为 O(nlogn) 和 O(1)，自然想到二分，从而联想到归并排序。\",\"归并排序详情：归并排序\",\"使用快慢指针 fast 和 slow，找到中间结点后，先递归再合并。\",\"确定分界点：\",\"归并每次都将中点作为分界点，将整个序列分为两部分；\",\"找到中点 slow 后，保存右半部分的头结点 slow.next，执行 slow.next = null 将链表分割；\",\"当 head.next == null 时，说明只有一个结点了，直接返回此结点。\",\"递归排序：\",\"建立临时结点 tmp 作为临时链表头部，从头开始遍历比较，每次比较 left 和 right，将小的结点接入临时链表后面；\",\"如果有一部分遍历完了，而另一部分还有剩余，则将剩余那部分直接接在临时链表后面；\",\"返回临时链表头结点。\"]},\"834\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode sortList(ListNode head) { if (head == null || head.next == null) return head; // 快慢指针找到中间结点 ListNode fast = head.next, slow = head; while (fast != null && fast.next != null){ fast = fast.next.next; slow = slow.next; } // 将链表断开，分割成两部分 ListNode slowNext = slow.next; slow.next = null; // 递归排序左右两部分 ListNode left = sortList(head); ListNode right = sortList(slowNext); // 合并排序后的两部分 ListNode tmp = new ListNode(0); ListNode dummp = tmp; while (left != null && right != null){ if (left.val < right.val){ tmp.next = left; left = left.next; } else { tmp.next = right; right = right.next; } tmp = tmp.next; } // 把剩余部分接上 tmp.next = left == null ? right : left; return dummp.next; // 返回头结点 } }\"]},\"835\":{\"c\":[\"hot100\",\"数据结构\"]},\"836\":{\"c\":[\"链表\"]},\"837\":{\"h\":\"最长公共子序列\",\"t\":[\"1143.最长公共子序列\"]},\"838\":{\"h\":\"题意\",\"t\":[\"给定两个字符串 s1 和 s2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。\",\"一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\",\"例如，\\\"ace\\\" 是 \\\"abcde\\\" 的子序列，但 \\\"aec\\\" 不是 \\\"abcde\\\" 的子序列。\",\"两个字符串的公共子序列是这两个字符串所共同拥有的子序列。\"]},\"839\":{\"h\":\"思路\",\"t\":[\"用两个指针 i, j 在两个字符串上游走，这就是「状态」，字符串中的每个字符都有两种「选择」，要么在 lcs 中，要么不在。\",\"f[i][j] 的含义是：对于 s1[1..i] 和 s2[1..j]，它们的 LCS 长度是 f[i][j]。\"]},\"840\":{\"h\":\"代码\",\"t\":[\"class Solution { public int longestCommonSubsequence(String s1, String s2) { // 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 f[i][j] // 目标：s1[0..n-1] 和 s2[0..m-1] 的 lcs 长度，即 f[n][m] int n = s1.length(), m = s2.length(); // 初始化：f[0][..] = f[..][0] = 0 int f[][] = new int[n + 1][m + 1]; for (int i = 1; i <= n; i++) { for (int j = 1; j <= m; j++) { // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中 f[i][j] = Math.max(f[i][j - 1], f[i - 1][j]); // 因为 i 和 j 从 1 开始，所以要减一 if (s1.charAt(i - 1) == s2.charAt(j - 1)) // s1[i-1] 和 s2[j-1] 必然在 lcs 中 f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; } }\"]},\"841\":{\"c\":[\"hot100\",\"动态规划\"]},\"842\":{\"c\":[\"线性DP\"]},\"843\":{\"h\":\"最长有效括号\",\"t\":[\"32.最长有效括号\"]},\"844\":{\"h\":\"题意\",\"t\":[\"给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。\"]},\"845\":{\"h\":\"思路一：栈模拟\",\"t\":[\"用栈模拟一遍，将所有无法匹配的括号的位置全部置 1。\",\"例如: \\\"()(()\\\" 的 mark 为 [0, 0, 1, 0, 0]\",\"再例如: \\\")()((())\\\"的 mark 为 [1, 0, 0, 1, 0, 0, 0, 0]\",\"经过这样的处理后, 此题就变成了寻找最长的连续的 0 的长度。\",\"代码：\",\"class Solution { public int longestValidParentheses(String s) { Deque<Integer> st = new ArrayDeque<>(); int n = s.length(); int[] mark = new int[n]; Arrays.fill(mark, 0); for (int i = 0; i < n; i++){ if (s.charAt(i) == '(') st.push(i); else { // 多余的右括号是不需要的，标记 if (st.isEmpty()) mark[i] = 1; else st.pop(); } } // 未匹配的左括号是不需要的，标记 while (!st.isEmpty()){ mark[st.peek()] = 1; st.pop(); } // 寻找标记与标记之间的最大长度 int len = 0, ans = 0; for (int i = 0; i < n; i++){ if (mark[i] == 1){ len = 0; continue; } len++; ans = Math.max(ans, len); } return ans; } }\"]},\"846\":{\"h\":\"思路二：动态规划\",\"t\":[\"定义 DP 数组：dp[i] 表示以下标为 i 的字符结尾的最长有效括号的长度\",\"判断条件：\",\"s[i] == '(' 时，s[i] 无法和其之前的元素组成有效的括号对，所以 dp[i] = 0\",\"s[i] == ')' 时，需要看其前面对元素来判断是否有有效括号对。 \",\"s[i − 1] == '('，即 s[i] 和 s[i − 1] 组成一对有效括号，有效括号长度新增长度 2，i 位置的最长有效括号长度为 其之前2个位置的最长括号长度加上当前位置新增的 2，我们无需知道 i − 2 位置对字符是否可以组成有效括号对。 那么有：dp[i] = dp[i − 2] + 2\",\"s[i − 1] == ')'，这种情况下，如果前面有和 s[i] 组成有效括号对的字符，即形如 ((....))，那就要求 s[i − 1] 位置必然是有效的括号对，否则 s[i] 无法和前面对字符组成有效括号对。 这时，我们只需要找到和 s[i] 配对的位置，并判断其是否是 ( 即可。和其配对的位置为：i − dp[i − 1] − 1。 如果：s[i − dp[i − 1] −1] == '()'：有效括号长度新增长度 2，i 位置的最长有效括号长度为 i - 1 位置的最长括号长度加上当前位置新增的 2，那么有：dp[i] = dp[i − 1] + 2 值得注意的是，i − dp[i − 1] − 1 和 i 组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 (...) 这种序列，那么当前位置的最长有效括号长度还需要加上这一段。 所以：dp[i] = dp[i − 1] + dp[i − dp[i − 1] − 2] + 2\",\"综上可得：\",\"当 s[i] == '(' 时，dp[i] 必然等于 0，因为不可能组成有效的括号；\",\"当 s[i] == ')' 时： \",\"若 s[i - 1] == '('，则 dp[i] = dp[i - 2] + 2；\",\"若 s[i - 1] == ')' 且 s[i - dp[i - 1] - 1] == '('，则 dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2\",\"每次循环取最大的 dp[i] 即可\",\"代码：\",\"class Solution { public int longestValidParentheses(String s) { int n = s.length(); if (s == null || n == 0) return 0; int[] dp = new int[n]; int ans = 0; for (int i = 0; i < n; i++){ if (i > 0 && s.charAt(i) == ')'){ if (s.charAt(i - 1) == '('){ if (i - 2 >= 0){ dp[i] = dp[i - 2] + 2; } else { dp[i] = 2; } } else if (s.charAt(i - 1) == ')' && i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == '('){ if (i - dp[i - 1] - 2 >= 0){ dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]; } else { dp[i] = dp[i - 1] + 2; } } } ans = Math.max(ans, dp[i]); } return ans; } }\"]},\"847\":{\"c\":[\"hot100\",\"动态规划\"]},\"848\":{\"c\":[\"线性DP\",\"栈\"]},\"849\":{\"h\":\"最长递增子序列\",\"t\":[\"300.最长递增子序列\"]},\"850\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\",\"子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\",\"子序列：是可以通过从另一个数组删除或不删除某些元素，但不更改其余元素的顺序得到的数组。\",\"进阶：你能将算法的时间复杂度降低到 O(nlog(n)) 吗?\"]},\"851\":{\"h\":\"思路\",\"t\":[\"要求从所有递增子序列（LIS）中找到最长的序列，本质上是子集型问题。\",\"有两种思路：\",\"选或不选：为了比大小，需要知道上一个选的数字（即需要知道下标和值）\",\"枚举选哪个：比较当前选的数字和下一个要选的数字（枚举前已确定值的范围，所以只需要知道下标）\",\"综上，采用枚举选哪个的方式，只需要一个参数，更加好写。\",\"具体的，枚举 nums[i] 作为 LIS 的末尾元素，那么需要枚举 nums[j] 作为 LIS 的倒数第二个元素，其中 j < i，且 nums[j] < nums[i]\",\"对于回溯，需要确定三个问题：\",\"子问题？以 nums[i] 结尾的 LIS 长度\",\"当前操作？枚举 nums[j]\",\"下一个子问题？以 nums[j] 结尾的 LIS 长度\",\"即：dfs(i)=max{dfs(j)}+1，条件为 j < i，且 nums[j] < nums[i]\",\"可以得到递归的解法。但是由于每个子问题都需要进行枚举，会存在重复计算的问题，于是可以使用动态规划解决。得到状态转移表达式，即：\",\"dp[i]=max(dp[i],dp[j])+1(j<i,nums[j]<nums[i])\",\"代码：\",\"class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length; int ans = 0; int[] dp = new int[n]; for (int i = 0; i < n; i++){ for (int j = 0; j < i; j++){ if (nums[j] < nums[i]){ dp[i] = Math.max(dp[i], dp[j]); } } dp[i]++; // 表示选了当前的数 ans = Math.max(ans, dp[i]); } return ans; } }\",\"动态规划的时间复杂度 = 状态个数 × 单个状态的计算时间。\",\"故时间复杂度为 O(n2)，空间复杂度为 O(n)。\"]},\"852\":{\"h\":\"二分优化\",\"t\":[\"DP 时间复杂度优化\",\"优化技巧：交换状态与状态值\",\"f[i] 表示末尾元素为 nums[i] 的最大上升子序列（LIS）的 长度。\",\"交换后得到：\",\"g[i] 表示长度为 i+1 的上升子序列（IS）的末尾元素的最小值。\",\"当定义为最小值的时候，才更有机会去扩展 g[i] 的长度\",\"对于动态规划问题，如果想要优化时间复杂度，可以考虑交换状态与状态值。\",\"比如 nums = [1, 6, 7, 2, 4, 5, 3]g = [1]；g = [1, 6]；g = [1, 6, 7]；g = [1, 2, 7]，遍历到 2，更新第一个大于 2 的元素 g[1]，满足严格递增；g = [1, 2, 4]，遍历到 4，同理更新；g = [1, 2, 4, 5]；g = [1, 2, 3, 5]，遍历到 3，同理更新。\",\"可以得到思路：在 g 上用二分查找快速找到第一个大于 nums[i] 的下标 j。如果 j 不存在，那么 nums[i] 直接加到 g 末尾，否则修改 g[j] 为 nums[i]。\",\"需要开辟额外空间写法：\",\"class Solution { public int lengthOfLIS(int[] nums) { List<Integer> g = new ArrayList<>(); for (int x : nums) { int j = lowerBound(g, x); if (j == g.size()) { g.add(x); // >=x 的 g[j] 不存在 } else { g.set(j, x); } } return g.size(); } // 开区间写法 private int lowerBound(List<Integer> g, int t) { int l = -1, r = g.size(); // 开区间 (left, right) while (l + 1 < r) { // 区间不为空 // 循环不变量： // nums[left] < target // nums[right] >= target int mid = l + (r - l) / 2; if (g.get(mid) < t) { l = mid; // 范围缩小到 (mid, right) } else { r = mid; // 范围缩小到 (left, mid) } } return r; // 或者 left+1 } }\",\"时间复杂度为 O(nlong(n))，空间复杂度为 O(n)。\",\"进一步优化空间：\",\"可以直接把 g 填入 nums 中，空间复杂度为 O(1)：\",\"class Solution { public int lengthOfLIS(int[] nums) { int ng = 0; // g 的长度 for (int x : nums) { int j = lowerBound(nums, ng, x); nums[j] = x; if (j == ng) { // >=x 的 g[j] 不存在 ng++; } } return ng; } // 开区间写法 private int lowerBound(int[] nums, int r, int t) { int l = -1; // 开区间 (left, right) while (l + 1 < r) { // 区间不为空 // 循环不变量： // nums[left] < target // nums[right] >= target int mid = l + (r - l) / 2; if (nums[mid] < t) { l = mid; // 范围缩小到 (mid, right) } else { r = mid; // 范围缩小到 (left, mid) } } return r; // 或者 left+1 } }\"]},\"853\":{\"c\":[\"hot100\",\"动态规划\"]},\"854\":{\"c\":[\"线性DP\"]},\"855\":{\"h\":\"滑动窗口最大值\",\"t\":[\"239.滑动窗口最大值\"]},\"856\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\",\"返回 滑动窗口中的最大值 。\"]},\"857\":{\"h\":\"思路一（优先队列）\",\"t\":[\"使用优先队列，维护值和下标，窗口每次移动，判断当前最大值的位置，若已滑出窗口，则更新最大值，否则不更新。将每次移动的最大值保存在 ans[]中。\",\"代码：\",\"class Solution { public: vector<int> maxSlidingWindow(vector<int>& nums, int k) { int n = nums.size(); priority_queue<pair<int, int>> q; for (int i = 0; i < k; i++){ q.push({nums[i], i}); } vector<int> ans = {q.top().first}; for (int i = k; i < n; i++){ q.push({nums[i], i}); while (q.top().second <= i - k){ q.pop(); } ans.push_back(q.top().first); } return ans; } };\"]},\"858\":{\"h\":\"思路二（单调队列）\"},\"859\":{\"c\":[\"hot100\",\"数据结构\"]},\"860\":{\"c\":[\"滑动窗口\",\"优先队列\",\"单调队列\"]},\"861\":{\"h\":\"翻转二叉树\",\"t\":[\"226.翻转二叉树\"]},\"862\":{\"h\":\"题意\",\"t\":[\"给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\"]},\"863\":{\"h\":\"思路\",\"t\":[\"如何翻转二叉树？其实就是把二叉树上的每个节点的左右子节点都交换一下。\",\"利用给出的函数定义，递归地交换每个节点的左右子树，返回每次的根节点即可。\"]},\"864\":{\"h\":\"代码\",\"t\":[\"class Solution { // 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点 public TreeNode invertTree(TreeNode root) { if (root == null) return null; // 利用函数定义，先翻转左右子树 TreeNode l = invertTree(root.left); TreeNode r = invertTree(root.right); // 然后交换左右子节点 root.left = r; root.right = l; // 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root return root; } }\"]},\"865\":{\"c\":[\"hot100\",\"数据结构\"]},\"866\":{\"c\":[\"二叉树\",\"递归\"]},\"867\":{\"h\":\"腐烂的橘子\",\"t\":[\"994.腐烂的橘子\"]},\"868\":{\"h\":\"题意\",\"t\":[\"在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\",\"值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\",\"返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\"]},\"869\":{\"h\":\"思路\",\"t\":[\"从初始的 0 分钟开始，当前分钟的烂橘子都使其相邻位置的橘子也腐烂，从而不断扩散直到没有新鲜橘子或者无法扩散。\",\"这个过程与广度优先搜索的过程一致，常规的广度优先搜索只有一个起点，而这道题有多个起点，因为烂橘子不止一个，每个烂橘子都会去扩散腐烂周边的新鲜橘子。所以每次扩散需要考虑每一层（即最外层）的烂橘子，使用 size 记录每层烂橘子的数量，将每层的扩散情况都加入队列。\",\"重复上述步骤，即可得到最终的花费时间。\",\"另外，为了判断是否有永远不会腐烂的橘子，我们可以统计初始新鲜橘子的个数 fresh。在 BFS 中，每有一个新鲜橘子被腐烂，就把 fresh 减一，这样最后如果发现 fresh > 0，就意味着有橘子永远不会腐烂，返回 −1。\",\"初始化时间 time = -1，在每层遍历的时候 time++，这样初始的烂橘子时间为 0，因为它们是本来就有的。但要注意，在全为烂橘子的情况下要返回 0，可是在这种情况下 time 仍为其初始值 −1，所以最后要返回 max(time,0)。\"]},\"870\":{\"h\":\"代码\",\"t\":[\"使用链表作为队列，提取BFS方法\",\"class Solution { int n, m; int g[][]; int dx[] = {1, 0, -1, 0}; // x方向数组 int dy[] = {0, 1, 0, -1}; // y方向数组 int fresh = 0; int time = -1; // 初始化时间为-1 Queue<Pair<Integer, Integer>> q = new LinkedList<>(); // 将BFS过程提取为单独的一个方法 void bfs() { while (!q.isEmpty()){ time++; // 每遍历一层时间+1 int size = q.size(); // 取出这一层的烂橘子开始遍历 while (size-- > 0){ Pair<Integer, Integer> t = q.poll(); int x = t.getKey(); int y = t.getValue(); for (int k = 0; k < 4; k++){ // 开始扩散 int xx = x + dx[k], yy = y + dy[k]; if (xx >= 0 && xx < n && yy >= 0 && yy < m && g[xx][yy] == 1){ fresh--; q.offer(new Pair<>(xx, yy)); g[xx][yy] = 2; // 标记变成烂橘子 } } } } } public int orangesRotting(int[][] g) { n = g.length; m = g[0].length; this.g = g; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (g[i][j] == 1){ fresh++; // 统计新鲜橘子数 } else if (g[i][j] == 2){ q.offer(new Pair<>(i, j)); // 将初始的烂橘子入队 } } } bfs(); return fresh > 0 ? -1 : Math.max(time, 0); } }\",\"更简洁的写法 - 使用数组列表作为队列（推荐）\",\"class Solution { int dd[][] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; // 四个方向 public int orangesRotting(int[][] g) { int n = g.length; int m = g[0].length; int fresh = 0; List<int[]> q = new ArrayList<>(); for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (g[i][j] == 1) fresh++; // 统计新鲜橘子个数 else if (g[i][j] == 2) q.add(new int[]{i, j}); // 初始的烂橘子 } } int time = -1; while (!q.isEmpty()) { time++; // 经过一分钟 List<int[]> tmp = q; // 取出当前最外层的烂橘子 q = new ArrayList<>(); // 记录下一层被扩散的烂橘子 for (int[] pos : tmp) { // 开始扩散 for (int[] d : dd) { int i = pos[0] + d[0]; int j = pos[1] + d[1]; if (0 <= i && i < n && 0 <= j && j < m && g[i][j] == 1) { fresh--; g[i][j] = 2; // 标记变成烂橘子 q.add(new int[]{i, j}); // 加入新的一层 } } } } return fresh > 0 ? -1 : Math.max(time, 0); } }\"]},\"871\":{\"c\":[\"hot100\",\"图论\"]},\"872\":{\"c\":[\"BFS\"]},\"873\":{\"h\":\"课程表\",\"t\":[\"207.课程表\"]},\"874\":{\"h\":\"题意\",\"t\":[\"你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。\",\"在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i]=[ai​,bi​] ，表示如果要学习课程 ai​ 则 必须 先学习课程 bi​ 。\",\"例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\"]},\"875\":{\"h\":\"思路\",\"t\":[\"判断条件：当存在循环依赖的时候，无法完成所有课程。\",\"比如：prerequisites = [[1,0],[0,1]]，在学习课程 1 之前，需要先完成​课程 0 ；并且学习课程 0 之前，还应先完成课程 1 。产生了循环依赖，所以不可能完成所有课程。\",\"所以，我们可以把题目的输入转化成一幅有向图，然后再判断图中是否存在环。\",\"使用邻接表建图：\",\"List<Integer>[] g; List<Integer>[] buildGraph(int n, int[][] edges) { // 图中共有 n 个节点 List<Integer>[] graph = new LinkedList[nu]; for (int i = 0; i < n; i++) { g[i] = new LinkedList<>(); } for (int[] edge : edges) { int from = edge[1], to = edge[0]; // 添加一条从 from 指向 to 的有向边 g[from].add(to); } return g; }\",\"接下来，遍历建好的图。\",\"要注意到图中并不一定所有节点都相连，所以要用一个 for 循环将所有节点都作为起点调用一次 DFS 搜索，用数组 st 标记所有走过的点，用数组 onPath 标记当前节点搜索时遍历过的节点，即路径节点，在搜索完当前所能走到的所有节点后，回退状态，以便给其他节点搜索。\",\"在一次搜索中，只要发现该节点已经被 onPath 标记了，表示回到了起点，成了一个环，那么就不满足条件，返回 false，否则返回 true。\"]},\"876\":{\"h\":\"代码\",\"t\":[\"class Solution { boolean onPath[]; // 记录一次DFS经过的节点 boolean st[]; // 记录遍历过的节点 boolean hasCycle = false; // 记录图中是否有环 void dfs(List<Integer>[] g, int x) { if (onPath[x]){ hasCycle = true; // 如果当前节点走过了，表示出现了环 } // 如果找到了环，就不用遍历了 if (st[x] || hasCycle) return; st[x] = true; onPath[x] = true; // 标记走过 for (int t : g[x]){ dfs(g, t); // 递归遍历 } onPath[x] = false; // 恢复现场 } // n为选修课程数，edges为先修课程关系 public boolean canFinish(int n, int[][] edges) { st = new boolean[n]; onPath = new boolean[n]; // 邻接表建图 g[a] -> b List<Integer>[] g = new LinkedList[n]; for (int i = 0; i < n; i++) g[i] = new LinkedList<>(); for (int[] edge : edges){ int from = edge[1]; int to = edge[0]; g[from].add(to); } for (int i = 0; i < n; i++){ dfs(g, i); } return !hasCycle; } }\"]},\"877\":{\"c\":[\"hot100\",\"图论\"]},\"878\":{\"c\":[\"DFS\"]},\"879\":{\"h\":\"路径总和 III\",\"t\":[\"437.路径总和 III\"]},\"880\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。\",\"路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\"]},\"881\":{\"h\":\"思路\",\"t\":[\"运用前缀和的思想，前缀和相当于从根节点开始的路径元素和。对二叉树进行递归遍历，同时用哈希表 cnt 统计从根节点到当前节点的路径上各个前缀和出现的次数。当我们递归到节点 node 时，设从根到 node 的路径元素和为 s，那么就找到了 cnt[s − targetSum] 个符合要求的路径，加入答案。\",\"设计递归函数 dfs(node,s)，表示当前遍历到的节点为 node，从根节点到当前节点的路径上的前缀和为 s。函数的返回值是统计以 node 节点及其子树节点作为路径终点且路径和为 targetSum 的路径数目。那么答案就是 dfs(root,0)。\"]},\"882\":{\"h\":\"代码\",\"t\":[\"class Solution { int targetSum; Map<Long, Integer> cnt = new HashMap<>(); int dfs(TreeNode root, long s){ if (root == null) return 0; s += root.val; int ans = cnt.getOrDefault(s - targetSum, 0); cnt.merge(s, 1, Integer::sum); ans += dfs(root.left, s); ans += dfs(root.right, s); cnt.merge(s, -1, Integer::sum); return ans; } public int pathSum(TreeNode root, int targetSum) { cnt.put(0L, 1); this.targetSum = targetSum; return dfs(root, 0); } }\"]},\"883\":{\"c\":[\"hot100\",\"数据结构\"]},\"884\":{\"c\":[\"二叉树\",\"递归\",\"前缀和\",\"哈希\"]},\"885\":{\"h\":\"随机链表的复制\",\"t\":[\"138.随机链表的复制\"]},\"886\":{\"h\":\"题意\",\"t\":[\"给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\",\"构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\",\"例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。\",\"返回复制链表的头节点。\",\"用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\",\"val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。\"]},\"887\":{\"h\":\"思路一：哈希表\",\"t\":[\"对于数据结构复制，记住最简单的方式：一个哈希表 + 两次遍历。\",\"第一次遍历专门克隆节点，借助哈希表把原始节点和克隆节点的映射存储起来；第二次专门组装节点，照着原数据结构的样子，把克隆节点的指针组装起来。\",\"题目如果让你克隆带随机指针的二叉树，或者克隆图，都是一样的，只不过是遍历的方式从 for 循环迭代遍历变成 traverse 递归函数遍历罢了。\",\"若头节点 head 为空节点，直接返回 null 。\",\"初始化： 哈希表 map ， 节点 cur 指向头节点。\",\"复制链表：\",\"建立新节点，并向 map 添加键值对 (原 cur 节点, 新 cur 节点)。\",\"cur 遍历至原链表下一节点。\",\"构建新链表的引用指向：\",\"构建新节点的 next 和 random 引用指向。\",\"cur 遍历至原链表下一节点。\",\"返回值： 新链表的头节点 map[cur] 。\",\"代码：\",\"class Solution { public Node copyRandomList(Node head) { if (head == null) return null; Node cur = head; Map<Node, Node> map = new HashMap<>(); // 第一次复制，并建立 “原节点 -> 新节点” 的 Map 映射 while(cur != null) { map.put(cur, new Node(cur.val)); cur = cur.next; } cur = head; // 第二次复制，构建新链表的 next 和 random 指向 while(cur != null) { map.get(cur).next = map.get(cur.next); map.get(cur).random = map.get(cur.random); cur = cur.next; } // 返回新链表的头节点 return map.get(head); } }\"]},\"888\":{\"h\":\"思路二：拼接 + 拆分\",\"t\":[\"相比于使用哈希表，这种做法可以降低空间复杂度\",\"考虑构建 原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。\",\"构建拼接链表\",\"复制 random 指针：当访问原节点 p 的随机指向节点 p.random 时，对应新节点 q.next 的随机指向节点为 p.random.next 。\",\"拆分两个链表：设置 p / cur 分别指向原 / 新链表头节点，遍历执行 p.next = p.next.next 和 cur.next = cur.next.next 将两链表拆分开。\",\"返回新链表的头节点 dummy.next 即可。\",\"class Solution { public Node copyRandomList(Node head) { // 复制每个节点，并将原链表和复制链表连在一起。 for(Node p = head; p != null; p = p.next.next) { Node q = new Node(p.val); q.next = p.next; p.next = q; } // 复制random指针 for(Node p = head; p != null; p = p.next.next) { if(p.random != null) p.next.random = p.random.next; } //拆分两个链表，并复原原链表 Node dummy = new Node(-1), cur = dummy; for(Node p = head; p != null; p = p.next) { Node q = p.next; cur = cur.next = q; p.next = q.next; } return dummy.next; } }\"]},\"889\":{\"c\":[\"hot100\",\"数据结构\"]},\"890\":{\"c\":[\"链表\"]},\"891\":{\"h\":\"零钱兑换\",\"t\":[\"322.零钱兑换\"]},\"892\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\",\"计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\",\"你可以认为每种硬币的数量是无限的。\"]},\"893\":{\"h\":\"思路一：完全背包\",\"t\":[\"完全背包：有 n 件物品，背包容量为 m ，每件物品只能使用无限次。\",\"本题翻译过来：有 n 个硬币，每个硬币都可以使用无限次，总金额为 m，求组成总金额所需的最少硬币数。\",\"定义 f[i][j]：表示从前 i 个硬币中选一些硬币（可以重复选），满足总金额恰好等于 j，最少要选的硬币个数。\",\"考虑第 i 个硬币选或不选：\",\"不选：问题变成从前 i−1 个硬币中选一些硬币（可以重复选），满足总金额恰好等于 j，最少要选的硬币个数，即 f[i][j] = f[i - 1][j]。\",\"选：前提是 coins[i]≥j。问题变成从前 i 个硬币中选一些硬币（可以重复选），满足总金额恰好等于 j−coins[i]，最少要选的硬币个数，即 f[i][j] = f[i][j - coins[i] + 1。注意这里是 i 而不是 i−1，因为我们可以重复选第 i 个硬币。\",\"这两种情况取最小值，就得到了答案，即 f[n][amount]。\",\"代码：\",\"class Solution { public int coinChange(int[] coins, int amount) { int n = coins.length; int[][] f = new int[n + 1][amount + 1]; Arrays.fill(f[0], Integer.MAX_VALUE / 2); f[0][0] = 0; // 这里从 0 开始遍历，整体 i + 1 for (int i = 0; i < n; i++){ for (int j = 0; j <= amount; j++){ if (j < coins[i]) f[i + 1][j] = f[i][j]; else f[i + 1][j] = Math.min(f[i][j], f[i + 1][j - coins[i]] + 1); } } int res = f[n][amount]; if (res >= Integer.MAX_VALUE / 2) res = -1; return res; } }\"]},\"894\":{\"h\":\"思路二：空间优化\",\"t\":[\"因为 f[i] 的状态只与 f[i -1] 有关，所以完全可以只使用两个数组（滚动数组）来优化空间。\",\"class Solution { public int coinChange(int[] coins, int amount) { int n = coins.length; int[][] f = new int[2][amount + 1]; Arrays.fill(f[0], Integer.MAX_VALUE / 2); f[0][0] = 0; for (int i = 0; i < n; i++) { for (int c = 0; c <= amount; c++) { if (c < coins[i]) f[(i + 1) % 2][c] = f[i % 2][c]; else f[(i + 1) % 2][c] = Math.min(f[i % 2][c], f[(i + 1) % 2][c - coins[i]] + 1); } } int ans = f[n % 2][amount]; return ans < Integer.MAX_VALUE / 2 ? ans : -1; } }\",\"通过观察，可以发现，对于某一个硬币 coins[i]，其 i 是固定的，每一次讨论都只有选与不选两种选择，因此可以将原来的二维数组压缩至一维数组。\",\"class Solution { public int coinChange(int[] coins, int amount) { int[] f = new int[amount + 1]; Arrays.fill(f, Integer.MAX_VALUE / 2); f[0] = 0; for (int x : coins) { for (int c = x; c <= amount; c++) { f[c] = Math.min(f[c], f[c - x] + 1); } } int ans = f[amount]; return ans < Integer.MAX_VALUE / 2 ? ans : -1; } }\"]},\"895\":{\"c\":[\"hot100\",\"动态规划\"]},\"896\":{\"c\":[\"背包问题\"]},\"897\":{\"h\":\"验证二叉搜索树\",\"t\":[\"98.验证二叉搜索树\"]},\"898\":{\"h\":\"题意\",\"t\":[\"给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\",\"有效 二叉搜索树定义如下：\",\"节点的左子树只包含 小于 当前节点的数。\",\"节点的右子树只包含 大于 当前节点的数。\",\"所有左子树和右子树自身必须也是二叉搜索树。\"]},\"899\":{\"h\":\"思路一：前序遍历\",\"t\":[\"由题意可知：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。\",\"使用递归前序遍历，使用递归函数 isValidBST(node, l, r) 来判断，判断以 node 为根的子树，其所有的节点是否都在 (l,r) 的范围内，如果不在则直接返回。\",\"在递归调用左子树时，需要把上界 r 改为 node.val，因为左子树的所有节点都要小于根节点的值，所以可以缩小比较范围；同理，右子树下界 l 也改为 node.val.\",\"注意区间范围\",\"我们写的递归函数，判断区间为 (l,r)，注意是开区间，而节点的值范围在 [−231,231−1] 之间。\",\"本来看都是 int 类型，想当然地初始化上下界为 [Integer.MIN_VALUE, Integer.MAX_VALUE]，但是如果数据给的 root.val = 2147483647，即 231−1，会导致边界问题，判断 x < right 会出错，因为 Ingeger.MAX_VALUE = 231−1，两者相等，所以初始化范围还要更大些，故使用 Long 类型。\",\"前序遍历在某些数据下不需要递归到叶子节点就能返回（比如根节点左儿子的值大于根节点的值，左儿子就不会继续往下递归了），而中序遍历和后序遍历至少要递归到一个叶子节点。从这个角度上来说，前序遍历是最快的。\",\"代码：\",\"class Solution { boolean isValidBST(TreeNode node, long left, long right) { if (node == null) return true; int x = node.val; return left < x && x < right && isValidBST(node.left, left, x) && isValidBST(node.right, x, right); } public boolean isValidBST(TreeNode root) { return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } }\"]},\"900\":{\"h\":\"思路二：中序遍历\",\"t\":[\"中序遍历即层序遍历，先遍历左节点，再遍历根节点，最后遍历右子树。\",\"根据题意可知中序遍历得到的序列一定是升序的。所以我们在遍历的时候实时检查当前节点的值是否大于前一个遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。\",\"中序遍历很好地利用了二叉搜索树的性质，使用到的变量最少。\",\"代码：\",\"class Solution { long pre = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } if (!isValidBST(root.left) || root.val <= pre) { return false; } pre = root.val; return isValidBST(root.right); } }\"]},\"901\":{\"h\":\"思路三：后序遍历\",\"t\":[\"后序遍历先遍历左右子树，最后遍历根节点，即自底向上计算子问题的过程。\",\"需要遍历整棵树，先找到左右叶子节点，再一层层向上递归判断。\",\"代码：\",\"class Solution { long[] dfs(TreeNode node) { if (node == null) { return new long[]{Long.MAX_VALUE, Long.MIN_VALUE}; } long[] left = dfs(node.left); long[] right = dfs(node.right); long x = node.val; // 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了 if (right[0] <= x || x <= left[1]) { return new long[]{Long.MIN_VALUE, Long.MAX_VALUE}; } return new long[]{Math.min(left[0], x), Math.max(right[1], x)}; } public boolean isValidBST(TreeNode root) { return dfs(root)[1] != Long.MAX_VALUE; } }\"]},\"902\":{\"c\":[\"hot100\",\"数据结构\"]},\"903\":{\"c\":[\"二叉树\",\"递归\"]},\"904\":{\"h\":\"MySQL 基础知识\"},\"905\":{\"h\":\"1. 基础\"},\"906\":{\"h\":\"1.1 连接\",\"t\":[\"MySQL服务器启动完毕后，然后再使用如下指令，来连接 MySQL 服务器：\",\"mysql -u用户名 -p密码 [-h数据库服务器的IP地址 -P端口号]\",\"命令解释\",\"-h 参数不加，默认连接的是本地 127.0.0.1 的 MySQL 服务器\",\"-P 参数不加，默认连接的端口号是 3306\",\"上述指令，可以有两种形式：\",\"密码直接在 -p 参数之后直接指定 （这种方式不安全，密码直接以明文形式出现在命令行）\",\"密码在 -p 回车之后，在命令行中输入密码，然后回车\"]},\"907\":{\"h\":\"1.2 SQL 简介\",\"t\":[\"SQL：结构化查询语言。一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\"]},\"908\":{\"h\":\"1.2.1 SQL 通用语法\",\"t\":[\"1、SQL 语句可以单行或多行书写，以分号结尾。\",\"2、SQL 语句可以使用空格/缩进来增强语句的可读性。\",\"3、MySQL 数据库的 SQL 语句不区分大小写。\",\"4、注释：\",\"单行注释：-- 注释内容或 # 注释内容 (MySQL特有)\",\"多行注释： /* 注释内容 */\"]},\"909\":{\"h\":\"1.2.2 分类\",\"t\":[\"SQL 语句根据其功能被分为四大类：DDL、DML、DQL、DCL\",\"分类\",\"全称\",\"说明\",\"DDL\",\"Data Definition Language\",\"数据定义语言，用来定义数据库对象(数据库，表，字段)\",\"DML\",\"Data Manipulation Language\",\"数据操作语言，用来对数据库表中的数据进行增删改\",\"DQL\",\"Data Query Language\",\"数据查询语言，用来查询数据库中表的记录\",\"DCL\",\"Data Control Language\",\"数据控制语言，用来创建数据库用户、控制数据库的访问权限\"]},\"910\":{\"h\":\"2. 数据库设计-DDL\",\"t\":[\"针对于数据库设计，主要包括三个阶段：\",\"数据库设计阶段 \",\"参照页面原型以及需求文档设计数据库表结构\",\"数据库操作阶段 \",\"根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作\",\"数据库优化阶段 \",\"通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等\"]},\"911\":{\"h\":\"2.1 数据库操作\",\"t\":[\"DDL 英文全称是 Data Definition Language (数据定义语言)，用来定义数据库对象(数据库、表)。\",\"DDL 中数据库的常见操作：查询、创建、使用、删除。\"]},\"912\":{\"h\":\"2.1.1 查询数据库\",\"t\":[\"查询所有数据库：\",\"show databases;\",\"查询当前数据库：\",\"select database();\",\"用法\",\"我们要操作某一个数据库，必须要切换到对应的数据库中。\",\"通过指令 select database()，就可以查询到当前所处的数据库\"]},\"913\":{\"h\":\"2.1.2 创建数据库\",\"t\":[\"语法：\",\"create database [ if not exists ] 数据库名;\",\"注意：在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。\",\"可以使用 if not exists 来避免这个问题\",\"-- 数据库不存在,则创建该数据库；如果存在则不创建 create database if not extists my_database;\"]},\"914\":{\"h\":\"2.1.3 使用数据库\",\"t\":[\"语法：\",\"use 数据库名 ;\",\"切换数据库\",\"我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则不能操作。\"]},\"915\":{\"h\":\"2.1.4 删除数据库\",\"t\":[\"语法：\",\"drop database [ if exists ] 数据库名 ;\",\"如果删除一个不存在的数据库，将会报错。\",\"可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\",\"案例：删除 itcast 数据库\",\"drop database if exists itcast; -- itcast数据库存在时删除\",\"命令执行效果如下：\",\"说明\",\"上述语法中的 database，也可以替换成 schema\",\"如：create schema db01;\",\"如：show schemas;\"]},\"916\":{\"h\":\"2.2 表操作\",\"t\":[\"关于表结构的操作也是包含四个部分：创建表、查询表、修改表、删除表。\"]},\"917\":{\"h\":\"2.2.1 创建\"},\"918\":{\"h\":\"2.2.1.1 语法\",\"t\":[\"create table 表名( 字段1 字段1类型 [约束] [comment 字段1注释 ], 字段2 字段2类型 [约束] [comment 字段2注释 ], ...... 字段n 字段n类型 [约束] [comment 字段n注释 ] ) [ comment 表注释 ] ;\",\"注意： [ ] 中的内容为可选参数； 最后一个字段后面没有逗号\"]},\"919\":{\"h\":\"2.2.1.2 约束\",\"t\":[\"概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。\",\"作用：就是来保证数据库当中数据的正确性、有效性和完整性。\",\"在MySQL数据库当中，提供了以下5种约束：\",\"约束\",\"描述\",\"关键字\",\"非空约束\",\"限制该字段值不能为null\",\"not null\",\"唯一约束\",\"保证字段的所有数据都是唯一、不重复的\",\"unique\",\"主键约束\",\"主键是一行数据的唯一标识，要求非空且唯一\",\"primary key\",\"默认约束\",\"保存数据时，如果未指定该字段值，则采用默认值\",\"default\",\"外键约束\",\"让两张表的数据建立连接，保证数据的一致性和完整性\",\"foreign key\",\"注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。\",\"MySQL数据库为解决id问题，提供了一个关键字：auto_increment（自动增长）\",\"主键自增：auto_increment\",\"每次插入新的行记录时，数据库自动生成 id 字段(主键)下的值\",\"具有 auto_increment 的数据列是一个正数序列开始增长(从 1 开始自增)\"]},\"920\":{\"h\":\"2.2.1.3 数据类型\",\"t\":[\"MySQL中的数据类型主要分为三类：数值类型、字符串类型、日期时间类型。\",\"数值类型\",\"类型\",\"大小\",\"有符号(SIGNED)范围\",\"无符号(UNSIGNED)范围\",\"描述\",\"TINYINT\",\"1byte\",\"(-128，127)\",\"(0，255)\",\"小整数值\",\"SMALLINT\",\"2bytes\",\"(-32768，32767)\",\"(0，65535)\",\"大整数值\",\"MEDIUMINT\",\"3bytes\",\"(-8388608，8388607)\",\"(0，16777215)\",\"大整数值\",\"INT/INTEGER\",\"4bytes\",\"(-2147483648，2147483647)\",\"(0，4294967295)\",\"大整数值\",\"BIGINT\",\"8bytes\",\"(-263，263-1)\",\"(0，2^64-1)\",\"极大整数值\",\"FLOAT\",\"4bytes\",\"(-3.402823466 E+38，3.402823466351 E+38)\",\"0 和 (1.175494351 E-38，3.402823466 E+38)\",\"单精度浮点数值\",\"DOUBLE\",\"8bytes\",\"(-1.7976931348623157 E+308，1.7976931348623157 E+308)\",\"0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)\",\"双精度浮点数值\",\"DECIMAL\",\"依赖于M(精度)和D(标度)的值\",\"依赖于M(精度)和D(标度)的值\",\"小数值(精确定点数)\",\"字符串类型\",\"类型\",\"大小\",\"描述\",\"CHAR\",\"0-255 bytes\",\"定长字符串(需要指定长度)\",\"VARCHAR\",\"0-65535 bytes\",\"变长字符串(需要指定长度)\",\"TINYBLOB\",\"0-255 bytes\",\"不超过255个字符的二进制数据\",\"TINYTEXT\",\"0-255 bytes\",\"短文本字符串\",\"BLOB\",\"0-65 535 bytes\",\"二进制形式的长文本数据\",\"TEXT\",\"0-65 535 bytes\",\"长文本数据\",\"MEDIUMBLOB\",\"0-16 777 215 bytes\",\"二进制形式的中等长度文本数据\",\"MEDIUMTEXT\",\"0-16 777 215 bytes\",\"中等长度文本数据\",\"LONGBLOB\",\"0-4 294 967 295 bytes\",\"二进制形式的极大文本数据\",\"LONGTEXT\",\"0-4 294 967 295 bytes\",\"极大文本数据\",\"char 与 varchar 都可以描述字符串，char 是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。 而 varchar 是变长字符串，指定的长度为最大占用长度 。相对来说，char 的性能会更高些。\",\"示例： 用户名 username ---长度不定, 最长不会超过50 username varchar(50) 手机号 phone ---固定长度为11 phone char(11)\",\"日期时间类型\",\"类型\",\"大小\",\"范围\",\"格式\",\"描述\",\"DATE\",\"3\",\"1000-01-01 至 9999-12-31\",\"YYYY-MM-DD\",\"日期值\",\"TIME\",\"3\",\"-838:59:59 至 838:59:59\",\"HH:MM:SS\",\"时间值或持续时间\",\"YEAR\",\"1\",\"1901 至 2155\",\"YYYY\",\"年份值\",\"DATETIME\",\"8\",\"1000-01-01 00:00:00 至 9999-12-31 23:59:59\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值\",\"TIMESTAMP\",\"4\",\"1970-01-01 00:00:01 至 2038-01-19 03:14:07\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值，时间戳\"]},\"921\":{\"h\":\"2.2.2 查询\",\"t\":[\"查询当前数据库所有表\",\"show tables;\",\"查看指定表结构\",\"desc 表名 ; #可以查看指定表的字段、字段的类型、是否可以为NULL、是否存在默认值等信息\",\"查询指定表的建表语句\",\"show create table 表名 ;\"]},\"922\":{\"h\":\"2.2.3 修改\",\"t\":[\"添加字段\",\"alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];\",\"案例： 为 tb_emp 表添加字段 qq，字段类型为 varchar(11)\",\"alter table tb_emp add qq varchar(11) comment 'QQ号码';\",\"修改数据类型\",\"alter table 表名 modify 字段名 新数据类型(长度);\",\"alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];\",\"案例：修改 qq 字段名为 qq_num，字段类型 varchar(13)\",\"alter table tb_emp change qq qq_num varchar(13) comment 'QQ号码';\",\"删除字段\",\"alter table 表名 drop 字段名;\",\"修改表名\",\"rename table 表名 to 新表名;\"]},\"923\":{\"h\":\"2.2.4 删除\",\"t\":[\"删除表语法：\",\"drop table [ if exists ] 表名;\",\"if exists ：只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。\"]},\"924\":{\"h\":\"3. 数据库操作-DML\",\"t\":[\"DML英文全称是 Data Manipulation Language (数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\",\"添加数据（INSERT）\",\"修改数据（UPDATE）\",\"删除数据（DELETE）\"]},\"925\":{\"h\":\"3.1 增加 (insert)\",\"t\":[\"insert 语法：\",\"向指定字段添加数据\",\"insert into 表名 (字段名1, 字段名2) values (值1, 值2);\",\"全部字段添加数据\",\"insert into 表名 values (值1, 值2, ...);\",\"批量添加数据（指定字段）\",\"insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2);\",\"批量添加数据（全部字段）\",\"insert into 表名 values (值1, 值2, ...), (值1, 值2, ...);\",\"Insert 操作的注意事项：\",\"插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\",\"字符串和日期型数据应该包含在引号中。\",\"插入的数据大小，应该在字段的规定范围内。\"]},\"926\":{\"h\":\"3.2 修改 (update)\",\"t\":[\"update 语法：\",\"update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [where 条件] ;\",\"案例：将 tb_emp 表中 id 为 1 的员工，姓名 name 字段更新为'张三'\",\"update tb_emp set name='张三',update_time=now() where id=1;\",\"注意事项\",\"修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\",\"在修改数据时，一般需要同时修改公共字段 update_time，将其修改为当前操作时间。\"]},\"927\":{\"h\":\"3.3 删除 (delete)\",\"t\":[\"delete 语法：\",\"delete from 表名 [where 条件] ;\",\"注意事项\",\"DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\",\"DELETE 语句不能删除某一个字段的值(可以使用 UPDATE，将该字段值置为 NULL 即可)。\",\"当进行删除全部数据操作时，会提示询问是否确认删除所有数据，直接点击 Execute 即可。\"]},\"928\":{\"h\":\"4. 数据库操作-DQL\"},\"929\":{\"h\":\"4.1 语法\",\"t\":[\"DQL 查询语句，语法结构如下：\",\"SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数\",\"查询分为以下几种类型：\",\"基本查询（不带任何条件）\",\"条件查询（where）\",\"分组查询（group by）\",\"排序查询（order by）\",\"分页查询（limit）\"]},\"930\":{\"h\":\"4.2 基本查询\",\"t\":[\"在基本查询的 DQL 语句中，不带任何的查询条件，语法如下：\",\"查询多个字段\",\"select 字段1, 字段2, 字段3 from 表名;\",\"查询所有字段（通配符）\",\"select * from 表名;\",\"设置别名\",\"select 字段1 [ as 别名1 ] , 字段2 [ as 别名2 ] from 表名;\",\"去除重复记录\",\"select distinct 字段列表 from 表名;\"]},\"931\":{\"h\":\"4.3 条件查询\",\"t\":[\"语法：\",\"select 字段列表 from 表名 where 条件列表 ; -- 条件列表：意味着可以有多个条件\",\"在SQL语句当中构造条件的运算符分为两类：\",\"比较运算符\",\"逻辑运算符\",\"常用的比较运算符如下:\",\"比较运算符\",\"功能\",\">\",\"大于\",\">=\",\"大于等于\",\"<\",\"小于\",\"<=\",\"小于等于\",\"=\",\"等于\",\"<> 或 !=\",\"不等于\",\"between ... and ...\",\"在某个范围之内(含最小、最大值)\",\"in(...)\",\"在in之后的列表中的值，多选一\",\"like 占位符\",\"模糊匹配(_匹配单个字符, %匹配任意个字符)\",\"is null\",\"是null\",\"常用的逻辑运算符如下:\",\"逻辑运算符\",\"功能\",\"and 或 &&\",\"并且 (多个条件同时成立)\",\"or 或 ||\",\"或者 (多个条件任意一个成立)\",\"not 或 !\",\"非 , 不是\"]},\"932\":{\"h\":\"4.4 聚合函数\",\"t\":[\"使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）\",\"语法：\",\"select 聚合函数(字段列表) from 表名 ;\",\"注意 : 聚合函数会忽略空值，对NULL值不作为统计。\",\"常用聚合函数：\",\"函数\",\"功能\",\"count\",\"统计数量\",\"max\",\"最大值\",\"min\",\"最小值\",\"avg\",\"平均值\",\"sum\",\"求和\",\"说明\",\"count ：按照列去统计有多少行数据。\",\"在根据指定的列统计的时候，如果这一列中有 null 的行，该行不会被统计在其中。\",\"sum ：计算指定列的数值和，如果不是数值类型，那么计算结果为0\",\"max ：计算指定列的最大值\",\"min ：计算指定列的最小值\",\"avg ：计算指定列的平均值\"]},\"933\":{\"h\":\"4.5 分组查询\",\"t\":[\"分组： 按照某一列或者某几列，把相同的数据进行合并输出。\",\"分组其实就是按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。\",\"分组查询通常会使用聚合函数进行计算。\",\"语法：\",\"select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\",\"注意事项\",\"分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\",\"执行顺序：where > 聚合函数 > having\",\"where 与 having 区别（面试题）\",\"执行时机不同：where 是分组之前进行过滤，不满足 where 条件，不参与分组；而 having 是分组之后对结果进行过滤。\",\"判断条件不同：where 不能对聚合函数进行判断，而 having 可以。\"]},\"934\":{\"h\":\"4.6 排序查询\",\"t\":[\"排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\",\"语法：\",\"select 字段列表 from 表名 [where 条件列表] [group by 分组字段 ] order by 字段1 排序方式1 , 字段2 排序方式2 … ;\",\"排序方式：\",\"ASC ：升序（默认值）\",\"DESC：降序\",\"注意事项：如果是升序, 可以不指定排序方式ASC\"]},\"935\":{\"h\":\"4.7 分页查询\",\"t\":[\"分页操作在业务系统开发时，也是非常常见的一个功能，日常我们在网站中看到的各种各样的分页条，后台也都需要借助于数据库的分页操作。\",\"分页查询语法：\",\"select 字段列表 from 表名 limit 起始索引, 查询记录数 ;\",\"注意事项\",\"起始索引从 0 开始。\",\"计算公式：起始索引 = （查询页码 - 1）* 每页显示记录数\",\"分页查询是数据库的方言，不同的数据库有不同的实现，MySQL 中是 LIMIT\",\"如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 条数\",\"前端查询数据库的流程：\",\"前端在请求服务端时，传递的参数 \",\"当前页码 page\",\"每页显示条数 pageSize\",\"后端需要响应什么数据给前端 \",\"所查询到的数据列表（存储到 List 集合中）\",\"总记录数\",\"示例\",\"后台给前端返回的数据包含：List 集合（数据列表）、total（总记录数）\",\"当数据量较大时，通常封装到 PageBean 对象中，并将该对象转换为 json 格式的数据响应回给浏览器。\",\"@Data @NoArgsConstructor @AllArgsConstructor public class PageBean { private Long total; // 总记录数 private List rows; // 当前页数据列表 }\"]},\"936\":{\"h\":\"5. 多表设计\",\"t\":[\"项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\",\"一对多（多对一）\",\"多对多\",\"一对一\"]},\"937\":{\"h\":\"5.1 一对多 - 外键约束\",\"t\":[\"一对多关系实现：在数据库表中多的一方，添加字段，来关联属于一这方的主键。\",\"外键约束：让两张表的数据建立连接，保证数据的一致性和完整性。\",\"对应的关键字：foreign key\",\"语法：\",\"-- 创建表时指定 create table 表名( 字段名 数据类型, ... [constraint] [外键名称] foreign key (外键字段名) references 主表 (主表列名) ); -- 建完表后，添加外键 alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);\",\"物理外键和逻辑外键\",\"物理外键\",\"概念：使用 foreign key 定义外键关联另外一张表。\",\"缺点： \",\"影响增、删、改的效率（需要检查外键关系）。\",\"仅用于单节点数据库，不适用与分布式、集群场景。\",\"容易引发数据库的死锁问题，消耗性能。\",\"逻辑外键\",\"概念：在业务层逻辑中，解决外键关联。\",\"通过逻辑外键，就可以很方便的解决上述问题。\",\"在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key\"]},\"938\":{\"h\":\"5.2 一对一\",\"t\":[\"一对一关系表在实际开发中应用起来比较简单，通常是用来做单表的拆分，也就是将一张大表拆分成两张小表，将大表中的一些基础字段放在一张表当中，将其他的字段放在另外一张表当中，以此来提高数据的操作效率。\",\"一对一的应用场景：用户表(基本信息+身份信息)\",\"基本信息：用户的ID、姓名、性别、手机号、学历\",\"身份信息：民族、生日、身份证号、身份证签发机关，身份证的有效期(开始时间、结束时间)\",\"如果在业务系统当中，对用户的基本信息查询频率特别的高，但是对于用户的身份信息查询频率很低，此时出于提高查询效率的考虑，可以将这张大表拆分成两张小表，第一张表存放的是用户的基本信息，而第二张表存放的就是用户的身份信息。他们两者之间一对一的关系，一个用户只能对应一个身份证，而一个身份证也只能关联一个用户。\",\"那么在数据库层面怎么去体现上述两者之间是一对一的关系呢？\",\"其实一对一我们可以看成一种特殊的一对多。一对多我们是怎么设计表关系的？是不是在多的一方添加外键。同样我们也可以通过外键来体现一对一之间的关系，我们只需要在任意一方来添加一个外键就可以了。\",\"一对一 ：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的 (UNIQUE)\"]},\"939\":{\"h\":\"5.3 多对多\",\"t\":[\"多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。\",\"案例：学生与课程的关系\",\"关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\",\"实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\"]},\"940\":{\"h\":\"6. 多表查询\"},\"941\":{\"h\":\"6.1 概述\"},\"942\":{\"h\":\"6.1.1 介绍\",\"t\":[\"多表查询：查询时从多张表中获取所需数据\",\"多表查询\",\"单表查询的 SQL 语句：select 字段列表 from 表名;\",\"那么要执行多表查询，只需要使用逗号分隔多张表即可，如：select 字段列表 from 表1, 表2;\",\"查询用户表和部门表中的数据：\",\"select * from tb_emp , tb_dept;\",\"笛卡尔积：笛卡尔乘积是指在数学中，两个集合（A 集合和 B 集合）的所有组合情况。\",\"在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据。\",\"在查询时给多表查询加上连接查询的条件：\",\"select * from tb_emp , tb_dept where tb_emp.dept_id = tb_dept.id ;\"]},\"943\":{\"h\":\"6.1.2 分类\",\"t\":[\"多表查询可以分为：\",\"连接查询\",\"内连接：相当于查询 A、B 交集部分数据\",\"外连接\",\"左外连接：查询左表所有数据(包括两张表交集部分数据)\",\"右外连接：查询右表所有数据(包括两张表交集部分数据)\",\"子查询\"]},\"944\":{\"h\":\"6.3 内连接\",\"t\":[\"内连接查询：查询两表或多表中交集部分数据。\",\"内连接从语法上可以分为：\",\"隐式内连接\",\"显式内连接\",\"隐式内连接语法：\",\"select 字段列表 from 表1 , 表2 where 条件 ... ;\",\"显式内连接语法：\",\"select 字段列表 from 表1 [ inner ] join 表2 on 连接条件 ... ;\",\"多表查询时给表起别名：\",\"- tableA as 别名1, tableB as 别名2 ; - tableA 别名1, tableB 别名2 ;\",\"注意事项\",\"一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\"]},\"945\":{\"h\":\"6.3 外连接\",\"t\":[\"外连接分为两种：左外连接 和 右外连接。\",\"左外连接语法结构：\",\"select 字段列表 from 表1 left [ outer ] join 表2 on 连接条件 ... ;\",\"左外连接相当于查询表1（左表）的所有数据，当然也包含表1和表2交集部分的数据。\",\"右外连接语法结构：\",\"select 字段列表 from 表1 right [ outer ] join 表2 on 连接条件 ... ;\",\"右外连接相当于查询表2（右表）的所有数据，当然也包含表1和表2交集部分的数据。\",\"注意事项\",\"左外连接和右外连接是可以相互替换的，只需要调整连接查询时 SQL 语句中表的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\"]},\"946\":{\"h\":\"6.4 子查询\"},\"947\":{\"h\":\"6.4.1 介绍\",\"t\":[\"SQL 语句中嵌套 select 语句，称为嵌套查询，又称子查询。\",\"SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 ... );\",\"子查询外部的语句可以是 insert / update / delete / select 的任何一个，最常见的是 select.\",\"根据子查询结果的不同分为：\",\"标量子查询（子查询结果为单个值「一行一列」）\",\"列子查询（子查询结果为一列，但可以是多行）\",\"行子查询（子查询结果为一行，但可以是多列）\",\"表子查询（子查询结果为多行多列「相当于子查询结果是一张表」）\",\"子查询可以书写的位置：\",\"where 之后\",\"from 之后\",\"select 之后\"]},\"948\":{\"h\":\"6.4.2 标量子查询\",\"t\":[\"子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。\",\"常用的操作符： =<>>>=<<=\"]},\"949\":{\"h\":\"6.4.3 列子查询\",\"t\":[\"子查询返回的结果是一列(可以是多行)，这种子查询称为列子查询。\",\"常用的操作符：\",\"操作符\",\"描述\",\"IN\",\"在指定的集合范围之内，多选一\",\"NOT IN\",\"不在指定的集合范围之内\"]},\"950\":{\"h\":\"6.4.4 行子查询\",\"t\":[\"子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。\",\"常用的操作符：= 、<> 、IN 、NOT IN\"]},\"951\":{\"h\":\"6.4.5 表子查询\",\"t\":[\"子查询返回的结果是多行多列，常作为临时表，这种子查询称为表子查询。\"]},\"952\":{\"h\":\"7. 事务\"},\"953\":{\"h\":\"7.1 介绍\",\"t\":[\"在实际的业务开发中，有些业务操作要多次访问数据库。一个业务要发送多条 SQL 语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的 SQL 语句全部执行成功。如果其中有一条 SQL 语句失败，就进行事务的回滚，所有的 SQL 语句全部执行失败。\",\"简而言之：事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\",\"事务作用：保证在一个事务中多次操作数据库表中数据时，要么全都成功,要么全都失败。\"]},\"954\":{\"h\":\"7.2 操作\",\"t\":[\"MYSQL中有两种方式进行事务的操作：\",\"自动提交事务：即执行一条 sql 语句提交一次事务。（默认 MySQL 的事务是自动提交）\",\"手动提交事务：先开启，再提交\",\"事务操作有关的 SQL 语句：\",\"SQL语句\",\"描述\",\"start transaction; / begin ;\",\"开启手动控制事务\",\"commit;\",\"提交事务\",\"rollback;\",\"回滚事务\",\"手动提交事务使用步骤：\",\"第1种情况：开启事务 => 执行SQL语句 => 成功 => 提交事务\",\"第2种情况：开启事务 => 执行SQL语句 => 失败 => 回滚事务\"]},\"955\":{\"h\":\"7.3 四大特性\",\"t\":[\"原子性（Atomicity） ：原子性是指事务包装的一组 sql 是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。\",\"一致性（Consistency）：一个事务完成之后数据都必须处于一致性状态。\",\"如果事务成功的完成，那么数据库的所有变化将生效。\",\"如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。\",\"隔离性（Isolation）：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。\",\"一个事务的成功或者失败对于其他的事务是没有影响。\",\"持久性（Durability）：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。\",\"关键\",\"面试题：事务有哪些特性？\",\"原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。\",\"一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\",\"隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\",\"持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\",\"事务的四大特性简称为：ACID\"]},\"956\":{\"h\":\"8. 索引\"},\"957\":{\"h\":\"8.1 介绍\",\"t\":[\"索引 index ：是帮助数据库高效获取数据的数据结构 。\",\"简单来讲，就是使用索引可以提高查询的效率。\",\"优点：\",\"提高数据查询的效率，降低数据库的 IO 成本。\",\"通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 消耗。\",\"缺点：\",\"索引会占用存储空间。\",\"索引大大提高了查询效率，同时却也降低了 insert、update、delete 的效率。\"]},\"958\":{\"h\":\"8.2 结构\",\"t\":[\"MySQL 数据库支持的索引结构有很多，如：Hash 索引、B+Tree 索引、Full-Text 索引等。\",\"我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\",\"二叉查找树\",\"二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大\",\"二叉查找树\",\"当我们向二叉查找树保存数据时，是按照从大到小（或从小到大）的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。\",\"退化的二叉查找树\",\"可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）\",\"平衡二叉树\",\"但是在 Mysql 数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构。\",\"思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？\",\"答案 最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。 因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会造成数的高度比较高，树的高度一旦高了，检索速度就会降低。 \",\"说明\",\"如果数据结构是红黑树，那么查询 1000 万条数据，根据计算树的高度大概是 23 左右，这样确实比之前的方式快了很多，但是如果高并发访问，那么一个用户有可能需要 23 次磁盘 IO，那么 100 万用户，那么会造成效率极其低下。\",\"所以为了减少红黑树的高度，那么就得增加树的宽度，就是不再像红黑树一样每个节点只能保存一个数据，可以引入另外一种数据结构，一个节点可以保存多个数据，这样宽度就会增加从而降低树的高度。而 B+Tree 就满足这种要求。\",\"B+Tree（多路平衡搜索树）结构中如何避免这个问题：\",\"B+Tree 结构：\",\"每一个节点，可以存储多个 key（有 n 个 key，就有 n 个指针）\",\"节点分为：叶子节点、非叶子节点 \",\"叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上\",\"非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key + 指针\",\"为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询\",\"拓展\",\"非叶子节点都是由 key + 指针域 组成的，一个 key 占 8 字节，一个指针占 6 字节，而一个节点总共容量是 16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节 / (8+6) = 1170 个元素。\",\"查看 mysql 索引节点大小：\",\"show global status like 'innodb_page_size'; -- 节点大小：16384\",\"当根节点中可以存储 1170 个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储 1170 个元素，那么第二层即第二次 IO 的时候就会找到数据大概是：1170∗1170=135W。也就是说 B+Tree 数据结构中只需要经历两次磁盘 IO 就可以找到 135W 条数据。\",\"对于第二层每个元素有指针，那么会找到第三层，第三层由 key + 数据 组成，假设 key + 数据 总大小是 1KB，而每个节点一共能存储 16KB，所以一个第三层一个节点大概可以存储 16 个元素(即 16 条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是 135W 个元素，那么第三层总元素大小就是：135W∗16 结果就是 2000W+ 的元素个数。\",\"结合上述分析 B+Tree 有如下优点：\",\"千万条数据，B+Tree 可以控制在小于等于 3 的高度\",\"所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找\"]},\"959\":{\"h\":\"8.3 语法\",\"t\":[\"创建索引\",\"create [ unique ] index 索引名 on 表名 (字段名,... ) ;\",\"查看索引\",\"show index from 表名;\",\"删除索引\",\"drop index 索引名 on 表名;\",\"注意事项\",\"主键字段，在建表时，会自动创建主键索引\",\"添加唯一约束时，数据库实际上会添加唯一索引\"]},\"960\":{\"c\":[\"MySQL\"]},\"961\":{\"c\":[\"基础\"]},\"962\":{\"h\":\"Singleton 单例模式 —— 只有一个实例\"},\"963\":{\"h\":\"1. 单例模式的定义\",\"t\":[\"如果一个类只允许创建一个对象（或实例），那么，这个类就是一个单例类，这种设计模式就称为单例模式。\",\"从业务概念方面来讲，如果某个类包含的数据在系统中只应保存一份，那么这个类就应该被设计为单例类。\"]},\"964\":{\"c\":[\"设计模式\"]},\"965\":{\"c\":[\"创建型模式\"]},\"966\":{\"h\":\"Factory Method 工厂方法模式 —— 将实例的生成交给子类\"},\"967\":{\"h\":\"1. 工厂方法模式的定义\"},\"968\":{\"c\":[\"设计模式\"]},\"969\":{\"c\":[\"创建型模式\"]},\"970\":{\"h\":\"哈希表\"},\"971\":{\"h\":\"哈希表的工作原理\",\"t\":[\"哈希表（Hash Table），也称为散列表，是一种通过哈希函数将键（Key）映射到表中一个位置以便存储和检索数据的数据结构。其工作原理主要包括以下几个步骤：\",\"哈希函数：哈希表使用一个哈希函数来计算键的哈希值。这个哈希值是一个整数，它表示了该键在哈希表中存储的位置（即索引）。\",\"处理冲突：理想情况下，哈希函数会为每个键生成一个唯一的哈希值，但在实际应用中，不同的键可能会产生相同的哈希值，这种现象称为冲突。哈希表通过以下几种方法来处理冲突：\",\"链地址法（Separate Chaining）：每个哈希表的槽位（slot）都链接一个链表，所有具有相同哈希值的元素都存储在这个链表中。\",\"开放寻址法（Open Addressing）：当冲突发生时，哈希表会在表中寻找下一个空闲位置来存储元素。常见的探测方法包括线性探测、二次探测和双重散列。\",\"插入操作：向哈希表中添加元素时，首先计算元素键的哈希值，然后根据哈希值将元素存储在表中适当的位置。\",\"查找操作：检索元素时，同样先计算键的哈希值，然后根据哈希值快速定位到元素在表中的位置，如果存在冲突，则通过冲突解决策略找到元素。\",\"删除操作：删除元素时，首先找到元素的位置，然后从该位置移除元素，并可能需要处理冲突链表或调整开放寻址中的空闲位置。\"]},\"972\":{\"h\":\"优点\",\"t\":[\"高效的数据检索：在理想情况下，哈希表可以在常数时间 (O(1)) 内完成插入、查找和删除操作。\",\"动态大小：哈希表可以根据需要动态调整大小，以适应数据的增减。\",\"键值对存储：哈希表支持键值对的存储方式，使得数据的存储和检索更加灵活。\",\"灵活的键类型：可以使用各种类型的键，包括整数、字符串等。\"]},\"973\":{\"h\":\"缺点\",\"t\":[\"冲突问题：冲突可能导致性能下降，特别是在冲突解决策略不够高效时。\",\"空间效率：为了减少冲突，哈希表通常需要预留一定比例的空闲空间，这可能导致空间的浪费。\",\"哈希函数的选择：一个不好的哈希函数可能导致性能下降，特别是在面对不理想的数据分布时。\",\"负载因子的调整：负载因子（表中元素数量与槽位数的比值）需要适时调整，以保持操作的效率，这可能需要重新哈希和复制整个表。\",\"不是有序的：哈希表不保证元素的顺序，如果需要有序的数据，可能需要额外的逻辑或使用其他数据结构。\",\"哈希表是一种非常实用的数据结构，适用于需要快速查找、插入和删除操作的场景。然而，设计和使用哈希表时需要仔细考虑哈希函数的选择、冲突解决策略以及负载因子的调整等问题。\"]},\"974\":{\"c\":[\"Java\"]},\"975\":{\"c\":[\"基础\"]},\"976\":{\"h\":\"Java 基础知识\"},\"977\":{\"h\":\"一、语法基础\"},\"978\":{\"h\":\"1.1 变量\",\"t\":[\"变量必须先定义，才可以使用。不能重名。\",\"变量定义的方式：\",\"public class Main { public static void main(String[] args) { int a = 5; int b, c = a, d = 10 / 2; } }\",\"内置数据类型：\",\"类型\",\"字节数\",\"举例\",\"byte\",\"1\",\"123\",\"short\",\"2\",\"12345\",\"int\",\"4\",\"123456789\",\"long\",\"8\",\"1234567891011L\",\"float\",\"4\",\"1.2F\",\"double\",\"8\",\"1.2, 1.2D\",\"boolean\",\"1\",\"true, false\",\"char\",\"2\",\"‘A’\",\"常量：\",\"使用final修饰：\",\"final int N = 110;\",\"类型转化：\",\"显示转化：int x = (int)'A';\",\"隐式转化：double x = 12, y = 4 * 3.3;\"]},\"979\":{\"h\":\"1.2 运算符\",\"t\":[\"A = 10, B = 20\",\"运算符\",\"描述\",\"实例\",\"+\",\"把两个数相加\",\"A + B 将得到 30\",\"-\",\"从第一个数中减去第二个数\",\"A - B 将得到 -10\",\"*\",\"把两个数相乘\",\"A * B 将得到 200\",\"/\",\"分子除以分母\",\"B / A 将得到 2\",\"%\",\"取模运算符，向零整除后的余数，注意余数可能为负数\",\"B % A 将得到 0\",\"++\",\"自增运算符\",\"A++：先取值后加1；++A：先加1后取值\",\"--\",\"自减运算符\",\"A--：先取值后减1；--A：先减1后取值\",\"+=\",\"第一个数加上第二个数\",\"A = A + B 可以简写为 A += B\",\"-=\",\"第一个数减去第二个数\",\"A = A - B 可以简写为 A -= B\",\"*=\",\"第一个数乘以第二个数\",\"A = A * B 可以简写为 A *= B\",\"/=\",\"第一个数除以第二个数\",\"A = A / B 可以简写为 A /= B\",\"%=\",\"第一个对第二个数取余数\",\"A = A % B 可以简写为 A %= B\"]},\"980\":{\"h\":\"1.3 表达式\",\"t\":[\"整数的加减乘除四则运算：\",\"public class Main { public static void main(String[] args) { int a = 6 + 3 * 4 / 2 - 2; System.out.println(a); int b = a * 10 + 5 / 2; System.out.println(b); System.out.println(23 * 56 - 78 / 3); } }\",\"浮点数（小数）的运算：\",\"public class Main { public static void main(String[] args) { double x = 1.5, y = 3.2; System.out.println(x * y); System.out.println(x + y); System.out.println(x - y); System.out.println(x / y); } }\",\"整型变量的自增、自减：\",\"public class Main { public static void main(String[] args) { int a = 1; int b = a ++ ; System.out.println(a + \\\" \\\" + b); int c = ++ a; System.out.println(a + \\\" \\\" + c); } }\"]},\"981\":{\"h\":\"1.4 输入\",\"t\":[\"方式1：效率较低，输入规模较小时使用。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); String str = sc.next(); // 读入下一个字符串 int x = sc.nextInt(); // 读入下一个整数 float y = sc.nextFloat(); // 读入下一个单精度浮点数 double z = sc.nextDouble(); // 读入下一个双精度浮点数 String line = sc.nextLine(); // 读入下一行 } }\",\"方式2：效率较高，输入规模较大时使用。注意需要抛异常。\",\"import java.io.BufferedReader; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); System.out.println(str); } }\"]},\"982\":{\"h\":\"1.5 输出\",\"t\":[\"方式1：效率较低，输出规模较小时使用。\",\"public class Main { public static void main(String[] args) throws Exception { System.out.println(123); // 输出整数 + 换行 System.out.println(\\\"Hello World\\\"); // 输出字符串 + 换行 System.out.print(123); // 输出整数 System.out.print(\\\"yxc\\\\n\\\"); // 输出字符串 System.out.printf(\\\"%04d %.2f\\\\n\\\", 4, 123.456D); // 格式化输出，float与double都用%f输出 } }\",\"System.out.printf() 中不同类型变量的输出格式：\",\"(1) int：%d (2) float: %f, 默认保留6位小数 (3) double: %f， 默认保留6位小数 (4) char: %c, 回车也是一个字符，用 '\\\\n' 表示 (5) String: %s\",\"方式2：效率较高，输出规模较大时使用。注意需要抛异常。\",\"import java.io.BufferedWriter; import java.io.OutputStreamWriter; public class Main { public static void main(String[] args) throws Exception { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); bw.write(\\\"Hello World\\\\n\\\"); bw.flush(); // 需要手动刷新缓冲区 } }\"]},\"983\":{\"h\":\"二、判断语句\",\"t\":[\"学习语言最好的方式就是实践，每当掌握一个新功能时，就要立即将这个功能应用到实践中。——闫学灿\"]},\"984\":{\"h\":\"2.1 if 语句\",\"t\":[\"基本 if-else 语句\",\"当条件成立时，执行某些语句；否则执行另一些语句。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) { System.out.printf(\\\"%d is big!\\\\n\\\", a); System.out.printf(\\\"%d + 1 = %d\\\\n\\\", a, a + 1); } else { System.out.printf(\\\"%d is small!\\\\n\\\", a); System.out.printf(\\\"%d - 1 = %d\\\\n\\\", a, a - 1); } } }\",\"else 语句可以省略：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) { System.out.printf(\\\"%d is big!\\\\n\\\", a); System.out.printf(\\\"%d + 1 = %d\\\\n\\\", a, a + 1); } } }\",\"当只有一条语句时，大括号可以省略：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) System.out.printf(\\\"%d is big!\\\\n\\\", a); else System.out.printf(\\\"%d is small!\\\\n\\\", a); } }\",\"练习：输入一个整数，输出这个数的绝对值。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); if (x > 0) System.out.println(x); else System.out.println(-x); } }\",\"练习：输入两个整数，输出两个数中较大的那个。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(); if (a > b) System.out.println(a); else System.out.println(b); } }\",\"if-else 语句内部也可以是 if-else 语句。\",\"练习：输入三个整数，输出三个数中最大的那个。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(); if (a > b) { if (a > c) System.out.println(a); else System.out.println(c); } else { if (b > c) System.out.println(b); else System.out.println(c); } } }\",\"常用比较运算符\",\"(1) 大于 > (2) 小于 < (3) 大于等于 >= (4) 小于等于 <= (5) 等于 == (6) 不等于 !=\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(); if (a > b) System.out.printf(\\\"%d > %d\\\\n\\\", a, b); if (a >= b) System.out.printf(\\\"%d >= %d\\\\n\\\", a, b); if (a < b) System.out.printf(\\\"%d < %d\\\\n\\\", a, b); if (a <= b) System.out.printf(\\\"%d <= %d\\\\n\\\", a, b); if (a == b) System.out.printf(\\\"%d == %d\\\\n\\\", a, b); if (a != b) System.out.printf(\\\"%d != %d\\\\n\\\", a, b); } }\",\"if-else连写：\",\"输入一个0到100之间的分数， 如果大于等于85，输出A； 如果大于等于70并且小于85，输出B； 如果大于等于60并且小于70，输出C； 如果小于60，输出 D；\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int s = sc.nextInt(); if (s >= 85) { System.out.println(\\\"A\\\"); } else if (s >= 70) { System.out.println(\\\"B\\\"); } else if (s >= 60) { System.out.println(\\\"C\\\"); } else { System.out.println(\\\"D\\\"); } } }\",\"练习：\",\"1.判断闰年。闰年有两种情况： (1) 能被100整除时，必须能被400整除； (2) 不能被100整除时，被4整除即可。 输入一个年份，如果是闰年输出yes，否则输出no。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int year = sc.nextInt(); if (year % 100 == 0) { if (year % 400 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } else { if (year % 4 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } } }\"]},\"985\":{\"h\":\"2.2 条件表达式\",\"t\":[\"​ (1) 与 && ​ (2) 或 || ​ (3) 非!\",\"例题：输入三个数，输出三个数中的最大值。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(); if (a >= b && a >= c) System.out.println(a); else if (b >= a && b >= c) System.out.println(b); else System.out.println(c); } }\",\"练习：用一条 if 语句，判断闰年。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int year = sc.nextInt(); if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } }\"]},\"986\":{\"h\":\"2.3 switch 语句\",\"t\":[\"注意： swtich 语句中如果不加 break 语句，则从上到下匹配到第一个 case 后，会顺次执行后面每个 case 中的语句。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int day = sc.nextInt(); String name; switch(day) { case 1: name = \\\"Monday\\\"; break; case 2: name = \\\"Tuesday\\\"; break; case 3: name = \\\"Wednesday\\\"; break; case 4: name = \\\"Thursday\\\"; break; case 5: name = \\\"Friday\\\"; break; case 6: name = \\\"Saturday\\\"; break; case 7: name = \\\"Sunday\\\"; break; default: name = \\\"not valid\\\"; } System.out.println(name); } }\"]},\"987\":{\"h\":\"三、循环语句\",\"t\":[\"学习编程语言语法是次要的，思维是主要的。如何把头脑中的想法变成简洁的代码，至关重要。——闫学灿\",\"学习循环语句只需要抓住一点 —— 代码执行顺序！\"]},\"988\":{\"h\":\"3. 1 while 循环\",\"t\":[\"可以简单理解为循环版的 if 语句。if 语句是判断一次，如果条件成立，则执行后面的语句；\",\"while 是每次判断，如果成立，则执行循环体中的语句，否则停止。\",\"public class Main { public static void main(String[] args) { int i = 0; while (i < 10) { System.out.println(i); i ++ ; } } }\",\"练习：求 1~100 中所有数的立方和。\",\"public class Main { public static void main(String[] args) { int i = 1, sum = 0; while (i <= 100) { sum += i * i * i; i ++ ; } System.out.println(sum); } }\",\"练习：求斐波那契数列的第 n 项。f(1)=1,f(2)=1,f(3)=2,f(n)=f(n−1)+f(n−2)。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int a = 1, b = 1, i = 1; while (i < n) { int c = a + b; a = b; b = c; i ++ ; } System.out.println(a); } }\",\"死循环：循环永久执行，无法结束。我们要避免写出死循环。\",\"public class Main { public static void main(String[] args) { int x = 1; while (x == 1) System.out.println(\\\"!\\\"); } }\"]},\"989\":{\"h\":\"3.2 do while 循环\",\"t\":[\"do while 循环不常用。\",\"do while语句与 while 语句非常相似。唯一的区别是，do while 语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。\",\"public class Main { public static void main(String[] args) { int x = 1; while (x < 1) { System.out.println(\\\"x!\\\"); } int y = 1; do { System.out.println(\\\"y!\\\"); } while (y < 1); } }\"]},\"990\":{\"h\":\"3.3 for 循环\",\"t\":[\"基本思想：把控制循环次数的变量从循环体中剥离。\",\"for (init-statement; condition; expression) { statement }\",\"init-statement 可以是声明语句、表达式、空语句，一般用来初始化循环变量；\",\"condition 是条件表达式，和 while 中的条件表达式作用一样；可以为空，空语句表示true；\",\"expression 一般负责修改循环变量，可以为空。\",\"public class Main { public static void main(String[] args) { for (int i = 0; i < 10; i ++ ) { // 循环体中只有一条语句时，可以不加大括号 System.out.println(i); } } }\",\"练习：求 1~100 中所有数的立方和。\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1; i <= 100; i ++ ) sum += i * i * i; System.out.println(sum); } }\",\"练习：求斐波那契数列的第 n 项。f(1)=1,f(2)=1,f(3)=2,f(n)=f(n−1)+f(n−2)。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int a = 1, b = 1; for (int i = 1; i < n; i ++ ) { int c = a + b; a = b; b = c; } System.out.println(a); } }\",\"init-statement 可以定义多个变量，expression 也可以修改多个变量。\",\"例如求 1 * 10 + 2 * 9 + 3 * 8 + 4 * 7 + 5 * 6：\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1, j = 10; i < j; i ++, j -- ) { sum += i * j; } System.out.println(sum); } }\"]},\"991\":{\"h\":\"3.4 跳转语句\"},\"992\":{\"h\":\"3.4.1 break\",\"t\":[\"可以提前从循环中退出，一般与 if 语句搭配。\",\"例题：判断一个大于 1 的数是否是质数：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); boolean isPrime = true; for (int i = 2; i < n; i ++ ) if (n % i == 0) { isPrime = false; break; } if (isPrime) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } }\"]},\"993\":{\"h\":\"3.4.2 continue\",\"t\":[\"可以直接跳到当前循环体的结尾。作用与 if 语句类似。\",\"例题：求 1~100 中所有偶数的和。\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1; i <= 100; i ++ ) { if (i % 2 == 1) continue; sum += i; } System.out.println(sum); } }\"]},\"994\":{\"h\":\"3.5 多层循环\",\"t\":[\"将 1~100 打印到一个 10×10 的矩阵中：\",\"public class Main { public static void main(String[] args) { for (int i = 0, k = 1; i < 10; i ++ ) { for (int j = 0; j < 10; j ++, k ++ ) { System.out.printf(\\\"%d \\\", k); } System.out.println(); } } }\",\"练习：打印 1~100 中的所有质数\",\"public class Main { public static void main(String[] args) { for (int i = 2; i <= 100; i ++ ) { boolean isPrime = true; for (int j = 2; j < i; j ++ ) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) System.out.println(i); } } }\"]},\"995\":{\"h\":\"四、数组\",\"t\":[\"程序 = 逻辑 + 数据，数组是存储数据的强而有力的手段。 ——闫学灿\"]},\"996\":{\"h\":\"4.1 一维数组\"},\"997\":{\"h\":\"4.1.1 数组的定义\",\"t\":[\"数组的定义方式和变量类似。\",\"public class Main { public static void main(String[] args) { int[] a = new int[10], b; float[] f = new float[33]; double[] d = new double[123]; char[] c = new char[21]; } }\"]},\"998\":{\"h\":\"4.1.2 数组的初始化\",\"t\":[\"public class Main { public static void main(String[] args) { int[] a = {0, 1, 2}; // 含有3个元素的数组，元素分别是0, 1, 2 int[] b = new int[3]; // 含有3个元素的数组，元素的值均为0 char[] d = {'a', 'b', 'c'}; // 字符数组的初始化 } }\"]},\"999\":{\"h\":\"4.1.3 访问数组元素\",\"t\":[\"通过下标访问数组。\",\"public class Main { public static void main(String[] args) { int[] a = {0, 1, 2}; // 数组下标从0开始 System.out.printf(\\\"%d %d %d\\\\n\\\", a[0], a[1], a[2]); a[0] = 5; System.out.println(a[0]); } }\",\"练习题1： 使用数组实现求斐波那契数列的第 N 项。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] f = new int[n + 1]; f[0] = 0; f[1] = 1; for (int i = 2; i <= n; i ++ ) f[i] = f[i - 1] + f[i - 2]; System.out.println(f[n]); } }\",\"练习题2：输入一个 n，再输入 n 个整数。将这 n 个整数逆序输出。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i ++ ) a[i] = sc.nextInt(); for (int i = n - 1; i >= 0; i -- ) System.out.printf(\\\"%d \\\", a[i]); } }\",\"练习题3：输入 n 个数，将这 n 个数按从小到大的顺序输出。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i ++ ) a[i] = sc.nextInt(); for (int i = 0; i < n; i ++ ) for (int j = i + 1; j < n; j ++ ) if (a[i] > a[j]) { int t = a[i]; a[i] = a[j]; a[j] = t; } for (int i = 0; i < n; i ++ ) System.out.printf(\\\"%d \\\", a[i]); } }\"]},\"1000\":{\"h\":\"4.2 多维数组\",\"t\":[\"多维数组就是数组的数组。\",\"public class Main { public static void main(String[] args) { int[][] a = new int[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组。 int[][][] b = new int[10][20][30]; // 将所有元素的初值为0 // 大小为10的数组，它的每个元素是含有20个数组的数组 // 这些数组的元素是含有30个整数的数组 } } public class Main { public static void main(String[] args) { int[][] a = { // 三个元素，每个元素都是大小为4的数组 {0, 1, 2, 3}, // 第1行的初始值 {4, 5, 6, 7}, // 第2行的初始值 {8, 9, 10, 11} // 第3行的初始值 }; for (int i = 0; i < 4; i ++ ) // 将第一行全部变成0 a[0][i] = 0; for (int i = 0; i < 3; i ++ ) { // 输出二维数组 for (int j = 0; j < 4; j ++ ) { System.out.printf(\\\"%d \\\", a[i][j]); } System.out.println(); } } }\"]},\"1001\":{\"h\":\"4.3 数组的范围遍历\",\"t\":[\"import java.util.Scanner; public class Main { public static void main(String[] args) { int[][] a = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}, }; for (int[] row: a) { // 范围遍历 for (int x: row) // 范围遍历 System.out.printf(\\\"%d \\\", x); System.out.println(); } } }\"]},\"1002\":{\"h\":\"4.3 常用API\",\"t\":[\"属性length：返回数组长度，注意不加小括号\",\"Arrays.sort()：数组排序\",\"Arrays.fill(int[] a, int val)：填充数组\",\"Arrays.toString()：将数组转化为字符串\",\"Arrays.deepToString()：将多维数组转化为字符串\",\"数组不可变长\",\"使用Arrays需要import java.util.Arrays\"]},\"1003\":{\"h\":\"五、字符串\",\"t\":[\"字符串是计算机与人类沟通的重要手段。——闫学灿\"]},\"1004\":{\"h\":\"5.1 字符与整数的联系——ASCII码\",\"t\":[\"每个常用字符都对应一个 -128 ~ 127 的数字，二者之间可以相互转化。\",\"注意：目前负数没有与之对应的字符。\",\"import java.util.Arrays; public class Main { public static void main(String[] args) { char c = 'a'; System.out.println((int)c); int a = 66; System.out.println((char)a); } }\",\"常用ASCII值：'A'- 'Z'是65 ~ 90，'a' - 'z'是97 - 122，0 - 9是 48 - 57。 字符可以参与运算，运算时会将其当做整数：\",\"import java.util.Arrays; public class Main { public static void main(String[] args) { int a = 'B' - 'A'; int b = 'A' * 'B'; char c = 'A' + 2; System.out.println(a); System.out.println(b); System.out.println(c); } }\"]},\"1005\":{\"h\":\"5.2 String 类\",\"t\":[\"初始化：\",\"String a = \\\"Hello World\\\"; String b = \\\"My name is \\\"; String x = b; // 存储到了相同地址 String c = b + \\\"yxc\\\"; // String可以通过加号拼接 String d = \\\"My age is \\\" + 18; // int会被隐式转化成字符串\\\"18\\\" String str = String.format(\\\"My age is %d\\\", 18); // 格式化字符串，类似于C++中的sprintf String money_str = \\\"123.45\\\"; double money = Double.parseDouble(money_str); // String转double\",\"只读变量，不能修改，例如：\",\"String a = \\\"Hello \\\"; a += \\\"World\\\"; // 会构造一个新的字符串\",\"访问String中的字符：\",\"String str = \\\"Hello World\\\"; for (int i = 0; i < str.length(); i ++ ) { System.out.print(str.charAt(i)); // 只能读取，不能写入 }\",\"常用API：\",\"length()：返回长度\",\"charAt(i)：字符串的第i个位置的字符\",\"split(String regex)：分割字符串\",\"String[] strs = sc.nextLine().split(” “);\",\"indexOf(char c)、indexOf(String str)、lastIndexOf(char c)、lastIndexOf(String str)：查找，找不到返回-1\",\"equals()：判断两个字符串是否相等，注意不能直接用==\",\"compareTo()：判断两个字符串的字典序大小，负数表示小于，0表示相等，正数表示大于\",\"startsWith()：判断是否以某个前缀开头\",\"endsWith()：判断是否以某个后缀结尾\",\"trim()：去掉首尾的空白字符\",\"toLowerCase()：全部用小写字符\",\"toUpperCase()：全部用大写字符\",\"replace(char oldChar, char newChar)：替换字符\",\"replace(String oldRegex, String newRegex)：替换字符串\",\"substring(int beginIndex, int endIndex)：返回[beginIndex, endIndex)中的子串\",\"toCharArray()：将字符串转化成字符数组\",\"reverse()：翻转字符串\",\"范围遍历：\",\"String str = “Hello World”; for ( char c:str.toCharArray()) { System.out.print(c); }\"]},\"1006\":{\"h\":\"5.3 输入与输出\",\"t\":[\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str1 = sc.next(); // 输入字符串，遇到空格、回车等空白字符时停止输入 String str2 = sc.nextLine(); // 输入一整行字符串，遇到空格不会停止输入，遇到回车才会停止 System.out.println(str1); // 可以直接输出 System.out.printf(\\\"%s\\\\n\\\", str2); // 也可以格式化输出，用 %s 表示字符串 } }\"]},\"1007\":{\"h\":\"5.4 StringBuilder、StringBuffer\",\"t\":[\"String不能被修改，如果打算修改字符串，可以使用StringBuilder和StringBuffer。\",\"StringBuffer线程安全，速度较慢；StringBuilder线程不安全，速度较快。\",\"StringBuilder sb = new StringBuilder(\\\"Hello \\\"); // 初始化 sb.append(\\\"World\\\"); // 拼接字符串 System.out.println(sb); for (int i = 0; i < sb.length(); i ++ ) { sb.setCharAt(i, (char)(sb.charAt(i) + 1)); // 读取和写入字符 } System.out.println(sb);\"]},\"1008\":{\"h\":\"六、函数\",\"t\":[\"理解函数，最重要的是理解代码的执行顺序。——闫学灿\"]},\"1009\":{\"h\":\"6.1 函数基础\",\"t\":[\"一个典型的函数定义包括以下部分：修饰符、返回类型、函数名字、由0个或多个形参组成的列表以及函数体。\"]},\"1010\":{\"h\":\"6.1.1 编写函数\",\"t\":[\"我们来编写一个求阶乘的程序。程序如下所示：\",\"private static int fact(int val) { int res = 1; for (int i = 1; i <= val; i ++ ) res *= i; return res; }\",\"函数名字是 fact，它作用于一个整型参数，返回一个整型值。return 语句负责结束 fact 并返回 res 的值。 修饰符包括 private、static 等，它们属于类相关的概念，会在下一章解释。\"]},\"1011\":{\"h\":\"6.1.2 调用函数\",\"t\":[\"public class Main { private static int fact(int val) { int res = 1; for (int i = 1; i <= val; i ++ ) res *= i; return res; } public static void main(String[] args) { int res = fact(5); System.out.printf(\\\"5! is %d\\\\n\\\", res); } }\",\"函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。\"]},\"1012\":{\"h\":\"6.1.3 形参和实参\",\"t\":[\"实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，依次类推。形参和实参的类型和个数必须匹配。\",\"fact(\\\"hello\\\"); // 错误：实参类型不正确 fact(); // 错误：实参数量不足 fact(42, 10, 0); // 错误：实参数量过多 fact(' '); // 正确：该实参能自动转换成int类型，' '的ASCII值为32，所以该操作等价于fact(32);\"]},\"1013\":{\"h\":\"6.1.4 函数的形参列表\",\"t\":[\"函数的形参列表可以为空，但是不能省略。\",\"void f1() {/* …. */} // 空形参列表\",\"形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：\",\"int f3(int v1, v2) {/* … */} // 错误 int f4(int v1, int v2) {/* … */} // 正确\"]},\"1014\":{\"h\":\"6.1.5 函数返回类型\",\"t\":[\"大多数类型都能用作函数的返回类型。一种特殊的返回类型是 void，它表示函数不返回任何值。 函数的返回类型也可以是数组、字符串或者其他对象：\",\"import java.util.Arrays; public class Main { private static int[] newArray() { int[] a = {1, 2, 3}; return a; } private static String newString() { return \\\"Hello World\\\"; } public static void main(String[] args) { System.out.println(Arrays.toString(newArray())); System.out.println(newString()); } }\"]},\"1015\":{\"h\":\"6.1.6 变量的作用域\",\"t\":[\"本章中我们只使用静态成员变量和静态成员函数，非静态成员变量/函数及其区别会在下一章中介绍。\",\"函数内定义的变量为局部变量，只能在函数内部使用。\",\"定义在类中的变量为成员变量，可以在类的所有成员函数中调用。\",\"当局部变量与全局变量重名时，会优先使用局部变量。\",\"public class Main { private static int x = 4; private static void f1() { int x = 3; System.out.println(x); } private static void f2() { System.out.println(x); } private static void f3() { System.out.println(x + 1); } public static void main(String[] args) { f1(); f2(); f3(); } }\"]},\"1016\":{\"h\":\"6.2 参数传递\"},\"1017\":{\"h\":\"6.2.1 值传递\",\"t\":[\"八大基本数据类型和 String 类型等采用值传递。\",\"将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。\",\"public class Main { private static void f(int x) { x = 5; } public static void main(String[] args) { int x = 10; f(x); System.out.println(x); } }\"]},\"1018\":{\"h\":\"6.2.2 引用传递\",\"t\":[\"除 String 以外的数据类型的对象，例如 数组、StringBuilder 等采用引用传递。\",\"将实参的引用（地址）传给形参，通过引用找到变量的真正地址，然后对地址中的值修改。所以此时对形参的修改会影响实参的初始值。\",\"import java.util.Arrays; public class Main { private static void f1(int[] a) { for (int i = 0, j = a.length - 1; i < j; i ++, j -- ) { int t = a[i]; a[i] = a[j]; a[j] = t; } } private static void f2(StringBuilder sb) { sb.append(\\\"Hello World\\\"); } public static void main(String[] args) { int[] a = {1, 2, 3, 4, 5}; f1(a); System.out.println(Arrays.toString(a)); StringBuilder sb = new StringBuilder(\\\"\\\"); f2(sb); System.out.println(sb); } }\"]},\"1019\":{\"h\":\"6.3 返回类型和 return 语句\",\"t\":[\"return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。\",\"return 语句有两种形式：\",\"return; return expression;\"]},\"1020\":{\"h\":\"6.3.1 无返回值函数\",\"t\":[\"没有返回值的 return 语句只能用在返回类型是 void 的函数中。 返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式地执行 return。\",\"通常情况下，void 函数如果想在它的中间位置提前退出，可以使用 return 语句。return 的这种用法有点类似于我们用 break 语句退出循环。\",\"public class Main { private static void swap(int[] a) { // 交换a[0]和a[1] // 如果两个值相等，则不需要交换，直接退出 if (a[0] == a[1]) return; // 如果程序执行到了这里，说明还需要继续完成某些功能 int tmp = a[0]; a[0] = a[1]; a[1] = tmp; // 此处无须显示的return语句 } public static void main(String[] args) { int[] a = {3, 4}; swap(a); System.out.printf(\\\"%d %d\\\\n\\\", a[0], a[1]); } }\"]},\"1021\":{\"h\":\"6.3.2 有返回值的函数\",\"t\":[\"只要函数的返回类型不是 void，则该函数内的每个分支都必须有 return 语句，且每条 return 语句都必须返回一个值。return 语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换函数的返回类型。\",\"import java.util.Scanner; public class Main { private static int max(int a, int b) { if (a > b) return a; return b; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(), y = sc.nextInt(); System.out.println(max(x, y)); } }\"]},\"1022\":{\"h\":\"6.4 函数重载\",\"t\":[\"函数重载 是指：在同一个类中存在多个函数，函数名称相同但参数列表不同。\",\"编译器会根据实参的类型选择最匹配的函数来执行。\",\"import java.util.Scanner; public class Main { private static int max(int a, int b) { System.out.println(\\\"int max\\\"); if (a > b) return a; return b; } private static double max(double a, double b) { System.out.println(\\\"double max\\\"); if (a > b) return a; return b; } public static void main(String[] args) { System.out.println(max(3, 4)); System.out.println(max(3.0, 4.0)); } }\"]},\"1023\":{\"h\":\"6.5 函数递归\",\"t\":[\"在一个函数内部，也可以调用函数本身。\",\"import java.util.Scanner; public class Main { private static int fib(int n) { // 求斐波那切数列第n项 if (n <= 2) return 1; return fib(n - 1) + fib(n - 2); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(fib(n)); } }\"]},\"1024\":{\"h\":\"七、类与接口\",\"t\":[\"类可以将变量、函数完美地打包在一起。——闫学灿\"]},\"1025\":{\"h\":\"7.1 类与对象\",\"t\":[\"类定义一种全新的数据类型，包含一组变量和函数；对象是类这种类型对应的实例。\",\"例如在一间教室中，可以将 Student 定义成类，表示 “学生” 这个抽象的概念。那么每个同学就是 Student 类的一个对象（实例）。\"]},\"1026\":{\"h\":\"7.1.1 源文件声明规则\",\"t\":[\"一个源文件中只能有一个 public 类。\",\"一个源文件可以有多个非 public 类。\",\"源文件的名称应该和 public 类的类名保持一致。\",\"每个源文件中，先写 package 语句，再写 import 语句，最后定义类。\"]},\"1027\":{\"h\":\"7.1.2 类的定义\",\"t\":[\"public: 所有对象均可以访问\",\"private: 只有本类内部可以访问\",\"protected：同一个包或者子类中可以访问\",\"不添加修饰符：在同一个包中可以访问\",\"静态（带 static 修饰符）成员变量/函数与普通成员变量/函数的区别： \",\"所有 static 成员变量/函数在类中只有一份，被所有类的对象共享；\",\"所有普通成员变量/函数在类的每个对象中都有独立的一份；\",\"静态函数中只能调用静态函数/变量；访问静态变量最好通过类名；\",\"普通函数中既可以调用普通函数/变量，也可以调用静态函数/变量。\",\"class Point { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public int getX() { return x; } public int getY() { return y; } public String toString() { return String.format(\\\"(%d, %d)\\\", x, y); } }\"]},\"1028\":{\"h\":\"7.1.3 类的继承\",\"t\":[\"每个类只能继承一个类。\",\"class ColorPoint extends Point { private String color; public ColorPoint(int x, int y, String color) { super(x, y); this.color = color; } public void setColor(String color) { this.color = color; } public String toString() { return String.format(\\\"(%d, %d, %s)\\\", super.getX(), super.getY(), this.color); } }\"]},\"1029\":{\"h\":\"7.1.4 类的多态\",\"t\":[\"public class Main { public static void main(String[] args) { Point point = new Point(3, 4); Point colorPoint = new ColorPoint(1, 2, \\\"red\\\"); // 多态，同一个类的实例，调用相同的函数，运行结果不同 System.out.println(point.toString()); System.out.println(colorPoint.toString()); } }\"]},\"1030\":{\"h\":\"7.2 接口\",\"t\":[\"interface 与 class 类似。主要用来定义类中所需包含的函数。\",\"接口也可以继承其他接口，一个类可以实现多个接口。\"]},\"1031\":{\"h\":\"7.2.1 接口的定义\",\"t\":[\"接口中不添加修饰符时，默认为 public。\",\"interface Role { public void greet(); public void move(); public int getSpeed(); }\"]},\"1032\":{\"h\":\"7.2.2 接口的继承\",\"t\":[\"每个接口可以继承多个接口\",\"interface Hero extends Role { public void attack(); }\"]},\"1033\":{\"h\":\"7.2.3 接口的实现\",\"t\":[\"每个类可以实现多个接口\",\"class Zeus implements Hero { private final String name = \\\"Zeus\\\"; public void attack() { System.out.println(name + \\\": Attack!\\\"); } public void greet() { System.out.println(name + \\\": Hi!\\\"); } public void move() { System.out.println(name + \\\": Move!\\\"); } public int getSpeed() { return 10; } }\"]},\"1034\":{\"h\":\"7.2.4 接口的多态\",\"t\":[\"class Athena implements Hero { private final String name = \\\"Athena\\\"; public void attack() { System.out.println(name + \\\": Attack!!!\\\"); } public void greet() { System.out.println(name + \\\": Hi!!!\\\"); } public void move() { System.out.println(name + \\\": Move!!!\\\"); } public int getSpeed() { return 10; } } public class Main { public static void main(String[] args) { Hero[] heros = {new Zeus(), new Athena()}; for (Hero hero: heros) { hero.greet(); } } }\"]},\"1035\":{\"h\":\"八、常用容器\"},\"1036\":{\"h\":\"8.1 List\",\"t\":[\"接口：java.util.List<>\",\"实现：\",\"java.util.ArrayList<>：变长数组\",\"java.util.LinkedList<>：双链表\",\"函数：\",\"add()：在末尾添加一个元素\",\"clear()：清空\",\"size()：返回长度\",\"isEmpty()：是否为空\",\"get(i)：获取第i个元素\",\"set(i, val)：将第i个元素设置为val\"]},\"1037\":{\"h\":\"8.2 栈\",\"t\":[\"类：java.util.Stack<>\",\"函数：\",\"push()：压入元素\",\"pop()：弹出栈顶元素，并返回栈顶元素\",\"peek()：返回栈顶元素\",\"size()：返回长度\",\"empty()：栈是否为空\",\"clear()：清空\"]},\"1038\":{\"h\":\"8.3 队列\",\"t\":[\"接口：java.util.Queue<>\",\"实现：\",\"java.util.LinkedList<>：双链表\",\"java.util.PriorityQueue<>：优先队列 \",\"默认是小根堆，大根堆写法：new PriorityQueue<>(Collections.reverseOrder())\",\"函数：\",\"add()：在队尾添加元素\",\"remove()：删除并返回队头\",\"isEmpty()：是否为空\",\"size()：返回长度\",\"peek()：返回队头\",\"clear()：清空\"]},\"1039\":{\"h\":\"8.4 Set\",\"t\":[\"接口：java.util.Set<K>\",\"实现：\",\"java.util.HashSet<K>：哈希表\",\"java.util.TreeSet<K>：平衡树\",\"函数：\",\"add()：添加元素\",\"contains()：是否包含某个元素\",\"remove()：删除元素\",\"size()：返回元素数\",\"isEmpty()：是否为空\",\"clear()：清空\",\"java.util.TreeSet多的函数：\",\"ceiling(key)：返回大于等于key的最小元素，不存在则返回null\",\"floor(key)：返回小于等于key的最大元素，不存在则返回null\"]},\"1040\":{\"h\":\"8.5 Map\",\"t\":[\"接口：java.util.Map<K, V>\",\"实现：\",\"java.util.HashMap<K, V>：哈希表\",\"java.util.TreeMap<K, V>：平衡树\",\"函数：\",\"put(key, value)：添加关键字和其对应的值\",\"get(key)：返回关键字对应的值\",\"containsKey(key)：是否包含关键字\",\"remove(key)：删除关键字\",\"size()：返回元素数\",\"isEmpty()：是否为空\",\"clear()：清空\",\"entrySet()：获取Map中的所有对象的集合\",\"Map.Entry<K, V>：Map中的对象类型 \",\"getKey()：获取关键字\",\"getValue()：获取值\",\"java.util.TreeMap<K, V>多的函数：\",\"ceilingEntry(key)：返回大于等于key的最小元素，不存在则返回null\",\"floorEntry(key)：返回小于等于key的最大元素，不存在则返回null\"]},\"1041\":{\"h\":\"九、异常处理\",\"t\":[\"异常处理可以允许我们在程序运行时进行诊断和补救。—— 闫学灿\"]},\"1042\":{\"h\":\"9.1 Error 与 Exception 的区别\",\"t\":[\"Error 是程序无法处理的错误，比如 OutOfMemoryError、ThreadDeath 等。这些异常发生时，Java 虚拟机 (JVM) 一般会选择线程终止。此类异常是程序的致命异常，是无法捕获处理的。\",\"Exception 是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。 程序中应当尽可能去处理这些异常。\"]},\"1043\":{\"h\":\"9.2 Exception类的继承关系\",\"t\":[\"exception.png\"]},\"1044\":{\"h\":\"9.3 运行时异常和非运行时异常的区别\",\"t\":[\"运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException、IndexOutOfBoundsException 等， 这些异常是非检查型异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\",\"非运行时异常是 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，这些是检查型异常。一般情况下不自定义检查型异常。\"]},\"1045\":{\"h\":\"9.4 内置异常类\",\"t\":[\"非检查性异常：\",\"异常\",\"描述\",\"ArithmeticException\",\"当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。\",\"ArrayIndexOutOfBoundsException\",\"用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。\",\"ArrayStoreException\",\"试图将错误类型的对象存储到一个对象数组时抛出的异常。\",\"ClassCastException\",\"当试图将对象强制转换为不是实例的子类时，抛出该异常。\",\"IllegalArgumentException\",\"抛出的异常表明向方法传递了一个不合法或不正确的参数。\",\"IllegalMonitorStateException\",\"抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。\",\"IllegalStateException\",\"在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。\",\"IllegalThreadStateException\",\"线程没有处于请求操作所要求的适当状态时抛出的异常。\",\"IndexOutOfBoundsException\",\"指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\",\"NegativeArraySizeException\",\"如果应用程序试图创建大小为负的数组，则抛出该异常。\",\"NullPointerException\",\"当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\",\"NumberFormatException\",\"当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\",\"SecurityException\",\"由安全管理器抛出的异常，指示存在安全侵犯。\",\"StringIndexOutOfBoundsException\",\"此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。\",\"UnsupportedOperationException\",\"当不支持请求的操作时，抛出该异常\",\"检查性异常：\",\"异常\",\"描述\",\"ClassNotFoundException\",\"应用程序试图加载类时，找不到相应的类，抛出该异常。\",\"CloneNotSupportedException\",\"当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。\",\"IllegalAccessException\",\"拒绝访问一个类的时候，抛出该异常。\",\"InstantiationException\",\"当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。\",\"InterruptedException\",\"一个线程被另一个线程中断，抛出该异常。\",\"NoSuchFieldException\",\"请求的变量不存在\",\"NoSuchMethodException\",\"请求的方法不存在\"]},\"1046\":{\"h\":\"9.5 内置异常方法\",\"t\":[\"方法\",\"说明\",\"public String getMessage()\",\"返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。\",\"public Throwable getCause()\",\"返回一个 Throwable 对象代表异常原因。\",\"public String toString()\",\"返回此 Throwable 的简短描述。\",\"public void printStackTrace()\",\"将此 Throwable 及其回溯打印到标准错误流\",\"public StackTraceElement [] getStackTrace()\",\"返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\",\"public Throwable fillInStackTrace()\",\"用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。\"]},\"1047\":{\"h\":\"9.6 捕获异常\",\"t\":[\"import java.util.Scanner; public class Main { private static void foo() { int[] array = new int[5]; for (int i = 0; i < 5; i ++ ) array[i] = i; Scanner sc = new Scanner(System.in); int k = sc.nextInt(); int x = sc.nextInt(); try { array[k] /= x; } catch (ArithmeticException e) { System.out.println(\\\"除零错误！\\\"); e.printStackTrace(); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\\\"数组越界！\\\"); e.printStackTrace(); } finally { for (int i = 0; i < 5; i ++ ) { System.out.println(array[i]); } } } public static void main(String[] args) { foo(); } }\"]},\"1048\":{\"h\":\"9.7 抛出异常\",\"t\":[\"throw: 在函数内抛出一个异常。\",\"throws：在函数定义时抛出一些可能的异常。\",\"检查型异常必须被捕获或者抛出。\",\"import java.io.IOException; import java.util.Scanner; public class Main { private static void foo() throws IOException, NoSuchFieldException { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); if (x == 1) throw new IOException(\\\"找不到文件！！！\\\"); else throw new NoSuchFieldException(\\\"自定义异常\\\"); } public static void main(String[] args) { try { foo(); } catch (IOException e) { System.out.println(\\\"IOException!\\\"); e.printStackTrace(); } catch (NoSuchFieldException e) { System.out.println(\\\"NoSuchFieldException!\\\"); e.printStackTrace(); } } }\"]},\"1049\":{\"h\":\"9.8 try-with-resources\",\"t\":[\"JDK7 之后，Java 新增的 try-with-resource 语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭 。\",\"try 用于声明和实例化资源，catch 用于处理关闭资源时可能引发的所有异常。\",\"import java.io.*; public class Main { public static void main(String[] args) { String line; try ( BufferedReader br = new BufferedReader(new FileReader(\\\"input.txt\\\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\\\"output.txt\\\")); ) { while ((line = br.readLine()) != null) { System.out.println(\\\"Line => \\\" + line); bw.write(\\\"copy: \\\" + line + \\\"\\\\n\\\"); } bw.flush(); } catch (IOException e) { System.out.println(\\\"IOException in try block =>\\\" + e.getMessage()); } } }\"]},\"1050\":{\"h\":\"十、注解与反射\"},\"1051\":{\"h\":\"10.1 注解\",\"t\":[\"(1) 注解（Annotation）也被称为元数据（Metadata），用于修饰包、方法、属性、构造器、局部变量等数据信息。\",\"(2) 注解不影响程序逻辑，但注解可以被编译或运行。\",\"(3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。\"]},\"1052\":{\"h\":\"10.1.1 常用注解\",\"t\":[\"(1) @Override: 限定某个函数必须重写其他函数，该注解只能用于函数。函数名和参数列表必须相同。\",\"(2) @Overload: 限定某个函数必须重载其他函数，该注解只能用于函数。函数名必须相同，参数列表必须不同。\",\"(3) @Deprecated：用于表示某个程序元素（类、函数）已过时\",\"(4) @SuppressWarnings：抑制编译器警告\"]},\"1053\":{\"h\":\"10.1.2 元注解\",\"t\":[\"修饰其他注解的注解，就被称为元注解。\",\"(1) Retention：指定注解的作用范围\",\"(2) Target：指定注解可以用在哪些地方\",\"(3) Document：注定注解是否出出现在 javadoc 中\",\"(4) Inherited：子类会继承父类的注解\"]},\"1054\":{\"h\":\"10.2 反射\",\"t\":[\"反射：动态引入类、动态调用实例的成员函数、成员变量等。\"]},\"1055\":{\"h\":\"10.2.1 常用API\",\"t\":[\"(1) java.lang.Class：获取类的实例对象\",\"(2) java.lang.reflect.Method：获取类或接口中的单个方法的信息\",\"(3) java.lang.reflect.Field：获取类或接口中的单个字段的信息\",\"(4) java.lang.reflect.Constructor：获取类中的单个构造函数的信息\",\"package org.yxc; public class Calculator { public String name; public Calculator() {} public Calculator(String name) { this.name = name; } public int add(int a, int b) { return a + b; } }\",\"package org.yxc; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { Class<?> cls = Class.forName(\\\"org.yxc.Calculator\\\"); Object o = cls.newInstance(); Method method = cls.getMethod(\\\"add\\\", int.class, int.class); int res = (int)method.invoke(o, 3, 4); System.out.println(res); Field field = cls.getField(\\\"name\\\"); field.set(o, \\\"My Calculator!\\\"); System.out.println(field.get(o)); Constructor<?> constructor = cls.getConstructor(String.class); Object new_o = constructor.newInstance(\\\"New Calculator!\\\"); System.out.println(new_o); } }\"]},\"1056\":{\"h\":\"10.2.2 优缺点\",\"t\":[\"优点：可以动态创建和使用对象，使用灵活 缺点：执行速度慢\"]},\"1057\":{\"h\":\"十一、多线程与锁\"},\"1058\":{\"h\":\"11.1 多线程\"},\"1059\":{\"h\":\"11.1.1 实现多线程\",\"t\":[\"写法1：继承 Thread 类\",\"class Worker extends Thread { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + this.getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) { Worker worker1 = new Worker(); Worker worker2 = new Worker(); worker1.setName(\\\"thread-1\\\"); worker2.setName(\\\"thread-2\\\"); worker1.start(); worker2.start(); } }\",\"写法2：实现 Runnable 接口\",\"class Worker1 implements Runnable { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + \\\"thread-1\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } class Worker2 implements Runnable { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + \\\"thread-2\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) { new Thread(new Worker1()).start(); new Thread(new Worker2()).start(); } }\"]},\"1060\":{\"h\":\"11.1.2 常用API\",\"t\":[\"start()：开启一个线程\",\"Thread.sleep(): 休眠一个线程\",\"join()：等待线程执行结束\",\"interrupt()：从休眠中中断线程（不能中断任何线程）\",\"setDaemon()：将线程设置为守护线程。当只剩下守护线程时，程序自动退出\"]},\"1061\":{\"h\":\"11.2 锁\",\"t\":[\"lock：获取锁，如果锁已经被其他线程获取，则阻塞\",\"unlock：释放锁，并唤醒被该锁阻塞的其他线程\",\"import java.util.concurrent.locks.ReentrantLock; class Worker extends Thread { public static int cnt = 0; private static final ReentrantLock lock = new ReentrantLock(); @Override public void run() { for (int i = 0; i < 100000; i ++ ) { lock.lock(); try { cnt ++ ; } finally { lock.unlock(); } } } } public class Main { public static void main(String[] args) throws InterruptedException { Worker worker1 = new Worker(); Worker worker2 = new Worker(); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(Worker.cnt); } }\"]},\"1062\":{\"h\":\"11.3 同步（Synchronized）\",\"t\":[\"写法1：将 Synchronized 加到代码块上\",\"class Count { public int cnt = 0; } class Worker extends Thread { public final Count count; public Worker(Count count) { this.count = count; } @Override public void run() { synchronized (count) { for (int i = 0; i < 100000; i ++ ) { count.cnt ++ ; } } } } public class Main { public static void main(String[] args) throws InterruptedException { Count count = new Count(); Worker worker1 = new Worker(count); Worker worker2 = new Worker(count); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(count.cnt); } }\",\"写法2：将 Synchronized 加到函数上（锁加到了 this 对象上）\",\"class Worker implements Runnable { public static int cnt = 0; private synchronized void work() { for (int i = 0; i < 100000; i ++ ) { cnt ++ ; } } @Override public void run() { work(); } } public class Main { public static void main(String[] args) throws InterruptedException { Worker worker = new Worker(); Thread worker1 = new Thread(worker); Thread worker2 = new Thread(worker); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(Worker.cnt); } }\"]},\"1063\":{\"h\":\"11.3.1 wait 与 notify\",\"t\":[\"package org.yxc; class Worker extends Thread { private final Object object; private final boolean needWait; public Worker(Object object, boolean needWait) { this.object = object; this.needWait = needWait; } @Override public void run() { synchronized (object) { try { if (needWait) { object.wait(); System.out.println(this.getName() + \\\": 被唤醒啦！\\\"); } else { object.notifyAll(); } } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) throws InterruptedException { Object object = new Object(); for (int i = 0; i < 5; i ++ ) { Worker worker = new Worker(object, true); worker.setName(\\\"thread-\\\" + i); worker.start(); } Worker worker = new Worker(object, false); worker.setName(\\\"thread-\\\" + 5); Thread.sleep(1000); worker.start(); } }\"]},\"1064\":{\"c\":[\"Java\"]},\"1065\":{\"c\":[\"基础\"]},\"1066\":{\"h\":\"常用API\",\"t\":[\"整理 java 刷题过程中常用 API\"]},\"1067\":{\"h\":\"数组\",\"t\":[\"toString(arr); // 返回一个字符串 copyOf(arr, begin, end); copyOfRange(arr, begin, end); // 返回与arr类型相同的一个数组，其长度为end或end-begin，并填入arr的值 // 如果end大于arr.length，结果会填充0或false值 sort(arr, begin, end); // 使用稳定的快排队数组进行排序 --- O(n logn) sort(arr, begin, end, Collections.reverseOrder()); // 数组降序排序排序 equals(arr1, arr2); // 如果两个数组长度相同，并且相同索引对应的元素都相同，则返回 true\"]},\"1068\":{\"h\":\"字符串\",\"t\":[\"字符串分为两类：不可变字符串（String）和可变字符串（StringBuilder）。\",\"String 类用来表示那些创建后就不会再改变的字符串，而 StringBuilder 类用来表示内容可变的字符串，并提供了修改字符串的方法。\",\"表面上拼接字符串时，String 类使用 str1 + str2 这种形式拼接字符串，实际上是 JVM 帮助创建 StringBuilder 对象来拼接，StringBuilder 类却要调用一个 append() 方法来拼接，但其实 StringBuilder 类的效率更高。\"]},\"1069\":{\"h\":\"String\",\"t\":[\"初始化有两种：\",\"String str = new String(\\\"XXX\\\"); // 参数可以是字符串常量，也可为字符数组 String str = \\\"XXX\\\"; // 参数可为字符串常量，可为String.valueOf()系列的返回值\",\"前者是 java 中标准的对象创建方式，其创建的对象将直接放置到堆中，每调用一次就会创建一个新的对象； 后者则会在栈中创建一个对象引用变量 str ，然后查看字符串池中是否存在 \\\"XXX\\\"，如果没有，则将 \\\"XXX\\\" 存放字符串池，并令引用变量 str 指向它；如果已经有 \\\"XXX\\\"，则直接令 str 指向它。\",\"常用方法：\",\"equals(); // 字符串比较必须能用equals()，相同返回true，否则返回false equalsIgnoreCase(); // 忽略大小写进行比较 charAt(int index); // 返回index位置的字符char --- O(1) length(); // 返回字符串长度 --- O(1) substring(int begin, int end); // 返回字符片段[begin, end) --- O(n) substring(int begin); // 返回从begin开始后面所有的字符片段 ---- O(n) contains(String str); // 是否包含子串str --- O(1) indexOf(String str); // 返回str第一个出现的位置，没找到则返回-1 --- O(m * n) m为原串长度， n为str长度 indexOf(String str, int index); // 同上，但从index开始找 --- O(m * n) lastIndexOf(String str); // 返回str最后出现的位置，没找到则返回-1 --- O(m * n) m为原串长度， n为str长度 lastIndexOf(String str, int index); // 同上，但从index开始从后往前找 [0 <- Index] --- O(m * n) replace(char oldChar, char newChar); // 返回一个新字符串String，其全部oldChar都替换成newChar --- O(n) toLowerCase(); // 返回一个新的字符串全部转成小写 --- O(n) toUpperCase(); // 返回一个新的字符串全部转成大写 --- O(n) trim(); // 去除首尾空白字符，包括 \\\\t \\\\r \\\\n --- O(n) strip(); // 去除首尾空白字符，还包括中文的空格字符 \\\\u3000 也会被移除 isEmpty(); // 判断字符串是否为空 isBlank(); // 判断是否为空白字符串 split(String regex); // 传入正则表达式分隔字符串 ---- O(n) // String s = \\\"A,B,C,D\\\"; // String[] ss = s.split(\\\"\\\\\\\\,\\\"); // {\\\"A\\\", \\\"B\\\", \\\"C\\\", \\\"D\\\"} join(); // 拼接字符串，用指定的字符串连接字符串数组 // String[] arr = {\\\"A\\\", \\\"B\\\", \\\"C\\\"}; // String s = String.join(\\\"***\\\", arr); // \\\"A***B***C\\\" formatted(); // 格式化字符串，通过传入其他参数，替换占位符，生成新的字符串 format(); // 同上 // String s = \\\"Hi %s, your score is %d!\\\"; // System.out.println(s.formatted(\\\"Alice\\\", 80)); // System.out.println(String.format(\\\"Hi %s, your score is %.2f!\\\", \\\"Bob\\\", 59.5));\",\"类型转换：\",\"valueOf(); // 将任意基本类型或引用类型转换为字符串 parseInt(); // 将字符串转换为int类型 parseBoolean(); // 将字符串转换为boolean类型 getInteger(); // 将该字符串对应的系统变量转换为Integer toCharArray(); // 将字符串转换为char[]数组 // char[] cs = \\\"Hello\\\".toCharArray(); // String -> char[] // String s = new String(cs); // char[] -> String // 将char[]转byte[] byte[] b1 = \\\"Hello\\\".getBytes(); // 按系统默认编码转换，不推荐 byte[] b2 = \\\"Hello\\\".getBytes(\\\"UTF-8\\\"); // 按UTF-8编码转换 byte[] b2 = \\\"Hello\\\".getBytes(\\\"GBK\\\"); // 按GBK编码转换 byte[] b3 = \\\"Hello\\\".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 // 将已知编码的byte[]转换为String byte[] b = ... String s1 = new String(b, \\\"GBK\\\"); // 按GBK转换 String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换\"]},\"1070\":{\"h\":\"StringBuilder\",\"t\":[\"StringBuilder sb = new StringBuilder(); // 创建对象 charAt(int index); // 返回index位置的char --- O(1) length(); // 返回缓冲字符串长度 --- O(1) append(String str); // 拼接字符串 --- O(n) toString(); // 返回一个与构建起或缓冲器内容相同的字符串 --- O(n)\"]},\"1071\":{\"h\":\"集合\"},\"1072\":{\"h\":\"List 列表\",\"t\":[\"两个实现类：ArrayList、LinkedList\",\"ArrayList 底层是通过数组（动态扩容的数组）实现的，查询快\",\"LinkedList 底层是通过双向链表实现的，插入和删除快\",\"// E 表示泛型 List<E> array = new ArrayList<>(); // 顺序数组列表 List<E> array = new LinkedList<>(); // 顺序链表 ArrayList<E>(int initialCapacity); // 指定容量的空数组列表 // Set<Integer> a = new HashSet<Integer>(); List<Integer> b = new ArrayList<>(a); //接受一个集合容器 set(int index, E e); // 将元素e放在index位置，返回之前的内容 get(int index); // 返回元素位置在index的元素e --- 数组 O(1), 链表 O(n) add(E e); // 在尾部添加一个元素e --- O(1) add(int index, E e); // 后移元素，在index位置插一个元素e --- O(n) remove(int index); // 删除位于index的元素，并返回删除元素e --- 删除最后元素为O(1)， 其余为O(n) //删除最后元素 list.remove(list.size() - 1); size(); // 返回动态数组所存元素个数/链表长度 --- O(1) subList(int satrt, int end) // 相当于返回原数组的一个片段，但不要对其进行改动，改动会影响原数组 --- O(1) // List<Integer> list, 对原来的list和返回的list做的 \\\"非结构性修改\\\" // 都会影响到彼此对方. 如果你在调用了sublist返回了子list之后，如果修改了原list的大小，那么之前产生的子list将会失效，变得不可使用 trimToSize(); // 将数组列表的存储容量削减到其当前大小\"]},\"1073\":{\"h\":\"Set 集合\",\"t\":[\"Set 是一种没有重复元素的集合，三个实现类：HashSet，LinkedHashSet，TreeSet。\",\"HashSet 元素乱序\",\"LinkedHashSet 保证元素添加顺序\",\"TreeSet 元素按自然顺序排序\",\"Set<E> set = new HashSet<>(); // 实例化 //List<E> list = new ArrayList<>(); Set<E> set = new HashSet<>(list); // 传参 add(E e); // 在集合中添加元素e，若成功添加则返回true，若集合中有元素e则返回false --- O(1) remove(E e); // 在集合中删除元素e，若删除成功返回true；若集合中没有元素e，返回false --- O(1) contains(E e); // 若存在元素e，则返回true，否则返回false --- O(1) isEmpty(); // 若集合为空返回true，否则返回false --- O(1) first()、last(); // 返回有序集合中第一个元素，最后一个元素，在TreeSet类中\"]},\"1074\":{\"h\":\"Map 映射\",\"t\":[\"两个实现类：HashMap，TreeMap\",\"HashMap 键值对乱序\",\"TreeMap 键值对以 “键” 排序\",\"TreeSet 中的元素和 TreeMap 中键如果是基本数据类型（的包装类型）或者是字符串，那么就按照数值大小以及字典序排序即可，但是如果是自定义的实体类对象，就需要自己自定义排序方式。自定义排序时，需要用到 Comparable 接口或者是 Comparator 接口。\",\"自然排序 -- 使用 Comparable 接口\",\"定制排序 -- 使用 Comparator 接口\",\"Map<Characters, Integer> map = new HashMap<>(); // 实例化 put(K key, V value); // 在Map中加入键值对<key, value>，返回value值。如果Map中有key，则replace旧的value --- O(1) get(K key); // 返回Map中key对应的value。若Map中没有该key，则返回null --- O(1) getOrDefault(K key, V defaultValue); // 返回Map中key对应的value。若Map中没有该key，则返回defaultValue --- O(1) // For example: // Map<Character, Integer> map = new HashMap<>(); // if (...) // 如果发现k，则k在Map中的值加1。没一开始没有k，则从0开始加1。（相当于给了key在Map中的一个初试值） map.put('k', map.getOrDefault('k', 0) + 1); containsKey(Key key); // 在Map中若存在key，则返回true，否则返回false --- O(1) containsValue(Value value); // 在Map中若存在value，则返回true，否则返回false --- O(1) Set<Map.Entry<K, V>> entrySet(); // 返回Map.Entry对象的一个集视图，可以删除元素，但不能添加任何元素 Set<K> keySet(); // 返回一个Set,这个Set中包含Map中所有的Key --- O(1) // For example: // We want to get all keys in Map // Map<Character, Integer> map = new HashMap<>(); for (Character key : map.keySet()) { // Operate with each key } Collection<V> values(); // 返回一个Collection<V>，里面全是对应的每一个value --- O(1) // For example: // We want to get all values in Map // Map<Character, Integer> map = new HashMap<>(); for (Integer value : map.values()) { // Operate with each values } getKey(); // 返回这个映射的键 getValue(); // 返回这个映射的值 setValue(V newValue); // 将关联映射中的值改为新值，并返回原来的值 isEmpty() // 若Map为空返回true， 否则返回false --- O(1) size() // 返回Map中中键值对<K, V>的个数 --- O(1)\"]},\"1075\":{\"h\":\"栈\",\"t\":[\"java 中 Stack 继承了 Vector 类，仅仅实现栈的操作。 另外，Deque 不仅有队列（双端队列，普通队列）的特性，也可以作为栈，用法同 Stack ，方法也相同。\",\"建议使用 Deque 用作堆栈而不是 Stack 类，因为 Stack 的方法是同步的，同步的过程会消耗时间。\",\"Deque 的实现类有 ArrayDeque 和 LinkedList，但最好使用 ArrayDeque 类在 Java 中实现堆栈数据结构。\",\"Stack<E> stack = new Stack<>(); // Stack类 Deque<E> stack = new ArrayDeque<>(); // Deque接口，ArrayDeque是Deque的一个实现类 push(E e); // 入栈元素e， 返回值为元素e --- O(1) pop(); // 出栈一个元素，返回出栈元素e --- O(1) peek(); // 查看栈顶元素， 返回值为栈顶元素e --- O(1) search(); // 从堆栈的顶部返回元素的位置 --- O(1) isEmpty() // 若栈空返回true，否则返回false --- O(1) size() // 返回栈中元素个数 --- O(1)\"]},\"1076\":{\"h\":\"Queue 队列\",\"t\":[\"Queue 为接口，实现类是 LinkedList（既实现 List 接口，又实现 Queue 接口） ，特性是先进先出。\",\"Queue<E> q = new LinkedList<>(); //实例化 // 添加元素e到队尾 --- O(1) offer(E e); // 成功返回true，否则返回false add(E e); // 失败抛出异常 // 取队首元素并删除 --- O(1) poll(); // 成功返回队首元素，否则返回null remove(); // 失败抛出异常 // 不建议把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。 // 取队首元素但不删除 --- O(1) peek(); // 成功返回队首元素，否则返回null element(); // 失败抛出异常 isEmpty() // 若队空返回true，否则返回false --- O(1) size() // 返回队中元素个数 --- O(1)\"]},\"1077\":{\"h\":\"Deque 双端队列\",\"t\":[\"Deque 接口实际上扩展自 Queue，Queue 中的方法在 Deque 中也可以使用，但不建议这么做。\",\"Deque<E> q = new LinkedList<>(); //实例化 offerFirst(E e); // 将元素添加到队首 --- O(1) offerLast(E e); // 将元素添加到队尾 --- O(1) pollFirst(); // 获取队首元素并删除 --- O(1) pollLast(); // 获取队尾元素并删除 --- O(1) peekFirst(); // 获取队首元素但不删除 --- O(1) peekLast(); // 获取队尾元素但不删除 --- O(1) isEmpty(); // 非空返回true，否则返回false size(); // 队列中元素个数\"]},\"1078\":{\"h\":\"PriorityQueue 优先队列\",\"t\":[\"优先队列在添加元素的时候对元素的大小排序后再保存。PriorityQueue 对元素采用的是堆排序，头是按指定排序方式的最小元素。（堆排序只能保证根是最大/最小，整个堆并不是有序的）\",\"因此，放入 PriorityQueue 的元素，需要先定义好排序规则，才能够确保队列元素整体有序。\",\"PriorityQueue 默认按元素的排序规则排序（必须实现 Comparable 接口），也可以通过 Comparator 自定义排序算法（元素就不必实现 Comparable 接口）。\",\"// 默认实现小根堆。 PriorityQueue<E> minHeap = new PriorityQueue<>(); // 大根堆 PriorityQueue<E> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // 自定义实现最小/最大（e1-e2，升序 / e2-e1，降序） // 开始指定大小capacity = 100，当元素超过容量后会扩容 PriorityQueue<E> priorityQueue = new PriorityQueue<E>(100, new Comparator<E>(){ @Override public int compare(E e1, E e2) { return e2.val - e1.val; // 返回值大于0，表示两个元素需要更换位置，否则不需要更换 } }); offer(E e); // 在堆中加入元素，并调整堆。若成功入堆返回值true，否则返回false --- O(logN) poll(); // 获取堆顶元素并删除，重新调整堆 --- O(logN) peek(); // 获取堆顶元素但不删除 --- O(1) isEmpty(); // 判断队列是否为空 size(); // 队列中元素数量\"]},\"1079\":{\"h\":\"工具类\"},\"1080\":{\"h\":\"java.util.Math\",\"t\":[\"主要包含数学内的应用方法\",\"Math.abs(a); // 返回a的绝对值 Math.max(a, b); // 返回a和b的最大值 Math.min(a, b); // 返回a和b的最小值 Math.sqrt(a); // 开平方 Math.cbrt(b); // 开立方 Math.pow(a, b); // 返回a的b次方 Math.ceil(a); // 对浮点数向上取整 Math.floor(a); // 对浮点数向下取整 Math.round(a); // 对浮点数四舍五入 Math.log(a); // 以e为底取对数 Math.log10(a); // 以10为底取对数 Math.log(n) / Math.log(m); // 以m为底取n的对数 Math.random(); // 返回一个随机数，范围为[0,1)，返回类型为double\"]},\"1081\":{\"h\":\"java.util.Collections\",\"t\":[\"主要对集合进行操作\",\"binarySearch(arr, start, end, v); // 使用二分查找算法在有序数组arr中查找值 v --- O(logn) // 如果找到 v，则返回相应的索引；否则返回一个负数值 r。-r-1 是 v 应插入的位置（为保持 a 有序） max(Collection<E> elements); // 返回集合中最大的元素 min(Collection<E> elements); // 返回集合中最小的元素 fill(Collection<E> c, V value); // 将集合的所有元素设置为 v addAll(Collection<E> c, V...values); // 将所有的值添加到给定的集合中 replaceAll(Collection<E> c, V oldvalue, V newvalue); // 用newValue替换所有等于oldValue的元素 indexOfSubList(List<E> list1, List<E> list2); // 返回list1中第一个等于list2的子列表的索引 lastIndexOfSubList(List<E> list1, List<E> list2); // 返回list1中最后一个等于list2的子列表的索引\"]},\"1082\":{\"h\":\"javafx.util.Pair<K, V>\",\"t\":[\"Java 8 的 package.json 中新增了一个 Pair<K,V> 类，表示键值对，类似于 C++ 中的 pair 二元组，实现对 first 和 second 的操作。\",\"getKey(); // 返回该pair的key值 getValue(); // 返回该pair的value值 hashCode(); // 生成该pair的哈希值 equals(E e); // 判断该pair是否和对象元素e相等 toString(); // 返回该pair的字符串表示\"]},\"1083\":{\"h\":\"基本类型的最大值和最小值\",\"t\":[\"数字类型包装类都支持两个常量：MAX_VALUE，MIN_VALUE，分别保存了对应基本类型的最大值与最小值。\",\"fmax = Float.MAX_VALUE; fmin = Float.MIN_VALUE; dmax = Double.MAX_VALUE; dmin = Double.MIN_VALUE; bmax = Byte.MAX_VALUE; bmin = Byte.MIN_VALUE; cmax = Character.MAX_VALUE; cmin = Character.MIN_VALUE; shmax = Short.MAX_VALUE; shmin = Short.MIN_VALUE; imax = Integer.MAX_VALUE; imin = Integer.MIN_VALUE; lmax = Long.MAX_VALUE; lmin = Long.MIN_VALUE;\"]},\"1084\":{\"c\":[\"Java\"]},\"1085\":{\"c\":[\"API\"]},\"1086\":{\"h\":\"MinIO 安装与部署\",\"t\":[\"官方仓库\",\"GitHub：https://github.com/minio\",\"GItee镜像：https://gitee.com/mirrors/minio\",\"官网下载：https://www.minio.org.cn/download.shtml#/\"]},\"1087\":{\"h\":\"Linux 安装启动\",\"t\":[\"下载安装包：\",\"wget https://dl.minio.org.cn/server/minio/release/linux-amd64/minio\",\"赋予可执行权限：\",\"chmod +x minio\",\"前台启动：\",\"MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address \\\":9001\\\"\",\"命令解释：\",\"MINIO_ROOT_USER=admin：指定MinIO的用户名\",\"MINIO_ROOT_PASSWORD=password：指定MinIO密码 （用户名和密码都可以省略，默认均为 minioadmin）\",\"./minio server：在 minio 所在目录下启动 minio 服务，可修改\",\"/mnt/data：指定数据存放位置，可以自定义修改\",\"--console-address \\\":9001\\\"：指定 MinIO 控制台的监听地址和端口\",\"后台启动：\",\"# 最简单的，只需要在最后面加上 & 即可，但关闭会话服务会停止 nohub ./minio server /mnt/data > /opt/minio/data/minio.log 2>&1 --console-address \\\":9001\\\" &\",\"命令解释：\",\"nohup：这是一个 Unix 命令，用于运行另一个命令在后台，并且忽略挂起（HUP）信号，即使你退出了终端或关闭了会话，该命令也会继续执行；\",\"> /opt/minio/data/minio.log：这部分是将标准输出（stdout）重定向到 /opt/minio/data/minio.log 文件，这意味着 MinIO 服务器的所有正常输出（如启动信息、状态更新等）都会被写入到这个日志文件中；\",\"2>&1：这部分是将标准错误输出（stderr）重定向到标准输出（stdout），即输出到 /opt/minio/data/minio.log 文件，这样，无论是标准输出还是错误输出，都会被写入到同一个日志文件中；\",\"&：这个符号是在命令的末尾，用于将命令放到后台执行，也就是即使你启动了 MinIO 服务器，你的终端或 shell 会话也不会被阻塞，你可以继续执行其他命令；\"]},\"1088\":{\"h\":\"Docker 安装启动\",\"t\":[\"搜索 MinIO 镜像：\",\"docker search minio\",\"拉取 MinIO 镜像：\",\"docker pull minio/minio\",\"启动 MinIO 容器：\",\"docker run -p 9000:9000 -p 9001:9001 minio/minio server /mnt/docker/data --console-address \\\":9001\\\"\"]},\"1089\":{\"h\":\"Windows 安装启动\",\"t\":[\"下载 Windows 版的 MinIO：\",\"https://dl.min.io/server/minio/release/windows-amd64/minio.exe\",\"进入到 minio.exe 所在的目录，导航栏输入 cmd 进入终端，执行：\",\"minio.exe server D:\\\\dev\\\\MinIO\\\\data --console-address \\\":9001\\\"\",\"启动 MinIO 服务，其中 D:\\\\dev\\\\MinIO\\\\data 是 MinIO 存储数据的目录路径\",\"在浏览器输入 http://localhost:9000/，登录 MinIO 服务器 web 管理后台\",\"提示\",\"默认用户名和密码都是 minioadmin\"]},\"1090\":{\"h\":\"Windows 后台服务安装\",\"t\":[\"使用上述命令将 MinIO 在 Windows 上启动，关闭终端后服务就会停止。如果要使用 Windows 搭建 MinIO 服务器，需要将其注册为 Windows 服务。\",\"下载 WinSW-x64.exe：https://github.com/winsw/winsw/releases\",\"将 WinSW.exe 复制到自己指定的目录，重命名为 minio-server.exe.\",\"在同目录下创建 minio-server.xml。注意，xml 和 exe 必须同名。\",\"配置 minio-server.xml 文件，内容如下:\",\"<service> <id>minio-server</id> <name>minio-server</name> <description>minio文件存储服务</description> <executable>%BASE%\\\\minio.exe</executable> <arguments>server \\\"%BASE%\\\\data\\\"</arguments> <logpath>%BASE%\\\\logs</logpath> <log mode=\\\"roll-by-size-time\\\"> <sizeThreshold>10240</sizeThreshold> <pattern>yyyyMMdd</pattern> <autoRollAtTime>00:00:00</autoRollAtTime> <zipOlderThanNumDays>5<zipOlderThanNumDays> <zipDateFormat>yyyyMMdd</zipDateFormat> </log> </service>\",\"执行 cmd 命令注册系统服务\",\"minio-server.exe install\",\"卸载服务\",\"minio-server.exe uninstall\"]},\"1091\":{\"c\":[\"中间件\"]},\"1092\":{\"c\":[\"MinIO\"]},\"1093\":{\"h\":\"MinIO 概述\",\"t\":[\"官网链接\",\"MinIO官网：https://min.io/\",\"中文官网：http://minio.org.cn/\",\"MinIO 是一个高性能的分布式对象存储系统，基于 Apache License v2.0 开源协议，兼容亚马逊 S3 云存储服务接口，非常适合存储大容量的数据，包括但不限于：\",\"文本数据：新闻报道、社交媒体文章、博客......\",\"语音数据：音频形式存储的数据，语音mp3文件......\",\"图像数据：各种图片......\",\"视频数据：各种视频、电影......\",\"非结构化数据：没有明确结构的数据，比如社交评论、日志文件......\"]},\"1094\":{\"h\":\"什么是对象存储？\",\"t\":[\"对象存储（Object Storage）是一种数据存储架构，它以对象为单位来处理、存储和检索数据，每个对象都包含了数据本身以及元数据，适合存放任意类型的文件。通常通过基于 HTTP 或 HTTPS 协议的 API（应用程序编程接口）进行数据读写。常见的有阿里云对象存储服务（OSS）、腾讯云对象存储（COS）等。\",\"所以基于对象的形式， MinIO 存储的元数据主要包括对象的描述信息，如用户（account）、存储桶（bucket）以及存储桶索引（bucket index）等。\",\"对于企业来说，可以使用各种公有云提供的 OSS 服务，将业务数据存储在云上，既能节省存储成本，也能使用云存储服务提供的 API 接口，方便使用和管理数据。但对于数据传输的安全性和及时性有较高要求的业务来说，使用公有云的 OSS 服务，就要付出较高的公网带宽传输成本，以及对数据安全的保障服务。在这种情况下，利用 MinIO 轻便、高性能、可拓展性的特点，企业可以快速搭建自己的内部对象存储服务。\",\"当然，对于个人来说，MinIO 是 100% 开源的，这就意味着个人也可以基于 MinIO 搭建自己专属的对象存储服务器。\"]},\"1095\":{\"h\":\"特点\",\"t\":[\"文档全面： MinIO 作为一款基于 Golang 语言开发的一款高性能的分布式式存储方案的开源项目，有十分完善的官方文档。\",\"MinIO 文档\",\"中文文档地址：https://www.minio.org.cn/docs/minio/\",\"高性能： MinIO 号称是目前速度最快的对象存储服务器。在标准硬件上，对象存储的读/写速度最高可以高达 183GB/s 和 171GB/s。对象存储可以作为主存储层，用来处理 Spark、Presto、TensorFlow、HAO.ai 等各种复杂工作负载以及成为 Hadoop HDFS 的替代品。\",\"云原生： 容器化、基于 K8S 的编排、多租户支持。 用作云原生应用程序的主要存储，和传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。\",\"可拓展： 不同 MinIO 集群可以组成联邦，并形成一个全局的命名空间，并且支持跨越多个数据中心。 并且除了 MinIO 自己的文件系统，还支持 DAS、 JBODs、NAS、Google 云存储和 Azure Blob 存储。\",\"Amazon S3 标准兼容: 亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界内大家都认可的标准。MinIO 在很早的时候就采用了 S3 兼容协议，并且 MinIO 是第一个支持 S3 Select 的产品。 使用 Amazon S3 v2 / v4 API，可以使用 MinIO SDK，MinIO Client，AWS SDK 和 AWS CLI 访问 MinIO 服务器。\",\"支持全面： 目前 MinIO 支持市面主流的开发语言并且可以通过 SDK 快速集成快速集成使用。\",\"常用语言的 SDK\",\"GO SDK：https://github.com/minio/minio-go\",\"Java SDK：https://github.com/minio/minio-java\",\"Python SDK：https://github.com/minio/minio-py\",\"可视化管理界面： MinIO 除了通过传统的命令行进行操作之外，还提供可视化的操作管理界面，在服务安装后，可以直接通过浏览器登录系统，完成文件夹、文件的管理，非常方便使用。\",\"数据存储高容错： Minio 的存储机制使用纠删码（Erasure Code）和校验和（CheckSum）。 校验和：保护数据免受硬件故障和无声数据损坏。 纠删码：是一种恢复丢失和损坏数据的数学算法。通过数学算法将数据分割成多个数据块和校验块，并将这些块分散存储在不同的磁盘上。这种机制使得即使部分磁盘发生故障，也能通过剩余的数据块和校验块恢复原始数据，从而提高系统的可靠性和容错能力。 具体地，MinIO 使用 Reed-Solomon 码作为其纠删码算法，将一个对象拆分成 N/2 份数据和 N/2 份奇偶校验块。如果是 12 块盘，一个对象会被分成 6 个数据块、 6 个奇偶校验块，可以丢失任意 6 块盘（不管其是存放的数据块还是奇偶校验块），仍可以从剩下的盘中的数据进行恢复。 这样的设计，保证了即使在最坏的情况，即丢失一半数量的硬盘的情况下仍能保证数据的安全性。\"]},\"1096\":{\"c\":[\"中间件\"]},\"1097\":{\"c\":[\"MinIO\"]},\"1098\":{\"h\":\"SpringBoot 整合 MinIO\"},\"1099\":{\"h\":\"引入依赖\",\"t\":[\"<dependency> <groupId>io.minio</groupId> <artifactId>minio</artifactId> <version>8.5.9</version> </dependency>\"]},\"1100\":{\"h\":\"配置文件\",\"t\":[\"MinIO 中的 Bucket、Object\",\"Bucket 是存储 Object 的逻辑空间，每个 Bucket 之间的数据是相互隔离的，对用户而言，相当于存放文件的顶层文件夹\",\"Object 是存储到 MinIO 的基本对象，对用户而言，相当于文件\",\"SpringBoot 使用 MinIO 非常方便，只需要创建 MinIOClient 即可，后续通过调用 API 对 MinIO 服务进行配置和操作。\",\"在 application.yml 中配置 MinIO 连接信息\",\"minio: endpoint: http://localhost:9000 # 服务器地址和端口 accessKey: minioadmin # minio用户名 secretKey: minioadmin # minio密码 bucket: user-bucket # 使用的存储桶（可选）\",\"添加 MinIO 实体类\",\"@Data @Component @ConfigurationProperties(prefix = \\\"minio\\\") public class MinIOInfo { private String endpoint; private String accessKey; private String secretKey; private String bucket; }\",\"将 MinIOClient 注册为 Bean 对象，后续通过注入 minioClient 对象即可实现对 MinIO 的操作。\",\"@Configuration public class Config { @Resource private MinIOInfo minIOInfo; @Bean public MinioClient minioClient() { //链式编程，构建MinioClient对象 return MinioClient.builder() .endpoint(minIOInfo.getEndpoint()) .credentials(minIOInfo.getAccessKey(), minIOInfo.getSecretKey()) .build(); } }\",\"支持多线程\",\"MinioClient 对象是单例的，那么有没有线程安全问题呢？\",\"答案是：没有线程安全问题。MinIO 官方团队表示，可以多个线程共同使用一个 MinIOClient 对象。\"]},\"1101\":{\"h\":\"MinioClient 的常用 API\"},\"1102\":{\"h\":\"Bucket 操作\",\"t\":[\"bucketExists()：用于检查指定的存储桶是否存在，返回布尔值，表示存储桶是否存在\",\" void test01() throws Exception { boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(\\\"myfile\\\").build()); System.out.println(\\\"myfile目录是否存在：\\\" + isBucketExists); }\",\"makeBucket()：用于创建一个新的存储桶（bucket），需要指定存储桶的名称\",\" void test02() throws Exception { String bucketName = \\\"myfile2\\\"; boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build()); if (!isBucketExists) { minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build()); } else { System.out.println(\\\"bucket已经存在，不需要创建\\\"); } String policyJsonString = \\\"{\\\\\\\"Version\\\\\\\" : \\\\\\\"2012-10-17\\\\\\\",\\\\\\\"Statement\\\\\\\":[{\\\\\\\"Sid\\\\\\\":\\\\\\\"PublicRead\\\\\\\",\\\\\\\"Effect\\\\\\\":\\\\\\\"Allow\\\\\\\",\\\\\\\"Principal\\\\\\\":{\\\\\\\"AWS\\\\\\\":\\\\\\\"*\\\\\\\"},\\\\\\\"Action\\\\\\\":[\\\\\\\"s3:GetObject\\\\\\\"],\\\\\\\"Resource\\\\\\\":[\\\\\\\"arn:aws:s3:::\\\" + bucketName + \\\"/*\\\\\\\"]}]}\\\"; //创建存储桶的时候，设置该存储桶里面的文件的访问策略，运行公开的读； minioClient.setBucketPolicy(SetBucketPolicyArgs.builder() .bucket(bucketName) .config(policyJsonString)//json串，里面是访问策略 .build()); }\",\"listBuckets()：用于列出用户有权访问的所有存储桶，返回存储桶的列表\",\" void test03() throws Exception { List<Bucket> bucketList = minioClient.listBuckets(); bucketList.forEach(bucket -> { System.out.println(bucket.name() + \\\" -- \\\" + bucket.creationDate()); }); }\",\"removeBucket()：用于删除一个已存在的存储桶（bucket），删除失败会抛出异常\",\" void test04() throws Exception { minioClient.removeBucket(RemoveBucketArgs.builder().bucket(\\\"myfile2\\\").build()); }\"]},\"1103\":{\"h\":\"Object 操作\",\"t\":[\"putObject()：用于上传文件到指定的存储桶\",\" void test05() throws Exception { File file = new File(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\"); // 文件路径 ObjectWriteResponse objectWriteResponse = minioClient.putObject(PutObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .stream(new FileInputStream(file), file.length(), -1) // 使用stream流读取文件，自动获取文件大小 .build() ); System.out.println(objectWriteResponse); ObjectWriteResponse objectWriteResponse2 = minioClient.uploadObject(UploadObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test2.jpg\\\") .filename(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\") // 指定文件路径 .build() ); System.out.println(objectWriteResponse); }\",\"statObject()：用于检查指定的对象（文件）的状态\",\" void test06() throws Exception { StatObjectResponse statObjectResponse = minioClient.statObject(StatObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(statObjectResponse); }\",\"getPresignedObjectUrl()：用于生成一个对象（文件）的签名URL，以便可以通过HTTP访问\",\" void test07() throws Exception { String presignedObjectUrl = minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .expiry(3, TimeUnit.MINUTES) .method(Method.GET) .build() ); System.out.println(presignedObjectUrl); }\",\"getObject()：用于从指定的存储桶中下载文件\",\" void test08() throws Exception { GetObjectResponse getObjectResponse = minioClient.getObject(GetObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(getObjectResponse.transferTo(new FileOutputStream(\\\"D:\\\\\\\\MinIO\\\\\\\\123.jpg\\\"))); }\",\"listObjects()：用于列出指定存储桶中的所有对象（文件）\",\" void test09() throws Exception { Iterable<Result<Item>> listObjects = minioClient.listObjects(ListObjectsArgs.builder() .bucket(\\\"myfile\\\") .build() ); listObjects.forEach( itemResult -> { try { Item item = itemResult.get(); System.out.println(item.objectName()); } catch (Exception e) { throw new RuntimeException(e); } }); }\",\"removeObject()：用于删除指定存储桶中的对象，需要指定存储桶名称和对象键\",\" void test10() throws Exception { minioClient.removeObject(RemoveObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); }\"]},\"1104\":{\"c\":[\"中间件\"]},\"1105\":{\"c\":[\"MinIO\"]},\"1106\":{\"h\":\"Shell 语法\"},\"1107\":{\"h\":\"概论\",\"t\":[\"shell 是我们通过命令行与操作系统沟通的语言。\",\"shell 脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 AC Terminal 中的命令行可以看成是一个\\\"shell脚本在逐行执行\\\"。\",\"Linux 中常见的 shell 脚本有很多种，常见的有：\",\"Bourne Shell ( /usr/bin/sh 或 /bin/sh )\",\"Bourne Again Shell ( /bin/bash )\",\"C Shell ( /usr/bin/csh )\",\"K Shell ( /usr/bin/ksh )\",\"zsh ...\",\"Linux 系统中一般默认使用 bash，所以接下来讲解 bash 中的语法。 文件开头需要写 #! /bin/bash ，指明 bash 为脚本解释器。\",\"学习技巧\",\"不要死记硬背，遇到含糊不清的地方，可以在 AC Terminal 里实际运行一遍。\",\"脚本示例\",\"新建一个 test.sh 文件，内容如下：\",\"#! /bin/bash echo \\\"Hello World!\\\"\",\"运行方式\",\"作为可执行文件\",\"acs@9e0ebfcd82d7:~$ chmod +x test.sh # 使脚本具有可执行权限 acs@9e0ebfcd82d7:~$ ./test.sh # 当前路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ /home/acs/test.sh # 绝对路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ ~/test.sh # 家目录路径下执行 Hello World! # 脚本输出\",\"用解释器执行\",\"acs@9e0ebfcd82d7:~$ bash test.sh Hello World! # 脚本输出\"]},\"1108\":{\"h\":\"1. 注释\"},\"1109\":{\"h\":\"1.1 单行注释\",\"t\":[\"每行中 # 之后的内容均是注释。\",\"# 这是一行注释 echo 'Hello World' # 这也是注释\"]},\"1110\":{\"h\":\"1.2 多行注释\",\"t\":[\"格式：\",\":<<EOF 第一行注释 第二行注释 第三行注释 EOF\",\"其中 EOF 可以换成其它任意字符串。例如：\",\":<<abc 第一行注释 第二行注释 第三行注释 abc :<<! 第一行注释 第二行注释 第三行注释 !\"]},\"1111\":{\"h\":\"2. 变量\"},\"1112\":{\"h\":\"2.1 定义变量\",\"t\":[\"定义变量，不需要加 $ 符号，例如：\",\"name1='yxc' # 单引号定义字符串 name2=\\\"yxc\\\" # 双引号定义字符串 name3=yxc # 也可以不加引号，同样表示字符串\"]},\"1113\":{\"h\":\"2.2 使用变量\",\"t\":[\"使用变量，需要加上 $ 符号，或者 ${} 符号。花括号是可选的，主要为了帮助解释器识别变量边界。\",\"name=yxc echo $name # 输出yxc echo ${name} # 输出yxc echo ${name}acwing # 输出yxcacwing\"]},\"1114\":{\"h\":\"2.3 只读变量\",\"t\":[\"使用 readonly 或者 declare 可以将变量变为只读。\",\"name=yxc readonly name declare -r name # 两种写法均可 name=abc # 会报错，因为此时name只读\"]},\"1115\":{\"h\":\"2.4 删除变量\",\"t\":[\"unset 可以删除变量。\",\"name=yxc unset name echo $name # 输出空行\"]},\"1116\":{\"h\":\"2.5 变量类型\",\"t\":[\"自定义变量（局部变量）\",\"子进程不能访问的变量\",\"环境变量（全局变量）\",\"子进程可以访问的变量\",\"自定义变量改成环境变量：\",\"acs@9e0ebfcd82d7:~$ name=yxc # 定义变量 acs@9e0ebfcd82d7:~$ export name # 第一种方法 acs@9e0ebfcd82d7:~$ declare -x name # 第二种方法\",\"环境变量改为自定义变量：\",\"acs@9e0ebfcd82d7:~$ export name=yxc # 定义环境变量 acs@9e0ebfcd82d7:~$ declare +x name # 改为自定义变量\"]},\"1117\":{\"h\":\"2.6 字符串\",\"t\":[\"字符串可以用单引号，也可以用双引号，也可以不用引号。\",\"单引号与双引号的区别：\",\"单引号中的内容会原样输出，不会执行、不会取变量；\",\"双引号中的内容可以执行、可以取变量；\",\"name=yxc # 不用引号 echo 'hello, $name \\\\\\\"hh\\\\\\\"' # 单引号字符串，输出 hello, $name \\\\\\\"hh\\\\\\\" echo \\\"hello, $name \\\\\\\"hh\\\\\\\"\\\" # 双引号字符串，输出 hello, yxc \\\"hh\\\"\",\"获取字符串长度\",\"name=\\\"yxc\\\" echo ${#name} # 输出3\",\"提取子串\",\"name=\\\"hello, yxc\\\" echo ${name:0:5} # 提取从0开始的5个字符\"]},\"1118\":{\"h\":\"3. 默认变量\"},\"1119\":{\"h\":\"3. 1 文件参数变量\",\"t\":[\"在执行 shell 脚本时，可以向脚本传递参数。$1 是第一个参数，$2 是第二个参数，以此类推。特殊的，$0 是文件名（包含路径）。例如：\",\"创建文件 test.sh ：\",\"#! /bin/bash echo \\\"文件名：\\\"$0 echo \\\"第一个参数：\\\"$1 echo \\\"第二个参数：\\\"$2 echo \\\"第三个参数：\\\"$3 echo \\\"第四个参数：\\\"$4\",\"然后执行该脚本：\",\"acs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4 文件名：./test.sh 第一个参数：1 第二个参数：2 第三个参数：3 第四个参数：4\"]},\"1120\":{\"h\":\"3.2 其它参数相关变量\",\"t\":[\"参数\",\"说明\",\"$#\",\"代表文件传入的参数个数，如上例中值为4\",\"$*\",\"由所有参数构成的用空格隔开的字符串，如上例中值为 \\\"$1 $2 $3 $4\\\"\",\"$@\",\"每个参数分别用双引号括起来的字符串，如上例中值为 \\\"$1\\\" \\\"$2\\\" \\\"$3\\\" \\\"$4\\\"\",\"$$\",\"脚本当前运行的进程ID\",\"$?\",\"上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\",\"$(command)\",\"返回 command这条命令的stdout（可嵌套）\",\"command\",\"返回 command 这条命令的stdout（不可嵌套）\"]},\"1121\":{\"h\":\"4. 数组\",\"t\":[\"数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。 数组 下标从0开始。\"]},\"1122\":{\"h\":\"4.1 定义\",\"t\":[\"数组用小括号表示，元素之间用空格隔开。例如：\",\"array=(1 abc \\\"def\\\" yxc)\",\"也可以直接定义数组中某个元素的值：\",\"array[0]=1 array[1]=abc array[2]=\\\"def\\\" array[3]=yxc\"]},\"1123\":{\"h\":\"4.2 读取数组中某个元素的值\",\"t\":[\"格式：\",\"${array[index]}\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${array[0]} echo ${array[1]} echo ${array[2]} echo ${array[3]}\"]},\"1124\":{\"h\":\"4.3 读取整个数组\",\"t\":[\"格式：\",\"${array[@]} # 第一种写法 ${array[*]} # 第二种写法\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${array[@]} # 第一种写法 echo ${array[*]} # 第二种写法\"]},\"1125\":{\"h\":\"4.4 数组长度\",\"t\":[\"类似于字符串\",\"${#array[@]} # 第一种写法 ${#array[*]} # 第二种写法\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${#array[@]} # 第一种写法 echo ${#array[*]} # 第二种写法\"]},\"1126\":{\"c\":[\"Linux\"]},\"1127\":{\"c\":[\"基础\"]},\"1128\":{\"h\":\"深入理解 IoC\"},\"1129\":{\"h\":\"1. IoC 理论\",\"t\":[\"IoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection），即依赖注入。\",\"如何理解 “控制反转” 呢？关键在于我们需要回答如下四个问题：\",\"谁控制谁\",\"控制什么\",\"为何是反转\",\"哪些方面反转了\",\"在回答这四个问题之前，我们先看 IoC 的定义：\",\"IoC\",\"所谓 IoC ，就是由 Spring IoC 容器来负责对象的生命周期和对象之间的关系。\",\"在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IoC Service Provider 为被注入对象服务的目的。所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IoC Service Provider）送过来。\",\"流程如下：\",\"现在在看上面那四个问题，答案就显得非常明显了:\",\"谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象\",\"控制什么：控制对象。\",\"为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。\",\"哪些方面反转了：所依赖对象的获取被反转了。\"]},\"1130\":{\"h\":\"2. Bromon 的 blog 上对 IoC 与 DI 浅显易懂的讲解\"},\"1131\":{\"h\":\"2.1 IoC\",\"t\":[\"首先想说说 IoC（Inversion of Control，控制反转）。这是 spring 的核心，贯穿始终。\",\"所谓 IoC，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。\",\"这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己 new 一个，或者从 JNDI 中查询一个），使用完之后还要将对象销毁（比如 Connection 等），对象始终会和其他的接口或类藕合起来。\",\"那么 IoC 是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在 spring 容器中登记，告诉 spring 你是个什么东西，你需要什么东西，然后 spring 会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。\",\"所有的类的创建、销毁都由 spring 来控制，也就是说控制对象生存周期的不再是引用它的对象，而是 spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被 spring 控制，所以这叫控制反转。\",\"即：获得依赖对象的方式反转了。\"]},\"1132\":{\"h\":\"2.2 DI\",\"t\":[\"IoC 的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过 DI（Dependency Injection，依赖注入）来实现的。\",\"比如对象 A 需要操作数据库，以前我们总是要在 A 中自己编写代码来获得一个 Connection 对象，有了 spring 我们就只需要告诉 spring，A 中需要一个 Connection，至于这个 Connection 怎么构造，何时构造，A 不需要知道。在系统运行时，spring 会在适当的时候制造一个 Connection，然后像打针一样，注射到 A 当中，这样就完成了对各个对象之间关系的控制。A 需要依赖 Connection 才能正常运行，而这个 Connection 是由 spring 注入到 A 中的，依赖注入的名字就这么来的。\",\"那么 DI 是如何实现的呢？Java 1.3 之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring 就是通过反射来实现注入的。\",\"理解了 IoC 和 DI 的概念后，一切都将变得简单明了，剩下的工作只是在 spring 的框架中堆积木而已。\"]},\"1133\":{\"h\":\"3. 注入形式\",\"t\":[\"IoC Service Provider 为被注入对象提供被依赖对象有如下几种方式：构造方法注入、stter方法注入、接口注入。\",\"1）构造器注入\",\"构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。\",\"YoungMan(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; }\",\"构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。\",\"2）setter 方法注入\",\"对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：\",\"public class YoungMan { private BeautifulGirl beautifulGirl; public void setBeautifulGirl(BeautifulGirl beautifulGirl) { this.beautifulGirl = beautifulGirl; } }\",\"相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。\",\"3）接口方式注入\",\"接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。\",\"可以看下 《依赖注入的三种实现形式 —— 接口注入（Interface Injection）》\"]},\"1134\":{\"h\":\"4. 各个组件\",\"t\":[\"先上图：\",\"该图为 ClassPathXmlApplicationContext 的类继承体系结构，虽然只有一部分，但是它基本上包含了 IoC 体系中大部分的核心类和接口。\",\"下面我们就针对这个图进行简单的拆分和补充说明\"]},\"1135\":{\"h\":\"4.1 Resource 体系\",\"t\":[\"org.springframework.core.io.Resource，对资源的抽象。它的每一个实现类都代表了一种资源的访问策略，如 ClassPathResource、RLResource、FileSystemResource 等。\",\"Resource 类图\"]},\"1136\":{\"h\":\"4.2 ResourceLoader 体系\",\"t\":[\"有了资源，就应该有资源加载，Spring 利用 org.springframework.core.io.ResourceLoader 来进行统一资源加载，类图如下：\",\"ResourceLoader 类图\"]},\"1137\":{\"h\":\"4.3 BeanFactory 体系\",\"t\":[\"org.springframework.beans.factory.BeanFactory，是一个非常纯粹的 bean 容器，它是 IoC 必备的数据结构，其中 BeanDefinition 是它的基本结构。BeanFactory 内部维护着一个BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。\",\"BeanFactory 类图\",\"BeanFactory 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。\",\"DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。\"]},\"1138\":{\"h\":\"4.4 BeanDefinition 体系\",\"t\":[\"org.springframework.beans.factory.config.BeanDefinition，用来描述 Spring 中的 Bean 对象。\",\"BeanDefinition 类图\"]},\"1139\":{\"h\":\"4.5 BeanDefinitionReader 体系\",\"t\":[\"org.springframework.beans.factory.support.BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构：BeanDefinition 。\",\"BeanDefinitionReader 类图\"]},\"1140\":{\"h\":\"4.6 ApplicationContext 体系\",\"t\":[\"org.springframework.context.ApplicationContext，这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有：\",\"继承 org.springframework.context.MessageSource 接口，提供国际化的标准访问策略。\",\"继承 org.springframework.context.ApplicationEventPublisher 接口，提供强大的事件机制。\",\"扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。\",\"对 Web 应用的支持。\",\"下图来源：https://blog.csdn.net/yujin753/article/details/47043143\",\"ApplicationContext 类图\"]},\"1141\":{\"h\":\"4.7 小结\",\"t\":[\"上面五个体系可以说是 Spring IoC 中最核心的部分，后续也会针对这五个部分进行分析。其实 IoC 咋一看还是挺简单的，无非就是将配置文件（暂且认为是 xml 文件）进行解析（分析 xml 谁不会啊），然后放到一个 Map 里面就差不多了，初看有道理，其实要面临的问题还是有很多的。\",\"另外，通过上面五个体系，我们可以看出，IoC 主要由 spring-beans 和 spring-context 项目，进行实现。\"]},\"1142\":{\"c\":[\"常用框架\"]},\"1143\":{\"c\":[\"Spring\"]},\"1144\":{\"h\":\"1. 领导让我研究 Eureka 源码：启动过程\",\"t\":[\"转载自悟空聊架构，原文链接：领导让我研究 Eureka 源码 | 启动过程\"]},\"1145\":{\"h\":\"一、初始化环境\",\"t\":[\"打开源码，找到这个启动类，EurekaBootStrap.java，在这个路径下：\",\"\\\\eureka\\\\eureka-core\\\\src\\\\main\\\\java\\\\com\\\\netflix\\\\eureka\\\\EurekaBootStrap.java\",\"启动时序图给大家画好了：\",\"初始化环境时序图\",\"启动代码：\",\"@Override public void contextInitialized(ServletContextEvent event) { initEurekaEnvironment(); initEurekaServerContext(); // 省略非核心代码 }\",\"分为两步，初始化环境和初始化上下文，先来看第一步。\",\"初始化环境的方法是 initEurekaEnvironment()，点进去看下这个方法做了什么。\",\"String dataCenter = ConfigurationManager.getConfigInstance() .getString(EUREKA_DATACENTER);\",\"就是获取配置管理类的一个单例。单例的实现方法用的是 双重检测 + volatile\",\"public static AbstractConfiguration getConfigInstance() { if (instance == null) { synchronized (ConfigurationManager.class) { if (instance == null) { instance = getConfigInstance(false)); } } } return instance; }\",\"instance 变量定义成了 volatile，保证可见性。\",\"static volatile AbstractConfiguration instance = null;\",\"线程 A 修改后，会将变量的值刷到主内存中，线程 B 会将主内存中的值刷回到自己的线程内存中，也就是说线程 A 改了后，线程 B 可以看到改了后的值。\",\"可以参考之前我写的文章：反制面试官 - 14 张原理图 - 再也不怕被问 volatile\"]},\"1146\":{\"h\":\"二、初始化上下文\",\"t\":[\"初始化上下文的时序图如下：\",\"初始化上下文的时序图\",\"还是在 EurekaBootStrap.java 类中 contextInitialized 方法中，第二步调用了 initEurekaServerContext() 方法。\",\"initEurekaServerContext 里面主要的操作分为六步：\",\"第一步就是加载配置文件。\"]},\"1147\":{\"h\":\"2.1 加载 eureka-server 配置文件\",\"t\":[\"基于接口的方式，获取配置项。\",\"initEurekaServerContext 方法创建了一个 eurekaServerConfig 对象：\",\"EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();\",\"EurekaServerConfig 是一个接口，里面定义了很多获取配置项的方法。和定义常量来获取配置项的方式不同。比如获取 AccessId 和 SecretKey。\",\"String getAWSAccessId(); String getAWSSecretKey();\",\"还有另外一种获取配置项的方式：Config.get(Constants.XX_XX)，这种方式和上面的接口的方式相比：\",\"常量的方式较容易取错变量。因为常量的定义都是大写，很可能拿到 XX_XY 变量，而接口的方法是驼峰命名的，更容易辨识，对于相似的变量，取一个辨识度更高的方法名即可。\",\"常量的方式不易于修改。假如修改了常量名称，则需要全局搜索用到的地方，都改掉。如果是用接口的方式，则只需要修改接口方法中引用常量的地方即可，对于调用接口方法的地方是透明的。\"]},\"1148\":{\"h\":\"2.1.1 创建默认的 eureka server 配置\",\"t\":[\"new DefaultEurekaServerConfig()，会创建出一个默认的 server 配置，构造方法会调用 init 方法：\",\"public DefaultEurekaServerConfig() { init(); }\"]},\"1149\":{\"h\":\"2.2.2 加载配置文件\",\"t\":[\"private void init() { String env = ConfigurationManager.getConfigInstance() .getString(EUREKA_ENVIRONMENT, TEST); ConfigurationManager.getConfigInstance() .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env); String eurekaPropsFile = EUREKA_PROPS_FILE.get(); try { ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile); } catch (IOException e) { logger.warn( \\\"Cannot find the properties specified : {}. This may be okay if there are other environment \\\" + \\\"specific properties or the configuration is installed with a different mechanism.\\\", eurekaPropsFile); } }\",\"前两行是设置环境名称，后面几行是关键语句：获取配置文件，并放到 ConfigurationManager 单例中。\",\"来看下 EUREKA_PROPS_FILE.get(); 做了什么。\",\"首先 EUREKA_PROPS_FILE 是这样定义的：\",\"private static final DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory.getInstance() .getStringProperty(\\\"eureka.server.props\\\", \\\"eureka-server\\\");\",\"用单例工厂 DynamicPropertyFactory 设置了默认值 eureka-server，然后 EUREKA_PROP_FILE.get() 就会从缓存里面这个默认值。\",\"然后再调用 loadCascadedPropertiesFromResources 方法，来加载配置文件。\",\"首先会拼接默认的配置文件：\",\"String defaultConfigFileName = configName + \\\".properties\\\";\",\"然后获取默认配置文件的配置项：\",\"Properties props = getPropertiesFromFile(url);\",\"然后再拼接当前环境的配置文件\",\"String envConfigFileName = configName + \\\"-\\\" + environment + \\\".properties\\\";\",\"然后获取环境的配置文件的配置项并覆盖之前的默认配置项。\",\"props.putAll(envProps);\",\"putAll 方法就是将这些属性放到一个 map 中。\",\"然后这些配置项统一都交给 ConfigurationManager 来管理：\",\"config.loadProperties(props);<br>\",\"其实就是加载这个文件：\",\"eureka-server.properties\",\"打开这个文件后，发现里面有几个 demo 配置项，不过都被注释了。\"]},\"1150\":{\"h\":\"2.1.3 真正的配置项在哪？\",\"t\":[\"上面可以看到 eureka-server.properties 都是空的，那配置项都配置在哪呢？\",\"我们之前说过，DefaultEurekaServerConfig 是实现了 EurekaServerConfig 接口的，如下所示：\",\"public class DefaultEurekaServerConfig implements EurekaServerConfig\",\"在 EurekaServerConfig 接口里面定义很多 get 方法，而 DefaultEurekaServerConfig 实现了这些 get 方法，来看下怎么实现的：\",\"@Override public int getWaitTimeInMsWhenSyncEmpty() { return configInstance.getIntProperty( namespace + \\\"waitTimeInMsWhenSyncEmpty\\\", (1000 * 60 * 5)).get(); }\",\"里面的类似这样的 getXX 的方法，都有一个 default value，比如上面的是 1000∗60∗5，所以我们可以知道，配置项是在 DefaultEurekaServerConfig 类中定义的。\",\"configInstance 这个单例又是 DynamicPropertyFactory 类型的，而在创建 configInstance 单例的时候，ConfigurationManager 还做了一些事情：将配置文件中的配置项放到 DynamicPropertyFactory 单例中，这样的话，DefaultEurekaServerConfig 中的 get 方法就可以获取到配置文件中的配置项了。具体的代码在 DynamicPropertyFactory 类中的 initWithConfigurationSource 方法中。\",\"结合上面的加载配置文件的分析，可以得出结论：如果配置文件中没有配置，则用 DefaultEurekaServerConfig 定义的默认值。\"]},\"1151\":{\"h\":\"2.1.4 加载配置文件小结\",\"t\":[\"（1）创建一个 DefaultEurekaServerConfig 对象，实现了 EurekaServerConfig 接口，里面有很多获取配置项的方法。\",\"（2）DefaultEurekaServerConfig 构造函数中调用了 init 方法。\",\"（3）init 方法会加载 eureka-server.properties 配置文件，把里面的配置项都放到一个 map 中，然后交给 ConfigurationManager 来管理。\",\"（4）DefaultEurekaServerConfig 对象里面有很多 get 方法，里面通过 hard code 定义了配置项的名称，当调用 get 方法时，调用的是 DynamicPropertyFactory 的获取配置项的方法，这些配置项如果在配置文件中有，则用配置项的。配置文件中的配置项是通过 ConfigurationManager 赋值给 DynamicPropertyFactory 的。\",\"（5）当要获取配置项时，就调用对应的 get 方法，如果配置文件没有配置，则用默认值。\"]},\"1152\":{\"h\":\"2.2 构造实例信息管理器\",\"t\":[\"结构如下图所示：\",\"实例信息管理器\"]},\"1153\":{\"h\":\"2.2.1 初始化服务实例的配置 instanceConfig\",\"t\":[\"创建了一个 ApplicationInfoManager 对象，服务配置管理器，Application 可以理解为一个 Eureka client，作为一个应用程序向 Eureka 服务注册的。\",\"applicationInfoManager = new ApplicationInfoManager( instanceConfig, new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());\",\"创建这个对象时，传了 instanceConfig，这个就是 eureka 实例的配置。这个 instanceConfig 和之前讲过的 EurekaServerConfig 很像，都是实现了一个接口，通过接口的 getXX 方法来获取配置信息。\"]},\"1154\":{\"h\":\"2.2.2 构造服务实例 instanceInfo\",\"t\":[\"另外一个参数是 EurekaConfigBasedInstanceInfoProvider，这个 Provider 是用来构造 instanceInfo（服务实例）。\",\"怎么构造出来的呢？用到了设计模式中的 构造器模式，而用到的配置信息就是从 EurekaInstanceConfig 里面获取到的。\",\"InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder(vipAddressResolver); builder.setXX ... instanceInfo = builder.build();\",\"setXX 的代码如下所示：\",\"setXX 示例\"]},\"1155\":{\"h\":\"2.2.3 小结\",\"t\":[\"（1）初始化服务实例的配置 instanceConfig。\",\"（2）用构造器模式初始化服务实例 instanceInfo。\",\"（3）将 instanceConfig 和 instanceInfo 传给了 ApplicationInfoManager，交由它来管理。\"]},\"1156\":{\"h\":\"2.3 初始化 eureka-client\"},\"1157\":{\"h\":\"2.3.1 初始化 eureka-client 配置\",\"t\":[\"eurekaClient 是包含在 eureka-server 服务中的，用来跟其他 eureka-server 进行通信的。为什么还会有其他 eureka-server，因为在集群环境中，是会有多个 eureka 服务的，而服务之间是需要相互通信的。\",\"初始化 eureka-client 代码：\",\"EurekaClientConfig eurekaClientConfig = new DefaultEurekaClientConfig(); eurekaClient = new DiscoveryClient(applicationInfoManager, eurekaClientConfig);\",\"第一行又是初始化了一个配置，和之前初始化 server config，instance config 的地方很相似。也是通过接口方法里面的 DynamicPropertyFactory 来获取配置项的值。\",\"eureka-client 也有一个加载配置文件的方法：\",\"Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);\",\"这个文件就是 eureka-client.properties。\",\"初始化配置的时候还初始化了一个 DefaultEurekaTransportConfig()，可以理解为传输的配置。\"]},\"1158\":{\"h\":\"2.3.2 初始化 eurekaClient\",\"t\":[\"再来看下第二行代码，创建了一个 DiscoveryClient 对象，赋值给了 eurekaClient。\",\"创建 DiscoveryClient 对象的过程非常复杂，我们来细看下。\",\"（1） 拿到 eureka-client 的 config 、transport 的 config、instance 实例信息。\",\"（2） 判断是否要获取注册表信息，默认会获取。\",\"if (config.shouldFetchRegistry())\",\"如果在配置文件中定义了 fetch-registry: false，则不会获取，单机 eureka 情况下，配置为 false，因为自己就包含了注册表信息，而且也不需要从其他` eureka 实例上获取配置信息。当在集群环境下，才需要获取注册表信息。\",\"（3） 判断是否要把自己注册到其他 eureka 上，默认会注册。\",\"if (config.shouldRegisterWithEureka())\",\"单机情况下，配置 register-with-eureka: false。\",\"（4） 创建了一个支持任务调度的线程池。\",\"scheduler = Executors.newScheduledThreadPool(2, new ThreadFactoryBuilder() .setNameFormat(\\\"DiscoveryClient-%d\\\") .setDaemon(true) .build());\",\"（5） 创建了一个支持心跳检测的线程池。\",\"heartbeatExecutor = new ThreadPoolExecutor( 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactoryBuilder() .setNameFormat(\\\"DiscoveryClient-HeartbeatExecutor-%d\\\") .setDaemon(true) .build() ); // use direct handoff\",\"（6） 创建了一个支持缓存刷新的线程池。\",\"cacheRefreshExecutor = new ThreadPoolExecutor( 1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactoryBuilder() .setNameFormat(\\\"DiscoveryClient-CacheRefreshExecutor-%d\\\") .setDaemon(true) .build() ); // use direct handoff\",\"（7） 创建了一个支持 eureka client 和 eureka server 进行通信的对象\",\"eurekaTransport = new EurekaTransport();\",\"（8） 初始化调度任务\",\"initScheduledTasks();\",\"这个里面就会根据 fetch-registry 来判断是否需要开始调度执行刷新注册表信息，默认 30 s 调度一次。这个刷新的操作是由一个 CacheRefreshThread 线程来执行的。\",\"同样的，也会根据 register-with-eureka 来判断是否需要开始调度执行发送心跳，默认 30 s 调度一次。这个发送心跳的操作由一个 HeartbeatThread 线程来执行的。\",\"然后还创建了一个实例信息的副本，用来将自己本地的 instanceInfo 实例信息传给其他服务。什么时候发送这些信息呢？\",\"又创建了一个监听器 statusChangeListener，这个监听器监听到状态改变时，就调用副本的 onDemandUpdate() 方法，将 instanceInfo 传给其他服务。\"]},\"1159\":{\"h\":\"2.4 处理注册相关的流程\"},\"1160\":{\"h\":\"2.4.1 注册对象\",\"t\":[\"创建了一个 PeerAwareInstanceRegistryImpl 对象，通过名字可以知道是 可以感知集群实例注册表的实现类。通过官方注释可以知道这个类的作用：\",\"处理所有的拷贝操作到其他节点，让他们保持同步。复制的操作包含 注册，续约，摘除，过期和状态变更。\",\"当 eureka server 启动后，它尝试着从集群节点去获取所有的注册信息。如果获取失败了，当前 eureka server 在一段时间内不会让其他应用获取注册信息，默认 5 分钟。\",\"自我保护机制：如果应用丢失续约的占比在一定时间内超过了设定的百分比，则 eureka 会报警，然后停止执行过期应用。\",\"registry = new PeerAwareInstanceRegistryImpl( eurekaServerConfig, eurekaClient.getEurekaClientConfig(), serverCodecs, eurekaClient );\",\"PeerAwareInstanceRegistryImpl 继承 AbstractInstanceRegistry 抽象类，构造函数主要做了以下事情：\",\"初始化 server config 和 client config 的配置信息。\",\"this.serverConfig = serverConfig; this.clientConfig = clientConfig;\",\"初始化摘除的队列，队列长度为 1000。\",\"this.recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);\",\"初始化注册的队列。\",\"this.recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);\"]},\"1161\":{\"h\":\"2.5 初始化上下文\"},\"1162\":{\"h\":\"2.5.1 集群节点帮助类\",\"t\":[\"创建了一个 PeerEurekaNodes，它是一个帮助类，来管理集群节点的生命周期。\",\"PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes( registry, eurekaServerConfig, eurekaClient.getEurekaClientConfig(), serverCodecs, applicationInfoManager );\"]},\"1163\":{\"h\":\"2.5.2 默认上下文\",\"t\":[\"创建了一个 DefaultEurekaServerContext 默认上下文。\",\"serverContext = new DefaultEurekaServerContext( eurekaServerConfig, serverCodecs, registry, peerEurekaNodes, applicationInfoManager );\"]},\"1164\":{\"h\":\"2.5.3 创建上下文的持有者\",\"t\":[\"创建了一个 holder，用来持有上下文。其他地方想要获取上下文，就通过 holder 来获取。用到了单例模式。\",\"EurekaServerContextHolder.initialize(serverContext);\",\"holder 的 initialize() 初始化方法是一个线程安全的方法。\",\"public static synchronized void initialize(EurekaServerContext serverContext) { holder = new EurekaServerContextHolder(serverContext); }\",\"定义了一个静态的私有的 holder 变量\",\"private static EurekaServerContextHolder holder;\",\"其他地方想获取 holder 的话，就通过 getInstance() 方法来获取 holder。\",\"public static EurekaServerContextHolder getInstance() { return holder; }\",\"然后想要获取上下文的就调用 holder 的 getServerContext() 方法。\",\"public EurekaServerContext getServerContext() { return this.serverContext; }\"]},\"1165\":{\"h\":\"2.5.4 初始化上下文\",\"t\":[\"调用 serverContext 的 initialize() 方法来初始化。\",\"public void initialize() throws Exception { logger.info(\\\"Initializing ...\\\"); peerEurekaNodes.start(); registry.init(peerEurekaNodes); logger.info(\\\"Initialized\\\"); }\",\"peerEurekaNodes.start();\",\"这个里面就是启动了一个定时任务，将集群节点的 URL 放到集合里面，这个集合不包含本地节点的 url。每隔一定时间，就更新 eureka server 集群的信息。\",\"registry.init(peerEurekaNodes);\",\"这个里面会初始化注册表，将集群中的 注册信息获取下，然后放到注册表里面。\"]},\"1166\":{\"h\":\"2.6 其他\"},\"1167\":{\"h\":\"2.6.1 从相邻节点拷贝注册信息\",\"t\":[\"int registryCount = registry.syncUp();\"]},\"1168\":{\"h\":\"2.6.2 eureka 监控\",\"t\":[\"EurekaMonitors.registerAllStats();\"]},\"1169\":{\"h\":\"2.7 编译报错的解决方案\"},\"1170\":{\"h\":\"1、异常1\",\"t\":[\"An exception occurred applying plugin request [id: 'nebula.netflixoss', version: '3.6.0']\",\"解决方案\",\"plugins { id 'nebula.netflixoss' version '5.1.1' }\"]},\"1171\":{\"h\":\"2、异常2\",\"t\":[\"eureka-server-governator Plugin with id 'jetty' not found.\",\"参考 https://blog.csdn.net/Sino_Crazy_Snail/article/details/79300058\"]},\"1172\":{\"h\":\"三、总结\",\"t\":[\"来一份 Eureka 启动的整体流程图\",\"Eureka 启动过程\"]},\"1173\":{\"c\":[\"常用框架\"]},\"1174\":{\"c\":[\"SpringCloud\"]},\"1175\":{\"h\":\"2. 领导“叕”让我研究 Eureka 源码：注册过程\",\"t\":[\"转载自悟空聊架构，原文链接：领导“叕”让我研究 Eureka 源码：注册过程\",\"这次我们来分析客户端是如何注册的。\",\"Eureka Client 就是客户端，可以是 Eureka Server 自身，也可以是要注册的服务实例，比如订单服务、商品服务等。\",\"后续讲到 @EnableEurekaClient 注解时，其实是将当前 Application 当作一个 eureka client，注册到 eureka 服务上。\",\"那么 Eureka Client 是如何注册的呢？\",\"我们可以通过 Eureka 源码提供的示例类 ExampleEurekaClient 来看下 Eureka Client 的构造和注册过程。\",\"首先从 main 方法方法看起，但是只看 main 表面，看不出来注册的代码在哪，那我们就来研究下底层的源码。\",\"public static void main(String[] args) throws UnknownHostException { injectEurekaConfiguration(); ExampleEurekaClient sampleClient = new ExampleEurekaClient(); // create the client ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(new MyDataCenterInstanceConfig()); EurekaClient client = initializeEurekaClient(applicationInfoManager, new DefaultEurekaClientConfig()); // shutdown the client eurekaClient.shutdown(); }\",\"接着我们来一步一步分析 main 里面做了什么事情。\",\"先放一张时序图，下文会逐步讲解。\"]},\"1176\":{\"h\":\"一、初始化配置\"},\"1177\":{\"h\":\"1.1 初始化变量\",\"t\":[\"injectEurekaConfiguration() 方法初始化了 Eureka 的一些变量，比如端口号、当前服务的访问路径、是否需要抓取注册表信息等等。\",\"private static void injectEurekaConfiguration() throws UnknownHostException { String myHostName = InetAddress.getLocalHost().getHostName(); String myServiceUrl = \\\"http://\\\" + myHostName + \\\":8080/v2/\\\"; System.setProperty(\\\"eureka.name\\\", \\\"eureka\\\"); System.setProperty(\\\"eureka.port\\\", \\\"8080\\\"); ... }\"]},\"1178\":{\"h\":\"1.2 获取配置文件配置\",\"t\":[\"在这一行代码中，将配置文件 eureka-client.properties 中的配置读取后，放到了 EurekaInstanceConfig 中。这个 EurekaInstanceConfig 是用来初始化 applicationInfoManager 信息管理器的。\",\"看下面代码，创建了一个 MyDataCenterInstanceConfig，其实就是创建了 EurekaInstanceConfig。\",\"new MyDataCenterInstanceConfig()\",\"那 MyDataCenterInstanceConfig 和 EurekaInstanceConfig 是什么关系呢？\",\"InstanceConfig 类图\",\"从类图关系中可以看到 MyDataCenterInstanceConfig 继承 PropertiesInstanceConfig 类，实现了 EurekaInstanceConfig 接口。这种接口之前专门讲过，通过接口来获取配置信息，类似这种方法 getXX()。\",\"然后在 PropertiesInstanceConfig 类的构造函数调用了一个工具类，读取了配置文件 eureka-client.properties 中的值。这个隐藏的有点深啊！\",\"Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);\"]},\"1179\":{\"h\":\"1.3 初始化实例信息\",\"t\":[\"主要就是构造出 instanceInfo 实例信息。这个里面的信息包含了第一步初始化变量中的配置信息。\",\"InstanceInfo instanceInfo = new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get();\",\"intanceInfo 信息\"]},\"1180\":{\"h\":\"1.4 初始化实例信息管理器\",\"t\":[\"就是将 instanceConfig 和 instanceInfo 交给实例信息管理器来管理。\",\"applicationInfoManager = new ApplicationInfoManager(instanceConfig, instanceInfo);\"]},\"1181\":{\"h\":\"二、构造 EurekaClient\"},\"1182\":{\"h\":\"2.1 构造流程\",\"t\":[\"构造 eurekaClient 的代码\",\"eurekaClient = new DiscoveryClient(applicationInfoManager, clientConfig);\",\"DiscoveryClient 是 EurekaClient 的子类，构造 DiscoveryClient 做了以下几件事：\",\"构造 EurekaClient 流程\",\"加载配置文件\",\"初始化网络传输组件\",\"将服务实例配置、配置文件配置、网络传输组件都赋值给了 DiscoveryClient。\",\"初始化两个线程，一个用来心跳检测，一个用来刷新缓存。\",\"初始化网络通信组件 EurekaTransport\",\"尝试抓取注册表信息，如果没有抓取到，则从备用的注册表中获取。\",\"初始化调度任务的方法中，启动了定时调度任务：心跳检测 heartbeat、缓存刷新 cacheRefresh。（这两个功能在后续篇章中都会讲到，请持续关注）\",\"初始化调度任务的方法中，初始化了一个 InstanceInfoReplicator，用来向 eureka server 注册的。\",\"初始化调度任务的方法中，初始化了一个状态变更的监听器 StatusChangeListener，这个里面也有注册的逻辑。\",\"注意\",\"在初始化调度任务的方法，会根据是否设置了抓取注册表信息和是否注册将 eureka-client 注册到 eureka-server 来执行上面的初始化操作。\",\"如下代码所示：\"]},\"1183\":{\"h\":\"三、Eureka Client 注册\"},\"1184\":{\"h\":\"3.1 注册流程\",\"t\":[\"Eureka Client 向 Server 注册的代码隐藏的比较深，很难找到，不是直接调用注册的方法，而是通过一个后台线程去做的，而且调用注册方法的类的名字起得也有争议，叫做 InstanceInfoReplicator，“Replicator” 是拷贝副本的意思，而注册其实不是拷贝副本，而是将新的注册信息发送到 eureka server 上去的，所以这个类的名字起得不太好，这也是容易造成找不到注册代码的一个原因。\",\"下面来看下 eureka client 是怎么向 eureka server 注册的。\",\"（1）注册是通过 InstanceInfoReplicator 类来注册的。它是在构造 DiscoveryClient 时创建出来的。\",\"启动了一个延时 40 s 的线程，\",\"instanceInfoReplicator.start(40); // 40 s后执行\",\"（2）然后将一个标志位设置为 true，用来标记是否注册过了。\",\"instanceInfo.setIsDirty();\",\"（3）然后调用注册的方法\",\"discoveryClient.register();\",\"register() 里面的核心代码就是\",\"httpResponse = eurekaTransport.registrationClient.register(instanceInfo);\",\"返回的 httpResponse 大家可以想到这是一个 HTTP 请求，eureka client 注册时就是发送的 http 请求。\",\"eurekaTransport：底层的传输组件，在初始化 DiscoveryClient 时初始化出来的。\",\"registrationClient：它是一个抽象类，在初始化 DiscoveryClient 时，通过调用 scheduleServerEndpointTask() 初始化了专门用于注册的 registrationClient，这里就是 SessionedEurekaHttpClient。\",\"instanceInfo：就是要发送给 eureka server 的当前实例信息，用来注册的信息。\",\"（4）发送 post 注册请求\",\"执行 register() 方法，发送注册请求的类是 AbstractJerseyEurekaHttpClient，这个类在工程 eureka-client-jersey2 里面，用到的是 Jersey 框架，国内用这个框架的不多，就是一个支持 restful 的 Java 框架，不用深究，下篇还会讲到这一块。请求的 url 为\",\"http://localhost:8080/v2/apps/EUREKA\",\"注册的方法里面发送了 post 请求。至此，Client 就注册到 Server 那边了。\",\"response = resourceBuilder .accept(MediaType.APPLICATION_JSON) .acceptEncoding(\\\"gzip\\\") .post(Entity.json(info));\",\"那么 Server 是如何将注册信息保存到自己注册表里面的呢？ 下篇我们再来讲解。\"]},\"1185\":{\"h\":\"四、总结\",\"t\":[\"Eureka Client 向 Eureka Server 注册的过程：\",\"（1）Eureka Client 初始化了一个 DiscoveryClient，抓取注册表，执行调度任务。\",\"（2）InstanceInfoReplicator 对象启动了一个延迟 40 s 的后台线程，执行注册。\",\"（3）然后使用 AbstractJersey2EurekaHttpClient 发送 post 请求，将 instanceInfo 实例信息发送给 Eureka Server。\",\"时序图如下：\"]},\"1186\":{\"h\":\"留个问题\",\"t\":[\"我们使用 Eureka 时，Service 启动后，Eureka 很快就发现了 Service 的存在，如下图所示的控制台界面：\",\"并不需要等待 40 s 才能注册到 Eureka，那这又是为什么呢？\",\"好了，本篇接近尾声，下一篇，我们来看下 Eureka Server 是如何将 Eureka Client 发送过来的注册信息保存起来的。\"]},\"1187\":{\"c\":[\"常用框架\"]},\"1188\":{\"c\":[\"SpringCloud\"]},\"1189\":{\"h\":\"3. 值得收藏的 Eureka 控制台详解\",\"t\":[\"转载自悟空聊架构，原文链接：值得收藏的 Eureka 控制台详解\",\"本篇将会给大家讲解我在本地搭建的 Eureka 集群环境下，Eureka 控制台的参数说明。\"]},\"1190\":{\"h\":\"系统状态\",\"t\":[\"首先就得进入 Eureka 控制台页面，本地可以通过访问 http://localhost:8762/ 打开。\",\"最上面的是 System Status，就是系统状态。\",\"System Status\",\"Environment: 环境，默认为 test。\",\"Data center：数据中心，默认为 default。\",\"Current time：当前的系统时间。\",\"Uptime：已经运行了多长时间。\",\"Lease expiration enabled：是否启用租约过期 ，自我保护机制关闭时，该值默认是 true， 自我保护机制开启之后为 false。\",\"Renews threshold：期望每分钟最少续约数。也就是 Eureka Server 期望每分钟收到客户端实例续约的总数。目前悟空我的机器上显示的 3 个。\",\"Renews (last min)：最后一分钟的续约数量（不含当前，1分钟更新一次），Eureka Server 最后 1 分钟收到客户端实例续约的总数。目前悟空我的机器上显示的 2 个。\"]},\"1191\":{\"h\":\"自我保护机制\",\"t\":[\"系统在三种情况下会出现红色加粗的字体提示：\",\"1）自我保护机制配置已经配置成关闭了。\",\"RENEWALS ARE LESSER THAN THE THRESHOLD. THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.\",\"关闭自我保护模式\",\"eureka.server.enable-self-preservation = false\",\"2）自我保护机制开启了\",\"EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.\",\"Eureka 的自我保护模式 是非常有意义的，该模式被激活后，它不会从注册列表中剔除因长时间没收到心跳导致租期过期的服务，而是等待修复，直到心跳恢复正常之后，它自动退出自我保护模式。\",\"这种模式旨在避免因网络分区故障导致服务不可用的问题。\",\"例如：两个客户端实例 C1 和 C2 的连通性是良好的，但是由于网络故障，C2 未能及时向 Eureka 发送心跳续约，这时候 Eureka 不能简单的将 C2 从注册表中剔除。因为如果剔除了，C1 就无法从 Eureka 服务器中获取 C2 注册的服务，但是这时候 C2 服务是可用的。\",\"3）在配置上，自我保护机制关闭了，但是一分钟内的续约数没有达到 85%，可能发生了网络分区，会有如下提示\",\"THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.\"]},\"1192\":{\"h\":\"集群信息\",\"t\":[\"DS Replicas 代表集群信息，当有多个 Eureka Server 组成集群时，DS Replicas 会展示集群 的其他节点。当前是单节点的。\",\"如果配置成集群环境，则会显示其他服务，而且在服务实例列表里面也会显示集群节点。\"]},\"1193\":{\"h\":\"已注册的实例列表\",\"t\":[\"已注册的实例列表会显示在 Instances currently registered with Eureka 列表里面。目前显示了一个，\",\"名称：SERVICEA\",\"状态：UP (1) - localhost:ServiceA:8006\"]},\"1194\":{\"h\":\"通用信息\",\"t\":[\"total-avail-memory : 总共可用的内存，598 MB。\",\"environment : 环境名称，默认 test。\",\"num-of-cpus : CPU 的个数，12 核。\",\"current-memory-usage : 当前已经使用内存的百分比，使用了 110 MB，使用率 18%。\",\"server-uptime : 服务已启动时间，6 分钟。\",\"registered-replicas : 当前 Eureka Server 是往哪个 Eureka Server 进行注册的。悟空我的本机是 eureka-server1 往 eureka-server 2 进行注册了。\",\"unavailable-replicas ：不可用的集群复制节点，用法没懂。\",\"available-replicas ：可用的相邻集群复制节点。\"]},\"1195\":{\"h\":\"服务实例信息\",\"t\":[\"ipAddr：Eureka 服务端 IP。\",\"status：Eureka 服务端状态。\"]},\"1196\":{\"h\":\"最近 1000 个取消的租约\",\"t\":[\"Last 1000 cancelled leases 这个列表里面会显示最近 1000 个取消的租约。\",\"Last 1000 newly registered leases，这个列表里面会显示最后 1000 个新注册的租约。比如悟空我的机器上就是 Service A。\"]},\"1197\":{\"c\":[\"常用框架\"]},\"1198\":{\"c\":[\"SpringCloud\"]},\"1199\":{\"h\":\"Java 实现本地缓存的几种方式\"},\"1200\":{\"h\":\"1. 概念\",\"t\":[\"引入缓存，主要用于实现系统的高性能，高并发。将数据库查询出来的数据放入缓存服务中，因为缓存是存储在内存中的，内存的读写性能远超磁盘的读写性能，所以访问的速度非常快。但是电脑重启后，内存中的数据会全部清除，而磁盘中的数据虽然读写性能很差，但是数据不会丢失。\"]},\"1201\":{\"h\":\"2. 手写本地缓存\",\"t\":[\"首先创建一个缓存实体类：\",\"/** * 自定义缓存实体类 */ @Data public class MyCache { // 键 private String key; // 值 private Object value; // 过期时间 private Long expireTime; }\",\"接着我们编写一个缓存操作的工具类：\",\"/** * 自定义本地缓存工具类 */ public class CacheUtil { // 缓存数据Map private static final Map<String, MyCache> CACHE_MAP = new ConcurrentHashMap<>(); // 定时器线程池，用于清除过期缓存 private static final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); static { // 注册一个定时线程任务，服务启动1秒之后，每隔500毫秒执行一次 // 定时清理过期缓存 executorService.scheduleAtFixedRate(CacheUtil::clearCache, 1000, 500, TimeUnit.MILLISECONDS); } /** * 添加缓存 * * @param key 缓存键 * @param value 缓存值 * @param expire 过期时间，单位秒 */ public static void put(String key, Object value, long expire) { MyCache myCache = new MyCache(); myCache.setKey(key); myCache.setValue(value); if (expire > 0) { long expireTime = System.currentTimeMillis() + Duration.ofSeconds(expire).toMillis(); myCache.setExpireTime(expireTime); } CACHE_MAP.put(key, myCache); } /** * 获取缓存 * * @param key 缓存键 * @return 缓存数据 */ public static Object get(String key) { if (CACHE_MAP.containsKey(key)) { return CACHE_MAP.get(key).getValue(); } return null; } /** * 移除缓存 * * @param key 缓存键 */ public static void remove(String key) { CACHE_MAP.remove(key); } /** * 清理过期的缓存数据 */ private static void clearCache() { if (CACHE_MAP.size() <= 0) { return; } // 判断是否过期 过期就从缓存Map删除这个元素 CACHE_MAP.entrySet().removeIf(entry -> entry.getValue().getExpireTime() != null && entry.getValue().getExpireTime() > System.currentTimeMillis()); } }\",\"最后，我们来测试一下缓存服务\",\"@SpringBootTest class VueSpringBootApplicationTests { @Test void contextLoads() throws InterruptedException { // 写入缓存数据 2秒后过期 CacheUtil.put(\\\"name\\\", \\\"qx\\\", 2); Object value1 = CacheUtil.get(\\\"name\\\"); System.out.println(\\\"第一次查询结果：\\\" + value1); // 停顿3秒 TimeUnit.SECONDS.sleep(3); Object value2 = CacheUtil.get(\\\"name\\\"); System.out.println(\\\"第二次查询结果：\\\" + value2); } }\",\"启动测试，我们从控制台的返回看到输出结果和我们的预期一致!\",\"第一次查询结果：qx 第二次查询结果：null\",\"实现思路其实很简单，采用 ConcurrentHashMap 作为缓存数据存储服务，然后开启一个定时调度，每隔 500 毫秒检查一下过期的缓存数据，然后清除掉即可。\"]},\"1202\":{\"h\":\"3. 基于 Guava Cache 实现本地缓存\",\"t\":[\"相比自己编写的缓存服务，Guava Cache 要强大的多，支持很多特性如下：\",\"支持最大容量限制\",\"支持两种过期删除策略（插入时间和读取时间）\",\"支持简单的统计功能\",\"基于 LRU 算法实现\"]},\"1203\":{\"h\":\"3.1 添加 gugva 的依赖\",\"t\":[\"<!--guava--> <dependency> <groupId>com.google.guava</groupId> <artifactId>guava</artifactId> <version>31.1-jre</version> </dependency>\"]},\"1204\":{\"h\":\"3.2 测试\",\"t\":[\"@Test void testGuava() throws ExecutionException, InterruptedException { // 创建一个缓存实例 Cache<String, String> cache = CacheBuilder.newBuilder() .initialCapacity(5) // 初始容量 .maximumSize(10) // 最大缓存数，超出淘汰 .expireAfterWrite(3, TimeUnit.SECONDS) // 过期时间 设置写入3秒后过期 .build(); // 写入缓存数据 cache.put(\\\"name\\\", \\\"qq\\\"); // 读取缓存数据 String value1 = cache.get(\\\"name\\\", () -> \\\"key过期\\\"); System.out.println(\\\"第一次查询结果：\\\" + value1); // 停顿4秒 TimeUnit.SECONDS.sleep(4); // 读取缓存数据 String value2 = cache.get(\\\"name\\\", () -> \\\"key过期\\\"); System.out.println(\\\"第二次查询结果：\\\" + value2); }\",\"启动测试，我们从控制台的返回看到输出结果和我们的预期一致!\",\"第一次查询结果：qq 第二次查询结果：key过期\"]},\"1205\":{\"h\":\"4. 基于 Caffeine 实现本地缓存\",\"t\":[\"Caffeine 是基于 java8 实现的新一代缓存工具，缓存性能接近理论最优，可以看作是 Guava Cache 的增强版，功能上两者类似，不同的是 Caffeine 采用了一种结合 LRU、LFU 优点的算法：W-TinyLFU，在性能上有明显的优越性。\"]},\"1206\":{\"h\":\"4.1 引入Caffeine\",\"t\":[\"<!--caffeine--> <dependency> <groupId>com.github.ben-manes.caffeine</groupId> <artifactId>caffeine</artifactId> <version>2.9.3</version> </dependency>\"]},\"1207\":{\"h\":\"4.2 测试\",\"t\":[\"@Test void testCaffeine() throws InterruptedException { // 创建一个缓存实例 Cache<String, String> cache = Caffeine.newBuilder() .initialCapacity(5) // 初始容量 .maximumSize(10) // 最大缓存数，超出淘汰 .expireAfterWrite(3, TimeUnit.SECONDS) // 设置缓存写入间隔多久过期 .build(); // 写入缓存数据 cache.put(\\\"userName\\\", \\\"张三\\\"); // 读取缓存数据 String value1 = cache.get(\\\"userName\\\", (key) -> { // 如果key不存在，会执行回调方法 return \\\"key已过期\\\"; }); System.out.println(\\\"第一次查询结果：\\\" + value1); // 停顿4秒 Thread.sleep(4000); // 读取缓存数据 String value2 = cache.get(\\\"userName\\\", (key) -> { // 如果key不存在，会执行回调方法 return \\\"key已过期\\\"; }); System.out.println(\\\"第二次查询结果：\\\" + value2); }\",\"输出结果：\",\"第一次查询结果：张三 第二次查询结果：key已过期\"]},\"1208\":{\"h\":\"5. 基于 Encache 实现本地缓存\"},\"1209\":{\"h\":\"5.1 引入 ehcache 依赖\",\"t\":[\"<!--ehcache--> <dependency> <groupId>org.ehcache</groupId> <artifactId>ehcache</artifactId> <version>3.9.7</version> </dependency>\"]},\"1210\":{\"h\":\"5.2 自定义过期策略实现\",\"t\":[\"/** * 自定义过期策略实现 */ public class CustomExpiryPolicy<K, V> implements ExpiryPolicy<K, V> { private final Map<K, Duration> keyExpireMap = new ConcurrentHashMap(); public Duration setExpire(K key, Duration duration) { return keyExpireMap.put(key, duration); } public Duration getExpireByKey(K key) { return Optional.ofNullable(keyExpireMap.get(key)) .orElse(null); } public Duration removeExpire(K key) { return keyExpireMap.remove(key); } @Override public Duration getExpiryForCreation(K key, V value) { return Optional.ofNullable(getExpireByKey(key)) .orElse(Duration.ofNanos(Long.MAX_VALUE)); } @Override public Duration getExpiryForAccess(K key, Supplier<? extends V> value) { return getExpireByKey(key); } @Override public Duration getExpiryForUpdate(K key, Supplier<? extends V> oldValue, V newValue) { return getExpireByKey(key); } }\"]},\"1211\":{\"h\":\"5.3 测试\",\"t\":[\"/** * 测试Encache */ public class EncacheTest { public static void main(String[] args) throws InterruptedException { String userCache = \\\"userCache\\\"; // 自定义过期策略 CustomExpiryPolicy<Object, Object> customExpiryPolicy = new CustomExpiryPolicy<>(); // 声明一个容量为20的堆内缓存配置 CacheConfigurationBuilder configurationBuilder = CacheConfigurationBuilder .newCacheConfigurationBuilder(String.class, String.class, ResourcePoolsBuilder.heap(20)) .withExpiry(customExpiryPolicy); // 初始化一个缓存管理器 CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder() // 创建cache实例 .withCache(userCache, configurationBuilder) .build(true); // 获取cache实例 Cache<String, String> cache = cacheManager.getCache(userCache, String.class, String.class); // 获取过期策略 CustomExpiryPolicy expiryPolicy = (CustomExpiryPolicy) cache.getRuntimeConfiguration().getExpiryPolicy(); // 写入缓存数据 cache.put(\\\"userName\\\", \\\"张三\\\"); // 设置3秒过期 expiryPolicy.setExpire(\\\"userName\\\", Duration.ofSeconds(3)); // 读取缓存数据 String value1 = cache.get(\\\"userName\\\"); System.out.println(\\\"第一次查询结果：\\\" + value1); // 停顿4秒 Thread.sleep(4000); // 读取缓存数据 String value2 = cache.get(\\\"userName\\\"); System.out.println(\\\"第二次查询结果：\\\" + value2); } }\",\"输出结果：\",\"第一次查询结果：张三 第二次查询结果：null\"]},\"1212\":{\"c\":[\"杂项\"]},\"1213\":{\"c\":[\"工作笔记\"]},\"1214\":{\"h\":\"如何实现 List 转 Map 后依然有序？\"},\"1215\":{\"c\":[\"杂项\"]},\"1216\":{\"c\":[\"工作笔记\"]},\"1217\":{\"h\":\"并发的优缺点\"},\"1218\":{\"h\":\"1. 为什么要用到并发\",\"t\":[\"一直以来，硬件的发展极其迅速，也有一个很著名的\\\"摩尔定律\\\"，可能会奇怪明明讨论的是并发编程为什么会扯到了硬件的发展，这其中的关系应该是多核 CPU 的发展为并发编程提供的硬件基础。\",\"摩尔定律并不是一种自然法则或者是物理定律，它只是基于认为观测数据后，对未来的一种预测。按照所预测的速度，我们的计算能力会按照指数级别的速度增长，不久以后会拥有超强的计算能力。正是在畅想未来的时候，2004年，Intel 宣布 4GHz 芯片的计划推迟到2005年，然后在2004年秋季，Intel 宣布彻底取消 4GHz 的计划，也就是说摩尔定律的有效性超过了半个世纪戛然而止。\",\"但是，聪明的硬件工程师并没有停止研发的脚步，他们为了进一步提升计算速度，而不是再追求单独的计算单元，而是将多个计算单元整合到了一起，也就是形成了多核 CPU。短短十几年的时间，家用型 CPU，比如 Intel i7 就可以达到 4 核心甚至 8 核心。而专业服务器则通常可以达到几个独立的 CPU，每一个 CPU 甚至拥有多达 8 个以上的内核。因此，摩尔定律似乎在 CPU 核心扩展上继续得到体验。因此，多核的 CPU 的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。\",\"顶级计算机科学家 DonaldErvinKnuth 如此评价这种情况：在我看来，这种现象（并发）或多或少是由于硬件设计者无计可施了导致的，他们将摩尔定律的责任推给了软件开发者。\",\"另外，在特殊的业务场景下先天的就适合于并发编程。比如在图像处理领域，一张 1024×768 像素的图片，包含达到78万6千多个像素。即时将所有的像素遍历一边都需要很长的时间，面对如此复杂的计算量就需要充分利用多核的计算的能力。又比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。正是因为这些优点，使得多线程技术能够得到重视，也是一名 CS 学习者应该掌握的：\",\"充分利用多核 CPU 的计算能力；\",\"方便进行业务拆分，提升应用性能\"]},\"1219\":{\"h\":\"2. 并发编程有哪些缺点\",\"t\":[\"多线程技术有这么多的好处，难道就没有一点缺点么，就在任何场景下就一定适用么？很显然不是。\"]},\"1220\":{\"h\":\"2.1 频繁的上下文切换\",\"t\":[\"时间片是 CPU 分配给各个线程的时间，因为时间非常短，所以 CPU 不断通过切换线程，让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。而每次切换时，需要保存当前的状态起来，以便能够进行恢复先前状态，而这个切换时非常损耗性能，过于频繁反而无法发挥出多线程编程的优势。\",\"通常减少上下文切换可以采用无锁并发编程，CAS算法，使用最少的线程和使用协程。\",\"无锁并发编程：可以参照 ConcurrentHashMap 分段锁的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。\",\"CAS算法，利用 Atomic 下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换\",\"使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态\",\"协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换\",\"由于上下文切换也是个相对比较耗时的操作，所以在《java并发编程的艺术》一书中有过一个实验，并发累加未必会比串行累加速度要快。 可以使用 Lmbench3 测量上下文切换的时长，vmstat 测量上下文切换次数。\"]},\"1221\":{\"h\":\"2.2 线程安全\",\"t\":[\"多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。\",\"public class DeadLockDemo { private static String resource_a = \\\"A\\\"; private static String resource_b = \\\"B\\\"; public static void main(String[] args) { deadLock(); } public static void deadLock() { Thread threadA = new Thread(new Runnable() { @Override public void run() { synchronized (resource_a) { System.out.println(\\\"get resource a\\\"); try { Thread.sleep(3000); synchronized (resource_b) { System.out.println(\\\"get resource b\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } } }); Thread threadB = new Thread(new Runnable() { @Override public void run() { synchronized (resource_b) { System.out.println(\\\"get resource b\\\"); synchronized (resource_a) { System.out.println(\\\"get resource a\\\"); } } } }); threadA.start(); threadB.start(); } }\",\"在上面的这个 demo 中，开启了两个线程 threadA，threadB，其中 threadA 占用了 resource_a，并等待被 threadB 释放的 resource _b。threadB 占用了 resource _b 正在等待被 threadA 释放的resource _a。因此 threadA，threadB 出现线程安全的问题，形成死锁。同样可以通过 jps，jstack 证明这种推论：\",\"\\\"Thread-1\\\": waiting to lock monitor 0x000000000b695360 (object 0x00000007d5ff53a8, a java.lang.String), which is held by \\\"Thread-0\\\" \\\"Thread-0\\\": waiting to lock monitor 0x000000000b697c10 (object 0x00000007d5ff53d8, a java.lang.String), which is held by \\\"Thread-1\\\" Java stack information for the threads listed above: =================================================== \\\"Thread-1\\\": at learn.DeadLockDemo$2.run(DeadLockDemo.java:34) - waiting to lock <0x00000007d5ff53a8(a java.lang.String) - locked <0x00000007d5ff53d8(a java.lang.String) at java.lang.Thread.run(Thread.java:722) \\\"Thread-0\\\": at learn.DeadLockDemo$1.run(DeadLockDemo.java:20) - waiting to lock <0x00000007d5ff53d8(a java.lang.String) - locked <0x00000007d5ff53a8(a java.lang.String) at java.lang.Thread.run(Thread.java:722) Found 1 deadlock.\",\"如上所述，完全可以看出当前死锁的情况。\",\"那么，通常可以用如下方式避免死锁的情况：\",\"避免一个线程同时获得多个锁；\",\"避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；\",\"尝试使用定时锁，使用 lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞；\",\"对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况\",\"所以，如何正确的使用多线程编程技术有很大的学问，比如如何保证线程安全，如何正确理解由于JMM内存模型在原子性，有序性，可见性带来的问题，比如数据脏读，DCL等这些问题（在后续篇幅会讲述）。而在学习多线程编程技术的过程中也会让你收获颇丰。\"]},\"1222\":{\"h\":\"3. 应该了解的概念\"},\"1223\":{\"h\":\"3.1 同步VS异步\",\"t\":[\"同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。\"]},\"1224\":{\"h\":\"3.2 并发与并行\",\"t\":[\"并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的 “同时进行”。实际上，如果系统内只有一个 CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个 CPU 的系统中。\"]},\"1225\":{\"h\":\"3.3 阻塞和非阻塞\",\"t\":[\"阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。\"]},\"1226\":{\"h\":\"3.4 临界区\",\"t\":[\"临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。\"]},\"1227\":{\"h\":\"4. Java 并发知识图谱\"},\"1228\":{\"c\":[\"并发编程\"]},\"1229\":{\"c\":[\"JUC\"]},\"1230\":{\"h\":\"彻底理解 ReentrantLock\"},\"1231\":{\"h\":\"1. 基本介绍\",\"t\":[\"ReentrantLock 重入锁，是实现 Lock 接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。\",\"在 Java 关键字中， synchronized 隐式支持重入性，synchronized 通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock 不仅支持重入性，还支持公平锁和非公平锁两种方式。\",\"那么，要想完完全全的弄懂 ReentrantLock 的话，主要也就是 ReentrantLock 同步语义的学习：\",\"重入性的实现原理\",\"公平锁和非公平锁\"]},\"1232\":{\"h\":\"2. 重入性的实现原理\",\"t\":[\"要想支持重入性，就要解决两个问题：\",\"在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功\",\"由于锁会被获取 n 次，那么只有锁在被释放同样的 n 次之后，该锁才算是完全释放成功\",\"首先，同步组件主要是通过重写 AQS 的几个 protected 方法来表达自己的同步语义。\",\"针对第一个问题，我们来看看 ReentrantLock 是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为 nonfairTryAcquire：\",\"final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); // 1. 如果该锁未被任何线程占有，该锁能被当前线程获取 if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 2.若被占有，检查占有线程是否是当前线程 else if (current == getExclusiveOwnerThread()) { // 3. 再次获取，计数加一 int nextc = c + acquires; if (nextc < 0) // overflow throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } return false; }\",\"这段代码的逻辑也很简单，具体请看注释。\",\"为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的了？（依然还是以非公平锁为例）核心方法为 tryRelease：\",\"protected final boolean tryRelease(int releases) { // 1. 同步状态减1 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { // 2. 只有当同步状态为0时，锁成功被释放，返回true free = true; setExclusiveOwnerThread(null); } // 3. 锁未被完全释放，返回false setState(c); return free; }\",\"代码的逻辑请看注释，需要注意的是，重入锁的释放必须得等到同步状态为 0 时锁才算成功释放，否则锁仍未释放。如果锁被获取 n 次，释放了 n−1 次，该锁未完全释放返回 false，只有被释放 n 次才算成功释放，返回 true。\",\"通过分析，我们可以理清 ReentrantLock 重入性的实现了，也就是理解了同步语义的第一条。\"]},\"1233\":{\"h\":\"3. 公平锁与公平锁\",\"t\":[\"ReentrantLock 支持两种锁：公平锁和非公平锁。\",\"公平性\",\"何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足 FIFO。\",\"ReentrantLock 的构造方法无参时是构造非公平锁，源码为：\",\"public ReentrantLock() { sync = new NonfairSync(); }\",\"另外还提供了另外一种方式，可传入一个 boolean 值，true 时为公平锁，false 时为非公平锁，源码为：\",\"public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); }\",\"在上面非公平锁获取时（nonfairTryAcquire 方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：\",\"protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } return false; }\",\"这段代码的逻辑与 nonfairTryAcquire 基本上一致，唯一的不同在于增加了 hasQueuedPredecessors 的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。\",\"公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。\",\"公平锁 VS 非公平锁\",\"公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成 “饥饿” 现象。\",\"公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock 默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。\"]},\"1234\":{\"c\":[\"并发编程\"]},\"1235\":{\"c\":[\"JUC\"]},\"1236\":{\"h\":\"深入理解读写锁 ReentrantReadWriteLock\"},\"1237\":{\"h\":\"1. 读写锁介绍\",\"t\":[\"在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用 Java 提供的关键字 synchronized 或者 concurrent 包中实现了 Lock 接口的 ReentrantLock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。\",\"而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（即出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。\",\"针对这种读多写少的情况，Java 还提供了另外一个实现 Lock 接口的 ReentrantReadWriteLock（读写锁）。读写所允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。在分析 WirteLock 和 ReadLock 的互斥性时可以按照 WriteLock 与 WriteLock 之间，WriteLock 与 ReadLock 之间以及 ReadLock 与 ReadLock 之间进行分析。\",\"关于读写锁的特性，这里简单做个小结：\",\"公平性选择：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；\",\"重入性：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；\",\"锁降级：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁\",\"要想能够彻底的理解读写锁必须能够理解这样几个问题：\",\"读写锁是怎样实现分别记录读写状态的？\",\"写锁是怎样获取和释放的？\",\"读锁是怎样获取和释放的？\",\"下面我们带着这三个问题，去深入了解下读写锁。\"]},\"1238\":{\"h\":\"2. 写锁详解\"},\"1239\":{\"h\":\"2.1 写锁的获取\",\"t\":[\"同步组件的实现聚合了同步器（AQS），并通过重写同步器（AQS）中的方法实现同步组件的同步语义（关于同步组件的实现层级结构可以看这篇文章，AQS的底层实现分析可以看这篇文章）。\",\"因此，写锁的实现依然也是采用这种方式。在同一时刻写锁是不能被多个线程所获取，很显然写锁是独占式锁，而实现写锁的同步语义是通过重写 AQS 中的 tryAcquire 方法实现的。源码为:\",\"protected final boolean tryAcquire(int acquires) { /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ Thread current = Thread.currentThread(); // 1. 获取写锁当前的同步状态 int c = getState(); // 2. 获取写锁获取的次数 int w = exclusiveCount(c); if (c != 0) { // (Note: if c != 0 and w == 0 then shared count != 0) // 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话 // 当前线程获取写锁失败 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) > MAX_COUNT) throw new Error(\\\"Maximum lock count exceeded\\\"); // Reentrant acquire // 3.2 当前线程获取写锁，支持可重复加锁 setState(c + acquires); return true; } // 3.3 写锁未被任何线程获取，当前线程可获取写锁 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true; }\",\"这段代码的逻辑请看注释，这里有一个地方需要重点关注，exclusiveCount(c) 方法，该方法源码为：\",\"static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }\",\"其中 EXCLUSIVE_MASK 为:\",\"static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\",\"EXCLUSIVE _MASK 为 1 左移 16 位然后减 1 ，即为 0x0000FFFF。而 exclusiveCount 方法是将同步状态（state 为 int 类型）与 0x0000FFFF 相与，即取同步状态的低 16 位。那么低 16 位代表什么呢？根据 exclusiveCount 方法的注释为独占式锁获取的次数即写锁被获取的次数，现在就可以得出来一个结论，即 同步状态的低 16 位用来表示写锁的获取次数。\",\"同时还有一个方法值得我们注意：\",\"static int sharedCount(int c) { return c >>> SHARED_SHIFT; }\",\"该方法是获取读锁被获取的次数，是将同步状态（int c）右移 16 次，即取同步状态的高 16 位，现在我们可以得出另外一个结论，即 同步状态的高 16 位用来表示读锁被获取的次数。\",\"于是我们开篇的第一个问题 —— 读写锁是怎样实现分别记录读锁和写锁的状态的？现在这个问题的答案就已经被我们弄清楚了，其示意图如下图所示：\",\"现在我们回过头来看写锁获取方法 tryAcquire，其主要逻辑为：\",\"当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。\"]},\"1240\":{\"h\":\"2.2 写锁的释放\",\"t\":[\"写锁释放通过重写 AQS 的 tryRelease 方法，源码为：\",\"protected final boolean tryRelease(int releases) { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 1. 同步状态减去写状态 int nextc = getState() - releases; // 2. 当前写状态是否为0，为0则释放写锁 boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); // 3. 不为0则更新同步状态 setState(nextc); return free; }\",\"源码的实现逻辑请看注释，不难理解与 ReentrantLock 基本一致，这里需要注意的是：\",\"减少写状态 int nextc = getState() - releases; 只需要 用当前同步状态直接减去写状态。\",\"其原因正是我们刚才所说的：写状态由同步状态的低 16 位表示。\"]},\"1241\":{\"h\":\"3. 读锁详解\"},\"1242\":{\"h\":\"3.1.读锁的获取\",\"t\":[\"看完了写锁，现在来看看读锁，读锁不是独占式锁，即同一时刻该锁可以被多个读线程获取也就是一种共享式锁。按照之前对 AQS 介绍，实现共享式同步组件的同步语义需要通过重写 AQS 的 tryAcquireShared 方法和 tryReleaseShared 方法。读锁的获取实现方法为：\",\"protected final int tryAcquireShared(int unused) { /* * Walkthrough: * 1. If write lock held by another thread, fail. * 2. Otherwise, this thread is eligible for * lock wrt state, so ask if it should block * because of queue policy. If not, try * to grant by CASing state and updating count. * Note that step does not check for reentrant * acquires, which is postponed to full version * to avoid having to check hold count in * the more typical non-reentrant case. * 3. If step 2 fails either because thread * apparently not eligible or CAS fails or count * saturated, chain to version with full retry loop. */ Thread current = Thread.currentThread(); int c = getState(); // 1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前线程获取读锁失败返回-1 if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current) return -1; int r = sharedCount(c); if (!readerShouldBlock() && r < MAX_COUNT && // 2. 当前线程获取读锁 compareAndSetState(c, c + SHARED_UNIT)) { // 3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法 // 返回当前获取读锁的次数 if (r == 0) { firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) { firstReaderHoldCount++; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; } return 1; } // 4. 处理在第二步中CAS操作失败的自旋已经实现重入性 return fullTryAcquireShared(current); }\",\"代码的逻辑请看注释，需要注意的是 当写锁被其他线程获取后，读锁获取失败，否则获取成功利用 CAS 更新同步状态。另外，当前同步状态需要加上 SHARED_UNIT（(1 << SHARED_SHIFT) 即 0x00010000）的原因正是我们在上面说的，同步状态的高 16 位用来表示读锁被获取的次数。如果 CAS 失败或者已经获取读锁的线程再次获取读锁时，是靠 fullTryAcquireShared 方法实现的，这段代码就不展开说了，有兴趣可以看看。\"]},\"1243\":{\"h\":\"3.2 读锁的释放\",\"t\":[\"读锁释放的实现主要通过方法 tryReleaseShared，源码如下，主要逻辑请看注释：\",\"protected final boolean tryReleaseShared(int unused) { Thread current = Thread.currentThread(); // 前面还是为了实现getReadHoldCount等新功能 if (firstReader == current) { // assert firstReaderHoldCount > 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); int count = rh.count; if (count <= 1) { readHolds.remove(); if (count <= 0) throw unmatchedUnlockException(); } --rh.count; } for (;;) { int c = getState(); // 读锁释放 将同步状态减去读状态即可 int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. return nextc == 0; } }\"]},\"1244\":{\"h\":\"4. 锁降级\",\"t\":[\"读写锁支持锁降级，遵循获取写锁，获取读锁再释放写锁的次序。\",\"写锁能够降级成为读锁，不支持锁升级。\",\"关于锁降级下面的示例代码摘自 ReentrantWriteReadLock源码中：\",\"void processCachedData() { rwl.readLock().lock(); if (!cacheValid) { // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try { // Recheck state because another thread might have // acquired write lock and changed state before we did. if (!cacheValid) { data = ... cacheValid = true; } // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); } finally { rwl.writeLock().unlock(); // Unlock write, still hold read } } try { use(data); } finally { rwl.readLock().unlock(); } }\"]},\"1245\":{\"c\":[\"并发编程\"]},\"1246\":{\"c\":[\"JUC\"]},\"1247\":{\"h\":\"详解 Condition 的 await 和 signal 等待通知机制\"},\"1248\":{\"h\":\"1. Condition 简介\",\"t\":[\"任何一个 Java 对象都天然继承于 Object 类，在线程间实现通信的往往会应用到 Object 的几个方法，比如 wait()，wait(long timeout)，wait(long timeout, int nanos) 与 notify()，notifyAll() 几个方法实现等待/通知机制。\",\"同样的，在 Java Lock 体系下依然会有同样的方法实现等待/通知机制。从整体上来看 Object 的 wait 和 notify/notifyAll 是与对象监视器配合完成线程间的等待/通知机制，而 Condition 与 Lock 配合完成等待通知机制，前者是 Java 底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。\",\"两者除了在使用方式上不同外，在功能特性上还是有很多的不同：\",\"Condition 能够支持不响应中断，而通过使用 Object 方式不支持；\",\"Condition 能够支持多个等待队列（new 多个 Condition 对象），而 Object 方式只能支持一个；\",\"Condition 能够支持超时时间的设置，而 Object 不支持\",\"参照 Object 的 wait 和 notify/notifyAll 方法，Condition 也提供了同样的方法：\",\"针对 Object 的 wait 方法\",\"void await() throws InterruptedException：当前线程进入等待状态，如果其他线程调用 Condition 的 signal/signalAll 方法并且当前线程获取 Lock 从 await 方法返回，如果在等待状态中被中断会抛出被中断异常\",\"long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时\",\"boolean await(long time, TimeUnit unit) throws InterruptedException：同第二种，支持自定义时间单位\",\"boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间\",\"针对 Object 的 notify/notifyAll 方法\",\"void signal()：唤醒一个等待在 Condition 上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到 Lock 则可以从等待方法中返回\",\"void signalAll()：与第一种的区别在于能够唤醒所有等待在 Condition 上的线程\"]},\"1249\":{\"h\":\"2. Condition 实现原理分析\"},\"1250\":{\"h\":\"2.1 等待队列\",\"t\":[\"要想能够深入的掌握 Condition 还是应该知道它的实现原理。\",\"通过分析 Condiiton 的源码，我们会发现，创建一个 Condition 对象是通过 lock.newCondition()，而这个方法实际上是会 new 出一个 ConditionObject 对象，该类是 AQS 的一个内部类。前面我们说过，condition 是要和 lock 配合使用，也就是 Condition 和 Lock 是绑定在一起的，而 lock 的实现原理又依赖于 AQS，自然而然 ConditionObject 作为 AQS 的一个内部类无可厚非。\",\"我们知道在锁机制的实现上，AQS 内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，Condition 内部也是使用同样的方式，内部维护了一个等待队列，所有调用 condition.await 方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到 ConditionObject 中有两个成员变量：\",\"/** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter;\",\"可以发现 ConditionObject 通过持有等待队列的头尾指针来管理等待队列。需要注意的是 Node 类复用了在 AQS 中的 Node 类，其节点状态和相关属性可以去看 AQS的实现原理。\",\"Node 类有这样一个属性：\",\"//后继节点 Node nextWaiter;\",\"进一步说明，等待队列是一个单向队列，而在之前说 AQS 时知道同步队列是一个双向队列。接下来我们用一个 demo，通过 debug 进去看是不是符合我们的猜想：\",\"public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(() -> { lock.lock(); try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); } }); thread.start(); } }\",\"这段代码没有任何实际意义，甚至很臭，只是想说明下我们刚才所想的。\",\"新建了 10 个线程，没有线程先获取锁，然后调用 condition.await 方法释放锁将当前线程加入到等待队列中，通过 debug 控制当走到第 10 个线程的时候查看 firstWaiter，即等待队列中的头结点，debug 模式下情景图如下：\",\"从这个图我们可以很清楚的看到这样几点：\",\"调用 condition.await 方法后线程依次尾插入到等待队列中，如图队列中的线程引用依次为 Thread-0，Thread-1，Thread-2....Thread-8\",\"等待队列是一个单向队列。\",\"通过我们的猜想然后进行实验验证，我们可以得出等待队列的示意图如下图所示：\",\"同时还有一点需要注意的是：我们可以多次调用 lock.newCondition() 方法创建多个 Condition 对象，也就是一个 lock 可以持有多个等待队列。而在之前利用 Object 的方式实际上是指在对象 Object 对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的 Lock 拥有一个同步队列和多个等待队列。\",\"示意图如下：\",\"AQS 持有多个 Condition\",\"如图所示，ConditionObject 是 AQS 的内部类，因此每个 ConditionObject 能够访问到 AQS 提供的方法，相当于每个 Condition 都拥有所属同步器的引用。\"]},\"1251\":{\"h\":\"2.2 await 实现原理\",\"t\":[\"当调用 condition.await() 方法后会使得当前获取 lock 的线程进入到等待队列，如果该线程能够从 await() 方法返回的话一定是该线程获取了与 condition 相关联的 lock。\",\"接下来，我们还是从源码的角度去看，只有熟悉了源码的逻辑我们的理解才是最深的。\",\"await() 方法源码为：\",\"public final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 1. 将当前线程包装成Node，尾插入到等待队列中 Node node = addConditionWaiter(); // 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) { // 3. 当前线程进入到等待状态 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } // 4. 自旋等待获取到同步状态（即获取到lock） if (acquireQueued(node, savedState) && interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 5. 处理被中断的情况 if (interruptMode != 0) reportInterruptAfterWait(interruptMode); }\",\"代码的主要逻辑请看注释，我们都知道当当前线程调用 condition.await() 方法后，会使得当前线程释放 lock 然后加入到等待队列中，直至被 signal/signalAll 后会使得当前线程从等待队列中移至到同步队列中去，直到获得了 lock 后才会从 await 方法返回，或者在等待时被中断会做中断处理。\",\"那么关于这个实现过程，有这样几个问题：\",\"是怎样将当前线程添加到等待队列中去的？\",\"释放锁的过程？\",\"怎样才能从 await 方法退出？\",\"而这段代码的逻辑就是告诉我们这三个问题的答案。\",\"具体请看注释，在第 1 步中调用 addConditionWaiter() 将当前线程添加到等待队列中，该方法源码为：\",\"private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null && t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } // 将当前线程包装成Node Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else // 尾插入 t.nextWaiter = node; // 更新lastWaiter lastWaiter = node; return node; }\",\"这段代码就很容易理解了，将当前节点包装成 Node，如果等待队列的 firstWaiter 为 null 的话（等待队列为空队列），则将 firstWaiter 指向当前的 Node，否则，更新 lastWaiter(尾节点)即可。\",\"就是通过尾插入的方式将当前线程封装的 Node 插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前学习过 AQS，就知道同步队列是一个带头结点的链式队列，这是两者的一个区别。\",\"将当前节点插入到等待对列之后，会使当前线程释放 lock，由 fullyRelease() 方法实现，fullyRelease 的源码为：\",\"final int fullyRelease(Node node) { boolean failed = true; try { int savedState = getState(); if (release(savedState)) { //成功释放同步状态 failed = false; return savedState; } else { //不成功释放同步状态抛出异常 throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } }\",\"这段代码调用 AQS 的模板方法 release 方法释放 AQS 的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。\",\"到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题 —— 怎样从 await 方法退出？\",\"现在回过头再来看 await 方法有这样一段逻辑：\",\"while (!isOnSyncQueue(node)) { // 3. 当前线程进入到等待状态 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; }\",\"很显然，当线程第一次调用 condition.await()方法时，会进入到这个 while() 循环中，然后通过 LockSupport.park(this) 方法使得当前线程进入等待状态，那么要想退出这个 await 方法第一个前提条件自然而然的是要先退出这个 while 循环，出口就只剩下两个地方：\",\"逻辑走到 break 退出 while 循环\",\"while 循环中的逻辑判断为 false\",\"再看代码出现第 1 种情况的条件是当前等待的线程被中断后代码会走到 break 退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的 condition 的 signal/signalAll 方法），while 中逻辑判断为 false 后结束 while 循环。\",\"总结下，就是当前线程被中断或者调用 condition.signal/condition.signalAll 方法当前节点移动到了同步队列后，这是当前线程退出 await 方法的前提条件。当退出 while 循环后就会调用 acquireQueued(node, savedState)，这个方法在介绍 AQS 的底层实现时说过，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到 lock）。这样也说明了退出 await 方法必须是已经获得了 condition 引用（关联）的 lock。\",\"到目前为止，开头的三个问题我们通过阅读源码的方式已经完全找到了答案，也对 await 方法的理解加深。await 方法示意图如下图：\",\"如图，调用 condition.await 方法的线程必须是已经获得了 lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的 Node 尾插入到等待队列中。\",\"超时机制的支持\",\"Condition 还额外支持了超时机制，使用者可调用方法 awaitNanos，awaitUtil。这两个方法的实现原理，基本上与 AQS 中的 tryAcquire 方法如出一辙。\",\"不响应中断的支持\",\"要想不响应中断可以调用 condition.awaitUninterruptibly() 方法，该方法的源码为：\",\"public final void awaitUninterruptibly() { Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean interrupted = false; while (!isOnSyncQueue(node)) { LockSupport.park(this); if (Thread.interrupted()) interrupted = true; } if (acquireQueued(node, savedState) || interrupted) selfInterrupt(); }\",\"这段方法与上面的 await 方法基本一致，只不过减少了对中断的处理，并省略了 reportInterruptAfterWait 方法抛被中断的异常。\"]},\"1252\":{\"h\":\"2.3 signal/signalAll 实现原理\",\"t\":[\"调用 condition 的 signal/signalAll 方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得 lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用 condition 的 signal 方法是将头节点移动到同步队列中。\",\"我们来通过看源码的方式来看这样的猜想是不是对的，signal 方法源码为：\",\"public final void signal() { // 1. 先检测当前线程是否已经获取lock if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 2. 获取等待队列中第一个节点，之后的操作都是针对这个节点 Node first = firstWaiter; if (first != null) doSignal(first); }\",\"signal 方法首先会检测当前线程是否已经获取 lock，如果没有获取 lock 会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的 doSignal 方法也是基于该节点。\",\"下面我们来看看 doSignal 方法做了些什么事情，该方法源码为：\",\"private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; // 1. 将头结点从等待队列中移除 first.nextWaiter = null; // 2. while中transferForSignal方法对头结点做真正的处理 } while (!transferForSignal(first) && (first = firstWaiter) != null); }\",\"具体逻辑请看注释，真正对头节点做处理的逻辑在 transferForSignal 处，该方法源码为：\",\"final boolean transferForSignal(Node node) { /* * If cannot change waitStatus, the node has been cancelled. */ // 1. 更新状态为0 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ // 2.将该节点移入到同步队列中去 Node p = enq(node); int ws = p.waitStatus; if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; }\",\"关键逻辑请看注释，这段代码主要做了两件事情：\",\"将头结点的状态更改为 CONDITION\",\"调用 enq 方法，将该节点尾插入到同步队列中（关于 enq方法请看 AQS的底层实现）\",\"现在我们可以得出结论：调用 condition 的 signal 的前提条件是当前线程已经获取了 lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从 await 方法中的 LockSupport.park(this) 方法中返回，从而才有机会使得调用 await 方法的线程成功退出。\",\"signal 执行示意图如下图：\",\"signalAll\",\"signalAll 与 signal 方法的区别体现在 doSignalAll 方法上，前面我们已经知道 doSignal 方法只会对等待队列的头节点进行操作，而 doSignalAll 的源码为：\",\"private void doSignalAll(Node first) { lastWaiter = firstWaiter = null; do { Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; } while (first != null); }\",\"该方法只不过是将等待队列中的每一个节点都移入到同步队列中，即 “通知” 当前调用 condition.await() 方法的每一个线程。\"]},\"1253\":{\"h\":\"3. await 与 signal/signalAll 的结合思考\",\"t\":[\"文章开篇提到等待/通知机制，通过使用 Condition 提供的 await 和 signal/signalAll 方法就可以实现这种机制，而这种机制能够解决最经典的问题就是 “生产者与消费者问题”，关于 “生产者消费者问题”之后后面也会用单独的一篇文章进行解析。await 和 signal/signalAll 方法就像一个开关控制着线程 A（等待方）和线程B（通知方）。\",\"它们之间的关系可以用下面一个图来表现得更加贴切：\",\"Condition 下的等待通知机制\",\"如上图。\",\"线程 awaitThread 先通过 lock.lock() 方法获取锁成功后调用了 condition.await 方法进入等待队列，而另一个线程 signalThread 通过 lock.lock() 方法获取锁成功后调用了 condition.signal 或者 signalAll 方法，使得线程 awaitThread 能够有机会移入到同步队列中，\",\"当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取 lock，从而使得线程 awaitThread 能够从 await 方法中退出执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列。\"]},\"1254\":{\"h\":\"4. 一个例子\",\"t\":[\"我们用一个很简单的例子说说 condition 的用法：\",\"public class AwaitSignal { private static ReentrantLock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); private static volatile boolean flag = false; public static void main(String[] args) { Thread waiter = new Thread(new waiter()); waiter.start(); Thread signaler = new Thread(new signaler()); signaler.start(); } static class waiter implements Runnable { @Override public void run() { lock.lock(); try { while (!flag) { System.out.println(Thread.currentThread().getName() + \\\"当前条件不满足等待\\\"); try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + \\\"接收到通知条件满足\\\"); } finally { lock.unlock(); } } } static class signaler implements Runnable { @Override public void run() { lock.lock(); try { flag = true; condition.signalAll(); } finally { lock.unlock(); } } } }\",\"输出结果为：\",\"Thread-0当前条件不满足等待 Thread-0接收到通知，条件满足\",\"开启了两个线程 waiter 和 signaler，waiter 线程开始执行的时候由于条件不满足，执行 condition.await 方法使该线程进入等待状态同时释放锁，signaler 线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。\",\"这时，waiter 线程获取到锁，并由于 signaler 线程更改了条件此时相对于 waiter 来说条件满足，继续执行。\"]},\"1255\":{\"c\":[\"并发编程\"]},\"1256\":{\"c\":[\"JUC\"]},\"1257\":{\"h\":\"LockSupport 工具\"},\"1258\":{\"h\":\"1. LockSupport 简介\",\"t\":[\"在之前介绍 AQS 的底层实现，以及在 ReentrantLock 和 ReentReadWriteLocks 中，介绍过线程间等待/通知机制使用 Condition 时都会调用 LockSupport.park() 方法和 LockSupport.unpark() 方法。关于这个在同步组件的实现中被频繁使用的 LockSupport 究竟为何方神圣，现在来看看。\",\"LockSupport 位于 java.util.concurrent.locks 包下，有兴趣的可以直接去看源码，该类的方法并不是很多。LockSupprot 是线程的阻塞原语，用来阻塞线程和唤醒线程。\",\"每个使用 LockSupport 的线程都会与一个许可关联，如果该许可可用，并且可在线程中使用，则调用 park() 将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark() 使其可用。但是注意许可不可重入，也就是说只能调用一次 park() 方法，否则会一直阻塞。\"]},\"1259\":{\"h\":\"2. LockSupport方法介绍\",\"t\":[\"LockSupport 中的方法不多，这里将这些方法做一个总结：\",\"阻塞线程\",\"void park()：阻塞当前线程，如果调用 unpark 方法或者当前线程被中断，能从 park() 方法中返回\",\"void park(Object blocker)：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\",\"void parkNanos(long nanos)：阻塞当前线程，最长不超过 nanos 纳秒，增加了超时返回的特性；\",\"void parkNanos(Object blocker, long nanos)：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\",\"void parkUntil(long deadline)：阻塞当前线程，直到 deadline；\",\"void parkUntil(Object blocker, long deadline)：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\",\"唤醒线程\",\"void unpark(Thread thread)：唤醒处于阻塞状态的指定线程\",\"实际上 LockSupport 阻塞和唤醒线程的功能是依赖于 sun.misc.Unsafe，这是一个很底层的类，有兴趣的可以去查阅资料。\",\"比如 park() 方法的功能实现则是靠 unsafe.park() 方法。另外在阻塞线程这一系列方法中还有一个很有意思的现象就是，每个方法都会新增一个带有 Object 的阻塞对象的重载方法。那么增加了一个 Object 对象的入参会有什么不同的地方了？示例代码很简单就不说了，直接看 dump 线程的信息。\",\"调用 park() 方法 dump 线程：\",\"\\\"main\\\" #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304) at learn.LockSupportDemo.main(LockSupportDemo.java:7)\",\"调用 park(Object blocker) 方法 dump 线程：\",\"\\\"main\\\" #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for <0x048c2d18> (a java.lang.String) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at learn.LockSupportDemo.main(LockSupportDemo.java:7)\",\"通过分别调用这两个方法然后 dump 线程信息可以看出：带 Object 的 park 方法相较于无参的 park 方法会增加 parking to wait for <0x048c2d18> (a java.lang.String） 的信息，这种信息就类似于记录 “案发现场”，有助于工程人员能够迅速发现问题解决问题。\",\"有意思的是，我们都知道如果使用 synchronzed 阻塞了线程，dump 线程时都会有阻塞对象的描述，在 Java 5 推出 LockSupport 时遗漏了这一点，在 Java 6 时进行了补充。\",\"还有一点需要注意的是：synchronzed 致使线程阻塞，线程会进入到 BLOCKED 状态；而调用 LockSupprt 方法阻塞线程会致使线程进入到 WAITING 状态。\"]},\"1260\":{\"h\":\"3. 一个例子\",\"t\":[\"用一个很简单的例子说说这些方法怎么用。\",\"public class LockSupportDemo { public static void main(String[] args) { Thread thread = new Thread(() -> { LockSupport.park(); System.out.println(Thread.currentThread().getName() + \\\"被唤醒\\\"); }); thread.start(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } LockSupport.unpark(thread); } }\",\"thread 线程调用 LockSupport.park() 致使 thread 阻塞，当 main 线程睡眠 3 秒结束后通过 LockSupport.unpark(thread) 方法唤醒 thread 线程，thread 线程被唤醒执行后续操作。\",\"另外，还有一点值得关注的是，LockSupport.unpark(thread) 可以指定线程对象唤醒指定的线程。\"]},\"1261\":{\"c\":[\"并发编程\"]},\"1262\":{\"c\":[\"JUC\"]},\"1263\":{\"h\":\"并发容器之 ConcurrentHashMap\"},\"1264\":{\"h\":\"1. ConcurrentHashMap 简介\",\"t\":[\"在使用 HashMap 时在多线程情况下扩容会出现 CPU 接近 100% 的情况，因为 hashmap 并不是线程安全的，通常我们可以使用在 Java 体系中古老的 hashtable 类，该类基本上所有的方法都采用 synchronized 进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。另外一种方式通过 Collections 的 Map<K,V> synchronizedMap(Map<K,V> m) 将 hashmap 包装成一个线程安全的 map。比如 SynchronzedMap 的 put 方法源码为：\",\"public V put(K key, V value) { synchronized (mutex) { return m.put(key, value); } }\",\"实际上 SynchronizedMap 实现依然是采用 synchronized 独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。针对这种境况，DougLea 大师不遗余力的为我们创造了一些线程安全的并发容器，让每一个 Java 开发人员倍感幸福。\",\"相对于 hashMap 来说，ConcurrentHashMap 就是线程安全的 Map，其中利用了锁分段的思想提高了并发度。\",\"ConcurrentHashMap 在 JDK1.6 的版本网上资料很多，有兴趣的可以去看看。\",\"JDK 1.6版本关键要素：\",\"segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；\",\"segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。\",\"而到了 JDK 1.8 的 ConcurrentHashMap 就有了很大的变化，光是代码量就足足增加了很多。\",\"1.8 版本舍弃了 segment，并且大量使用了 synchronized，以及 CAS 无锁操作以保证 ConcurrentHashMap 操作的线程安全性。至于为什么不用 ReentrantLock 而是 Synchronzied 呢？实际上，synchronzied 做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级。因此，使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。\"]},\"1265\":{\"h\":\"2. ConcurrentHashMap 关键属性及类\",\"t\":[\"ConcurrentHashMap 中有几个关键的属性和类，需要先进行了解。\"]},\"1266\":{\"h\":\"2.1 关键属性\",\"t\":[\"1. table\",\"volatile Node<K,V>[] table：装载 Node 的数组，作为 ConcurrentHashMap 的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为 2 的幂次方。\",\"2. nextTable\",\"volatile Node<K,V>[] nextTable：扩容时使用，平时为 null，只有在扩容的时候才为非 null\",\"3. sizeCtl\",\"volatile int sizeCtl：该属性用来控制 table 数组的大小，根据是否初始化和是否正在扩容有几种情况：\",\"当值为负数时：如果为 −1 表示正在初始化，如果为 −N 则表示当前正有 N−1 个线程进行扩容操作\",\"当值为正数时： \",\"如果当前数组为 null 的话表示 table 在初始化过程中，sizeCtl 表示为需要新建数组的长度；\",\"若已经初始化了，表示当前数据容器（table 数组）可用容量，也可以理解成临界值（插入节点数超过了该临界值就需要扩容），具体为 数组的长度(n) × 加载因子(loadFactor)\",\"当值为 0 时，即数组长度为默认初始值。\",\"4. sun.misc.Unsafe U\",\"在 ConcurrentHashMapde 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。这些方法实际上是利用了 CAS 算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而 CAS 操作依赖于现代处理器指令集，通过底层 CMPXCHG 指令实现。\",\"CAS(V,O,N) 核心思想为：若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，再进行重试。\",\"而在大量的同步组件和并发容器的实现中使用 CAS 是通过 sun.misc.Unsafe 类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 Java 中的 “指针”。该成员变量的获取是在静态代码块中：\",\"static { try { U = sun.misc.Unsafe.getUnsafe(); ....... } catch (Exception e) { throw new Error(e); } }\"]},\"1267\":{\"h\":\"2.2 关键内部类\",\"t\":[\"1. Node\",\"Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域。\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; volatile V val; volatile Node<K,V> next; ...... }\",\"另外可以看出很多属性都是用 volatile 进行修饰的，也就是为了保证内存可见性。\",\"2. TreeNode\",\"TreeNode 树节点，继承于承载数据的 Node 类。而红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，TreeBin 会将 TreeNode 进行再一次封装。\",\"/** * Nodes for use in TreeBins */ static final class TreeNode<K,V> extends Node<K,V> { TreeNode<K,V> parent; // red-black tree links TreeNode<K,V> left; TreeNode<K,V> right; TreeNode<K,V> prev; // needed to unlink next upon deletion boolean red; ...... }\",\"3. TreeBin\",\"TreeBin 这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。实际的 ConcurrentHashMap “数组” 中，存放的是 TreeBin 对象，而不是 TreeNode 对象。\",\"static final class TreeBin<K,V> extends Node<K,V> { TreeNode<K,V> root; volatile TreeNode<K,V> first; volatile Thread waiter; volatile int lockState; // values for lockState static final int WRITER = 1; // set while holding write lock static final int WAITER = 2; // set when waiting for write lock static final int READER = 4; // increment value for setting read lock ...... }\",\"4. ForwardingNode\",\"ForwardingNode 在扩容时才会出现的特殊节点，其 key，value，hash 全部为 null，并拥有 nextTable 指针引用新的 table 数组。\",\"static final class ForwardingNode<K,V> extends Node<K,V> { final Node<K,V>[] nextTable; ForwardingNode(Node<K,V>[] tab) { super(MOVED, null, null, null); this.nextTable = tab; } ..... }\"]},\"1268\":{\"h\":\"2.3 CAS 关键操作\",\"t\":[\"在上面我们提及到在 ConcurrentHashMap 中会大量使用 CAS 修改它的属性和一些操作。因此，在理解 ConcurrentHashMap 的方法前我们需要了解下面几个常用的利用 CAS 算法来保障线程安全的操作。\",\"1. tabAt\",\"static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) { return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE); }\",\"该方法用来获取 table 数组中索引为 i 的 Node 元素。\",\"2. casTabAt\",\"static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v) { return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v); }\",\"利用 CAS 操作设置 table 数组中索引为 i 的元素。\",\"3. setTabAt\",\"static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) { U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v); }\",\"该方法用来设置 table 数组中索引为 i 的元素。\"]},\"1269\":{\"h\":\"3. 重点方法讲解\",\"t\":[\"在熟悉上面的这核心信息之后，我们接下来就来依次看看几个常用的方法是怎样实现的。\"]},\"1270\":{\"h\":\"3.1 实例构造器方法\",\"t\":[\"在使用 ConcurrentHashMap 第一件事自然而然就是 new 出来一个 ConcurrentHashMap 对象，一共提供了如下几个构造器方法：\",\"// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16 ConcurrentHashMap() // 2. 给定map的大小 ConcurrentHashMap(int initialCapacity) // 3. 给定一个map ConcurrentHashMap(Map<? extends K, ? extends V> m) // 4. 给定map的大小以及加载因子 ConcurrentHashMap(int initialCapacity, float loadFactor) // 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程） ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)\",\"ConcurrentHashMap 一共给我们提供了 5 种构造器方法，具体使用请看注释，我们来看看第 2 种构造器，传入指定大小时的情况，该构造器源码为：\",\"public ConcurrentHashMap(int initialCapacity) { // 1. 小于0直接抛异常 if (initialCapacity < 0) throw new IllegalArgumentException(); // 2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理 int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1)); // 3. 赋值给sizeCtl this.sizeCtl = cap; }\",\"这段代码的逻辑请看注释，很容易理解，如果小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 cap 赋值给 sizeCtl（关于 sizeCtl 的说明请看上面的说明）。\",\"当调用构造器方法之后，sizeCtl 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度。\",\"tableSizeFor 做了哪些事情呢？源码为：\",\"/** * Returns a power of two table size for the given desired capacity. * See Hackers Delight, sec 3.2 */ private static final int tableSizeFor(int c) { int n = c - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }\",\"通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方。比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 ConcurrentHashMap 的大小为 2 的 5 次方（即32）。\",\"另外，需要注意的是，调用构造器方法的时候并未构造出 table 数组（可以理解为 ConcurrentHashMap 的数据容器），只是算出 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作。\"]},\"1271\":{\"h\":\"3.2 initTable 方法\",\"t\":[\"直接上源码：\",\"private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { if ((sc = sizeCtl) < 0) { // 1. 保证只有一个线程正在进行初始化操作 Thread.yield(); // lost initialization race; just spin } else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { if ((tab = table) == null || tab.length == 0) { // 2. 得出数组的大小 int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") // 3. 这里才真正的初始化数组 Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; // 4. 计算数组中可用的大小：实际大小n*0.75（加载因子） sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; }\",\"代码的逻辑见注释。有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第 1 步中会先通过 if 进行判断，若当前已经有一个线程正在初始化即 sizeCtl 值变为 −1，这个时候其他线程在 If 判断为 true 从而调用 Thread.yield() 让出 CPU 时间片。正在进行初始化的线程会调用 U.compareAndSwapInt 方法将 sizeCtl 改为 −1 即正在初始化的状态。\",\"另外还需要注意的是，在第 4 步中会进一步计算数组中可用的大小，即为数组实际大小 n 乘以加载因子 0.75，可以看下这里乘以 0.75 是怎么算的：\",\"0.75 为四分之三，这里 n - (n >>> 2) 是不是刚好是 n−41​n=43​n，挺有意思的吧。\",\"如果选择是无参的构造器的话，这里在 new Node 数组的时候会使用默认大小为 DEFAULT_CAPACITY（16），然后乘以加载因子 0.75 为 12，也就是说数组的可用大小为 12。\"]},\"1272\":{\"h\":\"3.3 put 方法\",\"t\":[\"使用 ConcurrentHashMap 最常用的也应该是 put 和 get 方法了吧，我们先来看看 put 方法是怎样实现的。\",\"调用 put 方法时实际具体实现是 putVal 方法，源码如下：\",\"/** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); // 1. 计算key的hash值 int hash = spread(key.hashCode()); int binCount = 0; for (Node<K,V>[] tab = table;;) { Node<K,V> f; int n, i, fh; // 2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } // 4. 当前正在扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { if (tabAt(tab, i) == f) { // 5. 当前为链表，在链表中插入新的键值对 if (fh >= 0) { binCount = 1; for (Node<K,V> e = f;; ++binCount) { K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node<K,V> pred = e; if ((e = e.next) == null) { pred.next = new Node<K,V>(hash, key, value, null); break; } } } // 6. 当前为红黑树，将新的键值对插入到红黑树中 else if (f instanceof TreeBin) { Node<K,V> p; binCount = 2; if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } // 7. 插入完键值对后再根据实际大小看是否需要转换成红黑树 if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 addCount(1L, binCount); return null; }\",\"put 方法的代码量有点长，我们按照上面的分解的步骤一步步来看。从整体而言，为了解决线程安全的问题，ConcurrentHashMap 使用了 synchronzied 和 CAS 的方式。\",\"在之前了解过 HashMap 以及 1.8 版本之前的 ConcurrenHashMap 应该都知道 ConcurrentHashMap 结构图，为了方面下面的讲解这里先直接给出，如果对这有疑问的话，可以在网上随便搜搜即可。\",\"ConcurrentHashMap散列桶数组结构示意图\",\"如上图，ConcurrentHashMap 是一个哈希桶数组，如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是标准的链地址的解决方式，将 hash 值相同的节点构成链表的形式，称为 “拉链法”。另外，在 1.8 版本中为了防止拉链过长，当链表的长度大于 8 的时候会将链表转换成红黑树。\",\"table 数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。当插入键值对时首先应该定位到要插入的桶，即插入 table 数组的索引 i 处。那么，怎样计算得出索引 i 呢？当然是根据 key 的 hashCode 值。\",\"1. spread() 重哈希，以减小 Hash 冲突\",\"我们知道对于一个 hash 表来说，hash 值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到 hash 表的性能。因此通过 spread 方法进行了一次重 hash 从而大大减小哈希冲突的可能性。spread 方法为：\",\"static final int spread(int h) { return (h ^ (h >>> 16)) & HASH_BITS; }\",\"该方法主要是将 key 的 hashCode 的低 16 位与高 16 位进行异或运算，这样不仅能够使得 hash 值能够分散能够均匀减小 hash 冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的 trade-off。\",\"2. 初始化 table\",\"紧接着到第 2 步，会判断当前 table 数组是否初始化了，没有的话就调用 initTable 进行初始化，该方法在上面已经讲过了。\",\"3. 能否直接将新值插入到 table 数组中\",\"从上面的结构示意图就可以看出存在这样一种情况，如果插入值待插入的位置刚好所在的 table 数组为 null 的话就可以直接将值插入即可。那么怎样根据 hash 确定在 table 中待插入的索引 i 呢？很显然可以通过 hash 值与数组的长度取模操作，从而确定新值插入到数组的哪个位置。\",\"而之前我们提过 ConcurrentHashMap 的大小总是 2 的幂次方，(n - 1) & hash 运算等价于对长度 n 取模，也就是 hash % n，但是位运算比取模运算的效率要高很多。\",\"确定好数组的索引 i 后，就可以通过 tabAt() 方法获取该位置上的元素，如果当前 Node f 为 null 的话，就可以直接用 casTabAt() 方法将新值插入即可。\",\"4. 当前是否正在扩容\",\"如果当前节点不为 null，且该节点为特殊节点（forwardingNode）的话，就说明当前 ConcurrentHashMap 正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。\",\"那么怎样确定当前的这个 Node 是不是特殊的节点呢？是通过判断该节点的 hash 值是不是等于 −1（MOVED），代码为 (fh = f.hash) == MOVED，对 MOVED 的解释在源码上也写的很清楚了：\",\"static final int MOVED = -1; // hash for forwarding nodes\",\"5. 当 table[i] 为链表的头结点，在链表中插入新值\",\"在 table[i] 不为 null 并且不为 forwardingNode 时，并且当前 Node f 的 hash 值大于 0（fh >= 0） 的话说明当前节点 f 为当前桶的所有的节点组成的链表的头结点。\",\"那么接下来，要想向 ConcurrentHashMap 插入新值的话就是向这个链表插入新值。通过 synchronized (f) 的方式进行加锁以实现线程安全性。往链表中插入节点的部分代码为：\",\"if (fh >= 0) { binCount = 1; for (Node<K,V> e = f;; ++binCount) { K ek; // 找到hash值相同的key,覆盖旧值即可 if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node<K,V> pred = e; if ((e = e.next) == null) { // 如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可 pred.next = new Node<K,V>(hash, key, value, null); break; } } }\",\"这部分代码很好理解，就是两种情况：\",\"在链表中如果找到了与待插入的键值对的 key 相同的节点，就直接覆盖即可\",\"如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可\",\"6. 当 table[i] 为红黑树的根节点，在红黑树中插入新值\",\"按照之前的 数组+链表 的设计方案，这里存在一个问题，即使负载因子和 Hash 算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为 O(n) 的情况，则会严重影响 ConcurrentHashMap 的性能。\",\"于是，在 JDK1.8 版本中，对数据结构做了进一步的优化，引入了红黑树。当链表长度太长（默认超过 8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 ConcurrentHashMap 的性能，其中会用到红黑树的插入、删除、查找等算法。\",\"当 table[i] 为红黑树的树节点时的操作为：\",\"if (f instanceof TreeBin) { Node<K,V> p; binCount = 2; if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } }\",\"首先在 if 中通过 f instanceof TreeBin 判断当前 table[i] 是否是树节点，这下也正好验证了我们在最上面介绍时说的 TreeBin 会对 TreeNode 做进一步封装，对红黑树进行操作的时候针对的是 TreeBin 而不是 TreeNode。接着调用 putTreeVal 方法完成向红黑树插入新节点，如果在红黑树中存在与待插入键值对的 Key 相同（hash 值相等并且 equals 方法判断为 true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点。\",\"7. 根据当前节点个数进行调整\",\"当完成数据新节点插入之后，会进一步对当前链表大小进行调整，这部分代码为：\",\"if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; }\",\"很容易理解，如果当前链表节点个数大于等于 8（TREEIFY_THRESHOLD）的时候，就会调用 treeifyBin 方法将 tabel[i]（第 i 个散列桶）拉链转换成红黑树。\",\"至此，关于 put 方法的逻辑就基本说的差不多了，现在来做一些总结：\",\"put 方法整体流程\",\"首先对于每一个放入的值，首先利用 spread 方法对 key 的 hashcode 进行一次 hash 计算，由此来确定这个值在 table 中的位置\",\"如果当前 table 数组还未初始化，先将 table 数组进行初始化操作\",\"如果这个位置是 null 的，那么使用 CAS 操作直接放入\",\"如果这个位置存在结点，说明发生了 hash 碰撞，首先判断这个节点的类型： \",\"如果该节点 fh == MOVED（代表 forwardingNode，数组正在进行扩容），说明正在进行扩容；\",\"如果是链表节点（fh > 0），则得到的结点就是 hash 值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到 key 相同的节点，则只需要覆盖该结点的 value 值即可。否则依次向后遍历，直到链表尾插入这个结点；\",\"如果这个节点的类型是 TreeBin，直接调用红黑树的插入方法进行插入新的节点。\",\"插入完节点之后再次检查链表长度，如果长度大于 8，就把这个链表转换成红黑树\",\"对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。\"]},\"1273\":{\"h\":\"3.4 get 方法\",\"t\":[\"看完了 put 方法再来看 get 方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了。get 方法源码为：\",\"public V get(Object key) { Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek; // 1. 重hash int h = spread(key.hashCode()); if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) { // 2. table[i]桶节点的key与查找的key相同，则直接返回 if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null && key.equals(ek))) return e.val; } // 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可 else if (eh < 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) { //4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可 if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) return e.val; } } return null; }\",\"代码的逻辑请看注释，首先先看当前的 hash 桶数组节点即 table[i] 是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的 hash 值是否为小于 0，如果小于 0 则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若找到则返回节点的 value，若没有找到就返回 null。\"]},\"1274\":{\"h\":\"3.5 transfer 方法\",\"t\":[\"当 ConcurrentHashMap 容量不足的时候，需要对 table 进行扩容。这个方法的基本思想跟 HashMap 是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足 concurrent 的要求，而是希望利用并发处理去减少扩容带来的时间影响。transfer方法源码为：\",\"private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) { int n = tab.length, stride; if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range // 1. 新建Node数组，容量为之前的两倍 if (nextTab == null) { // initiating try { @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } nextTable = nextTab; transferIndex = n; } int nextn = nextTab.length; // 2. 新建forwardingNode引用，在之后会用到 ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) { Node<K,V> f; int fh; // 3. 确定遍历中的索引i while (advance) { int nextIndex, nextBound; if (--i >= bound || finishing) advance = false; else if ((nextIndex = transferIndex) <= 0) { i = -1; advance = false; } else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex > stride ? nextIndex - stride : 0))) { bound = nextBound; i = nextIndex - 1; advance = false; } } // 4. 将原数组中的元素复制到新数组中去 // 4.5 for循环退出，扩容结束修改sizeCtl属性 if (i < 0 || i >= n || i + n >= nextn) { int sc; if (finishing) { nextTable = null; table = nextTab; sizeCtl = (n << 1) - (n >>> 1); return; } if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit } } // 4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符) else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); // 4.2 如果遍历到ForwardingNode节点 说明这个点已经被处理过了 直接跳过 这里是控制并发扩容的核心 else if ((fh = f.hash) == MOVED) advance = true; // already processed else { synchronized (f) { if (tabAt(tab, i) == f) { Node<K,V> ln, hn; if (fh >= 0) { // 4.3 处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表 另一个是原链表的反序排列 int runBit = fh & n; Node<K,V> lastRun = f; for (Node<K,V> p = f.next; p != null; p = p.next) { int b = p.hash & n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } for (Node<K,V> p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph & n) == 0) ln = new Node<K,V>(ph, pk, pv, ln); else hn = new Node<K,V>(ph, pk, pv, hn); } // 在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); // 在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); // 在table的i位置上插入forwardNode节点 表示已经处理过该节点 setTabAt(tab, i, fwd); // 设置advance为true 返回到上面的while循环中 就可以执行i--操作 advance = true; } // 4.4 处理当前节点是TreeBin时的情况，操作和上面的类似 else if (f instanceof TreeBin) { TreeBin<K,V> t = (TreeBin<K,V>)f; TreeNode<K,V> lo = null, loTail = null; TreeNode<K,V> hi = null, hiTail = null; int lc = 0, hc = 0; for (Node<K,V> e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode<K,V> p = new TreeNode<K,V> (h, e.key, e.val, null, null); if ((h & n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin<K,V>(lo) : t; hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin<K,V>(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } } } } } }\",\"代码逻辑请看注释，整个扩容操作分为两个部分：\",\"第一部分是构建一个 nextTable，它的容量是原来的两倍，这个操作是单线程完成的。新建 table数组的代码为：\",\"Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1]\",\"在原容量大小的基础上右移一位。\",\"第二部分就是将原来 table 中的元素复制到 nextTable 中，主要是遍历复制的过程。根据运算得到当前遍历的数组的位置 i，然后利用 tabAt 方法获得 i 位置的元素再进行判断：\",\"如果这个位置为空，就在原 table 中的 i 位置放入 forwardNode 节点，这个也是触发并发扩容的关键点；\",\"如果这个位置是 Node 节点（fh >= 0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在 nextTable 的 i 和 i+n 的位置上\",\"如果这个位置是 TreeBin 节点（fh < 0），也做一个反序处理，并且判断是否需要 untreefi，把处理的结果分别放在 nextTable 的 i 和 i+n 的位置上\",\"遍历过所有的节点以后就完成了复制工作，这时让 nextTable 作为新的 table，并且更新 sizeCtl 为新容量的 0.75 倍，完成扩容。\",\"设置为新容量的 0.75 倍代码为 sizeCtl = (n << 1) - (n >>> 1)，仔细体会下会发现很巧妙。n << 1 相当于 n 右移一位表示 n 的两倍即 2n，n >>> 1 右移一位相当于 2n​ 即 0.5n，然后两者相减为 2n−0.5n=1.5n，刚好等于新容量的 0.75 倍即 2n∗0.75=1.5n。\",\"最后用一个示意图来进行总结（图片摘自网络）：\",\"ConcurrentHashMap扩容示意图\"]},\"1275\":{\"h\":\"3.6 与 size 相关的一些方法\",\"t\":[\"对于 ConcurrentHashMap 来说，这个 table 里到底装了多少东西其实是个不确定的数量，因为不可能在调用 size() 方法的时候像 GC 的 “stop the world” 一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap 也是大费周章才计算出来的。\",\"为了统计元素个数，ConcurrentHashMap 定义了一些变量和一个内部类：\",\"/** * A padded cell for distributing counts. Adapted from LongAdder * and Striped64. See their internal docs for explanation. */ @sun.misc.Contended static final class CounterCell { volatile long value; CounterCell(long x) { value = x; } } /******************************************/ /** * 实际上保存的是hashmap中的元素个数 利用CAS锁进行更新 * 但它并不用返回当前hashmap的元素个数 */ private transient volatile long baseCount; /** * Spinlock (locked via CAS) used when resizing and/or creating CounterCells. */ private transient volatile int cellsBusy; /** * Table of counter cells. When non-null, size is a power of 2. */ private transient volatile CounterCell[] counterCells;\",\"1. mappingCount 与 size 方法\",\"mappingCount 与 size 方法类似，从给出的注释来看，应该使用 mappingCount 代替 size 方法。两个方法都没有直接返回 basecount，而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。\",\"public int size() { long n = sumCount(); return ((n < 0L) ? 0 : (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n); } /** * Returns the number of mappings. This method should be used * instead of {@link #size} because a ConcurrentHashMap may * contain more mappings than can be represented as an int. The * value returned is an estimate; the actual count may differ if * there are concurrent insertions or removals. * * @return the number of mappings * @since 1.8 */ public long mappingCount() { long n = sumCount(); return (n < 0L) ? 0L : n; // ignore transient negative values } final long sumCount() { CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) { for (int i = 0; i < as.length; ++i) { if ((a = as[i]) != null) sum += a.value; // 所有counter的值求和 } } return sum; }\",\"2. addCount 方法\",\"在 put 方法结尾处调用了 addCount 方法，把当前 ConcurrentHashMap 的元素个数 +1。这个方法一共做了两件事，更新 baseCount 的值，检测是否进行扩容。\",\"private final void addCount(long x, int check) { CounterCell[] as; long b, s; // 利用CAS方法更新baseCount的值 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) < 0 || (a = as[ThreadLocalRandom.getProbe() & m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { fullAddCount(x, uncontended); return; } if (check <= 1) return; s = sumCount(); } // 如果check值大于等于0 则需要检验是否需要进行扩容操作 if (check >= 0) { Node<K,V>[] tab, nt; int n, sc; while (s >= (long)(sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) { int rs = resizeStamp(n); // 当前线程不是唯一的或不是第一个发起扩容的线程 if (sc < 0) { if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0) break; // 如果已经有其他线程在执行扩容操作 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } // 当前线程是唯一的或是第一个发起扩容的线程 此时nextTable=null else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } }\"]},\"1276\":{\"h\":\"4. 总结\",\"t\":[\"JDK6,7 中的 ConcurrentHashMap 主要使用 Segment 来实现减小锁粒度，分割成若干个 Segment，在 put 的时候需要锁住 Segment，get 时候不加锁，使用 volatile 来保证可见性，当要统计全局时（比如 size），首先会尝试多次计算 modcount 来确定，这几次尝试中，判断是否有其他线程进行了修改操作，如果没有，则直接返回 size。如果有，则需要依次锁住所有的 Segment 来计算。\",\"1.8 之前 put 定位节点时要先定位到具体的 segment，然后再在 segment 中定位到具体的桶。而在 1.8 的时候摒弃了 segment 臃肿的设计，直接针对的是 Node[] tale 数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于 8 的时候采用红黑树的设计。\",\"主要设计上的变化有以下几点:\",\"不采用 segment 而采用 node，锁住 node 来实现减小锁粒度。\",\"设计了 MOVED 状态，当 resize 的过程中，线程 2 还在 put 数据，线程 2 会帮助 resize。\",\"使用 3 个 CAS 操作来确保 node 的一些操作的原子性，这种方式代替了锁。\",\"sizeCtl 的不同值来代表不同含义，起到了控制的作用。\",\"采用 synchronized 而不是 ReentrantLock\",\"更多关于 1.7 版本与 1.8 版本的 ConcurrentHashMap 的实现对比，可以参考这篇 —— 谈谈ConcurrentHashMap1.7和1.8的不同实现。\",\"参考文章：深入浅出ConcurrentHashMap1.8\"]},\"1277\":{\"c\":[\"并发编程\"]},\"1278\":{\"c\":[\"JUC\"]},\"1279\":{\"h\":\"并发容器之 ConcurrentLinkedQueue\"},\"1280\":{\"h\":\"1. ConcurrentLinkedQueue 简介\",\"t\":[\"在单线程编程中我们会经常用到一些集合类，比如 ArrayList，HashMap 等，但是这些类都不是线程安全的类。在面试中也经常会有一些考点，比如 ArrayList 不是线程安全的，Vector 是线程安全。而保障 Vector 线程安全的方式，是非常粗暴的在方法上用 synchronized 独占锁，将多线程执行变成串行化。要想将 ArrayList 变成线程安全的也可以使用 Collections.synchronizedList(List<T> list) 方法将 ArrayList 转换成线程安全的，但这种转换方式依然是通过 synchronized 修饰方法实现的，很显然这不是一种高效的方式。\",\"同时，队列也是我们常用的一种数据结构。为了解决线程安全的问题，DougLea 大师为我们准备了 ConcurrentLinkedQueue 这个线程安全的队列。从类名就可以看的出来实现队列的数据结构是链式。\"]},\"1281\":{\"h\":\"1.1 Node\",\"t\":[\"要想先学习 ConcurrentLinkedQueue 自然而然得先从它的节点类看起，明白它的底层数据结构。Node 类的源码为：\",\"private static class Node<E> { volatile E item; volatile Node<E> next; ....... }\",\"Node 节点主要包含了两个域：一个是数据域 item，另一个是 next 指针，用于指向下一个节点从而构成链式队列。并且都是用volatile进行修饰的，以保证内存可见性（关于 volatile 可以看这篇文章）。\",\"另外 ConcurrentLinkedQueue 含有这样两个成员变量：\",\"private transient volatile Node<E> head; private transient volatile Node<E> tail;\",\"说明 ConcurrentLinkedQueue 通过持有头尾指针进行管理队列。当我们调用无参构造器时，其源码为：\",\"public ConcurrentLinkedQueue() { head = tail = new Node<E>(null); }\",\"head 和 tail 指针会指向一个 item 域为 null 的节点，此时 ConcurrentLinkedQueue 状态如下图所示：\",\"1. ConcurrentLinkedQueue 初始化状态\",\"如图，head 和 tail 指向同一个节点 Node0，该节点 item 域为 null，next域为 null。\"]},\"1282\":{\"h\":\"1.2 操作 Node 的几个 CAS 操作\",\"t\":[\"在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。可以看出在处理器指令集能够支持 CMPXCHG 指令后，在 Java 源码中涉及到并发处理都会使用 CAS 操作，那么在 ConcurrentLinkedQueue 中对 Node 的 CAS 操作有这样几个：\",\"// 更改Node中的数据域item boolean casItem(E cmp, E val) { return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); } // 更改Node中的指针域next void lazySetNext(Node<E> val) { UNSAFE.putOrderedObject(this, nextOffset, val); } // 更改Node中的指针域next boolean casNext(Node<E> cmp, Node<E> val) { return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); }\",\"可以看出这些方法实际上是通过调用 UNSAFE 实例的方法，UNSAFE 为 sun.misc.Unsafe 类，该类是 hotspot 底层方法，目前为止了解即可，知道 CAS 的操作归根结底是由该类提供就好。\"]},\"1283\":{\"h\":\"2. offer 方法\",\"t\":[\"对一个队列来说，插入满足 FIFO 特性，插入元素总是在队列最末尾的地方进行插入，而取（移除）元素总是从队列的队头。所有要想能够彻底弄懂 ConcurrentLinkedQueue 自然而然是从 offer 方法和 poll 方法开始。\",\"另外，在看多线程的代码时，可采用这样的思维方式：\",\"多线程分析方式\",\"单个线程 offer，多个线程 offer，部分线程 offer，部分线程 poll\",\"---- offer 的速度快于 poll --------\",\"队列长度会越来越长，由于 offer 节点总是在对队列队尾，而 poll节点总是在队列对头，也就是说 offer 线程和 poll 线程两者并无 “交集”，也就是说两类线程间并不会相互影响，这种情况站在相对速率的角度来看，也就是一个 \\\"单线程 offer\\\"\",\"---- offer 的速度慢于 poll --------\",\"poll 的相对速率快于 offer，也就是队头删的速度要快于队尾添加节点的速度，导致的结果就是队列长度会越来越短，而 offer 线程和 poll 线程就会出现 “交集”，即那一时刻就可以称之为 offer 线程和 poll 线程同时操作的节点为 临界点，且在该节点 offer 线程和 poll 线程必定相互影响。\",\"根据在临界点时 offer 和 poll 发生的相对顺序又可从两个角度去思考：\",\"执行顺序为：offer --> poll --> offer，即表现为当 offer 线程在 Node1 后插入 Node2 时，此时 poll 线程已经将 Node1 删除，这种情况很显然需要在 offer 方法中考虑；\",\"执行顺序可能为：poll --> offer --> poll，即表现为当 poll 线程准备删除的节点为 null 时（队列为空队列），此时 offer 线程插入一个节点使得队列变为非空队列\",\"那么为了能够理解 offer 方法，采用 debug 的方式来一行一行的看代码。\",\"先看这么一段代码：\",\"1. ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>(); 2. queue.offer(1); 3. queue.offer(2);\",\"创建一个 ConcurrentLinkedQueue 实例，先 offer(1)，然后再 offer(2)。offer 的源码为：\",\"public boolean offer(E e) { checkNotNull(e); final Node<E> newNode = new Node<E>(e); for (Node<E> t = tail, p = t; ; ) { Node<E> q = p.next; if (q == null) { // p is last node if (p.casNext(null, newNode)) { // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become \\\"live\\\". if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; } // Lost CAS race to another thread; re-read next } else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t && t != (t = tail)) ? t : q; } }\",\"单线程执行角度分析：\",\"先从单线程执行的角度看起，分析 offer(1) 的过程。第 2 行代码会对是否为 null 进行判断，为 null 的话就直接抛出空指针异常，第 3 行代码将 e 包装成一个 Node 类，第 5 行为 for 循环，只有初始化条件没有循环结束条件，这很符合 CAS 的 “套路”，在循环体 CAS 操作成功会直接 return 返回，如果 CAS 操作失败的话就在 for 循环中不断重试直至成功。\",\"这里实例变量 t 被初始化为 tail，p 被初始化为 t 即 tail。为了方便下面的理解，p 被认为队列真正的尾节点，tail 不一定指向对象真正的尾节点，因为在 ConcurrentLinkedQueue 中 tail 是被延迟更新的，具体原因看后面分析。\",\"代码走到第 5 行的时候，t 和 p 都分别指向初始化时创建的 item 域为 null，next 域为 null 的 Node0。第 6 行变量 q 被赋值为 null，第 7 行 if 判断为 true，在第 9 行使用 casNext 将插入的 Node 设置成当前队列尾节点 p 的 next 节点，如果 CAS 操作失败，此次循环结束在下次循环中进行重试。CAS 操作成功走到第 13 行，此时 p == t，if 判断为 false，直接 return true 返回。如果成功插入 1 的话，此时 ConcurrentLinkedQueue 的状态如下图所示：\",\"2. offer(1) 后队列的状态\",\"如图，此时队列的尾节点应该为 Node1，而 tail 指向的节点依然还是 Node0，因此可以说明 tail 是延迟更新的。\",\"那么我们继续来看 offer(2) 的时候的情况，很显然此时第 6 行 q 指向的节点不为 null 了，而是指向 Node1，第 7 行 if 判断为 false，第 19 行 if 判断为 false，代码会走到第 27 行。\",\"好了，再插入节点的时候我们会问自己这样一个问题？上面已经解释了 tail 并不是指向队列真正的尾节点，那么在插入节点的时候，我们是不是应该最开始做的就是找到队列当前的尾节点在哪里才能插入？那么第 27 行代码就是找出队列真正的尾节点。\",\"定位队列真正的对尾节点\",\"p = (p != t && t != (t = tail)) ? t : q;\",\"我们来分析一下这行代码，如果这段代码在单线程环境执行时，很显然由于 p == t，此时 p 会被赋值为 q，而 q 等于 Node<E> q = p.next，即 Node1。在第一次循环中指针 p 指向了队列真正的队尾节点 Node1，那么在下一次循环中第 6 行 q 指向的节点为 null，那么在第 7 行中 if 判断为 true，那么在第 9 行依然通过 casNext 方法设置 p 节点的 next 为当前新增的 Node，接下来走到第 13 行，这个时候 p != t，第 13 行 if 判断为 true，会通过 casTail(t, newNode) 将当前节点 Node 设置为队列的队尾节点，此时的队列状态示意图如下图所示：\",\"3. 队列 offer(2) 后的状态\",\"tail 指向的节点由 Node0 改变为 Node2，这里的 casTail 失败不需要重试的原因是，offer 代码中主要是通过 p 的 next 节点 q (Node<E> q = p.next) 决定后面的逻辑走向的，当 casTail 失败时状态示意图如下：\",\"4. 队列进行入队操作后 casTail 失败后的状态图\",\"如图，如果这里 casTail 设置 tail 失败即 tail 还是指向 Node0 节点的话，无非就是多循环几次通过 27 行代码定位到队尾节点。\",\"通过对单线程执行角度进行分析，我们可以了解到 poll 的执行逻辑为：\",\"如果 tail 指向的节点的下一个节点（next 域）为 null 的话，说明 tail 指向的节点即为队列真正的队尾节点，因此可以通过 casNext 插入当前待插入的节点，但此时 tail 并未变化，如图 2;\",\"如果 tail 指向的节点的下一个节点（next 域）不为 null 的话，说明 tail 指向的节点不是队列的真正队尾节点。通过 q（Node<E> q = p.next）指针往前递进去找到队尾节点，然后通过 casNext 插入当前待插入的节点，并通过 casTail 方式更改 tail，如图 3。\",\"我们回过头再来看 p = (p != t && t != (t = tail)) ? t : q; 这行代码在单线程中，这段代码永远不会将 p 赋值为 t，那么这么写就不会有任何作用，那我们试着在多线程的情况下进行分析。\",\"多线程执行角度分析：\",\"多个线程 offer\",\"很显然这么写另有深意，其实在多线程环境下这行代码很有意思的。 t != (t = tail) 这个操作并非一个原子操作，有这样一种情况：\",\"5. 线程 A 和线程 B 有可能的执行时序\",\"如图，假设线程 A 此时读取了变量 t，线程 B 刚好在这个时候 offer 一个 Node 后，此时会修改 tail 指针，那么这个时候线程 A 再次执行 t = tail 时 t 会指向另外一个节点，很显然线程 A 前后两次读取的变量 t 指向的节点不相同，即 t != (t = tail) 为 true，并且由于 t 指向节点的变化 p != t 也为 true，此时该行代码的执行结果为 p 和 t 最新的 t 指针指向了同一个节点，并且此时 t 也是队列真正的对尾节点。那么，现在已经定位到队列真正的队尾节点，就可以执行 offer 操作了。\",\"offer -> poll -> offer\",\"那么还剩下第 19 行的代码我们没有分析，大致可以猜想到应该就是回答一部分线程 offer，一部分 poll 的这种情况。当 if (p == q) 为 true 时，说明 p 指向的节点的 next 也指向它自己，这种节点称之为哨兵节点，这种节点在队列中存在的价值不大，一般表示为要删除的节点或者是空节点。为了能够很好的理解这种情况，我们先看看 poll 方法的执行过程后，再回过头来看，总之这是一个很有意思的事情。\"]},\"1284\":{\"h\":\"3. poll 方法\",\"t\":[\"poll 方法源码如下：\",\"public E poll() { restartFromHead: for (;;) { for (Node<E> h = head, p = h, q;;) { E item = p.item; if (item != null && p.casItem(item, null)) { // Successful CAS is the linearization point // for item to be removed from this queue. if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; } else if ((q = p.next) == null) { updateHead(h, p); return null; } else if (p == q) continue restartFromHead; else p = q; } } }\",\"我们还是先站在单线程的角度去理清该方法的基本逻辑。假设 ConcurrentLinkedQueue 初始状态如下图所示：\",\"6. 队列初始状态\",\"参数 offer 时的定义，我们还是先将变量 p 作为队列要删除真正的队头节点，h (head) 指向的节点并不一定是队列的队头节点。先来看 poll 出 Node1 时的情况，由于 p = h = head，参照上图，很显然此时 p 指向的 Node1 的数据域不为 null，在第 7 行代码中 item != null 判断为 true 后接下来通过 casItem 将 Node1 的数据域设置为 null。如果 CAS 设置失败则此次循环结束等待下一次循环进行重试。若第 7 行执行成功进入到第 10 行代码，此时 p 和 h 都指向 Node1，第 10 行 if 判断为 false，然后直接到第 12 行 return 回 Node1 的数据域 1，方法运行结束，此时的队列状态如下图：\",\"7. 队列出队操作后的状态\",\"下面继续从队列中 poll，很显然当前 h 和 p 指向的 Node1 的数据域为 null，那么第一件事就是要定位准备删除的队头节点（找到数据域不为 null 的节点）。\",\"定位删除的队头节点\",\"继续看，第 5 行代码 item 为 null，第 7 行代码 if 判断为 false，走到第 14 行代码（q = p.next）if 也为 false，由于 q 指向了 Node2，在第 18 行的 if 判断也为 false，因此代码走到了第 21 行，这个时候 p 和 q 共同指向了 Node2，也就找到了要删除的真正的队头节点。\",\"可以总结出，定位待删除的队头节点的过程为：如果当前节点的数据域为 null，很显然该节点不是待删除的节点，就用当前节点的下一个节点去试探。在经过第一次循环后，此时状态图为下图：\",\"8. 经过一次循环后的状态\",\"进行下一次循环，第 7 行的操作同上述，当前假设第 7 行中 casItem 设置成功，由于 p 已经指向了 Node2，而 h 还依旧指向 Node1，此时第 10 行的 if 判断为 true，然后执行 updateHead(h, ((q = p.next) != null) ? q : p)，此时 q 指向的 Node3，所有传入 updateHead 方法的分别是指向 Node1 的 h 引用和指向 Node3 的 q 引用。updateHead 方法的源码为：\",\"final void updateHead(Node<E> h, Node<E> p) { if (h != p && casHead(h, p)) h.lazySetNext(h); }\",\"该方法主要是通过 casHead 将队列的 head 指向 Node3，并且通过 h.lazySetNext 将 Node1 的 next 域指向它自己。最后在第7行代码中返回 Node2 的值。此时队列的状态如下图所示：\",\"9. Node2 从队列中出队后的状态\",\"Node1 的 next 域指向它自己，head 指向了 Node3。如果队列为空队列的话，就会执行到代码的第 14 行 (q = p.next) == null，if 判断为 true，因此在第 16 行中直接返回 null。\",\"以上的分析是从单线程执行的角度去看，也可以让我们了解 poll 的整体思路，现在来做一个总结：\",\"如果当前 head，h 和 p 指向的节点的 item 不为 null 的话，说明该节点即为真正的队头节点（待删除节点），只需要通过 casItem 方法将 item 域设置为 null，然后将原来的 item 直接返回即可。\",\"如果当前 head，h 和 p 指向的节点的 item 为 null 的话，则说明该节点不是真正的待删除节点，那么应该做的就是寻找 item 不为 null 的节点。通过让 q 指向 p 的下一个节点（q = p.next）进行试探，若找到则通过 updateHead 方法更新 head 指向的节点以及构造哨兵节点（通过 updateHead 方法的 h.lazySetNext(h)）。\",\"接下来，按照上面分析 offer 的思维方式，下面来分析一下多线程的情况，第一种情况是；\",\"多线程执行情况分析：\",\"多个线程poll\",\"现在回过头来看 poll 方法的源码，有这样一部分：\",\"else if (p == q) continue restartFromHead;\",\"这一部分就是处理多个线程 poll 的情况，q = p.next 也就是说 q 永远指向的是 p 的下一个节点，那么什么情况下会使得 p，q 指向同一个节点呢？根据上面我们的分析，只有 p 指向的节点在 poll 的时候转变成了哨兵节点（通过 updateHead 方法中的 h.lazySetNext）。当线程 A 在判断 p==q 时，线程 B 已经将执行完 poll 方法将 p 指向的节点转换为哨兵节点并且 head 指向的节点已经发生了改变，所以就需要从 restartFromHead 处执行，保证用到的是最新的 head。\",\"poll -> offer -> poll\",\"试想，还有这样一种情况，如果当前队列为空队列，线程 A 进行 poll 操作，同时线程 B 执行 offer，然后线程 A 在执行 poll，那么此时线程 A 返回的是 null 还是线程 B 刚插入的最新的那个节点呢？我们来写一下 demo：\",\"public static void main(String[] args) { Thread thread1 = new Thread(() -> { Integer value = queue.poll(); System.out.println(Thread.currentThread().getName() + \\\" poll 的值为：\\\" + value); System.out.println(\\\"queue当前是否为空队列：\\\" + queue.isEmpty()); }); thread1.start(); Thread thread2 = new Thread(() -> { queue.offer(1); }); thread2.start(); }\",\"输出结果为：\",\"Thread-0 poll 的值为：null queue当前是否为空队列：false\",\"通过 debug 控制线程 thread1 和线程 thread2 的执行顺序，thread1 先执行到第 14 行代码 if ((q = p.next) == null)，由于此时队列为空队列 if 判断为 true，进入 if 块，此时先让 thread1 暂停，然后 thread2 进行 offer 插入值为 1 的节点后，thread2 执行结束。再让 thread1 执行，这时 thread1 并没有进行重试，而是代码继续往下走，返回 null，尽管此时队列由于 thread2 已经插入了值为 1 的新的节点。所以输出结果为 thread0 poll的为null，然队列不为空队列。\",\"因此，在判断队列是否为空队列的时候是不能通过线程在 poll 的时候返回为 null 进行判断的，可以通过 isEmpty 方法进行判断。\"]},\"1285\":{\"h\":\"4. offer 方法中部分线程 offer 部分线程 poll\",\"t\":[\"在分析 offer 方法的时候我们还留下了一个问题，即对 offer 方法中第 19 行代码的理解。\",\"offer -> poll -> offer\",\"在 offer 方法的第 19 行代码 if (p == q)，能够让 if 判断为 true 的情况为 p 指向的节点为哨兵节点，而什么时候会构造哨兵节点呢？\",\"在对poll方法的讨论中，我们已经找到了答案，即当 head 指向的节点的 item 域为 null 时会寻找真正的队头节点，等到待插入的节点插入之后，会更新 head，并且将原来 head 指向的节点设置为哨兵节点。假设队列初始状态如下图所示：\",\"10. offer 和 poll 相互影响分析时队列初始状态\",\"因此在线程 A 执行 offer 时，线程 B 执行 poll 就会存在如下一种情况：\",\"11. 线程 A 和线程 B 可能存在的执行时序\",\"如图，线程 A 的 tail 节点存在 next 节点 Node1，因此会通过引用 q 往前寻找队列真正的队尾节点，当执行到判断 if (p == q) 时，此时线程 B 执行 poll 操作，在对线程 B 来说，head 和 p 指向 Node0，由于 Node0 的 item 域为 null，同样会往前递进找到队列真正的队头节点 Node1，在线程 B 执行完 poll 之后，Node0 就会转换为哨兵节点，也就意味着队列的 head 发生了改变，此时队列状态为下图。\",\"12. 线程 B 进行 poll 后队列的状态图\",\"此时线程 A 在执行判断 if (p == q) 时就为 true，会继续执行 p = (t != (t = tail)) ? t : head;，由于 tail 指针没有发生改变所以 p 被赋值为 head，重新从 head 开始完成插入操作。\"]},\"1286\":{\"h\":\"5. HOPS 的设计\",\"t\":[\"通过上面对 offer 和 poll 方法的分析，我们发现 tail 和 head 是延迟更新的，两者更新触发时机为：\",\"tail 更新触发时机：当 tail 指向的节点的下一个节点不为 null 的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过 casTail 进行 tail 更新；当 tail 指向的节点的下一个节点为 null 的时候，只插入节点不更新 tail。\",\"head 更新触发时机：当 head 指向的节点的 item 域为 null 的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过 updateHead 进行 head 更新；当 head 指向的节点的 item 域不为 null 的时候，只删除节点不更新 head。\",\"并且在更新操作时，源码中会有注释为：hop two nodes at a time。所以这种延迟更新的策略就被叫做 HOPS 的大概原因是这个（猜的 😃），从上面更新时的状态图可以看出，head 和 tail 的更新是 “跳着的”，即中间总是间隔了一个。\",\"那么这样设计的意图是什么呢？\",\"如果让 tail 永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，如果大量的入队操作，每次都要执行 CAS 进行 tail 的更新，汇总起来对性能也会是大大的损耗。如果能减少 CAS 更新的操作，无疑可以大大提升入队的操作效率，所以 douglea 大师每间隔 1 次（tail 和队尾节点的距离为 1）进行才利用 CAS 更新 tail。\",\"对 head 的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能。因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。\"]},\"1287\":{\"c\":[\"并发编程\"]},\"1288\":{\"c\":[\"JUC\"]},\"1289\":{\"h\":\"并发容器之 CopyOnWriteArrayList\"},\"1290\":{\"h\":\"1. CopyOnWriteArrayList 简介\",\"t\":[\"Java 学习者都清楚 ArrayList 并不是线程安全的，在读线程在读取 ArrayList 的时候如果有写线程在写数据，基于 fast-fail 机制，会抛出 ConcurrentModificationException 异常，也就是说 ArrayList 并不是一个线程安全的容器，当然我们可以用 Vector，或者用 Collections 的静态方法将 ArrayList 包装成一个线程安全的类，但是这些方式都是采用 Java 关键字 synchronzied 对方法进行修饰，利用独占式锁来保证线程安全的。但是，由于独占式锁在同一时刻只有一个线程能够获取到对象监视器，很显然这种方式效率并不是太高。\",\"回到业务场景中，有很多业务往往是读多写少的，比如系统配置的信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻其他模块之后对系统信息只需要进行读取，又比如白名单，黑名单等配置，只需要读取名单配置然后检测当前用户是否在该配置范围以内。类似的还有很多业务场景，它们都是属于读多写少的场景。\",\"如果在这种情况用到上述的方法，使用 Vector，Collections 转换的这些方式是不合理的，因为尽管多个读线程从同一个数据容器中读取数据，但是读线程对数据容器的数据并不会发生发生修改。自然而然的我们会想到 ReenTrantReadWriteLock（关于读写锁可以看这篇文章），通过读写分离的思想，使得读读之间不会阻塞，无疑如果一个 list 能够做到被多个读线程读取的话，性能会大大提升。但是，如果仅仅是将 list 通过读写锁（ReentrantReadWriteLock）进行再一次封装的话，由于读写锁的特性，当写锁被写线程获取后，读写线程都会被阻塞。所以如果仅使用读写锁对 list 进行封装的话，仍然存在读线程在读数据的时候被阻塞的情况，如果想 list 的读效率更高的话，这里就是我们的突破口，如果我们保证读线程无论什么时候都不被阻塞，效率岂不是会更高？\",\"于是乎，DougLea 大师为我们提供了 CopyOnWriteArrayList 容器可以保证线程安全，保证读读之间在任何时候都不会被阻塞，CopyOnWriteArrayList 也被广泛应用于很多业务场景之中，值得好好认识一番。\"]},\"1291\":{\"h\":\"2. COW 的设计思想\",\"t\":[\"如上述所说，如果简单的使用读写锁的话，在写锁被获取之后，读写线程被阻塞，只有当写锁被释放后读线程才有机会获取到锁从而读到最新的数据，站在读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性。既然我们说到要进行优化，必然有 trade-off，通过牺牲数据实时性满足数据的最终一致性。而 CopyOnWriteArrayList 就是通过 Copy-On-Write(COW)，即写时复制的思想，通过延时更新的策略来实现数据的最终一致性，并且能够保证读线程间不阻塞。\",\"COW 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对 CopyOnWrite 容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。\"]},\"1292\":{\"h\":\"3. CopyOnWriteArrayList 的实现原理\",\"t\":[\"现在我们通过看源码的方式来理解 CopyOnWriteArrayList，实际上 CopyOnWriteArrayList 内部维护的就是一个数组：\",\"/** The array, accessed only via getArray/setArray. */ private transient volatile Object[] array;\",\"并且该数组引用是被 volatile 修饰，注意这里修饰的仅是数组引用，其中另有玄机，稍后揭晓。关于 volatile 很重要的一条性质是它能够够保证可见性。对 list 来说，我们自然而然最关心的就是读写的时候，分别为 get 和 add 方法的实现。\"]},\"1293\":{\"h\":\"3.1 get 方法实现原理\",\"t\":[\"get 方法的源码为：\",\"public E get(int index) { return get(getArray(), index); } /** * Gets the array. Non-private so as to also be accessible * from CopyOnWriteArraySet class. */ final Object[] getArray() { return array; } private E get(Object[] a, int index) { return (E) a[index]; }\",\"可以看出来 get 方法实现非常简单，几乎就是一个 “单线程” 程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有 CAS 操作等等，原因是，所有的读线程只是会读取数据容器中的数据，并不会进行修改。\"]},\"1294\":{\"h\":\"3.2 add 方法实现原理\",\"t\":[\"再来看下如何进行添加数据的，add 方法的源码为：\",\"public boolean add(E e) { final ReentrantLock lock = this.lock; // 1. 使用Lock，保证写线程在同一时刻只有一个 lock.lock(); try { // 2. 获取旧数组引用 Object[] elements = getArray(); int len = elements.length; // 3. 创建新的数组，并将旧数组的数据复制到新数组中 Object[] newElements = Arrays.copyOf(elements, len + 1); // 4. 往新数组中添加新的数据 newElements[len] = e; // 5. 将旧数组引用指向新的数组 setArray(newElements); return true; } finally { lock.unlock(); } }\",\"add 方法的逻辑也比较容易理解，请看上面的注释。需要注意这么几点：\",\"采用 ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份被复制的数据\",\"前面说过数组引用是 volatile 修饰的，因此将旧的数组引用指向新的数组，根据 volatile 的 happens-before 规则，写线程对数组引用的修改对读线程是可见的\",\"由于在写数据的时候，是在新的数组中插入数据的，从而保证读写是在两个不同的数据容器中进行操作。\"]},\"1295\":{\"h\":\"4. 总结\",\"t\":[\"我们知道 COW 和读写锁都是通过读写分离的思想实现的，但两者还是有些不同，可以进行比较：\",\"COW vs 读写锁\",\"相同点：\",\"两者都是通过读写分离的思想实现；\",\"读线程间是互不阻塞的\",\"不同点：\",\"对读线程而言，为了实现数据实时性，在写锁被获取后，读线程会等待或者当读锁被获取后，写线程会等待，从而解决 “脏读” 等问题。也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。\",\"而 COW 则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况。\",\"对这一点从文字上还是很难理解，我们来通过 debug 看一下，add 方法核心代码为：\",\"1. Object[] elements = getArray(); 2. int len = elements.length; 3. Object[] newElements = Arrays.copyOf(elements, len + 1); 4. newElements[len] = e; 5. setArray(newElements);\",\"假设 COW 的变化如下图所示：\",\"最终一致性的分析\",\"数组中已有数据 1,2,3，现在写线程想往数组中添加数据 4，我们在第 5 行处打上断点，让写线程暂停。读线程依然会 “不受影响” 的能从数组中读取数据，可是只能读到 1,2,3。如果读线程能够立即读到新添加的数据的话就叫做能保证数据实时性。\",\"当对第 5 行的断点放开后，读线程才能感知到数据变化，读到完整的数据 1,2,3,4，而保证数据最终一致性，尽管有可能中间间隔了好几秒才感知到。\",\"这里还有这样一个问题：为什么需要复制呢？如果将 array 数组设定为 volitile 的，对 volatile 变量写 happens-before 读，读线程不是能够感知到 volatile 变量的变化吗？\",\"原因是，这里 volatile 的修饰的仅仅只是数组引用，数组中的元素的修改是不能保证可见性的。因此 COW 采用的是新旧两个数据容器，通过第 5 行代码将数组引用指向新的数组。\",\"这也是为什么 concurrentHashMap 只具有弱一致性的原因 —— volatile 的数组只针对数组的引用具有 volatile 的语义，而不是它的元素。\",\"COW 的缺点\",\"CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。\",\"内存占用问题：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意：在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 minor GC 和 major GC。\",\"数据一致性问题：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。\"]},\"1296\":{\"c\":[\"并发编程\"]},\"1297\":{\"c\":[\"JUC\"]},\"1298\":{\"h\":\"并发容器之 ThreadLocal\"},\"1299\":{\"h\":\"1. ThreadLocal 简介\",\"t\":[\"在多线程编程中通常解决线程安全的问题我们会利用 synchronzed 或者 lock 控制线程对临界区资源的同步顺序从而解决线程安全的问题，但是这种加锁的方式会让未获取到锁的线程进行阻塞等待，很显然这种方式的时间效率并不是很好。线程安全问题的核心在于多个线程会对同一个临界区共享资源进行操作，那么，如果每个线程都使用自己的 “共享资源”，各自使用各自的，又互相不影响到彼此即让多个线程间达到隔离的状态，这样就不会出现线程安全的问题。事实上，这就是一种 “空间换时间” 的方案，每个线程都会都拥有自己的 “共享资源” 无疑内存会大很多，但是由于不需要同步也就减少了线程可能存在的阻塞等待的情况从而提高的时间效率。\",\"虽然 ThreadLocal 并不在 java.util.concurrent 包而在 java.lang 包中，但我更倾向于把它当作是一种并发容器（虽然真正存放数据的是 ThreadLoclMap）进行归类。从 ThreadLocal 这个类名可以顾名思义的进行理解，表示线程的 “本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争。\"]},\"1300\":{\"h\":\"2. ThreadLocal 的实现原理\",\"t\":[\"要想学习到 ThreadLocal 的实现原理，就必须了解它的几个核心方法，包括怎样存怎样取等等，下面我们一个个来看。\"]},\"1301\":{\"h\":\"2.1 set 方法\",\"t\":[\"set 方法用于设置在当前线程中 threadLocal 变量的值，该方法的源码为：\",\"public void set(T value) { // 1. 获取当前线程实例对象 Thread t = Thread.currentThread(); // 2. 通过当前线程实例获取到ThreadLocalMap对象 ThreadLocalMap map = getMap(t); if (map != null) // 3. 如果Map不为null,则以当前threadLocl实例为key,值为value进行存入 map.set(this, value); else // 4.map为null,则新建ThreadLocalMap并存入value createMap(t, value); }\",\"方法的逻辑很清晰，具体请看上面的注释。通过源码我们知道 value 是存放在了 ThreadLocalMap 里面，当前先把它理解为一个普通的 map 即可，也就是说，数据 value 真正是存放在 ThreadLocalMap 这个容器中，并且是以当前 threadLocal 实例为 key。\",\"先简单的看下 ThreadLocalMap 是什么，有个简单的认识就好，下面会具体说的。\",\"首先 ThreadLocalMap 是怎样来的？源码很清楚，是通过 getMap(t) 进行获取：\",\"ThreadLocalMap getMap(Thread t) { return t.threadLocals; }\",\"该方法直接返回的就是当前线程对象 t 的一个成员变量 threadLocals：\",\"/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null;\",\"也就是说 ThreadLocalMap 的引用是作为 Thread 的一个成员变量，被 Thread 进行维护的。回过头再来看看 set 方法，当 map 为 null 的时候会通过 createMap(t，value) 方法：\",\"void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); }\",\"该方法就是 new 一个 ThreadLocalMap 实例对象，然后同样以当前 threadLocal 实例作为 key，值为 value 存放到 threadLocalMap 中，然后将当前线程对象的 threadLocals 赋值为 threadLocalMap。\",\"现在来对 set 方法进行总结一下：\",\"通过当前线程对象 thread 获取该 thread 所维护的 threadLocalMap，若 threadLocalMap 不为 null，则以 threadLocal 实例为 key，值为 value 的键值对存入 threadLocalMap；\",\"若 threadLocalMap 为 null 的话，就新建 threadLocalMap 然后在以 threadLocal 为 key，值为 value 的键值对存入。\"]},\"1302\":{\"h\":\"2.2 get 方法\",\"t\":[\"get 方法是获取当前线程中 threadLocal 变量的值，同样的还是来看看源码：\",\"public T get() { // 1. 获取当前线程的实例对象 Thread t = Thread.currentThread(); // 2. 获取当前线程的threadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { // 3. 获取map中当前threadLocal实例为key的值的entry ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\\\"unchecked\\\") // 4. 当前entitiy不为null的话，就返回相应的值value T result = (T)e.value; return result; } } // 5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value return setInitialValue(); }\",\"弄懂了 set 方法的逻辑，看 get 方法只需要带着逆向思维去看就好，如果是那样存的，反过来去拿就好。\",\"代码逻辑请看注释，另外，看下 setInitialValue 主要做了些什么事情？\",\"private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; }\",\"这段方法的逻辑和 set 方法几乎一致，另外值得关注的是 initialValue 方法:\",\"protected T initialValue() { return null; }\",\"这个方法是 protected 修饰的也就是说继承 ThreadLocal 的子类可重写该方法，实现赋值为其他的初始值。\",\"关于 get 方法来总结一下：\",\"通过当前线程 thread 实例获取到它所维护的 threadLocalMap，然后以当前 threadLocal 实例为 key 获取该 map 中的键值对（Entry），若 Entry 不为 null 则返回 Entry 的 value；\",\"如果获取 threadLocalMap 为 null 或者 Entry 为 null 的话，就以当前 threadLocal 为 Key，value 为 null 存入 map 后，并返回 null。\"]},\"1303\":{\"h\":\"2.3 remove 方法\",\"t\":[\"public void remove() { // 1. 获取当前线程的threadLocalMap ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) // 2. 从map中删除以当前threadLocal实例为key的键值对 m.remove(this); }\",\"get，set 方法实现了存数据和读数据，我们还得看下如何删数据。\",\"删除数据是从 map 中删除数据，先获取与当前线程相关联的 threadLocalMap 然后从 map 中删除该 threadLocal 实例为 key 的键值对即可。\"]},\"1304\":{\"h\":\"3. ThreadLocalMap 详解\",\"t\":[\"从上面的分析我们已经知道，数据其实都放在了 threadLocalMap 中，threadLocal 的 get，set 和 remove 方法实际上具体是通过 threadLocalMap 的 getEntry，set 和 remove 方法实现的。如果想真正全方位的弄懂 threadLocal，势必得再对 threadLocalMap 做一番理解。\"]},\"1305\":{\"h\":\"3.1 Entry 数据结构\",\"t\":[\"ThreadLocalMap 是 threadLocal 一个静态内部类，和大多数容器一样内部维护了一个数组，同样的 threadLocalMap 内部维护了一个 Entry 类型的 table 数组。\",\"/** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table;\",\"通过注释可以看出，table 数组的长度为 2 的幂次方。\",\"接下来看下 Entry 是什么：\",\"static class Entry extends WeakReference<ThreadLocal<?>> { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal<?> k, Object v) { super(k); value = v; } }\",\"Entry 是一个以 ThreadLocal 为 key，Object 为 value 的键值对，另外需要注意的是这里的 threadLocal 是弱引用，因为 Entry 继承了 WeakReference，在 Entry 的构造方法中，调用了 super(k) 方法就会将 threadLocal 实例包装成一个 WeakReferenece。\",\"用下图来理解下 thread，threadLocal，threadLocalMap，Entry 之间的关系：\",\"ThreadLocal各引用间的关系\",\"注意上图中的实线表示强引用，虚线表示弱引用。如图所示，每个线程实例中可以通过 threadLocals 获取到 threadLocalMap，而 threadLocalMap 实际上就是一个以 threadLocal 实例为 key，任意对象为 value 的 Entry 数组。当我们为 threadLocal 变量赋值，实际上就是以当前 threadLocal 实例为 key，值为 value 的 Entry 往这个 threadLocalMap 中存放。\",\"需要注意的是 Entry 中的 key 是弱引用，当 threadLocal 外部强引用被置为 null（threadLocalInstance = null），那么系统 GC 的时候，根据可达性分析，这个 threadLocal 实例就没有任何一条链路能够引用到它，这个 ThreadLocal 势必会被回收，这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value。如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value 永远无法回收，造成内存泄漏。\",\"当然，如果当前 thread 运行结束，threadLocal，threadLocalMap，Entry 没有引用链可达，在垃圾回收的时候都会被系统进行回收。在实际开发中，会使用线程池去维护线程的创建和复用，比如固定大小的线程池，线程为了复用是不会主动结束的，所以，threadLocal 的内存泄漏问题，是应该值得我们思考和注意的问题，关于这个问题可以看这篇文章 —— 详解 threadLocal 内存泄漏问题。\"]},\"1306\":{\"h\":\"3.2 set 方法\",\"t\":[\"与 concurrentHashMap，hashMap 等容器一样，threadLocalMap 也是采用散列表进行实现的。在了解 set 方法前，我们先来回顾下关于散列表相关的知识（摘自 这篇的 threadLocalMap 部分 以及 这篇文章的 hash）。\",\"散列表：\",\"理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。如下图：\",\"理想散列表的示意图\",\"在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式：分离链表法（separate chaining）和 开放寻址法（open addressing）。\",\"分离链表法：\",\"分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素，典型实现为 hashMap，concurrentHashMap 的拉链法。下面是一个示意图：\",\"分离链表法示意图\",\"开放寻址法：\",\"开放寻址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 —— 线性探测法。\",\"线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示：\",\"开放寻址法示意图\",\"关于两种方式的比较，网上有很多，请自行查阅。\",\"ThreadLocalMap 中使用开放寻址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。\",\"在了解这些相关知识后我们再回过头来看一下 set 方法。set 方法的源码为：\",\"private void set(ThreadLocal<?> key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 根据threadLocal的hashCode确定Entry应该存放的位置 int i = key.threadLocalHashCode & (len-1); // 采用开放寻址法，hash冲突的时候使用线性探测 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal<?> k = e.get(); // 覆盖旧Entry if (k == key) { e.value = value; return; } // 当key为null时，说明threadLocal强引用已经被释放掉，那么就无法 // 再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性 if (k == null) { // 用当前插入的值替换掉这个key为null的“脏”entry replaceStaleEntry(key, value, i); return; } } // 新建entry并插入table中i处 tab[i] = new Entry(key, value); int sz = ++size; // 插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容 if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); }\",\"set 方法的关键部分请看上面的注释，主要有这样几点需要注意：\",\"1. threadLocal 的 hashcode？\",\"private final int threadLocalHashCode = nextHashCode(); private static final int HASH_INCREMENT = 0x61c88647; private static AtomicInteger nextHashCode =new AtomicInteger(); /** * Returns the next hash code. */ private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); }\",\"从源码中我们可以清楚的看到 threadLocal 实例的 hashCode 是通过 nextHashCode() 方法实现的，该方法实际上总是用一个 AtomicInteger 加上 0x61c88647 来实现的。\",\"0x61c88647 这个数是有特殊意义的，它能够保证 hash 表的每个散列桶能够均匀的分布，这是 Fibonacci Hashing，关于更多介绍可以看 这篇文章的 threadLocal 散列值部分。也正是能够均匀分布，所以 threadLocal 选择使用开放寻址法来解决 hash 冲突的问题。\",\"2. 怎样确定新值插入到哈希表中的位置？\",\"该操作源码为：key.threadLocalHashCode & (len-1)，同 hashMap 和 ConcurrentHashMap 等容器的方式一样，利用当前 key（即 threadLocal 实例）的 hashcode 与哈希表大小相与，因为哈希表大小总是为 2 的幂次方，所以相与等同于一个取模的过程，这样就可以通过 Key 分配到具体的哈希桶中去。而至于为什么取模要通过位与运算的原因就是位运算的执行效率远远高于了取模运算。\",\"3. 怎样解决 hash 冲突？\",\"源码中通过 nextIndex(i, len) 方法解决 hash 冲突的问题，该方法为 ((i + 1 < len) ? i + 1 : 0);，也就是不断往后线性探测，当到哈希表末尾的时候再从 0 开始，成环形。\",\"4. 怎样解决 “脏” Entry？\",\"在分析 threadLocal，threadLocalMap 以及 Entry 的关系的时候，我们已经知道使用 threadLocal 有可能存在内存泄漏（对象创建出来后，在之后的逻辑一直没有使用该对象，但是垃圾回收器无法回收这个部分的内存），在源码中针对这种 key 为 null 的 Entry 称之为 “stale entry”，直译为不新鲜的 entry，我把它理解为 “脏entry”。\",\"自然而然，JoshBlochandDougLea 大师考虑到了这种情况，在 set 方法的 for 循环中寻找和当前 Key 相同的可覆盖 entry 的过程中通过 replaceStaleEntry 方法解决脏 entry 的问题。如果当前 table[i] = null 的话，直接插入新 entry 后也会通过 cleanSomeSlots 来解决脏 entry 的问题，关于 cleanSomeSlots 和 replaceStaleEntry 方法，会在 详解 threadLocal 内存泄漏 中讲到。\",\"5. 如何进行扩容？\",\"threshold 的确定\",\"也几乎和大多数容器一样，threadLocalMap 会有扩容机制，那么它的 threshold 又是怎样确定的呢？\",\"private int threshold; // Default to 0 /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } /** * Set the resize threshold to maintain at worst a 2/3 load factor. */ private void setThreshold(int len) { threshold = len * 2 / 3; }\",\"根据源码可知，在第一次为 threadLocal 进行赋值的时候会创建初始大小为 16 的 threadLocalMap，并且通过 setThreshold 方法设置 threshold，其值为 当前哈希数组长度 × 32​，也就是说加载因子为 32​。\",\"加载因子\",\"加载因子是衡量哈希表密集程度的一个参数。\",\"加载因子越大，说明哈希表被装载的越多，出现 hash 冲突的可能性越大；反之，则被装载的越少，出现 hash 冲突的可能性越小。\",\"同时如果过小，很显然内存使用率不高，该值取值应该考虑到内存使用率和 hash 冲突概率的一个平衡，如 hashMap，concurrentHashMap 的加载因子都为 0.75。\",\"这里 threadLocalMap 初始大小为 16，加载因子为 32​，所以哈希表可用大小为：16∗32​=10，即可用容量为 10。\",\"扩容 resize\",\"从 set 方法中可以看出当 hash 表的 size 大于 threshold 的时候，会通过 resize 方法进行扩容。\",\"/** * Double the capacity of the table. */ private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; // 新数组为原数组的2倍 int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j < oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal<?> k = e.get(); // 遍历过程中如果遇到脏entry的话直接令value为null，有助于value能够被回收 if (k == null) { e.value = null; // Help the GC } else { // 重新确定entry在新数组的位置，然后进行插入 int h = k.threadLocalHashCode & (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; } } } // 设置新哈希表的threshHold和size属性 setThreshold(newLen); size = count; table = newTab; }\",\"方法逻辑请看注释，新建一个大小为原来数组长度的两倍的数组，然后遍历旧数组中的 entry 并将其插入到新的 hash 数组中。需要注意的是，在扩容的过程中针对脏 entry 的话会令 value 为 null，以便能够被垃圾回收器回收，解决隐藏的内存泄漏的问题。\"]},\"1307\":{\"h\":\"3.3 getEntry 方法\",\"t\":[\"getEntry 方法源码为：\",\"private Entry getEntry(ThreadLocal<?> key) { // 1. 确定在散列数组中的位置 int i = key.threadLocalHashCode & (table.length - 1); // 2. 根据索引i获取entry Entry e = table[i]; // 3. 满足条件则返回该entry if (e != null && e.get() == key) return e; else // 4. 未查找到满足条件的entry，额外在做的处理 return getEntryAfterMiss(key, i, e); }\",\"方法逻辑很简单，若能当前定位的 entry 的 key 和查找的 key 相同的话就直接返回这个 entry，否则的话就是在 set 的时候存在 hash 冲突的情况，需要通过 getEntryAfterMiss 做进一步处理。\",\"getEntryAfterMiss 方法为：\",\"private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal<?> k = e.get(); if (k == key) // 找到和查询的key相同的entry则返回 return e; if (k == null) // 解决脏entry的问题 expungeStaleEntry(i); else // 继续向后环形查找 i = nextIndex(i, len); e = tab[i]; } return null; }\",\"这个方法同样很好理解，通过 nextIndex 往后环形查找，如果找到和查询的 key 相同的 entry 的话就直接返回，如果在查找过程中遇到脏 entry 的话使用 expungeStaleEntry 方法进行处理。\",\"到目前为止，为了解决潜在的内存泄漏的问题，在 set，resize，getEntry 这些地方都会对脏 entry 进行处理，可见为了尽可能解决这个问题几乎无时无刻都在做出努力。\"]},\"1308\":{\"h\":\"3.4 remove 方法\",\"t\":[\"/** * Remove the entry for key. */ private void remove(ThreadLocal<?> key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len - 1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { // 将entry的key置为null e.clear(); // 将该entry的value也置为null expungeStaleEntry(i); return; } } }\",\"该方法逻辑很简单，通过往后环形查找到与指定 key 相同的 entry 后，先通过 clear 方法将 key 置为 null 后，使其转换为一个脏 entry，然后调用 expungeStaleEntry 方法将其 value 置为 null，以便垃圾回收时能够清理，同时将 table[i] 置为 null。\"]},\"1309\":{\"h\":\"4. ThreadLocal 的使用场景\",\"t\":[\"ThreadLocal 不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个 thread 实例引用的 threadLocalMap，也就是说每个不同的线程都拥有专属于自己的数据容器（threadLocalMap），彼此不影响。\",\"因此 threadLocal 只适用于 共享对象会造成线程安全 的业务场景。比如 hibernate 中通过 threadLocal 管理 Session 就是一个典型的案例，不同的请求线程（用户）拥有自己的 session，若将 session 共享出去被多线程访问，必然会带来线程安全问题。\",\"下面，我们自己来写一个例子，SimpleDateFormat.parse 方法会有线程安全的问题，我们可以尝试使用 threadLocal 包装 SimpleDateFormat，将该实例不被多线程共享即可。\",\"public class ThreadLocalDemo { private static ThreadLocal<SimpleDateFormat> sdf = new ThreadLocal<>(); public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); for (int i = 0; i < 100; i++) { executorService.submit(new DateUtil(\\\"2019-11-25 09:00:\\\" + i % 60)); } } static class DateUtil implements Runnable { private String date; public DateUtil(String date) { this.date = date; } @Override public void run() { if (sdf.get() == null) { sdf.set(new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\")); } else { try { Date date = sdf.get().parse(this.date); System.out.println(date); } catch (ParseException e) { e.printStackTrace(); } } } } }\",\"如果当前线程不持有 SimpleDateformat 对象实例，那么就新建一个并把它设置到当前线程中，如果已经持有，就直接使用。另外，从 if (sdf.get() == null){....}else{.....} 可以看出为每一个线程分配一个 SimpleDateformat 对象实例是从应用层面（业务代码逻辑）去保证的。\",\"在上面我们说过 threadLocal 有可能存在内存泄漏，在使用完之后，最好使用 remove 方法将这个变量移除，就像在使用数据库连接一样，及时关闭连接。\"]},\"1310\":{\"c\":[\"并发编程\"]},\"1311\":{\"c\":[\"JUC\"]},\"1312\":{\"h\":\"从源码深入详解 ThreadLocal 内存泄漏问题\"},\"1313\":{\"h\":\"1. 造成内存泄露的原因？\",\"t\":[\"threadLocal 是为了解决对象不能被多线程共享访问的问题，通过 threadLocal.set 方法将对象实例保存在每个线程自己所拥有的 threadLocalMap 中，这样每个线程使用自己的对象实例，彼此不会影响达到隔离的作用，从而就解决了对象在被共享访问带来线程安全问题。\",\"如果将同步机制和 threadLocal 做一个横向比较的话，同步机制就是通过控制线程访问共享对象的顺序，而 threadLocal 就是为每一个线程分配一个该对象，各用各的互不影响。\",\"打个比方说，现在有 100 个同学需要填写一张表格但是只有一支笔，同步就相当于 A 使用完这支笔后给 B，B 使用后给 C 用......老师就控制着这支笔的使用顺序，使得同学之间不会产生冲突。而 threadLocal 就相当于，老师直接准备了 100 支笔，这样每个同学都使用自己的，同学之间就不会产生冲突。\",\"很显然这就是两种不同的思路，同步机制以 “时间换空间”，由于每个线程在同一时刻共享对象只能被一个线程访问造成整体上响应时间增加，但是对象只占有一份内存，牺牲了时间效率换来了空间效率即 “时间换空间”。而 threadLocal，为每个线程都分配了一份对象，自然而然内存使用率增加，每个线程各用各的，整体上时间效率要增加很多，牺牲了空间效率换来时间效率即 “空间换时间”。\",\"关于 threadLocal，threadLocalMap 更多的细节可以看 上一篇文章，给出了很详细的各个方面的知识。threadLocal，threadLocalMap，entry 之间的关系如下图所示：\",\"ThreadLocal 各引用间的关系\",\"上图中，实线代表强引用，虚线代表的是弱引用，如果 threadLocal 外部强引用被置为 null（threadLocalInstance = null）的话，threadLocal 实例就没有一条引用链路可达，很显然在 GC（垃圾回收）的时候势必会被回收，因此 entry 就存在 key 为 null 的情况，无法通过一个 Key 为 null 去访问到该 entry 的 value。\",\"同时，就存在了这样一条引用链：threadRef -> currentThread -> threadLocalMap -> entry -> valueRef -> valueMemory，导致在垃圾回收的时候进行可达性分析的时候，value 可达从而不会被回收掉，但是该 value 永远不能被访问到，这样就存在了内存泄漏。\",\"当然，如果线程执行结束后，threadLocal，threadRef会断掉，因此 threadLocal，threadLocalMap，entry 都会被回收掉。可是，在实际使用中我们都是会用线程池去维护我们的线程，比如在 Executors.newFixedThreadPool() 时创建线程的时候，为了复用线程是不会结束的，所以 threadLocal 内存泄漏就值得我们关注。\"]},\"1314\":{\"h\":\"2. 已经做出了哪些改进？\",\"t\":[\"实际上，为了解决 threadLocal 潜在的内存泄漏的问题，JoshBlochandDougLea 大师已经做了一些改进。在 threadLocal 的 set 和 get 方法中都有相应的处理。\",\"下文为了叙述，针对 key 为 null 的 entry，源码注释为 stale entry，直译为不新鲜的 entry，这里我就称之为 “脏 entry”。比如在 ThreadLocalMap 的 set 方法中：\",\"private void set(ThreadLocal<?> key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal<?> k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); }\",\"在该方法中针对脏 entry 做了这样的处理：\",\"如果当前 table[i] != null，说明 hash 冲突就需要向后环形查找，若在查找过程中遇到脏 entry 就通过 replaceStaleEntry 进行处理。\",\"如果当前 table[i] == null，说明新的 entry 可以直接插入，但是插入后会调用 cleanSomeSlots 方法检测并清除脏 entry。\"]},\"1315\":{\"h\":\"2.1 cleanSomeSlots\",\"t\":[\"该方法的源码为：\",\"/* @param i a position known NOT to hold a stale entry. The * scan starts at the element after i. * * @param n scan control: {@code log2(n)} cells are scanned, * unless a stale entry is found, in which case * {@code log2(table.length)-1} additional cells are scanned. * When called from insertions, this parameter is the number * of elements, but when from replaceStaleEntry, it is the * table length. (Note: all this could be changed to be either * more or less aggressive by weighting n instead of just * using straight log n. But this version is simple, fast, and * seems to work well.) * * @return true if any stale entries have been removed. */ private boolean cleanSomeSlots(int i, int n) { boolean removed = false; Entry[] tab = table; int len = tab.length; do { i = nextIndex(i, len); Entry e = tab[i]; if (e != null && e.get() == null) { n = len; removed = true; i = expungeStaleEntry(i); } } while ( (n >>>= 1) != 0); return removed; }\",\"入参：\",\"i 表示：插入 entry 的位置 i，很显然在上述情况 2（table[i] == null）中，entry 刚插入后该位置 i 很显然不是脏 entry。\",\"参数 n\",\"n 的用途\",\"主要用于扫描控制（scan control），while 中通过 n 来进行条件判断，说明 n 就是用来控制扫描趟数（循环次数）的。\",\"在扫描过程中，如果没有遇到脏 entry 就整个扫描过程持续 log2​(n) 次，log2​(n) 的得来是因为 n >>>= 1，每次 n 右移一位相当于 n/2。如果在扫描过程中遇到脏 entry 的话就会令 n 为当前 hash 表的长度（n = len），再扫描 log2​(n) 趟，注意此时 n 增加无非就是多增加了循环次数，从而通过 nextIndex 使得往后搜索的范围扩大，示意图如下：\",\"cleanSomeSlots 示意图\",\"按照 n 的初始值，搜索范围为黑线，当遇到了脏 entry，此时 n 变成了哈希数组的长度（n 取值增大），搜索范围 log2​(n) 增大。红线表示，如果在整个搜索过程没遇到脏 entry 的话，搜索结束。\",\"采用这种方式主要是用于时间效率上的平衡。\",\"n 的取值\",\"如果是在 set 方法插入新的 entry 后调用（上述情况 2），n 位当前已经插入的 entry 个数 size；如果是在 replaceSateleEntry 方法中调用，n 为哈希表的长度 len。\"]},\"1316\":{\"h\":\"2.2 expungeStaleEntry\",\"t\":[\"如果对输入参数能够理解的话，那么 cleanSomeSlots 方法搜索基本上清楚了，但是全部搞定还需要掌握 expungeStaleEntry 方法，当在搜索过程中遇到了脏 entry 的话会调用该方法去清理掉脏 entry。\",\"源码为：\",\"/** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). */ private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // 1. 清除当前脏entry // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; // 2. 往后环形继续查找，直到遇到table[i]==null时结束 for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal<?> k = e.get(); // 3. 如果在向后搜索过程中再次遇到脏entry，同样将其清理掉 if (k == null) { e.value = null; tab[i] = null; size--; } else { // 处理rehash的情况 int h = k.threadLocalHashCode & (len - 1); if (h != i) { tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; } } } return i; }\",\"该方法逻辑请看注释（第 1,2,3 步），主要做了这么几件事情：\",\"清理当前脏 entry，即将其 value 引用置为 null，并且将 table[staleSlot] 也置为 null。value 置为 null 后该 value 域变为不可达，在下一次 GC 的时候就会被回收掉，同时 table[staleSlot] = null 后以便于存放新的 entry。\",\"从当前 staleSlot 位置向后环形（nextIndex）继续搜索，直到遇到哈希桶（tab[i]）为 null 的时候退出。\",\"若在搜索过程再次遇到脏 entry，继续将其清除。\",\"也就是说该方法，清理掉当前脏 entry 后，并没有闲下来，而是继续向后搜索，若再次遇到脏 entry 继续将其清理，直到哈希桶（table[i]）为 null 时退出。\",\"因此方法执行完的结果为 从当前脏 entry（staleSlot）位到返回的 i 位，这中间所有的 entry 不是脏 entry。\",\"为什么是遇到 null 退出呢？\",\"原因是存在脏 entry 的前提条件是 当前哈希桶（table[i]）不为 null，只是该 entry 的 key 域为 null。如果遇到哈希桶为 null，很显然它连成为脏 entry 的前提条件都不具备。\",\"现在对 cleanSomeSlot 方法做一下总结，其方法执行示意图如下：\",\"cleanSomeSlots 示意图\",\"如图所示，cleanSomeSlot 方法主要有这样几点：\",\"从当前位置 i 处（位于 i 处的 entry 一定不是脏 entry）为起点在初始小范围（log2​(n)，n 为哈希表已插入 entry 的个数 size）开始向后搜索脏 entry，若在整个搜索过程没有脏 entry，方法结束退出。\",\"如果在搜索过程中遇到脏 entry，则通过 expungeStaleEntry 方法清理掉当前脏 entry，并且该方法会返回下一个哈希桶（table[i]）为 null 的索引位置为 i。这时重新令搜索起点为索引位置 i，n 为哈希表的长度 len，再次扩大搜索范围为 log2​(n) 继续搜索。\",\"下面，以一个例子更清晰的来说一下，假设当前 table 数组的情况如下图：\",\"cleanSomeSlots 执行情景图\",\"如图当前 n 等于 hash 表的 size 即 n=10，i=1，在第一趟搜索过程中通过 nextIndex，i 指向了索引为 2 的位置，此时 table[2] 为 null，说明第一趟未发现脏 entry，则第一趟结束进行第二趟的搜索。\",\"第二趟所搜先通过 nextIndex 方法，索引由 2 的位置变成了 i=3，当前 table[3] != null 但是该 entry 的 key 为 null，说明找到了一个脏 entry，先将 n 置为哈希表的长度 len，然后继续调用 expungeStaleEntry 方法，该方法会将当前索引为 3 的脏 entry给清除掉（令 value 为 null，并且 table[3] = null）。\",\"但是该方法并不会停下，它会继续往后环形搜索，往后会发现索引为 4,5 的位置的 entry 同样为脏 entry，索引为 6 的位置的 entry 不是脏 entry 保持不变，直至 i=7 的时候此处 table[7] = null，该方法就以 i=7 返回。至此，第二趟搜索结束。\",\"由于在第二趟搜索中发现脏 entry，n 增大为数组的长度 len，因此扩大搜索范围（增大循环次数）继续向后环形搜索。\",\"直到在整个搜索范围里都未发现脏 entry，cleanSomeSlot 方法执行结束退出。\"]},\"1317\":{\"h\":\"2.3 replaceStaleEntry\",\"t\":[\"先来看 replaceStaleEntry 方法，该方法源码为：\",\"/* * @param key the key * @param value the value to be associated with key * @param staleSlot index of the first stale entry encountered while * searching for key. */ private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). // 向前找到第一个脏entry int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // [23] // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal<?> k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) { // 如果在向后环形查找过程中发现key相同的entry就覆盖并且和脏entry进行交换 e.value = value; // [40] tab[i] = tab[staleSlot]; // [41] tab[staleSlot] = e; // [42] // Start expunge at preceding stale entry if it exists // 如果在查找过程中还未发现脏entry，那么就以当前位置作为cleanSomeSlots的起点 if (slotToExpunge == staleSlot) slotToExpunge = i; // [47] // 搜索脏entry并进行清理 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); // [48] return; } // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. // 如果向前未搜索到脏entry，则在查找过程遇到脏entry的话，后面就以此时这个位置 // 作为起点执行cleanSomeSlots if (k == null && slotToExpunge == staleSlot) slotToExpunge = i; // [59] } // If key not found, put new entry in stale slot // 如果在查找过程中没有找到可以覆盖的entry，则将新的entry插入在脏entry tab[staleSlot].value = null; // [64] tab[staleSlot] = new Entry(key, value); // [65] // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) // [68] // 执行cleanSomeSlots cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); // [70] }\",\"该方法的逻辑请看注释，下面我结合各种情况详细说一下该方法的执行过程。首先先看这一部分的代码：\",\"int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i;\",\"这部分代码通过 preIndex 方法实现往前环形搜索脏 entry 的功能，初始时 slotToExpunge 和 staleSlot 相同，若在搜索过程中发现了脏 entry，则更新 slotToExpunge 为当前索引 i。\",\"另外，说明 replaceStaleEntry 并不仅仅局限于处理当前已知的脏 entry，它认为在出现脏 entry 的相邻位置也有很大概率出现脏 entry，所以为了一次处理到位，就需要向前环形搜索，找到前面的脏 entry。\",\"那么根据在向前搜索中是否还有脏 entry 以及在 for 循环后向环形查找中是否找到可覆盖的 entry，我们分这四种情况来充分理解这个方法：\",\"前向有脏 entry\",\"1.1 后向环形查找找到可覆盖的 entry\",\"该情形如下图所示：\",\"向前环形搜索到脏 entry，向后环形查找到可覆盖的 entry\",\"如图，slotToExpunge 初始状态和 staleSlot 相同，当前向环形搜索遇到脏 entry 时，在第 23 行代码中 slotToExpunge 会更新为当前脏 entry 的索引 i，直到遇到哈希桶（table[i]）为 null 的时候，前向搜索过程结束。\",\"在接下来的 for 循环中进行后向环形查找，若查找到了可覆盖的 entry，第 40,41,42 行代码先覆盖当前位置的 entry，然后再与 staleSlot 位置上的脏 entry 进行交换。交换之后脏 entry 就更换到了 i 处，最后使用 cleanSomeSlots 方法从 slotToExpunge 为起点开始进行清理脏 entry 的过程。\",\"1.2 后向环形查找未找到可覆盖的 entry\",\"该情形如下图所示：\",\"前向环形搜索到脏 entry，向后环形未搜索可覆盖 entry\",\"如图，slotToExpunge 初始状态和 staleSlot 相同，当前向环形搜索遇到脏 entry 时，在第 23 行代码中 slotToExpunge 会更新为当前脏 entry 的索引 i，直到遇到哈希桶（table[i]）为 null 的时候，前向搜索过程结束。\",\"在接下来的 for 循环中进行后向环形查找，若没有查找到了可覆盖的 entry，哈希桶（table[i] ）为 null 的时候，后向环形查找过程结束。那么接下来在 64,65 行代码中，将插入的新 entry 直接放在 staleSlot 处即可，最后使用 cleanSomeSlots 方法从 slotToExpunge 为起点开始进行清理脏 entry 的过程。\",\"前向没有脏 entry\",\"2.1 后向环形查找找到可覆盖的 entry\",\"该情形如下图所示：\",\"前向环形未搜索到脏 entry，后向环形搜索到可覆盖的 entry\",\"如图，slotToExpunge 初始状态和 staleSlot 相同，当前向环形搜索直到遇到哈希桶（table[i]）为 null 的时候，前向搜索过程结束，若在整个过程未遇到脏 entry，slotToExpunge 初始状态依旧和 staleSlot 相同。\",\"在接下来的 for 循环中进行后向环形查找，若遇到了脏 entry，在第 59 行代码中更新 slotToExpunge 为位置 i。若查找到了可覆盖的 entry，第 40,41,42 行代码先覆盖当前位置的 entry，然后再与 staleSlot 位置上的脏 entry 进行交换，交换之后脏 entry 就更换到了 i 处。如果在整个查找过程中都还没有遇到脏 entry 的话，会通过第 47 行代码，将 slotToExpunge 更新当前 i 处，最后使用 cleanSomeSlots 方法从 slotToExpunge 为起点开始进行清理脏 entry 的过程。\",\"2.2 后向环形查找未找到可覆盖的 entry\",\"该情形如下图所示：\",\"前向环形未搜索到脏 entry，后向环形查找未查找到可覆盖的 entry\",\"如图，slotToExpunge 初始状态和 staleSlot 相同，当前向环形搜索直到遇到哈希桶（table[i]）为 null 的时候，前向搜索过程结束，若在整个过程未遇到脏 entry，slotToExpunge 初始状态依旧和 staleSlot 相同。\",\"在接下来的 for 循环中进行后向环形查找，若遇到了脏 entry，在第 59 行代码中更新 slotToExpunge 为位置 i。若没有查找到了可覆盖的 entry，哈希桶（table[i]）为 null 的时候，后向环形查找过程结束。那么接下来在 64,65 行代码中，将插入的新 entry 直接放在 staleSlot 处即可。另外，如果发现 slotToExpunge 被重置，则第 68 行代码 if 判断为 true，就使用 cleanSomeSlots 方法从 slotToExpunge 为起点开始进行清理脏 entry 的过程。\",\"下面用一个实例来有个直观的感受，示例代码就不给出了，代码 debug 时 table 状态如下图所示：\",\"1.2 情况示意图\",\"如图所示，当前的 staleSolt 为 i=4，首先先进行前向搜索脏 entry，当 i=3 的时候遇到脏 entry，slotToExpung 更新为 3，当 i=2 的时候 tabel[2] = null，因此前向搜索脏 entry 的过程结束。\",\"然后进行后向环形查找，直到 i=7 的时候遇到 table[7] = null，结束后向查找过程，并且在该过程并没有找到可以覆盖的 entry。最后只能在 staleSlot(4) 处插入新 entry，然后从 slotToExpunge(3) 为起点进行 cleanSomeSlots 进行脏 entry 的清理（同上面的 1.2 情况）。\",\"这些核心方法，通过源码以及示例图，最终都应能掌握。\",\"当我们调用 threadLocal 的 get 方法时，如果 table[i] 不是和所要找的 key 相同，会继续通过 threadLocalMap 的 getEntryAfterMiss 方法向后环形去找，该方法为：\",\"private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal<?> k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; }\",\"当 key == null 的时候，即遇到脏 entry 也会调用 expungeStleEntry 对脏 entry 进行清理。\",\"当我们调用 threadLocal.remove 方法的时候，实际上会调用 threadLocalMap 的 remove 方法，该方法的源码为：\",\"private void remove(ThreadLocal<?> key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } }\",\"同样的可以看出，当遇到了 key 为 null 的脏 entry 的时候，也会调用 expungeStaleEntry 清理掉脏 entry。\",\"从以上 set，getEntry，remove 方法看出，在 threadLocal 的生命周期里，针对 threadLocal 存在的内存泄漏的问题，都会通过 expungeStaleEntry，cleanSomeSlots，replaceStaleEntry 这三个方法清理掉 key 为 null 的脏 entry。\"]},\"1318\":{\"h\":\"2.4 为什么使用弱引用？\",\"t\":[\"从文章开头通过 threadLocal，threadLocalMap，entry 的引用关系看起来 threadLocal 存在内存泄漏的问题似乎是因为 threadLocal 是被弱引用修饰的。那为什么要使用弱引用呢？\",\"如果使用强引用\",\"假设 threadLocal 使用的是强引用，在业务代码中执行 threadLocalInstance == null操作，实现清理掉 threadLocal 实例的目的。\",\"但是因为 threadLocalMap 的 Entry 强引用 threadLocal，因此在 GC 的时候进行可达性分析，threadLocal 依然可达，对 threadLocal 并不会进行垃圾回收，这样就无法真正达到业务逻辑的目的，出现逻辑错误。\",\"如果使用弱引用\",\"假设 Entry 弱引用 threadLocal，尽管会出现内存泄漏的问题，但是在 threadLocal 的生命周期（set，getEntry，remove）里，都会针对 key 为 null 的脏 entry 进行处理。\",\"从以上的分析可以看出，使用弱引用的话在 threadLocal 生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。\"]},\"1319\":{\"h\":\"2.5 Thread.exit()\",\"t\":[\"当线程退出时会执行 exit 方法：\",\"private void exit() { if (group != null) { group.threadTerminated(this); group = null; } /* Aggressively null out all reference fields: see bug 4006245 */ target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; }\",\"从源码可以看出当线程结束时，会令 threadLocals = null，也就意味着 GC 的时候就可以将 threadLocalMap 进行垃圾回收，换句话说 threadLocalMap 生命周期实际上和 thread 的生命周期相同。\"]},\"1320\":{\"h\":\"3. threadLocal 最佳实践\",\"t\":[\"通过这篇文章对 threadLocal 的内存泄漏做了很详细的分析，我们可以完全理解 threadLocal 内存泄漏的前因后果，那么实践中我们应该怎么做？\",\"每次使用完 ThreadLocal，都调用它的 remove() 方法，清除数据。\",\"在使用线程池的情况下，没有及时清理 ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用 ThreadLocal 就跟加锁完要解锁一样，用完就清理。\"]},\"1321\":{\"c\":[\"并发编程\"]},\"1322\":{\"c\":[\"JUC\"]},\"1323\":{\"h\":\"并发容器之 BlockingQueue\"},\"1324\":{\"h\":\"1. BlockingQueue 简介\",\"t\":[\"在实际编程中，会经常使用到 JDK 中 Collection 集合框架中的各种容器类如实现 List，Map，Queue 接口的容器类，但是这些容器类基本上不是线程安全的，除了使用 Collections 可以将其转换为线程安全的容器，DougLea 大师为我们都准备了对应的线程安全的容器，如实现 List 接口的 CopyOnWriteArrayList，实现 Map 接口的 ConcurrentHashMap，实现 Queue 接口的 ConcurrentLinkedQueue。\",\"最常用的 “生产者-消费者” 问题中，队列通常被视作线程间操作的数据容器，这样就可以对各个模块的业务功能进行解耦，生产者将 “生产” 出来的数据放置在数据容器中，而消费者仅仅只需要在 “数据容器” 中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。\",\"阻塞队列（BlockingQueue）被广泛使用在 “生产者-消费者” 问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。\"]},\"1325\":{\"h\":\"2. 基本操作\",\"t\":[\"BlockingQueue 基本操作总结如下（此图来源于 JAVA API 文档）：\",\"BlockingQueue 基本操作\",\"BlockingQueue 继承于 Queue 接口，因此，对数据元素的基本操作有：\",\"插入元素\",\"add(E e)：往队列插入数据，当队列满时，插入元素时会抛出 IllegalStateException 异常。\",\"offer(E e)：当往队列插入数据时，插入成功返回 true，否则则返回 false。当队列满时不会抛出异常。\",\"删除元素\",\"remove(Object o)：从队列中删除数据，成功则返回 true，否则为 false。\",\"poll()：删除数据，当队列为空时，返回 null。\",\"查看元素\",\"element()：获取队头元素，如果队列为空时则抛出 NoSuchElementException 异常。\",\"peek()：获取队头元素，如果队列为空则抛出 NoSuchElementException 异常。\",\"BlockingQueue 具有的特殊操作：\",\"插入数据\",\"put(E e)：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用。\",\"offer(E e, long timeout, TimeUnit unit)：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与 put 方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出。\",\"删除数据\",\"take()：当阻塞队列为空时，获取队头数据的线程会被阻塞。\",\"poll(long timeout, TimeUnit unit)：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出。\"]},\"1326\":{\"h\":\"3. 常用的 BlockingQueue\",\"t\":[\"实现 BlockingQueue 接口的有 ArrayBlockingQueue，DelayQueue，LinkedBlockingDeque，LinkedBlockingQueue，LinkedTransferQueue，PriorityBlockingQueue，SynchronousQueue。而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：\",\"ArrayBlockingQueue\",\"ArrayBlockingQueue 是由数组实现的有界阻塞队列。该队列命令元素 FIFO（先进先出）。因此，队头元素是队列中存在时间最长的数据元素，而队尾数据则是当前队列最新的数据元素。\",\"ArrayBlockingQueue 可作为 “有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。\",\"ArrayBlockingQueue 一旦创建，容量不能改变。\",\"当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。\",\"ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，一旦 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：\",\"private static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true);\",\"关于 ArrayBlockingQueue 的实现原理，在下一篇文章。\",\"LinkedBlockingQueue\",\"LinkedBlockingQueue 是用链表实现的有界阻塞队列，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量。\",\"为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存，通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。\",\"PriorityBlockingQueue\",\"PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。\",\"默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。\",\"SynchronousQueue\",\"SynchronousQueue 每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue 实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。\",\"SynchronousQueue 也可以通过构造器参数来为其指定公平性。\",\"LinkedTransferQueue\",\"LinkedTransferQueue 是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了 TransferQueue 接口，与其他阻塞队列相比主要有以下不同的方法：\",\"transfer(E e)：如果当前有线程（消费者）正在调用 take() 方法或者可延时的 poll() 方法在消费数据，生产者线程可以调用 transfer 方法将数据传递给消费者线程。如果当前没有消费者线程，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出。\",\"tryTransfer(E e)：如果当前有线程（消费者）正在调用 take() 方法或者具有超时特性的 poll() 方法在消费数据，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据，就立即返回 false。\",\"因此，与 transfer 方法相比，transfer 方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而 tryTransfer 方法能够立即返回结果退出。\",\"tryTransfer(E e,long timeout,imeUnit unit)：与 transfer 基本功能一样，只是增加了超时特性，如果数据在规定的超时时间内没有消费者进行消费的话，就返回 false。\",\"LinkedBlockingDeque\",\"LinkedBlockingDeque 是基于链表数据结构的有界阻塞双端队列，如果在创建对象时未指定大小，其默认大小为 Integer.MAX_VALUE。\",\"与 LinkedBlockingQueue 相比，主要的不同点在于 LinkedBlockingDeque 具有双端队列的特性。\",\"LinkedBlockingDeque 基本操作如下图所示（来源于 Java 文档）\",\"LinkedBlockingDeque 的基本操作\",\"如上图所示，LinkedBlockingDeque 的基本操作可以分为四种类型：\",\"特殊情况，抛出异常；\",\"特殊情况，返回特殊值，如 null 或者 false；\",\"当线程不满足操作条件时，线程会被阻塞直至条件满足；\",\"操作具有超时特性。\",\"另外，LinkedBlockingDeque 实现了 BlockingDueue 接口而 LinkedBlockingQueue 实现的是 BlockingQueue，这两个接口的主要区别如下图所示（来源于 Java 文档）：\",\"BlockingQueue 和 BlockingDeque 的区别\",\"从上图可以看出，两个接口的功能是可以等价使用的，比如 BlockingQueue 的 add 方法和 BlockingDeque 的 addLast 方法的功能是一样的。\",\"DelayQueue\",\"DelayQueue 是一个存放实现 Delayed 接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。\",\"如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过 poll 等方法获取数据元素会返回 null。\",\"所谓数据延时期满，是通过 Delayed 接口的 getDelay(TimeUnit.NANOSECONDS) 来进行判定，如果该方法返回的是小于等于 0 则说明该数据元素的延时期已满。\"]},\"1327\":{\"c\":[\"并发编程\"]},\"1328\":{\"c\":[\"JUC\"]},\"1329\":{\"h\":\"线程状态及其属性\",\"t\":[\"线程的 6 种状态:\",\"New（新建）\",\"Runable（可运行）\",\"Blocked（阻塞）\",\"Waiting（等待）\",\"Timed Waiting（计时等待）\",\"Terminates（终止）\",\"要确定一个线程的当前状态，只需要调用 getState() 方法。\"]},\"1330\":{\"h\":\"1. 新建线程\",\"t\":[\"一个 java 程序从 main() 方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上 java 程序天生就是一个多线程程序，包含了：\",\"（1）分发处理发送给给 JVM 信号的线程；\",\"（2）调用对象的 finalize 方法的线程；\",\"（3）清除 Reference 的线程；\",\"（4）main 线程，用户程序的入口。\",\"在用户程序中新建一个线程，一般有四种方式：\",\"通过继承 Thread 类，重写 run 方法；\",\"通过实现 runable 接口；\",\"通过实现 callable 接口；\",\"通过线程池创建。\",\"创建线程池Demo：\",\"public class CreateThreadDemo { public static void main(String[] args) { // 1.继承Thread Thread thread = new Thread() { @Override public void run() { System.out.println(\\\"继承Thread\\\"); super.run(); } }; thread.start(); // 2.实现runable接口 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(\\\"实现runable接口\\\"); } }); thread1.start(); // 3.实现callable接口 ExecutorService service = Executors.newSingleThreadExecutor(); Future<String> future = service.submit(new Callable() { @Override public String call() throws Exception { return \\\"通过实现Callable接口\\\"; } }); try { String result = future.get(); System.out.println(result); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } }\",\"第四种通过线程池新建线程后面单拎出来。\",\"以上三种新建线程的方式需要注意的是：\",\"由于 java 不能多继承可以实现多个接口，因此，在创建线程的时候尽量多考虑采用实现接口的形式；\",\"实现 callable 接口，提交给 ExecutorService 返回的是异步执行的结果，另外，通常也可以利用 FutureTask(Callable callable) 将 callable 进行包装然后 FeatureTask 提交给 ExecutorsService。如下图所示：\",\"另外由于 FeatureTask 也实现了 Runable 接口，也可以利用上面第二种方式（实现 Runable 接口）来新建线程；\",\"可以通过 Executors 将 Runable 转换成 Callable，具体方法是：\",\"Callable callable(Runnable task, T result); Callable callable(Runnable task);\",\"注意\",\"不要调用 Thread 类或 Runnable 对象的 run 方法。直接调用 run 方法只会在同一个线程中执行这个任务，而没有启动新的线程。\",\"实际上，应当调用 Thread.start() 方法，这会创建一个新线程来执行 run 方法。\"]},\"1331\":{\"h\":\"2. 可运行线程\",\"t\":[\"一旦调用 start 方法，线程就处于可运行状态。一个可运行的线程可能正在运行，也可能没有运行，要由操作系统为线程提供具体的运行时间。\",\"一旦一个线程开始运行，它不一定始终保持运行。事实上，运行中的线程有时需要暂停，让其他线程有机会运行。线程调度的细节依赖于操作系统提供的服务。\",\"抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完时，操作系统会剥夺该线程的运行权，并给另一个线程一个机会来运行。当选择下一个线程时，操作系统会考虑线程的优先级。\",\"所有现代桌面和服务器操作系统都是用抢占式调度。但是，对于像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 yield 方法或者像被阻塞或等待时才失去控制权。\",\"在有多个处理器的机器上，每个处理器可以运行一个线程，而且可以有多个线程并行运行。但如果线程数多于处理器的数目，调度器仍然需要分配时间片。\"]},\"1332\":{\"h\":\"3. 阻塞和等待线程\",\"t\":[\"当线程处于阻塞或等待状态时，它是暂时不活动的，不执行任何代码，且消耗最少的资源。要由线程调度器重新激活这个线程。\",\"当一个线程试图获取一个内部的对象锁，而这个锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将变成非阻塞状态。\",\"当线程等待另一个线程通知调度器出现某个条件时，这个线程会进入等待状态。\"]},\"1333\":{\"h\":\"4. 终止线程\",\"t\":[\"线程会由于以下两个原因之一而终止：\",\"由于 run 方法正常退出，线程自然终于。\",\"由于一个没有捕获到的异常终止了 run 方法，使线程意外终止。\"]},\"1334\":{\"h\":\"5. 线程状态转换\",\"t\":[\"此图来源于《JAVA并发编程的艺术》一书中，线程是会在不同的状态间进行转换的，java 线程线程转换图如上图所示。\",\"线程创建之后调用 start() 方法开始运行，当调用 wait()，join()，LockSupport.lock() 方法线程会进入到 WAITING 状态；\",\"而同样的 wait(long timeout)，sleep(long)，join(long)，LockSupport.parkNanos()，LockSupport.parkUtil() 增加了超时等待的功能，也就是调用这些方法后线程会进入 TIMED_WAITING 状态；\",\"当超时等待时间到达后，线程会切换到 Runable 的状态，另外当 WAITING 和 TIMED _WAITING 状态时可以通过 Object.notify()，Object.notifyAll() 方法使线程转换到 Runable 状态；\",\"当线程出现资源竞争时，即等待获取锁的时候，线程会进入到 BLOCKED 阻塞状态；\",\"当线程获取锁时，线程进入到 Runable 状态；\",\"线程运行结束后，线程进入到 TERMINATED 状态。\",\"状态转换可以说是线程的生命周期。另外需要注意的是：\",\"当一个线程被重新激活，调度器会先检查它是否具有比当前允许线程更高的优先级。如果是，则调度器会剥夺某个当前允许线程的运行权，选择运行该新线程。\",\"当线程进入到 synchronized 方法或者 synchronized 代码块时，线程切换到的是 BLOCKED 状态，而使用 java.util.concurrent.locks 下 lock 进行加锁的时候线程切换的是 WAITING 或者 TIMED_WAITING 状态，因为 lock 会调用 LockSupport 的方法。\",\"用一个表格将上面六种状态进行一个总结归纳。\"]},\"1335\":{\"h\":\"6. 线程的基本操作\"},\"1336\":{\"h\":\"6.1 interrupted\",\"t\":[\"中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了一个招呼。其他线程可以调用该线程的 interrupt() 方法对其进行中断操作，同时该线程可以调用 isInterrupted() 来感知其他线程对其自身的中断操作，从而做出响应。另外，同样可以调用 Thread 的静态方法 interrupted() 对当前线程进行中断操作，该方法会清除中断标志位。\",\"注意\",\"当抛出 InterruptedException 时候，会清除中断标志位，也就是说在调用 isInterrupted() 会返回 false。\",\"结合具体的实例看一看：\",\"public class InterruptDemo { public static void main(String[] args) throws InterruptedException { // sleepThread睡眠1000ms final Thread sleepThread = new Thread() { @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } super.run(); } }; // busyThread一直执行死循环 Thread busyThread = new Thread() { @Override public void run() { while (true) ; } }; sleepThread.start(); busyThread.start(); sleepThread.interrupt(); busyThread.interrupt(); while (sleepThread.isInterrupted()); System.out.println(\\\"sleepThread isInterrupted: \\\" + sleepThread.isInterrupted()); System.out.println(\\\"busyThread isInterrupted: \\\" + busyThread.isInterrupted()); } }\",\"输出结果：\",\"sleepThread isInterrupted: false busyThread isInterrupted: true\",\"开启了两个线程分别为 sleepThread 和 BusyThread，sleepThread 睡眠 1s，BusyThread 执行死循环。然后分别对着两个线程进行中断操作，可以看出 sleepThread 抛出 InterruptedException 后清除标志位，而 busyThread 就不会清除标志位。\",\"另外，同样可以通过中断的方式实现线程间的简单交互，while (sleepThread.isInterrupted()) 表示在 Main 中会持续监测 sleepThread，一旦 sleepThread 的中断标志位清零，即 sleepThread.isInterrupted() 返回为 false 时才会继续，Main 线程才会继续往下执行。因此，中断操作可以看做线程间一种简便的交互方式。\",\"一般在结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。\"]},\"1337\":{\"h\":\"6.2 join\",\"t\":[\"join 方法可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出，这就像两个好基友，一个基友先走在前面突然看见另一个基友落在后面了，这个时候他就会在原处等一等这个基友，等基友赶上来后，就两人携手并进。其实线程间的这种协作方式也符合现实生活。在软件开发的过程中，从客户那里获取需求后，需要经过需求分析师进行需求分解后，这个时候产品，开发才会继续跟进。\",\"如果一个线程实例 A 执行了 threadB.join()，其含义是：当前线程 A 会等待 threadB 线程终止后 threadA 才会继续执行。\",\"关于 join 方法一共提供如下这些方法:\",\"public final synchronized void join(long millis); public final synchronized void join(long millis, int nanos); public final void join() throws InterruptedException;\",\"Thread 类除了提供 join() 方法外，另外还提供了超时等待的方法，如果线程 threadB 在等待的时间内还没有结束的话，threadA 会在超时之后继续执行。\",\"join方法源码关键是：\",\"while (isAlive()) { wait(0); }\",\"可以看出来当前等待对象 threadA 会一直阻塞，直到被等待对象 threadB 结束后即 isAlive() 返回 false 的时候才会结束 while 循环，当 threadB 退出时会调用 notifyAll() 方法通知所有的等待线程。\",\"下面用一个具体的例子来说说 join 方法的使用：\",\"public class JoinDemo { public static void main(String[] args) { Thread previousThread = Thread.currentThread(); for (int i = 1; i <= 10; i++) { Thread curThread = new JoinThread(previousThread); curThread.start(); previousThread = curThread; } } static class JoinThread extends Thread { private Thread thread; public JoinThread(Thread thread) { this.thread = thread; } @Override public void run() { try { thread.join(); System.out.println(thread.getName() + \\\" terminated.\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }\",\"输出结果为：\",\"main terminated. Thread-0 terminated. Thread-1 terminated. Thread-2 terminated. Thread-3 terminated. Thread-4 terminated. Thread-5 terminated. Thread-6 terminated. Thread-7 terminated. Thread-8 terminated.\",\"在上面的例子中一个创建了 10 个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程......\"]},\"1338\":{\"h\":\"6.3 sleep\",\"t\":[\"public static native void sleep(long millis)\",\"这个方法显然是 Thread 的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。\",\"需要注意的是如果当前线程获得了锁，sleep 方法并不会失去锁。\",\"sleep() 方法经常拿来与 Object.wait() 方法进行比价，这也是面试经常被问的地方。\",\"sleep() VS wait()\",\"两者主要的区别：\",\"sleep() 方法是 Thread 的静态方法，而 wait() 是 Object 实例方法。\",\"wait() 方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而 sleep() 方法没有这个限制可以在任何地方种使用。另外，wait() 方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源，而 sleep() 方法只是会让出CPU并不会释放掉对象锁。\",\"sleep() 方法在休眠时间达到后如果再次获得 CPU 时间片就会继续执行，而 wait() 方法必须等待 Object.notift/Object.notifyAll 通知后，才会离开等待池，并且再次获得 CPU 时间片才会继续执行。\"]},\"1339\":{\"h\":\"6.4 yield\",\"t\":[\"public static native void yield();\",\"这是一个静态方法，一旦执行，它会使当前线程让出 CPU，但是，需要注意的是，让出的 CPU 并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了 CPU 时间片当前线程依然会继续运行。另外，让出的时间片只会分配给当前线程相同优先级的线程。\",\"什么是线程优先级呢？⬇️\",\"线程优先级\",\"现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当前时间片用完后就会发生线程调度，并等待这下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。\",\"在 Java 程序中，每个线程都有一个优先级。默认情况下，一个线程会继承构造它的那个线程的优先级。通过一个整型成员变量 Priority 来控制优先级，优先级的范围从 1 ~ 10。在构建线程的时候可以通过 setPriority(int) 方法进行设置，默认优先级为 5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同 JVM 以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。\",\"另外需要注意的是，sleep() 和 yield() 方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep() 交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而 yield() 方法只允许与当前线程具有相同优先级的线程能够获得释放出来的 CPU 时间片。\"]},\"1340\":{\"h\":\"7. 守护线程 Daemon\",\"t\":[\"守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT 线程就可以理解守护线程。\",\"与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退出。\",\"当一个 Java 应用，只有守护线程的时候，虚拟机就会自然退出。\",\"下面以一个简单的例子来表述 Daemon 线程的使用。\",\"public class DaemonDemo { public static void main(String[] args) { Thread daemonThread = new Thread(new Runnable() { @Override public void run() { while (true) { try { System.out.println(\\\"i am alive\\\"); Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\\\"finally block\\\"); } } } }); daemonThread.setDaemon(true); daemonThread.start(); //确保main线程结束前能给daemonThread能够分到时间片 try { Thread.sleep(800); } catch (InterruptedException e) { e.printStackTrace(); } } }\",\"输出结果为：\",\"i am alive finally block i am alive\",\"上面的例子中，daemodThread 的 run 方法中是一个 while 死循环，会一直打印，但是当 main 线程结束后 daemonThread 就会退出所以不会出现死循环的情况。main 线程先睡眠 800ms 保证 daemonThread 能够拥有一次时间片的机会，也就是说可以正常执行一次打印 “i am alive” 操作和一次 finally 块中 “finally block” 操作。紧接着 main 线程结束后，daemonThread 退出，这个时候只打印了 “i am alive” 并没有打印 finally 块中的语句。\",\"因此，这里需要注意的是守护线程在退出的时候并不会执行 finnaly 块中的代码，所以将释放资源等操作不要放在 finnaly 块中执行，这种操作是不安全的。\",\"线程可以通过 setDaemon(true) 的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于 start() 方法，否则会报\",\"Exception in thread \\\"main\\\" java.lang.IllegalThreadStateException at java.lang.Thread.setDaemon(Thread.java:1365) at learn.DaemonDemo.main(DaemonDemo.java:19)\",\"这样的异常，但是该线程还是会执行，只不过会当做正常的用户线程执行。\"]},\"1341\":{\"c\":[\"并发编程\"]},\"1342\":{\"c\":[\"JUC\"]},\"1343\":{\"h\":\"并发容器之 ArrayBlockingQueue 和 LinkedBlockingQueue 实现原理详解\"},\"1344\":{\"h\":\"1. ArrayBlockingQueue 简介\",\"t\":[\"在多线程编程过程中，为了业务解耦和架构设计，经常会使用并发容器用于存储多线程间的共享数据，这样不仅可以保证线程安全，还可以简化各个线程操作。例如在 “生产者-消费者” 问题中，会使用阻塞队列（BlockingQueue）作为数据容器，关于 BlockingQueue 可以看 这篇文章。\",\"为了加深对阻塞队列的理解，唯一的方式是对其实现原理进行理解，这篇文章就主要来看看 ArrayBlockingQueue 和 LinkedBlockingQueue 的实现原理。\"]},\"1345\":{\"h\":\"2. ArrayBlockingQueue 实现原理\",\"t\":[\"阻塞队列最核心的功能是，能够可阻塞式的插入和删除队列元素。\",\"当前队列为空时，会阻塞消费数据的线程，直至队列非空时，通知被阻塞的线程；当队列满时，会阻塞插入数据的线程，直至队列未满时，通知插入数据的线程（生产者线程）。\",\"多线程中消息通知机制最常用的是 Lock 的 Condition 机制。那么 ArrayBlockingQueue 的实现是不是也会采用 Condition 的通知机制呢？下面来看看。\"]},\"1346\":{\"h\":\"2.1 ArrayBlockingQueue 的主要属性\",\"t\":[\"ArrayBlockingQueue 的主要属性如下:\",\"/** The queued items */ final Object[] items; /** items index for next take, poll, peek or remove */ int takeIndex; /** items index for next put, offer, or add */ int putIndex; /** Number of elements in the queue */ int count; /* * Concurrency control uses the classic two-condition algorithm * found in any textbook. */ /** Main lock guarding all access */ final ReentrantLock lock; /** Condition for waiting takes */ private final Condition notEmpty; /** Condition for waiting puts */ private final Condition notFull;\",\"从源码中可以看出 ArrayBlockingQueue 内部是采用数组（属性 items）进行数据存储的，为了保证线程安全，采用的是 ReentrantLock lock，为了保证可阻塞式的插入删除数据利用的是 Condition，当获取数据的消费者线程被阻塞时会将该线程放置到 notEmpty 等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到 notFull 等待队列中。\",\"而 notEmpty 和 notFull 等重要属性在构造方法中进行创建：\",\"public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity <= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition(); }\",\"接下来，主要看看可阻塞式的 put 和 take 方法是怎样实现的。\"]},\"1347\":{\"h\":\"2.2 put 方法详解\",\"t\":[\"put(E e) 方法源码如下：\",\"public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { // 如果当前队列已满，将线程移入到notFull等待队列中 while (count == items.length) notFull.await(); // 满足插入数据的要求，直接进行入队操作 enqueue(e); } finally { lock.unlock(); } }\",\"该方法的逻辑很简单，当队列已满时（count == items.length）将线程移入到 notFull 等待队列中，如果当前满足插入数据的条件，就可以直接调用 enqueue(e) 插入数据元素。\",\"enqueue 方法源码为：\",\"private void enqueue(E x) { // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; // 插入数据 items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; // 通知消费者线程，当前队列中有数据可供消费 notEmpty.signal(); }\",\"enqueue 方法的逻辑同样也很简单，先完成插入数据，即往数组中添加数据（items[putIndex] = x），然后通知被阻塞的消费者线程，当前队列中有数据可供消费（notEmpty.signal()）。\"]},\"1348\":{\"h\":\"2.3 take 方法详解\",\"t\":[\"take 方法源码如下：\",\"public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { // 如果队列为空，没有数据，将消费者线程移入等待队列中 while (count == 0) notEmpty.await(); // 获取数据 return dequeue(); } finally { lock.unlock(); } }\",\"take 方法也主要做了两步：\",\"如果当前队列为空的话，则将获取数据的消费者线程移入到等待队列中；\",\"若队列不为空则获取数据，即完成出队操作 dequeue。\",\"dequeue 方法源码为：\",\"private E dequeue() { // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings(\\\"unchecked\\\") // 获取数据 E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); // 通知被阻塞的生产者线程 notFull.signal(); return x; }\",\"dequeue 方法也主要做了两件事情：\",\"获取队列中的数据，即获取数组中的数据元素（(E) items[takeIndex]）；\",\"通知 notFull 等待队列中的线程，使其由等待队列移入到同步队列中，使其能够有机会获得 lock，并执行完成功退出。\",\"从以上分析，可以看出 put 和 take 方法主要是通过 Condition 的通知机制来完成可阻塞式的插入数据和获取数据。\",\"在理解 ArrayBlockingQueue 后再去理解 LinkedBlockingQueue 就很容易了。\"]},\"1349\":{\"h\":\"3. LinkedBlockingQueue 实现原理\",\"t\":[\"LinkedBlockingQueue 是用链表实现的有界阻塞队列，当构造对象时为指定队列大小时，队列默认大小为 Integer.MAX_VALUE。\",\"从它的构造方法可以看出：\",\"public LinkedBlockingQueue() { this(Integer.MAX_VALUE); }\"]},\"1350\":{\"h\":\"3.1 LinkedBlockingQueue 的主要属性\",\"t\":[\"LinkedBlockingQueue 的主要属性有：\",\"/** Current number of elements */ private final AtomicInteger count = new AtomicInteger(); /** * Head of linked list. * Invariant: head.item == null */ transient Node<E> head; /** * Tail of linked list. * Invariant: last.next == null */ private transient Node<E> last; /** Lock held by take, poll, etc */ private final ReentrantLock takeLock = new ReentrantLock(); /** Wait queue for waiting takes */ private final Condition notEmpty = takeLock.newCondition(); /** Lock held by put, offer, etc */ private final ReentrantLock putLock = new ReentrantLock(); /** Wait queue for waiting puts */ private final Condition notFull = putLock.newCondition();\",\"可以看出与 ArrayBlockingQueue 主要的区别是，LinkedBlockingQueue 在插入数据和删除数据时分别是由两个不同的 lock（takeLock 和 putLock）来控制线程安全。因此，也由这两个 lock 生成了两个对应的 condition（notEmpty 和 notFull）来实现可阻塞的插入和删除数据。\",\"并且，采用了链表的数据结构来实现队列，Node 结点的定义为：\",\"static class Node<E> { E item; /** * One of: * - the real successor Node * - this Node, meaning the successor is head.next * - null, meaning there is no successor (this is the last node) */ Node<E> next; Node(E x) { item = x; } }\",\"接下来，我们也同样来看看 put 方法和 take 方法的实现。\"]},\"1351\":{\"h\":\"3.2 put 方法详解\",\"t\":[\"put 方法源码为:\",\"public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node<E> node = new Node<E>(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ // 如果队列已满，则阻塞当前线程，将其移入等待队列 while (count.get() == capacity) { notFull.await(); } // 入队操作，插入数据 enqueue(node); c = count.getAndIncrement(); // 若队列满足插入数据的条件，则通知被阻塞的生产者线程 if (c + 1 < capacity) notFull.signal(); } finally { putLock.unlock(); } if (c == 0) signalNotEmpty(); }\",\"put 方法的逻辑也同样很容易理解，可见注释。基本上和 ArrayBlockingQueue 的 put 方法一样。\"]},\"1352\":{\"h\":\"3.3 take 方法详解\",\"t\":[\"take 方法的源码如下：\",\"public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { // 当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件 while (count.get() == 0) { notEmpty.await(); } // 移除队头元素，获取数据 x = dequeue(); c = count.getAndDecrement(); // 如果当前满足移除元素的条件，则通知被阻塞的消费者线程 if (c > 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; }\",\"take 方法的主要逻辑请见于注释，也很容易理解。\"]},\"1353\":{\"h\":\"4. ArrayBlockingQueue 与 LinkedBlockingQueue 比较\",\"t\":[\"相同点：ArrayBlockingQueue 和 LinkedBlockingQueue 都是通过 Condition 通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性。\",\"不同点：\",\"ArrayBlockingQueue 底层是采用的数组进行实现，而 LinkedBlockingQueue 则是采用链表数据结构；\",\"ArrayBlockingQueue 插入和删除数据，只采用了一个 lock，而 LinkedBlockingQueue 则是在插入和删除分别采用了 putLock 和 takeLock，这样可以降低线程由于线程无法获取到 lock 而进入 WAITING 状态的可能性，从而提高了线程并发执行的效率。\"]},\"1354\":{\"c\":[\"并发编程\"]},\"1355\":{\"c\":[\"JUC\"]},\"1356\":{\"h\":\"线程池 ThreadPoolExecutor 实现原理\"},\"1357\":{\"h\":\"1. 为什么要使用线程池\",\"t\":[\"在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池管理线程主要有如下好处：\",\"降低资源消耗。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；\",\"提升系统响应速度。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；\",\"提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。\"]},\"1358\":{\"h\":\"2. 线程池的工作原理\",\"t\":[\"当一个并发任务提交给线程池，线程池分配线程去执行任务的过程如下图所示：\",\"从图可以看出，线程池执行所提交的任务过程主要有这样几个阶段：\",\"先判断线程池中核心线程池所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第 2 步；\",\"判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中，否则，则进入第 3 步；\",\"判断线程池中所有的线程是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给拒绝策略进行处理。\"]},\"1359\":{\"h\":\"3. 线程池的创建\",\"t\":[\"创建线程池主要是 ThreadPoolExecutor 类来完成，ThreadPoolExecutor 有许多重载的构造方法，通过参数最多的构造方法来理解创建线程池有哪些需要配置的参数。\",\"ThreadPoolExecutor 的构造方法为：\",\"ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\",\"下面对参数进行说明：\",\"corePoolSize：表示核心线程池的大小。\",\"当提交一个任务时，如果当前核心线程池的线程个数没有达到 corePoolSize，则会创建新的线程来执行所提交的任务，即使当前核心线程池有空闲的线程。如果当前核心线程池的线程个数已经达到了 corePoolSize，则不再重新创建线程。\",\"如果调用了 prestartCoreThread() 或者 prestartAllCoreThreads()，线程池创建的时候所有的核心线程都会被创建并且启动。\",\"maximumPoolSize：表示线程池能创建线程的最大个数。\",\"如果当阻塞队列已满时，并且当前线程池线程个数没有超过 maximumPoolSize 的话，就会创建新的线程来执行任务。\",\"keepAliveTime：空闲线程存活时间。\",\"如果当前线程池的线程个数已经超过了 corePoolSize，并且线程空闲时间超过了 keepAliveTime，就会将这些空闲线程销毁，这样可以尽可能降低系统资源消耗。\",\"unit：时间单位。\",\"为 keepAliveTime 指定时间单位。\",\"workQueue：阻塞队列。\",\"用于保存任务的 阻塞队列。可以使用 ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue, PriorityBlockingQueue。\",\"threadFactory：创建线程的工程类。\",\"可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，也方便查找问题原因。\",\"handler：拒绝策略。\",\"当线程池的阻塞队列已满和指定的线程都已经开启，说明当前线程池已经处于饱和状态了，那么就需要采用一种策略来处理这种情况。\",\"采用的策略有下面几种：\",\"AbortPolicy：直接拒绝所提交的任务，并抛出 RejectedExecutionException 异常；\",\"CallerRunsPolicy：只用调用者所在的线程来执行任务；\",\"DiscardPolicy：不处理直接丢弃掉任务；\",\"DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。\",\"线程池执行逻辑\",\"通过 ThreadPoolExecutor 创建线程池后，提交任务后执行过程是怎样的？下面通过源码来看一看。\",\"execute 方法源码如下：\",\"public void execute(Runnable command) { if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); // 如果线程池的线程个数少于corePoolSize则创建新线程执行当前任务 if (workerCountOf(c) < corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // 如果线程个数大于corePoolSize或者创建线程失败，则将任务存放在阻塞队列workQueue中 if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) && remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 如果当前任务无法放进阻塞队列中，则创建新的线程来执行任务 else if (!addWorker(command, false)) reject(command); }\",\"ThreadPoolExecutor 的 execute 方法执行逻辑请见注释。\",\"下图为 ThreadPoolExecutor 的 execute 方法的执行示意图：\",\"execute执行过程示意图\",\"execute 方法执行逻辑有这样几种情况：\",\"如果当前运行的线程少于 corePoolSize，则会创建新的线程来执行新的任务；\",\"如果运行的线程个数等于或者大于 corePoolSize，则会将提交的任务存放到阻塞队列 workQueue 中；\",\"如果当前 workQueue 队列已满的话，则会创建新的线程来执行任务；\",\"如果线程个数已经超过了 maximumPoolSize，则会使用拒绝策略 RejectedExecutionHandler 来进行处理。\",\"需要注意的是，线程池的设计思想就是使用了 核心线程池 corePoolSize，阻塞队列 workQueue 和 线程池 maximumPoolSize，这样的缓存策略来处理任务，实际上这样的设计思想在需要框架中都会使用。\"]},\"1360\":{\"h\":\"4. 线程池的关闭\",\"t\":[\"关闭线程池，可以通过 shutdown 和 shutdownNow 这两个方法。它们的原理都是遍历线程池中所有的线程，然后依次中断线程。\",\"shutdown 和 shutdownNow 还是有不一样的地方：\",\"shutdownNow 首先将线程池的状态设置为 STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表；\",\"shutdown 只是将线程池的状态设置为 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。\",\"可以看出 shutdown 方法会将正在执行的任务继续执行完，而 shutdownNow 会直接中断正在执行的任务。\",\"调用这两个方法的任意一个，isShutdown 方法都会返回 false，当所有的线程都关闭成功，才表示线程池成功关闭，这时调用 isTerminated 方法才会返回 true。\"]},\"1361\":{\"h\":\"5. 如何合理配置线程池参数？\",\"t\":[\"要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\",\"任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务。\",\"任务的优先级：高，中和低。\",\"任务的执行时间：长，中和短。\",\"任务的依赖性：是否依赖其他系统资源，如数据库连接。\",\"任务性质不同的任务可以用不同规模的线程池分开处理。\",\"CPU 密集型任务配置尽可能少的线程数量，IO 密集型任务则由于需要等待 IO 操作，线程并不是一直在执行任务，则配置尽可能多的线程。\",\"有一个经验值公式，其中 N 为 CPU 核心数：\",\"CPU 密集型任务，核心线程数设置为 N（或 N+1）;\",\"IO 密集型任务，核心线程数设置为 2N。\",\"混合型的任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过 Runtime.getRuntime().availableProcessors() 方法获得当前设备的 CPU 个数。\",\"优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。\",\"执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\",\"依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，如果等待的时间越长 CPU 空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用 CPU。\",\"并且，阻塞队列最好是使用有界队列，如果采用无界队列的话，一旦任务积压在阻塞队列中的话就会占用过多的内存资源，甚至会使得系统崩溃。\"]},\"1362\":{\"c\":[\"并发编程\"]},\"1363\":{\"c\":[\"JUC\"]},\"1364\":{\"h\":\"线程池之 ScheduledThreadPoolExecutor\"},\"1365\":{\"h\":\"1. ScheduledThreadPoolExecutor 简介\",\"t\":[\"ScheduledThreadPoolExecutor 可以用来在给定延时后执行异步任务或者周期性执行任务，相对于任务调度的 Timer 来说，其功能更加强大，Timer 只能使用一个后台线程执行任务，而 ScheduledThreadPoolExecutor 则可以通过构造函数来指定后台线程的个数。\",\"ScheduledThreadPoolExecutor 类的 UML 图如下：\",\"从 UML 图可以看出，ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor，也就是说 ScheduledThreadPoolExecutor 拥有 execute() 和 submit() 提交异步任务的基础功能。但是，ScheduledThreadPoolExecutor 类实现了 ScheduledExecutorService，该接口定义了 ScheduledThreadPoolExecutor 能够延时执行任务和周期执行任务的功能；\",\"ScheduledThreadPoolExecutor 也有两个重要的内部类：DelayedWorkQueue 和 ScheduledFutureTask。可以看出 DelayedWorkQueue 实现了 BlockingQueue 接口，也就是一个阻塞队列，ScheduledFutureTask 则是继承了 FutureTask 类，也表示该类用于返回异步任务的结果。\",\"这两个关键类，下面会具体详细来看。\"]},\"1366\":{\"h\":\"1.1 构造方法\",\"t\":[\"ScheduledThreadPoolExecutor 有如下几个构造方法：\",\"public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory); } public ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), handler); } public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory, handler); }\",\"可以看出由于 ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor，它的构造方法实际上是调用了 ThreadPoolExecutor，理解 ThreadPoolExecutor 构造方法的几个参数的意义后，理解这就很容易了。\",\"可以看出，ScheduledThreadPoolExecutor 的核心线程池的线程个数为指定的 corePoolSize，当核心线程池的线程个数达到 corePoolSize 后，就会将任务提交给有界阻塞队列 DelayedWorkQueue，对 DelayedWorkQueue 在下面进行详细介绍，线程池允许最大的线程个数为 Integer.MAX_VALUE，也就是说理论上这是一个大小无界的线程池。\"]},\"1367\":{\"h\":\"1.2 特有方法\",\"t\":[\"ScheduledThreadPoolExecutor 实现了 ScheduledExecutorService 接口，该接口定义了可延时执行异步任务和可周期执行异步任务的特有功能，相应的方法分别为：\",\"// 达到给定的延时时间后，执行任务。这里传入的是实现Runnable接口的任务， // 因此通过ScheduledFuture.get()获取结果为null public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit); // 达到给定的延时时间后，执行任务。这里传入的是实现Callable接口的任务， // 因此，返回的是任务的最终计算结果 public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit); // 以上一个任务开始的时间计时，period时间过去后， // 检测上一个任务是否执行完毕，如果上一个任务执行完毕， // 则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行 public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); // 当达到延时时间initialDelay后，任务开始执行。上一个任务执行结束后到下一次 // 任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。 public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);\"]},\"1368\":{\"h\":\"2. 可周期性执行的任务 —— ScheduledFutureTask\",\"t\":[\"ScheduledThreadPoolExecutor 最大的特色是能够周期性执行异步任务，当调用 schedule,scheduleAtFixedRate 和 scheduleWithFixedDelay 方法时，实际上是将提交的任务转换成的 ScheduledFutureTask 类，从源码就可以看出。\",\"以 schedule 方法为例：\",\"public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) { if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture<?> t = decorateTask(command, new ScheduledFutureTask<Void>(command, null, triggerTime(delay, unit))); delayedExecute(t); return t; }\",\"可以看出，通过 decorateTask 会将传入的 Runnable 转换成 ScheduledFutureTask 类。\",\"线程池最大作用是将任务和线程进行解耦，线程主要是任务的执行者，而任务也就是现在所说的 ScheduledFutureTask。紧接着，会想到任何线程执行任务，总会调用 run() 方法。\",\"为了保证 ScheduledThreadPoolExecutor 能够延时执行任务以及能够周期性执行任务，ScheduledFutureTask 重写了 run 方法：\",\"public void run() { boolean periodic = isPeriodic(); if (!canRunInCurrentRunState(periodic)) cancel(false); else if (!periodic) // 如果不是周期性执行任务，则直接调用run方法 ScheduledFutureTask.super.run(); // 如果是周期性执行任务的话，需要重设下一次执行任务的时间 else if (ScheduledFutureTask.super.runAndReset()) { setNextRunTime(); reExecutePeriodic(outerTask); } }\",\"从源码可以很明显的看出，在重写的 run 方法中会先 if (!periodic) 判断当前任务是否是周期性任务，如果不是的话就直接调用 run() 方法；否则的话执行 setNextRunTime() 方法重设下一次任务执行的时间，并通过 reExecutePeriodic(outerTask) 方法将下一次待执行的任务放置到 DelayedWorkQueue 中。\",\"因此，可以得出结论：ScheduledFutureTask 最主要的功能是根据当前任务是否具有周期性，对异步任务进行进一步封装。如果不是周期性任务（调用 schedule 方法）则直接通过 run() 执行，若是周期性任务，则需要在每一次执行完后，重设下一次执行的时间，然后将下一次任务继续放入到阻塞队列中。\"]},\"1369\":{\"h\":\"3. DelayedWorkQueue\",\"t\":[\"在 ScheduledThreadPoolExecutor 中还有另外的一个重要的类就是 DelayedWorkQueue。为了实现其 ScheduledThreadPoolExecutor 能够延时执行异步任务以及能够周期执行任务，DelayedWorkQueue 进行相应的封装。\",\"DelayedWorkQueue 是一个基于堆的数据结构，类似于 DelayQueue 和 PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以 DelayedWorkQueue 的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。\",\"为什么要使用 DelayedWorkQueue 呢？\",\"定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。\",\"DelayedWorkQueue 是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。\",\"DelayedWorkQueue 的数据结构\",\"// 初始大小 private static final int INITIAL_CAPACITY = 16; // DelayedWorkQueue是由一个大小为16的数组组成，数组元素为实现RunnableScheduleFuture接口的类 // 实际上为ScheduledFutureTask private RunnableScheduledFuture<?>[] queue = new RunnableScheduledFuture<?>[INITIAL_CAPACITY]; private final ReentrantLock lock = new ReentrantLock(); private int size = 0;\",\"可以看出 DelayedWorkQueue 底层是采用数组构成的。\",\"关于 DelayedWorkQueue 我们可以得出这样的结论：DelayedWorkQueue是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行。\"]},\"1370\":{\"h\":\"4.ScheduledThreadPoolExecutor 执行过程\",\"t\":[\"现在我们对 ScheduledThreadPoolExecutor 的两个内部类 ScheduledFutueTask 和 DelayedWorkQueue 进行了了解，实际上这也是线程池工作流程中最重要的两个关键因素：任务以及阻塞队列。现在我们来看下 ScheduledThreadPoolExecutor 提交一个任务后，整体的执行过程。\",\"以 ScheduledThreadPoolExecutor 的 schedule 方法为例，具体源码为：\",\"public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) { if (command == null || unit == null) throw new NullPointerException(); //将提交的任务转换成ScheduledFutureTask RunnableScheduledFuture<?> t = decorateTask(command, new ScheduledFutureTask<Void>(command, null, triggerTime(delay, unit))); // 延时执行任务ScheduledFutureTask delayedExecute(t); return t; }\",\"方法很容易理解，为了满足 ScheduledThreadPoolExecutor 能够延时执行任务和能周期执行任务的特性，会先将实现 Runnable 接口的类转换成 ScheduledFutureTask。然后会调用 delayedExecute 方法进行执行任务，这个方法也是关键方法，来看下源码：\",\"private void delayedExecute(RunnableScheduledFuture<?> task) { if (isShutdown()) // 如果当前线程池已经关闭，则拒绝任务 reject(task); else { // 将任务放入阻塞队列中 super.getQueue().add(task); if (isShutdown() && !canRunInCurrentRunState(task.isPeriodic()) && remove(task)) task.cancel(false); else // 保证至少有一个线程启动，即使corePoolSize=0 ensurePrestart(); } }\",\"delayedExecute 方法的主要逻辑请看注释，可以看出该方法的重要逻辑会是在 ensurePrestart() 方法中，它的源码为：\",\"void ensurePrestart() { int wc = workerCountOf(ctl.get()); if (wc < corePoolSize) addWorker(null, true); else if (wc == 0) addWorker(null, false); }\",\"可以看出该方法逻辑很简单，关键在于它所调用的 addWorker 方法，该方法主要功能：\",\"新建 Worker 类，当执行任务时，就会调用被 Worker 所重写的 run 方法，进而会继续执行 runWorker 方法。\",\"在 runWorker 方法中会调用 getTask 方法从阻塞队列中不断的去获取任务进行执行，直到从阻塞队列中获取的任务为 null，线程才结束终止。\",\"addWorker 方法是 ThreadPoolExecutor 类中的方法，对 ThreadPoolExecutor 的源码分析看 这篇文章。\"]},\"1371\":{\"h\":\"5. 总结\",\"t\":[\"ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor 类，因此，整体上功能一致，线程池主要负责创建线程（Worker类），线程从阻塞队列中不断获取新的异步任务，直到阻塞队列中已经没有了异步任务为止。\",\"但是相较于 ThreadPoolExecutor 来说，ScheduledThreadPoolExecutor 具有延时执行任务和可周期性执行任务的特性，ScheduledThreadPoolExecutor 重新设计了任务类 ScheduleFutureTask，ScheduleFutureTask重写了 run 方法使其具有可延时执行和可周期性执行任务的特性。\",\"另外，阻塞队列 DelayedWorkQueue 是可根据优先级排序的队列，采用了堆的底层数据结构，使得与当前时间相比，待执行时间越靠近的任务放置队头，以便线程能够获取到任务进行执行。\",\"线程池无论是 ThreadPoolExecutor 还是 ScheduledThreadPoolExecutor，在设计时的三个关键要素是：任务，执行者以及任务结果。它们的设计思想也是完全将这三个关键要素进行了解耦。\",\"任务\",\"在 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 中任务是指实现了 Runnable 接口和 Callable 接口的实现类。\",\"ThreadPoolExecutor 中会将任务转换成 FutureTask 类，而在 ScheduledThreadPoolExecutor 中为了实现可延时执行任务和周期性执行任务的特性，任务会被转换成 ScheduledFutureTask 类，该类继承了 FutureTask，并重写了 run 方法。\",\"执行者\",\"任务的执行机制，完全交由 Worker 类，也就是进一步了封装了 Thread。\",\"向线程池提交任务，无论为 ThreadPoolExecutor 的 execute 方法和 submit 方法，还是 ScheduledThreadPoolExecutor 的 schedule 方法，都是先将任务移入到阻塞队列中，然后通过 addWork 方法新建了 Work 类，并通过 runWorker 方法启动线程，并不断的从阻塞对列中获取异步任务执行交给 Worker 执行，直至阻塞队列中无法取到任务为止。\",\"任务结果\",\"在 ThreadPoolExecutor 中提交任务后，获取任务结果可以通过 Future 接口的类，在 ThreadPoolExecutor 中实际上为 FutureTask 类，而在 ScheduledThreadPoolExecutor 中则是 ScheduledFutureTask 类。\"]},\"1372\":{\"c\":[\"并发编程\"]},\"1373\":{\"c\":[\"JUC\"]},\"1374\":{\"h\":\"FutureTask 基本操作总结\"},\"1375\":{\"h\":\"1. FutureTask 简介\",\"t\":[\"在 Executors 框架体系中，FutureTask 用来表示可获取结果的异步任务。\",\"FutureTask 实现了 Future 接口，FutureTask 提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法。\",\"通过 get() 方法来获取异步任务的结果，但是会阻塞当前线程直至异步任务执行结束。一旦任务执行结束，任务不能重新启动或取消，除非调用 runAndReset() 方法。\",\"在 FutureTask 的源码中为其定义了这些状态：\",\"private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6;\",\"另外，在《Java并发编程的艺术》一书，作者根据 FutureTask.run() 方法的执行的时机，将 FutureTask 分为了3种状态：\",\"未启动。FutureTask.run() 方法还没有被执行之前，FutureTask 处于未启动状态。当创建一个 FutureTask，还没有执行 FutureTask.run() 方法之前，FutureTask 处于未启动状态。\",\"已启动。FutureTask.run() 方法被执行的过程中，FutureTask 处于已启动状态。\",\"已完成。FutureTask.run() 方法执行结束，或者调用 FutureTask.cancel(...) 方法取消任务，或者在执行任务期间抛出异常，这些情况都称之为 FutureTask 的已完成状态。\",\"下图总结了 FutureTask 的状态变化的过程：\",\"FutureTask 状态迁移图\",\"由于 FutureTask 具有这三种状态，因此执行 FutureTask 的 get 方法和 cancel 方法，当前处于不同的状态对应的结果也是大不相同。\",\"这里对 get 方法和 cancel 方法做个总结：\",\"get 方法\",\"当 FutureTask 处于未启动或已启动状态时，执行 FutureTask.get() 方法将导致调用线程阻塞。\",\"如果 FutureTask 处于已完成状态，调用 FutureTask.get() 方法将导致调用线程立即返回结果或者抛出异常。\",\"cancel 方法\",\"当 FutureTask 处于未启动状态时，执行 FutureTask.cancel() 方法将此任务永远不会执行。\",\"当 FutureTask 处于已启动状态时，执行 FutureTask.cancel(true) 方法将以中断线程的方式来阻止任务继续进行，如果执行 FutureTask.cancel(false) 将不会对正在执行任务的线程有任何影响。\",\"当 FutureTask 处于已完成状态时，执行 FutureTask.cancel(...) 方法将返回 false。\",\"对 Future 的 get() 方法和 cancel() 方法用下图进行总结：\"]},\"1376\":{\"h\":\"2. FutureTask 的基本使用\",\"t\":[\"FutureTask 除了实现 Future 接口外，还实现了 Runnable 接口。因此，FutureTask 可以交给 Executor 执行，也可以由调用的线程直接执行（FutureTask.run()）。\",\"另外，FutureTask 的获取也可以通过 ExecutorService.submit() 方法返回一个 FutureTask 对象，然后在通过 FutureTask.get() 或者 FutureTask.cancel 方法。\",\"应用场景：当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用 FutureTask。假设有多个线程执行若干任务，每个任务最多只能被执行一次。当多个线程试图执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行。\"]},\"1377\":{\"c\":[\"并发编程\"]},\"1378\":{\"c\":[\"JUC\"]},\"1379\":{\"h\":\"atomic 包中的原子操作类总结\"},\"1380\":{\"h\":\"1. 原子操作类介绍\",\"t\":[\"在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程执行 i++ 操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过 Synchronized 进行控制来达到线程安全的目的。但由于 synchronized 采用的是悲观锁策略，并不是一种特别高效的解决方案。\",\"实际上，在 J.U.C 下的 atomic 包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic 包下的这些类都是采用的是乐观锁策略去原子更新数据，在 Java 中则是使用 CAS 操作具体实现。\"]},\"1381\":{\"h\":\"2. CAS 操作\",\"t\":[\"如果要弄懂 atomic 包下这些原子操作类的实现原理，首先要明白什么是 CAS 操作。\"]},\"1382\":{\"h\":\"2.1 什么是 CAS？\",\"t\":[\"使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而 CAS 操作（又称为无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？\",\"无锁操作是使用 CAS（compare and swap）又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。\"]},\"1383\":{\"h\":\"2.2 CAS的操作过程\",\"t\":[\"CAS 比较交换的过程可以通俗的理解为 CAS(V,O,N)，包含三个值分别为：\",\"V 内存地址存放的实际值；\",\"O 预期的值（旧值）；\",\"N 更新的新值。\",\"当 V 和 O 相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值 O 就是目前来说最新的值了，自然而然可以将新值 N 赋值给 V。\",\"反之，若 V 和 O 不同，表明该值已经被其他线程改过了，则该旧值 O 不是最新版本的值了，所以不能将新值 N 赋给 V，返回 V 即可。\",\"当多个线程使用 CAS 操作一个变量时，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。\",\"CAS 的实现需要硬件指令集的支撑，在 JDK1.5 后虚拟机才可以使用处理器提供的 CMPXCHG 指令实现。\"]},\"1384\":{\"h\":\"2.3 Synchronized vs CAS\",\"t\":[\"元老级的 Synchronized（未优化前）最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而 CAS 并不是武断的间线程挂起，当 CAS 操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。\",\"CAS 的问题\",\"ABA 问题\",\"因为 CAS 会检查旧值有没有变化，这里就会存在一个问题。比如一个旧值 A 变为了成 B，然后再变成 A，刚好在做 CAS 时检查发现旧值并没有变化依然为 A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径 A -> B -> A 就变成了 1A -> 2B -> 3C。\",\"自旋时间过长\",\"使用 CAS 时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果 JVM 能支持处理器提供的 pause 指令，那么在效率上会有一定的提升。\"]},\"1385\":{\"h\":\"3. 原子更新基本类型\",\"t\":[\"atomic 包提高原子更新基本类型的工具类，主要有这些：\",\"AtomicBoolean：以原子更新的方式更新 boolean；\",\"AtomicInteger：以原子更新的方式更新 Integer；\",\"AtomicLong：以原子更新的方式更新 Long；\",\"这几个类的用法基本一致，这里以 AtomicInteger 为例总结常用的方法：\",\"addAndGet(int delta)：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果。\",\"incrementAndGet()：以原子的方式将实例中的原值进行加 1 操作，并返回最终相加后的结果。\",\"getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值。\",\"getAndIncrement()：以原子的方式将实例中的原值加 1，返回的是自增前的旧值。\",\"还有一些方法，可以查看 API，不再赘述。为了能够弄懂 AtomicInteger 的实现原理，以 getAndIncrement 方法为例，来看下源码：\",\"public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); }\",\"可以看出，该方法实际上是调用了 unsafe 实例的 getAndAddInt 方法，unsafe 实例通过 UnSafe 类的静态方法 getUnsafe 获取：\",\"private static final Unsafe unsafe = Unsafe.getUnsafe();\",\"Unsafe 类在 sun.misc 包下，Unsafer 类提供了一些底层操作，atomic 包下的原子操作类的也主要是通过 Unsafe 类提供的 compareAndSwapInt，compareAndSwapLong 等一系列提供 CAS 操作的方法来进行实现。\",\"下面用一个简单的例子来说明 AtomicInteger 的用法：\",\"public class AtomicDemo { private static AtomicInteger atomicInteger = new AtomicInteger(1); public static void main(String[] args) { System.out.println(atomicInteger.getAndIncrement()); System.out.println(atomicInteger.get()); } }\",\"输出结果：\",\"1 2\",\"例子很简单，就是新建了一个 atomicInteger 对象，而 atomicInteger 的构造方法也就是传入一个基本类型数据即可，对其进行了封装。对基本变量的操作比如自增，自减，相加，更新等操作，atomicInteger 也提供了相应的方法进行这些操作。\",\"因为 atomicInteger 借助了 UnSafe 提供的 CAS 操作，能够保证数据更新的时候是线程安全的，并且由于 CAS 是采用乐观锁策略，因此，这种数据更新的方法也具有高效性。\",\"AtomicLong 的实现原理和 AtomicInteger 一致，只不过一个针对的是 long 变量，一个针对的是 int 变量。而 boolean 变量的更新类 AtomicBoolean 类是怎样实现更新的呢？核心方法是 compareAndSet 方法，其源码如下：\",\"public final boolean compareAndSet(boolean expect, boolean update) { int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); }\",\"可以看出，compareAndSet 方法的实际上也是先转换成 0，1 的整型变量，然后是通过针对 int 型变量的原子更新方法 compareAndSwapInt 来实现的。\",\"可以看出 atomic 包中只提供了对 boolean，int，long 这三种基本类型的原子更新的方法，参考对 boolean 更新的方式，原子更新 char，doule，float 也可以采用类似的思路进行实现。\"]},\"1386\":{\"h\":\"4. 原子更新数组类型\",\"t\":[\"atomic 包下提供能原子更新数组中元素的类有：\",\"AtomicIntegerArray：原子更新整型数组中的元素。\",\"AtomicLongArray：原子更新长整型数组中的元素。\",\"AtomicReferenceArray：原子更新引用类型数组中的元素。\",\"这几个类的用法一致，以 AtomicIntegerArray 来总结下常用的方法：\",\"addAndGet(int i, int delta)：以原子更新的方式将数组中索引为 i 的元素与输入值相加。\",\"getAndIncrement(int i)：以原子更新的方式将数组中索引为 i 的元素自增加 1。\",\"compareAndSet(int i, int expect, int update)：将数组中索引为 i 的位置的元素进行更新。\",\"可以看出，AtomicIntegerArray 与 AtomicInteger 的方法基本一致，只不过在 AtomicIntegerArray 的方法中会多一个指定数组索引位 i。\",\"下面举一个简单的例子：\",\"public class AtomicDemo { // private static AtomicInteger atomicInteger = new AtomicInteger(1); private static int[] value = new int[]{1, 2, 3}; private static AtomicIntegerArray integerArray = new AtomicIntegerArray(value); public static void main(String[] args) { // 对数组中索引为1的位置的元素加5 int result = integerArray.getAndAdd(1, 5); System.out.println(integerArray.get(1)); System.out.println(result); } }\",\"输出结果：\",\"7 2\",\"通过 getAndAdd 方法将位置为 1 的元素加 5，从结果可以看出索引为 1 的元素变成了 7，该方法返回的也是相加之前的数为 2。\"]},\"1387\":{\"h\":\"5. 原子更新引用类型\",\"t\":[\"如果需要原子更新引用类型变量的话，为了保证线程安全，atomic 也提供了相关的类：\",\"AtomicReference：原子更新引用类型。\",\"AtomicReferenceFieldUpdater：原子更新引用类型里的字段。\",\"AtomicMarkableReference：原子更新带有标记位的引用类型。\",\"这几个类的使用方法也是基本一样的，以 AtomicReference 为例，来说明这些类的基本用法。\",\"下面是一个 demo：\",\"public class AtomicDemo { private static AtomicReference<User> reference = new AtomicReference<>(); public static void main(String[] args) { User user1 = new User(\\\"a\\\", 1); reference.set(user1); User user2 = new User(\\\"b\\\",2); User user = reference.getAndSet(user2); System.out.println(user); System.out.println(reference.get()); } static class User { private String userName; private int age; public User(String userName, int age) { this.userName = userName; this.age = age; } @Override public String toString() { return \\\"User{\\\" + \\\"userName='\\\" + userName + '\\\\'' + \\\", age=\\\" + age + '}'; } } }\",\"输出结果：\",\"User{userName='a', age=1} User{userName='b', age=2}\",\"首先将对象 User1 用 AtomicReference 进行封装，然后调用 getAndSet 方法。从结果可以看出，该方法会原子更新引用的 user 对象，变为 User{userName='b', age=2}，返回的是原来的 user 对象 User{userName='a', age=1}。\"]},\"1388\":{\"h\":\"6. 原子更新字段类型\",\"t\":[\"如果需要更新对象的某个字段，并在多线程的情况下，能够保证线程安全，atomic 同样也提供了相应的原子操作类：\",\"AtomicIntegeFieldUpdater：原子更新整型字段类。\",\"AtomicLongFieldUpdater：原子更新长整型字段类。\",\"AtomicStampedReference：原子更新引用类型，这种更新方式会带有版本号。而为什么在更新的时候会带有版本号，是为了解决CAS的ABA问题。\",\"要想使用原子更新字段需要两步操作：\",\"原子更新字段类都是抽象类，只能通过静态方法 newUpdater 来创建一个更新器，并且需要设置想要更新的类和属性；\",\"更新类的属性必须使用 public volatile 进行修饰。\",\"这几个类提供的方法基本一致，以 AtomicIntegerFieldUpdater 为例来看看具体的使用：\",\"public class AtomicDemo { private static AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(User.class,\\\"age\\\"); public static void main(String[] args) { User user = new User(\\\"a\\\", 1); int oldValue = updater.getAndAdd(user, 5); System.out.println(oldValue); System.out.println(updater.get(user)); } static class User { private String userName; public volatile int age; public User(String userName, int age) { this.userName = userName; this.age = age; } @Override public String toString() { return \\\"User{\\\" + \\\"userName='\\\" + userName + '\\\\'' + \\\", age=\\\" + age + '}'; } } }\",\"输出结果：\",\"1 6\",\"从示例中可以看出，创建 AtomicIntegerFieldUpdater 是通过它提供的静态方法进行创建，getAndAdd 方法会将指定的字段加上输入的值，并且返回相加之前的值。user 对象中 age 字段原值为 1，加 5 之后，可以看出 user 对象中的 age 字段的值已经变成了 6。\"]},\"1389\":{\"c\":[\"并发编程\"]},\"1390\":{\"c\":[\"JUC\"]},\"1391\":{\"h\":\"Java并发工具类 - CountDownLatch，CyclicBarrier\"},\"1392\":{\"h\":\"1. 倒计时器 CountDownLatch\",\"t\":[\"在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能，在这种的业务场景下，通常可以使用 Thread 类的 join 方法，让主线程等待被 join 的线程执行完之后，主线程才能继续往下执行。当然，使用线程间消息通信机制也可以完成。其实，Java 并发工具类中为我们提供了类似 “倒计时” 这样的工具类，可以十分方便的完成所说的这种业务场景。\",\"为了能够理解 CountDownLatch，举一个很通俗的例子，运动员进行跑步比赛时，假设有 6 个运动员参与比赛，裁判员在终点会为这 6 个运动员分别计时，可以想象每当一个运动员到达终点的时候，对于裁判员来说就少了一个计时任务。直到所有运动员都到达终点了，裁判员的任务也才完成。这 6 个运动员可以类比成 6 个线程，当线程调用 CountDownLatch.countDown 方法时就会对计数器的值减一，直到计数器的值为 0 的时候，裁判员（调用 await 方法的线程）才能继续往下执行。\",\"下面来看些 CountDownLatch 的一些重要方法。\",\"先从 CountDownLatch 的构造方法看起：\",\"public CountDownLatch(int count)\",\"构造方法会传入一个整型数 N，之后调用 CountDownLatch 的 countDown 方法会对 N 减一，直到 N 减到 0 的时候，当前调用 await 方法的线程继续执行。\",\"CountDownLatch 的方法不是很多，将它们一个个列举出来：\",\"await() throws InterruptedException：调用该方法的线程等到构造方法传入的 N 减到 0 的时候，才能继续往下执行。\",\"await(long timeout, TimeUnit unit)：与上面的 await 方法功能一致，只不过这里有了时间限制，调用该方法的线程等到指定的 timeout 时间后，不管 N 是否减至为 0，都会继续往下执行。\",\"countDown()：使 CountDownLatch 初始值 N 减 1。\",\"long getCount()：获取当前 CountDownLatch 维护的值。\",\"下面用一个具体的例子来说明 CountDownLatch 的具体用法:\",\"public class CountDownLatchDemo { private static CountDownLatch startSignal = new CountDownLatch(1); // 用来表示裁判员需要维护的是6个运动员 private static CountDownLatch endSignal = new CountDownLatch(6); public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.newFixedThreadPool(6); for (int i = 0; i < 6; i++) { executorService.execute(() -> { try { System.out.println(Thread.currentThread().getName() + \\\" 运动员等待裁判员响哨！！！\\\"); startSignal.await(); System.out.println(Thread.currentThread().getName() + \\\"正在全力冲刺\\\"); endSignal.countDown(); System.out.println(Thread.currentThread().getName() + \\\" 到达终点\\\"); } catch (InterruptedException e) { e.printStackTrace(); } }); } System.out.println(\\\"裁判员发号施令啦！！！\\\"); startSignal.countDown(); endSignal.await(); System.out.println(\\\"所有运动员到达终点，比赛结束！\\\"); executorService.shutdown(); } }\",\"输出结果：\",\"pool-1-thread-2 运动员等待裁判员响哨！！！ pool-1-thread-3 运动员等待裁判员响哨！！！ pool-1-thread-1 运动员等待裁判员响哨！！！ pool-1-thread-4 运动员等待裁判员响哨！！！ pool-1-thread-5 运动员等待裁判员响哨！！！ pool-1-thread-6 运动员等待裁判员响哨！！！ 裁判员发号施令啦！！！ pool-1-thread-2正在全力冲刺 pool-1-thread-2 到达终点 pool-1-thread-3正在全力冲刺 pool-1-thread-3 到达终点 pool-1-thread-1正在全力冲刺 pool-1-thread-1 到达终点 pool-1-thread-4正在全力冲刺 pool-1-thread-4 到达终点 pool-1-thread-5正在全力冲刺 pool-1-thread-5 到达终点 pool-1-thread-6正在全力冲刺 pool-1-thread-6 到达终点 所有运动员到达终点，比赛结束！\",\"该示例代码中设置了两个 CountDownLatch，第一个 endSignal 用于控制让 main 线程（裁判员）必须等到其他线程（运动员）让 CountDownLatch 维护的数值 N 减到 0 为止，另一个 startSignal 用于让 main 线程对其他线程进行 “发号施令”，startSignal 引用的 CountDownLatch 初始值为 1。\",\"而其他线程执行的 run 方法中都会先通过 startSignal.await() 让这些线程都被阻塞，直到 main 线程通过调用 startSignal.countDown()，将值 N 减 1，CountDownLatch 维护的数值 N 为 0 后，其他线程才能往下执行。并且，每个线程执行的 run 方法中都会通过 endSignal.countDown() 对 endSignal 维护的数值进行减一，由于往线程池提交了 6 个任务，会被减 6 次，所以 endSignal 维护的值最终会变为 0，因此 main 线程在 latch.await() 阻塞结束，才能继续往下执行。\",\"另外，需要注意的是，当调用 CountDownLatch 的 countDown 方法时，当前线程不会被阻塞，而是会继续往下执行，比如在该例中会继续输出 pool-1-thread-4 到达终点。\"]},\"1393\":{\"h\":\"2. 循环栅栏 CyclicBarrier\",\"t\":[\"CyclicBarrier 也是一种多线程并发控制的实用工具，和 CountDownLatch 一样具有等待计数的功能，但是相比于 CountDownLatch 功能更加强大。\",\"为了理解 CyclicBarrier，这里举一个通俗的例子。开运动会时，会有跑步这一项运动，我们来模拟下运动员入场时的情况，假设有 6 条跑道，在比赛开始时，就需要 6 个运动员在比赛开始的时候都站在起点，裁判员吹哨后才能开始跑步。跑道起点就相当于 “barrier”，是临界点，而将这 6 个运动员就类比成线程的话，就是这 6 个线程都必须到达指定点，意味着凑齐了一波，然后才能继续执行，否则每个线程都得阻塞等待，直至凑齐一波。\",\"cyclic 是循环的意思，也就是说 CyclicBarrier 当多个线程凑齐了一波之后，仍然有效，可以继续凑齐下一波。\",\"CyclicBarrier 的执行示意图如下：\",\"当多个线程都达到了指定点后，才能继续往下继续执行。这就有点像报数的感觉，假设 6 个线程就相当于 6 个运动员，到赛道起点时会报数进行统计，如果刚好是 6 的话，这一波就凑齐了，才能往下执行。\",\"CyclicBarrier 在使用一次后，后面依然有效，可以继续当做计数器使用，这是与 CountDownLatch 的区别之一。\",\"这里的 6 个线程，也就是计数器的初始值 6，是通过 CyclicBarrier 的构造方法传入的。\",\"下面来看下 CyclicBarrier 的主要方法：\",\"// 等到所有的线程都到达指定的临界点 await() throws InterruptedException, BrokenBarrierException // 与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止 await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException // 获取当前有多少个线程阻塞等待在临界点上 int getNumberWaiting() // 用于查询阻塞等待的线程是否被中断 boolean isBroken() // 将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException。 void reset()\",\"另外需要注意的是，CyclicBarrier 提供了这样的构造方法：\",\"public CyclicBarrier(int parties, Runnable barrierAction)\",\"当指定的线程都到达了指定的临界点的时，接下来执行的操作由 barrierAction 传入即可。\",\"我们通过模拟上面的运动员的例子，来看下 CyclicBarrier 的用法：\",\"public class CyclicBarrierDemo { // 指定必须有6个运动员到达才行 private static CyclicBarrier barrier = new CyclicBarrier(6, () -> { System.out.println(\\\"所有运动员入场，裁判员一声令下！！！！！\\\"); }); public static void main(String[] args) { System.out.println(\\\"运动员准备进场，全场欢呼............\\\"); ExecutorService service = Executors.newFixedThreadPool(6); for (int i = 0; i < 6; i++) { service.execute(() -> { try { System.out.println(Thread.currentThread().getName() + \\\" 运动员，进场\\\"); barrier.await(); System.out.println(Thread.currentThread().getName() + \\\" 运动员出发\\\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }); } } }\",\"输出结果：\",\"运动员准备进场，全场欢呼............ pool-1-thread-2 运动员，进场 pool-1-thread-1 运动员，进场 pool-1-thread-3 运动员，进场 pool-1-thread-4 运动员，进场 pool-1-thread-5 运动员，进场 pool-1-thread-6 运动员，进场 所有运动员入场，裁判员一声令下！！！！！ pool-1-thread-6 运动员出发 pool-1-thread-1 运动员出发 pool-1-thread-5 运动员出发 pool-1-thread-4 运动员出发 pool-1-thread-3 运动员出发 pool-1-thread-2 运动员出发\",\"从输出结果可以看出，当 6 个运动员（线程）都到达了指定的临界点（barrier）时候，才能继续往下执行，否则，会阻塞等待在调用 await() 处。\"]},\"1394\":{\"h\":\"3. CountDownLatch 与 CyclicBarrier 比较\",\"t\":[\"CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\",\"CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行，强调一个线程等多个线程完成某件事情；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行，强调多个线程互等，等大家都完成，再携手共进。\",\"调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行。\",\"CountDownLatch 方法比较少，操作比较简单，而 CyclicBarrier 提供的方法更多，比如能够通过 getNumberWaiting()，isBroken() 这些方法获取当前多个线程的状态，并且 CyclicBarrier 的构造方法可以传入 barrierAction，指定当所有线程都到达时执行的业务功能。\",\"CountDownLatch 是不能复用的，而 CyclicLatch 是可以复用的。\"]},\"1395\":{\"c\":[\"并发编程\"]},\"1396\":{\"c\":[\"JUC\"]},\"1397\":{\"h\":\"Java并发工具类 - Semaphore，Exchanger\"},\"1398\":{\"h\":\"1. 控制资源并发访问 —— Semaphore\",\"t\":[\"Semaphore 可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。Semaphore 就相当于一个许可证，线程需要先通过 acquire 方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。当执行完业务功能后，需要通过 release() 方法将许可证归还，以便其他线程能够获得许可证继续执行。\",\"Semaphore 可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有 10 个，这时候就需要使用 Semaphore 来控制能够并发访问到数据库连接资源的线程个数最多只有 10 个。在限制资源使用的应用场景下，Semaphore 是特别合适的。\",\"下面来看下 Semaphore 的主要方法：\",\"// 获取许可，如果无法获取到，则阻塞等待直至能够获取为止 void acquire() throws InterruptedException // 同acquire方法功能基本一样，只不过该方法可以一次获取多个许可 void acquire(int permits) throws InterruptedException // 释放许可 void release() // 释放指定个数的许可 void release(int permits) // 尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false boolean tryAcquire() // 与tryAcquire方法一致，只不过这里可以指定获取多个许可 boolean tryAcquire(int permits) // 尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException // 与上一个方法一致，只不过这里能够获取多个许可 boolean tryAcquire(int permits, long timeout, TimeUnit unit) // 返回当前可用的许可证个数 int availablePermits() // 返回正在等待获取许可证的线程数 int getQueueLength() // 是否有线程正在等待获取许可证 boolean hasQueuedThreads() // 获取所有正在等待许可的线程集合 Collection<Thread> getQueuedThreads()\",\"另外，在Semaphore的构造方法中还支持指定是够具有公平性，默认的是非公平性，这样也是为了保证吞吐量。\",\"一个例子\",\"下面用一个简单的例子来说明 Semaphore 的具体使用。\",\"我们来模拟这样一样场景：\",\"有一天，班主任需要班上 10 个同学到讲台上来填写一个表格，但是老师只准备了 5 支笔，因此，只能保证同时只有 5 个同学能够拿到笔并填写表格，没有获取到笔的同学只能够等前面的同学用完之后，才能拿到笔去填写表格。该示例代码如下：\",\"public class SemaphoreDemo { // 表示老师只有10支笔 private static Semaphore semaphore = new Semaphore(5); public static void main(String[] args) { // 表示50个学生 ExecutorService service = Executors.newFixedThreadPool(10); for (int i = 0; i < 10; i++) { service.execute(() -> { try { System.out.println(Thread.currentThread().getName() + \\\" 同学准备获取笔......\\\"); semaphore.acquire(); System.out.println(Thread.currentThread().getName() + \\\" 同学获取到笔\\\"); System.out.println(Thread.currentThread().getName() + \\\" 填写表格ing.....\\\"); TimeUnit.SECONDS.sleep(3); semaphore.release(); System.out.println(Thread.currentThread().getName() + \\\" 填写完表格，归还了笔！！！！！！\\\"); } catch (InterruptedException e) { e.printStackTrace(); } }); } service.shutdown(); } }\",\"输出结果：\",\"pool-1-thread-1 同学准备获取笔...... pool-1-thread-1 同学获取到笔 pool-1-thread-1 填写表格ing..... pool-1-thread-2 同学准备获取笔...... pool-1-thread-2 同学获取到笔 pool-1-thread-2 填写表格ing..... pool-1-thread-3 同学准备获取笔...... pool-1-thread-4 同学准备获取笔...... pool-1-thread-3 同学获取到笔 pool-1-thread-4 同学获取到笔 pool-1-thread-4 填写表格ing..... pool-1-thread-3 填写表格ing..... pool-1-thread-5 同学准备获取笔...... pool-1-thread-5 同学获取到笔 pool-1-thread-5 填写表格ing..... pool-1-thread-6 同学准备获取笔...... pool-1-thread-7 同学准备获取笔...... pool-1-thread-8 同学准备获取笔...... pool-1-thread-9 同学准备获取笔...... pool-1-thread-10 同学准备获取笔...... pool-1-thread-4 填写完表格，归还了笔！！！！！！ pool-1-thread-9 同学获取到笔 pool-1-thread-9 填写表格ing..... pool-1-thread-5 填写完表格，归还了笔！！！！！！ pool-1-thread-7 同学获取到笔 pool-1-thread-7 填写表格ing..... pool-1-thread-8 同学获取到笔 pool-1-thread-8 填写表格ing..... pool-1-thread-1 填写完表格，归还了笔！！！！！！ pool-1-thread-6 同学获取到笔 pool-1-thread-6 填写表格ing..... pool-1-thread-3 填写完表格，归还了笔！！！！！！ pool-1-thread-2 填写完表格，归还了笔！！！！！！ pool-1-thread-10 同学获取到笔 pool-1-thread-10 填写表格ing..... pool-1-thread-7 填写完表格，归还了笔！！！！！！ pool-1-thread-9 填写完表格，归还了笔！！！！！！ pool-1-thread-8 填写完表格，归还了笔！！！！！！ pool-1-thread-6 填写完表格，归还了笔！！！！！！ pool-1-thread-10 填写完表格，归还了笔！！！！！！\",\"根据输出结果进行分析，Semaphore 允许的最大许可数为 5，也就是允许的最大并发执行的线程个数为 5。\",\"可以看出，前 5 个线程（前 5 个学生）先获取到笔，然后填写表格，而 6−10 这 5 个线程，由于获取不到许可，只能阻塞等待。当线程 pool-1-thread-4 释放了许可之后，pool-1-thread-9 就可以获取到许可，继续往下执行。对其他线程的执行过程，也是同样的道理。\",\"从这个例子就可以看出，Semaphore 用来做特殊资源的并发访问控制是相当合适的，如果有业务场景需要进行流量控制，可以优先考虑 Semaphore。\"]},\"1399\":{\"h\":\"2. 线程间交换数据的工具 —— Exchanger\",\"t\":[\"Exchanger 是一个用于线程间协作的工具类，用于两个线程间能够交换。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。\",\"具体交换数据是通过 exchange 方法来实现的，如果一个线程先执行 exchange 方法，那么它会同步等待另一个线程也执行 exchange 方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。\",\"Exchanger 除了一个无参的构造方法外，主要方法也很简单：\",\"// 当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点 // 将数据交换给另一个线程，同时返回获取的数据 V exchange(V x) throws InterruptedException // 同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间 V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException\",\"一个例子\",\"Exchanger 理解起来很容易，这里用一个简单的例子来看下它的具体使用。\",\"我们来模拟这样一个情景，在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩子送情书（相信大家都做过这样的事情吧）。男孩会先到女孩教室门口，然后等女孩出来，教室那里就是一个同步点，然后彼此交换信物，也就是彼此交换了数据。现在，就来模拟这个情景。\",\"public class ExchangerDemo { private static Exchanger<String> exchanger = new Exchanger(); public static void main(String[] args) { // 代表男生和女生 ExecutorService service = Executors.newFixedThreadPool(2); service.execute(() -> { try { // 男生对女生说的话 String girl = exchanger.exchange(\\\"我其实暗恋你很久了......\\\"); System.out.println(\\\"女孩儿说：\\\" + girl); } catch (InterruptedException e) { e.printStackTrace(); } }); service.execute(() -> { try { System.out.println(\\\"女生慢慢的地从教室走出来......\\\"); TimeUnit.SECONDS.sleep(3); // 女生对男生说的话 String boy = exchanger.exchange(\\\"我也很喜欢你......\\\"); System.out.println(\\\"男孩儿说：\\\" + boy); } catch (InterruptedException e) { e.printStackTrace(); } }); } }\",\"输出结果：\",\"女生慢慢地从教室走出来...... 男孩儿说：我其实暗恋你很久了...... 女孩儿说：我也很喜欢你......\",\"这个例子很简单，也很能说明 Exchanger 的基本使用。男女生说的话和定义时的不一样，即发生了数据交换。\",\"当两个线程都到达调用 exchange 方法的同步点的时候，两个线程就能交换彼此的数据。\"]},\"1400\":{\"c\":[\"并发编程\"]},\"1401\":{\"c\":[\"JUC\"]},\"1402\":{\"h\":\"一篇文章彻底弄懂生产者 - 消费者问题\",\"t\":[\"生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。所谓生产者-消费者问题，实际上主要是包含了两类线程：一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据。为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。\",\"但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：\",\"如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；\",\"如果共享数据区为空的话，阻塞消费者继续消费数据。\",\"在实现生产者-消费者问题时，可以采用三种方式：\",\"使用 Object 的 wait/notify 的消息通知机制；\",\"使用 Lock 的 Condition 的 await/signal 的消息通知机制；\",\"使用 BlockingQueue 实现。\",\"本文主要将这三种实现方式进行总结归纳。\"]},\"1403\":{\"h\":\"1. wait/notify 的消息通知机制\"},\"1404\":{\"h\":\"1.1 预备知识\",\"t\":[\"Java 中，可以通过配合调用 Object 对象的 wait() 方法和 notify() 方法或 notifyAll() 方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞当前线程，直至等到其他线程调用了调用 notify() 方法或 notifyAll() 方法进行通知之后，当前线程才能从 wait() 方法处返回，继续执行下面的操作。\",\"1. wait\",\"该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。\",\"在调用 wait() 之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法或同步块中调用 wait() 方法。调用 wait() 方法之后，当前线程会释放锁。如果调用 wait() 方法时，线程并未获取到锁的话，则会抛出 IllegalMonitorStateException 异常，这是一个 RuntimeException。如果再次获取到锁的话，当前线程才能从 wait() 方法处成功返回。\",\"2. notify\",\"该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用 notify() 时没有持有适当的锁，也会抛出 IllegalMonitorStateException。\",\"该方法任意从 WAITTING 状态的线程中挑选一个进行通知，使得调用 wait() 方法的线程从等待队列移入到同步队列中，等待有机会再一次获取到锁，从而使得调用 wait() 方法的线程能够从 wait() 方法处退出。\",\"调用 notify() 后，当前线程不会马上释放该对象锁，要等到程序退出同步块后，当前线程才会释放锁。\",\"3. notifyAll\",\"该方法与 notify() 方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 WAITTING 状态，使得他们全部从等待队列中移入到同步队列中去，等待下一次能够有机会获取到对象监视器锁。\"]},\"1405\":{\"h\":\"1.2 wait/notify 消息通知潜在的一些问题\"},\"1406\":{\"h\":\"1.2.1 notify 早期通知\",\"t\":[\"notify 通知的遗漏很容易理解，即 threadA 还没开始 wait 的时候，threadB 已经 notify 了，这样，threadB 通知是没有任何响应的，当 threadB 退出 synchronized 代码块后，threadA 再开始 wait，便会一直阻塞等待，直到被别的线程打断。\",\"比如在下面的示例代码中，就模拟出 notify 早期通知带来的问题：\",\"public class EarlyNotify { private static String lockObject = \\\"\\\"; public static void main(String[] args) { WaitThread waitThread = new WaitThread(lockObject); NotifyThread notifyThread = new NotifyThread(lockObject); notifyThread.start(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } waitThread.start(); } static class WaitThread extends Thread { private String lock; public WaitThread(String lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { try { System.out.println(Thread.currentThread().getName() + \\\" 进去代码块\\\"); System.out.println(Thread.currentThread().getName() + \\\" 开始wait\\\"); lock.wait(); System.out.println(Thread.currentThread().getName() + \\\" 结束wait\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } static class NotifyThread extends Thread { private String lock; public NotifyThread(String lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { System.out.println(Thread.currentThread().getName() + \\\" 进去代码块\\\"); System.out.println(Thread.currentThread().getName() + \\\" 开始notify\\\"); lock.notify(); System.out.println(Thread.currentThread().getName() + \\\" 结束开始notify\\\"); } } } }\",\"示例中开启了两个线程，一个是 WaitThread，另一个是 NotifyThread。NotifyThread 会先启动，先调用 notify 方法。然后 WaitThread 线程才启动，调用 wait 方法，但是由于通知过了，wait 方法就无法再获取到相应的通知，因此 WaitThread 会一直在 wait 方法处阻塞，这种现象就是通知过早的现象。\",\"针对这种现象，解决方法，一般是添加一个状态标志，让 waitThread 调用 wait 方法前先判断状态是否已经改变，如果通知早已发出的话，WaitThread 就不再去 wait。\",\"对上面的代码进行更正：\",\"public class EarlyNotify { private static String lockObject = \\\"\\\"; private static boolean isWait = true; public static void main(String[] args) { WaitThread waitThread = new WaitThread(lockObject); NotifyThread notifyThread = new NotifyThread(lockObject); notifyThread.start(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } waitThread.start(); } static class WaitThread extends Thread { private String lock; public WaitThread(String lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { try { while (isWait) { System.out.println(Thread.currentThread().getName() + \\\" 进去代码块\\\"); System.out.println(Thread.currentThread().getName() + \\\" 开始wait\\\"); lock.wait(); System.out.println(Thread.currentThread().getName() + \\\" 结束wait\\\"); } } catch (InterruptedException e) { e.printStackTrace(); } } } } static class NotifyThread extends Thread { private String lock; public NotifyThread(String lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { System.out.println(Thread.currentThread().getName() + \\\" 进去代码块\\\"); System.out.println(Thread.currentThread().getName() + \\\" 开始notify\\\"); lock.notifyAll(); isWait = false; System.out.println(Thread.currentThread().getName() + \\\" 结束开始notify\\\"); } } } }\",\"这段代码只是增加了一个 isWait 状态变量，NotifyThread 调用 notify 方法后会对状态变量进行更新，在 WaitThread 中调用 wait 方法之前会先对状态变量进行判断。在该示例中，调用 notify 后将状态变量 isWait 改变为 false，因此，在 WaitThread 中 while 对 isWait 判断后就不会执行 wait 方法，从而避免了 Notify 过早通知造成遗漏的情况。\",\"等待/通知机制总结一\",\"在使用线程的等待/通知机制时，一般都要配合一个 boolean 变量值（或者其他能够判断真假的条件），在 notify 之前改变该 boolean 变量的值，让 wait 返回后能够退出 while 循环（一般都要在 wait 方法外围加一层 while 循环，以防止早期通知），或在通知被遗漏后，不会被阻塞在 wait 方法处。这样便保证了程序的正确性。\"]},\"1407\":{\"h\":\"1.2.2 等待 wait 的条件发生变化\",\"t\":[\"如果线程在等待时接受到了通知，但是之后等待的条件发生了变化，并没有再次对等待条件进行判断，也会导致程序出现错误。\",\"下面用一个例子来说明这种情况：\",\"public class ConditionChange { private static List<String> lockObject = new ArrayList(); public static void main(String[] args) { Consumer consumer1 = new Consumer(lockObject); Consumer consumer2 = new Consumer(lockObject); Productor productor = new Productor(lockObject); consumer1.start(); consumer2.start(); productor.start(); } static class Consumer extends Thread { private List<String> lock; public Consumer(List lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { try { // 这里使用if的话，就会存在wait条件变化造成程序错误的问题 if (lock.isEmpty()) { System.out.println(Thread.currentThread().getName() + \\\" list为空\\\"); System.out.println(Thread.currentThread().getName() + \\\" 调用wait方法\\\"); lock.wait(); System.out.println(Thread.currentThread().getName() + \\\" wait方法结束\\\"); } String element = lock.remove(0); System.out.println(Thread.currentThread().getName() + \\\" 取出第一个元素为：\\\" + element); } catch (InterruptedException e) { e.printStackTrace(); } } } } static class Productor extends Thread { private List<String> lock; public Productor(List lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { System.out.println(Thread.currentThread().getName() + \\\" 开始添加元素\\\"); lock.add(Thread.currentThread().getName()); lock.notifyAll(); } } } }\",\"会报异常：\",\"Exception in thread \\\"Thread-1\\\" Thread-0 list为空 Thread-0 调用wait方法 Thread-1 list为空 Thread-1 调用wait方法 Thread-2 开始添加元素 Thread-1 wait方法结束 java.lang.IndexOutOfBoundsException: Index: 0, Size: 0\",\"异常原因分析：\",\"在这个例子中一共开启了 3 个线程：Consumer1，Consumer2 以及 Productor。\",\"首先 consumer1 调用了 wait 方法后，线程处于 WAITTING 状态，并且将对象锁释放出来。接着，consumer2能够获取对象锁，从而进入到同步代块中，当执行到 wait 方法时，同样的也会释放对象锁。再然后，productor 能够获取到对象锁，进入到同步代码块中，向 list 中插入数据后，通过 notifyAll 方法通知处于 WAITING 状态的 consumer1 和 consumer2 线程。consumer1 得到对象锁后，从 wait 方法出退出，删除了一个元素让 list 为空，方法执行结束，退出同步块，释放掉对象锁。这个时候 consumer2 获取到对象锁后，从 wait 方法退出，继续往下执行，这个时候 consumer2 再执行 lock.remove(0) 就会出错，因为 list 由于 consumer1 删除一个元素之后已经为空了。\",\"解决方案：通过上面的分析，可以看出 consumer2 报异常是因为线程从 wait 方法退出之后没有再次对 wait 条件进行判断，因此，此时的 wait 条件已经发生了变化。解决办法就是，在 wait 退出之后再对条件进行判断即可。\",\"public class ConditionChange { private static List<String> lockObject = new ArrayList(); public static void main(String[] args) { Consumer consumer1 = new Consumer(lockObject); Consumer consumer2 = new Consumer(lockObject); Productor productor = new Productor(lockObject); consumer1.start(); consumer2.start(); productor.start(); } static class Consumer extends Thread { private List<String> lock; public Consumer(List lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { try { // 这里使用if的话，就会存在wait条件变化造成程序错误的问题 while (lock.isEmpty()) { System.out.println(Thread.currentThread().getName() + \\\" list为空\\\"); System.out.println(Thread.currentThread().getName() + \\\" 调用wait方法\\\"); lock.wait(); System.out.println(Thread.currentThread().getName() + \\\" wait方法结束\\\"); } String element = lock.remove(0); System.out.println(Thread.currentThread().getName() + \\\" 取出第一个元素为：\\\" + element); } catch (InterruptedException e) { e.printStackTrace(); } } } } static class Productor extends Thread { private List<String> lock; public Productor(List lock) { this.lock = lock; } @Override public void run() { synchronized (lock) { System.out.println(Thread.currentThread().getName() + \\\" 开始添加元素\\\"); lock.add(Thread.currentThread().getName()); lock.notifyAll(); } } } }\",\"上面的代码与之前的代码仅仅只是将 wait 外围的 if 语句改为 while 循环即可，这样当 list 为空时，线程便会继续等待，而不会继续去执行删除 list 中元素的代码。\",\"等待/通知机制总结二\",\"在使用线程的等待/通知机制时，一般都要在 while 循环中调用 wait() 方法，因此需要配合使用一个 boolean 变量（或其他能判断真假的条件，如本文中的 list.isEmpty()），满足 while 循环的条件时，进入 while 循环，执行 wait() 方法，不满足 while 循环的条件时，跳出循环，执行后面的代码。\"]},\"1408\":{\"h\":\"1.2.3 “假死” 状态**\",\"t\":[\"现象：如果是多消费者和多生产者情况，使用 notify 方法可能会出现 “假死” 的情况，即唤醒的是同类线程。\",\"原因分析：假设当前多个生产者线程会调用 wait 方法阻塞等待，当其中的生产者线程获取到对象锁之后使用 notify 通知处于 WAITTING 状态的线程，如果唤醒的仍然是生产者线程，就会造成所有的生产者线程都处于等待状态。\",\"解决办法：将 notify 方法替换成 notifyAll 方法，如果使用的是 lock 的话，就将 signal 方法替换成 signalAll 方法。\",\"等待/通知机制总结三\",\"在 Object 提供的消息通知机制应该遵循以下条件：\",\"永远在 while 循环中对条件进行判断，而不是在 if 语句中进行 wait 条件的判断；\",\"使用 NotifyAll 而不是使用 notify。\",\"基本的使用范式如下：\",\"// The standard idiom for calling the wait method in Java synchronized (sharedObject) { while (condition) { sharedObject.wait(); // (Releases lock, and reacquires on wakeup) } // do action based upon condition e.g. take or put into queue }\"]},\"1409\":{\"h\":\"1.3 wait/notifyAll 实现生产者-消费者\",\"t\":[\"利用 wait/notifyAll 实现生产者和消费者代码如下：\",\"public class ProductorConsumer { public static void main(String[] args) { LinkedList linkedList = new LinkedList(); ExecutorService service = Executors.newFixedThreadPool(15); for (int i = 0; i < 5; i++) { service.submit(new Productor(linkedList, 8)); } for (int i = 0; i < 10; i++) { service.submit(new Consumer(linkedList)); } } static class Productor implements Runnable { private List<Integer> list; private int maxLength; public Productor(List list, int maxLength) { this.list = list; this.maxLength = maxLength; } @Override public void run() { while (true) { synchronized (list) { try { while (list.size() == maxLength) { System.out.println(\\\"生产者\\\" + Thread.currentThread().getName() + \\\" list以达到最大容量，进行wait\\\"); list.wait(); System.out.println(\\\"生产者\\\" + Thread.currentThread().getName() + \\\" 退出wait\\\"); } Random random = new Random(); int i = random.nextInt(); System.out.println(\\\"生产者\\\" + Thread.currentThread().getName() + \\\" 生产数据\\\" + i); list.add(i); list.notifyAll(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } static class Consumer implements Runnable { private List<Integer> list; public Consumer(List list) { this.list = list; } @Override public void run() { while (true) { synchronized (list) { try { while (list.isEmpty()) { System.out.println(\\\"消费者\\\" + Thread.currentThread().getName() + \\\" list为空，进行wait\\\"); list.wait(); System.out.println(\\\"消费者\\\" + Thread.currentThread().getName() + \\\" 退出wait\\\"); } Integer element = list.remove(0); System.out.println(\\\"消费者\\\" + Thread.currentThread().getName() + \\\" 消费数据：\\\" + element); list.notifyAll(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } }\",\"输出结果：\",\"生产者pool-1-thread-1 生产数据-232820990 生产者pool-1-thread-1 生产数据1432164130 生产者pool-1-thread-1 生产数据1057090222 生产者pool-1-thread-1 生产数据1201395916 生产者pool-1-thread-1 生产数据482766516 生产者pool-1-thread-1 list以达到最大容量，进行wait 消费者pool-1-thread-15 退出wait 消费者pool-1-thread-15 消费数据：1237535349 消费者pool-1-thread-15 消费数据：-1617438932 消费者pool-1-thread-15 消费数据：-535396055 消费者pool-1-thread-15 消费数据：-232820990 消费者pool-1-thread-15 消费数据：1432164130 消费者pool-1-thread-15 消费数据：1057090222 消费者pool-1-thread-15 消费数据：1201395916 消费者pool-1-thread-15 消费数据：482766516 消费者pool-1-thread-15 list为空，进行wait 生产者pool-1-thread-5 退出wait 生产者pool-1-thread-5 生产数据1442969724 生产者pool-1-thread-5 生产数据1177554422 生产者pool-1-thread-5 生产数据-133137235 生产者pool-1-thread-5 生产数据324882560 生产者pool-1-thread-5 生产数据2065211573 生产者pool-1-thread-5 生产数据253569900 生产者pool-1-thread-5 生产数据571277922 生产者pool-1-thread-5 生产数据1622323863 生产者pool-1-thread-5 list以达到最大容量，进行wait 消费者pool-1-thread-10 退出wait\"]},\"1410\":{\"h\":\"2. 使用 Lock 中 Condition 的 await/signalAll 实现生产者-消费者\",\"t\":[\"参照 Object 的 wait 和 notify/notifyAll方法，Condition 也提供了同样的方法：\",\"针对 wait 方法\",\"void await() throws InterruptedException：当前线程进入等待状态，如果其他线程调用 condition 的 signal 或者 signalAll 方法并且当前线程获取 Lock 从 await 方法返回，如果在等待状态中被中断会抛出被中断异常。\",\"long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时。\",\"boolean await(long time, TimeUnit unit)throws InterruptedException：同第二种，支持自定义时间单位。\",\"boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间。\",\"针对 notify 方法\",\"void signal()：唤醒一个等待在 condition 上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。\",\"void signalAll()：与第一种的区别在于能够唤醒所有等待在 condition 上的线程。\",\"也就是说 wait -> await，notify -> Signal。关于 lock 中 condition 消息通知的原理解析可以看这篇文章。\",\"如果采用 lock 中 Conditon 的消息通知原理来实现生产者-消费者问题，原理同使用 wait/notifyAll 一样。直接上代码：\",\"public class ProductorConsumer { private static ReentrantLock lock = new ReentrantLock(); private static Condition full = lock.newCondition(); private static Condition empty = lock.newCondition(); public static void main(String[] args) { LinkedList linkedList = new LinkedList(); ExecutorService service = Executors.newFixedThreadPool(15); for (int i = 0; i < 5; i++) { service.submit(new Productor(linkedList, 8, lock)); } for (int i = 0; i < 10; i++) { service.submit(new Consumer(linkedList, lock)); } } static class Productor implements Runnable { private List<Integer> list; private int maxLength; private Lock lock; public Productor(List list, int maxLength, Lock lock) { this.list = list; this.maxLength = maxLength; this.lock = lock; } @Override public void run() { while (true) { lock.lock(); try { while (list.size() == maxLength) { System.out.println(\\\"生产者\\\" + Thread.currentThread().getName() + \\\" list以达到最大容量，进行wait\\\"); full.await(); System.out.println(\\\"生产者\\\" + Thread.currentThread().getName() + \\\" 退出wait\\\"); } Random random = new Random(); int i = random.nextInt(); System.out.println(\\\"生产者\\\" + Thread.currentThread().getName() + \\\" 生产数据\\\" + i); list.add(i); empty.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } } static class Consumer implements Runnable { private List<Integer> list; private Lock lock; public Consumer(List list, Lock lock) { this.list = list; this.lock = lock; } @Override public void run() { while (true) { lock.lock(); try { while (list.isEmpty()) { System.out.println(\\\"消费者\\\" + Thread.currentThread().getName() + \\\" list为空，进行wait\\\"); empty.await(); System.out.println(\\\"消费者\\\" + Thread.currentThread().getName() + \\\" 退出wait\\\"); } Integer element = list.remove(0); System.out.println(\\\"消费者\\\" + Thread.currentThread().getName() + \\\" 消费数据：\\\" + element); full.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } } }\",\"输出结果：\",\"消费者pool-1-thread-9 消费数据：1146627506 消费者pool-1-thread-9 消费数据：1508001019 消费者pool-1-thread-9 消费数据：-600080565 消费者pool-1-thread-9 消费数据：-1000305429 消费者pool-1-thread-9 消费数据：-1270658620 消费者pool-1-thread-9 消费数据：1961046169 消费者pool-1-thread-9 消费数据：-307680655 消费者pool-1-thread-9 list为空，进行wait 消费者pool-1-thread-13 退出wait 消费者pool-1-thread-13 list为空，进行wait 消费者pool-1-thread-10 退出wait 生产者pool-1-thread-5 退出wait 生产者pool-1-thread-5 生产数据-892558288 生产者pool-1-thread-5 生产数据-1917220008 生产者pool-1-thread-5 生产数据2146351766 生产者pool-1-thread-5 生产数据452445380 生产者pool-1-thread-5 生产数据1695168334 生产者pool-1-thread-5 生产数据1979746693 生产者pool-1-thread-5 生产数据-1905436249 生产者pool-1-thread-5 生产数据-101410137 生产者pool-1-thread-5 list以达到最大容量，进行wait 生产者pool-1-thread-1 退出wait 生产者pool-1-thread-1 list以达到最大容量，进行wait 生产者pool-1-thread-4 退出wait 生产者pool-1-thread-4 list以达到最大容量，进行wait 生产者pool-1-thread-2 退出wait 生产者pool-1-thread-2 list以达到最大容量，进行wait 生产者pool-1-thread-3 退出wait 生产者pool-1-thread-3 list以达到最大容量，进行wait 消费者pool-1-thread-9 退出wait 消费者pool-1-thread-9 消费数据：-892558288\"]},\"1411\":{\"h\":\"3. 使用 BlockingQueue 实现生产者-消费者\",\"t\":[\"由于 BlockingQueue 内部实现就附加了两个阻塞操作，即：\",\"当队列已满时，阻塞向队列中插入数据的线程，直至队列中未满；\",\"当队列为空时，阻塞从队列中获取数据的线程，直至队列非空时为止。\",\"关于 BlockingQueue 更多细节可以看这篇文章。\",\"可以利用 BlockingQueue 实现生产者-消费者问题，阻塞队列完全可以充当共享数据区域，就可以很好的完成生产者和消费者线程之间的协作。\",\"public class ProductorConsumer { private static LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>(); public static void main(String[] args) { ExecutorService service = Executors.newFixedThreadPool(15); for (int i = 0; i < 5; i++) { service.submit(new Productor(queue)); } for (int i = 0; i < 10; i++) { service.submit(new Consumer(queue)); } } static class Productor implements Runnable { private BlockingQueue queue; public Productor(BlockingQueue queue) { this.queue = queue; } @Override public void run() { try { while (true) { Random random = new Random(); int i = random.nextInt(); System.out.println(\\\"生产者\\\" + Thread.currentThread().getName() + \\\"生产数据\\\" + i); queue.put(i); } } catch (InterruptedException e) { e.printStackTrace(); } } } static class Consumer implements Runnable { private BlockingQueue queue; public Consumer(BlockingQueue queue) { this.queue = queue; } @Override public void run() { try { while (true) { Integer element = (Integer) queue.take(); System.out.println(\\\"消费者\\\" + Thread.currentThread().getName() + \\\"正在消费数据\\\" + element); } } catch (InterruptedException e) { e.printStackTrace(); } } } }\",\"输出结果：\",\"消费者pool-1-thread-7正在消费数据1520577501 生产者pool-1-thread-4生产数据-127809610 消费者pool-1-thread-8正在消费数据504316513 生产者pool-1-thread-2生产数据1994678907 消费者pool-1-thread-11正在消费数据1967302829 生产者pool-1-thread-1生产数据369331507 消费者pool-1-thread-9正在消费数据1994678907 生产者pool-1-thread-2生产数据-919544017 消费者pool-1-thread-12正在消费数据-127809610 生产者pool-1-thread-4生产数据1475197572 消费者pool-1-thread-14正在消费数据-893487914 生产者pool-1-thread-3生产数据906921688 消费者pool-1-thread-6正在消费数据-1292015016 生产者pool-1-thread-5生产数据-652105379 生产者pool-1-thread-5生产数据-1622505717 生产者pool-1-thread-3生产数据-1350268764 消费者pool-1-thread-7正在消费数据906921688 生产者pool-1-thread-4生产数据2091628867 消费者pool-1-thread-13正在消费数据1475197572 消费者pool-1-thread-15正在消费数据-919544017 生产者pool-1-thread-2生产数据564860122 生产者pool-1-thread-2生产数据822954707 消费者pool-1-thread-14正在消费数据564860122 消费者pool-1-thread-10正在消费数据369331507 生产者pool-1-thread-1生产数据-245820912 消费者pool-1-thread-6正在消费数据822954707 生产者pool-1-thread-2生产数据1724595968 生产者pool-1-thread-2生产数据-1151855115 消费者pool-1-thread-12正在消费数据2091628867 生产者pool-1-thread-4生产数据-1774364499 生产者pool-1-thread-4生产数据2006106757 消费者pool-1-thread-14正在消费数据-1774364499 生产者pool-1-thread-3生产数据-1070853639 消费者pool-1-thread-9正在消费数据-1350268764 消费者pool-1-thread-11正在消费数据-1622505717 生产者pool-1-thread-5生产数据355412953\",\"可以看出，使用 BlockingQueue 来实现生产者-消费者很简洁，这正是利用了 BlockingQueue 插入和获取数据附加阻塞操作的特性。\",\"关于生产者-消费者实现的三种方式，已全部总结完成。\",\"本篇也是 JUC 并发编程系列的结尾篇，希望能对在看的朋友有所帮助~\"]},\"1412\":{\"c\":[\"并发编程\"]},\"1413\":{\"c\":[\"JUC\"]},\"1414\":{\"h\":\"Java 内存模型及 happens-before\"},\"1415\":{\"h\":\"1. JMM 介绍\",\"t\":[\"什么是线程安全？\",\"关于线程安全问题，《深入理解Java虚拟机》中给出的定义如下：\",\"当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象就是线程安全的。\",\"出现线程安全的问题一般是因为主内存和工作内存数据不一致性和重排序导致的，而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，其核心在于理解 java 内存模型（JMM）。\",\"在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等，另外，为了性能优化，还会涉及到编译器指令重排序和处理器指令重排序。\"]},\"1416\":{\"h\":\"2. 线程通信\",\"t\":[\"线程间协作通信可以类比人与人之间的协作的方式。\",\"在现实生活中，网上有个流行语 “你妈喊你回家吃饭了”，就以这个生活场景为例，小明在外面玩耍，小明妈妈在家里做饭，做晚饭后准备叫小明回家吃饭，那么就存在两种方式：\",\"一种方式是：小明妈妈要去上班了十分紧急这个时候手机又没有电了，于是就在桌子上贴了一张纸条 “饭做好了，放在...”。小明回家后看到纸条如愿吃到妈妈做的饭菜，那么，如果将小明妈妈和小明作为两个线程，那么这张纸条就是这两个线程间通信的共享变量，通过读写共享变量实现两个线程间协作；\",\"另一种方式是：妈妈的手机还有电，妈妈在赶去坐公交的路上给小明打了个电话，这种方式就是通知机制来完成协作。同样，可以引申到线程间通信机制。\",\"通过上面的例子，大概有个了解。在并发编程中主要需要解决两个问题：\",\"线程之间如何通信；\",\"线程之间如何完成同步（这里的线程指的是并发执行的活动实体）。\",\"通信是指线程之间以何种机制来交换信息，主要有两种：共享内存和消息传递。\",\"java 内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量来完成隐式通信。\",\"哪些是共享变量\",\"在java程序中所有实例域，静态域和数组元素都是放在堆内存中（所有线程均可访问到，是可以共享的）；\",\"而局部变量，方法定义参数和异常处理器参数不会在线程间共享。\",\"共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题。\"]},\"1417\":{\"h\":\"3. JMM 抽象结构模型\",\"t\":[\"我们知道 CPU 的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个 CPU 都会有缓存。因此，共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。JMM 就从抽象层次定义了这种方式，并且 JMM 决定了一个线程对共享变量的写入何时对其他线程是可见的。\",\"如上图为 JMM 抽象示意图，线程 A 和线程 B 之间要完成通信的话，要经历如下两步：\",\"线程 A 从主内存中将共享变量读入线程 A 的工作内存后并进行操作，之后将数据重新写回到主内存中\",\"线程 B 从主存中读取最新的共享变量\",\"从横向上看，线程 A 和线程 B 就好像通过共享变量在进行隐式通信。\",\"这其中有一个问题，如果线程 A 更新后数据并没有及时写回到主存，而此时线程 B 读到的是过期的数据，这就出现了 “脏读” 现象。针对这种情况，可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过 volatile 关键字使得每次 volatile 变量都能够强制刷新到主存，从而对每个线程都是可见的。\"]},\"1418\":{\"h\":\"4. 重排序\",\"t\":[\"一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。JMM 对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\",\"编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序\",\"指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序\",\"内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。\",\"如图，1 属于编译器重排序，而 2 和 3 统称为处理器重排序。这些重排序会导致线程安全的问题，一个很经典的例子就是 DCL 问题。\",\"针对编译器重排序，JMM 的编译器重排序规则会禁止一些特定类型的编译器重排序；\",\"针对处理器重排序，编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序。\",\"那么什么情况下，不能进行重排序？比如数据依赖性。有如下代码：\",\"double pi = 3.14 //A double r = 1.0 //B double area = pi * r * r //C\",\"这是一个计算圆面积的代码，由于 A，B 之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是 A->B->C 或者 B->A->C，执行最终结果都是 3.14，即 A 和 B 之间没有数据依赖性。具体的定义为：\",\"**如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性。**这里就存在三种情况：\",\"读后写；\",\"写后写；\",\"写后读。\",\"这三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。\",\"另外，还有一个比较有意思的就是 as-if-serial 语义。\",\"as-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。比如上面计算圆面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行上，实际上 A，B 两行不存在数据依赖性可能会进行重排序，即 A，B 不是顺序执行的。as-if-serial 语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。\"]},\"1419\":{\"h\":\"5. happens-before 规则\",\"t\":[\"上面的重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM 为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。下面以两个方面来说。\"]},\"1420\":{\"h\":\"5.1 happens-before 定义\",\"t\":[\"happens-before 的概念最初由 Leslie Lamport 提出。JSR-133 使用 happens-before 的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证（如果 A 线程的写操作 a 与 B 线程的读操作 b 之间存在 happens-before 关系，尽管 a 操作和 b 操作在不同的线程中执行，但 JMM 向程序员保证 a 操作将对 b 操作可见）。具体的定义为：\",\"如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\",\"两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM 允许这种重排序）。\",\"上面的第 1 点是 JMM 对程序员的承诺。从程序员的角度来说，可以这样理解 happens-before 关系：如果A happens-before B，那么 Java 内存模型将向程序员保证 —— A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。注意，这只是 Java 内存模型向程序员做出的保证！\",\"上面的第 2 点是 JMM 对编译器和处理器重排序的约束原则。正如前面所言，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM 这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before 关系本质上和 as-if-serial 语义是一回事。\",\"as-if-serial VS happens-before\",\"as-if-serial 语义保证单线程内程序的执行结果不被改变，happens-before 关系保证正确同步的多线程程序的执行结果不被改变。\",\"as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。\",\"as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\"]},\"1421\":{\"h\":\"5.2 具体规则\",\"t\":[\"具体的一共有六项规则：\",\"程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。\",\"监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\",\"volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\",\"传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。\",\"start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作。\",\"join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。\",\"程序中断规则：对线程 interrupted() 方法的调用先行于被中断线程的代码检测到中断时间的发生。\",\"对象 finalize 规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的 finalize() 方法的开始。\",\"下面以一个具体的例子来讲下如何使用这些规则进行推论：\",\"依旧以上面计算圆面积的进行描述。利用程序顺序规则（规则1）存在三个 happens-before 关系：\",\"A happens-before B；\",\"B happens-before C；\",\"A happens-before C。\",\"这里的第三个关系是利用传递性进行推论的。A happens-before B，定义 1 要求 A 执行结果对 B 可见，并且 A 操作的执行顺序在 B 操作之前，但与此同时利用定义中的第二条，A，B 操作彼此不存在数据依赖性，两个操作的执行顺序对最终结果都不会产生影响，在不改变最终结果的前提下，允许 A，B 两个操作重排序，即 happens-before 关系并不代表了最终的执行顺序。\"]},\"1422\":{\"h\":\"6. 总结\",\"t\":[\"我们从三个方面做个总结。\",\"如果让我们设计 JMM 应该从哪些方面考虑，也就是说 JMM 承担哪些功能\",\"happens-before 与 JMM 的关系\",\"由于 JMM，多线程情况下可能会出现哪些问题？\"]},\"1423\":{\"h\":\"6.1 JMM 的设计\",\"t\":[\"JMM 是语言级的内存模型，在我的理解中 JMM 处于中间层，包含了两个方面： （1）内存模型；（2）重排序以及 happens-before 规则。\",\"同时，为了禁止特定类型的重排序会对编译器和处理器指令序列加以控制。而上层会有基于 JMM 的关键字和 J.U.C 包下的一些具体类用来方便程序员能够迅速高效率的进行并发编程。站在 JMM 设计者的角度，在设计 JMM 时需要考虑两个关键因素:\",\"程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。\",\"编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。\",\"另外还要一个特别有意思的事情就是关于重排序问题，更简单的说，重排序可以分为两类：\",\"会改变程序执行结果的重排序。\",\"不会改变程序执行结果的重排序。\",\"JMM 对这两种不同性质的重排序，采取了不同的策略，如下。\",\"对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。\",\"对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不做要求（JMM 允许这种重排序）\",\"JMM的设计图为：\",\"从上图中可以看出：\",\"JMM 向程序员提供的 happens-before 规则能满足程序员的需求。 JMM 的 happens-before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A happens-before B）。\",\"JMM 对编译器和处理器的束缚已经尽可能少。 从上面的分析可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个 volatile 变量只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。\"]},\"1424\":{\"h\":\"6.2 happens-before 与 JMM 的关系\",\"t\":[\"一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。对于 Java 程序员来说，happens-before 规则简单易懂，它避免 Java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。\"]},\"1425\":{\"h\":\"6.3 今后可能需要关注的问题\",\"t\":[\"从上面内存抽象结构来说，可能出在数据 “脏读” 的现象，这就是数据可见性的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是 DCL（双重检验锁），这就是需要禁止重排序，另外，在多线程下原子操作例如 i++ 不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。\"]},\"1426\":{\"c\":[\"并发编程\"]},\"1427\":{\"c\":[\"JUC\"]},\"1428\":{\"h\":\"彻底理解 synchronized\"},\"1429\":{\"h\":\"1. synchronized 简介\",\"t\":[\"先看一个现象：\",\"public class SynchronizedDemo implements Runnable { private static int count = 0; public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(new SynchronizedDemo()); thread.start(); } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"result: \\\" + count); } @Override public void run() { for (int i = 0; i < 1000000; i++) count++; } }\",\"开启 10 个线程，每个线程都累加了 1000000 次，如果结果正确的话自然而然总数就应该是 10∗1000000=10000000。可无论运行多少次，结果都不是这个数，而且每次运行结果都不一样。这是为什么？有什么解决方案？\",\"在上一篇中我们已经了解了 java 内存模型的一些知识，并且已经知道出现线程安全的主要来源于 JMM 的设计，主要集中在主内存和线程的工作内存而导致的内存可见性问题，以及重排序导致的问题，进一步知道了 happens-before 规则。线程运行时拥有自己的栈空间，会在自己的栈空间运行，如果多线程间没有共享的数据也就是说多线程间并没有协作完成一件事情，那么，多线程就不能发挥优势，不能带来巨大的价值。那么共享数据的线程安全问题怎样处理？很自然而然的想法就是每一个线程依次去读写这个共享变量，这样就不会有任何数据安全的问题，因为每个线程所操作的都是当前最新的版本数据。\",\"那么，在 java 中关键字 synchronized 就具有使每个线程依次排队操作共享变量的功能。很显然，这种同步机制效率很低，但 synchronized 是其他并发容器实现的基础。\"]},\"1430\":{\"h\":\"2. synchronized 实现原理\",\"t\":[\"在 java 代码中 synchronized 可使用在代码块和方法中，根据 Synchronized 用的位置可以有这些使用场景：\",\"如图，synchronized 可以用在方法上也可以使用在代码块中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里的需要注意的是：如果锁的是类对象的话，尽管 new 多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系。\"]},\"1431\":{\"h\":\"2.1 对象锁（monitor）机制\",\"t\":[\"用一个简单的 demo 来看看 synchronized 的具体底层实现：\",\"public class SynchronizedDemo { public static void main(String[] args) { synchronized (SynchronizedDemo.class) { } method(); } private static void method() { } }\",\"上面的代码中有一个同步代码块，锁住的是类对象，并且还有一个同步静态方法，锁住的依然是该类的类对象。编译之后，切换到 SynchronizedDemo.class 的同级目录之后，然后用 javap -v SynchronizedDemo.class 查看字节码文件：\",\"SynchronizedDemo.class\",\"如图，上面用黄色高亮的部分就是需要注意的部分了，这也是添加 Synchronized 关键字之后独有的。执行同步代码块后首先要先执行 monitorenter 指令，退出的时候 monitorexit 指令。\",\"通过分析之后可以看出，使用 Synchronized 进行同步，其关键就是必须要对对象的监视器 monitor 进行获取，当线程获取 monitor 后才能继续往下执行，否则就只能等待。而这个获取的过程是互斥的，即同一时刻只有一个线程能够获取到 monitor。上面的 demo 中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗？答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条 monitorexit 指令，并没有 monitorenter 获取锁的指令。\",\"这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。Synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。\",\"任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到 BLOCKED 状态。\",\"下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：\",\"该图可以看出，任意线程对 Object 的访问，首先要获得 Object 的监视器，如果获取失败，该线程就进入同步状态，线程状态变为 BLOCKED，当 Object 的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。\"]},\"1432\":{\"h\":\"2.2 synchronized 的 happens-before 关系\",\"t\":[\"在上一篇讨论过 happens-before 规则，现在来看一看 Synchronized 的 happens-before 规则，即监视器锁规则：对同一个监视器的解锁，happens-before 于对该监视器的加锁。继续来看代码：\",\"public class MonitorDemo { private int a = 0; public synchronized void writer() { // 1 a++; // 2 } // 3 public synchronized void reader() { // 4 int i = a; // 5 } // 6 }\",\"该代码的 happens-before 关系如图所示：\",\"在图中每一个箭头连接的两个节点就代表之间的 happens-before 关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程 A 释放锁 happens-before 线程 B 加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来 happens-befor 关系，通过传递性规则进一步推导的 happens-before 关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么？\",\"根据 happens-before 的定义中的一条：如果 A happens-before B，则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B。线程 A 先对共享变量 A 进行加一，由 2 happens-before 5 关系可知线程 A 的执行结果对线程 B 可见即线程 B 所读取到的 a 的值为 1。\"]},\"1433\":{\"h\":\"2.3 锁获取和锁释放的内存语义\",\"t\":[\"在上一篇提到过 JMM 核心为两个部分：happens-before 规则以及内存抽象模型。我们分析完 Synchronized 的 happens-before 关系后，还是不太完整的，我们接下来看看基于 java 内存抽象模型的 Synchronized 的内存语义。\",\"继续先看图：\",\"从上图可以看出，线程 A 会首先先从主内存中读取共享变量 a = 0 的值然后将该变量拷贝到自己的本地内存，进行加一操作后，再将该值刷新到主内存，整个过程即为 线程 A 加锁 --> 执行临界区代码 --> 释放锁相对应的内存语义。\",\"线程 B 获取锁的时候同样会从主内存中共享变量 a 的值，这个时候就是最新的值 1，然后将该值拷贝到线程 B 的工作内存中去，释放锁的时候同样会重写到主内存中。\",\"从整体上来看，线程 A 的执行结果（a = 1）对线程 B 是可见的，实现原理为：释放锁的时候会将值刷新到主内存中，其他线程获取锁时会强制从主内存中获取最新的值。另外也验证了 2 happens-before 5，2 的执行结果对 5 是可见的。\",\"从横向来看，这就像线程 A 通过主内存中的共享变量和线程 B 进行通信，A 告诉 B 我们俩的共享数据现在为 1 啦，这种线程间的通信机制正好吻合 java 的内存模型正好是共享内存的并发模型结构。\"]},\"1434\":{\"h\":\"3. synchronized优化\",\"t\":[\"通过上面的讨论大概能了解 Synchronized了，它最大的特征就是在同一时刻只有一个线程能够获得对象的监视器（monitor），从而进入到同步代码块或者同步方法之中，即表现为互斥性（排它性）。\",\"这种方式肯定效率低下，每次只能通过一个线程，既然每次只能通过一个，这种形式不能改变的话，那么我们能不能让每次通过的速度变快一点了。打个比方，去收银台付款，之前的方式是，大家都去排队，然后去纸币付款收银员找零，有的时候付款的时候在包里拿出钱包再去拿出钱，这个过程是比较耗时的，然后，支付宝解放了大家去钱包找钱的过程，现在只需要扫描下就可以完成付款了，也省去了收银员跟你找零的时间了。同样是需要排队，但整个付款的时间大大缩短，是不是整体的效率变高速率变快了？这种优化方式同样可以引申到锁优化上，缩短获取锁的时间，伟大的科学家们也是这样做的，令人钦佩，毕竟 java 是这么优秀的语言😀。\",\"在聊到锁的优化也就是锁的几种状态前，有两个知识点需要先关注：（1）CAS操作 （2）Java对象头，这是理解下面知识的前提条件。\"]},\"1435\":{\"h\":\"3.1 CAS 操作\"},\"1436\":{\"h\":\"3.1.1 什么是 CAS？\",\"t\":[\"使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而 CAS 操作（又称为无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用 CAS(compare and swap)，又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。\"]},\"1437\":{\"h\":\"3.1.2 CAS 的操作过程\",\"t\":[\"CAS 比较交换的过程可以通俗的理解为 CAS(V, O, N)，包含三个值分别为：\",\"V 内存地址存放的实际值\",\"O 预期的值（旧值）\",\"N 更新的新值\",\"当 V 和 O 相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值 O 就是目前来说最新的值了，自然而然可以将新值 N 赋值给 V。反之，V 和 O 不相同，表明该值已经被其他线程改过了则该旧值 O 不是最新版本的值了，所以不能将新值 N 赋给 V，返回 V 即可。当多个线程使用 CAS 操作一个变量时，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。\",\"CAS 的实现需要硬件指令集的支撑，在 JDK1.5 后虚拟机才可以使用处理器提供的 CMPXCHG 指令实现。\",\"Synchronized VS CAS\",\"元老级的 Synchronized(未优化前) 最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。\",\"而 CAS 并不是武断的间线程挂起，当 CAS 操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。\"]},\"1438\":{\"h\":\"3.1.3 CAS 的应用场景\",\"t\":[\"在 J.U.C 包中利用 CAS 实现类有很多，可以说是支撑起整个 concurrency 包的实现，在 Lock 实现中会有 CAS 改变 state 变量，在 atomic 包中的实现类也几乎都是用 CAS 实现。\"]},\"1439\":{\"h\":\"3.1.4 CAS 的问题\",\"t\":[\"ABA 问题\",\"因为 CAS 会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值 A 变为了成 B，然后再变成 A，刚好在做 CAS 时检查发现旧值并没有变化依然为 A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径 A->B->A 就变成了 1A->2B->3C。java 这么优秀的语言，当然在 java 1.5 后的 atomic 包中提供了 AtomicStampedReference 来解决 ABA 问题了。\",\"自旋时间过长\",\"使用 CAS 时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果 JVM 能支持处理器提供的 pause 指令，那么在效率上会有一定的提升。\",\"只能保证一个共享变量的原子操作\",\"当对一个共享变量执行操作时 CAS 能保证其原子性，如果对多个共享变量进行操作，CAS 就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做 CAS 操作就可以保证其原子性。atomic 中提供了 AtomicReference 来保证引用对象之间的原子性。\"]},\"1440\":{\"h\":\"3.2 Java 对象头\",\"t\":[\"在同步的时候是获取对象的 monitor，即获取到对象的锁。\",\"那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在 Java 对象的对象头。\",\"Java 对象头里的 Mark Word 里默认的存放的对象的 Hashcode，分代年龄和锁标记位。32 位 JVM Mark Word 默认存储结构为：\",\"Mark Word 存储结构\",\"如图在 Mark Word 会默认存放 hasdcode，年龄值以及锁标志位等信息。\",\"JavaSE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。\",\"锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：\",\"Mark Word 状态变化\"]},\"1441\":{\"h\":\"3.3 偏向锁\",\"t\":[\"HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。\"]},\"1442\":{\"h\":\"3.3.1 偏向锁的获取\",\"t\":[\"当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。\"]},\"1443\":{\"h\":\"3.3.2 偏向锁的撤销\",\"t\":[\"偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。\",\"偏向锁撤销流程\",\"如上图，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。\",\"下图线程 1 展示了偏向锁获取的过程，线程 2 展示了偏向锁撤销的过程。\"]},\"1444\":{\"h\":\"3.3.3 如何关闭偏向锁\",\"t\":[\"偏向锁在 Java 6 和 Java 7 里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用 JVM 参数来关闭延迟：-XX:BiasedLockingStartupDelay = 0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking = false，那么程序默认会进入轻量级锁状态。\"]},\"1445\":{\"h\":\"3.4 轻量级锁\"},\"1446\":{\"h\":\"3.4.1 加锁\",\"t\":[\"线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\"]},\"1447\":{\"h\":\"3.4.2 解锁\",\"t\":[\"轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。\",\"下图是两个线程同时争夺锁，导致锁膨胀的流程图。\",\"因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。\"]},\"1448\":{\"h\":\"3.5 各种锁的比较\"},\"1449\":{\"h\":\"4. 一个例子\",\"t\":[\"经过上面的理解，对于文章开头的现象，就知道如何解决了：\",\"public class SynchronizedDemo implements Runnable { private static int count = 0; public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(new SynchronizedDemo()); thread.start(); } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"result: \\\" + count); } @Override public void run() { synchronized (SynchronizedDemo.class) { for (int i = 0; i < 1000000; i++) count++; } } }\",\"开启 10 个线程，每个线程在原值上累加 1000000 次，最终正确的结果为 10∗1000000=10000000，这里能够计算出正确的结果是因为在做累加操作时使用了同步代码块，这样就能保证每个线程所获得共享变量的值都是当前最新的值，如果不使用同步的话，就可能会出现 A 线程累加后，而 B 线程做累加操作有可能是使用原来的就值，即“脏值”。这样，就导致最终的计算结果不是正确的。\",\"而使用 Syncnized 就可以保证内存可见性，保证每个线程都是操作的最新值。\"]},\"1450\":{\"c\":[\"并发编程\"]},\"1451\":{\"c\":[\"JUC\"]},\"1452\":{\"h\":\"彻底理解 volatile\"},\"1453\":{\"h\":\"1. volatile 简介\",\"t\":[\"在上一篇文章中我们了解到 synchronized 是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而 volatile 就可以说是 java 虚拟机提供的最轻量级的同步机制。但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用 synchronized。\",\"Java 内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对 volatile 修饰的变量给 java 虚拟机特殊的约定，线程对 volatile 变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的 “可见性”。\",\"现在大概的理解就是：被 volatile 修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。\"]},\"1454\":{\"h\":\"2. volatile 实现原理\",\"t\":[\"volatile 是怎样实现了？比如一个很简单的 Java 代码：\",\"instance = new Instancce(); //instance是volatile变量\",\"在生成汇编代码时会在 volatile 修饰的共享变量进行写操作的时候会多出 Lock 前缀的指令（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。我们想这个 Lock 指令肯定有神奇的地方，那么 Lock 前缀的指令在多核处理器下会发现什么事情了？主要有这两个方面的影响：\",\"将当前处理器缓存行的数据写回系统内存\",\"这个写回内存的操作会使得其他 CPU 里缓存了该内存地址的数据无效\",\"为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。\",\"所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，经过分析我们可以得出如下结论：\",\"Lock 前缀的指令会引起处理器缓存写回内存；\",\"一个处理器的缓存回写到内存会导致其他处理器的缓存失效；\",\"当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\",\"这样针对 volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\"]},\"1455\":{\"h\":\"3. volatile 的 happens-before 关系\",\"t\":[\"经过上面的分析，我们已经知道了 volatile 变量可以通过缓存一致性协议保证每个线程都能获得最新值，即满足数据的 “可见性”。\",\"对并发分析的切入点可以分为 两个核心，三大性质。\",\"两个核心：JMM 内存模型（主内存和工作内存）以及 happens-before；\",\"三条性质：原子性，可见性，有序性。\",\"先来看两个核心之一：volatile 的 happens-before 关系。\",\"在六条 happens-before 规则中有一条是：volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个volatile域的读。\",\"下面我们结合具体的代码，我们利用这条规则推导下：\",\"public class VolatileExample { private int a = 0; private volatile boolean flag = false; public void writer(){ a = 1; //1 flag = true; //2 } public void reader(){ if (flag){ //3 int i = a; //4 } } }\",\"上面的实例代码对应的 happens-before 关系如下图所示：\",\"加锁线程 A 先执行 writer 方法，然后线程 B 执行 reader 方法，图中每一个箭头两个节点就代码一个 happens-before 关系，黑色的代表根据程序顺序规则推导出来，红色的是根据 volatile 变量的写 happens-before 于任意后续对 volatile 变量的读，而蓝色的就是根据传递性规则推导出来的。\",\"这里的2 happen-before 3，同样根据 happens-before 规则定义：如果 A happens-before B，则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B 的执行顺序，我们可以知道操作 2 执行结果对操作 3 来说是可见的，也就是说当线程 A 将 volatile 变量 flag 更改为 true 后线程 B 就能够迅速感知。\"]},\"1456\":{\"h\":\"4. volatile 的内存语义\",\"t\":[\"分析完 happens-before 关系后我们现在就来进一步分析 volatile 的内存语义。\",\"还是以上面的代码为例，假设线程 A 先执行 writer 方法，线程 B 随后执行 reader 方法，初始时线程的本地内存中 flag 和 a 都是初始状态，下图是线程 A 执行 volatile 写后的状态图：\",\"当 volatile 变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程 B 再需要读取从主内存中去读取该变量的最新值。下图就展示了线程 B 读取同一个 volatile 变量的内存变化示意图：\",\"从横向上看，线程 A 和线程 B 之间进行了一次通信，线程 A 在写 volatile 变量时，实际上就像是给 B 发送了一个消息告诉线程 B 你现在的值都是旧的了，然后线程 B 读这个 volatile 变量时就像是接收了线程 A 刚刚发送的消息。既然是旧的了，那线程 B 该怎么办了？自然而然就只能去主内存去取了。\"]},\"1457\":{\"h\":\"5. volatile 的内存语义实现\",\"t\":[\"在前面的学习中，我们知道，为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序，那如果想阻止重排序要怎么办了？答案是可以添加内存屏障。\",\"JMM 内存屏障分为四类见下图：\",\"内存屏障分类表\",\"java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。为了实现 volatile 的内存语义，JMM 会限制特定类型的编译器和处理器重排序，JMM 会针对编译器制定 volatile 重排序规则表：\",\"\\\"NO\\\" 表示禁止重排序。为了实现 volatile 内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守策略：\",\"在每个 volatile 写操作的前面插入一个 StoreStore 屏障；\",\"在每个 volatile 写操作的后面插入一个 StoreLoad 屏障；\",\"在每个 volatile 读操作的后面插入一个 LoadLoad 屏障；\",\"在每个 volatile 读操作的后面插入一个 LoadStore 屏障。\",\"需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障\",\"StoreStore 屏障：禁止上面的普通写和下面的 volatile 写重排序；\",\"StoreLoad 屏障：防止上面的 volatile 写与下面可能有的 volatile 读/写重排序\",\"LoadLoad 屏障：禁止下面所有的普通读操作和上面的 volatile 读重排序\",\"LoadStore 屏障：禁止下面所有的普通写操作和上面的 volatile 读重排序\",\"以《Java并发编程的艺术》中的两个示意图帮助理解：\"]},\"1458\":{\"h\":\"6. 一个例子\",\"t\":[\"现在对于文章开头的问题，通过 volatile 给出答案：\",\"public class VolatileDemo { private static volatile boolean isOver = false; public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { while (!isOver) ; } }); thread.start(); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } isOver = true; } }\",\"注意不同点，现在已经 将 isOver 设置成了 volatile 变量，这样在 main 线程中将 isOver 改为了 true 后，thread 的工作内存该变量值就会失效，从而需要再次从主内存中读取该值，现在能够读出 isOver 最新值为 true 从而能够结束在 thread 里的死循环，从而能够顺利停止掉 thread 线程。\"]},\"1459\":{\"c\":[\"并发编程\"]},\"1460\":{\"c\":[\"JUC\"]},\"1461\":{\"h\":\"你真的了解 final 吗\"},\"1462\":{\"h\":\"1. final 简介\",\"t\":[\"final 可以修饰变量，方法和类，用于表示所修饰的内容一旦赋值之后就不会再被改变。\",\"比如 String 类就是一个 final 类型的类，它是一个不可变类。\"]},\"1463\":{\"h\":\"2. final 的具体使用场景\"},\"1464\":{\"h\":\"2.1 变量\",\"t\":[\"在 java 中变量，可以分为成员变量以及方法局部变量。\"]},\"1465\":{\"h\":\"2.1.1 final 成员变量\",\"t\":[\"通常每个类中的成员变量可以分为类变量（static修饰的变量）以及实例变量。\",\"针对这两种类型的变量赋初值的时机是不同的：类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值；而实例变量可以在声明变量的时候给实例变量赋初值，在非静态初始化块中以及构造器中赋初值。\",\"类变量有两个时机赋初值，而实例变量则可以有三个时机赋初值。当 final 变量未初始化时系统不会进行隐式初始化，会出现报错。下面用具体的代码来演示：\",\"看上面的图片已经将每种情况整理出来了，现在将这几种情况归纳整理一下：\",\"类变量：必须要在静态初始化块中指定初始值或者声明该类变量时指定初始值，而且只能在这两个地方之一进行指定\",\"实例变量：必要要在非静态初始化块，声明该实例变量或者在构造器中指定初始值，而且只能在这三个地方进行指定\"]},\"1466\":{\"h\":\"2.1.2 final 局部变量\",\"t\":[\"final 局部变量由程序员进行显式初始化，如果 final 局部变量已经进行了初始化则后面就不能再次进行更改，如果 final 变量未进行初始化，可以进行赋值，当且仅有一次赋值，一旦赋值之后再次赋值就会出错。\",\"下面用具体的代码演示 final 局部变量的情况：\",\"现在我们来换一个角度进行考虑，final 修饰的是基本数据类型和引用类型有区别吗？\"]},\"1467\":{\"h\":\"2.1.2 final 基本数据类型 VS final 引用数据类型\",\"t\":[\"通过上面的例子我们能够看出，如果 final 修饰的是一个基本数据类型的数据，一旦赋值后就不能再次更改，那么，如果 final 是引用数据类型呢？这个引用的对象能够改变吗？\",\"同样来看一段代码：\",\"public class FinalExample { //在声明final实例成员变量时进行赋值 private final static Person person = new Person(24, 170); public static void main(String[] args) { //对final引用数据类型person进行更改 person.age = 22; System.out.println(person.toString()); } static class Person { private int age; private int height; public Person(int age, int height) { this.age = age; this.height = height; } @Override public String toString() { return \\\"Person{\\\" + \\\"age=\\\" + age + \\\", height=\\\" + height + '}'; } } }\",\"当我们对 final 修饰的引用数据类型变量 person 的属性改成 22，是可以成功操作的。\",\"通过这个实验我们就可以看出来当 final 修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final 只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的。\",\"宏变量\",\"利用 final 变量的不可更改性，在满足一下三个条件时，该变量就会成为一个 “宏变量”，即是一个常量。\",\"使用 final 修饰符修饰\",\"在定义该 final 变量时就指定了初始值\",\"该初始值在编译时就能够唯一指定\",\"注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值\"]},\"1468\":{\"h\":\"2.2 方法\"},\"1469\":{\"h\":\"2.2.1 重写？\",\"t\":[\"当父类的方法被 final 修饰的时候，子类不能重写父类的该方法，比如在 Object 中，getClass() 方法就是 final 的，我们就不能重写该方法，但是 hashCode() 方法就不是被 final 所修饰的，我们就可以重写 hashCode() 方法。\",\"写一个例子来加深理解：先定义一个父类，里面有 final 修饰的方法 test();\",\"public class FinalExampleParent { public final void test() {} }\",\"然后 FinalExample 继承该父类，当重写 test() 方法时出现报错，如下图：\",\"通过这个现象我们就可以看出来被 final 修饰的方法不能够被子类所重写。\"]},\"1470\":{\"h\":\"2.2.2 重载？\",\"t\":[\"public class FinalExampleParent { public final void test() {} public final void test(String str) {} }\",\"可以看出被 final 修饰的方法是可以重载的。\",\"经过我们的分析可以得出如下结论：\",\"父类的 final 方法是不能够被子类重写的\",\"final 方法是可以被重载的\"]},\"1471\":{\"h\":\"2.3 类\",\"t\":[\"当一个类被 final 修饰时，表明该类是不能被子类继承的。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此，当一个类不希望被继承时就可以使用 final 修饰。\",\"举一个小例子：\",\"public final class FinalExampleParent { public final void test() {} }\",\"父类被 final 修饰，当子类继承该父类的时候，就会报错，如下图：\"]},\"1472\":{\"h\":\"3. final 的例子\",\"t\":[\"final 经常会被用作不变类上，利用 final 的不可更改性。我们先来看看什么是不可变类。\",\"不可变类\",\"不可变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。\",\"满足以下条件则可以成为不可变类：\",\"使用 private 和 final 修饰符来修饰该类的成员变量\",\"提供带参的构造器用于初始化类的成员变量\",\"仅为该类的成员变量提供 getter 方法，不提供 setter 方法，因为普通方法无法修改 final 修饰的成员变量\",\"如果有必要就重写 Object 类的 hashCode() 和 equals() 方法，应该保证用 equals() 判断相同的两个对象其 Hashcode 值也是相等的\",\"JDK 中提供的八个包装类和 String 类都是不可变类，我们来看看 String 的实现：\",\"/** The value is used for character storage. */ private final char value[];\",\"可以看出 String 的 value 就是 final 修饰的，上述其他几条性质也是吻合的。\"]},\"1473\":{\"h\":\"4. 多线程中你真的了解 final 吗？\",\"t\":[\"在 java 内存模型中我们知道，java 内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说，对于底层而言，java 内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下，final 会进行怎样的重排序？会导致线程安全的问题吗？\"]},\"1474\":{\"h\":\"4.1 final 域重排序规则\"},\"1475\":{\"h\":\"4.1.1 final 域为基本类型\",\"t\":[\"先看一段示例代码：\",\"public class FinalDemo { private int a; //普通域 private final int b; //final域 private static FinalDemo finalDemo; public FinalDemo() { a = 1; // 1. 写普通域 b = 2; // 2. 写final域 } public static void writer() { finalDemo = new FinalDemo(); } public static void reader() { FinalDemo demo = finalDemo; // 3.读对象引用 int a = demo.a; //4.读普通域 int b = demo.b; //5.读final域 } }\",\"假设线程 A 在执行 writer() 方法，线程 B 执行 reader() 方法。\",\"写 final 域重排序规则\",\"写 final 域的重排序规则为：禁止对final域的写重排序到构造函数之外。\",\"这个规则的实现主要包含了两个方面：\",\"JMM 禁止编译器把 final 域的写重排序到构造函数之外\",\"编译器会在 final 域写之后，构造函数 return 之前，插入一个 storestore 屏障，这个屏障可以禁止处理器把 final 域的写重排序到构造函数之外。\",\"我们再来分析 writer 方法，虽然只有一行代码，但实际上做了两件事情：\",\"构造了一个 FinalDemo 对象；\",\"把这个对象赋值给成员变量 finalDemo。\",\"我们来画下存在的一种可能执行时序图，如下：\",\"由于 a，b 之间没有数据依赖性，普通域（普通变量）a 可能会被重排序到构造函数之外，线程 B 就有可能读到的是普通变量 a 初始化之前的值（零值），这样就可能出现错误。\",\"而 final 域变量 b，根据重排序规则，会禁止 final 修饰的变量 b 重排序到构造函数之外，从而 b 能够正确赋值，线程 B 就能够读到 final 变量初始化后的值。\",\"因此，写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程 B 有可能就是一个未正确初始化的对象 finalDemo。\",\"读 final 域重排序规则\",\"读 final 域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的 final 域，JMM 会禁止这两个操作的重排序。\",\"注意，这个规则仅仅是针对处理器。\",\"处理器会在读 final 域操作的前面插入一个 LoadLoad 屏障。实际上，读对象的引用和读该对象的 final 域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。\",\"read() 方法主要包含了三个操作：\",\"初次读引用变量 finalDemo;\",\"初次读引用变量 finalDemo 的普通域 a;\",\"初次读引用变量 finalDemo 的 final 与 b;\",\"假设线程 A 写过程没有重排序，那么线程 A 和线程 B 有一种的可能执行时序为下图：\",\"读对象的普通域被重排序到了读对象引用的前面就会出现线程 B 还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而 final 域的读操作就 “限定” 了在读 final 域变量前已经读到了该对象的引用，从而就可以避免这种情况。\",\"读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读这个包含这个 final 域的对象的引用。\"]},\"1476\":{\"h\":\"4.1.2 final 域为引用类型\",\"t\":[\"对 final 修饰的对象的成员域写操作\",\"针对引用数据类型，final 域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个 final 修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。\",\"注意这里的是 “增加” 也就说前面对 final 基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看：\",\"public class FinalReferenceDemo { final int[] arrays; private FinalReferenceDemo finalReferenceDemo; public FinalReferenceDemo() { arrays = new int[1]; //1 arrays[0] = 1; //2 } public void writerOne() { finalReferenceDemo = new FinalReferenceDemo(); //3 } public void writerTwo() { arrays[0] = 2; //4 } public void reader() { if (finalReferenceDemo != null) { //5 int temp = finalReferenceDemo.arrays[0]; //6 } } }\",\"针对上面的实例程序，线程线程 A 执行 wirterOne 方法，执行完后线程 B 执行 writerTwo 方法，然后线程 C 执行 reader 方法。下图就以这种执行时序出现的一种情况来讨论：\",\"由于对 final 域的写禁止重排序到构造方法外，因此 1 和 3 不能被重排序。由于一个 final 域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此 2 和 3 不能重排序。\",\"对 final 修饰的对象的成员域读操作\",\"JMM 可以确保线程 C 至少能看到写线程 A 对 final 引用的对象的成员域的写入，即能看到 arrays[0] = 1，而写线程 B 对数组元素的写入可能看到也可能看不到。JMM 不保证线程 B 的写入对线程 C 可见，线程 B 和线程 C 之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者 volatile。\",\"关于 final 重排序的总结\",\"按照 final 修饰的数据类型分类：\",\"基本数据类型: \",\"final 域写：禁止 final 域写与构造方法重排序，即禁止 final 域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的 final 域全部已经初始化过。\",\"final 域读：禁止初次读对象的引用与读该对象包含的 final 域的重排序。\",\"引用数据类型： \",\"额外增加约束：禁止在构造函数对一个 final 修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序\"]},\"1477\":{\"h\":\"5. final 的实现原理\",\"t\":[\"上面我们提到过，写 final 域会要求编译器在 final 域写之后，构造函数返回前插入一个 StoreStore 屏障。读 final 域的重排序规则会要求编译器在读 final 域的操作前插入一个 LoadLoad 屏障。\",\"有意思的是，如果以 X86 处理为例，X86 不会对写-写重排序，所以 StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在 X86 处理器中，读 final 域需要的 LoadLoad屏障也会被省略掉。也就是说，以 X86 为例的话，对 final 域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器。\"]},\"1478\":{\"h\":\"6. 为什么 final 引用不能从构造函数中 “溢出”\",\"t\":[\"上面对 final 域写重排序规则可以确保我们在使用一个对象引用的时候，该对象的 final 域已经在构造函数被初始化过了。\",\"但是这里其实是有一个前提条件的，即：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中 “溢出”。\",\"以下面的例子来说：\",\"public class FinalReferenceEscapeDemo { private final int a; private FinalReferenceEscapeDemo referenceDemo; public FinalReferenceEscapeDemo() { a = 1; //1 referenceDemo = this; //2 } public void writer() { new FinalReferenceEscapeDemo(); } public void reader() { if (referenceDemo != null) { //3 int temp = referenceDemo.a; //4 } } }\",\"可能的执行时序如图所示：\",\"假设一个线程 A 执行 writer 方法另一个线程执行 reader 方法。因为构造函数中操作 1 和 2 之间没有数据依赖性，1 和 2 可以重排序，先执行了 2，这个时候引用对象 referenceDemo 是个没有完全初始化的对象，而当线程 B 去读取该对象时就会出错。\",\"尽管依然满足了 final 域写重排序规则：在引用对象对所有线程可见时，其 final 域已经完全初始化成功。但是，引用对象 “this” 溢出，该代码依然存在线程安全的问题。\"]},\"1479\":{\"c\":[\"并发编程\"]},\"1480\":{\"c\":[\"JUC\"]},\"1481\":{\"h\":\"三大性质总结：原子性、可见性、有序性\"},\"1482\":{\"h\":\"1. 原子性\",\"t\":[\"原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。\",\"先看看哪些是原子操作，哪些不是原子操作，有一个直观的印象：\",\"int a = 10; //1 a++; //2 int b = a; //3 a = a + 1; //4\",\"上面这四个语句中只有第 1 个语句是原子操作，将 10 赋值给线程工作内存的变量 a，而语句 2（a++），实际上包含了三个操作：\",\"读取变量 a 的值；\",\"对 a 进行加一的操作；\",\"将计算后的值再赋值给变量a\",\"而这三个操作无法构成原子操作。\",\"对语句 3，4 的分析同理可得这两条语句不具备原子性。\",\"在 java 内存模型中定义了 8 种操作都是原子的，不可再分的。\",\"lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；\",\"unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；\",\"read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的 load 动作使用；\",\"load（载入）：作用于工作内存中的变量，它把 read 操作从主内存中得到的变量值放入工作内存中的变量副本；\",\"use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；\",\"assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；\",\"store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的 write操作使用；\",\"write（操作）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。\",\"上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。\",\"那么如何理解这些指令了？\",\"比如，把一个变量从主内存中复制到工作内存中就需要执行 read，load 操作，将工作内存同步到主内存中就需要执行 store，write操作。\",\"注意\",\"java 内存模型只是要求上述两个操作是顺序执行的并不是连续执行的。\",\"也就是说 read 和 load 之间可以插入其他指令，store 和 writer 也可以插入其他指令。\",\"比如对主内存中的 a,b 进行访问就可以出现这样的操作顺序：read a, read b, load b, load a。\",\"由原子性变量操作 read,load,use,assign,store,write，可以大致认为基本数据类型的访问读写具备原子性（例外就是 long 和 double 的非原子性协定）\",\"synchronized\",\"上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下 lock 和 unlock 两条原子操作。如果我们需要更大范围的原子性操作就可以使用 lock 和 unlock 原子操作。\",\"尽管 jvm 没有把 lock 和 unlock 开放给我们使用，但 jvm 以更高层次的指令 monitorenter 和 monitorexit 指令开放给我们使用，反应到 java 代码中就是 synchronized 关键字，也就是说 synchronized 满足原子性。\",\"我们先来看这样一个例子：\",\"public class VolatileExample { private static volatile int counter = 0; public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10000; i++) counter++; } }); thread.start(); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(counter); } }\",\"开启 10 个线程，每个线程都自加 10000 次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000。可实际上，不管运行多少次都是小于 100000 的结果，问题在于 volatile 并不能保证原子性，在前面说过 counter++ 这并不是一个原子操作，包含了三个步骤：\",\"读取变量 counter 的值；\",\"对 counter 加一；\",\"将新值赋值给变量 counter。\",\"如果线程 A 读取 counter 到工作内存后，其他线程对这个值已经做了自增操作后，那么线程 A 的这个值自然而然就是一个过期的值，因此，总结果必然会是小于 100000 的。\",\"如果让 volatile 保证原子性，必须符合以下两条规则：\",\"运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；\",\"变量不需要与其他的状态变量共同参与不变约束。\"]},\"1483\":{\"h\":\"2. 有序性\"},\"1484\":{\"h\":\"2.1 synchronized\",\"t\":[\"synchronized 语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。\",\"因此，synchronized 语义就要求线程在访问读写共享变量时只能 “串行” 执行，故 synchronized 具有有序性。\"]},\"1485\":{\"h\":\"2.2 volatile\",\"t\":[\"在 java 内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序；也就是说 java 程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。\",\"在单例模式的实现上有一种双重检验锁定的方式（Double-checked Locking）。代码如下：\",\"public class Singleton { private Singleton() {}; private volatile static Singleton instance; public Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } }\",\"这里为什么要加 volatile 了？我们先来分析一下不加 volatile 的情况，有问题的语句是这条：\",\"instance = new Singleton();\",\"这条语句实际上包含了三个操作：\",\"分配对象的内存空间；\",\"初始化对象；\",\"设置 instance 指向刚分配的内存地址。\",\"但由于存在重排序的问题，可能有以下的执行顺序：\",\"如果 2 和 3 进行了重排序的话，线程 B 进行判断 if(instance == null) 时就会为 true，而实际上这个 instance 并没有初始化成功，显而易见对线程 B 来说之后的操作就会是错的。而用 volatile 修饰的话就可以禁止 2 和 3 操作重排序，从而避免这种情况。\",\"volatile包含禁止指令重排序的语义，故其具有有序性。\"]},\"1486\":{\"h\":\"3. 可见性\",\"t\":[\"可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。\",\"通过之前对 synchronzed 内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，synchronized 具有可见性。\",\"同样的在 volatile 分析中，会通过在指令中添加 lock 指令，以实现内存可见性。因此，volatile 具有可见性。\"]},\"1487\":{\"h\":\"4. 总结\",\"t\":[\"综上分析：\",\"synchronized: 具有原子性，有序性和可见性\",\"volatile：具有有序性和可见性\"]},\"1488\":{\"c\":[\"并发编程\"]},\"1489\":{\"c\":[\"JUC\"]},\"1490\":{\"h\":\"初识 Lock 与 AQS\"},\"1491\":{\"h\":\"1. concurrent 包的结构层次\",\"t\":[\"在针对并发编程中，Doug Lea 大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱。这些代码在 java.util.concurrent 包下。如下图所示。\",\"其中包含了两个子包：atomic 以及 lock，另外在 concurrent 下的阻塞队列以及 executors，这些就是 concurrent 包中的精华。而这些类的实现主要是依赖于 volatile 以及 CAS，从整体上来看 concurrent 包的整体实现图如下图所示：\"]},\"1492\":{\"h\":\"2. lock 简介\",\"t\":[\"锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在 Lock 接口出现之前，java 程序主要是靠 synchronized 关键字实现锁功能的，而 java SE5 之后，并发包中增加了 lock 接口，它提供了与 synchronized 一样的锁功能。虽然它失去了像 synchronize 关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。\",\"通常显示使用 lock 的形式如下：\",\"Lock lock = new ReentrantLock(); lock.lock(); try { ....... } finally { lock.unlock(); }\",\"需要注意的是 synchronized 同步块执行完成或者遇到异常是锁会自动释放，而 lock 必须调用 unlock() 方法释放锁，为保证能够释放，需要在 finally 块中释放锁。\"]},\"1493\":{\"h\":\"2.1 Lock 接口 API\",\"t\":[\"lock 接口中定义的方法：\",\"//获取锁 void lock(); //获取锁的过程能够响应中断 void lockInterruptibly() throws InterruptedException; //非阻塞式响应中断能立即返回，获取锁放回true反之返回fasle boolean tryLock(); //超时获取锁，在超时内或者未中断的情况下能够获取锁 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回 Condition newCondition();\",\"在上述五个接口中，最熟悉的 ReentrantLock 类实现如下:\",\"public class ReentrantLock implements Lock, java.io.Serializable\",\"如果去查看源码的实现，会发现 ReentrantLock 中并没有多少代码。其实是因为，基本上所有方法的实现，实际上都是调用了其静态内存类 Sync 中的方法，而 Sync 类继承了 AbstractQueuedSynchronizer（AQS）。可以看出要想理解 ReentrantLock 关键核心在于对队列同步器 AbstractQueuedSynchronizer（简称同步器）的理解。\"]},\"1494\":{\"h\":\"2.2 初识 AQS\",\"t\":[\"同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个 int 成员变量来表示同步状态以及通过一个 FIFO 队列构成等待队列。它的子类必须重写 AQS 的几个 protected 修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用 getState，setState 以及 compareAndSetState 这三个方法。\",\"子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。\",\"同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：\",\"锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；\",\"同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。\",\"锁和同步器很好的隔离了使用者和实现者所需关注的领域。\"]},\"1495\":{\"h\":\"2.3 AQS 的模板方法设计模式\",\"t\":[\"AQS 的设计是使用模板方法设计模式，它将一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法。\",\"举个例子，AQS 中需要重写的方法 tryAcquire：\",\"protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); }\",\"ReentrantLock 中 NonfairSync（继承AQS）会重写该方法为：\",\"protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); }\",\"而 AQS 中的模板方法 acquire():\",\"public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); }\",\"会调用 tryAcquire 方法，而此时当继承 AQS 的 NonfairSync 调用模板方法 acquire 时就会调用已经被 NonfairSync 重写的 tryAcquire 方法。这就是使用 AQS 的方式，在弄懂这点后会lock的实现理解有很大的提升。可以归纳总结为这么几点：\",\"同步组件（这里不仅仅值锁，还包括 CountDownLatch 等）的实现依赖于同步器 AQS，在同步组件实现中，使用 AQS 的方式被推荐定义继承 AQS 的静态内存类；\",\"AQS 采用模板方法进行设计，AQS 的 protected 修饰的方法需要由继承 AQS 的子类进行重写实现，当调用 AQS 的子类的方法时就会调用被重写的方法；\",\"AQS 负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而 Lock 等同步组件主要专注于实现同步语义；\",\"在重写 AQS 的方式时，使用 AQS 提供的 getState()，setState()，compareAndSetState() 方法进行修改同步状态。\",\"AQS可重写的方法如下图（摘自《java并发编程的艺术》一书）所示：\",\"在实现同步组件时 AQS 提供的模板方法如下图：\",\"AQS 提供的模板方法可以分为 3 类：\",\"独占式获取与释放同步状态；\",\"共享式获取与释放同步状态；\",\"查询同步队列中等待线程情况；\",\"同步组件通过 AQS 提供的模板方法实现自己的同步语义。\"]},\"1496\":{\"h\":\"3. 一个例子\",\"t\":[\"下面使用一个例子来进一步理解下 AQS 的使用。这个例子也是来源于 AQS 源码中的 example。\",\"class Mutex implements Lock, java.io.Serializable { // Our internal helper class // 继承AQS的静态内存类 // 重写方法 private static class Sync extends AbstractQueuedSynchronizer { // Reports whether in locked state protected boolean isHeldExclusively() { return getState() == 1; } // Acquires the lock if state is zero public boolean tryAcquire(int acquires) { assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } // Releases the lock by setting state to zero protected boolean tryRelease(int releases) { assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; } // Provides a Condition Condition newCondition() { return new ConditionObject(); } // Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); setState(0); // reset to unlocked state } } // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); //使用同步器的模板方法实现自己的同步语义 public void lock() { sync.acquire(1); } public boolean tryLock() { return sync.tryAcquire(1); } public void unlock() { sync.release(1); } public Condition newCondition() { return sync.newCondition(); } public boolean isLocked() { return sync.isHeldExclusively(); } public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } }\",\"MutexDemo：\",\"public class MutextDemo { private static Mutex mutex = new Mutex(); public static void main(String[] args) { for (int i = 0; i < 10; i++) { Thread thread = new Thread(() -> { mutex.lock(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } finally { mutex.unlock(); } }); thread.start(); } } }\",\"执行情况：\",\"上面的这个例子实现了独占锁的语义，在同一个时刻只允许一个线程占有锁。\",\"MutexDemo 新建了 10 个线程，分别睡眠 3s。从执行情况也可以看出来当前 Thread-6 正在执行占有锁而其他Thread-7，Thread-8 等线程处于 WAIT 状态。按照推荐的方式，Mutex 定义了一个继承 AQS 的静态内部类 Sync，并且重写了 AQS 的 tryAcquire 等方法，而对 state 的更新也是利用了 setState()，getState()，compareAndSetState() 这三个方法。在实现实现 lock 接口中的方法也只是调用了 AQS 提供的模板方法（因为 Sync 继承 AQS）。\",\"从这个例子就可以很清楚的看出来，在同步组件的实现上主要是利用了 AQS，而 AQS “屏蔽”了同步状态的修改，线程排队等底层实现，通过 AQS 的模板方法可以很方便的给同步组件的实现者进行调用。而针对用户来说，只需要调用同步组件提供的方法来实现并发编程即可。\",\"同时在新建一个同步组件时需要把握的两个关键点是：\",\"实现同步组件时推荐定义继承 AQS 的静态内存类，并重写需要的 protected 修饰的方法；\",\"同步组件语义的实现依赖于 AQS 的模板方法，而 AQS 模板方法又依赖于被 AQS 的子类所重写的方法。\",\"通俗点说，因为 AQS 整体设计思路采用模板方法设计模式，同步组件以及 AQS 的功能实际上别切分成各自的两部分：\",\"同步组件实现者的角度：\",\"通过可重写的方法：\",\"独占式： \",\"tryAcquire()(独占式获取同步状态)\",\"tryRelease()(独占式释放同步状态)\",\"共享式 ： \",\"tryAcquireShared()(共享式获取同步状态)\",\"tryReleaseShared()(共享式释放同步状态)\",\"告诉 AQS 怎样判断当前同步状态是否成功获取或者是否成功释放。\",\"**同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。**这句话比较抽象，举例来说，上面的 Mutex 例子中通过 tryAcquire 方法实现自己的同步语义，在该方法中如果当前同步状态为 0（即该同步组件没被任何线程获取），当前线程可以获取同时将状态更改为 1 返回 true，否则，该组件已经被线程占用返回 false。很显然，该同步组件只能在同一时刻被线程占用，Mutex 专注于获取释放的逻辑来实现自己想要表达的同步语义。\",\"AQS的角度：\",\"而对 AQS 来说，只需要同步组件返回的 true 和 false 即可，因为 AQS 会对 true 和 false 会有不同的操作，true 会认为当前线程获取同步组件成功直接返回，而 false 的话就 AQS 也会将当前线程插入同步队列等一系列的方法。\",\"总的来说，同步组件通过重写 AQS 的方法实现自己想要表达的同步语义，而 AQS 只需要同步组件表达的 true 和 false 即可，AQS 会针对 true 和 false 不同的情况做不同的处理。\",\"而关于底层实现，可以看这篇文章。\"]},\"1497\":{\"c\":[\"并发编程\"]},\"1498\":{\"c\":[\"JUC\"]},\"1499\":{\"h\":\"深入理解 AQS\"},\"1500\":{\"h\":\"1. AQS 简介\",\"t\":[\"在同步组件的实现中，AQS 是核心部分，同步组件的实现者通过使用 AQS 提供的模板方法实现同步组件语义，AQS 则实现了对同步状态的管理，以及对阻塞线程进行排队，等待通知等等一些底层的实现处理。AQS 的核心也包括了这些方面：同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现，而这些实际上则是 AQS 提供出来的模板方法。\",\"整理如下：\",\"独占式锁\",\"void acquire(int arg)：独占式获取同步状态，如果获取失败则插入同步队列进行等待\",\"void acquireInterruptibly(int arg)：与 acquire 方法相同，但在同步队列中进行等待的时候可以检测中断\",\"boolean tryAcquireNanos(int arg, long nanosTimeout)：在 acquireInterruptibly 基础上增加了超时等待功能，在超时时间内没有获得同步状态返回 false\",\"boolean release(int arg)：释放同步状态，该方法会唤醒在同步队列中的下一个节点\",\"共享式锁\",\"void acquireShared(int arg)：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态\",\"void acquireSharedInterruptibly(int arg)：在 acquireShared 方法基础上增加了能响应中断的功能\",\"boolean tryAcquireSharedNanos(int arg, long nanosTimeout)：在 acquireSharedInterruptibly 基础上增加了超时等待的功能\",\"boolean releaseShared(int arg)：共享式释放同步状态\",\"接下来要对这些模板方法的逻辑进行学习，而在此之前，首先得了解下 AQS 中的同步队列是一种什么样的数据结构，因为同步队列是 AQS 对同步状态的管理的基石。\"]},\"1501\":{\"h\":\"2. 同步队列\",\"t\":[\"当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。\",\"就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。\",\"AQS 中的同步队列则是通过链式方式进行实现。\",\"接下来，我们需要解决三个问题：\",\"节点的数据结构是什么样的？\",\"是单向还是双向？\",\"是带头结点的还是不带头节点的？\",\"我们依旧先是通过看源码的方式。\",\"在 AQS 有一个静态内部类 Node，其中的属性有：\",\"volatile int waitStatus; // 节点状态 volatile Node prev; // 当前节点/线程的前驱节点 volatile Node next; // 当前节点/线程的后继节点 volatile Thread thread; // 加入同步队列的线程引用 Node nextWaiter; // 等待队列中的下一个节点\",\"节点的状态有：\",\"int INITIAL = 0; // 初始状态 int CANCELLED = 1; // 节点从同步队列中取消 int SIGNAL = -1; // 后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行 int CONDITION = -2; // 当前节点进入等待队列中 int PROPAGATE = -3; // 表示下一次共享式同步状态获取将会无条件传播下去\",\"也就是说，每个节点拥有其前驱和后继节点，并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息。\",\"所以 AQS 实际上通过头尾指针来管理同步队列，同时实现包括获取锁失败的线程进行入队，释放锁时对同步队列中的线程进行通知等核心方法。其示意图如下：\",\"可以清楚地知道两点：\",\"节点的数据结构，即 AQS 的静态内部类 Node，节点的等待状态等信息\",\"同步队列是一个双向队列，AQS 通过持有头尾指针管理同步队列\",\"那么，节点如何进行入队和出队是怎样做的呢？\",\"实际上这对应着锁的获取和释放两个操作：（1）获取锁失败进行入队操作；（2）获取锁成功进行出队操作。\"]},\"1502\":{\"h\":\"3. 独占锁\"},\"1503\":{\"h\":\"3.1 独占锁的获取（acquire）\",\"t\":[\"调用 lock() 方法是获取独占式锁，获取失败就将当前线程加入同步队列，成功则线程执行。而 lock() 方法实际上会调用 AQS 的 acquire()方法，源码如下：\",\"public final void acquire(int arg) { // 先看同步状态是否获取成功，如果成功则方法结束返回 // 若失败则先调用 addWaiter()方法再调用 acquireQueued()方法 if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); }\",\"acquire 根据当前获得同步状态成功与否做了两件事情：\",\"成功，则方法结束返回；\",\"失败，则先调用 addWaiter() 然后在调用 acquireQueued()方法。\"]},\"1504\":{\"h\":\"3.1.1 获取同步状态失败，入队操作\",\"t\":[\"当线程获取独占式锁失败后就会将当前线程加入同步队列，接下来就去研究一下加入队列的方式，即 addWaiter() 和 acquireQueued()。\",\"addWaiter() 源码如下：\",\"private Node addWaiter(Node mode) { // 1. 将当前线程构建成Node类型 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 2. 当前尾节点是否为null? Node pred = tail; if (pred != null) { // 2.2 将当前节点尾插入的方式插入同步队列中 node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } // 2.1 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程 enq(node); return node; }\",\"可以看到，程序的逻辑主要分为两个部分：\",\"当前同步队列的尾节点为 null，调用方法enq()插入；\",\"当前队列的尾节点不为 null，则采用尾插入（compareAndSetTail（）方法）的方式入队。\",\"另外还会有另外一个问题：如果 if (compareAndSetTail(pred, node)) = false 怎么办？\",\"会继续执行到 enq() 方法，同时很明显 compareAndSetTail 是一个 CAS 操作，通常来说如果 CAS 操作失败会继续自旋（死循环）进行重试。\",\"因此，经过我们这样的分析，enq() 方法可能承担两个任务：\",\"处理当前同步队列尾节点为 null 时进行入队操作；\",\"如果 CAS 尾插入节点失败后负责自旋进行尝试。\",\"那么是不是真的就像我们分析的一样了？只有源码会告诉我们答案。enq() 源码如下：\",\"private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize // 1. 构造头结点 if (compareAndSetHead(new Node())) tail = head; } else { // 2. 尾插入，CAS操作失败自旋尝试 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } }\",\"在上面的源码中我们可以看出在第1步中会先创建头结点，说明同步队列是带头结点的链式存储结构。带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。\",\"那么带头节点的队列初始化时机是什么？自然而然是在 tail 为 null 时，即当前线程是第一次插入同步队列。compareAndSetTail(t, node) 方法会利用 CAS 操作设置尾节点，如果 CAS 操作失败会在 for (;;) 死循环中不断尝试，直至成功 return 返回为止。因此，对 enq() 方法可以做这样的总结：\",\"在当前线程是第一个加入同步队列时，调用 compareAndSetHead(new Node()) 方法，完成链式队列的头结点的初始化；\",\"自旋不断尝试CAS尾插入节点直至成功为止。\",\"现在我们已经很清楚获取独占式锁失败的线程包装成 Node 然后插入同步队列的过程了。那么紧接着会有下一个问题 —— 在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？\",\"带着这样的问题我们就来看看 acquireQueued() 方法，从方法名就可以很清楚，这个方法的作用就是排队获取锁的过程，源码如下：\",\"final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { // 1. 获得当前节点的先驱节点 final Node p = node.predecessor(); // 2. 当前节点能否获取独占式锁 // 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁 if (p == head && tryAcquire(arg)) { // 队列头指针用指向当前节点 setHead(node); // 释放前驱节点 p.next = null; // help GC failed = false; return interrupted; } // 2.2 获取锁失败，线程进入等待状态等待获取独占式锁 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }\",\"程序逻辑通过注释已经标出，整体来看这是一个这又是一个自旋的过程（for (;;)），代码首先获取当前节点的先驱节点，如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head && tryAcquire(arg))），当前节点所指向的线程能够获取锁。反之，获取锁失败进入等待状态。整体示意图为下图：\"]},\"1505\":{\"h\":\"3.1.2 获取锁成功，出队操作\",\"t\":[\"获取锁的节点出队的逻辑是：\",\"// 队列头结点引用指向当前节点 setHead(node); // 释放前驱节点 p.next = null; // help GC failed = false; return interrupted;\",\"setHead() 方法为：\",\"private void setHead(Node node) { head = node; node.thread = null; node.prev = null; }\",\"将当前节点通过 setHead() 方法设置为队列的头结点，然后将之前的头结点的 next 域设置为 null 并且 pre 域也为 null，即与队列断开，无任何引用方便 GC 时能够将内存进行回收。示意图如下：\",\"那么当获取锁失败的时候会调用 shouldParkAfterFailedAcquire() 方法和 parkAndCheckInterrupt() 方法，看看他们做了什么事情。\",\"shouldParkAfterFailedAcquire() 方法源码为：\",\"private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws > 0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; }\",\"shouldParkAfterFailedAcquire() 方法主要逻辑是使用 compareAndSetWaitStatus(pred, ws, Node.SIGNAL)，使用 CAS 将节点状态由 INITIAL 设置成 SIGNAL，表示当前线程阻塞。\",\"当 compareAndSetWaitStatus 设置失败则说明 shouldParkAfterFailedAcquire() 方法返回 false，然后会在 acquireQueued() 方法中 for (;;) 死循环中会继续重试，直至 compareAndSetWaitStatus 设置节点状态位为 SIGNAL 时，shouldParkAfterFailedAcquire 返回 true 时才会执行方法 parkAndCheckInterrupt() 方法，该方法的源码为：\",\"private final boolean parkAndCheckInterrupt() { // 使得该线程阻塞 LockSupport.park(this); return Thread.interrupted(); }\",\"该方法的关键是会调用 LookSupport.park() 方法，该方法是用来阻塞当前线程的。因此到这里就应该清楚了，acquireQueued() 在自旋过程中主要完成了两件事情：\",\"如果当前节点的前驱节点是头节点，并且能够获得同步状态的话，当前线程能够获得锁该方法执行结束退出；\",\"获取锁失败的话，先将节点状态设置成 SIGNAL，然后调用 LookSupport.park 方法使得当前线程阻塞。\",\"经过上面的分析，独占式锁的获取过程也就是 acquire() 方法的执行流程如下图所示：\"]},\"1506\":{\"h\":\"3.2 独占锁的释放（release）\",\"t\":[\"独占锁的释放就相对来说比较容易理解了，先看源码：\",\"public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; }\",\"这段代码逻辑就比较容易理解了，如果同步状态释放成功（tryRelease返回 true）则会执行 if 块中的代码，当 head 指向的头结点不为 null，并且该节点的状态值不为 0 的话才会执行 unparkSuccessor() 方法。\",\"unparkSuccessor() 方法源码：\",\"private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws < 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ //头节点的后继节点 Node s = node.next; if (s == null || s.waitStatus > 0) { s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus <= 0) s = t; } if (s != null) // 后继节点不为null时唤醒该线程 LockSupport.unpark(s.thread); }\",\"首先获取头节点的后继节点，当后继节点的时候会调用 LookSupport.unpark() 方法，该方法会唤醒该节点的后继节点所包装的线程。因此，每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个 FIFO（先进先出）的过程。\",\"现在通过学习源码的方式，我们学习到了独占式锁的获取和释放的过程以及同步队列，做一下总结：\",\"线程获取锁失败，线程被封装成 Node 进行入队操作，核心方法在于 addWaiter() 和 enq()，同时 enq() 完成对同步队列的头结点初始化工作以及 CAS 操作失败的重试；\",\"线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用 LookSupport.park() 方法使得线程阻塞；\",\"释放锁的时候会唤醒后继节点。\",\"总体来说：在获取同步状态时，AQS 维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用 unparkSuccessor() 方法唤醒后继节点。\"]},\"1507\":{\"h\":\"3.3 可中断式获取锁（acquireInterruptibly）\",\"t\":[\"我们知道 lock 相较于 synchronized 有一些更方便的特性，比如能响应中断以及超时等待等特性，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。\",\"可响应中断式锁可调用方法 lock.lockInterruptibly();，而该方法其底层会调用 AQS 的 acquireInterruptibly() 方法，源码为：\",\"public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) // 线程获取锁失败 doAcquireInterruptibly(arg); }\",\"在获取同步状态失败后就会调用 doAcquireInterruptibly() 方法：\",\"private void doAcquireInterruptibly(int arg) throws InterruptedException { // 将节点插入到同步队列中 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); // 获取锁出队 if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return; } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) //线程中断抛异常 throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } }\",\"关键信息请看注释。与 acquire 方法逻辑几乎一致，唯一的区别是当 parkAndCheckInterrupt() 返回 true 即线程阻塞时该线程被中断，代码抛出被中断异常。\"]},\"1508\":{\"h\":\"3.4 超时等待式获取锁（tryAcquireNanos）\",\"t\":[\"通过调用 lock.tryLock(timeout, TimeUnit) 方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：\",\"在超时时间内，当前线程成功获取了锁；\",\"当前线程在超时时间内被中断；\",\"超时时间结束，仍未获得锁返回 false。\",\"阅读源码来看下底层具体是怎么实现的，该方法会调用 AQS 的方法 tryAcquireNanos()，源码为：\",\"public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 实现超时等待的效果 return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout); }\",\"很显然这段源码最终是靠 doAcquireNanos 方法实现超时等待的效果，该方法源码如下：\",\"private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (nanosTimeout <= 0L) return false; // 1. 根据超时时间和当前时间计算出截止时间 final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); //2. 当前线程获得锁出队列 if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return true; } // 3.1 重新计算超时时间 nanosTimeout = deadline - System.nanoTime(); // 3.2 已经超时返回false if (nanosTimeout <= 0L) return false; // 3.3 线程阻塞等待 if (shouldParkAfterFailedAcquire(p, node) && nanosTimeout > spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); // 3.4 线程被中断抛出被中断异常 if (Thread.interrupted()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } }\",\"程序逻辑如图所示：\",\"程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上。\",\"在第 1 步会先计算出按照现在时间和超时时间计算出理论上的截止时间。比如当前时间是 8h10min，超时时间是 10min，那么根据 deadline = System.nanoTime() + nanosTimeout 计算出刚好达到超时时间时的系统时间就是 8h10min+10min=8h20min。\",\"然后根据 deadline - System.nanoTime() 就可以判断是否已经超时了。比如，当前系统时间是 8h30min 很明显已经超过了理论上的系统时间 8h20min，deadline - System.nanoTime() 计算出来就是一个负数，自然而然会在 3.2 步中的 if 判断之间返回 false。\",\"如果还没有超时，即 3.2 步中的 if 判断为 true，那就会继续执行 3.3 步。通过 LockSupport.parkNanos 使得当前线程阻塞，同时在 3.4 步增加了对中断的检测，若检测出被中断直接抛出被中断异常。\"]},\"1509\":{\"h\":\"4. 共享锁\"},\"1510\":{\"h\":\"4.1 共享锁的获取（acquireShared）\",\"t\":[\"现在来看看共享锁是怎样实现的？共享锁的获取方法为 acquireShared，源码为：\",\"public final void acquireShared(int arg) { if (tryAcquireShared(arg) < 0) doAcquireShared(arg); }\",\"这段源码的逻辑也很容易理解，在该方法中会首先调用 tryAcquireShared() 方法，其返回值是一个int类型，当返回值为大于等于 0 的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行 doAcquireShared() 方法，该方法的源码为：\",\"private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r >= 0) { // 当该节点的前驱节点是头结点且成功获取同步状态 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }\",\"现在看这段代码，逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且 tryAcquireShared(arg) 返回值大于等于 0 即能成功获得同步状态。\"]},\"1511\":{\"h\":\"4.2 共享锁的释放（releaseShared）\",\"t\":[\"共享锁的释放在 AQS 中会调用方法 releaseShared()：\",\"public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; }\",\"当成功释放同步状态之后，即 tryReleaseShared 会继续执行 doReleaseShared 方法：\",\"private void doReleaseShared() { /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) { Node h = head; if (h != null && h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } }\",\"这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的 CAS 保证，当 CAS 操作失败 continue，在下一次循环中进行重试。\"]},\"1512\":{\"h\":\"4.3 可中断（acquireSharedInterruptibly），超时等待（tryAcquireSharedNanos）\",\"t\":[\"关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致，具体的就不再说了，如果理解了上面的内容对这部分的理解也是水到渠成的。\"]},\"1513\":{\"c\":[\"并发编程\"]},\"1514\":{\"c\":[\"JUC\"]},\"1515\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"1516\":{\"h\":\"System Design\"},\"1517\":{\"h\":\"For Offer\"},\"1518\":{\"h\":\"Leetcode\"},\"1519\":{\"h\":\"Note\"},\"1520\":{\"h\":\"Template\"},\"1521\":{\"h\":\"Big Data\"},\"1522\":{\"h\":\"Ruoyi\"},\"1523\":{\"h\":\"Mianshiba\"},\"1524\":{\"h\":\"User Center\"},\"1525\":{\"h\":\"User Match\"},\"1526\":{\"h\":\"Article\"},\"1527\":{\"h\":\"Book\"},\"1528\":{\"h\":\"Tool Build\"},\"1529\":{\"h\":\"Hot100\"},\"1530\":{\"h\":\"Mysql\"},\"1531\":{\"h\":\"Database\"},\"1532\":{\"h\":\"创建型\"},\"1533\":{\"h\":\"Design Mode\"},\"1534\":{\"h\":\"Java\"},\"1535\":{\"h\":\"Language\"},\"1536\":{\"h\":\"Min IO\"},\"1537\":{\"h\":\"Middleware\"},\"1538\":{\"h\":\"Linux\"},\"1539\":{\"h\":\"Operating System\"},\"1540\":{\"h\":\"IOC\"},\"1541\":{\"h\":\"Spring\"},\"1542\":{\"h\":\"源码剖析\"},\"1543\":{\"h\":\"Spring Cloud\"},\"1544\":{\"h\":\"Work Note\"},\"1545\":{\"h\":\"Sundry\"},\"1546\":{\"h\":\"JUC 并发编程\"}},\"dirtCount\":0,\"index\":[[\"阅读源码来看下底层具体是怎么实现的\",{\"1\":{\"1508\":1}}],[\"阅读历史\",{\"0\":{\"651\":1}}],[\"屏蔽\",{\"1\":{\"1496\":1}}],[\"屏蔽了同步状态的管理\",{\"1\":{\"1494\":1}}],[\"屏障\",{\"1\":{\"1457\":8,\"1475\":2,\"1477\":2}}],[\"载入\",{\"1\":{\"1482\":1}}],[\"溢出\",{\"0\":{\"1478\":1},\"1\":{\"1478\":2}}],[\"溢出的结果就是取模的结果\",{\"1\":{\"421\":1}}],[\"零值\",{\"1\":{\"1475\":1}}],[\"零钱兑换\",{\"0\":{\"891\":1},\"1\":{\"891\":1}}],[\"宏变量\",{\"1\":{\"1467\":2}}],[\"声明该实例变量或者在构造器中指定初始值\",{\"1\":{\"1465\":1}}],[\"声明一个容量为20的堆内缓存配置\",{\"1\":{\"1211\":1}}],[\"竞争锁\",{\"1\":{\"1442\":1}}],[\"偏向锁在\",{\"1\":{\"1444\":1}}],[\"偏向锁撤销流程\",{\"1\":{\"1443\":1}}],[\"偏向锁使用了一种等到竞争出现才释放锁的机制\",{\"1\":{\"1443\":1}}],[\"偏向锁的撤销\",{\"0\":{\"1443\":1},\"1\":{\"1443\":1}}],[\"偏向锁的获取\",{\"0\":{\"1442\":1}}],[\"偏向锁\",{\"0\":{\"1441\":1}}],[\"偏向锁状态\",{\"1\":{\"1440\":1}}],[\"级别从低到高依次是\",{\"1\":{\"1440\":1}}],[\"伟大的科学家们也是这样做的\",{\"1\":{\"1434\":1}}],[\"缩短获取锁的时间\",{\"1\":{\"1434\":1}}],[\"缩进来增强语句的可读性\",{\"1\":{\"908\":1}}],[\"啦\",{\"1\":{\"1433\":1}}],[\"蓝色的则是通过程序顺序规则和监视器锁规则推测出来\",{\"1\":{\"1432\":1}}],[\"今后可能需要关注的问题\",{\"0\":{\"1425\":1}}],[\"今天是\",{\"1\":{\"129\":1}}],[\"认定一个\",{\"1\":{\"1423\":1}}],[\"认定一个锁只会被单个线程访问\",{\"1\":{\"1423\":1}}],[\"认证通过后\",{\"1\":{\"451\":1}}],[\"认证管理器用户校验\",{\"1\":{\"451\":1}}],[\"认证管理器进行登录校验\",{\"1\":{\"447\":1}}],[\"认证失败处理类\",{\"1\":{\"446\":2}}],[\"认证就像用户登录时提交的用户名和密码\",{\"1\":{\"445\":1}}],[\"认证\",{\"1\":{\"445\":1}}],[\"认证和授权\",{\"1\":{\"445\":1}}],[\"易于编程\",{\"1\":{\"1423\":1}}],[\"承担哪些功能\",{\"1\":{\"1422\":1}}],[\"承载高并发和海量存储等场景难题\",{\"1\":{\"634\":1}}],[\"承载的功能模块相当之多\",{\"1\":{\"25\":1}}],[\"监视器锁规则\",{\"1\":{\"1421\":1}}],[\"监控\",{\"0\":{\"1168\":1}}],[\"监控完善\",{\"1\":{\"40\":1}}],[\"于任意后续对\",{\"1\":{\"1455\":1}}],[\"于任意后续对这个volatile域的读\",{\"1\":{\"1455\":1}}],[\"于任意后续对这个\",{\"1\":{\"1421\":1}}],[\"于对该监视器的加锁\",{\"1\":{\"1432\":1}}],[\"于线程\",{\"1\":{\"1421\":2}}],[\"于随后对这个锁的加锁\",{\"1\":{\"1421\":1}}],[\"于该线程中的任意后续操作\",{\"1\":{\"1421\":1}}],[\"于是就在桌子上贴了一张纸条\",{\"1\":{\"1416\":1}}],[\"于是就产生了\",{\"1\":{\"436\":1}}],[\"于是乎\",{\"1\":{\"1290\":1}}],[\"于是我们开篇的第一个问题\",{\"1\":{\"1239\":1}}],[\"于是我们发现只有一个大于\",{\"1\":{\"368\":1}}],[\"于是可以使用动态规划解决\",{\"1\":{\"851\":1}}],[\"于是可以去\",{\"1\":{\"576\":1}}],[\"于是利用之前学过的\",{\"1\":{\"668\":1}}],[\"于是\",{\"1\":{\"438\":1,\"1272\":1}}],[\"于是采用动态规划求解\",{\"1\":{\"72\":1}}],[\"于是在架构设计上\",{\"1\":{\"40\":1}}],[\"于是从2020年起\",{\"1\":{\"30\":1}}],[\"严重影响了并发编程的效率\",{\"1\":{\"1419\":1}}],[\"严格保证时序性\",{\"1\":{\"36\":1}}],[\"遵守\",{\"1\":{\"1418\":1}}],[\"遵循获取写锁\",{\"1\":{\"1237\":1,\"1244\":1}}],[\"妈妈在赶去坐公交的路上给小明打了个电话\",{\"1\":{\"1416\":1}}],[\"妈妈的手机还有电\",{\"1\":{\"1416\":1}}],[\"饭做好了\",{\"1\":{\"1416\":1}}],[\"报异常是因为线程从\",{\"1\":{\"1407\":1}}],[\"弄懂生产者\",{\"1\":{\"1402\":1}}],[\"弄懂了\",{\"1\":{\"1302\":1}}],[\"教室那里就是一个同步点\",{\"1\":{\"1399\":1}}],[\"教程\",{\"2\":{\"660\":1,\"667\":1,\"678\":1}}],[\"班主任需要班上\",{\"1\":{\"1398\":1}}],[\"跑道起点就相当于\",{\"1\":{\"1393\":1}}],[\"裁判员一声令下\",{\"1\":{\"1393\":2}}],[\"裁判员吹哨后才能开始跑步\",{\"1\":{\"1393\":1}}],[\"裁判员发号施令啦\",{\"1\":{\"1392\":2}}],[\"裁判员\",{\"1\":{\"1392\":2}}],[\"裁判员的任务也才完成\",{\"1\":{\"1392\":1}}],[\"裁判员在终点会为这\",{\"1\":{\"1392\":1}}],[\"倒计时\",{\"1\":{\"1392\":1}}],[\"倒计时器\",{\"0\":{\"1392\":1}}],[\"倒序输出\",{\"1\":{\"329\":1}}],[\"倒序插入\",{\"1\":{\"329\":1}}],[\"倒序存放\",{\"1\":{\"327\":1,\"328\":1}}],[\"型变量的原子更新方法\",{\"1\":{\"1385\":1}}],[\"借助了\",{\"1\":{\"1385\":1}}],[\"借助哈希表把原始节点和克隆节点的映射存储起来\",{\"1\":{\"887\":1}}],[\"混合型的任务\",{\"1\":{\"1361\":1}}],[\"混合日期和时间值\",{\"1\":{\"920\":2}}],[\"密集型任务和一个\",{\"1\":{\"1361\":1}}],[\"密集型任务和混合型任务\",{\"1\":{\"1361\":1}}],[\"密集型任务则由于需要等待\",{\"1\":{\"1361\":1}}],[\"密集型任务配置尽可能少的线程数量\",{\"1\":{\"1361\":1}}],[\"密集型任务\",{\"1\":{\"1361\":4}}],[\"密码在\",{\"1\":{\"906\":1}}],[\"密码直接以明文形式出现在命令行\",{\"1\":{\"906\":1}}],[\"密码直接在\",{\"1\":{\"906\":1}}],[\"密码则为系统所生成的密码\",{\"1\":{\"675\":1}}],[\"密码不能为空\",{\"1\":{\"587\":1}}],[\"密码不小于8位\",{\"1\":{\"568\":1,\"575\":1}}],[\"密码就不小于\",{\"1\":{\"574\":1}}],[\"密码千万不要直接明文存到数据库中\",{\"1\":{\"568\":1,\"575\":1}}],[\"密码千万不要直接以明文存储到数据库中\",{\"1\":{\"568\":1}}],[\"密码和校验密码是否相同\",{\"1\":{\"568\":1}}],[\"密码和校验密码相同\",{\"1\":{\"568\":1}}],[\"密码\",{\"1\":{\"510\":1,\"566\":2,\"568\":3,\"573\":1,\"575\":1}}],[\"丢弃掉阻塞队列中存放时间最久的任务\",{\"1\":{\"1359\":1}}],[\"拒绝策略\",{\"1\":{\"1359\":1}}],[\"拒绝访问一个类的时候\",{\"1\":{\"1045\":1}}],[\"省去创建线程的过程\",{\"1\":{\"1357\":1}}],[\"省略非核心代码\",{\"1\":{\"1145\":1}}],[\"省略其他字段\",{\"1\":{\"523\":2,\"525\":1}}],[\"紧接着\",{\"1\":{\"1340\":1,\"1368\":1}}],[\"紧接着到第\",{\"1\":{\"1272\":1}}],[\"守护线程自然而然就会退出\",{\"1\":{\"1340\":1}}],[\"守护线程是一种特殊的线程\",{\"1\":{\"1340\":1}}],[\"守护线程\",{\"0\":{\"1340\":1}}],[\"守护进程独立于任何终端会话\",{\"1\":{\"671\":1}}],[\"守护进程\",{\"1\":{\"671\":1}}],[\"守护进程干嘛的\",{\"1\":{\"671\":1}}],[\"⬇️\",{\"1\":{\"1339\":1}}],[\"睡眠\",{\"1\":{\"1336\":1}}],[\"损耗大量内存\",{\"1\":{\"1326\":1}}],[\"达到给定的延时时间后\",{\"1\":{\"1367\":2}}],[\"达到安全的状态\",{\"1\":{\"1318\":1}}],[\"达到人手一份的效果\",{\"1\":{\"1299\":1}}],[\"弱引用\",{\"1\":{\"1318\":1}}],[\"弱依赖\",{\"1\":{\"34\":1}}],[\"红色的是根据\",{\"1\":{\"1455\":1}}],[\"红色的为监视器锁规则推导而出\",{\"1\":{\"1432\":1}}],[\"红线表示\",{\"1\":{\"1315\":1}}],[\"红黑树也是一棵平衡的二叉树\",{\"1\":{\"958\":1}}],[\"红黑树\",{\"1\":{\"422\":1}}],[\"趟\",{\"1\":{\"1315\":1}}],[\"潜在的内存泄漏的问题\",{\"1\":{\"1314\":1}}],[\"垃圾回收\",{\"1\":{\"1313\":1}}],[\"牺牲了空间效率换来时间效率即\",{\"1\":{\"1313\":1}}],[\"牺牲了时间效率换来了空间效率即\",{\"1\":{\"1313\":1}}],[\"牺牲空间来换取读性能\",{\"1\":{\"436\":1}}],[\"老师直接准备了\",{\"1\":{\"1313\":1}}],[\"老师就控制着这支笔的使用顺序\",{\"1\":{\"1313\":1}}],[\"彼此不会影响达到隔离的作用\",{\"1\":{\"1313\":1}}],[\"彼此不影响\",{\"1\":{\"1309\":1}}],[\"拥有偏向锁的栈会被执行\",{\"1\":{\"1443\":1}}],[\"拥有\",{\"1\":{\"1365\":1}}],[\"拥有自己的\",{\"1\":{\"1309\":1}}],[\"拥有一个同步队列和多个等待队列\",{\"1\":{\"1250\":1}}],[\"称之为\",{\"1\":{\"1306\":1}}],[\"称为\",{\"1\":{\"1272\":1}}],[\"称为嵌套查询\",{\"1\":{\"947\":1}}],[\"称为盐\",{\"1\":{\"568\":1}}],[\"称为这个图的最大匹配\",{\"1\":{\"363\":1}}],[\"称为正确排列\",{\"1\":{\"224\":1,\"279\":1}}],[\"散列值部分\",{\"1\":{\"1306\":1}}],[\"散列表就是一个包含关键字的固定大小的数组\",{\"1\":{\"1306\":1}}],[\"散列表\",{\"1\":{\"1306\":1}}],[\"覆盖旧entry\",{\"1\":{\"1306\":1}}],[\"覆盖旧值即可\",{\"1\":{\"1272\":1}}],[\"摘自\",{\"1\":{\"1306\":1,\"1495\":1}}],[\"摘除\",{\"1\":{\"1160\":1}}],[\"势必会被回收\",{\"1\":{\"1305\":1}}],[\"势必得再对\",{\"1\":{\"1304\":1}}],[\"虚线代表的是弱引用\",{\"1\":{\"1313\":1}}],[\"虚线表示弱引用\",{\"1\":{\"1305\":1}}],[\"虚拟机特殊的约定\",{\"1\":{\"1453\":1}}],[\"虚拟机提供的最轻量级的同步机制\",{\"1\":{\"1453\":1}}],[\"虚拟机就会自然退出\",{\"1\":{\"1340\":1}}],[\"虚拟机\",{\"1\":{\"1042\":1}}],[\"虚拟头结点\",{\"1\":{\"789\":1}}],[\"虚拟头节点\",{\"1\":{\"700\":1}}],[\"虚拟文件系统等特性实现灵活的文件管理体验\",{\"1\":{\"669\":1}}],[\"马上能读到\",{\"1\":{\"1295\":1}}],[\"马哥的\",{\"1\":{\"634\":1}}],[\"脏值\",{\"1\":{\"1449\":1}}],[\"脏entry\",{\"1\":{\"1306\":1}}],[\"脏\",{\"1\":{\"1306\":3,\"1314\":1}}],[\"脏读\",{\"1\":{\"1295\":1,\"1417\":1,\"1425\":1}}],[\"脏数据或者非常规的展示侧控制\",{\"1\":{\"37\":1}}],[\"延时执行任务scheduledfuturetask\",{\"1\":{\"1370\":1}}],[\"延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的\",{\"1\":{\"1291\":1}}],[\"延迟升高\",{\"1\":{\"49\":1}}],[\"延迟导致了过程不一致\",{\"1\":{\"37\":1}}],[\"延迟\",{\"1\":{\"31\":1}}],[\"黑色的代表根据程序顺序规则推导出来\",{\"1\":{\"1455\":1}}],[\"黑色的是通过程序顺序规则推导出来\",{\"1\":{\"1432\":1}}],[\"黑名单等配置\",{\"1\":{\"1290\":1}}],[\"黑白名单过滤\",{\"1\":{\"493\":1,\"497\":1,\"508\":1}}],[\"机制\",{\"0\":{\"1431\":1},\"1\":{\"1290\":1,\"1345\":1}}],[\"机器学习\",{\"1\":{\"438\":1}}],[\"猜的\",{\"1\":{\"1286\":1}}],[\"套路\",{\"1\":{\"1283\":1}}],[\"套餐\",{\"1\":{\"152\":3}}],[\"套餐里任意两种咖啡饮品价格差的最小值\",{\"1\":{\"152\":1}}],[\"临界点\",{\"1\":{\"1283\":1}}],[\"临界区用来表示一种公共资源或者说是共享数据\",{\"1\":{\"1226\":1}}],[\"临界区\",{\"0\":{\"1226\":1}}],[\"知道\",{\"1\":{\"1282\":1}}],[\"明白它的底层数据结构\",{\"1\":{\"1281\":1}}],[\"明确需求开发的优先级\",{\"1\":{\"506\":1}}],[\"明确要做的需求\",{\"1\":{\"506\":1}}],[\"独占式锁的获取过程也就是\",{\"1\":{\"1505\":1}}],[\"独占式锁的获取和释放\",{\"1\":{\"1500\":1}}],[\"独占式锁\",{\"1\":{\"1500\":1}}],[\"独占式锁进行线程安全的并发控制的\",{\"1\":{\"1264\":1}}],[\"独占式释放同步状态\",{\"1\":{\"1496\":1}}],[\"独占式获取同步状态\",{\"1\":{\"1496\":1,\"1500\":1}}],[\"独占式获取与释放同步状态\",{\"1\":{\"1495\":1}}],[\"独占式\",{\"1\":{\"1496\":1}}],[\"独占锁的释放就相对来说比较容易理解了\",{\"1\":{\"1506\":1}}],[\"独占锁的释放\",{\"0\":{\"1506\":1}}],[\"独占锁的获取\",{\"0\":{\"1503\":1}}],[\"独占锁\",{\"0\":{\"1502\":1},\"1\":{\"1280\":1}}],[\"谈谈concurrenthashmap1\",{\"1\":{\"1276\":1}}],[\"臃肿的设计\",{\"1\":{\"1276\":1}}],[\"刚刚发送的消息\",{\"1\":{\"1456\":1}}],[\"刚插入后该位置\",{\"1\":{\"1315\":1}}],[\"刚插入的最新的那个节点呢\",{\"1\":{\"1284\":1}}],[\"刚好在做\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"刚好在这个时候\",{\"1\":{\"1283\":1}}],[\"刚好等于新容量的\",{\"1\":{\"1274\":1}}],[\"刚需关键词检索能力\",{\"1\":{\"26\":1}}],[\"仔细体会下会发现很巧妙\",{\"1\":{\"1274\":1}}],[\"桶数组节点即\",{\"1\":{\"1273\":1}}],[\"桶节点的key与查找的key相同\",{\"1\":{\"1273\":1}}],[\"碰撞\",{\"1\":{\"1272\":1}}],[\"挺有意思的吧\",{\"1\":{\"1271\":1}}],[\"域也为\",{\"1\":{\"1505\":1}}],[\"域已经完全初始化成功\",{\"1\":{\"1478\":1}}],[\"域已经在构造函数被初始化过了\",{\"1\":{\"1478\":1}}],[\"域已经被正确初始化过了\",{\"1\":{\"1475\":1}}],[\"域需要的\",{\"1\":{\"1477\":1}}],[\"域会要求编译器在\",{\"1\":{\"1477\":1}}],[\"域读\",{\"1\":{\"1476\":1}}],[\"域全部已经初始化过\",{\"1\":{\"1476\":1}}],[\"域写重排序规则\",{\"1\":{\"1478\":1}}],[\"域写重排序规则可以确保我们在使用一个对象引用的时候\",{\"1\":{\"1478\":1}}],[\"域写重排序到构造方法之外\",{\"1\":{\"1476\":1}}],[\"域写与构造方法重排序\",{\"1\":{\"1476\":1}}],[\"域写\",{\"1\":{\"1476\":1}}],[\"域写针对编译器和处理器重排序增加了这样的约束\",{\"1\":{\"1476\":1}}],[\"域写之后\",{\"1\":{\"1475\":1,\"1477\":1}}],[\"域之前\",{\"1\":{\"1475\":1}}],[\"域存在间接依赖性\",{\"1\":{\"1475\":1}}],[\"域操作的前面插入一个\",{\"1\":{\"1475\":1}}],[\"域变量前已经读到了该对象的引用\",{\"1\":{\"1475\":1}}],[\"域变量\",{\"1\":{\"1475\":1}}],[\"域变为不可达\",{\"1\":{\"1316\":1}}],[\"域重排序规则为\",{\"1\":{\"1475\":1}}],[\"域重排序规则\",{\"0\":{\"1474\":1},\"1\":{\"1475\":2}}],[\"域的操作前插入一个\",{\"1\":{\"1477\":1}}],[\"域的重排序\",{\"1\":{\"1476\":1}}],[\"域的重排序规则会要求编译器在读\",{\"1\":{\"1477\":1}}],[\"域的重排序规则可以确保\",{\"1\":{\"1475\":2}}],[\"域的重排序规则为\",{\"1\":{\"1475\":1}}],[\"域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序\",{\"1\":{\"1476\":1}}],[\"域的对象的引用\",{\"1\":{\"1475\":1}}],[\"域的读操作就\",{\"1\":{\"1475\":1}}],[\"域的读\",{\"1\":{\"1421\":1,\"1477\":1}}],[\"域的写禁止重排序到构造方法外\",{\"1\":{\"1476\":1}}],[\"域的写重排序到构造函数之外\",{\"1\":{\"1475\":2}}],[\"域的写\",{\"1\":{\"1421\":1,\"1455\":1}}],[\"域不为\",{\"1\":{\"1286\":1}}],[\"域设置为\",{\"1\":{\"1284\":1,\"1505\":1}}],[\"域指向它自己\",{\"1\":{\"1284\":2}}],[\"域为引用类型\",{\"0\":{\"1476\":1}}],[\"域为基本类型\",{\"0\":{\"1475\":1}}],[\"域为\",{\"1\":{\"1281\":2,\"1283\":2,\"1285\":2,\"1286\":1,\"1316\":1}}],[\"域\",{\"1\":{\"1267\":1,\"1283\":2,\"1475\":1}}],[\"域名解析dns\",{\"1\":{\"672\":1}}],[\"域名加速访问\",{\"1\":{\"670\":1}}],[\"扩容\",{\"1\":{\"1306\":1}}],[\"扩容结束修改sizectl属性\",{\"1\":{\"1274\":1}}],[\"扩容时使用\",{\"1\":{\"1266\":1}}],[\"扩展\",{\"1\":{\"526\":1,\"1140\":1}}],[\"扩展欧几里得\",{\"1\":{\"384\":1}}],[\"扩展欧几里得算法\",{\"0\":{\"382\":1}}],[\"装载\",{\"1\":{\"1266\":1}}],[\"光是代码量就足足增加了很多\",{\"1\":{\"1264\":1}}],[\"光标放在\",{\"1\":{\"576\":1}}],[\"充当锁的角色\",{\"1\":{\"1264\":1}}],[\"充分利用多核\",{\"1\":{\"1218\":1}}],[\"秒结束后通过\",{\"1\":{\"1260\":1}}],[\"秒的\",{\"1\":{\"60\":2}}],[\"致使\",{\"1\":{\"1260\":1}}],[\"致使线程阻塞\",{\"1\":{\"1259\":1}}],[\"致力于为中文互联网提供一个和谐\",{\"1\":{\"41\":1}}],[\"案发现场\",{\"1\":{\"1259\":1}}],[\"案例\",{\"1\":{\"915\":1,\"922\":2,\"926\":1,\"939\":1}}],[\"唤醒处于阻塞状态的指定线程\",{\"1\":{\"1259\":1}}],[\"唤醒线程\",{\"1\":{\"1259\":1}}],[\"唤醒一个等待在\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"纳秒\",{\"1\":{\"1259\":1}}],[\"究竟为何方神圣\",{\"1\":{\"1258\":1}}],[\"尾节点\",{\"1\":{\"1251\":1}}],[\"尾插入节点失败后负责自旋进行尝试\",{\"1\":{\"1504\":1}}],[\"尾插入\",{\"1\":{\"1251\":1,\"1504\":1}}],[\"尾插入到等待队列中\",{\"1\":{\"1251\":2}}],[\"示意图\",{\"1\":{\"1315\":1,\"1316\":1}}],[\"示意图如下\",{\"1\":{\"1250\":1,\"1315\":1,\"1505\":1}}],[\"示例中开启了两个线程\",{\"1\":{\"1406\":1}}],[\"示例中图形就可以通过让\",{\"1\":{\"224\":1,\"279\":1}}],[\"示例配置在\",{\"1\":{\"664\":1}}],[\"示例代码就不给出了\",{\"1\":{\"1317\":1}}],[\"示例代码很简单就不说了\",{\"1\":{\"1259\":1}}],[\"示例代码\",{\"1\":{\"273\":1,\"274\":1}}],[\"示例解析\",{\"1\":{\"181\":1}}],[\"示例结果\",{\"1\":{\"181\":1}}],[\"示例\",{\"1\":{\"70\":1,\"71\":1,\"72\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"92\":1,\"93\":1,\"97\":1,\"98\":1,\"99\":1,\"104\":1,\"108\":1,\"109\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"134\":1,\"135\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"157\":1,\"161\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1,\"193\":1,\"196\":1,\"199\":1,\"202\":1,\"205\":1,\"663\":1,\"920\":1,\"935\":1,\"1154\":1}}],[\"吞吐量还是非公平优于公平\",{\"1\":{\"1237\":1}}],[\"饥饿\",{\"1\":{\"1233\":1}}],[\"造成内存泄露的原因\",{\"0\":{\"1313\":1}}],[\"造成内存泄漏\",{\"1\":{\"1305\":1}}],[\"造成\",{\"1\":{\"1233\":1}}],[\"何谓公平性\",{\"1\":{\"1233\":1}}],[\"何时构造\",{\"1\":{\"1132\":1}}],[\"彻底理解\",{\"0\":{\"1230\":1,\"1428\":1,\"1452\":1}}],[\"阻塞从队列中获取数据的线程\",{\"1\":{\"1411\":1}}],[\"阻塞向队列中插入数据的线程\",{\"1\":{\"1411\":1}}],[\"阻塞消费者继续消费数据\",{\"1\":{\"1402\":1}}],[\"阻塞生产者继续生产数据放置入内\",{\"1\":{\"1402\":1}}],[\"阻塞等待直至到达超时时间为止\",{\"1\":{\"1393\":1}}],[\"阻塞结束\",{\"1\":{\"1392\":1}}],[\"阻塞同步\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"阻塞状态\",{\"1\":{\"1334\":1}}],[\"阻塞队列完全可以充当共享数据区域\",{\"1\":{\"1411\":1}}],[\"阻塞队列最好是使用有界队列\",{\"1\":{\"1361\":1}}],[\"阻塞队列最核心的功能是\",{\"1\":{\"1345\":1}}],[\"阻塞队列\",{\"1\":{\"1324\":1,\"1359\":3,\"1371\":1}}],[\"阻塞\",{\"1\":{\"1260\":1,\"1329\":1}}],[\"阻塞了线程\",{\"1\":{\"1259\":1}}],[\"阻塞和等待线程\",{\"0\":{\"1332\":1}}],[\"阻塞和唤醒线程的功能是依赖于\",{\"1\":{\"1259\":1}}],[\"阻塞和非阻塞通常用来形容多线程间的相互影响\",{\"1\":{\"1225\":1}}],[\"阻塞和非阻塞\",{\"0\":{\"1225\":1}}],[\"阻塞当前线程\",{\"1\":{\"1259\":3}}],[\"阻塞线程\",{\"1\":{\"1259\":1}}],[\"阻止方法执行\",{\"1\":{\"465\":1}}],[\"释放前驱节点\",{\"1\":{\"1504\":1,\"1505\":1}}],[\"释放同步状态\",{\"1\":{\"1500\":1}}],[\"释放后的变量才可以被其他线程锁定\",{\"1\":{\"1482\":1}}],[\"释放掉对象锁\",{\"1\":{\"1407\":1}}],[\"释放指定个数的许可\",{\"1\":{\"1398\":1}}],[\"释放许可\",{\"1\":{\"1398\":1}}],[\"释放当前线程所占用的lock\",{\"1\":{\"1251\":1}}],[\"释放了许可之后\",{\"1\":{\"1398\":1}}],[\"释放了\",{\"1\":{\"1232\":1}}],[\"释放自减的方式实现重入\",{\"1\":{\"1231\":1}}],[\"释放的resource\",{\"1\":{\"1221\":1}}],[\"释放的\",{\"1\":{\"1221\":1}}],[\"释放锁时对同步队列中的线程进行通知等核心方法\",{\"1\":{\"1501\":1}}],[\"释放锁的时候会唤醒后继节点\",{\"1\":{\"1506\":1}}],[\"释放锁的时候会将共享变量同步到主内存中\",{\"1\":{\"1486\":1}}],[\"释放锁的时候会将值刷新到主内存中\",{\"1\":{\"1433\":1}}],[\"释放锁的时候同样会重写到主内存中\",{\"1\":{\"1433\":1}}],[\"释放锁的过程\",{\"1\":{\"1251\":1}}],[\"释放锁相对应的内存语义\",{\"1\":{\"1433\":1}}],[\"释放锁后就会将计数器减一\",{\"1\":{\"1431\":1}}],[\"释放锁\",{\"1\":{\"1061\":1,\"1432\":1}}],[\"稍后揭晓\",{\"1\":{\"1292\":1}}],[\"稍微不注意就会出现死锁的情况\",{\"1\":{\"1221\":1}}],[\"稍有不慎就会报错\",{\"1\":{\"546\":1}}],[\"测量上下文切换次数\",{\"1\":{\"1220\":1}}],[\"测量上下文切换的时长\",{\"1\":{\"1220\":1}}],[\"测试encache\",{\"1\":{\"1211\":1}}],[\"测试用例的答案是一个\",{\"1\":{\"704\":1}}],[\"测试用例中不会出现超出匹配字符范围之外的字符\",{\"1\":{\"127\":1}}],[\"测试端口是否能连接上\",{\"1\":{\"663\":1}}],[\"测试账号不重复\",{\"1\":{\"568\":1}}],[\"测试账户长度小于4\",{\"1\":{\"568\":1}}],[\"测试密码和校验密码不相同\",{\"1\":{\"568\":1}}],[\"测试密码小于6位\",{\"1\":{\"568\":1}}],[\"测试特殊字符\",{\"1\":{\"568\":1}}],[\"测试非空\",{\"1\":{\"568\":1}}],[\"测试出错的情况\",{\"1\":{\"568\":1}}],[\"测试注册功能\",{\"1\":{\"568\":1}}],[\"测试类如下\",{\"1\":{\"567\":1}}],[\"测试相关的配置文件\",{\"1\":{\"559\":1}}],[\"测试\",{\"0\":{\"1204\":1,\"1207\":1,\"1211\":1},\"1\":{\"555\":1}}],[\"频繁的上下文切换\",{\"0\":{\"1220\":1}}],[\"难道就没有一点缺点么\",{\"1\":{\"1219\":1}}],[\"难以抉择\",{\"1\":{\"438\":1}}],[\"难以承载评论的大流量\",{\"1\":{\"33\":1}}],[\"顶级计算机科学家\",{\"1\":{\"1218\":1}}],[\"催生了并发编程的趋势\",{\"1\":{\"1218\":1}}],[\"聪明的硬件工程师并没有停止研发的脚步\",{\"1\":{\"1218\":1}}],[\"芯片的计划推迟到2005年\",{\"1\":{\"1218\":1}}],[\"宣布彻底取消\",{\"1\":{\"1218\":1}}],[\"宣布\",{\"1\":{\"1218\":1}}],[\"摩尔定律似乎在\",{\"1\":{\"1218\":1}}],[\"摩尔定律并不是一种自然法则或者是物理定律\",{\"1\":{\"1218\":1}}],[\"摩尔定律\",{\"1\":{\"1218\":1}}],[\"杂项\",{\"2\":{\"1212\":1,\"1215\":1}}],[\"毫秒检查一下过期的缓存数据\",{\"1\":{\"1201\":1}}],[\"毫无隐私可言\",{\"1\":{\"668\":1}}],[\"悟空我的本机是\",{\"1\":{\"1194\":1}}],[\"核\",{\"1\":{\"1194\":1}}],[\"核心为两个部分\",{\"1\":{\"1433\":1}}],[\"核心方法在于\",{\"1\":{\"1506\":1}}],[\"核心方法是\",{\"1\":{\"1385\":1}}],[\"核心方法为\",{\"1\":{\"1232\":2,\"1233\":1}}],[\"核心线程数设置为\",{\"1\":{\"1361\":2}}],[\"核心线程池\",{\"1\":{\"1359\":1}}],[\"核心线程池中所有的线程都在执行任务\",{\"1\":{\"1358\":1}}],[\"核心数\",{\"1\":{\"1361\":1}}],[\"核心扩展上继续得到体验\",{\"1\":{\"1218\":1}}],[\"核心甚至\",{\"1\":{\"1218\":1}}],[\"核心业务流程\",{\"0\":{\"494\":1}}],[\"核心\",{\"0\":{\"479\":1},\"1\":{\"1218\":1}}],[\"核心思想为\",{\"1\":{\"1266\":1}}],[\"核心思想\",{\"1\":{\"421\":1}}],[\"核心思路\",{\"1\":{\"373\":1}}],[\"核心思路是先按照等级对元组进行排序\",{\"1\":{\"140\":1}}],[\"核心是高效地在指定区间内找出保质期最长的特定类型商品\",{\"1\":{\"168\":1}}],[\"核心在于找出幂运算结果个位数的循环规律\",{\"1\":{\"139\":1}}],[\"名称\",{\"1\":{\"1193\":1}}],[\"名企面试官精讲典型编程题\",{\"1\":{\"655\":1}}],[\"留个问题\",{\"0\":{\"1186\":1}}],[\"留给后手都是一个必胜状态时\",{\"1\":{\"394\":1}}],[\"留给后手是一个必败状态时\",{\"1\":{\"394\":1}}],[\"抓取注册表\",{\"1\":{\"1185\":1}}],[\"叫做\",{\"1\":{\"1184\":1}}],[\"叫做求最小生成树\",{\"1\":{\"359\":1}}],[\"心跳检测\",{\"1\":{\"1182\":1}}],[\"商品服务等\",{\"1\":{\"1175\":1}}],[\"商业利益\",{\"1\":{\"39\":1}}],[\"商业软件\",{\"1\":{\"21\":1}}],[\"叕\",{\"0\":{\"1175\":1},\"1\":{\"1175\":1}}],[\"领导\",{\"0\":{\"1175\":1},\"1\":{\"1175\":1}}],[\"领导让我研究\",{\"0\":{\"1144\":1},\"1\":{\"1144\":1}}],[\"续约\",{\"1\":{\"1160\":1}}],[\"情况\",{\"1\":{\"1317\":1}}],[\"情况示意图\",{\"1\":{\"1317\":1}}],[\"情况下\",{\"1\":{\"1158\":1}}],[\"情绪\",{\"1\":{\"39\":1}}],[\"拿到\",{\"1\":{\"1158\":1}}],[\"赋给\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"赋给变量操作就是不安全的\",{\"1\":{\"1266\":1}}],[\"赋值\",{\"1\":{\"1482\":1}}],[\"赋值为\",{\"1\":{\"1283\":1,\"1301\":1}}],[\"赋值给线程工作内存的变量\",{\"1\":{\"1482\":1}}],[\"赋值给sizectl\",{\"1\":{\"1270\":1}}],[\"赋值给变量\",{\"1\":{\"1266\":1}}],[\"赋值给了\",{\"1\":{\"1158\":1}}],[\"赋值给\",{\"1\":{\"1151\":1,\"1270\":1,\"1383\":1,\"1437\":1}}],[\"赋予可执行权限\",{\"1\":{\"1087\":1}}],[\"赋予执行权限\",{\"1\":{\"670\":1}}],[\"谁不会啊\",{\"1\":{\"1141\":1}}],[\"谁控制谁\",{\"1\":{\"1129\":3}}],[\"暂且认为是\",{\"1\":{\"1141\":1}}],[\"暂停任务\",{\"1\":{\"482\":1}}],[\"暂停和恢复任务\",{\"1\":{\"479\":1}}],[\"暂停\",{\"1\":{\"475\":1,\"1284\":1}}],[\"咋一看还是挺简单的\",{\"1\":{\"1141\":1}}],[\"虽然它失去了像\",{\"1\":{\"1492\":1}}],[\"虽然只有一行代码\",{\"1\":{\"1475\":1}}],[\"虽然只有一部分\",{\"1\":{\"1134\":1}}],[\"虽然真正存放数据的是\",{\"1\":{\"1299\":1}}],[\"虽然\",{\"1\":{\"1286\":1,\"1299\":1}}],[\"虽然你可以更换\",{\"1\":{\"664\":1}}],[\"赵丽颖款式的\",{\"1\":{\"1133\":1}}],[\"顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表\",{\"1\":{\"1133\":1}}],[\"销毁都由\",{\"1\":{\"1131\":1}}],[\"唱歌像周杰伦\",{\"1\":{\"1131\":1}}],[\"身材像林熙雷\",{\"1\":{\"1131\":1}}],[\"身份证的有效期\",{\"1\":{\"938\":1}}],[\"身份证签发机关\",{\"1\":{\"938\":1}}],[\"身份证号\",{\"1\":{\"938\":1}}],[\"身份信息\",{\"1\":{\"938\":1}}],[\"身份认证接口\",{\"1\":{\"446\":1}}],[\"告诉\",{\"1\":{\"1131\":1,\"1433\":1,\"1496\":1}}],[\"告诉它我想找个什么样的女朋友\",{\"1\":{\"1131\":1}}],[\"告诉前端这个请求在业务层面上是成功还是失败\",{\"1\":{\"598\":1}}],[\"婚介管理了很多男男女女的资料\",{\"1\":{\"1131\":1}}],[\"婚姻介绍所\",{\"1\":{\"1131\":1}}],[\"投其所好送其所要\",{\"1\":{\"1131\":1}}],[\"投递一个\",{\"1\":{\"60\":1}}],[\"投递到消息队列\",{\"1\":{\"31\":1}}],[\"贯穿始终\",{\"1\":{\"1131\":1}}],[\"贯穿上下文\",{\"1\":{\"40\":1}}],[\"浅显易懂的讲解\",{\"0\":{\"1130\":1}}],[\"送过来\",{\"1\":{\"1129\":1}}],[\"家用型\",{\"1\":{\"1218\":1}}],[\"家用电器或电子计算机\",{\"1\":{\"21\":1}}],[\"家目录路径下执行\",{\"1\":{\"1107\":1}}],[\"绝对路径下执行\",{\"1\":{\"1107\":1}}],[\"份奇偶校验块\",{\"1\":{\"1095\":1}}],[\"份数据和\",{\"1\":{\"1095\":1}}],[\"码作为其纠删码算法\",{\"1\":{\"1095\":1}}],[\"纠删码\",{\"1\":{\"1095\":1}}],[\"兼容协议\",{\"1\":{\"1095\":1}}],[\"兼容亚马逊\",{\"1\":{\"1093\":1}}],[\"亚马逊云的\",{\"1\":{\"1095\":1}}],[\"轻量级解锁时\",{\"1\":{\"1447\":1}}],[\"轻量级锁状态和重量级锁状态\",{\"1\":{\"1440\":1}}],[\"轻量级锁\",{\"0\":{\"1445\":1},\"1\":{\"1264\":1}}],[\"轻便\",{\"1\":{\"1094\":1}}],[\"轻松驾驭复杂业务场景\",{\"1\":{\"639\":1}}],[\"音频形式存储的数据\",{\"1\":{\"1093\":1}}],[\"音乐播放器\",{\"1\":{\"658\":1}}],[\"音乐剧\",{\"1\":{\"21\":1}}],[\"音乐制作\",{\"1\":{\"21\":1}}],[\"社交媒体文章\",{\"1\":{\"1093\":1}}],[\"社区影响也大\",{\"1\":{\"39\":1}}],[\"云存储和\",{\"1\":{\"1095\":1}}],[\"云存储服务接口\",{\"1\":{\"1093\":1}}],[\"云原生应用程序需要更高的吞吐量和更低的延迟\",{\"1\":{\"1095\":1}}],[\"云原生\",{\"1\":{\"1095\":1}}],[\"云端生成外链使用\",{\"1\":{\"670\":1}}],[\"卸载服务\",{\"1\":{\"1090\":1}}],[\"版的\",{\"1\":{\"1089\":1}}],[\"版本与\",{\"1\":{\"1276\":1}}],[\"版本中\",{\"1\":{\"1272\":1}}],[\"版本中为了防止拉链过长\",{\"1\":{\"1272\":1}}],[\"版本之前的\",{\"1\":{\"1272\":1}}],[\"版本舍弃了\",{\"1\":{\"1264\":1}}],[\"版本为\",{\"1\":{\"663\":1}}],[\"版本检测命令\",{\"1\":{\"537\":1}}],[\"版本的组件库\",{\"1\":{\"540\":1}}],[\"版本的工具\",{\"1\":{\"537\":1}}],[\"版本的\",{\"1\":{\"537\":1,\"1276\":1}}],[\"版本\",{\"1\":{\"502\":3,\"559\":1,\"670\":1}}],[\"版本需要使用\",{\"1\":{\"502\":1}}],[\"版本2\",{\"0\":{\"322\":1}}],[\"版本1\",{\"0\":{\"321\":1}}],[\"拉链转换成红黑树\",{\"1\":{\"1272\":1}}],[\"拉链法\",{\"0\":{\"419\":1},\"1\":{\"1272\":1}}],[\"拉取\",{\"1\":{\"1088\":1}}],[\"镜像\",{\"1\":{\"1088\":2}}],[\"镜像为国内源\",{\"1\":{\"538\":1}}],[\"信号的线程\",{\"1\":{\"1330\":1}}],[\"信号\",{\"1\":{\"1087\":1}}],[\"信息管理器的\",{\"1\":{\"1178\":1}}],[\"信息\",{\"1\":{\"599\":1,\"1179\":1,\"1267\":1}}],[\"信息脱敏通常应用于需要处理敏感数据的场景\",{\"1\":{\"574\":1}}],[\"信息脱敏\",{\"1\":{\"574\":1}}],[\"信息可以直接使用\",{\"1\":{\"56\":1}}],[\"键\",{\"1\":{\"1074\":1,\"1201\":1}}],[\"键值对以\",{\"1\":{\"1074\":1}}],[\"键值对乱序\",{\"1\":{\"1074\":1}}],[\"键值对存储\",{\"1\":{\"972\":1}}],[\"底层是采用数组构成的\",{\"1\":{\"1369\":1}}],[\"底层是采用的数组进行实现\",{\"1\":{\"1353\":1}}],[\"底层是通过双向链表实现的\",{\"1\":{\"1072\":1}}],[\"底层是通过数组\",{\"1\":{\"1072\":1}}],[\"底层方法\",{\"1\":{\"1282\":1}}],[\"底层数据结构改变为采用数组+链表+红黑树的数据形式\",{\"1\":{\"1264\":1}}],[\"底层级别的\",{\"1\":{\"1248\":1}}],[\"底层的传输组件\",{\"1\":{\"1184\":1}}],[\"底部栏\",{\"1\":{\"549\":1}}],[\"底部栏的响应式布局\",{\"1\":{\"548\":1}}],[\"忽略大小写进行比较\",{\"1\":{\"1069\":1}}],[\"忽略警告等\",{\"1\":{\"1051\":1}}],[\"系列的返回值\",{\"1\":{\"1069\":1}}],[\"系统在三种情况下会出现红色加粗的字体提示\",{\"1\":{\"1191\":1}}],[\"系统状态\",{\"0\":{\"1190\":1}}],[\"系统会自动报警\",{\"1\":{\"826\":1}}],[\"系统会使用相同的盐和用户输入的密码进行组合\",{\"1\":{\"568\":1}}],[\"系统生成的连接地址填入\",{\"1\":{\"676\":1}}],[\"系统有很多守护进程\",{\"1\":{\"671\":1}}],[\"系统设计之路\",{\"1\":{\"634\":1}}],[\"系统可以容忍一定的误判率\",{\"1\":{\"613\":1}}],[\"系统可以考虑自行重试\",{\"1\":{\"37\":1}}],[\"系统测试\",{\"1\":{\"555\":1}}],[\"系统错误\",{\"1\":{\"526\":1}}],[\"系统支持以下五种数据权限类型\",{\"1\":{\"470\":1}}],[\"系统中一般默认使用\",{\"1\":{\"1107\":1}}],[\"系统中\",{\"1\":{\"470\":1}}],[\"系统通过这些信息来验证\",{\"1\":{\"445\":1}}],[\"系统架构设计\",{\"1\":{\"151\":1}}],[\"系统需求分析\",{\"1\":{\"151\":1}}],[\"系统需要处理大量的广告点击数据\",{\"1\":{\"151\":1}}],[\"系统需要避免重复回传数据\",{\"1\":{\"151\":1}}],[\"系统需要在高并发下处理广告点击数据\",{\"1\":{\"151\":1}}],[\"系统始终以最大化方式消费\",{\"1\":{\"49\":1}}],[\"系统的数据权限设计主要通过用户\",{\"1\":{\"471\":1}}],[\"系统的瓶颈往往就来自于存储层\",{\"1\":{\"49\":1}}],[\"系统的并发处理能力有了极大提升\",{\"1\":{\"33\":1}}],[\"系统\",{\"1\":{\"46\":1}}],[\"休眠一个线程\",{\"1\":{\"1060\":1}}],[\"抑制编译器警告\",{\"1\":{\"1052\":1}}],[\"限定\",{\"1\":{\"1475\":1}}],[\"限定某个函数必须重载其他函数\",{\"1\":{\"1052\":1}}],[\"限定某个函数必须重写其他函数\",{\"1\":{\"1052\":1}}],[\"限制该字段值不能为null\",{\"1\":{\"919\":1}}],[\"限制每个用户注销的次数\",{\"1\":{\"613\":1}}],[\"限制在本部门范围内\",{\"1\":{\"470\":1}}],[\"旧值\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"旧的对象和新写入的对象\",{\"1\":{\"1295\":1}}],[\"旧版中所遗留的繁冗代码和\",{\"1\":{\"1051\":1}}],[\"旧字段名\",{\"1\":{\"922\":1}}],[\"局部变量的情况\",{\"1\":{\"1466\":1}}],[\"局部变量已经进行了初始化则后面就不能再次进行更改\",{\"1\":{\"1466\":1}}],[\"局部变量由程序员进行显式初始化\",{\"1\":{\"1466\":1}}],[\"局部变量\",{\"0\":{\"1466\":1},\"1\":{\"1116\":1}}],[\"局部变量等数据信息\",{\"1\":{\"1051\":1}}],[\"局部串行的生产消费方式\",{\"1\":{\"49\":1}}],[\"抛出\",{\"1\":{\"1336\":1}}],[\"抛出异常\",{\"0\":{\"1048\":1},\"1\":{\"1326\":1}}],[\"抛出的异常表明某一线程已经试图等待对象的监视器\",{\"1\":{\"1045\":1}}],[\"抛出的异常表明向方法传递了一个不合法或不正确的参数\",{\"1\":{\"1045\":1}}],[\"抛出该异常\",{\"1\":{\"1045\":9}}],[\"抛出此类的一个实例\",{\"1\":{\"1045\":1}}],[\"抛出此异常\",{\"1\":{\"1045\":1}}],[\"试想\",{\"1\":{\"1284\":1}}],[\"试图将错误类型的对象存储到一个对象数组时抛出的异常\",{\"1\":{\"1045\":1}}],[\"试除法求所有约数\",{\"0\":{\"375\":1}}],[\"试除法分解质因数\",{\"0\":{\"368\":1}}],[\"试除法判定质数\",{\"0\":{\"367\":1}}],[\"九\",{\"0\":{\"1041\":1}}],[\"七\",{\"0\":{\"1024\":1}}],[\"七牛云\",{\"1\":{\"668\":1}}],[\"八\",{\"0\":{\"1035\":1}}],[\"八大基本数据类型和\",{\"1\":{\"1017\":1}}],[\"八数码\",{\"1\":{\"224\":1}}],[\"错误\",{\"1\":{\"1012\":3,\"1013\":1}}],[\"六\",{\"0\":{\"1008\":1}}],[\"速度像卡洛斯\",{\"1\":{\"1131\":1}}],[\"速度较快\",{\"1\":{\"1007\":1}}],[\"速度较慢\",{\"1\":{\"1007\":1}}],[\"速度快\",{\"1\":{\"434\":1}}],[\"遇到含糊不清的地方\",{\"1\":{\"1107\":1}}],[\"遇到回车才会停止\",{\"1\":{\"1006\":1}}],[\"遇到空格不会停止输入\",{\"1\":{\"1006\":1}}],[\"遇到空格\",{\"1\":{\"1006\":1}}],[\"死循环中会继续重试\",{\"1\":{\"1505\":1}}],[\"死循环中不断尝试\",{\"1\":{\"1504\":1}}],[\"死循环\",{\"1\":{\"988\":1,\"1340\":1,\"1504\":1}}],[\"项\",{\"1\":{\"988\":1,\"990\":1,\"999\":1}}],[\"项目开发中\",{\"1\":{\"936\":1}}],[\"项目部署\",{\"0\":{\"605\":1}}],[\"项目又封装了一次\",{\"1\":{\"585\":1}}],[\"项目的方式\",{\"0\":{\"560\":1}}],[\"项目中的每个页面和组件都是单独的文件夹\",{\"1\":{\"544\":1}}],[\"项目中引入\",{\"1\":{\"540\":1}}],[\"项目中涉及到大量企业项目开发新技术\",{\"1\":{\"493\":1}}],[\"项目主流的组件库\",{\"1\":{\"540\":1}}],[\"项目\",{\"1\":{\"1141\":1},\"2\":{\"503\":1,\"527\":1,\"552\":1,\"561\":1,\"569\":1,\"581\":1,\"593\":1,\"601\":1,\"611\":1,\"614\":1}}],[\"项目功能\",{\"0\":{\"495\":1}}],[\"项目介绍\",{\"0\":{\"492\":1,\"493\":1},\"1\":{\"492\":1}}],[\"项目在启动时\",{\"1\":{\"480\":1}}],[\"闰年有两种情况\",{\"1\":{\"984\":1}}],[\"练习题3\",{\"1\":{\"999\":1}}],[\"练习题2\",{\"1\":{\"999\":1}}],[\"练习题1\",{\"1\":{\"999\":1}}],[\"练习\",{\"1\":{\"984\":4,\"985\":1,\"988\":2,\"990\":2,\"994\":1}}],[\"闫学灿\",{\"1\":{\"983\":1,\"987\":1,\"995\":1,\"1003\":1,\"1008\":1,\"1024\":1,\"1041\":1}}],[\"浮点数\",{\"1\":{\"980\":1}}],[\"浮点数二分\",{\"0\":{\"325\":1}}],[\"冲突就需要向后环形查找\",{\"1\":{\"1314\":1}}],[\"冲突概率的一个平衡\",{\"1\":{\"1306\":1}}],[\"冲突的情况\",{\"1\":{\"1307\":1}}],[\"冲突的可能性越小\",{\"1\":{\"1306\":1}}],[\"冲突的可能性越大\",{\"1\":{\"1306\":1}}],[\"冲突的问题\",{\"1\":{\"1306\":2}}],[\"冲突的概率\",{\"1\":{\"1272\":1}}],[\"冲突\",{\"1\":{\"1272\":1,\"1306\":1}}],[\"冲突解决策略以及负载因子的调整等问题\",{\"1\":{\"973\":1}}],[\"冲突可能导致性能下降\",{\"1\":{\"973\":1}}],[\"冲突问题\",{\"1\":{\"973\":1}}],[\"灵活的键类型\",{\"1\":{\"972\":1}}],[\"灵活动态交互的优点\",{\"1\":{\"535\":1}}],[\"链式编程\",{\"1\":{\"1100\":1}}],[\"链地址法\",{\"1\":{\"971\":1}}],[\"链表就转换为红黑树\",{\"1\":{\"1272\":1}}],[\"链表长度\",{\"1\":{\"1072\":1}}],[\"链表无法像数组那样直接通过索引来获取元素\",{\"1\":{\"777\":1}}],[\"链表有顺序之分\",{\"1\":{\"687\":1}}],[\"链表\",{\"1\":{\"274\":1,\"1072\":1},\"2\":{\"684\":1,\"690\":1,\"696\":1,\"702\":1,\"780\":1,\"792\":1,\"836\":1,\"890\":1}}],[\"链表排序\",{\"0\":{\"134\":1}}],[\"千万条数据\",{\"1\":{\"958\":1}}],[\"占用了\",{\"1\":{\"1221\":2}}],[\"占\",{\"1\":{\"958\":1}}],[\"占位符\",{\"1\":{\"931\":1}}],[\"拓展\",{\"1\":{\"958\":1}}],[\"拓扑排序\",{\"0\":{\"349\":1}}],[\"叶子节点是一个双向链表\",{\"1\":{\"958\":1}}],[\"叶子节点形成了一个双向链表\",{\"1\":{\"958\":1}}],[\"叶子节点\",{\"1\":{\"958\":2}}],[\"退化的二叉查找树\",{\"1\":{\"958\":1}}],[\"退出的时候\",{\"1\":{\"1431\":1}}],[\"退出wait\",{\"1\":{\"1409\":5,\"1410\":10}}],[\"退出之后再对条件进行判断即可\",{\"1\":{\"1407\":1}}],[\"退出同步块\",{\"1\":{\"1407\":1}}],[\"退出时会调用\",{\"1\":{\"1337\":1}}],[\"退出呢\",{\"1\":{\"1316\":1}}],[\"退出\",{\"1\":{\"1251\":2,\"1340\":1,\"1406\":1}}],[\"退出登录接口\",{\"1\":{\"596\":1}}],[\"退出处理类\",{\"1\":{\"446\":1}}],[\"哪些不是原子操作\",{\"1\":{\"1482\":1}}],[\"哪些是共享变量\",{\"1\":{\"1416\":1}}],[\"哪些方面反转了\",{\"1\":{\"1129\":2}}],[\"哪怕数据库发生异常\",{\"1\":{\"955\":1}}],[\"哪个房子是网吧\",{\"1\":{\"108\":1}}],[\"隔离性\",{\"1\":{\"955\":2}}],[\"撤销\",{\"1\":{\"955\":1}}],[\"隐藏了实现细节\",{\"1\":{\"1494\":1}}],[\"隐藏敏感信息\",{\"1\":{\"574\":2}}],[\"隐式支持重入性\",{\"1\":{\"1231\":1}}],[\"隐式转化\",{\"1\":{\"978\":1}}],[\"隐式内连接语法\",{\"1\":{\"944\":1}}],[\"隐式内连接\",{\"1\":{\"944\":1}}],[\"笛卡尔乘积是指在数学中\",{\"1\":{\"942\":1}}],[\"笛卡尔积\",{\"1\":{\"942\":1}}],[\"学习者都清楚\",{\"1\":{\"1290\":1}}],[\"学习者应该掌握的\",{\"1\":{\"1218\":1}}],[\"学习技巧\",{\"1\":{\"1107\":1}}],[\"学习循环语句只需要抓住一点\",{\"1\":{\"987\":1}}],[\"学习编程语言语法是次要的\",{\"1\":{\"987\":1}}],[\"学习语言最好的方式就是实践\",{\"1\":{\"983\":1}}],[\"学生\",{\"1\":{\"1025\":1}}],[\"学生与课程的关系\",{\"1\":{\"939\":1}}],[\"学生和课程的关系\",{\"1\":{\"939\":1}}],[\"学生和老师的关系\",{\"1\":{\"939\":1}}],[\"学历\",{\"1\":{\"938\":1}}],[\"民族\",{\"1\":{\"938\":1}}],[\"传递性\",{\"1\":{\"1421\":1}}],[\"传递的参数\",{\"1\":{\"935\":1}}],[\"传给其他服务\",{\"1\":{\"1158\":1}}],[\"传给了\",{\"1\":{\"1155\":1}}],[\"传给形参\",{\"1\":{\"1018\":1}}],[\"传了\",{\"1\":{\"1153\":1}}],[\"传统的程序开发也是如此\",{\"1\":{\"1131\":1}}],[\"传参\",{\"1\":{\"1073\":1}}],[\"传入即可\",{\"1\":{\"1393\":1}}],[\"传入指定大小时的情况\",{\"1\":{\"1270\":1}}],[\"传入正则表达式分隔字符串\",{\"1\":{\"1069\":1}}],[\"传入比较函数\",{\"1\":{\"423\":1}}],[\"传入t的地址\",{\"1\":{\"330\":1}}],[\"降低资源消耗\",{\"1\":{\"1357\":1}}],[\"降低性能开销\",{\"1\":{\"1233\":1}}],[\"降低\",{\"1\":{\"957\":1}}],[\"降低数据排序的成本\",{\"1\":{\"957\":1}}],[\"降低数据库的\",{\"1\":{\"957\":1}}],[\"降低开销\",{\"1\":{\"436\":1}}],[\"降序\",{\"1\":{\"934\":1,\"1078\":1}}],[\"聚合函数会忽略空值\",{\"1\":{\"932\":1}}],[\"聚合函数\",{\"0\":{\"932\":1},\"1\":{\"932\":1,\"933\":1}}],[\"聚合粒度\",{\"1\":{\"33\":1}}],[\"意味着偏向锁升级成轻量级锁后不能降级成偏向锁\",{\"1\":{\"1440\":1}}],[\"意味着凑齐了一波\",{\"1\":{\"1393\":1}}],[\"意味着可以有多个条件\",{\"1\":{\"931\":1}}],[\"意思是从\",{\"1\":{\"56\":1}}],[\"意思就是把消息都暂存在\",{\"1\":{\"49\":1}}],[\"固定长度为11\",{\"1\":{\"920\":1}}],[\"手写本地缓存\",{\"0\":{\"1201\":1}}],[\"手动提交事务使用步骤\",{\"1\":{\"954\":1}}],[\"手动提交事务\",{\"1\":{\"954\":1}}],[\"手机号\",{\"1\":{\"920\":1,\"938\":1}}],[\"手搓\",{\"0\":{\"687\":1}}],[\"精确定点数\",{\"1\":{\"920\":1}}],[\"精度\",{\"1\":{\"920\":2}}],[\"精选\",{\"1\":{\"22\":1}}],[\"极大文本数据\",{\"1\":{\"920\":1}}],[\"极大整数值\",{\"1\":{\"920\":1}}],[\"极大地方便了开发过程\",{\"1\":{\"475\":1}}],[\"英文全称是\",{\"1\":{\"911\":1}}],[\"英语\",{\"1\":{\"14\":1}}],[\"滚动数组\",{\"1\":{\"894\":1}}],[\"拆分两个链表\",{\"1\":{\"888\":2}}],[\"拆分\",{\"0\":{\"888\":1}}],[\"拆分为前置和后置两部分\",{\"1\":{\"33\":1}}],[\"照着原数据结构的样子\",{\"1\":{\"887\":1}}],[\"照片保证第\",{\"1\":{\"280\":1}}],[\"照片中有多少岛屿会被完全淹没\",{\"1\":{\"280\":1}}],[\"门课程\",{\"1\":{\"874\":1}}],[\"课程表\",{\"0\":{\"873\":1},\"1\":{\"873\":1}}],[\"周期性执行任务\",{\"1\":{\"1367\":1}}],[\"周期为\",{\"1\":{\"139\":3}}],[\"周围\",{\"1\":{\"868\":1}}],[\"腐烂的橘子\",{\"0\":{\"867\":1},\"1\":{\"867\":1,\"868\":1}}],[\"窗口每次移动\",{\"1\":{\"857\":1}}],[\"故其具有有序性\",{\"1\":{\"1485\":1}}],[\"故\",{\"1\":{\"1484\":1}}],[\"故使用\",{\"1\":{\"899\":1}}],[\"故时间复杂度为\",{\"1\":{\"851\":1}}],[\"故可以不写\",{\"1\":{\"688\":1}}],[\"吗\",{\"0\":{\"1461\":1,\"1473\":1},\"1\":{\"850\":1}}],[\"括号\",{\"1\":{\"844\":1}}],[\"推出\",{\"1\":{\"1259\":1}}],[\"推出来的状态为\",{\"1\":{\"828\":1}}],[\"推荐搭配宝塔面板使用\",{\"1\":{\"671\":1}}],[\"推荐\",{\"0\":{\"535\":1},\"1\":{\"870\":1}}],[\"推荐答案\",{\"1\":{\"512\":1,\"517\":1}}],[\"推荐使用宝塔面板来操作\",{\"1\":{\"663\":1}}],[\"推荐使用\",{\"1\":{\"502\":1}}],[\"间房子开始抢劫\",{\"1\":{\"827\":1}}],[\"强调多个线程互等\",{\"1\":{\"1394\":1}}],[\"强调一个线程等多个线程完成某件事情\",{\"1\":{\"1394\":1}}],[\"强引用\",{\"1\":{\"1318\":1}}],[\"强盗从第\",{\"1\":{\"827\":1}}],[\"强散列哈希加密实现\",{\"1\":{\"446\":1}}],[\"抢占式调度系统给每一个可运行线程一个时间片来执行任务\",{\"1\":{\"1331\":1}}],[\"抢和不抢就是选择\",{\"1\":{\"827\":1}}],[\"抢或者不抢\",{\"1\":{\"827\":1}}],[\"影响增\",{\"1\":{\"937\":1}}],[\"影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统\",{\"1\":{\"826\":1}}],[\"影响到下一个点\",{\"1\":{\"354\":1}}],[\"陆地\",{\"1\":{\"819\":1}}],[\"升序\",{\"1\":{\"813\":1,\"832\":1,\"934\":1,\"1078\":1}}],[\"观察上面的状态转移方程\",{\"1\":{\"797\":1}}],[\"观察数据库\",{\"0\":{\"489\":1},\"1\":{\"489\":1}}],[\"∞\",{\"1\":{\"795\":2,\"796\":1,\"797\":1}}],[\"慢指针就指向倒数第\",{\"1\":{\"777\":1}}],[\"物理外键\",{\"1\":{\"937\":1}}],[\"物理外键和逻辑外键\",{\"1\":{\"937\":1}}],[\"物品\",{\"1\":{\"795\":1}}],[\"物品价值都是\",{\"1\":{\"795\":1}}],[\"物品遍历和背包遍历的顺序可以颠倒\",{\"1\":{\"772\":1}}],[\"物化视图\",{\"0\":{\"441\":1}}],[\"动作使用\",{\"1\":{\"1482\":1}}],[\"动规分析\",{\"1\":{\"772\":1}}],[\"动态的向某个对象提供它所需要的其他对象\",{\"1\":{\"1132\":1}}],[\"动态扩容的数组\",{\"1\":{\"1072\":1}}],[\"动态调用实例的成员函数\",{\"1\":{\"1054\":1}}],[\"动态引入类\",{\"1\":{\"1054\":1}}],[\"动态大小\",{\"1\":{\"972\":1}}],[\"动态路由\",{\"1\":{\"542\":1}}],[\"动态部分由\",{\"1\":{\"535\":1}}],[\"动态内容有限\",{\"1\":{\"534\":1}}],[\"动态维护有序序列\",{\"1\":{\"422\":1}}],[\"动态邻接矩阵\",{\"1\":{\"345\":1}}],[\"动态外露评论\",{\"1\":{\"40\":1}}],[\"动态外露评论等\",{\"1\":{\"39\":1}}],[\"动态\",{\"1\":{\"21\":1,\"493\":1,\"497\":1,\"508\":1}}],[\"动态规划的时间复杂度\",{\"1\":{\"851\":1}}],[\"动态规划\",{\"0\":{\"294\":1,\"783\":1,\"846\":1},\"1\":{\"3\":1,\"65\":1,\"104\":1,\"109\":1,\"110\":1,\"135\":1,\"142\":1,\"178\":1,\"182\":1},\"2\":{\"207\":1,\"315\":1,\"706\":1,\"773\":1,\"785\":1,\"798\":1,\"829\":1,\"841\":1,\"847\":1,\"853\":1,\"895\":1}}],[\"神的写法\",{\"1\":{\"767\":1}}],[\"神州信息笔试\",{\"0\":{\"160\":1}}],[\"仍未获得锁返回\",{\"1\":{\"1508\":1}}],[\"仍可以从剩下的盘中的数据进行恢复\",{\"1\":{\"1095\":1}}],[\"仍可复用以上方法划分子树的左右子树\",{\"1\":{\"766\":1}}],[\"仍为其初始值\",{\"1\":{\"869\":1}}],[\"仍然有效\",{\"1\":{\"1393\":1}}],[\"仍然存在读线程在读数据的时候被阻塞的情况\",{\"1\":{\"1290\":1}}],[\"仍然可以被数仓查询使用\",{\"1\":{\"438\":1}}],[\"仍然可能会短时\",{\"1\":{\"60\":1}}],[\"仍然为前闭后开\",{\"1\":{\"423\":1}}],[\"仍然处于一个动态权衡取舍的过程\",{\"1\":{\"40\":1}}],[\"顺便更新最大直径\",{\"1\":{\"760\":1}}],[\"顺序链表\",{\"1\":{\"1072\":1}}],[\"顺序数组列表\",{\"1\":{\"1072\":1}}],[\"顺序相同\",{\"1\":{\"723\":1}}],[\"顺序不会乱\",{\"1\":{\"49\":1}}],[\"额外增加约束\",{\"1\":{\"1476\":1}}],[\"额外在做的处理\",{\"1\":{\"1307\":1}}],[\"额外空间\",{\"1\":{\"723\":1}}],[\"额外用一个字段判断是否要关联查询题目列表\",{\"1\":{\"523\":1}}],[\"展开的顺序其实就是二叉树的先序遍历\",{\"1\":{\"724\":1}}],[\"展开这棵树吗\",{\"1\":{\"723\":1}}],[\"展开后的单链表应该与二叉树\",{\"1\":{\"723\":1}}],[\"展开后的单链表应该同样使用\",{\"1\":{\"723\":1}}],[\"展示了偏向锁撤销的过程\",{\"1\":{\"1443\":1}}],[\"展示了偏向锁获取的过程\",{\"1\":{\"1443\":1}}],[\"展示题库下的题目\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"展示\",{\"1\":{\"50\":1}}],[\"逆序遍历\",{\"1\":{\"725\":1}}],[\"逆序\",{\"1\":{\"698\":1}}],[\"综上\",{\"1\":{\"851\":1}}],[\"综上可得\",{\"1\":{\"846\":1}}],[\"综上分析\",{\"1\":{\"688\":1,\"1487\":1}}],[\"综合评估而言\",{\"1\":{\"37\":1}}],[\"源文件的名称应该和\",{\"1\":{\"1026\":1}}],[\"源文件声明规则\",{\"0\":{\"1026\":1}}],[\"源于\",{\"1\":{\"688\":1}}],[\"源码剖析\",{\"0\":{\"1542\":1}}],[\"源码注释为\",{\"1\":{\"1314\":1}}],[\"源码很清楚\",{\"1\":{\"1301\":1}}],[\"源码中的\",{\"1\":{\"1496\":1}}],[\"源码中通过\",{\"1\":{\"1306\":1}}],[\"源码中会有注释为\",{\"1\":{\"1286\":1}}],[\"源码中涉及到并发处理都会使用\",{\"1\":{\"1282\":1}}],[\"源码如下\",{\"1\":{\"1243\":1,\"1272\":1,\"1503\":1,\"1504\":3}}],[\"源码的实现逻辑请看注释\",{\"1\":{\"1240\":1}}],[\"源码为\",{\"1\":{\"1233\":2,\"1239\":1,\"1240\":1,\"1270\":1,\"1316\":1,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"源码提供的示例类\",{\"1\":{\"1175\":1}}],[\"源码\",{\"0\":{\"1144\":1,\"1175\":1},\"1\":{\"585\":1,\"658\":1,\"688\":1,\"1144\":1,\"1175\":1}}],[\"源码实现\",{\"0\":{\"471\":1}}],[\"源码分析\",{\"0\":{\"465\":1,\"475\":1}}],[\"盘的\",{\"1\":{\"676\":1}}],[\"盘古想知道\",{\"1\":{\"66\":1}}],[\"盘古在开山之前\",{\"1\":{\"66\":1}}],[\"盘古选择的山必须满足\",{\"1\":{\"66\":1}}],[\"盘古会选择一段连续的山进行开辟\",{\"1\":{\"66\":1}}],[\"盘古的面前一共有\",{\"1\":{\"66\":1}}],[\"映射到表中一个位置以便存储和检索数据的数据结构\",{\"1\":{\"971\":1}}],[\"映射到1\",{\"1\":{\"341\":1}}],[\"映射\",{\"0\":{\"1074\":1},\"1\":{\"887\":1}}],[\"映射网络驱动器\",{\"1\":{\"676\":1}}],[\"签发速度会比较慢\",{\"1\":{\"672\":1}}],[\"勾选\",{\"1\":{\"672\":1}}],[\"免费证书\",{\"1\":{\"672\":1}}],[\"申请免费的\",{\"1\":{\"672\":1}}],[\"填写完表格\",{\"1\":{\"1398\":11}}],[\"填写表格ing\",{\"1\":{\"1398\":11}}],[\"填写想配置的\",{\"1\":{\"672\":1}}],[\"填入\",{\"1\":{\"852\":1}}],[\"填充数组\",{\"1\":{\"1002\":1}}],[\"填充默认值\",{\"1\":{\"526\":1}}],[\"填充\",{\"1\":{\"127\":1}}],[\"填充dp表\",{\"1\":{\"126\":1}}],[\"及时关闭连接\",{\"1\":{\"1309\":1}}],[\"及其回溯打印到标准错误流\",{\"1\":{\"1046\":1}}],[\"及其映射关系\",{\"1\":{\"417\":1}}],[\"及免费\",{\"0\":{\"672\":1}}],[\"外围的\",{\"1\":{\"1407\":1}}],[\"外部强引用被置为\",{\"1\":{\"1305\":1,\"1313\":1}}],[\"外连接分为两种\",{\"1\":{\"945\":1}}],[\"外连接\",{\"0\":{\"945\":1},\"1\":{\"943\":1}}],[\"外键字段名\",{\"1\":{\"937\":2}}],[\"外键名称\",{\"1\":{\"937\":2}}],[\"外键约束\",{\"0\":{\"937\":1},\"1\":{\"919\":1,\"937\":1}}],[\"外链也不用改\",{\"1\":{\"670\":1}}],[\"外露子评论\",{\"1\":{\"39\":1}}],[\"启动线程b\",{\"1\":{\"1421\":1}}],[\"启动测试\",{\"1\":{\"1201\":1,\"1204\":1}}],[\"启动了一个延时\",{\"1\":{\"1184\":1}}],[\"启动了定时调度任务\",{\"1\":{\"1182\":1}}],[\"启动的整体流程图\",{\"1\":{\"1172\":1}}],[\"启动代码\",{\"1\":{\"1145\":1}}],[\"启动时序图给大家画好了\",{\"1\":{\"1145\":1}}],[\"启动过程\",{\"0\":{\"1144\":1},\"1\":{\"1144\":1,\"1172\":1}}],[\"启动服务\",{\"1\":{\"671\":2}}],[\"启动后\",{\"1\":{\"670\":1,\"1160\":1,\"1186\":1}}],[\"启动后如下图所示\",{\"1\":{\"670\":1}}],[\"启动\",{\"1\":{\"670\":1,\"1088\":1,\"1089\":1}}],[\"启发函数减小搜索空间\",{\"1\":{\"221\":1}}],[\"启发函数会影响\",{\"1\":{\"216\":1}}],[\"启发函数\",{\"0\":{\"216\":1}}],[\"配对的位置\",{\"1\":{\"846\":1}}],[\"配合使用\",{\"1\":{\"1250\":1}}],[\"配合完成等待通知机制\",{\"1\":{\"1248\":1}}],[\"配合\",{\"1\":{\"668\":1}}],[\"配置为\",{\"1\":{\"1158\":1}}],[\"配置项是在\",{\"1\":{\"1150\":1}}],[\"配置项\",{\"1\":{\"1149\":1}}],[\"配置等\",{\"1\":{\"1051\":1}}],[\"配置站点\",{\"0\":{\"672\":1}}],[\"配置站点信息\",{\"1\":{\"670\":1}}],[\"配置进程守护\",{\"0\":{\"671\":1},\"1\":{\"671\":1}}],[\"配置存储策略\",{\"1\":{\"670\":2}}],[\"配置解释\",{\"1\":{\"664\":1}}],[\"配置好宝塔后\",{\"1\":{\"663\":1}}],[\"配置返回的用户信息\",{\"1\":{\"589\":1}}],[\"配置方式\",{\"1\":{\"586\":1}}],[\"配置文件配置\",{\"1\":{\"1182\":1}}],[\"配置文件中的配置项是通过\",{\"1\":{\"1151\":1}}],[\"配置文件\",{\"0\":{\"1100\":1,\"1147\":1},\"1\":{\"585\":1,\"1151\":1}}],[\"配置serialversionuid\",{\"1\":{\"576\":1}}],[\"配置中心\",{\"1\":{\"500\":1}}],[\"配置类注释\",{\"1\":{\"487\":1}}],[\"配置web应用程序规则\",{\"1\":{\"446\":1}}],[\"配置url访问授权规则\",{\"1\":{\"446\":1}}],[\"配置\",{\"0\":{\"446\":1,\"673\":1,\"1148\":1,\"1157\":1},\"1\":{\"557\":1,\"1090\":1,\"1148\":1,\"1158\":1}}],[\"供所有人访问\",{\"1\":{\"668\":1}}],[\"供未来的数据挖掘使用\",{\"1\":{\"438\":1}}],[\"别名2\",{\"1\":{\"930\":1,\"944\":2}}],[\"别名1\",{\"1\":{\"930\":1,\"944\":2}}],[\"别人未必会帮你好好保存\",{\"1\":{\"668\":1}}],[\"别再自己瞎写工具类了\",{\"1\":{\"639\":1}}],[\"绕过大陆\",{\"1\":{\"665\":1}}],[\"毕竟\",{\"1\":{\"1434\":1}}],[\"毕竟这个端口的安全组会阻拦\",{\"1\":{\"664\":1}}],[\"毕竟是放在别人家里\",{\"1\":{\"668\":1}}],[\"毕竟是公家的\",{\"1\":{\"668\":1}}],[\"毕竟是\",{\"1\":{\"50\":1}}],[\"扫描\",{\"1\":{\"664\":1}}],[\"扫描并封禁\",{\"1\":{\"664\":1}}],[\"国外服务器a\",{\"1\":{\"664\":1}}],[\"国内用这个框架的不多\",{\"1\":{\"1184\":1}}],[\"国内服务器b\",{\"1\":{\"664\":1,\"665\":1}}],[\"国内的中文文档不够新\",{\"1\":{\"537\":1}}],[\"永远在\",{\"1\":{\"1408\":1}}],[\"永远不能被访问到\",{\"1\":{\"1313\":1}}],[\"永远不会被输出\",{\"1\":{\"407\":2}}],[\"永远无法回收\",{\"1\":{\"1305\":1}}],[\"永远作为队列的队尾节点\",{\"1\":{\"1286\":1}}],[\"永远指向的是\",{\"1\":{\"1284\":1}}],[\"永久生效\",{\"1\":{\"663\":1}}],[\"香港\",{\"1\":{\"662\":1}}],[\"硅云\",{\"1\":{\"662\":1}}],[\"阿里云数字证书管理服务\",{\"1\":{\"672\":1}}],[\"阿里云\",{\"1\":{\"662\":1}}],[\"阿里云开发者\",{\"1\":{\"635\":1}}],[\"端口只允许\",{\"1\":{\"664\":1}}],[\"端口的请求全部转发给\",{\"1\":{\"664\":1}}],[\"端口点击确定\",{\"1\":{\"663\":1}}],[\"端口一般都能连接上\",{\"1\":{\"663\":1}}],[\"端口使用情况\",{\"1\":{\"663\":1}}],[\"端口信息\",{\"1\":{\"663\":1}}],[\"端口为公开\",{\"1\":{\"663\":1}}],[\"端口\",{\"1\":{\"662\":1,\"663\":2,\"664\":2,\"670\":1}}],[\"海外服务器的采购可以使用\",{\"1\":{\"662\":1}}],[\"海外服务器\",{\"1\":{\"662\":1}}],[\"准备一台\",{\"1\":{\"662\":1}}],[\"准确性\",{\"1\":{\"151\":1}}],[\"采取了保守策略\",{\"1\":{\"1457\":1}}],[\"采取了不同的策略\",{\"1\":{\"1423\":1}}],[\"采购云服务器\",{\"1\":{\"662\":1}}],[\"采用模板方法进行设计\",{\"1\":{\"1495\":1}}],[\"采用的策略有下面几种\",{\"1\":{\"1359\":1}}],[\"采用的是悲观锁策略\",{\"1\":{\"1380\":1}}],[\"采用的是\",{\"1\":{\"1346\":1}}],[\"采用的是新旧两个数据容器\",{\"1\":{\"1295\":1}}],[\"采用了堆的底层数据结构\",{\"1\":{\"1371\":1}}],[\"采用了链表的数据结构来实现队列\",{\"1\":{\"1350\":1}}],[\"采用了一种结合\",{\"1\":{\"1205\":1}}],[\"采用这种方式主要是用于时间效率上的平衡\",{\"1\":{\"1315\":1}}],[\"采用开放寻址法\",{\"1\":{\"1306\":1}}],[\"采用懒加载的方式\",{\"1\":{\"1266\":1}}],[\"采用\",{\"1\":{\"1201\":1,\"1276\":1,\"1283\":1,\"1294\":1}}],[\"采用二叉搜索树或者是红黑树来作为索引的结构有什么问题\",{\"1\":{\"958\":1}}],[\"采用枚举选哪个的方式\",{\"1\":{\"851\":1}}],[\"采用最新\",{\"1\":{\"634\":1}}],[\"采用数组模拟队列的写法\",{\"1\":{\"349\":1}}],[\"喜欢动手的朋友\",{\"1\":{\"661\":1}}],[\"科学上网的需求也不是很高\",{\"1\":{\"665\":1}}],[\"科学上网与本地代理\",{\"0\":{\"661\":1}}],[\"科学家预测未来几十年\",{\"1\":{\"280\":1}}],[\"冴羽\",{\"1\":{\"658\":1}}],[\"搭建自己专属的对象存储服务器\",{\"1\":{\"1094\":1}}],[\"搭建过程\",{\"0\":{\"670\":1}}],[\"搭建\",{\"1\":{\"658\":1,\"1090\":1}}],[\"沉浸式\",{\"1\":{\"658\":1}}],[\"书籍\",{\"2\":{\"656\":1}}],[\"书评\",{\"1\":{\"21\":1}}],[\"货拉拉大数据元数据管理体系演进和实践\",{\"1\":{\"645\":1}}],[\"干货｜在抖音集团\",{\"1\":{\"645\":1}}],[\"漫谈数仓\",{\"1\":{\"644\":1}}],[\"奇淫巧技\",{\"1\":{\"643\":1}}],[\"奇数数量\",{\"1\":{\"87\":1}}],[\"奇数的数量为\",{\"1\":{\"87\":1}}],[\"火山引擎\",{\"1\":{\"639\":1}}],[\"😃\",{\"1\":{\"1286\":1}}],[\"🔗\",{\"1\":{\"634\":1}}],[\"🔥\",{\"1\":{\"634\":2}}],[\"魔法变量\",{\"1\":{\"670\":1}}],[\"魔法水晶箭到达坐标\",{\"1\":{\"97\":1}}],[\"魔众软件\",{\"1\":{\"634\":1}}],[\"魔众短链接系统\",{\"1\":{\"634\":1}}],[\"魔众短连接\",{\"1\":{\"634\":1}}],[\"博客搭建系列\",{\"1\":{\"658\":1}}],[\"博客\",{\"1\":{\"658\":1,\"1093\":1}}],[\"博客园\",{\"1\":{\"634\":1}}],[\"博弈论\",{\"0\":{\"393\":1}}],[\"疯狂创客圈\",{\"1\":{\"634\":1}}],[\"呢\",{\"1\":{\"632\":1,\"820\":1,\"1129\":1,\"1264\":1,\"1272\":2,\"1369\":1}}],[\"京东短网址高可用提升最佳实践\",{\"1\":{\"634\":1}}],[\"京东技术\",{\"1\":{\"633\":1,\"636\":1}}],[\"京东云开发者社区\",{\"1\":{\"632\":2}}],[\"京东面试\",{\"1\":{\"632\":1}}],[\"京东笔试\",{\"0\":{\"75\":1}}],[\"腾讯云对象存储\",{\"1\":{\"1094\":1}}],[\"腾讯女后端设计了一套短链系统\",{\"1\":{\"634\":1}}],[\"腾讯技术工程\",{\"1\":{\"630\":1}}],[\"腾讯文档在线表格卡顿指标探索之路\",{\"1\":{\"630\":1}}],[\"腾讯老干妈大瓜背后\",{\"1\":{\"41\":1}}],[\"芋道源码\",{\"1\":{\"629\":1}}],[\"什么事就不用管了\",{\"1\":{\"1223\":1}}],[\"什么时候发送这些信息呢\",{\"1\":{\"1158\":1}}],[\"什么才是架构师的真内核\",{\"1\":{\"625\":1}}],[\"什么是线程安全\",{\"1\":{\"1415\":1}}],[\"什么是线程优先级呢\",{\"1\":{\"1339\":1}}],[\"什么是对象存储\",{\"0\":{\"1094\":1}}],[\"什么是守护进程\",{\"1\":{\"671\":1}}],[\"什么是\",{\"0\":{\"669\":1,\"674\":1,\"1382\":1,\"1436\":1}}],[\"什么是设计数据库表\",{\"0\":{\"565\":1}}],[\"什么是数据库\",{\"1\":{\"564\":1}}],[\"什么是客户端和服务端渲染\",{\"0\":{\"531\":1}}],[\"什么是热评\",{\"0\":{\"39\":1}}],[\"站在\",{\"1\":{\"1423\":1}}],[\"站在读线程的角度来看\",{\"1\":{\"1291\":1}}],[\"站点信息\",{\"1\":{\"672\":1}}],[\"站基于\",{\"1\":{\"621\":1}}],[\"站的评论图\",{\"1\":{\"56\":1}}],[\"站的评论系统为样本\",{\"1\":{\"44\":1}}],[\"揭秘jdq限流架构\",{\"1\":{\"633\":1}}],[\"揭秘\",{\"1\":{\"619\":1}}],[\"揭秘火山引擎全站加速\",{\"1\":{\"617\":1}}],[\"规则定义\",{\"1\":{\"1455\":1}}],[\"规则中有一条是\",{\"1\":{\"1455\":1}}],[\"规则以及内存抽象模型\",{\"1\":{\"1433\":1}}],[\"规则简单易懂\",{\"1\":{\"1424\":1}}],[\"规则对应于一个或多个编译器和处理器重排序规则\",{\"1\":{\"1424\":1}}],[\"规则不但简单易懂\",{\"1\":{\"1423\":1}}],[\"规则能满足程序员的需求\",{\"1\":{\"1423\":1}}],[\"规则1\",{\"1\":{\"1421\":1}}],[\"规则\",{\"0\":{\"1419\":1},\"1\":{\"1294\":1,\"1421\":3,\"1423\":1,\"1429\":1,\"1432\":2}}],[\"规则机执行命中后\",{\"1\":{\"40\":1}}],[\"规则机\",{\"1\":{\"40\":1}}],[\"规模容器化最佳实践\",{\"1\":{\"617\":1}}],[\"期\",{\"0\":{\"616\":1,\"638\":1},\"1\":{\"652\":2}}],[\"期望每分钟收到客户端实例续约的总数\",{\"1\":{\"1190\":1}}],[\"期望每分钟最少续约数\",{\"1\":{\"1190\":1}}],[\"期望误判率为\",{\"1\":{\"613\":1}}],[\"期望的误判率\",{\"1\":{\"613\":1}}],[\"期望能为用户带来更好的体验\",{\"1\":{\"41\":1}}],[\"亿级查重\",{\"1\":{\"632\":1}}],[\"亿级黑名单\",{\"1\":{\"632\":1}}],[\"亿级高性能通知系统实践\",{\"1\":{\"625\":1}}],[\"亿\",{\"1\":{\"613\":1}}],[\"亿个用户名\",{\"1\":{\"613\":1}}],[\"万用户\",{\"1\":{\"958\":1}}],[\"万条数据\",{\"1\":{\"958\":1}}],[\"万一服务器突然宕机或停电等\",{\"1\":{\"671\":1}}],[\"万一想存点嘿嘿的东西\",{\"1\":{\"668\":1}}],[\"万字长文\",{\"1\":{\"634\":1}}],[\"万\",{\"1\":{\"613\":1}}],[\"万个用户名\",{\"1\":{\"613\":1}}],[\"万能头文件\",{\"1\":{\"235\":1}}],[\"误判是可以容忍的\",{\"1\":{\"613\":1}}],[\"误判\",{\"1\":{\"613\":2}}],[\"绑定域名\",{\"0\":{\"609\":1}}],[\"宝塔\",{\"0\":{\"607\":1}}],[\"宝石项链\",{\"0\":{\"103\":1}}],[\"末尾\",{\"1\":{\"852\":1}}],[\"末\",{\"0\":{\"595\":1},\"1\":{\"595\":1}}],[\"昵称\",{\"1\":{\"592\":1}}],[\"序号\",{\"1\":{\"592\":1}}],[\"序列中每对相邻节点之间都存在一条边\",{\"1\":{\"717\":1}}],[\"序列中的数字均不超过\",{\"1\":{\"304\":1}}],[\"序列化篇\",{\"1\":{\"635\":1}}],[\"序列化\",{\"1\":{\"576\":2}}],[\"序列化的方式存入\",{\"1\":{\"58\":2}}],[\"旁边加上\",{\"1\":{\"588\":1}}],[\"忘记密码\",{\"1\":{\"588\":1}}],[\"追踪\",{\"1\":{\"585\":1}}],[\"追求用户价值平衡\",{\"1\":{\"39\":1,\"40\":1}}],[\"怎样判断当前同步状态是否成功获取或者是否成功释放\",{\"1\":{\"1496\":1}}],[\"怎样解决\",{\"1\":{\"1306\":2}}],[\"怎样确定新值插入到哈希表中的位置\",{\"1\":{\"1306\":1}}],[\"怎样计算得出索引\",{\"1\":{\"1272\":1}}],[\"怎样从\",{\"1\":{\"1251\":1}}],[\"怎样才能从\",{\"1\":{\"1251\":1}}],[\"怎样才算好看呢\",{\"1\":{\"147\":1}}],[\"怎么办\",{\"1\":{\"1504\":1}}],[\"怎么构造出来的呢\",{\"1\":{\"1154\":1}}],[\"怎么构造\",{\"1\":{\"1132\":1}}],[\"怎么实现代理\",{\"1\":{\"586\":1}}],[\"怎么发请求\",{\"1\":{\"585\":1}}],[\"终止线程\",{\"0\":{\"1333\":1}}],[\"终止\",{\"1\":{\"1329\":1}}],[\"终止的条件改一下\",{\"1\":{\"682\":1}}],[\"终\",{\"0\":{\"583\":1},\"1\":{\"583\":1}}],[\"终点\",{\"1\":{\"221\":1,\"223\":1}}],[\"终点的最短距离\",{\"1\":{\"221\":1}}],[\"格式化字符串\",{\"1\":{\"1005\":1,\"1069\":1}}],[\"格式化输出\",{\"1\":{\"982\":1}}],[\"格式\",{\"1\":{\"920\":1,\"1110\":1,\"1123\":1,\"1124\":1}}],[\"格式正确且连续\",{\"1\":{\"844\":1}}],[\"格式为\",{\"1\":{\"663\":1}}],[\"格式参数的话\",{\"1\":{\"576\":1}}],[\"格式的数据响应回给浏览器\",{\"1\":{\"935\":1}}],[\"格式的数据\",{\"1\":{\"573\":1}}],[\"风格\",{\"1\":{\"576\":1}}],[\"风格的\",{\"1\":{\"576\":1}}],[\"风味差异度是\",{\"1\":{\"152\":3}}],[\"风味差异度\",{\"1\":{\"152\":3}}],[\"控制不同线程间操作发生的相对顺序\",{\"1\":{\"1417\":1}}],[\"控制资源并发访问\",{\"0\":{\"1398\":1}}],[\"控制线程对临界区资源的同步顺序从而解决线程安全的问题\",{\"1\":{\"1299\":1}}],[\"控制线程\",{\"1\":{\"1284\":1}}],[\"控制当走到第\",{\"1\":{\"1250\":1}}],[\"控制台页面\",{\"1\":{\"1190\":1}}],[\"控制台的参数说明\",{\"1\":{\"1189\":1}}],[\"控制台的监听地址和端口\",{\"1\":{\"1087\":1}}],[\"控制台详解\",{\"0\":{\"1189\":1},\"1\":{\"1189\":1}}],[\"控制\",{\"1\":{\"1131\":1}}],[\"控制对象\",{\"1\":{\"1129\":1}}],[\"控制什么\",{\"1\":{\"1129\":2}}],[\"控制反转\",{\"1\":{\"1129\":2,\"1131\":1}}],[\"控制数据库的访问权限\",{\"1\":{\"909\":1}}],[\"控制层\",{\"1\":{\"576\":1}}],[\"控制精度\",{\"1\":{\"385\":1}}],[\"匿名会话\",{\"1\":{\"575\":1}}],[\"匿名可以访问\",{\"1\":{\"446\":1}}],[\"连接信息\",{\"1\":{\"1100\":1}}],[\"连接条件\",{\"1\":{\"944\":1,\"945\":2}}],[\"连接查询\",{\"1\":{\"943\":1}}],[\"连接成功后如下所示\",{\"1\":{\"676\":1}}],[\"连接\",{\"0\":{\"906\":1},\"1\":{\"675\":1}}],[\"连接服务器端后\",{\"1\":{\"575\":1}}],[\"连通图\",{\"1\":{\"362\":1}}],[\"连通这两个顶点\",{\"1\":{\"361\":1}}],[\"析等环境\",{\"1\":{\"574\":1}}],[\"式\",{\"1\":{\"574\":2}}],[\"脱敏后用户信息\",{\"1\":{\"575\":1}}],[\"脱敏\",{\"1\":{\"573\":1,\"574\":1}}],[\"￥\",{\"1\":{\"568\":1,\"575\":1}}],[\"盐值\",{\"1\":{\"568\":1}}],[\"盐值是一种用于增加密码破解难度的技术\",{\"1\":{\"568\":1}}],[\"盐值加密\",{\"1\":{\"568\":1}}],[\"软件基金会开发的一组\",{\"1\":{\"568\":1}}],[\"断言\",{\"1\":{\"567\":1}}],[\"女生慢慢地从教室走出来\",{\"1\":{\"1399\":1}}],[\"女生慢慢的地从教室走出来\",{\"1\":{\"1399\":1}}],[\"女生对男生说的话\",{\"1\":{\"1399\":1}}],[\"女孩儿说\",{\"1\":{\"1399\":2}}],[\"女\",{\"1\":{\"566\":1,\"592\":1}}],[\"男女生说的话和定义时的不一样\",{\"1\":{\"1399\":1}}],[\"男孩儿说\",{\"1\":{\"1399\":2}}],[\"男孩会先到女孩教室门口\",{\"1\":{\"1399\":1}}],[\"男生对女生说的话\",{\"1\":{\"1399\":1}}],[\"男生经常会给走廊里为自己喜欢的女孩子送情书\",{\"1\":{\"1399\":1}}],[\"男\",{\"1\":{\"566\":1,\"592\":1}}],[\"备忘录\",{\"1\":{\"827\":1}}],[\"备注\",{\"1\":{\"566\":2}}],[\"备份\",{\"1\":{\"246\":1,\"291\":1}}],[\"停顿4秒\",{\"1\":{\"1204\":1,\"1207\":1,\"1211\":1}}],[\"停顿3秒\",{\"1\":{\"1201\":1}}],[\"停用\",{\"1\":{\"566\":2}}],[\"停止服务\",{\"1\":{\"671\":1}}],[\"停止\",{\"1\":{\"479\":1}}],[\"账户不包含特殊字符\",{\"1\":{\"568\":1,\"574\":1}}],[\"账户不能重复\",{\"1\":{\"568\":1}}],[\"账户长度不小于\",{\"1\":{\"574\":1}}],[\"账户长度\",{\"1\":{\"568\":1}}],[\"账户状态\",{\"1\":{\"566\":1}}],[\"账号时\",{\"1\":{\"675\":1}}],[\"账号并不互通\",{\"1\":{\"675\":1}}],[\"账号不能为空\",{\"1\":{\"587\":1}}],[\"账号长度不能小于4\",{\"1\":{\"587\":1}}],[\"账号状态\",{\"1\":{\"566\":1}}],[\"账号\",{\"1\":{\"510\":1,\"592\":1}}],[\"账号密码注册\",{\"1\":{\"587\":1}}],[\"账号密码\",{\"1\":{\"496\":1,\"507\":1,\"510\":1}}],[\"邮箱\",{\"1\":{\"566\":2,\"592\":1}}],[\"邮件服务器\",{\"1\":{\"671\":1}}],[\"邮件\",{\"1\":{\"475\":1}}],[\"跟着说明文档配置\",{\"1\":{\"662\":1}}],[\"跟着官网来就可以了\",{\"1\":{\"560\":1}}],[\"跟两个儿子比较大小\",{\"1\":{\"417\":1}}],[\"搜现成的代码\",{\"1\":{\"560\":1}}],[\"搜索脏entry并进行清理\",{\"1\":{\"1317\":1}}],[\"搜索范围\",{\"1\":{\"1315\":1}}],[\"搜索范围为黑线\",{\"1\":{\"1315\":1}}],[\"搜索性能会打折扣\",{\"1\":{\"958\":1}}],[\"搜索结束\",{\"1\":{\"821\":1,\"1315\":1}}],[\"搜索引擎最喜欢的就是静态\",{\"1\":{\"534\":1}}],[\"搜索引擎可以直接获取到完整的\",{\"1\":{\"533\":1}}],[\"搜索引擎难以理解和索引页面的全部内容\",{\"1\":{\"532\":1}}],[\"搜索引擎\",{\"1\":{\"500\":1}}],[\"搜索并将其赋值为海水\",{\"1\":{\"229\":1}}],[\"搜索\",{\"0\":{\"211\":1,\"277\":1},\"1\":{\"4\":1,\"22\":1,\"45\":1,\"212\":1,\"576\":1,\"875\":1,\"1088\":1}}],[\"搜索与图论\",{\"0\":{\"344\":1},\"1\":{\"3\":1}}],[\"帮你在火狐或谷歌自动测试\",{\"1\":{\"559\":1}}],[\"帮助创建\",{\"1\":{\"1068\":1}}],[\"帮助我们更科学地上网📶\",{\"1\":{\"661\":1}}],[\"帮助你管理\",{\"1\":{\"557\":1}}],[\"帮助业务更好地发展\",{\"1\":{\"436\":1}}],[\"帮助学习\",{\"1\":{\"18\":1}}],[\"帮助用户灵活\",{\"1\":{\"14\":1}}],[\"脚本当前运行的进程id\",{\"1\":{\"1120\":1}}],[\"脚本时\",{\"1\":{\"1119\":1}}],[\"脚本输出\",{\"1\":{\"1107\":4}}],[\"脚本示例\",{\"1\":{\"1107\":1}}],[\"脚本有很多种\",{\"1\":{\"1107\":1}}],[\"脚本可以直接在命令行中执行\",{\"1\":{\"1107\":1}}],[\"脚本\",{\"1\":{\"559\":1}}],[\"脚手架已经帮我们配置了\",{\"1\":{\"539\":1}}],[\"脚手架会自动生成代码并安装依赖\",{\"1\":{\"538\":1}}],[\"脚手架可以帮我们自动整合\",{\"1\":{\"538\":1}}],[\"脚手架版本是\",{\"1\":{\"538\":1}}],[\"脚手架工具\",{\"1\":{\"538\":1}}],[\"挂了梯子以及修改了\",{\"1\":{\"559\":1}}],[\"插件\",{\"1\":{\"567\":1,\"613\":1}}],[\"插件的构建\",{\"1\":{\"559\":1}}],[\"插入和获取数据附加阻塞操作的特性\",{\"1\":{\"1411\":1}}],[\"插入和删除数据\",{\"1\":{\"1353\":1}}],[\"插入和删除快\",{\"1\":{\"1072\":1}}],[\"插入和删除操作的场景\",{\"1\":{\"973\":1}}],[\"插入成功返回\",{\"1\":{\"1325\":1}}],[\"插入元素时会抛出\",{\"1\":{\"1325\":1}}],[\"插入元素\",{\"1\":{\"1325\":1}}],[\"插入元素总是在队列最末尾的地方进行插入\",{\"1\":{\"1283\":1}}],[\"插入后再次清除一些key为null的\",{\"1\":{\"1306\":1}}],[\"插入值为\",{\"1\":{\"1284\":1}}],[\"插入当前待插入的节点\",{\"1\":{\"1283\":2}}],[\"插入满足\",{\"1\":{\"1283\":1}}],[\"插入完节点之后再次检查链表长度\",{\"1\":{\"1272\":1}}],[\"插入完键值对后再根据实际大小看是否需要转换成红黑树\",{\"1\":{\"1272\":1}}],[\"插入新值的话就是向这个链表插入新值\",{\"1\":{\"1272\":1}}],[\"插入到等待队列中即可\",{\"1\":{\"1251\":1}}],[\"插入时间和读取时间\",{\"1\":{\"1202\":1}}],[\"插入操作\",{\"1\":{\"971\":1}}],[\"插入的数据大小\",{\"1\":{\"925\":1}}],[\"插入的数是一个pair\",{\"1\":{\"422\":1}}],[\"插入字符串\",{\"1\":{\"802\":1}}],[\"插入节点数超过了该临界值就需要扩容\",{\"1\":{\"1266\":1}}],[\"插入节点\",{\"1\":{\"789\":1}}],[\"插入删除快\",{\"1\":{\"687\":1}}],[\"插入数据元素\",{\"1\":{\"1347\":1}}],[\"插入数据的线程会退出\",{\"1\":{\"1325\":1}}],[\"插入数据的时候才真正的完成初始化创建\",{\"1\":{\"1270\":1}}],[\"插入数据时\",{\"1\":{\"925\":1}}],[\"插入数据\",{\"1\":{\"568\":1,\"1325\":1,\"1347\":1,\"1351\":1}}],[\"插入一个\",{\"1\":{\"1475\":1}}],[\"插入一个元素\",{\"1\":{\"422\":1}}],[\"插入一个数\",{\"1\":{\"417\":1,\"422\":1}}],[\"插入一个字符串\",{\"1\":{\"412\":1}}],[\"插入\",{\"1\":{\"306\":1,\"711\":1,\"1315\":1,\"1504\":1}}],[\"持有偏向锁的线程才会释放锁\",{\"1\":{\"1443\":1}}],[\"持有多个\",{\"1\":{\"1250\":1}}],[\"持久性\",{\"1\":{\"955\":2}}],[\"持久层框架\",{\"1\":{\"557\":1}}],[\"持续探索排序策略\",{\"1\":{\"41\":1}}],[\"企业可以快速搭建自己的内部对象存储服务\",{\"1\":{\"1094\":1}}],[\"企业云盘服务端实现简介\",{\"1\":{\"624\":1}}],[\"企业做项目流程\",{\"0\":{\"555\":1}}],[\"企业在持续发展过程中\",{\"1\":{\"437\":1}}],[\"样式文件\",{\"1\":{\"544\":2,\"548\":1}}],[\"`register\",{\"1\":{\"587\":1}}],[\"`~\",{\"1\":{\"568\":1,\"575\":1}}],[\"`\",{\"1\":{\"543\":1,\"587\":1}}],[\"``dist\",{\"1\":{\"354\":1}}],[\"引用对象\",{\"1\":{\"1478\":1}}],[\"引用不能从构造函数中\",{\"0\":{\"1478\":1}}],[\"引用数据类型\",{\"0\":{\"1467\":1},\"1\":{\"1476\":1}}],[\"引用的对象的成员域的写入\",{\"1\":{\"1476\":1}}],[\"引用的\",{\"1\":{\"1392\":1}}],[\"引用类型以及更新对象中的字段类型\",{\"1\":{\"1380\":1}}],[\"引用置为\",{\"1\":{\"1316\":1}}],[\"引用和指向\",{\"1\":{\"1284\":1}}],[\"引用\",{\"1\":{\"1251\":1,\"1284\":1}}],[\"引用传递\",{\"0\":{\"1018\":1}}],[\"引用指向\",{\"1\":{\"887\":1}}],[\"引入了红黑树\",{\"1\":{\"1272\":1}}],[\"引入caffeine\",{\"0\":{\"1206\":1}}],[\"引入缓存\",{\"1\":{\"1200\":1}}],[\"引入依赖\",{\"0\":{\"1099\":1},\"1\":{\"568\":1}}],[\"引入需要的技术\",{\"1\":{\"555\":1}}],[\"引入\",{\"0\":{\"1209\":1},\"1\":{\"540\":1}}],[\"引入组件库后\",{\"1\":{\"540\":1}}],[\"引入组件库\",{\"0\":{\"540\":1}}],[\"引发一场评论区的狂欢\",{\"1\":{\"33\":1}}],[\"安装启动\",{\"0\":{\"1087\":1,\"1088\":1,\"1089\":1}}],[\"安装与部署\",{\"0\":{\"1086\":1}}],[\"安装目录\",{\"1\":{\"672\":1}}],[\"安装路径下的相对路径\",{\"1\":{\"670\":1}}],[\"安装依赖完成后\",{\"1\":{\"559\":1}}],[\"安装\",{\"1\":{\"539\":1,\"559\":1}}],[\"安全\",{\"1\":{\"663\":1}}],[\"安全性和高可用性\",{\"1\":{\"586\":1}}],[\"安全性\",{\"1\":{\"500\":1}}],[\"安全性设计\",{\"0\":{\"35\":1}}],[\"安全框架\",{\"1\":{\"445\":1}}],[\"安全中间件\",{\"1\":{\"14\":1}}],[\"官网链接\",{\"1\":{\"1093\":1}}],[\"官网下载\",{\"1\":{\"1086\":1}}],[\"官网\",{\"1\":{\"539\":1}}],[\"官方称为\",{\"1\":{\"1446\":1}}],[\"官方团队表示\",{\"1\":{\"1100\":1}}],[\"官方仓库\",{\"1\":{\"1086\":1}}],[\"官方的模板生成器\",{\"1\":{\"560\":1}}],[\"官方文档中提供了两种配置进程守护的方法\",{\"1\":{\"671\":1}}],[\"官方文档中搜索\",{\"1\":{\"541\":1}}],[\"官方文档才是最新版\",{\"1\":{\"537\":1}}],[\"官方文档\",{\"1\":{\"537\":1,\"540\":1,\"575\":1,\"670\":1}}],[\"官方给出了智能湖仓的参考架构\",{\"1\":{\"438\":1}}],[\"命令注册系统服务\",{\"1\":{\"1090\":1}}],[\"命令执行效果如下\",{\"1\":{\"915\":1}}],[\"命令解释\",{\"1\":{\"906\":1,\"1087\":2}}],[\"命令安装的\",{\"1\":{\"672\":1}}],[\"命令启动服务可以看出\",{\"1\":{\"671\":1}}],[\"命令session\",{\"1\":{\"575\":1}}],[\"命令\",{\"1\":{\"538\":1,\"671\":1,\"1087\":1}}],[\"命令来执行存在性判定\",{\"1\":{\"31\":1}}],[\"校验和\",{\"1\":{\"1095\":1}}],[\"校验用户是否合法\",{\"1\":{\"589\":1}}],[\"校验用户账户和密码是否合法\",{\"1\":{\"574\":1}}],[\"校验用户的用户名\",{\"1\":{\"568\":1,\"575\":1}}],[\"校验用户的账户\",{\"1\":{\"568\":1}}],[\"校验等常用功能实现的工具类\",{\"1\":{\"568\":1}}],[\"校验等库\",{\"1\":{\"538\":1}}],[\"校验密码是否输入正确\",{\"1\":{\"574\":1}}],[\"校验密码\",{\"1\":{\"568\":3,\"575\":1,\"576\":1,\"587\":1}}],[\"校验规则可能也会存在冲突\",{\"1\":{\"539\":1}}],[\"校验数据\",{\"1\":{\"526\":1}}],[\"切换到\",{\"1\":{\"1431\":1}}],[\"切换到对应的数据库下\",{\"1\":{\"914\":1}}],[\"切换数据库\",{\"1\":{\"914\":1}}],[\"切换和管理\",{\"1\":{\"537\":1}}],[\"切面类\",{\"1\":{\"471\":1}}],[\"页脚等\",{\"1\":{\"535\":1}}],[\"页面和\",{\"1\":{\"548\":1}}],[\"页面开发规范\",{\"0\":{\"545\":1}}],[\"页面文件和\",{\"1\":{\"544\":2}}],[\"页面加载时\",{\"1\":{\"535\":1}}],[\"页面加载速度相对较慢\",{\"1\":{\"531\":1}}],[\"页面发送给客户端\",{\"1\":{\"533\":1}}],[\"页面作为响应返回给客户端浏览器\",{\"1\":{\"533\":1}}],[\"页面\",{\"1\":{\"533\":3}}],[\"页面切换时可以更快地加载和渲染\",{\"1\":{\"532\":1}}],[\"页面展示\",{\"1\":{\"532\":1}}],[\"页面的静态部分预先渲染\",{\"1\":{\"535\":1}}],[\"页面的首次加载速度相对较慢\",{\"1\":{\"532\":1}}],[\"页面的大部分内容在服务器端已经渲染完成\",{\"1\":{\"531\":1}}],[\"页面的渲染过程主要由客户端的浏览器完成\",{\"1\":{\"531\":1}}],[\"页面结构和一些必要的\",{\"1\":{\"531\":1}}],[\"页面权限\",{\"0\":{\"457\":1}}],[\"部分\",{\"1\":{\"1306\":1}}],[\"部分线程\",{\"0\":{\"1285\":1},\"1\":{\"1283\":2}}],[\"部分预渲染\",{\"1\":{\"535\":1}}],[\"部署\",{\"0\":{\"607\":1},\"1\":{\"555\":1,\"557\":1,\"641\":1}}],[\"部门表的别名\",{\"1\":{\"471\":1}}],[\"部门表建立关系\",{\"1\":{\"471\":1}}],[\"部门及用户权限注解\",{\"1\":{\"471\":1}}],[\"部门及以下数据权限\",{\"1\":{\"470\":1}}],[\"部门数据权限注解\",{\"1\":{\"471\":1}}],[\"部门数据权限\",{\"1\":{\"470\":1}}],[\"部门级权限\",{\"1\":{\"470\":1}}],[\"部门\",{\"1\":{\"451\":1}}],[\"工作笔记\",{\"2\":{\"1213\":1,\"1216\":1}}],[\"工作流程\",{\"1\":{\"534\":1,\"535\":1}}],[\"工厂方法模式的定义\",{\"0\":{\"967\":1}}],[\"工厂方法模式\",{\"0\":{\"966\":1}}],[\"工具\",{\"0\":{\"1257\":1}}],[\"工具类\",{\"0\":{\"1079\":1}}],[\"工具类库\",{\"1\":{\"568\":1}}],[\"工具搭建\",{\"2\":{\"659\":1,\"666\":1,\"677\":1}}],[\"工人们的种树区间至少多长\",{\"1\":{\"173\":1}}],[\"工人所站的位置为\",{\"1\":{\"173\":1}}],[\"效率岂不是会更高\",{\"1\":{\"1290\":1}}],[\"效率较高\",{\"1\":{\"981\":1,\"982\":1}}],[\"效率较低\",{\"1\":{\"981\":1,\"982\":1}}],[\"效率很高\",{\"1\":{\"58\":1}}],[\"效果更好\",{\"1\":{\"671\":1}}],[\"效果如下\",{\"1\":{\"588\":1}}],[\"效果\",{\"1\":{\"534\":1}}],[\"友好和快速初始加载\",{\"1\":{\"535\":1}}],[\"友好特性的同时\",{\"1\":{\"534\":1}}],[\"友好\",{\"1\":{\"534\":1}}],[\"静态域和数组元素都是放在堆内存中\",{\"1\":{\"1416\":1}}],[\"静态函数中只能调用静态函数\",{\"1\":{\"1027\":1}}],[\"静态\",{\"1\":{\"1027\":1}}],[\"静态部分直接显示\",{\"1\":{\"535\":1}}],[\"静态化\",{\"1\":{\"534\":1}}],[\"静态页面可以增量更新\",{\"1\":{\"534\":1}}],[\"静态文件的部署和维护成本较低\",{\"1\":{\"534\":1}}],[\"静态网站生成适合内容数量有限的\",{\"1\":{\"534\":1}}],[\"静态网站生成是在构建时\",{\"1\":{\"534\":1}}],[\"静态网站生成\",{\"0\":{\"534\":1},\"1\":{\"534\":1}}],[\"静态资源\",{\"0\":{\"543\":1},\"1\":{\"446\":1}}],[\"响应后\",{\"1\":{\"533\":1}}],[\"首屏加载速度较慢\",{\"1\":{\"532\":1}}],[\"首先获取头节点的后继节点\",{\"1\":{\"1506\":1}}],[\"首先得了解下\",{\"1\":{\"1500\":1}}],[\"首先要获得\",{\"1\":{\"1431\":1}}],[\"首先要明白什么是\",{\"1\":{\"1381\":1}}],[\"首先要拿到用户的信息\",{\"1\":{\"589\":1}}],[\"首先将对象\",{\"1\":{\"1387\":1}}],[\"首先将线程池的状态设置为\",{\"1\":{\"1360\":1}}],[\"首先将用户名都初始化在布隆过滤器中\",{\"1\":{\"613\":1}}],[\"首先先进行前向搜索脏\",{\"1\":{\"1317\":1}}],[\"首先先看这一部分的代码\",{\"1\":{\"1317\":1}}],[\"首先先看当前的\",{\"1\":{\"1273\":1}}],[\"首先会尝试多次计算\",{\"1\":{\"1276\":1}}],[\"首先会拼接默认的配置文件\",{\"1\":{\"1149\":1}}],[\"首先判断这个节点的类型\",{\"1\":{\"1272\":1}}],[\"首先利用\",{\"1\":{\"1272\":1}}],[\"首先对于每一个放入的值\",{\"1\":{\"1272\":1}}],[\"首先在\",{\"1\":{\"1272\":1}}],[\"首先在设计一个评论系统之前\",{\"1\":{\"44\":1}}],[\"首先创建一个缓存实体类\",{\"1\":{\"1201\":1}}],[\"首先就得进入\",{\"1\":{\"1190\":1}}],[\"首先从\",{\"1\":{\"1175\":1}}],[\"首先想说说\",{\"1\":{\"1131\":1}}],[\"首先找到元素所在的链表\",{\"1\":{\"1306\":1}}],[\"首先找到元素的位置\",{\"1\":{\"971\":1}}],[\"首先找到最底下的叶子节点\",{\"1\":{\"796\":1}}],[\"首先计算元素键的哈希值\",{\"1\":{\"971\":1}}],[\"首先遍历左子树\",{\"1\":{\"729\":1}}],[\"首先遍历起点周围邻近的点\",{\"1\":{\"212\":1}}],[\"首先设置安全组\",{\"1\":{\"663\":1}}],[\"首先修改当前\",{\"1\":{\"488\":1}}],[\"首先预处理出所有阶乘取模的余数fact\",{\"1\":{\"388\":1}}],[\"首先选择\",{\"1\":{\"121\":1}}],[\"首先\",{\"1\":{\"33\":1,\"66\":1,\"288\":1,\"289\":1,\"544\":1,\"772\":1,\"1149\":1,\"1232\":1,\"1301\":1,\"1407\":1}}],[\"首先是引入了自适应的冷却算法\",{\"1\":{\"40\":1}}],[\"首先是评论表\",{\"1\":{\"30\":1}}],[\"首先是c端的发评接口会返回展示新评论所需的数据内容\",{\"1\":{\"28\":1}}],[\"渲染并展示页面给用户\",{\"1\":{\"532\":1}}],[\"客户端配置\",{\"1\":{\"665\":1}}],[\"客户端配置如下\",{\"1\":{\"665\":1}}],[\"客户端通常不知道代理的存在\",{\"1\":{\"586\":1}}],[\"客户端通过\",{\"1\":{\"532\":1}}],[\"客户端意识到代理的存在\",{\"1\":{\"586\":1}}],[\"客户端的意识\",{\"1\":{\"586\":1}}],[\"客户端的\",{\"1\":{\"535\":1}}],[\"客户端的浏览器通过执行\",{\"1\":{\"531\":1}}],[\"客户端解析和渲染\",{\"1\":{\"533\":1}}],[\"客户端使用获取到的数据\",{\"1\":{\"532\":1}}],[\"客户端执行\",{\"1\":{\"532\":1}}],[\"客户端浏览器接收到\",{\"1\":{\"533\":2}}],[\"客户端浏览器接收到响应后\",{\"1\":{\"532\":1}}],[\"客户端浏览器根据最终的\",{\"1\":{\"532\":1}}],[\"客户端浏览器解析并执行下载的\",{\"1\":{\"532\":1}}],[\"客户端浏览器发送页面请求给服务器\",{\"1\":{\"532\":1,\"533\":1}}],[\"客户端下载资源\",{\"1\":{\"532\":1}}],[\"客户端发送请求\",{\"1\":{\"532\":1,\"533\":1}}],[\"客户端接收到\",{\"1\":{\"531\":1}}],[\"客户端渲染和服务端渲染的主要区别在于渲染过程发生的地点\",{\"1\":{\"531\":1}}],[\"客户端渲染\",{\"0\":{\"532\":1},\"1\":{\"531\":1}}],[\"客户端据此展示新评论\",{\"1\":{\"28\":1}}],[\"涉及多表操作\",{\"1\":{\"526\":1}}],[\"涉及到链表的操作\",{\"1\":{\"200\":1}}],[\"懒加载\",{\"1\":{\"526\":1}}],[\"移除队列\",{\"1\":{\"1506\":1}}],[\"移除队头元素\",{\"1\":{\"1352\":1}}],[\"移除\",{\"1\":{\"1283\":1}}],[\"移除缓存\",{\"1\":{\"1201\":1}}],[\"移除国际化\",{\"1\":{\"559\":1}}],[\"移除题库题目关联请求\",{\"1\":{\"526\":1}}],[\"移除题库题目关联\",{\"1\":{\"526\":3}}],[\"移除不必要的模块\",{\"1\":{\"514\":1}}],[\"巧妙地复用了原有的题目过滤条件\",{\"1\":{\"525\":1}}],[\"联表查询\",{\"1\":{\"525\":1}}],[\"联合主键\",{\"1\":{\"30\":1}}],[\"封号\",{\"1\":{\"592\":1}}],[\"封装全局异常处理器\",{\"0\":{\"599\":1}}],[\"封装了\",{\"1\":{\"585\":1}}],[\"封装类\",{\"1\":{\"523\":1}}],[\"封装类的接口\",{\"1\":{\"523\":1}}],[\"封闭岛屿\",{\"1\":{\"229\":1}}],[\"封闭岛屿数量\",{\"0\":{\"229\":1}}],[\"封闭岛屿的树木\",{\"1\":{\"227\":1}}],[\"⭐\",{\"1\":{\"521\":3}}],[\"略微调整数据校验\",{\"1\":{\"519\":1}}],[\"雪花算法生成\",{\"1\":{\"515\":1}}],[\"硬删除\",{\"1\":{\"513\":1}}],[\"硬件的发展极其迅速\",{\"1\":{\"1218\":1}}],[\"硬件\",{\"1\":{\"21\":1}}],[\"详见\",{\"1\":{\"662\":1}}],[\"详解\",{\"0\":{\"1247\":1,\"1304\":1},\"1\":{\"618\":1,\"1305\":1,\"1306\":1}}],[\"详细设计\",{\"1\":{\"555\":1}}],[\"详细内容\",{\"1\":{\"512\":1}}],[\"详情请自行了解\",{\"1\":{\"661\":1}}],[\"详情可自行百度\",{\"1\":{\"668\":1}}],[\"详情可\",{\"1\":{\"547\":1}}],[\"详情\",{\"1\":{\"512\":1,\"664\":2}}],[\"几个方法实现等待\",{\"1\":{\"1248\":1}}],[\"几个重点\",{\"1\":{\"512\":1,\"513\":1}}],[\"几乎就是一个\",{\"1\":{\"1293\":1}}],[\"几乎退化成\",{\"1\":{\"274\":1}}],[\"几乎是不二选择\",{\"1\":{\"26\":1}}],[\"地址安全\",{\"1\":{\"664\":1}}],[\"地址和端口\",{\"1\":{\"663\":1}}],[\"地址映射到页面文件\",{\"1\":{\"542\":1}}],[\"地址\",{\"1\":{\"511\":1,\"520\":1,\"542\":2,\"634\":2,\"672\":1,\"1018\":1}}],[\"地图上有\",{\"1\":{\"263\":1}}],[\"地图其有以下几种标识\",{\"1\":{\"180\":1}}],[\"微博架构组面试\",{\"1\":{\"649\":1}}],[\"微服务架构\",{\"1\":{\"634\":1}}],[\"微信开放平台id\",{\"1\":{\"510\":1}}],[\"微调\",{\"1\":{\"40\":1}}],[\"库表设计\",{\"0\":{\"509\":1}}],[\"≥j\",{\"1\":{\"893\":1}}],[\"≥\",{\"1\":{\"502\":1,\"537\":1}}],[\"性价比机场\",{\"1\":{\"661\":1}}],[\"性别\",{\"1\":{\"566\":2,\"592\":1,\"938\":1}}],[\"性别是否需要加索引\",{\"1\":{\"565\":1}}],[\"性能高效\",{\"1\":{\"1380\":1}}],[\"性能会大大提升\",{\"1\":{\"1290\":1}}],[\"性能得到提升\",{\"1\":{\"1218\":1}}],[\"性能提升\",{\"1\":{\"619\":1}}],[\"性能极高\",{\"1\":{\"534\":1}}],[\"性能\",{\"1\":{\"500\":1,\"622\":1}}],[\"性质\",{\"1\":{\"362\":1,\"407\":1}}],[\"富文本编辑器组件\",{\"1\":{\"499\":1}}],[\"熔断\",{\"1\":{\"493\":1}}],[\"探测数组空单元的方式有很多\",{\"1\":{\"1306\":1}}],[\"探测\",{\"1\":{\"493\":1}}],[\"复用同一个页面\",{\"1\":{\"542\":1}}],[\"复杂的交互和动态内容需要等待客户端的\",{\"1\":{\"533\":1}}],[\"复杂的交互和动态内容有延迟\",{\"1\":{\"533\":1}}],[\"复杂评论业务的服务编排\",{\"1\":{\"46\":1}}],[\"复制到锁记录中\",{\"1\":{\"1446\":1}}],[\"复制到自己指定的目录\",{\"1\":{\"1090\":1}}],[\"复制出一个新的容器\",{\"1\":{\"1291\":1}}],[\"复制的操作包含\",{\"1\":{\"1160\":1}}],[\"复制random指针\",{\"1\":{\"888\":1}}],[\"复制每个节点\",{\"1\":{\"888\":1}}],[\"复制链表\",{\"1\":{\"887\":1}}],[\"复制链表中的指针都不应指向原链表中的节点\",{\"1\":{\"886\":1}}],[\"复制框架生成的登录页面\",{\"1\":{\"587\":1}}],[\"复制\",{\"1\":{\"488\":1,\"592\":1,\"888\":1}}],[\"打个比方\",{\"1\":{\"1434\":1}}],[\"打个比方说\",{\"1\":{\"1313\":1}}],[\"打声招呼\",{\"1\":{\"1129\":1}}],[\"打印\",{\"1\":{\"994\":1}}],[\"打印到一个\",{\"1\":{\"994\":1}}],[\"打印开头下标\",{\"1\":{\"411\":1}}],[\"打家劫舍\",{\"0\":{\"825\":1},\"1\":{\"825\":1}}],[\"打开这个文件后\",{\"1\":{\"1149\":1}}],[\"打开源码\",{\"1\":{\"1145\":1}}],[\"打开终端\",{\"1\":{\"559\":2}}],[\"打开项目\",{\"1\":{\"538\":1}}],[\"打开\",{\"1\":{\"487\":1,\"663\":1,\"664\":1,\"1190\":1}}],[\"导航栏输入\",{\"1\":{\"1089\":1}}],[\"导航左侧\",{\"1\":{\"675\":1}}],[\"导航菜单配置\",{\"0\":{\"551\":1}}],[\"导致锁膨胀的流程图\",{\"1\":{\"1447\":1}}],[\"导致在垃圾回收的时候进行可达性分析的时候\",{\"1\":{\"1313\":1}}],[\"导致的结果就是队列长度会越来越短\",{\"1\":{\"1283\":1}}],[\"导致数据库压力很大甚至崩溃\",{\"1\":{\"613\":1}}],[\"导致部分数据被过滤\",{\"1\":{\"37\":1}}],[\"导入到数据库中\",{\"1\":{\"486\":1}}],[\"导入sql\",{\"0\":{\"486\":1}}],[\"失败的线程会重新尝试\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"失败即\",{\"1\":{\"1283\":1}}],[\"失败后的状态图\",{\"1\":{\"1283\":1}}],[\"失败时状态示意图如下\",{\"1\":{\"1283\":1}}],[\"失败不需要重试的原因是\",{\"1\":{\"1283\":1}}],[\"失败会直接进入到同步队列\",{\"1\":{\"1253\":1}}],[\"失败或者已经获取读锁的线程再次获取读锁时\",{\"1\":{\"1242\":1}}],[\"失败抛出异常\",{\"1\":{\"1076\":3}}],[\"失败\",{\"1\":{\"481\":6,\"954\":1,\"1503\":1}}],[\"失败则输出\",{\"1\":{\"174\":1}}],[\"入队操作\",{\"0\":{\"1504\":1},\"1\":{\"1351\":1}}],[\"入参\",{\"1\":{\"1315\":1}}],[\"入参增加一个\",{\"1\":{\"1259\":3}}],[\"入栈元素e\",{\"1\":{\"1075\":1}}],[\"入口在定时任务模块的\",{\"1\":{\"481\":1,\"482\":1}}],[\"入度为0\",{\"1\":{\"314\":1}}],[\"入度\",{\"1\":{\"314\":1}}],[\"体系中古老的\",{\"1\":{\"1264\":1}}],[\"体系中大部分的核心类和接口\",{\"1\":{\"1134\":1}}],[\"体系下依然会有同样的方法实现等待\",{\"1\":{\"1248\":1}}],[\"体系\",{\"0\":{\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":1,\"1139\":1,\"1140\":1}}],[\"体系结构\",{\"0\":{\"478\":1}}],[\"体量大\",{\"1\":{\"434\":1}}],[\"继承aqs的静态内存类\",{\"1\":{\"1496\":1}}],[\"继承aqs\",{\"1\":{\"1495\":1}}],[\"继承该父类\",{\"1\":{\"1469\":1}}],[\"继承thread\",{\"1\":{\"1330\":2}}],[\"继承于\",{\"1\":{\"1325\":1}}],[\"继承于承载数据的\",{\"1\":{\"1267\":1}}],[\"继承了\",{\"1\":{\"1075\":1,\"1264\":1,\"1305\":1,\"1365\":1,\"1366\":1,\"1371\":1}}],[\"继承\",{\"0\":{\"688\":1},\"1\":{\"688\":1,\"1059\":1,\"1140\":2,\"1160\":1,\"1178\":1,\"1496\":1}}],[\"继承抽象类\",{\"1\":{\"477\":2}}],[\"继自建博客之后\",{\"1\":{\"668\":1}}],[\"继续先看图\",{\"1\":{\"1433\":1}}],[\"继续来看代码\",{\"1\":{\"1432\":1}}],[\"继续往下执行\",{\"1\":{\"1398\":1,\"1407\":1}}],[\"继续向后环形搜索\",{\"1\":{\"1316\":1}}],[\"继续向后环形查找\",{\"1\":{\"1307\":1}}],[\"继续将其清理\",{\"1\":{\"1316\":1}}],[\"继续将其清除\",{\"1\":{\"1316\":1}}],[\"继续搜索\",{\"1\":{\"1316\":2}}],[\"继续看\",{\"1\":{\"1284\":1}}],[\"继续执行下面的操作\",{\"1\":{\"1404\":1}}],[\"继续执行\",{\"1\":{\"1254\":1}}],[\"继续上述迭代处理即可\",{\"1\":{\"731\":1}}],[\"继续down\",{\"1\":{\"417\":1}}],[\"继续枚举\",{\"1\":{\"291\":1}}],[\"继续后移\",{\"1\":{\"262\":1}}],[\"禁止在构造函数对一个\",{\"1\":{\"1476\":1}}],[\"禁止初次读对象的引用与读该对象包含的\",{\"1\":{\"1476\":1}}],[\"禁止\",{\"1\":{\"1476\":1}}],[\"禁止编译器把\",{\"1\":{\"1475\":1}}],[\"禁止对final域的写重排序到构造函数之外\",{\"1\":{\"1475\":1}}],[\"禁止下面所有的普通写操作和上面的\",{\"1\":{\"1457\":1}}],[\"禁止下面所有的普通读操作和上面的\",{\"1\":{\"1457\":1}}],[\"禁止上面的普通写和下面的\",{\"1\":{\"1457\":1}}],[\"禁止并发执行\",{\"1\":{\"477\":1}}],[\"禁用http响应标头\",{\"1\":{\"446\":1}}],[\"禁用\",{\"1\":{\"446\":1}}],[\"抽象示意图\",{\"1\":{\"1417\":1}}],[\"抽象结构模型\",{\"0\":{\"1417\":1}}],[\"抽象类\",{\"1\":{\"1160\":1}}],[\"抽象\",{\"1\":{\"477\":1}}],[\"抽象为一个排队的\",{\"1\":{\"37\":1}}],[\"执行情况\",{\"1\":{\"1496\":1}}],[\"执行情景图\",{\"1\":{\"1316\":1}}],[\"执行临界区代码\",{\"1\":{\"1433\":1}}],[\"执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法\",{\"1\":{\"1431\":1}}],[\"执行静态同步方法的时候就只有一条\",{\"1\":{\"1431\":1}}],[\"执行同步代码块后首先要先执行\",{\"1\":{\"1431\":1}}],[\"执行最终结果都是\",{\"1\":{\"1418\":1}}],[\"执行后面的代码\",{\"1\":{\"1407\":1}}],[\"执行后进入前端框架初始化过程\",{\"1\":{\"559\":1}}],[\"执行者\",{\"1\":{\"1371\":1}}],[\"执行者以及任务结果\",{\"1\":{\"1371\":1}}],[\"执行过程\",{\"0\":{\"1370\":1}}],[\"执行任务\",{\"1\":{\"1367\":2}}],[\"执行时间距离当前时间越近的任务在队列的前面\",{\"1\":{\"1369\":1}}],[\"执行时间不同的任务可以交给不同规模的线程池来处理\",{\"1\":{\"1361\":1}}],[\"执行时机不同\",{\"1\":{\"933\":1}}],[\"执行当前任务\",{\"1\":{\"1359\":1}}],[\"执行了\",{\"1\":{\"1337\":1}}],[\"执行死循环\",{\"1\":{\"1336\":1}}],[\"执行cleansomeslots\",{\"1\":{\"1317\":1}}],[\"执行完后线程\",{\"1\":{\"1476\":1}}],[\"执行完\",{\"1\":{\"1285\":1}}],[\"执行结果对操作\",{\"1\":{\"1455\":1}}],[\"执行结果对\",{\"1\":{\"1421\":1}}],[\"执行结果等\",{\"1\":{\"476\":1}}],[\"执行结束\",{\"1\":{\"1284\":1}}],[\"执行示意图如下图\",{\"1\":{\"1252\":1}}],[\"执行注册\",{\"1\":{\"1185\":1}}],[\"执行调度任务\",{\"1\":{\"1185\":1}}],[\"执行对象的方法\",{\"1\":{\"1132\":1}}],[\"执行速度慢\",{\"1\":{\"1056\":1}}],[\"执行某些语句\",{\"1\":{\"984\":1}}],[\"执行sql语句\",{\"1\":{\"954\":2}}],[\"执行顺序可能为\",{\"1\":{\"1283\":1}}],[\"执行顺序为\",{\"1\":{\"1283\":1}}],[\"执行顺序\",{\"1\":{\"933\":1}}],[\"执行将会报错\",{\"1\":{\"923\":1}}],[\"执行操作\",{\"1\":{\"585\":1,\"1421\":2}}],[\"执行具体的业务代码\",{\"1\":{\"576\":1}}],[\"执行\",{\"1\":{\"559\":1,\"833\":1,\"1089\":1,\"1090\":1,\"1184\":1,\"1254\":1,\"1284\":2,\"1285\":3,\"1368\":1,\"1371\":1,\"1375\":4,\"1376\":1,\"1407\":1,\"1455\":1,\"1456\":1,\"1475\":1,\"1476\":3,\"1478\":1,\"1484\":1}}],[\"执行命令\",{\"1\":{\"539\":1}}],[\"执行安装命令\",{\"1\":{\"538\":1,\"540\":1}}],[\"执行相应的处理逻辑\",{\"1\":{\"533\":1}}],[\"执行数据库初始化文件\",{\"1\":{\"514\":1}}],[\"执行的参数\",{\"1\":{\"476\":1}}],[\"执行的类全名\",{\"1\":{\"476\":1}}],[\"执行缓存的更新操作\",{\"1\":{\"28\":1}}],[\"界面\",{\"1\":{\"475\":1,\"663\":1}}],[\"往阻塞队列插入数据的线程会被阻塞\",{\"1\":{\"1325\":1}}],[\"往队列插入数据\",{\"1\":{\"1325\":1}}],[\"往后会发现索引为\",{\"1\":{\"1316\":1}}],[\"往后环形继续查找\",{\"1\":{\"1316\":1}}],[\"往后环形查找\",{\"1\":{\"1307\":1}}],[\"往这个\",{\"1\":{\"1305\":1}}],[\"往新数组中添加新的数据\",{\"1\":{\"1294\":1}}],[\"往前寻找队列真正的队尾节点\",{\"1\":{\"1285\":1}}],[\"往链表中插入节点的部分代码为\",{\"1\":{\"1272\":1}}],[\"往\",{\"1\":{\"822\":1,\"1194\":1}}],[\"往期回顾\",{\"0\":{\"652\":1}}],[\"往往利用定时任务调度进行一些比对工作\",{\"1\":{\"475\":1}}],[\"往大了做就是评论平台\",{\"1\":{\"45\":1}}],[\"属性length\",{\"1\":{\"1002\":1}}],[\"属性\",{\"1\":{\"592\":1,\"1051\":1,\"1346\":1}}],[\"属性中\",{\"1\":{\"471\":1}}],[\"属于编译器重排序\",{\"1\":{\"1418\":1}}],[\"属于\",{\"1\":{\"467\":2}}],[\"属于非强制需要一致性考虑的\",{\"1\":{\"56\":1}}],[\"仅为该类的成员变量提供\",{\"1\":{\"1472\":1}}],[\"仅仅实现栈的操作\",{\"1\":{\"1075\":1}}],[\"仅用于单节点数据库\",{\"1\":{\"937\":1}}],[\"仅管理员可见\",{\"1\":{\"556\":1}}],[\"仅管理员可用\",{\"1\":{\"525\":2,\"526\":1}}],[\"仅管理员可操作\",{\"1\":{\"513\":1}}],[\"仅实体继承\",{\"1\":{\"471\":1}}],[\"仅本人数据权限\",{\"1\":{\"470\":1}}],[\"仅由字符\",{\"1\":{\"71\":1}}],[\"市场部的员工应该只能访问到销售部的数据\",{\"1\":{\"470\":1}}],[\"角色\",{\"1\":{\"467\":2,\"471\":1,\"592\":1}}],[\"角色权限示例\",{\"1\":{\"467\":1}}],[\"符合题目要求\",{\"1\":{\"688\":1}}],[\"符合\",{\"1\":{\"467\":2}}],[\"符号\",{\"1\":{\"337\":1,\"1112\":1,\"1113\":2}}],[\"符号翻转的意思是正数变负数\",{\"1\":{\"104\":1}}],[\"验证二叉搜索树\",{\"0\":{\"897\":1},\"1\":{\"897\":1}}],[\"验证用户是否不具备某角色\",{\"1\":{\"466\":1}}],[\"验证用户是否不具备某权限\",{\"1\":{\"466\":1}}],[\"验证用户是否具有以下任意一个角色\",{\"1\":{\"466\":1}}],[\"验证用户是否具有以下任意一个权限\",{\"1\":{\"466\":1}}],[\"验证用户是否具备某权限\",{\"1\":{\"466\":1}}],[\"验证码校验\",{\"1\":{\"451\":1}}],[\"验证码captchaimage\",{\"1\":{\"446\":1}}],[\"框架体系中\",{\"1\":{\"1375\":1}}],[\"框架来说\",{\"1\":{\"1131\":1}}],[\"框架初探及概念详解\",{\"1\":{\"640\":1}}],[\"框架本身是用来做后台管理系统\",{\"1\":{\"587\":1}}],[\"框架封装的服务器\",{\"1\":{\"574\":1}}],[\"框架\",{\"1\":{\"499\":1,\"500\":2,\"557\":1,\"1184\":2}}],[\"框架的权限注解\",{\"1\":{\"465\":1}}],[\"框架会抛出相应的权限异常\",{\"1\":{\"465\":1}}],[\"框架中提供的一个安全注解\",{\"1\":{\"465\":1}}],[\"侧边栏\",{\"1\":{\"463\":1}}],[\"布谷鸟过滤器\",{\"1\":{\"632\":1}}],[\"布局组件\",{\"1\":{\"463\":1}}],[\"布隆过滤器中二进制\",{\"1\":{\"613\":1}}],[\"布隆过滤器解决缓存穿透\",{\"1\":{\"613\":1}}],[\"布隆过滤器提供一组\",{\"1\":{\"613\":1}}],[\"布隆过滤器在项目中的使用\",{\"0\":{\"613\":1}}],[\"布隆过滤器\",{\"1\":{\"27\":1,\"613\":3,\"632\":1},\"2\":{\"615\":1}}],[\"路由选择\",{\"1\":{\"665\":1}}],[\"路由组\",{\"1\":{\"542\":1}}],[\"路由菜单加载\",{\"0\":{\"463\":1}}],[\"路径总和\",{\"0\":{\"879\":1},\"1\":{\"879\":1}}],[\"路径和\",{\"1\":{\"717\":1}}],[\"路径\",{\"1\":{\"592\":1,\"717\":1,\"880\":2}}],[\"路径中至少存在两个相同的点\",{\"1\":{\"354\":1}}],[\"路径的定义是从\",{\"1\":{\"312\":1}}],[\"路径允许重复经过点或边\",{\"1\":{\"223\":1}}],[\"文档\",{\"1\":{\"1095\":1,\"1325\":1,\"1326\":2}}],[\"文档全面\",{\"1\":{\"1095\":1}}],[\"文本数据\",{\"1\":{\"1093\":1}}],[\"文持\",{\"1\":{\"545\":1}}],[\"文件名\",{\"1\":{\"1119\":2}}],[\"文件参数变量\",{\"0\":{\"1119\":1}}],[\"文件开头需要写\",{\"1\":{\"1107\":1}}],[\"文件路径\",{\"1\":{\"1103\":1}}],[\"文件的管理\",{\"1\":{\"1095\":1}}],[\"文件的技术\",{\"1\":{\"534\":1}}],[\"文件上传至\",{\"1\":{\"672\":1}}],[\"文件上传都会被扫描一遍\",{\"1\":{\"668\":1}}],[\"文件安装即可\",{\"1\":{\"665\":2}}],[\"文件进行使用了\",{\"1\":{\"665\":1}}],[\"文件夹主要是和测试相关的\",{\"1\":{\"559\":1}}],[\"文件夹里面定义了一系列后台接口程序\",{\"1\":{\"559\":1}}],[\"文件夹里面定义的是一系列测试流程\",{\"1\":{\"559\":1}}],[\"文件夹的\",{\"1\":{\"559\":1}}],[\"文件夹\",{\"1\":{\"549\":1,\"559\":5}}],[\"文件组织形式\",{\"0\":{\"544\":1}}],[\"文件可以改变校验规则\",{\"1\":{\"539\":1}}],[\"文件中配置之后即可使用\",{\"1\":{\"613\":1}}],[\"文件中找到\",{\"1\":{\"596\":1}}],[\"文件中\",{\"1\":{\"592\":1}}],[\"文件中引入\",{\"1\":{\"540\":1}}],[\"文件中执行格式化快捷键\",{\"1\":{\"539\":1}}],[\"文件中通过\",{\"1\":{\"471\":1}}],[\"文件和其他静态资源\",{\"1\":{\"532\":1}}],[\"文件\",{\"1\":{\"458\":1,\"531\":1,\"532\":4,\"534\":1,\"542\":1,\"559\":3,\"1087\":2,\"1090\":1,\"1103\":3,\"1107\":1,\"1141\":1}}],[\"文章开篇提到等待\",{\"1\":{\"1253\":1}}],[\"文章等业务下也能接入一样的评论系统\",{\"1\":{\"45\":1}}],[\"文章\",{\"1\":{\"19\":1},\"2\":{\"637\":1,\"650\":1,\"654\":1}}],[\"看看他们做了什么事情\",{\"1\":{\"1505\":1}}],[\"看上面的图片已经将每种情况整理出来了\",{\"1\":{\"1465\":1}}],[\"看似没有其他线程参与\",{\"1\":{\"1330\":1}}],[\"看下\",{\"1\":{\"1302\":1}}],[\"看下面代码\",{\"1\":{\"1178\":1}}],[\"看\",{\"1\":{\"1302\":1}}],[\"看一下\",{\"1\":{\"1295\":1}}],[\"看完了\",{\"1\":{\"1273\":1}}],[\"看完了写锁\",{\"1\":{\"1242\":1}}],[\"看不出来注册的代码在哪\",{\"1\":{\"1175\":1}}],[\"看到的侧边栏菜单将根据他的角色权限而有所不同\",{\"1\":{\"458\":1}}],[\"看是否能找到匹配的\",{\"1\":{\"187\":1}}],[\"菜单\",{\"1\":{\"456\":1,\"665\":1}}],[\"登录失败\",{\"1\":{\"589\":1}}],[\"登录页面\",{\"0\":{\"588\":1}}],[\"登录页面和注册页面不需要强制路由\",{\"1\":{\"587\":1}}],[\"登录接口\",{\"0\":{\"576\":1}}],[\"登录实现代码\",{\"1\":{\"575\":1}}],[\"登录名\",{\"1\":{\"575\":1}}],[\"登录逻辑\",{\"0\":{\"574\":1}}],[\"登录功能\",{\"0\":{\"572\":1}}],[\"登录\",{\"1\":{\"556\":1,\"589\":1,\"1089\":1}}],[\"登录成功后\",{\"1\":{\"575\":1}}],[\"登录成功\",{\"1\":{\"451\":1,\"580\":1,\"589\":1}}],[\"登录前置校验\",{\"1\":{\"451\":1}}],[\"添加完元素之后\",{\"1\":{\"1291\":1}}],[\"添加缓存\",{\"1\":{\"1201\":1}}],[\"添加到栈层次任何先前信息中\",{\"1\":{\"1046\":1}}],[\"添加关键字和其对应的值\",{\"1\":{\"1040\":1}}],[\"添加元素e到队尾\",{\"1\":{\"1076\":1}}],[\"添加元素\",{\"1\":{\"1039\":1}}],[\"添加唯一约束时\",{\"1\":{\"959\":1}}],[\"添加外键\",{\"1\":{\"937\":1}}],[\"添加数据\",{\"1\":{\"924\":1}}],[\"添加字段\",{\"1\":{\"922\":1,\"937\":1}}],[\"添加键值对\",{\"1\":{\"887\":1}}],[\"添加记录\",{\"1\":{\"672\":1}}],[\"添加端口规则\",{\"1\":{\"663\":1}}],[\"添加端口\",{\"1\":{\"663\":1}}],[\"添加一个版本号可以解决\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"添加一条从\",{\"1\":{\"875\":1}}],[\"添加一条边a\",{\"1\":{\"345\":1}}],[\"添加一层\",{\"1\":{\"613\":1}}],[\"添加用户注销接口\",{\"1\":{\"596\":1}}],[\"添加后台管理页面\",{\"0\":{\"592\":1}}],[\"添加白名单\",{\"1\":{\"587\":1}}],[\"添加路由规则\",{\"1\":{\"587\":1}}],[\"添加页面\",{\"1\":{\"559\":1}}],[\"添加逻辑删除注解\",{\"1\":{\"515\":1}}],[\"添加联合唯一索引\",{\"1\":{\"513\":1}}],[\"添加定时任务\",{\"0\":{\"481\":1}}],[\"添加\",{\"0\":{\"1203\":1},\"1\":{\"475\":1,\"526\":1,\"588\":1,\"663\":1,\"665\":1,\"1100\":1}}],[\"添加cors\",{\"1\":{\"446\":1}}],[\"添加jwt\",{\"1\":{\"446\":1}}],[\"添加logout\",{\"1\":{\"446\":1}}],[\"允许\",{\"1\":{\"1421\":1}}],[\"允许这种重排序\",{\"1\":{\"1420\":1,\"1423\":1}}],[\"允许的最大许可数为\",{\"1\":{\"1398\":1}}],[\"允许应用直接访问我们的云盘内容\",{\"1\":{\"674\":1}}],[\"允许外部访问\",{\"1\":{\"670\":1}}],[\"允许部分页面在构建之后进行更新\",{\"1\":{\"534\":1}}],[\"允许并发执行\",{\"1\":{\"477\":1}}],[\"允许匿名访问\",{\"1\":{\"446\":1}}],[\"允许匿名访问的地址\",{\"1\":{\"446\":1}}],[\"允许通过remember\",{\"1\":{\"446\":1}}],[\"授权是确认用户在通过认证之后\",{\"1\":{\"445\":1}}],[\"授权\",{\"1\":{\"445\":1,\"446\":1}}],[\"权限校验\",{\"1\":{\"556\":1}}],[\"权限的分配和控制主要依赖于角色\",{\"1\":{\"470\":1}}],[\"权限的验证最核心的是使用的\",{\"1\":{\"465\":1}}],[\"权限提示\",{\"1\":{\"467\":1}}],[\"权限要求即可\",{\"1\":{\"467\":1}}],[\"权限要求\",{\"1\":{\"467\":2}}],[\"权限方法\",{\"0\":{\"466\":1}}],[\"权限注解\",{\"0\":{\"464\":1}}],[\"权限控制流程\",{\"1\":{\"465\":1}}],[\"权限控制\",{\"0\":{\"444\":1},\"1\":{\"500\":1}}],[\"权重\",{\"1\":{\"361\":1}}],[\"权重为\",{\"1\":{\"196\":1}}],[\"挖出干货\",{\"1\":{\"438\":1}}],[\"挖掘和利用\",{\"1\":{\"437\":1}}],[\"挥之则去\",{\"1\":{\"438\":1}}],[\"日志文件\",{\"1\":{\"1093\":1}}],[\"日志分析\",{\"1\":{\"438\":1}}],[\"日常我们在网站中看到的各种各样的分页条\",{\"1\":{\"935\":1}}],[\"日常的代理客户端\",{\"1\":{\"664\":1}}],[\"日期等\",{\"1\":{\"948\":1}}],[\"日期值\",{\"1\":{\"920\":1}}],[\"日期时间类型\",{\"1\":{\"920\":2}}],[\"日卡\",{\"1\":{\"65\":1}}],[\"环形查找\",{\"1\":{\"1306\":1}}],[\"环形依赖\",{\"1\":{\"46\":1}}],[\"环境名称\",{\"1\":{\"1194\":1}}],[\"环境\",{\"1\":{\"1190\":1}}],[\"环境变量改为自定义变量\",{\"1\":{\"1116\":1}}],[\"环境变量\",{\"1\":{\"1116\":1}}],[\"环境或\",{\"1\":{\"1045\":1}}],[\"环境准备\",{\"0\":{\"502\":1}}],[\"环湖而饲\",{\"1\":{\"438\":1}}],[\"环上的服务包括了\",{\"1\":{\"438\":1}}],[\"智能湖仓并非单一产品\",{\"1\":{\"438\":1}}],[\"智能湖仓\",{\"1\":{\"438\":1}}],[\"仓以及所有其他数据处理服务组成统一且连续的整体\",{\"1\":{\"438\":1}}],[\"仓里\",{\"1\":{\"438\":1}}],[\"摄取到数仓中\",{\"1\":{\"438\":1}}],[\"流程\",{\"1\":{\"1182\":1}}],[\"流程如下\",{\"1\":{\"1129\":1}}],[\"流程图\",{\"1\":{\"480\":1}}],[\"流量被盗刷事件\",{\"1\":{\"668\":1}}],[\"流量包推荐\",{\"1\":{\"661\":1}}],[\"流量控制\",{\"1\":{\"500\":1}}],[\"流量热点是因为突然热门的主题\",{\"1\":{\"61\":1}}],[\"流动\",{\"1\":{\"438\":1}}],[\"诞生了\",{\"1\":{\"438\":1}}],[\"少点重复建设\",{\"1\":{\"438\":1}}],[\"人们尝试着将彼此整合一下\",{\"1\":{\"438\":1}}],[\"又能提高程序的执行效率\",{\"1\":{\"1423\":1}}],[\"又能及时更新网站的内容\",{\"1\":{\"534\":1}}],[\"又叫做比较交换来鉴别线程是否出现冲突\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"又称为无锁操作\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"又称子查询\",{\"1\":{\"947\":1}}],[\"又获得了\",{\"1\":{\"1339\":1}}],[\"又是怎样确定的呢\",{\"1\":{\"1306\":1}}],[\"又是空节点\",{\"1\":{\"412\":1}}],[\"又互相不影响到彼此即让多个线程间达到隔离的状态\",{\"1\":{\"1299\":1}}],[\"又比如白名单\",{\"1\":{\"1290\":1}}],[\"又比如当我们在网上购物时\",{\"1\":{\"1218\":1}}],[\"又创建了一个监听器\",{\"1\":{\"1158\":1}}],[\"又实现\",{\"1\":{\"1076\":1}}],[\"又想建仓的用户来说\",{\"1\":{\"438\":1}}],[\"湖仓一体架构的创新与实践\",{\"1\":{\"639\":1}}],[\"湖仓一体\",{\"0\":{\"438\":1}}],[\"湖里的\",{\"1\":{\"438\":1}}],[\"湖里\",{\"1\":{\"437\":1,\"438\":1}}],[\"兜底\",{\"1\":{\"437\":1}}],[\"含有这样两个成员变量\",{\"1\":{\"1281\":1}}],[\"含有3个元素的数组\",{\"1\":{\"998\":2}}],[\"含最小\",{\"1\":{\"931\":1}}],[\"含金量更高\",{\"1\":{\"437\":1}}],[\"含义如题所示3≤n≤10182≤k≤100\",{\"1\":{\"99\":1}}],[\"含义如题所述\",{\"1\":{\"97\":1,\"126\":1}}],[\"价值也为元素的数值\",{\"1\":{\"772\":1}}],[\"价值密度更高\",{\"1\":{\"437\":1}}],[\"价格分别是\",{\"1\":{\"152\":1}}],[\"价格\",{\"1\":{\"140\":1}}],[\"制定数据访问策略和安全策略\",{\"1\":{\"437\":1}}],[\"搬到\",{\"1\":{\"437\":1}}],[\"治理工具\",{\"1\":{\"437\":1}}],[\"囤\",{\"1\":{\"437\":1}}],[\"化的方式优化表结构\",{\"1\":{\"436\":1}}],[\"化为\",{\"1\":{\"385\":1}}],[\"视频数据\",{\"1\":{\"1093\":1}}],[\"视频播放器等产品都支持通过\",{\"1\":{\"674\":1}}],[\"视频等\",{\"1\":{\"434\":1}}],[\"视频游戏评论\",{\"1\":{\"21\":1}}],[\"半结构化数据和非结构化数据\",{\"1\":{\"434\":1}}],[\"半径为\",{\"1\":{\"97\":1}}],[\"拍字节\",{\"1\":{\"434\":1}}],[\"太字节\",{\"1\":{\"434\":1}}],[\"唯一的不同在于获取锁失败后\",{\"1\":{\"1508\":1}}],[\"唯一的不同在于增加了\",{\"1\":{\"1233\":1}}],[\"唯一的方式是对其实现原理进行理解\",{\"1\":{\"1344\":1}}],[\"唯一的区别是当\",{\"1\":{\"1507\":1}}],[\"唯一的区别是\",{\"1\":{\"989\":1}}],[\"唯一的区别是查找第一个大于\",{\"1\":{\"423\":1}}],[\"唯一约束\",{\"1\":{\"919\":1}}],[\"唯一标识\",{\"1\":{\"566\":1}}],[\"唯一不同的在于\",{\"1\":{\"411\":1}}],[\"唯一不同的是需要计算出每次逃出迷宫的路径\",{\"1\":{\"236\":1}}],[\"圧位\",{\"1\":{\"422\":1}}],[\"默认存储结构为\",{\"1\":{\"1440\":1}}],[\"默认的是非公平性\",{\"1\":{\"1398\":1}}],[\"默认的下载不限速\",{\"1\":{\"670\":1}}],[\"默认优先级为\",{\"1\":{\"1339\":1}}],[\"默认情况下\",{\"1\":{\"1339\":1}}],[\"默认情况下元素采用自然顺序进行排序\",{\"1\":{\"1326\":1}}],[\"默认情况下不能保证线程访问队列的公平性\",{\"1\":{\"1326\":1}}],[\"默认超过\",{\"1\":{\"1272\":1}}],[\"默认大小为16\",{\"1\":{\"1270\":1}}],[\"默认选择的是非公平锁\",{\"1\":{\"1233\":1}}],[\"默认上下文\",{\"0\":{\"1163\":1},\"1\":{\"1163\":1}}],[\"默认变量\",{\"0\":{\"1118\":1}}],[\"默认用户名和密码都是\",{\"1\":{\"1089\":1}}],[\"默认均为\",{\"1\":{\"1087\":1}}],[\"默认实现小根堆\",{\"1\":{\"1078\":1}}],[\"默认是小根堆\",{\"1\":{\"1038\":1}}],[\"默认是大根堆\",{\"1\":{\"422\":1}}],[\"默认保留6位小数\",{\"1\":{\"982\":2}}],[\"默认\",{\"1\":{\"954\":1,\"1158\":2,\"1160\":1,\"1194\":1,\"1237\":1}}],[\"默认约束\",{\"1\":{\"919\":1}}],[\"默认连接的端口号是\",{\"1\":{\"906\":1}}],[\"默认连接的是本地\",{\"1\":{\"906\":1}}],[\"默认路径在\",{\"1\":{\"672\":2}}],[\"默认启动方式是前台启动\",{\"1\":{\"671\":1}}],[\"默认会注册\",{\"1\":{\"1158\":1}}],[\"默认会获取\",{\"1\":{\"1158\":1}}],[\"默认会监听\",{\"1\":{\"670\":1}}],[\"默认会帮助我们查询出来没有被删的用户\",{\"1\":{\"575\":1}}],[\"默认权限\",{\"1\":{\"580\":1}}],[\"默认为\",{\"1\":{\"523\":1,\"1031\":1,\"1190\":2}}],[\"默认所有的\",{\"1\":{\"484\":1}}],[\"默认值\",{\"1\":{\"471\":1,\"934\":1}}],[\"默认按元素的排序规则排序\",{\"1\":{\"1078\":1}}],[\"默认按\",{\"1\":{\"422\":1}}],[\"默认染成\",{\"1\":{\"362\":1}}],[\"起到了控制的作用\",{\"1\":{\"1276\":1}}],[\"起始索引可以省略\",{\"1\":{\"935\":1}}],[\"起始索引从\",{\"1\":{\"935\":1}}],[\"起始索引\",{\"1\":{\"935\":2}}],[\"起始下标\",{\"1\":{\"422\":1}}],[\"起来\",{\"1\":{\"437\":1}}],[\"起点的入度为0\",{\"1\":{\"349\":1}}],[\"起点==终点时\",{\"1\":{\"223\":1}}],[\"起点到state的真实距离\",{\"1\":{\"221\":2}}],[\"起点\",{\"1\":{\"221\":1}}],[\"清除\",{\"1\":{\"1330\":1}}],[\"清除数据\",{\"1\":{\"1320\":1}}],[\"清除当前脏entry\",{\"1\":{\"1316\":1}}],[\"清理掉脏\",{\"1\":{\"1317\":1}}],[\"清理掉当前脏\",{\"1\":{\"1316\":1}}],[\"清理当前脏\",{\"1\":{\"1316\":1}}],[\"清理过期的缓存数据\",{\"1\":{\"1201\":1}}],[\"清空\",{\"1\":{\"422\":1,\"1036\":1,\"1037\":1,\"1038\":1,\"1039\":1,\"1040\":1}}],[\"清零\",{\"1\":{\"338\":1}}],[\"哈希桶\",{\"1\":{\"1317\":2}}],[\"哈希\",{\"2\":{\"769\":1,\"884\":1}}],[\"哈希链表\",{\"1\":{\"687\":1}}],[\"哈希函数可以将关键字均匀的分散到数组的不同位置\",{\"1\":{\"1306\":1}}],[\"哈希函数的选择\",{\"1\":{\"973\":1}}],[\"哈希函数会为每个键生成一个唯一的哈希值\",{\"1\":{\"971\":1}}],[\"哈希函数\",{\"1\":{\"420\":1,\"613\":1,\"971\":1}}],[\"哈希函数离散化\",{\"1\":{\"419\":1}}],[\"哈希表是一种非常实用的数据结构\",{\"1\":{\"973\":1}}],[\"哈希表不保证元素的顺序\",{\"1\":{\"973\":1}}],[\"哈希表通常需要预留一定比例的空闲空间\",{\"1\":{\"973\":1}}],[\"哈希表通过以下几种方法来处理冲突\",{\"1\":{\"971\":1}}],[\"哈希表支持键值对的存储方式\",{\"1\":{\"972\":1}}],[\"哈希表可以根据需要动态调整大小\",{\"1\":{\"972\":1}}],[\"哈希表可以在常数时间\",{\"1\":{\"972\":1}}],[\"哈希表会在表中寻找下一个空闲位置来存储元素\",{\"1\":{\"971\":1}}],[\"哈希表使用一个哈希函数来计算键的哈希值\",{\"1\":{\"971\":1}}],[\"哈希表的工作原理\",{\"0\":{\"971\":1}}],[\"哈希表查找快\",{\"1\":{\"687\":1}}],[\"哈希表\",{\"0\":{\"418\":1,\"887\":1,\"970\":1},\"1\":{\"422\":1,\"887\":1,\"971\":1,\"1039\":1,\"1040\":1}}],[\"串每一个特定的下标\",{\"1\":{\"411\":1}}],[\"串行\",{\"1\":{\"1484\":1}}],[\"串行处理\",{\"1\":{\"37\":1}}],[\"串行化\",{\"1\":{\"37\":1}}],[\"弹出堆顶元素\",{\"1\":{\"422\":1}}],[\"弹出队头元素\",{\"1\":{\"422\":1}}],[\"弹出队尾元素\",{\"1\":{\"410\":1}}],[\"弹出栈中所有高度小于等于当前高度的元素\",{\"1\":{\"128\":1}}],[\"弹出栈顶元素\",{\"1\":{\"128\":1,\"422\":1,\"1037\":1}}],[\"普通变量\",{\"1\":{\"1475\":1}}],[\"普通域\",{\"1\":{\"1475\":2}}],[\"普通函数中既可以调用普通函数\",{\"1\":{\"1027\":1}}],[\"普通用户\",{\"1\":{\"566\":2,\"592\":1}}],[\"普通用户会分配了特定的角色权限\",{\"1\":{\"458\":1}}],[\"普通队列\",{\"0\":{\"409\":1},\"1\":{\"1075\":1}}],[\"普通栈\",{\"0\":{\"406\":1}}],[\"普通数组\",{\"1\":{\"256\":1}}],[\"新数组为原数组的2倍\",{\"1\":{\"1306\":1}}],[\"新数据类型\",{\"1\":{\"922\":1}}],[\"新闻报道\",{\"1\":{\"1093\":1}}],[\"新表名\",{\"1\":{\"922\":1}}],[\"新字段名\",{\"1\":{\"922\":1}}],[\"新链表头节点\",{\"1\":{\"888\":1}}],[\"新链表的头节点\",{\"1\":{\"887\":1}}],[\"新节点\",{\"1\":{\"887\":1,\"888\":2}}],[\"新节点的\",{\"1\":{\"886\":1}}],[\"新节点的下一节点指向\",{\"1\":{\"403\":1}}],[\"新\",{\"1\":{\"887\":1}}],[\"新添加一个存储策略时采用的是\",{\"1\":{\"670\":1}}],[\"新加坡\",{\"1\":{\"662\":1}}],[\"新增的\",{\"1\":{\"1049\":1}}],[\"新增用户id\",{\"1\":{\"567\":1}}],[\"新增了\",{\"1\":{\"40\":2}}],[\"新建线程\",{\"0\":{\"1330\":1}}],[\"新建entry并插入table中i处\",{\"1\":{\"1306\":1}}],[\"新建forwardingnode引用\",{\"1\":{\"1274\":1}}],[\"新建node数组\",{\"1\":{\"1274\":1}}],[\"新建了\",{\"1\":{\"1250\":1,\"1496\":1}}],[\"新建一个大小为原来数组长度的两倍的数组\",{\"1\":{\"1306\":1}}],[\"新建一个\",{\"1\":{\"580\":1,\"1107\":1}}],[\"新建好工程\",{\"1\":{\"560\":1}}],[\"新建\",{\"1\":{\"548\":1,\"549\":1,\"1274\":1,\"1329\":1,\"1370\":1}}],[\"新鲜\",{\"1\":{\"438\":1}}],[\"胜负判定也比较复杂\",{\"1\":{\"395\":1}}],[\"公开的\",{\"1\":{\"663\":1}}],[\"公开接口\",{\"0\":{\"468\":1}}],[\"公平性选择\",{\"1\":{\"1237\":1}}],[\"公平性\",{\"1\":{\"1233\":1}}],[\"公平锁为了保证时间上的绝对顺序\",{\"1\":{\"1233\":1}}],[\"公平锁每次获取到锁为同步队列中的第一个节点\",{\"1\":{\"1233\":1}}],[\"公平锁每次都是从同步队列中的第一个节点获取到锁\",{\"1\":{\"1233\":1}}],[\"公平锁\",{\"1\":{\"1233\":1}}],[\"公平锁与公平锁\",{\"0\":{\"1233\":1}}],[\"公平锁与非公平锁之奥秘\",{\"1\":{\"643\":1}}],[\"公平锁和非公平锁\",{\"1\":{\"1231\":1,\"1233\":1}}],[\"公平组合游戏icg\",{\"0\":{\"395\":1}}],[\"公众号openid\",{\"1\":{\"510\":1}}],[\"公司级权限\",{\"1\":{\"470\":1}}],[\"公司新大楼要设计一片花坛\",{\"1\":{\"141\":1}}],[\"公司战略导向\",{\"1\":{\"39\":1}}],[\"必要要在非静态初始化块\",{\"1\":{\"1465\":1}}],[\"必要字段\",{\"1\":{\"566\":1}}],[\"必备的数据结构\",{\"1\":{\"1137\":1}}],[\"必然会带来线程安全问题\",{\"1\":{\"1309\":1}}],[\"必然有\",{\"1\":{\"1291\":1}}],[\"必然等于\",{\"1\":{\"846\":1}}],[\"必然在\",{\"1\":{\"840\":1}}],[\"必败状态\",{\"1\":{\"394\":1}}],[\"必胜状态\",{\"1\":{\"394\":1}}],[\"必胜状态和必败状态\",{\"1\":{\"394\":1}}],[\"必须保证多个线程能够安全的释放同步状态\",{\"1\":{\"1511\":1}}],[\"必须调用\",{\"1\":{\"1492\":1}}],[\"必须符合以下两条规则\",{\"1\":{\"1482\":1}}],[\"必须等到其他线程\",{\"1\":{\"1392\":1}}],[\"必须同名\",{\"1\":{\"1090\":1}}],[\"必须实现\",{\"1\":{\"1078\":1}}],[\"必须实现quartz的job接口\",{\"1\":{\"479\":1}}],[\"必须能被400整除\",{\"1\":{\"984\":1}}],[\"必须使所有的数据都保持一致状态\",{\"1\":{\"955\":1}}],[\"必须要在静态初始化块中指定初始值或者声明该类变量时指定初始值\",{\"1\":{\"1465\":1}}],[\"必须要切换到对应的数据库中\",{\"1\":{\"912\":1}}],[\"必须要判定\",{\"1\":{\"31\":1}}],[\"必须\",{\"1\":{\"874\":1}}],[\"必须以\",{\"1\":{\"686\":1}}],[\"必须鉴权\",{\"1\":{\"577\":1}}],[\"必须首先判断两个数是否相等\",{\"1\":{\"338\":1}}],[\"必须包含\",{\"1\":{\"174\":1}}],[\"必须匹配一个或多个前面的字符\",{\"1\":{\"127\":1}}],[\"必须容量大\",{\"1\":{\"30\":1}}],[\"必须有事务\",{\"1\":{\"30\":1}}],[\"集中处理\",{\"1\":{\"599\":1}}],[\"集成了多家云存储端\",{\"1\":{\"669\":1}}],[\"集成了多级缓存\",{\"1\":{\"27\":1}}],[\"集成一些其他的内容\",{\"1\":{\"557\":1}}],[\"集群信息\",{\"0\":{\"1192\":1}}],[\"集群环境下\",{\"1\":{\"1189\":1}}],[\"集群的信息\",{\"1\":{\"1165\":1}}],[\"集群节点帮助类\",{\"0\":{\"1162\":1}}],[\"集群可以组成联邦\",{\"1\":{\"1095\":1}}],[\"集群场景\",{\"1\":{\"937\":1}}],[\"集群\",{\"1\":{\"484\":1}}],[\"集群介绍\",{\"0\":{\"484\":1}}],[\"集群模式的优势\",{\"1\":{\"484\":1}}],[\"集群模式\",{\"0\":{\"483\":1},\"1\":{\"484\":1}}],[\"集合框架中的各种容器类如实现\",{\"1\":{\"1324\":1}}],[\"集合和\",{\"1\":{\"942\":1}}],[\"集合里的元素\",{\"1\":{\"772\":1}}],[\"集合中\",{\"1\":{\"613\":1,\"935\":1}}],[\"集合\",{\"0\":{\"1071\":1,\"1073\":1},\"1\":{\"456\":1,\"525\":1,\"935\":1,\"942\":1}}],[\"集合数量+1\",{\"1\":{\"392\":1}}],[\"跳出循环\",{\"1\":{\"1407\":1}}],[\"跳出这轮循环\",{\"1\":{\"392\":1}}],[\"跳着的\",{\"1\":{\"1286\":1}}],[\"跳转语句\",{\"0\":{\"991\":1}}],[\"跳转到对应的视图组件在\",{\"1\":{\"463\":1}}],[\"跳转到首页并加载\",{\"1\":{\"463\":1}}],[\"跳过\",{\"1\":{\"215\":1}}],[\"卡特兰数\",{\"0\":{\"391\":1}}],[\"卢卡斯\",{\"0\":{\"389\":1}}],[\"乘以加载因子\",{\"1\":{\"1271\":1}}],[\"乘积最大子数组\",{\"0\":{\"703\":1},\"1\":{\"703\":1}}],[\"乘积大于n\",{\"1\":{\"392\":1}}],[\"乘任意一个\",{\"1\":{\"388\":1}}],[\"乘法逆元\",{\"1\":{\"388\":1}}],[\"乘法逆元的定义\",{\"1\":{\"388\":1}}],[\"≡\",{\"1\":{\"388\":1}}],[\"费马小定理\",{\"1\":{\"388\":1}}],[\"∗1​=b\",{\"1\":{\"389\":1}}],[\"∗1∗b\",{\"1\":{\"389\":1}}],[\"∗b\",{\"1\":{\"389\":1}}],[\"∗infact\",{\"1\":{\"388\":2}}],[\"∗\",{\"1\":{\"388\":1,\"389\":9}}],[\"∗y\",{\"1\":{\"383\":1}}],[\"适用于需要快速查找\",{\"1\":{\"973\":1}}],[\"适用于编写\",{\"1\":{\"576\":1}}],[\"适用于复杂的交互和动态内容\",{\"1\":{\"532\":1}}],[\"适用于定义复杂的执行时间\",{\"1\":{\"479\":1}}],[\"适用于管理层级\",{\"1\":{\"470\":1}}],[\"适用于求解包含\",{\"1\":{\"385\":1}}],[\"适用题型\",{\"1\":{\"387\":1}}],[\"适合存放任意类型的文件\",{\"1\":{\"1094\":1}}],[\"适合内容变化不频繁的场景\",{\"1\":{\"534\":1}}],[\"适合稀疏图\",{\"1\":{\"351\":1}}],[\"适合稠密图\",{\"1\":{\"351\":1}}],[\"阶梯型矩阵\",{\"1\":{\"385\":1}}],[\"初识\",{\"0\":{\"1490\":1,\"1494\":1}}],[\"初识大数据\",{\"0\":{\"433\":1}}],[\"初次读引用变量\",{\"1\":{\"1475\":3}}],[\"初次读对象引用和初次读该对象包含的\",{\"1\":{\"1475\":1}}],[\"初看有道理\",{\"1\":{\"1141\":1}}],[\"初等行\",{\"1\":{\"385\":1}}],[\"初始大小\",{\"1\":{\"1369\":1}}],[\"初始大小为\",{\"1\":{\"1306\":1}}],[\"初始容量\",{\"1\":{\"1204\":1,\"1207\":1}}],[\"初始的烂橘子\",{\"1\":{\"870\":1}}],[\"初始的从左到右宝石分别编号\",{\"1\":{\"103\":1}}],[\"初始为前缀树的根节点\",{\"1\":{\"802\":2}}],[\"初始把所有链表的头节点入堆\",{\"1\":{\"789\":1}}],[\"初始将用户名的信息都初始化在布隆过滤器中\",{\"1\":{\"613\":1}}],[\"初始加载时需要下载和执行大量的\",{\"1\":{\"531\":1}}],[\"初始时线程的本地内存中\",{\"1\":{\"1456\":1}}],[\"初始时\",{\"1\":{\"1317\":1}}],[\"初始时队列里只有起始点\",{\"1\":{\"355\":1}}],[\"初始时画布上所有位置均为\",{\"1\":{\"157\":1}}],[\"初始值为\",{\"1\":{\"1392\":1}}],[\"初始值\",{\"1\":{\"307\":1,\"796\":1,\"797\":1,\"1392\":1}}],[\"初始值设为无穷大\",{\"1\":{\"146\":1}}],[\"初始最坏情况下一只猫一辆车\",{\"1\":{\"290\":1}}],[\"初始高度为1\",{\"1\":{\"274\":1}}],[\"初始根节点为它自己\",{\"1\":{\"274\":1}}],[\"初始步数为0\",{\"1\":{\"236\":1,\"237\":1}}],[\"初始状态依旧和\",{\"1\":{\"1317\":2}}],[\"初始状态和\",{\"1\":{\"1317\":4}}],[\"初始状态如下图所示\",{\"1\":{\"1284\":1}}],[\"初始状态\",{\"1\":{\"182\":1,\"1501\":1}}],[\"初始化对象\",{\"1\":{\"1485\":1}}],[\"初始化之前的值\",{\"1\":{\"1475\":1}}],[\"初始化状态\",{\"1\":{\"1281\":1}}],[\"初始化放在第一次插入数据时\",{\"1\":{\"1270\":1}}],[\"初始化了专门用于注册的\",{\"1\":{\"1184\":1}}],[\"初始化了一个状态变更的监听器\",{\"1\":{\"1182\":1}}],[\"初始化了一个\",{\"1\":{\"1182\":1,\"1185\":1}}],[\"初始化两个线程\",{\"1\":{\"1182\":1}}],[\"初始化网络通信组件\",{\"1\":{\"1182\":1}}],[\"初始化网络传输组件\",{\"1\":{\"1182\":1}}],[\"初始化网格\",{\"1\":{\"77\":1}}],[\"初始化实例信息管理器\",{\"0\":{\"1180\":1}}],[\"初始化实例信息\",{\"0\":{\"1179\":1}}],[\"初始化配置\",{\"0\":{\"1176\":1}}],[\"初始化配置的时候还初始化了一个\",{\"1\":{\"1157\":1}}],[\"初始化方法是一个线程安全的方法\",{\"1\":{\"1164\":1}}],[\"初始化注册的队列\",{\"1\":{\"1160\":1}}],[\"初始化摘除的队列\",{\"1\":{\"1160\":1}}],[\"初始化调度任务的方法中\",{\"1\":{\"1182\":3}}],[\"初始化调度任务\",{\"1\":{\"1158\":1}}],[\"初始化服务实例的配置\",{\"0\":{\"1153\":1},\"1\":{\"1155\":1}}],[\"初始化上下文的时序图\",{\"1\":{\"1146\":1}}],[\"初始化上下文的时序图如下\",{\"1\":{\"1146\":1}}],[\"初始化上下文\",{\"0\":{\"1146\":1,\"1161\":1,\"1165\":1}}],[\"初始化环境的方法是\",{\"1\":{\"1145\":1}}],[\"初始化环境和初始化上下文\",{\"1\":{\"1145\":1}}],[\"初始化环境时序图\",{\"1\":{\"1145\":1}}],[\"初始化环境\",{\"0\":{\"1145\":1}}],[\"初始化时不需要指明数组大小\",{\"1\":{\"1121\":1}}],[\"初始化时间为\",{\"1\":{\"870\":1}}],[\"初始化时间\",{\"1\":{\"869\":1}}],[\"初始化有两种\",{\"1\":{\"1069\":1}}],[\"初始化备忘录\",{\"1\":{\"827\":1}}],[\"初始化前缀树对象\",{\"1\":{\"801\":1}}],[\"初始化无穷大\",{\"1\":{\"796\":1,\"797\":1}}],[\"初始化当前字符串是否可以被分割\",{\"1\":{\"784\":1}}],[\"初始化框架规定在未登录情况下想操作其它页面\",{\"1\":{\"587\":1}}],[\"初始化项目\",{\"0\":{\"558\":1},\"1\":{\"538\":1}}],[\"初始化定时任务\",{\"1\":{\"480\":1}}],[\"初始化find\",{\"1\":{\"416\":1}}],[\"初始化各个顶点在不同的集合中\",{\"1\":{\"361\":1}}],[\"初始化大于1的区间为最大\",{\"1\":{\"307\":1}}],[\"初始化父亲为它自己\",{\"1\":{\"273\":1}}],[\"初始化为它自身\",{\"1\":{\"417\":1}}],[\"初始化为\",{\"1\":{\"255\":1}}],[\"初始化为一个较大的值\",{\"1\":{\"115\":1}}],[\"初始化输入数据\",{\"1\":{\"235\":1}}],[\"初始化岛屿数量为0\",{\"1\":{\"228\":1,\"229\":1}}],[\"初始化数组元素为\",{\"1\":{\"228\":1}}],[\"初始化小根堆\",{\"1\":{\"224\":1}}],[\"初始化左边界\",{\"1\":{\"173\":1}}],[\"初始化变量\",{\"0\":{\"1177\":1},\"1\":{\"146\":1}}],[\"初始化结果数组为\",{\"1\":{\"128\":1}}],[\"初始化一个缓存管理器\",{\"1\":{\"1211\":1}}],[\"初始化一个长度为\",{\"1\":{\"146\":1}}],[\"初始化一个结果数组\",{\"1\":{\"128\":1}}],[\"初始化一个空栈\",{\"1\":{\"93\":1}}],[\"初始化\",{\"0\":{\"269\":1,\"1156\":1,\"1157\":1,\"1158\":1},\"1\":{\"110\":1,\"115\":1,\"126\":2,\"127\":2,\"135\":1,\"142\":1,\"178\":1,\"215\":1,\"237\":1,\"261\":1,\"267\":1,\"274\":2,\"317\":1,\"345\":1,\"358\":1,\"403\":1,\"404\":1,\"414\":1,\"415\":1,\"416\":1,\"421\":1,\"555\":1,\"686\":1,\"772\":1,\"783\":1,\"802\":1,\"822\":1,\"840\":1,\"887\":1,\"1005\":1,\"1007\":1,\"1157\":1,\"1160\":1,\"1272\":1}}],[\"初始化全为\",{\"1\":{\"108\":1}}],[\"初始化dp数组\",{\"1\":{\"72\":1}}],[\"∀i∈\",{\"1\":{\"384\":1}}],[\"=1\",{\"1\":{\"383\":1}}],[\"​f\",{\"1\":{\"796\":1}}],[\"​j<i2j≥i2​\",{\"1\":{\"795\":1,\"796\":1}}],[\"​dfs\",{\"1\":{\"795\":1}}],[\"​b\",{\"1\":{\"621\":1}}],[\"​=\",{\"1\":{\"389\":1}}],[\"​=a\",{\"1\":{\"388\":1}}],[\"​\",{\"1\":{\"383\":2,\"388\":1,\"389\":1,\"985\":3}}],[\"​​\",{\"1\":{\"262\":1}}],[\"倍即\",{\"1\":{\"1274\":1}}],[\"倍代码为\",{\"1\":{\"1274\":1}}],[\"倍性能提升\",{\"1\":{\"621\":1}}],[\"倍增的思想\",{\"1\":{\"422\":1}}],[\"倍\",{\"1\":{\"380\":2,\"1274\":1}}],[\"倍区间的数目\",{\"1\":{\"261\":1}}],[\"倍区间吗\",{\"1\":{\"261\":1}}],[\"倍区间\",{\"1\":{\"261\":1}}],[\"修饰时\",{\"1\":{\"1471\":1}}],[\"修饰基本数据类型变量时\",{\"1\":{\"1467\":1}}],[\"修饰的用来改变同步状态的方法\",{\"1\":{\"1494\":1}}],[\"修饰的话就可以禁止\",{\"1\":{\"1485\":1}}],[\"修饰的数据类型分类\",{\"1\":{\"1476\":1}}],[\"修饰的对象的成员域读操作\",{\"1\":{\"1476\":1}}],[\"修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序\",{\"1\":{\"1476\":1}}],[\"修饰的对象的成员域的写入\",{\"1\":{\"1476\":1}}],[\"修饰的对象的成员域写操作\",{\"1\":{\"1476\":1}}],[\"修饰的成员变量\",{\"1\":{\"1472\":1}}],[\"修饰的方法需要由继承\",{\"1\":{\"1495\":1}}],[\"修饰的方法是可以重载的\",{\"1\":{\"1470\":1}}],[\"修饰的方法不能够被子类所重写\",{\"1\":{\"1469\":1}}],[\"修饰的方法\",{\"1\":{\"1469\":1,\"1496\":1}}],[\"修饰的时候\",{\"1\":{\"1469\":1}}],[\"修饰的引用数据类型变量\",{\"1\":{\"1467\":1}}],[\"修饰的是一个基本数据类型的数据\",{\"1\":{\"1467\":1}}],[\"修饰的是基本数据类型和引用类型有区别吗\",{\"1\":{\"1466\":1}}],[\"修饰的共享变量进行写操作的时候会多出\",{\"1\":{\"1454\":1}}],[\"修饰的变量\",{\"1\":{\"1475\":1}}],[\"修饰的变量能够保证每个线程能够获取该变量的最新值\",{\"1\":{\"1453\":1}}],[\"修饰的变量给\",{\"1\":{\"1453\":1}}],[\"修饰的也就是说继承\",{\"1\":{\"1302\":1}}],[\"修饰的\",{\"1\":{\"1294\":1,\"1472\":1}}],[\"修饰\",{\"1\":{\"1292\":1,\"1471\":2}}],[\"修饰方法实现的\",{\"1\":{\"1280\":1}}],[\"修饰其他注解的注解\",{\"1\":{\"1053\":1}}],[\"修饰符来修饰该类的成员变量\",{\"1\":{\"1472\":1}}],[\"修饰符修饰\",{\"1\":{\"1467\":1}}],[\"修饰符包括\",{\"1\":{\"1010\":1}}],[\"修饰符\",{\"1\":{\"1009\":1,\"1027\":1}}],[\"修正为\",{\"1\":{\"380\":2}}],[\"修改它的属性和一些操作\",{\"1\":{\"1268\":1}}],[\"修改语句的条件可以有\",{\"1\":{\"926\":1}}],[\"修改数据\",{\"1\":{\"924\":1}}],[\"修改数据类型\",{\"1\":{\"922\":1}}],[\"修改表名\",{\"1\":{\"922\":1}}],[\"修改表的时候添加约束\",{\"1\":{\"919\":1}}],[\"修改表\",{\"1\":{\"916\":1}}],[\"修改权限校验如下\",{\"1\":{\"592\":1}}],[\"修改后\",{\"1\":{\"1145\":1}}],[\"修改后的用户管理界面\",{\"1\":{\"592\":1}}],[\"修改后即可显示\",{\"1\":{\"591\":1}}],[\"修改后将页面中冗余的代码删除\",{\"1\":{\"587\":1}}],[\"修改注册逻辑\",{\"1\":{\"587\":1}}],[\"修改前端项目入口文件\",{\"1\":{\"587\":1}}],[\"修改页面全局布局文件\",{\"1\":{\"540\":1}}],[\"修改校验逻辑\",{\"1\":{\"526\":1}}],[\"修改\",{\"0\":{\"922\":1,\"926\":1},\"1\":{\"526\":1,\"539\":1,\"591\":1,\"664\":1,\"922\":1}}],[\"修改的本质包括添加和删除\",{\"1\":{\"526\":1}}],[\"修改题库响应封装类\",{\"1\":{\"523\":1}}],[\"修改题目所属题库接口\",{\"1\":{\"521\":1}}],[\"修改题目所属题库\",{\"0\":{\"526\":1},\"1\":{\"521\":1,\"526\":1}}],[\"修改题目所属题库等\",{\"1\":{\"496\":1,\"507\":1}}],[\"修改生成的\",{\"1\":{\"518\":1,\"519\":1}}],[\"修改任务\",{\"1\":{\"481\":6}}],[\"修改任意一个元素\",{\"1\":{\"417\":1}}],[\"修改定时任务\",{\"1\":{\"481\":1}}],[\"修改等操作\",{\"1\":{\"475\":1}}],[\"修改用户表更新登录信息\",{\"1\":{\"451\":1}}],[\"修改字符串的长度\",{\"1\":{\"243\":1}}],[\"修改为如下样式\",{\"1\":{\"540\":1}}],[\"修改为\",{\"1\":{\"122\":1}}],[\"互质时\",{\"1\":{\"388\":1}}],[\"互质\",{\"1\":{\"380\":1,\"388\":2}}],[\"互质的数的个数被称为欧拉函数\",{\"1\":{\"379\":1}}],[\"互质的充分必要条件是存在整数\",{\"1\":{\"248\":1,\"383\":1}}],[\"ϕ\",{\"1\":{\"379\":2}}],[\"辗转相除法时间可以忽略不计\",{\"1\":{\"377\":1}}],[\"辗转相除法\",{\"1\":{\"377\":1}}],[\"欧拉函数的定义\",{\"1\":{\"379\":1}}],[\"欧拉函数\",{\"0\":{\"378\":1}}],[\"欧拉筛\",{\"0\":{\"373\":1}}],[\"欧几里得算法\",{\"1\":{\"377\":1}}],[\"欧几里得公式\",{\"1\":{\"220\":1}}],[\"欧几里得距离是指两个节点之间的直线距离\",{\"1\":{\"220\":1}}],[\"欧几里得距离\",{\"0\":{\"220\":1},\"1\":{\"216\":1}}],[\"任务不能重新启动或取消\",{\"1\":{\"1375\":1}}],[\"任务结果\",{\"1\":{\"1371\":1}}],[\"任务会被转换成\",{\"1\":{\"1371\":1}}],[\"任务\",{\"1\":{\"1371\":2}}],[\"任务以及阻塞队列\",{\"1\":{\"1370\":1}}],[\"任务执行\",{\"1\":{\"1367\":1}}],[\"任务执行工具类\",{\"1\":{\"477\":1}}],[\"任务开始执行\",{\"1\":{\"1367\":1}}],[\"任务性质不同的任务可以用不同规模的线程池分开处理\",{\"1\":{\"1361\":1}}],[\"任务的执行机制\",{\"1\":{\"1371\":1}}],[\"任务的执行时间\",{\"1\":{\"1361\":1}}],[\"任务的依赖性\",{\"1\":{\"1361\":1}}],[\"任务的优先级\",{\"1\":{\"1361\":1}}],[\"任务的性质\",{\"1\":{\"1361\":1}}],[\"任务在初始化时是处于暂停状态的\",{\"1\":{\"482\":1}}],[\"任务组\",{\"1\":{\"476\":1}}],[\"任何对口的数据都能召之即来\",{\"1\":{\"438\":1}}],[\"任何热门的数据处理服务\",{\"1\":{\"438\":1}}],[\"任何一个\",{\"1\":{\"1248\":1}}],[\"任何一个文件都可以拥有一个外链\",{\"1\":{\"670\":1}}],[\"任何一个公平组合游戏都可以转化为有向图游戏\",{\"1\":{\"396\":1}}],[\"任何一个合数都能写成几个质数相乘的形式\",{\"1\":{\"371\":1}}],[\"任意线程对\",{\"1\":{\"1431\":1}}],[\"任意一个对象都拥有自己的监视器\",{\"1\":{\"1431\":1}}],[\"任意对象为\",{\"1\":{\"1305\":1}}],[\"任意步都可以\",{\"1\":{\"110\":1}}],[\"任意两边之和大于第三边\",{\"1\":{\"78\":1}}],[\"趋于无穷大时\",{\"1\":{\"371\":1}}],[\"调度器会先检查它是否具有比当前允许线程更高的优先级\",{\"1\":{\"1334\":1}}],[\"调度器仍然需要分配时间片\",{\"1\":{\"1331\":1}}],[\"调度一次\",{\"1\":{\"1158\":2}}],[\"调用方法enq\",{\"1\":{\"1504\":1}}],[\"调用模板方法\",{\"1\":{\"1495\":1}}],[\"调用这个对象的行为都可以获取正确的结果\",{\"1\":{\"1415\":1}}],[\"调用这两个方法的任意一个\",{\"1\":{\"1360\":1}}],[\"调用wait方法\",{\"1\":{\"1407\":4}}],[\"调用该方法的线程等到指定的\",{\"1\":{\"1392\":1}}],[\"调用该方法的线程等到构造方法传入的\",{\"1\":{\"1392\":1}}],[\"调用该方法后会使得当前线程所封装的\",{\"1\":{\"1251\":1}}],[\"调用对象的\",{\"1\":{\"1330\":1}}],[\"调用了\",{\"1\":{\"1305\":1,\"1407\":1}}],[\"调用构造器方法的时候并未构造出\",{\"1\":{\"1270\":1}}],[\"调用者不用管被调用方法是否完成\",{\"1\":{\"1223\":1}}],[\"调用者后面的代码才能执行\",{\"1\":{\"1223\":1}}],[\"调用者必须等待被调用的方法结束后\",{\"1\":{\"1223\":1}}],[\"调用的是\",{\"1\":{\"1151\":1}}],[\"调用相同的函数\",{\"1\":{\"1029\":1}}],[\"调用函数\",{\"0\":{\"1011\":1}}],[\"调用服务层的方法根据状态启动\",{\"1\":{\"482\":1}}],[\"调用类\",{\"1\":{\"477\":1}}],[\"调用执行\",{\"1\":{\"451\":1}}],[\"调用\",{\"1\":{\"448\":4,\"453\":2,\"459\":2,\"481\":3,\"576\":1,\"1165\":1,\"1250\":1,\"1251\":1,\"1252\":3,\"1259\":2,\"1272\":1,\"1368\":1,\"1375\":1,\"1392\":1,\"1394\":1,\"1404\":2,\"1406\":4,\"1503\":1,\"1504\":1}}],[\"调用关系复杂\",{\"1\":{\"25\":1}}],[\"调和级数\",{\"1\":{\"371\":1}}],[\"筛素数\",{\"1\":{\"390\":1}}],[\"筛法求出范围内的所有质数\",{\"1\":{\"390\":1}}],[\"筛法求欧拉函数\",{\"0\":{\"380\":1}}],[\"筛法求素数\",{\"0\":{\"370\":1}}],[\"筛掉它的倍数\",{\"1\":{\"371\":1}}],[\"埃氏筛\",{\"0\":{\"371\":1}}],[\"约束是作用于表中字段上的\",{\"1\":{\"919\":1}}],[\"约束的数据结构\",{\"1\":{\"686\":1}}],[\"约束\",{\"0\":{\"919\":1},\"1\":{\"664\":1,\"918\":3,\"919\":1,\"922\":2}}],[\"约为\",{\"1\":{\"613\":1}}],[\"约定在\",{\"1\":{\"543\":1}}],[\"约定式路由\",{\"0\":{\"542\":1},\"1\":{\"542\":1}}],[\"约数之和\",{\"1\":{\"376\":2}}],[\"约数个数\",{\"1\":{\"376\":1}}],[\"约数个数和约数之和\",{\"0\":{\"376\":1}}],[\"约数\",{\"0\":{\"374\":1}}],[\"约数枚举\",{\"1\":{\"369\":1}}],[\"约瑟夫环的变种问题\",{\"1\":{\"99\":1}}],[\"√n\",{\"1\":{\"369\":3}}],[\"素数测试\",{\"1\":{\"369\":1}}],[\"汇总起来对性能也会是大大的损耗\",{\"1\":{\"1286\":1}}],[\"汇总\",{\"0\":{\"369\":1}}],[\"汇总所有\",{\"1\":{\"61\":1}}],[\"质数定理\",{\"1\":{\"371\":1}}],[\"质数\",{\"0\":{\"366\":1},\"1\":{\"380\":1}}],[\"形参列表中的形参通常用逗号隔开\",{\"1\":{\"1013\":1}}],[\"形参和实参的类型和个数必须匹配\",{\"1\":{\"1012\":1}}],[\"形参和实参\",{\"0\":{\"1012\":1}}],[\"形成死锁\",{\"1\":{\"1221\":1}}],[\"形成\",{\"1\":{\"484\":1}}],[\"形成的路径叫交替路\",{\"1\":{\"363\":1}}],[\"形式化地讲\",{\"1\":{\"147\":1}}],[\"形式都更丰富\",{\"1\":{\"21\":1}}],[\"匈牙利算法中只会用到从第一个集合指向第二个集合的边\",{\"1\":{\"363\":1}}],[\"匈牙利算法\",{\"0\":{\"363\":1}}],[\"未优化前\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"未启动\",{\"1\":{\"1375\":1}}],[\"未查找到满足条件的entry\",{\"1\":{\"1307\":1}}],[\"未能及时向\",{\"1\":{\"1191\":1}}],[\"未匹配的左括号是不需要的\",{\"1\":{\"845\":1}}],[\"未过滤数据权限的情况\",{\"1\":{\"471\":1}}],[\"未确定阶梯型的行\",{\"1\":{\"385\":1}}],[\"未染色的点\",{\"1\":{\"362\":1}}],[\"未染色\",{\"1\":{\"362\":1}}],[\"未被删除\",{\"1\":{\"99\":1}}],[\"区别\",{\"1\":{\"933\":1}}],[\"区分度不大的字段没必要加索引\",{\"1\":{\"565\":1}}],[\"区分\",{\"1\":{\"362\":1}}],[\"区间不为空\",{\"1\":{\"852\":2}}],[\"区间覆盖\",{\"0\":{\"430\":1}}],[\"区间分组\",{\"0\":{\"429\":1}}],[\"区间选点\",{\"0\":{\"427\":1}}],[\"区间问题\",{\"0\":{\"426\":1}}],[\"区间筛法\",{\"0\":{\"372\":1}}],[\"区间合并\",{\"0\":{\"342\":1,\"431\":1}}],[\"区间终点\",{\"1\":{\"307\":1}}],[\"区间长度\",{\"1\":{\"307\":1}}],[\"区间长度最小是多少\",{\"1\":{\"174\":1}}],[\"区间dp枚举套路\",{\"1\":{\"307\":1}}],[\"区间dp\",{\"0\":{\"307\":1}}],[\"区间\",{\"1\":{\"254\":1,\"261\":1,\"307\":1,\"682\":1}}],[\"区间的最大值的下标\",{\"1\":{\"174\":1}}],[\"区间中选择一个数\",{\"1\":{\"174\":2}}],[\"换行\",{\"1\":{\"982\":2}}],[\"换句话说\",{\"1\":{\"794\":1,\"1045\":1,\"1319\":1}}],[\"换句话来说\",{\"1\":{\"359\":1}}],[\"换成\",{\"1\":{\"322\":1}}],[\"换成a\",{\"1\":{\"322\":1}}],[\"建完表后\",{\"1\":{\"937\":1}}],[\"建立第三张中间表\",{\"1\":{\"939\":1}}],[\"建立新节点\",{\"1\":{\"887\":1}}],[\"建立临时结点\",{\"1\":{\"833\":1}}],[\"建立右子树\",{\"1\":{\"767\":1}}],[\"建立左子树\",{\"1\":{\"767\":1}}],[\"建立根节点\",{\"1\":{\"767\":1}}],[\"建立一个队列\",{\"1\":{\"355\":1}}],[\"建议使用\",{\"1\":{\"1075\":1}}],[\"建议放在\",{\"1\":{\"672\":1}}],[\"建议同时指定\",{\"1\":{\"243\":1}}],[\"建表语句\",{\"1\":{\"566\":1}}],[\"建堆\",{\"1\":{\"417\":1}}],[\"号称是目前速度最快的对象存储服务器\",{\"1\":{\"1095\":1}}],[\"号点的判断中需要进行\",{\"1\":{\"354\":1}}],[\"号颜色\",{\"1\":{\"157\":3}}],[\"松弛操作\",{\"1\":{\"354\":2}}],[\"稀疏图改用\",{\"1\":{\"353\":1}}],[\"稀疏图用邻接表\",{\"1\":{\"352\":1}}],[\"寻找标记与标记之间的最大长度\",{\"1\":{\"845\":1}}],[\"寻找下一个字符\",{\"1\":{\"802\":1}}],[\"寻找距离最小的点\",{\"1\":{\"352\":1}}],[\"寻找两点之间的最大距离\",{\"1\":{\"345\":1}}],[\"访问静态变量最好通过类名\",{\"1\":{\"1027\":1}}],[\"访问string中的字符\",{\"1\":{\"1005\":1}}],[\"访问数组元素\",{\"0\":{\"999\":1}}],[\"访问所指定相对根目录下的目录及文件\",{\"1\":{\"675\":1}}],[\"访问不了再用代理线路\",{\"1\":{\"665\":1}}],[\"访问国外的一些优秀网站速度会很慢\",{\"1\":{\"661\":1}}],[\"访问\",{\"1\":{\"592\":1,\"670\":1,\"1095\":1}}],[\"访问加入集合并标记\",{\"1\":{\"352\":1}}],[\"访问标记\",{\"1\":{\"314\":1}}],[\"稠密图用邻接矩阵\",{\"1\":{\"352\":1}}],[\"堆结构在执行插入和删除操作时的最坏时间复杂度是\",{\"1\":{\"1369\":1}}],[\"堆是一棵\",{\"1\":{\"417\":1}}],[\"堆\",{\"0\":{\"417\":1}}],[\"堆优化版的dijkstra算法\",{\"0\":{\"353\":1},\"1\":{\"351\":1}}],[\"堆排序只能保证根是最大\",{\"1\":{\"1078\":1}}],[\"堆排\",{\"1\":{\"223\":1}}],[\"宽度优先遍历\",{\"0\":{\"348\":1}}],[\"邻接表建图\",{\"1\":{\"876\":1}}],[\"邻接表存储图\",{\"1\":{\"362\":1}}],[\"邻接表存储所有边\",{\"1\":{\"353\":1,\"355\":1,\"356\":1,\"363\":1}}],[\"邻接表\",{\"1\":{\"345\":1,\"353\":1,\"403\":1}}],[\"邻接矩阵初始化为无穷大\",{\"1\":{\"352\":1}}],[\"邻接矩阵\",{\"1\":{\"345\":1,\"360\":1}}],[\"正如前面所言\",{\"1\":{\"1420\":1}}],[\"正在执行占有锁而其他thread\",{\"1\":{\"1496\":1}}],[\"正在消费数据\",{\"1\":{\"1411\":1}}],[\"正在全力冲刺\",{\"1\":{\"1392\":1}}],[\"正在调用\",{\"1\":{\"1326\":2}}],[\"正在进行扩容操作\",{\"1\":{\"1272\":1}}],[\"正在进行初始化的线程会调用\",{\"1\":{\"1271\":1}}],[\"正在等待被\",{\"1\":{\"1221\":1}}],[\"正是因为这些优点\",{\"1\":{\"1218\":1}}],[\"正是在畅想未来的时候\",{\"1\":{\"1218\":1}}],[\"正确同步的多线程程序是按\",{\"1\":{\"1420\":1}}],[\"正确\",{\"1\":{\"1012\":1,\"1013\":1}}],[\"正数表示大于\",{\"1\":{\"1005\":1}}],[\"正数左补\",{\"1\":{\"338\":1}}],[\"正整数\",{\"1\":{\"686\":1}}],[\"正向代理需要客户端进行配置\",{\"1\":{\"586\":1}}],[\"正向代理主要用于客户端的访问控制和匿名性\",{\"1\":{\"586\":1}}],[\"正向代理靠近客户端\",{\"1\":{\"586\":1}}],[\"正向代理\",{\"1\":{\"586\":1}}],[\"正常来说\",{\"1\":{\"663\":1}}],[\"正常\",{\"1\":{\"566\":3,\"575\":1,\"592\":1}}],[\"正则匹配\",{\"0\":{\"201\":1}}],[\"才表示线程池成功关闭\",{\"1\":{\"1360\":1}}],[\"才需要获取注册表信息\",{\"1\":{\"1158\":1}}],[\"才可以使用\",{\"1\":{\"978\":1}}],[\"才更有机会去扩展\",{\"1\":{\"852\":1}}],[\"才会离开等待池\",{\"1\":{\"1338\":1}}],[\"才会继续执行\",{\"1\":{\"1337\":1}}],[\"才会处理之前找到的节点\",{\"1\":{\"731\":1}}],[\"才会被识别为路由\",{\"1\":{\"542\":1}}],[\"才会进行处理\",{\"1\":{\"471\":1}}],[\"才为\",{\"1\":{\"338\":1}}],[\"才为1\",{\"1\":{\"338\":1}}],[\"才能拿到笔去填写表格\",{\"1\":{\"1398\":1}}],[\"才能往下执行\",{\"1\":{\"1393\":1}}],[\"才能继续往下继续执行\",{\"1\":{\"1393\":1}}],[\"才能继续往下执行\",{\"1\":{\"1392\":3,\"1393\":1,\"1394\":1}}],[\"才能注册到\",{\"1\":{\"1186\":1}}],[\"才能正常运行\",{\"1\":{\"1132\":1}}],[\"才能够确保队列元素整体有序\",{\"1\":{\"1078\":1}}],[\"才能够成功跳转\",{\"1\":{\"589\":1}}],[\"才能生效\",{\"1\":{\"465\":1}}],[\"才能使得公路被种上至少\",{\"1\":{\"173\":1}}],[\"才能\",{\"1\":{\"58\":1}}],[\"才能设计出一个全面的架构\",{\"1\":{\"45\":1}}],[\"才能做出最佳的设计和抽象\",{\"1\":{\"45\":1}}],[\"算术右移\",{\"1\":{\"337\":1}}],[\"算法设计的再合理\",{\"1\":{\"1272\":1}}],[\"算法来保障线程安全的操作\",{\"1\":{\"1268\":1}}],[\"算法保证了线程安全性\",{\"1\":{\"1266\":1}}],[\"算法保证一定能够找到最短路径\",{\"1\":{\"216\":1}}],[\"算法实现\",{\"1\":{\"1202\":1}}],[\"算法步骤\",{\"1\":{\"385\":1}}],[\"算法描述\",{\"1\":{\"363\":1}}],[\"算法描述如下\",{\"1\":{\"215\":1}}],[\"算法思路\",{\"1\":{\"320\":1}}],[\"算法和求最近公共祖先\",{\"1\":{\"267\":1}}],[\"算法不断回溯来解决迷宫问题\",{\"1\":{\"234\":1}}],[\"算法不能保证找到最短路径\",{\"1\":{\"216\":1}}],[\"算法条件\",{\"1\":{\"221\":1}}],[\"算法比较灵活的地方\",{\"1\":{\"216\":1}}],[\"算法将找到最佳路径\",{\"1\":{\"216\":1}}],[\"算法将遍历越多的节点\",{\"1\":{\"216\":1}}],[\"算法将和广度优先算法变得一样\",{\"1\":{\"213\":1}}],[\"算法的行为\",{\"1\":{\"216\":1}}],[\"算法的启发函数\",{\"1\":{\"215\":1}}],[\"算法结束后\",{\"1\":{\"358\":1}}],[\"算法结束\",{\"1\":{\"215\":1}}],[\"算法使用两个集合来表示待遍历的节点\",{\"1\":{\"215\":1}}],[\"算法在运算过程中\",{\"1\":{\"215\":1}}],[\"算法通过下面这个函数来计算每个节点的优先级\",{\"1\":{\"215\":1}}],[\"算法类似\",{\"1\":{\"214\":1}}],[\"算法中\",{\"1\":{\"213\":1}}],[\"算法用来寻找图形中节点之间的最短路径\",{\"1\":{\"213\":1}}],[\"算法是一种很常用的路径查找和图形遍历算法\",{\"1\":{\"210\":1}}],[\"算法\",{\"0\":{\"209\":1,\"213\":1,\"361\":1},\"1\":{\"214\":1,\"216\":1,\"221\":1,\"351\":2}}],[\"算法题\",{\"0\":{\"152\":1}}],[\"算法笔记\",{\"0\":{\"2\":1}}],[\"÷\",{\"1\":{\"330\":2}}],[\"逐层遍历\",{\"1\":{\"742\":1}}],[\"逐出\",{\"1\":{\"686\":1}}],[\"逐个遍历\",{\"1\":{\"352\":1}}],[\"逐位压入数组中\",{\"1\":{\"329\":1}}],[\"逐步的向外扩散\",{\"1\":{\"212\":1}}],[\"低成本长久保存\",{\"1\":{\"438\":1}}],[\"低精\",{\"1\":{\"329\":1,\"330\":1}}],[\"低位补0\",{\"1\":{\"337\":1}}],[\"低位变为0\",{\"1\":{\"327\":1}}],[\"低位满10向高位进位\",{\"1\":{\"327\":1}}],[\"压入元素\",{\"1\":{\"1037\":1}}],[\"压入c数组中\",{\"1\":{\"327\":1}}],[\"压缩路径\",{\"1\":{\"273\":1,\"274\":1}}],[\"压缩后的结果为\",{\"1\":{\"82\":1}}],[\"检测上一个任务是否执行完毕\",{\"1\":{\"1367\":1}}],[\"检测是否进行扩容\",{\"1\":{\"1275\":1}}],[\"检索元素时\",{\"1\":{\"971\":1}}],[\"检索速度就会降低\",{\"1\":{\"958\":1}}],[\"检查占有线程是否是当前线程\",{\"1\":{\"1232\":1}}],[\"检查型异常必须被捕获或者抛出\",{\"1\":{\"1048\":1}}],[\"检查性异常\",{\"1\":{\"1045\":1}}],[\"检查它是否轴对称\",{\"1\":{\"807\":1}}],[\"检查x是否满足某种性质\",{\"1\":{\"325\":1}}],[\"检验\",{\"1\":{\"186\":1}}],[\"需求\",{\"1\":{\"523\":1,\"525\":1,\"526\":1}}],[\"需求分析\",{\"0\":{\"506\":1,\"556\":1},\"1\":{\"555\":1}}],[\"需开发\",{\"1\":{\"521\":3}}],[\"需使用头文件\",{\"1\":{\"324\":1}}],[\"需要等待全局安全点\",{\"1\":{\"1443\":1}}],[\"需要重设下一次执行任务的时间\",{\"1\":{\"1368\":1}}],[\"需要使用线程池来管理线程\",{\"1\":{\"1357\":1}}],[\"需要使用事务实现\",{\"1\":{\"526\":1}}],[\"需要经过需求分析师进行需求分解后\",{\"1\":{\"1337\":1}}],[\"需要通过\",{\"1\":{\"1307\":1,\"1398\":1}}],[\"需要注意这么几点\",{\"1\":{\"1294\":1}}],[\"需要注意的是如果一直有优先级高的任务提交到队列里\",{\"1\":{\"1361\":1}}],[\"需要注意的是如果当前线程获得了锁\",{\"1\":{\"1338\":1}}],[\"需要注意的是在不同\",{\"1\":{\"1339\":1}}],[\"需要注意的是\",{\"1\":{\"1232\":1,\"1242\":1,\"1250\":1,\"1270\":1,\"1305\":1,\"1306\":1,\"1339\":1,\"1359\":1,\"1392\":1,\"1457\":1,\"1492\":1}}],[\"需要依次向后遍历确定这个新加入的值所在位置\",{\"1\":{\"1272\":1}}],[\"需要依赖\",{\"1\":{\"1132\":1}}],[\"需要频繁的上下文切换\",{\"1\":{\"1233\":1}}],[\"需要拆分\",{\"1\":{\"1218\":1}}],[\"需要操作数据库\",{\"1\":{\"1132\":1}}],[\"需要加上\",{\"1\":{\"1113\":1}}],[\"需要先进行了解\",{\"1\":{\"1265\":1}}],[\"需要先定义好排序规则\",{\"1\":{\"1078\":1}}],[\"需要先完成​课程\",{\"1\":{\"875\":1}}],[\"需要用到\",{\"1\":{\"1074\":1}}],[\"需要用多重背包的二进制优化方法\",{\"1\":{\"298\":1}}],[\"需要手动刷新缓冲区\",{\"1\":{\"982\":1}}],[\"需要适时调整\",{\"1\":{\"973\":1}}],[\"需要将数据保存在数据库中\",{\"1\":{\"1398\":1}}],[\"需要将其注册为\",{\"1\":{\"1090\":1}}],[\"需要将多次访问数据库的操作视为一个整体来执行\",{\"1\":{\"953\":1}}],[\"需要将这个元素变为最近使用的\",{\"1\":{\"687\":1}}],[\"需要消除无效的笛卡尔积\",{\"1\":{\"942\":1}}],[\"需要检查外键关系\",{\"1\":{\"937\":1}}],[\"需要检索的数据维度比较多\",{\"1\":{\"50\":1}}],[\"需要指定存储桶名称和对象键\",{\"1\":{\"1103\":1}}],[\"需要指定存储桶的名称\",{\"1\":{\"1102\":1}}],[\"需要指定长度\",{\"1\":{\"920\":2}}],[\"需要指出的是\",{\"1\":{\"40\":1}}],[\"需要遍历整棵树\",{\"1\":{\"901\":1}}],[\"需要把上界\",{\"1\":{\"899\":1}}],[\"需要开辟额外空间写法\",{\"1\":{\"852\":1}}],[\"需要开启防火墙\",{\"1\":{\"663\":1}}],[\"需要确定三个问题\",{\"1\":{\"851\":1}}],[\"需要知道上一个选的数字\",{\"1\":{\"851\":1}}],[\"需要看其前面对元素来判断是否有有效括号对\",{\"1\":{\"846\":1}}],[\"需要单独创建\",{\"1\":{\"675\":1}}],[\"需要删除同级目录下的\",{\"1\":{\"670\":1}}],[\"需要展示图片\",{\"1\":{\"668\":1}}],[\"需要对\",{\"1\":{\"1274\":1}}],[\"需要对多少个元素进行存储\",{\"1\":{\"613\":1}}],[\"需要对非核心依赖的\",{\"1\":{\"51\":1}}],[\"需要判断用户的用户名是否重复\",{\"1\":{\"613\":1}}],[\"需要在\",{\"1\":{\"1492\":1}}],[\"需要在路劲为\",{\"1\":{\"559\":1}}],[\"需要在项目中安装对应的\",{\"1\":{\"540\":1}}],[\"需要在服务器端和客户端进行不同的处理和逻辑\",{\"1\":{\"533\":1}}],[\"需要服务器进行更多的计算和处理\",{\"1\":{\"533\":1}}],[\"需要综合考虑需求和限制\",{\"1\":{\"532\":1,\"533\":1}}],[\"需要客户端浏览器支持\",{\"1\":{\"532\":1}}],[\"需要结合具体的业务\",{\"1\":{\"517\":1}}],[\"需要保存当前的状态起来\",{\"1\":{\"1220\":1}}],[\"需要保留前端需要的字段\",{\"1\":{\"517\":1}}],[\"需要保证头结点存在\",{\"1\":{\"403\":1}}],[\"需要编写数据模型包装类\",{\"1\":{\"517\":1}}],[\"需要业务代码来更新\",{\"1\":{\"510\":1}}],[\"需要触发\",{\"1\":{\"484\":1}}],[\"需要实时或近实时的处理能力\",{\"1\":{\"434\":1}}],[\"需要实现点赞率的近实时计算\",{\"1\":{\"40\":1}}],[\"需要借位\",{\"1\":{\"328\":1}}],[\"需要减去序列头以转换为下标\",{\"1\":{\"256\":1}}],[\"需要考虑回溯的问题\",{\"1\":{\"235\":1}}],[\"需要计算每一个节点距离起点的总移动代价\",{\"1\":{\"213\":1}}],[\"需要达到终点\",{\"1\":{\"142\":1}}],[\"需要支持添加玩家\",{\"1\":{\"129\":1}}],[\"需要支持较丰富的数据结构\",{\"1\":{\"40\":1}}],[\"需要\",{\"1\":{\"119\":1,\"205\":1}}],[\"需要找到所有可能的组合方式\",{\"1\":{\"135\":1}}],[\"需要找到从起点到中电的路径\",{\"1\":{\"110\":1}}],[\"需要找到不在进行任何修改的情况下\",{\"1\":{\"66\":1}}],[\"需要设计一个算法来返回这两个日程区间列表的交集\",{\"1\":{\"70\":1}}],[\"需要回放录入到\",{\"1\":{\"50\":1}}],[\"需要处理页面闪动的情况\",{\"1\":{\"540\":1}}],[\"需要处理用户的广告点击数据\",{\"1\":{\"151\":1}}],[\"需要处理不同决策的优先级pk\",{\"1\":{\"40\":1}}],[\"需要处理各种细分场景下的差异化需求\",{\"1\":{\"40\":1}}],[\"需要多减去该一级评论的回复数\",{\"1\":{\"30\":1}}],[\"需要级联更新所有的父评论的回复数\",{\"1\":{\"30\":1}}],[\"需要为多个不同的查询场景建立多种索引分片\",{\"1\":{\"26\":1}}],[\"划分根节点\",{\"1\":{\"767\":1}}],[\"划分左子树范围\",{\"1\":{\"766\":1}}],[\"划分为\",{\"1\":{\"766\":2}}],[\"划分为两个非空子字符串的可行方案\",{\"1\":{\"71\":1}}],[\"划分成\",{\"1\":{\"321\":1,\"322\":1}}],[\"确认密码不能为空\",{\"1\":{\"587\":1}}],[\"确认环境\",{\"0\":{\"537\":1}}],[\"确定遍历中的索引i\",{\"1\":{\"1274\":1}}],[\"确定遍历顺序\",{\"1\":{\"772\":1}}],[\"确定好数组的索引\",{\"1\":{\"1272\":1}}],[\"确定在散列数组中的位置\",{\"1\":{\"1307\":1}}],[\"确定在\",{\"1\":{\"1272\":1}}],[\"确定递推公式\",{\"1\":{\"772\":1}}],[\"确定根节点再中序遍历中的位置\",{\"1\":{\"766\":1}}],[\"确定后就会自动开始代理服务了\",{\"1\":{\"665\":1}}],[\"确定优先级的需求列表如下\",{\"1\":{\"506\":1}}],[\"确定中间分界点\",{\"1\":{\"318\":1}}],[\"确定分界点\",{\"1\":{\"317\":1,\"318\":1,\"833\":1}}],[\"确保main线程结束前能给daemonthread能够分到时间片\",{\"1\":{\"1340\":1}}],[\"确保他们只能触及自己部门的信息\",{\"1\":{\"470\":1}}],[\"确保信息安全\",{\"1\":{\"470\":1}}],[\"确保用户只能访问他们被授权查看的数据\",{\"1\":{\"470\":1}}],[\"确保同一数据不会被重复处理\",{\"1\":{\"151\":1}}],[\"确保同一点击数据不会被重复处理\",{\"1\":{\"151\":1}}],[\"确保数据的真实性和可信度\",{\"1\":{\"434\":1}}],[\"确保数据的持久性和高可用性\",{\"1\":{\"151\":1}}],[\"确保数据的准确性\",{\"1\":{\"151\":1}}],[\"确保点击数据能够实时高效地被处理\",{\"1\":{\"151\":1}}],[\"快慢指针找到中间结点\",{\"1\":{\"834\":1}}],[\"快慢指针\",{\"1\":{\"777\":1}}],[\"快捷签发\",{\"1\":{\"672\":1}}],[\"快捷的设置字段\",{\"1\":{\"599\":1}}],[\"快速集成快速集成使用\",{\"1\":{\"1095\":1}}],[\"快速集成项目\",{\"1\":{\"557\":1}}],[\"快速部署\",{\"1\":{\"670\":1}}],[\"快速判断该用户名是否已经被使用了\",{\"1\":{\"613\":1}}],[\"快速判断某个元素是否在集合中出现了\",{\"1\":{\"613\":1}}],[\"快速启动\",{\"1\":{\"557\":1}}],[\"快速实现包含导航栏\",{\"1\":{\"548\":1}}],[\"快速幂模板\",{\"1\":{\"388\":1,\"389\":1}}],[\"快速幂求逆元\",{\"1\":{\"388\":1}}],[\"快速幂\",{\"0\":{\"381\":1}}],[\"快速排序\",{\"0\":{\"317\":1}}],[\"快排这一步不需要操作\",{\"1\":{\"317\":1}}],[\"快排的一般写法如下\",{\"1\":{\"317\":1}}],[\"快排属于分治算法\",{\"1\":{\"317\":1}}],[\"走进京东零售广告研发部\",{\"1\":{\"636\":1}}],[\"走交替路\",{\"1\":{\"363\":1}}],[\"走过的所有点的情况是\",{\"1\":{\"312\":1}}],[\"走到第\",{\"1\":{\"1284\":1}}],[\"走到\",{\"1\":{\"110\":1,\"312\":1}}],[\"蒙德里安的梦想\",{\"0\":{\"311\":1}}],[\"循环的条件时\",{\"1\":{\"1407\":2}}],[\"循环即可\",{\"1\":{\"1407\":1}}],[\"循环栅栏\",{\"0\":{\"1393\":1}}],[\"循环后向环形查找中是否找到可覆盖的\",{\"1\":{\"1317\":1}}],[\"循环后就会调用\",{\"1\":{\"1251\":1}}],[\"循环次数\",{\"1\":{\"1315\":1}}],[\"循环中对条件进行判断\",{\"1\":{\"1408\":1}}],[\"循环中调用\",{\"1\":{\"1407\":1}}],[\"循环中进行后向环形查找\",{\"1\":{\"1317\":4}}],[\"循环中寻找和当前\",{\"1\":{\"1306\":1}}],[\"循环中不断重试直至成功\",{\"1\":{\"1283\":1}}],[\"循环中的逻辑判断为\",{\"1\":{\"1251\":1}}],[\"循环中\",{\"1\":{\"1251\":1}}],[\"循环体中只有一条语句时\",{\"1\":{\"990\":1}}],[\"循环不常用\",{\"1\":{\"989\":1}}],[\"循环不变量\",{\"1\":{\"852\":2}}],[\"循环永久执行\",{\"1\":{\"988\":1}}],[\"循环语句\",{\"0\":{\"987\":1}}],[\"循环迭代遍历变成\",{\"1\":{\"887\":1}}],[\"循环将所有节点都作为起点调用一次\",{\"1\":{\"875\":1}}],[\"循环直到堆为空\",{\"1\":{\"789\":1}}],[\"循环出口\",{\"1\":{\"430\":1}}],[\"循环\",{\"0\":{\"988\":1,\"989\":1,\"990\":1},\"1\":{\"354\":2,\"1251\":3,\"1283\":1,\"1337\":1,\"1406\":2,\"1407\":1}}],[\"循环变量i可以表示剩下的数字有多少个\",{\"1\":{\"309\":1}}],[\"循环从1开始\",{\"1\":{\"309\":1}}],[\"循环周期\",{\"1\":{\"139\":1}}],[\"朴素并查集\",{\"0\":{\"414\":1}}],[\"朴素筛法\",{\"0\":{\"371\":1}}],[\"朴素prim算法\",{\"0\":{\"360\":1}}],[\"朴素版\",{\"0\":{\"352\":1}}],[\"朴素版的dijkstra算法\",{\"1\":{\"351\":1}}],[\"朴素做法\",{\"1\":{\"308\":1}}],[\"朴素dp写法\",{\"1\":{\"302\":1}}],[\"奶牛半懂不懂\",{\"1\":{\"304\":1}}],[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目\",{\"1\":{\"304\":1}}],[\"替服务器统一接收请求\",{\"1\":{\"586\":1}}],[\"替客户端向服务器发送请求\",{\"1\":{\"586\":1}}],[\"替换回到对象头\",{\"1\":{\"1447\":1}}],[\"替换占位符\",{\"1\":{\"1069\":1}}],[\"替换字符串\",{\"1\":{\"1005\":1}}],[\"替换字符\",{\"1\":{\"1005\":1}}],[\"替换为指向锁记录的指针\",{\"1\":{\"1446\":1}}],[\"替换为\",{\"1\":{\"538\":1}}],[\"替换\",{\"1\":{\"306\":1}}],[\"替换掉第一个大于或等于这个数字的那个数\",{\"1\":{\"302\":1}}],[\"替代\",{\"1\":{\"168\":1}}],[\"线程阻塞等待\",{\"1\":{\"1508\":1}}],[\"线程被中断抛出被中断异常\",{\"1\":{\"1508\":1}}],[\"线程被封装成\",{\"1\":{\"1506\":1}}],[\"线程被唤醒执行后续操作\",{\"1\":{\"1260\":1}}],[\"线程进入等待状态等待获取独占式锁\",{\"1\":{\"1504\":1}}],[\"线程进入到\",{\"1\":{\"1334\":2}}],[\"线程排队等底层实现\",{\"1\":{\"1496\":1}}],[\"线程线程\",{\"1\":{\"1476\":1}}],[\"线程线程转换图如上图所示\",{\"1\":{\"1334\":1}}],[\"线程中断抛异常\",{\"1\":{\"1507\":1}}],[\"线程中将\",{\"1\":{\"1458\":1}}],[\"线程中本地内存中共享变量就会置为失效的状态\",{\"1\":{\"1456\":1}}],[\"线程对\",{\"1\":{\"1453\":1}}],[\"线程对其他线程进行\",{\"1\":{\"1392\":1}}],[\"线程做累加操作有可能是使用原来的就值\",{\"1\":{\"1449\":1}}],[\"线程累加后\",{\"1\":{\"1449\":1}}],[\"线程不需要再次获取同一把锁\",{\"1\":{\"1431\":1}}],[\"线程运行时拥有自己的栈空间\",{\"1\":{\"1429\":1}}],[\"线程运行结束后\",{\"1\":{\"1334\":1}}],[\"线程之间主要通过读\",{\"1\":{\"1416\":1}}],[\"线程之间如何完成同步\",{\"1\":{\"1416\":1}}],[\"线程之间如何通信\",{\"1\":{\"1416\":1}}],[\"线程间协作通信可以类比人与人之间的协作的方式\",{\"1\":{\"1416\":1}}],[\"线程间交换数据的工具\",{\"0\":{\"1399\":1}}],[\"线程通信\",{\"0\":{\"1416\":1}}],[\"线程通过调用\",{\"1\":{\"1392\":1}}],[\"线程便会继续等待\",{\"1\":{\"1407\":1}}],[\"线程处于\",{\"1\":{\"1407\":1}}],[\"线程也必须要获得该对象的对象级别锁\",{\"1\":{\"1404\":1}}],[\"线程并未获取到锁的话\",{\"1\":{\"1404\":1}}],[\"线程并不是一直在执行任务\",{\"1\":{\"1361\":1}}],[\"线程必须要获得该对象的对象监视器锁\",{\"1\":{\"1404\":1}}],[\"线程必定相互影响\",{\"1\":{\"1283\":1}}],[\"线程需要先通过\",{\"1\":{\"1398\":1}}],[\"线程获取锁是一个自旋的过程\",{\"1\":{\"1506\":1}}],[\"线程获取锁是一种悲观锁策略\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"线程获取锁失败\",{\"1\":{\"1506\":1,\"1507\":1}}],[\"线程获取到锁\",{\"1\":{\"1254\":1}}],[\"线程获取到锁之后更改条件\",{\"1\":{\"1254\":1}}],[\"线程获取到\",{\"1\":{\"1251\":1}}],[\"线程从阻塞队列中不断获取新的异步任务\",{\"1\":{\"1371\":1}}],[\"线程主要是任务的执行者\",{\"1\":{\"1368\":1}}],[\"线程是稀缺资源\",{\"1\":{\"1357\":1}}],[\"线程是很占用系统资源的\",{\"1\":{\"1357\":1}}],[\"线程是会在不同的状态间进行转换的\",{\"1\":{\"1334\":1}}],[\"线程池无论是\",{\"1\":{\"1371\":1}}],[\"线程池主要负责创建线程\",{\"1\":{\"1371\":1}}],[\"线程池最大作用是将任务和线程进行解耦\",{\"1\":{\"1368\":1}}],[\"线程池允许最大的线程个数为\",{\"1\":{\"1366\":1}}],[\"线程池之\",{\"0\":{\"1364\":1}}],[\"线程池执行逻辑\",{\"1\":{\"1359\":1}}],[\"线程池执行所提交的任务过程主要有这样几个阶段\",{\"1\":{\"1358\":1}}],[\"线程池创建的时候所有的核心线程都会被创建并且启动\",{\"1\":{\"1359\":1}}],[\"线程池的关闭\",{\"0\":{\"1360\":1}}],[\"线程池的设计思想就是使用了\",{\"1\":{\"1359\":1}}],[\"线程池的创建\",{\"0\":{\"1359\":1}}],[\"线程池的工作原理\",{\"0\":{\"1358\":1}}],[\"线程池分配线程去执行任务的过程如下图所示\",{\"1\":{\"1358\":1}}],[\"线程池\",{\"0\":{\"1356\":1},\"1\":{\"1359\":1}}],[\"线程可以通过\",{\"1\":{\"1340\":1}}],[\"线程先睡眠\",{\"1\":{\"1340\":1}}],[\"线程结束后\",{\"1\":{\"1340\":2}}],[\"线程规划存在差异\",{\"1\":{\"1339\":1}}],[\"线程分配到的时间多少也就决定了线程使用处理器资源的多少\",{\"1\":{\"1339\":1}}],[\"线程优先级\",{\"1\":{\"1339\":1}}],[\"线程终止后\",{\"1\":{\"1337\":1}}],[\"线程才启动\",{\"1\":{\"1406\":1}}],[\"线程才结束终止\",{\"1\":{\"1370\":1}}],[\"线程才会继续往下执行\",{\"1\":{\"1336\":1}}],[\"线程才能删除数据\",{\"1\":{\"1326\":1}}],[\"线程切换到的是\",{\"1\":{\"1334\":1}}],[\"线程创建之后调用\",{\"1\":{\"1334\":1}}],[\"线程状态变为\",{\"1\":{\"1431\":1}}],[\"线程状态转换\",{\"0\":{\"1334\":1}}],[\"线程状态及其属性\",{\"0\":{\"1329\":1}}],[\"线程自然终于\",{\"1\":{\"1333\":1}}],[\"线程调度的细节依赖于操作系统提供的服务\",{\"1\":{\"1331\":1}}],[\"线程调用\",{\"1\":{\"1260\":1}}],[\"线程就不会出现阻塞停顿的状态\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"线程就可以理解守护线程\",{\"1\":{\"1340\":1}}],[\"线程就处于可运行状态\",{\"1\":{\"1331\":1}}],[\"线程就会出现\",{\"1\":{\"1283\":1}}],[\"线程的后继节点\",{\"1\":{\"1501\":1}}],[\"线程的前驱节点\",{\"1\":{\"1501\":1}}],[\"线程的排队\",{\"1\":{\"1494\":1,\"1495\":1}}],[\"线程的读操作\",{\"1\":{\"1420\":1}}],[\"线程的写操作\",{\"1\":{\"1420\":1}}],[\"线程的使用\",{\"1\":{\"1340\":1}}],[\"线程的基本操作\",{\"0\":{\"1335\":1}}],[\"线程的\",{\"1\":{\"1329\":1,\"1421\":1}}],[\"线程的信息\",{\"1\":{\"1259\":1}}],[\"线程会分配到若干时间片\",{\"1\":{\"1339\":1}}],[\"线程会切换到\",{\"1\":{\"1334\":1}}],[\"线程会由于以下两个原因之一而终止\",{\"1\":{\"1333\":1}}],[\"线程会被阻塞直至条件满足\",{\"1\":{\"1326\":1}}],[\"线程会进入到\",{\"1\":{\"1259\":1,\"1334\":1}}],[\"线程为了复用是不会主动结束的\",{\"1\":{\"1305\":1}}],[\"线程插入一个节点使得队列变为非空队列\",{\"1\":{\"1283\":1}}],[\"线程准备删除的节点为\",{\"1\":{\"1283\":1}}],[\"线程已经将\",{\"1\":{\"1283\":1}}],[\"线程在工作内存进行操作后何时会写到主内存中\",{\"1\":{\"1453\":1}}],[\"线程在执行同步块之前\",{\"1\":{\"1446\":1}}],[\"线程在\",{\"1\":{\"1283\":1,\"1392\":1}}],[\"线程同时操作的节点为\",{\"1\":{\"1283\":1}}],[\"线程两者并无\",{\"1\":{\"1283\":1}}],[\"线程和\",{\"1\":{\"1283\":4}}],[\"线程睡眠\",{\"1\":{\"1260\":1}}],[\"线程时都会有阻塞对象的描述\",{\"1\":{\"1259\":1}}],[\"线程信息可以看出\",{\"1\":{\"1259\":1}}],[\"线程更改了条件此时相对于\",{\"1\":{\"1254\":1}}],[\"线程开始执行的时候由于条件不满足\",{\"1\":{\"1254\":1}}],[\"线程安全问题的核心在于多个线程会对同一个临界区共享资源进行操作\",{\"1\":{\"1299\":1}}],[\"线程安全的方式\",{\"1\":{\"1280\":1}}],[\"线程安全\",{\"0\":{\"1221\":1}}],[\"线程来执行的\",{\"1\":{\"1158\":2}}],[\"线程\",{\"1\":{\"1145\":3,\"1253\":1,\"1259\":2,\"1260\":1,\"1276\":2,\"1283\":2,\"1284\":2,\"1285\":4,\"1330\":1,\"1392\":1,\"1393\":1,\"1407\":1,\"1417\":4,\"1432\":3,\"1433\":4,\"1443\":1,\"1456\":3,\"1458\":1,\"1475\":4,\"1476\":1,\"1485\":1,\"1504\":1}}],[\"线程没有处于请求操作所要求的适当状态时抛出的异常\",{\"1\":{\"1045\":1}}],[\"线上部署\",{\"0\":{\"603\":1},\"1\":{\"603\":1}}],[\"线性探测法就是从冲突的数组单元开始\",{\"1\":{\"1306\":1}}],[\"线性探测法\",{\"1\":{\"1306\":1}}],[\"线性代数方法解非齐次线性方程组\",{\"1\":{\"385\":1}}],[\"线性筛法求素数\",{\"1\":{\"390\":1}}],[\"线性筛\",{\"0\":{\"373\":1}}],[\"线性dp写法\",{\"1\":{\"301\":1}}],[\"线性dp\",{\"0\":{\"300\":1},\"2\":{\"707\":1,\"786\":1,\"842\":1,\"848\":1,\"854\":1}}],[\"线段树\",{\"1\":{\"157\":1,\"206\":1}}],[\"≤100\",{\"1\":{\"298\":1}}],[\"件物品的重量是\",{\"1\":{\"772\":1}}],[\"件物品和一个最多能背重量为\",{\"1\":{\"772\":1}}],[\"件物品\",{\"1\":{\"296\":1,\"297\":1,\"298\":1,\"893\":1}}],[\"没一开始没有k\",{\"1\":{\"1074\":1}}],[\"没找到则返回\",{\"1\":{\"1069\":2}}],[\"没找到则返回end\",{\"1\":{\"422\":1}}],[\"没事别叫我\",{\"1\":{\"411\":1}}],[\"没用过则标记\",{\"1\":{\"291\":1}}],[\"没有把\",{\"1\":{\"1482\":1}}],[\"没有获取到笔的同学只能够等前面的同学用完之后\",{\"1\":{\"1398\":1}}],[\"没有数据\",{\"1\":{\"1348\":1}}],[\"没有及时清理\",{\"1\":{\"1320\":1}}],[\"没有引用链可达\",{\"1\":{\"1305\":1}}],[\"没有对多线程添加任何的线程安全控制\",{\"1\":{\"1293\":1}}],[\"没有的话就调用\",{\"1\":{\"1272\":1}}],[\"没有线程先获取锁\",{\"1\":{\"1250\":1}}],[\"没有线程安全问题\",{\"1\":{\"1100\":1}}],[\"没有明确结构的数据\",{\"1\":{\"1093\":1}}],[\"没有返回值的\",{\"1\":{\"1020\":1}}],[\"没有此参数重启后失效\",{\"1\":{\"663\":1}}],[\"没有实际的高并发经验\",{\"1\":{\"631\":1}}],[\"没有采用关联表\",{\"1\":{\"512\":1}}],[\"没有入度\",{\"1\":{\"314\":1}}],[\"没有被访问过\",{\"1\":{\"314\":1}}],[\"没有上司的舞会\",{\"0\":{\"314\":1}}],[\"没有比d\",{\"1\":{\"221\":1}}],[\"没有\",{\"1\":{\"56\":1,\"1129\":1}}],[\"带着这样的问题我们就来看看\",{\"1\":{\"1504\":1}}],[\"带头结点与不带头结点相比\",{\"1\":{\"1504\":1}}],[\"带有侵入性\",{\"1\":{\"1133\":1}}],[\"带\",{\"1\":{\"1027\":1,\"1259\":1}}],[\"带入\",{\"1\":{\"613\":1}}],[\"带入上述公式即可计算出来理想情况下布隆过滤器的二进制数组的长度\",{\"1\":{\"613\":1}}],[\"带入等式中看是否成立\",{\"1\":{\"291\":1}}],[\"带分数中\",{\"1\":{\"291\":1}}],[\"枚举前已确定值的范围\",{\"1\":{\"851\":1}}],[\"枚举选哪个\",{\"1\":{\"851\":1}}],[\"枚举字段\",{\"1\":{\"592\":2}}],[\"枚举类\",{\"1\":{\"517\":1}}],[\"枚举当前状态的每一位\",{\"1\":{\"392\":1}}],[\"枚举每一列c\",{\"1\":{\"385\":1}}],[\"枚举分割点\",{\"1\":{\"307\":1}}],[\"枚举起点\",{\"1\":{\"307\":1}}],[\"枚举从1\",{\"1\":{\"392\":1}}],[\"枚举从\",{\"1\":{\"307\":1}}],[\"枚举a\",{\"1\":{\"291\":1}}],[\"枚举c\",{\"1\":{\"291\":1}}],[\"枚举\",{\"1\":{\"291\":1,\"371\":1,\"851\":2}}],[\"枚举位数\",{\"1\":{\"291\":1}}],[\"枚举全排列\",{\"1\":{\"291\":1}}],[\"美元\",{\"1\":{\"290\":1}}],[\"美团笔试\",{\"0\":{\"165\":1,\"171\":1}}],[\"索道上的缆车最大承重量为\",{\"1\":{\"290\":1}}],[\"索引为\",{\"1\":{\"1316\":1}}],[\"索引由\",{\"1\":{\"1316\":1}}],[\"索引名\",{\"1\":{\"959\":2}}],[\"索引节点大小\",{\"1\":{\"958\":1}}],[\"索引等\",{\"1\":{\"958\":1}}],[\"索引大大提高了查询效率\",{\"1\":{\"957\":1}}],[\"索引会占用存储空间\",{\"1\":{\"957\":1}}],[\"索引的最左前缀原则\",{\"1\":{\"513\":1}}],[\"索引即数据的组织顺序\",{\"1\":{\"58\":1}}],[\"索引内容分离\",{\"1\":{\"56\":1}}],[\"索引\",{\"0\":{\"956\":1},\"1\":{\"56\":1,\"910\":1,\"957\":1,\"958\":2}}],[\"索引越多写入速度会越慢\",{\"1\":{\"50\":1}}],[\"翰翰和达达就要付\",{\"1\":{\"290\":1}}],[\"翰翰和达达只好花钱让它们坐索道下山\",{\"1\":{\"290\":1}}],[\"翰翰和达达饲养了\",{\"1\":{\"290\":1}}],[\"呜咕>\",{\"1\":{\"290\":1}}],[\"剪枝\",{\"1\":{\"289\":1}}],[\"剪接到要操作的\",{\"1\":{\"200\":1}}],[\"⩽25\",{\"1\":{\"289\":1}}],[\"构造头结点\",{\"1\":{\"1504\":1}}],[\"构造了一个\",{\"1\":{\"1475\":1}}],[\"构造两个链表\",{\"1\":{\"1274\":1}}],[\"构造一个空的map\",{\"1\":{\"1270\":1}}],[\"构造流程\",{\"0\":{\"1182\":1}}],[\"构造\",{\"0\":{\"1181\":1},\"1\":{\"1182\":3}}],[\"构造函数返回前插入一个\",{\"1\":{\"1477\":1}}],[\"构造函数\",{\"1\":{\"1475\":1}}],[\"构造函数执行结束\",{\"1\":{\"1421\":1}}],[\"构造函数主要做了以下事情\",{\"1\":{\"1160\":1}}],[\"构造函数中调用了\",{\"1\":{\"1151\":1}}],[\"构造服务实例\",{\"0\":{\"1154\":1}}],[\"构造实例信息管理器\",{\"0\":{\"1152\":1}}],[\"构造方法会传入一个整型数\",{\"1\":{\"1392\":1}}],[\"构造方法会调用\",{\"1\":{\"1148\":1}}],[\"构造方法的几个参数的意义后\",{\"1\":{\"1366\":1}}],[\"构造方法\",{\"0\":{\"1366\":1}}],[\"构造方法注入\",{\"1\":{\"1133\":1}}],[\"构造器模式\",{\"1\":{\"1154\":1}}],[\"构造器注入方式比较直观\",{\"1\":{\"1133\":1}}],[\"构造器注入\",{\"1\":{\"1133\":2}}],[\"构造器\",{\"1\":{\"1051\":1}}],[\"构造这个链表的\",{\"1\":{\"886\":1}}],[\"构造查询\",{\"1\":{\"526\":1}}],[\"构造状态转移方程\",{\"1\":{\"307\":1}}],[\"构造成\",{\"1\":{\"291\":1}}],[\"构造成一个整数和一个分数\",{\"1\":{\"291\":1}}],[\"构成的链表\",{\"1\":{\"1264\":1}}],[\"构成的\",{\"1\":{\"280\":1}}],[\"构建minioclient对象\",{\"1\":{\"1100\":1}}],[\"构建拼接链表\",{\"1\":{\"888\":1}}],[\"构建新链表的\",{\"1\":{\"887\":1}}],[\"构建新链表的引用指向\",{\"1\":{\"887\":1}}],[\"构建新节点的\",{\"1\":{\"887\":1}}],[\"构建新节点\",{\"1\":{\"700\":1}}],[\"构建完成后使用\",{\"1\":{\"592\":1}}],[\"构建报错的话\",{\"1\":{\"546\":1}}],[\"构建时间可能较长\",{\"1\":{\"534\":1}}],[\"构建时间\",{\"1\":{\"534\":1}}],[\"构建前端路由所需要的菜单路由格式\",{\"1\":{\"462\":1}}],[\"构建依附关系\",{\"1\":{\"273\":1}}],[\"构建字典树\",{\"1\":{\"203\":1}}],[\"构建两个线段树\",{\"1\":{\"168\":1}}],[\"构建缓存\",{\"1\":{\"60\":1}}],[\"座岛屿\",{\"1\":{\"280\":1}}],[\"座山高度所能得到的最长递增子序列的长度\",{\"1\":{\"66\":1}}],[\"座山的高度\",{\"1\":{\"66\":1}}],[\"座山的高度为\",{\"1\":{\"66\":1}}],[\"座山结尾的最长递增子序列的长度\",{\"1\":{\"66\":2}}],[\"座山\",{\"1\":{\"66\":2}}],[\"像素的图片\",{\"1\":{\"1218\":1}}],[\"像素的照片\",{\"1\":{\"280\":1}}],[\"像上面我们配置了请求转发\",{\"1\":{\"665\":1}}],[\"像\",{\"1\":{\"534\":1}}],[\"像这种迷宫问题\",{\"1\":{\"238\":1}}],[\"节省时间\",{\"1\":{\"327\":1,\"328\":1}}],[\"节省查找时间\",{\"1\":{\"274\":1}}],[\"节点出队即该节点引用的线程获得锁\",{\"1\":{\"1506\":1}}],[\"节点如何进行入队和出队是怎样做的呢\",{\"1\":{\"1501\":1}}],[\"节点从同步队列中取消\",{\"1\":{\"1501\":1}}],[\"节点状态\",{\"1\":{\"1501\":1}}],[\"节点存在\",{\"1\":{\"1285\":1}}],[\"节点总是在对队列队尾\",{\"1\":{\"1283\":1}}],[\"节点主要包含了两个域\",{\"1\":{\"1281\":1}}],[\"节点大小\",{\"1\":{\"958\":1}}],[\"节点分为\",{\"1\":{\"958\":1}}],[\"节点的等待状态等信息\",{\"1\":{\"1501\":1}}],[\"节点的数据结构\",{\"1\":{\"1501\":1}}],[\"节点的数据结构是什么样的\",{\"1\":{\"1501\":1}}],[\"节点的状态有\",{\"1\":{\"1501\":1}}],[\"节点的话\",{\"1\":{\"1283\":1}}],[\"节点的\",{\"1\":{\"1283\":1}}],[\"节点的右子树只包含\",{\"1\":{\"898\":1}}],[\"节点的左子树只包含\",{\"1\":{\"898\":1}}],[\"节点组成\",{\"1\":{\"886\":1}}],[\"节点及其子树节点作为路径终点且路径和为\",{\"1\":{\"881\":1}}],[\"节点按照\",{\"1\":{\"766\":2}}],[\"节点复制\",{\"0\":{\"488\":1}}],[\"节点\",{\"1\":{\"215\":1,\"717\":1,\"887\":3,\"1267\":1,\"1274\":3,\"1283\":2,\"1285\":1}}],[\"扁平化处理\",{\"1\":{\"274\":1}}],[\"较平衡\",{\"1\":{\"274\":1}}],[\"较大时查询性能特别差\",{\"1\":{\"40\":1}}],[\"树节点\",{\"1\":{\"1267\":1}}],[\"树深度\",{\"1\":{\"748\":1}}],[\"树又称字典树\",{\"1\":{\"412\":1}}],[\"树与图的遍历\",{\"0\":{\"346\":1}}],[\"树与图的存储\",{\"0\":{\"345\":1}}],[\"树形dp\",{\"0\":{\"313\":1},\"2\":{\"721\":1}}],[\"树的层级比较深\",{\"1\":{\"958\":1}}],[\"树的结构\",{\"1\":{\"802\":1}}],[\"树的高度一旦高了\",{\"1\":{\"958\":1}}],[\"树的高度\",{\"1\":{\"361\":1,\"414\":1}}],[\"树的高度最坏情况下可能变成\",{\"1\":{\"274\":1}}],[\"树的根节点\",{\"1\":{\"766\":2}}],[\"树的根节点从0开始\",{\"1\":{\"255\":1}}],[\"树的根\",{\"1\":{\"314\":1}}],[\"树\",{\"1\":{\"274\":1}}],[\"洛谷\",{\"0\":{\"274\":1}}],[\"询问是否存在依附关系\",{\"1\":{\"273\":1}}],[\"亲戚关系\",{\"0\":{\"273\":1}}],[\"典型实现为\",{\"1\":{\"1306\":1}}],[\"典型的二分\",{\"1\":{\"162\":1}}],[\"典例分析\",{\"0\":{\"272\":1}}],[\"头节点的后继节点\",{\"1\":{\"1506\":1}}],[\"头是按指定排序方式的最小元素\",{\"1\":{\"1078\":1}}],[\"头像\",{\"1\":{\"592\":1}}],[\"头尾指针\",{\"1\":{\"349\":1}}],[\"头重脚轻\",{\"1\":{\"271\":1}}],[\"头小母牛\",{\"1\":{\"182\":1}}],[\"粗暴的把\",{\"1\":{\"271\":1}}],[\"假死\",{\"0\":{\"1408\":1},\"1\":{\"1408\":1}}],[\"假如有多个线程读取数据后\",{\"1\":{\"1398\":1}}],[\"假如有编号为\",{\"1\":{\"269\":1}}],[\"假如修改了常量名称\",{\"1\":{\"1147\":1}}],[\"假定节点编号是1~n\",{\"1\":{\"414\":1,\"415\":1,\"416\":1}}],[\"假设一个线程\",{\"1\":{\"1478\":1}}],[\"假设一定存在\",{\"1\":{\"423\":1}}],[\"假设当前多个生产者线程会调用\",{\"1\":{\"1408\":1}}],[\"假设当前\",{\"1\":{\"1316\":1}}],[\"假设当前节点为\",{\"1\":{\"802\":2}}],[\"假设关键字数量小于数组的大小\",{\"1\":{\"1306\":1}}],[\"假设队列初始状态如下图所示\",{\"1\":{\"1285\":1}}],[\"假设线程\",{\"1\":{\"1283\":1,\"1456\":1,\"1475\":2}}],[\"假设每一次操作都不会产生冲突\",{\"1\":{\"1266\":1}}],[\"假设\",{\"1\":{\"958\":1,\"1284\":1,\"1295\":1,\"1318\":2,\"1393\":1}}],[\"假设你就是这个强盗\",{\"1\":{\"827\":1}}],[\"假设你是瑞幸咖啡的一名运营人员\",{\"1\":{\"152\":1}}],[\"假设名为\",{\"1\":{\"662\":1,\"664\":1}}],[\"假设输入都是正数\",{\"1\":{\"369\":1}}],[\"假设目标值在闭区间\",{\"1\":{\"320\":1}}],[\"假设终点第一次出队列时不是最优\",{\"1\":{\"221\":1}}],[\"假设农场中成熟的母牛每年只会生\",{\"1\":{\"182\":1}}],[\"假设有\",{\"1\":{\"1392\":1,\"1393\":1}}],[\"假设有多个线程执行若干任务\",{\"1\":{\"1376\":1}}],[\"假设有四种咖啡饮品\",{\"1\":{\"152\":1}}],[\"假设有若干个订单号\",{\"1\":{\"114\":1}}],[\"假设所有的房主回答都是正确的情况下\",{\"1\":{\"108\":1}}],[\"假设我们修改第\",{\"1\":{\"66\":1}}],[\"父类被\",{\"1\":{\"1471\":1}}],[\"父类的\",{\"1\":{\"1470\":1}}],[\"父节点为它自己\",{\"1\":{\"361\":1}}],[\"父节点设置为自己\",{\"1\":{\"269\":1}}],[\"父亲数组\",{\"1\":{\"273\":1,\"274\":1}}],[\"父评论等\",{\"1\":{\"30\":1}}],[\"简称同步器\",{\"1\":{\"1493\":1}}],[\"简而言之\",{\"1\":{\"953\":1}}],[\"简化基础设施\",{\"1\":{\"534\":1}}],[\"简介\",{\"0\":{\"267\":1,\"907\":1,\"1248\":1,\"1258\":1,\"1264\":1,\"1280\":1,\"1290\":1,\"1299\":1,\"1324\":1,\"1344\":1,\"1365\":1,\"1375\":1,\"1429\":1,\"1453\":1,\"1462\":1,\"1492\":1,\"1500\":1}}],[\"简单明了\",{\"1\":{\"1131\":1}}],[\"简单来讲\",{\"1\":{\"957\":1}}],[\"简单来说\",{\"1\":{\"674\":1}}],[\"简单来说就是\",{\"1\":{\"322\":1}}],[\"简单模拟\",{\"1\":{\"172\":1}}],[\"简单的线性dp\",{\"1\":{\"194\":1}}],[\"简单的数学表达式计算\",{\"0\":{\"83\":1}}],[\"简单的字符串压缩\",{\"0\":{\"82\":1}}],[\"边缘下沉\",{\"1\":{\"622\":1}}],[\"边\",{\"1\":{\"354\":1}}],[\"边多\",{\"1\":{\"351\":1}}],[\"边读边加\",{\"1\":{\"263\":1}}],[\"边界条件\",{\"1\":{\"182\":1,\"309\":1}}],[\"递\",{\"1\":{\"796\":1}}],[\"递推结果到\",{\"1\":{\"796\":1}}],[\"递推\",{\"0\":{\"796\":1,\"828\":1},\"2\":{\"830\":1}}],[\"递推式简化为\",{\"1\":{\"797\":1}}],[\"递推式\",{\"1\":{\"387\":1}}],[\"递推法求组合数\",{\"0\":{\"387\":1}}],[\"递推求出二维前缀和\",{\"1\":{\"263\":1}}],[\"递归函数遍历罢了\",{\"1\":{\"887\":1}}],[\"递归地交换每个节点的左右子树\",{\"1\":{\"863\":1}}],[\"递归地合并所有子链表\",{\"1\":{\"134\":1}}],[\"递归的构建左子树与右子树\",{\"1\":{\"815\":1}}],[\"递归的终止情况\",{\"1\":{\"317\":1}}],[\"递归过程\",{\"1\":{\"808\":1}}],[\"递归向上将结果返回的父节点是可以确定的\",{\"1\":{\"796\":1}}],[\"递归入口\",{\"1\":{\"795\":1}}],[\"递归边界\",{\"1\":{\"795\":1}}],[\"递归边界使某数变成了0\",{\"1\":{\"377\":1}}],[\"递归终止\",{\"1\":{\"767\":1}}],[\"递归终点\",{\"1\":{\"730\":1}}],[\"递归建树\",{\"1\":{\"766\":1}}],[\"递归返回即可\",{\"1\":{\"760\":1}}],[\"递归实现\",{\"1\":{\"748\":1}}],[\"递归遍历\",{\"0\":{\"736\":1},\"1\":{\"876\":1}}],[\"递归结束条件\",{\"1\":{\"808\":1}}],[\"递归结束\",{\"1\":{\"730\":1}}],[\"递归处理左右子树并接收返回值\",{\"1\":{\"713\":1}}],[\"递归处理子问题\",{\"1\":{\"317\":2}}],[\"递归方法\",{\"1\":{\"693\":1}}],[\"递归反转后续链表并连接起来\",{\"1\":{\"682\":1}}],[\"递归调用\",{\"1\":{\"681\":1}}],[\"递归生成父子菜单\",{\"1\":{\"462\":1}}],[\"递归排序\",{\"1\":{\"318\":1,\"833\":1}}],[\"递归排序左右两部分\",{\"1\":{\"134\":1,\"834\":1}}],[\"递归从后往前更新\",{\"1\":{\"314\":1}}],[\"递归出口\",{\"1\":{\"270\":1}}],[\"递归解题的模板\",{\"1\":{\"238\":1}}],[\"递归搜索完成后回退\",{\"1\":{\"235\":1,\"236\":1,\"237\":1}}],[\"递归继续搜索\",{\"1\":{\"235\":1}}],[\"递归后再回溯\",{\"1\":{\"235\":1}}],[\"递归\",{\"0\":{\"725\":1,\"730\":1,\"748\":1},\"1\":{\"228\":1,\"229\":1,\"255\":1,\"377\":1,\"754\":1},\"2\":{\"190\":1,\"293\":1,\"684\":1,\"715\":1,\"721\":1,\"733\":1,\"739\":1,\"751\":1,\"757\":1,\"763\":1,\"769\":1,\"811\":1,\"866\":1,\"884\":1,\"903\":1}}],[\"递归左右子树\",{\"1\":{\"187\":1}}],[\"递归合并\",{\"1\":{\"134\":1}}],[\"递归相关题型\",{\"0\":{\"286\":1},\"1\":{\"4\":1}}],[\"坐标和价值\",{\"1\":{\"263\":1}}],[\"坐标\",{\"1\":{\"263\":1}}],[\"轴平行\",{\"1\":{\"263\":1}}],[\"轴方向向右行走\",{\"1\":{\"97\":1}}],[\"激光炸弹的投放是通过卫星定位的\",{\"1\":{\"263\":1}}],[\"共享锁的释放在\",{\"1\":{\"1511\":1}}],[\"共享锁的释放\",{\"0\":{\"1511\":1}}],[\"共享锁的获取方法为\",{\"1\":{\"1510\":1}}],[\"共享锁的获取\",{\"0\":{\"1510\":1}}],[\"共享锁的获取和释放以及可中断锁\",{\"1\":{\"1500\":1}}],[\"共享锁\",{\"0\":{\"1509\":1}}],[\"共享式锁\",{\"1\":{\"1500\":1}}],[\"共享式释放同步状态\",{\"1\":{\"1496\":1,\"1500\":1}}],[\"共享式获取同步状态\",{\"1\":{\"1496\":1,\"1500\":1}}],[\"共享式获取与释放同步状态\",{\"1\":{\"1495\":1}}],[\"共享式\",{\"1\":{\"1496\":1}}],[\"共享变量会先放在主存中\",{\"1\":{\"1417\":1}}],[\"共享数据会出现线程安全的问题\",{\"1\":{\"1416\":1}}],[\"共享内存和消息传递\",{\"1\":{\"1416\":1}}],[\"共享出去被多线程访问\",{\"1\":{\"1309\":1}}],[\"共享对象会造成线程安全\",{\"1\":{\"1309\":1}}],[\"共享资源\",{\"1\":{\"1299\":2}}],[\"共同指向了\",{\"1\":{\"1284\":1}}],[\"共\",{\"1\":{\"380\":1}}],[\"共一行\",{\"1\":{\"281\":1,\"339\":1}}],[\"共有多少种不同的截断方法\",{\"1\":{\"262\":1}}],[\"共进行了\",{\"1\":{\"99\":1}}],[\"说人话\",{\"1\":{\"261\":1}}],[\"说明同步队列是带头结点的链式存储结构\",{\"1\":{\"1504\":1}}],[\"说明当前线程是第一个加入同步队列进行等待的线程\",{\"1\":{\"1504\":1}}],[\"说明当前线程池已经处于饱和状态了\",{\"1\":{\"1359\":1}}],[\"说明找到了一个脏\",{\"1\":{\"1316\":1}}],[\"说明找到了总和为\",{\"1\":{\"772\":1}}],[\"说明第一趟未发现脏\",{\"1\":{\"1316\":1}}],[\"说明新的\",{\"1\":{\"1314\":1}}],[\"说明哈希表被装载的越多\",{\"1\":{\"1306\":1}}],[\"说明threadlocal强引用已经被释放掉\",{\"1\":{\"1306\":1}}],[\"说明该节点即为真正的队头节点\",{\"1\":{\"1284\":1}}],[\"说明该节点的子树是空子树\",{\"1\":{\"730\":1}}],[\"说明正在进行扩容\",{\"1\":{\"1272\":1}}],[\"说明发生了\",{\"1\":{\"1272\":1}}],[\"说明还需要继续完成某些功能\",{\"1\":{\"1020\":1}}],[\"说明只有一个结点了\",{\"1\":{\"833\":1}}],[\"说明目标节点是通过right返回的\",{\"1\":{\"755\":1}}],[\"说明这个点已经被处理过了\",{\"1\":{\"1274\":1}}],[\"说明这个字符没有匹配上\",{\"1\":{\"802\":1}}],[\"说明这个数是它的一个约数\",{\"1\":{\"375\":1}}],[\"说明这就是大于\",{\"1\":{\"368\":1}}],[\"说明此时root就是最近公共节点\",{\"1\":{\"755\":1}}],[\"说明此时的\",{\"1\":{\"373\":1}}],[\"说明此时遍历到的\",{\"1\":{\"373\":1}}],[\"说明两个顶点已经连通\",{\"1\":{\"361\":1}}],[\"说明图中存在负权回路\",{\"1\":{\"354\":1}}],[\"说明不连通\",{\"1\":{\"352\":1}}],[\"说明存在拓扑序列\",{\"1\":{\"349\":1}}],[\"说明是叶子节点\",{\"1\":{\"314\":1}}],[\"说明从j出发找不到第k短路\",{\"1\":{\"223\":1}}],[\"说明房主提供了有效信息\",{\"1\":{\"108\":1}}],[\"说明所有括号都已正确匹配\",{\"1\":{\"93\":1}}],[\"说明右括号无法匹配\",{\"1\":{\"93\":1}}],[\"说明\",{\"1\":{\"71\":1,\"72\":1,\"108\":1,\"109\":1,\"135\":1,\"193\":1,\"196\":1,\"566\":2,\"613\":1,\"909\":1,\"915\":1,\"932\":1,\"958\":1,\"1046\":1,\"1120\":1,\"1281\":1,\"1283\":3,\"1314\":1,\"1315\":1,\"1317\":1}}],[\"说明哪个\",{\"1\":{\"48\":1}}],[\"翻译为\",{\"1\":{\"1129\":1}}],[\"翻译\",{\"1\":{\"261\":1}}],[\"翻转字符串\",{\"1\":{\"1005\":1}}],[\"翻转这棵二叉树\",{\"1\":{\"862\":1}}],[\"翻转这两个数的符号\",{\"1\":{\"104\":1}}],[\"翻转二叉树\",{\"0\":{\"861\":1},\"1\":{\"861\":1}}],[\"翻转一个数组\",{\"1\":{\"423\":1}}],[\"翻转一个\",{\"1\":{\"423\":1}}],[\"翻转\",{\"1\":{\"423\":1}}],[\"翻转指定位\",{\"1\":{\"338\":1}}],[\"翻转后还是\",{\"1\":{\"104\":1}}],[\"经常会被用作不变类上\",{\"1\":{\"1472\":1}}],[\"经常会使用并发容器用于存储多线程间的共享数据\",{\"1\":{\"1344\":1}}],[\"经常会出现多个关键字散列值相同的情况\",{\"1\":{\"1306\":1}}],[\"经常需要清除无用的对象\",{\"1\":{\"1306\":1}}],[\"经过我们这样的分析\",{\"1\":{\"1504\":1}}],[\"经过我们的分析可以得出如下结论\",{\"1\":{\"1470\":1}}],[\"经过上面的分析\",{\"1\":{\"1455\":1,\"1505\":1}}],[\"经过上面的理解\",{\"1\":{\"1449\":1}}],[\"经过分析我们可以得出如下结论\",{\"1\":{\"1454\":1}}],[\"经过一次循环后的状态\",{\"1\":{\"1284\":1}}],[\"经过一分钟\",{\"1\":{\"870\":1}}],[\"经过这样的处理后\",{\"1\":{\"845\":1}}],[\"经过若干操作变为\",{\"1\":{\"306\":1}}],[\"经过某个流程处理后\",{\"1\":{\"114\":1}}],[\"经历了千辛万苦\",{\"1\":{\"290\":1}}],[\"经验\",{\"2\":{\"259\":1}}],[\"迭代地寻找当前节点的左子节点\",{\"1\":{\"731\":1}}],[\"迭代\",{\"0\":{\"731\":1,\"749\":1},\"1\":{\"354\":1},\"2\":{\"733\":1,\"739\":1,\"751\":1}}],[\"迭代器的++\",{\"1\":{\"422\":1}}],[\"迭代器\",{\"1\":{\"256\":3}}],[\"迭代隔离也是好的\",{\"1\":{\"47\":1}}],[\"捕获异常\",{\"0\":{\"1047\":1}}],[\"捕获代码中所有的异常\",{\"1\":{\"599\":1}}],[\"捕获业务逻辑异常做出反馈\",{\"1\":{\"576\":1}}],[\"捕获\",{\"1\":{\"255\":1}}],[\"让这些线程都被阻塞\",{\"1\":{\"1392\":1}}],[\"让主线程等待被\",{\"1\":{\"1392\":1}}],[\"让执行时间短的任务先执行\",{\"1\":{\"1361\":1}}],[\"让其他线程有机会运行\",{\"1\":{\"1331\":1}}],[\"让写线程暂停\",{\"1\":{\"1295\":1}}],[\"让出的时间片只会分配给当前线程相同优先级的线程\",{\"1\":{\"1339\":1}}],[\"让出的\",{\"1\":{\"1339\":1}}],[\"让出\",{\"1\":{\"1271\":1}}],[\"让每一个\",{\"1\":{\"1264\":1}}],[\"让我们觉得多个线程是同时执行的\",{\"1\":{\"1220\":1}}],[\"让我研究\",{\"0\":{\"1175\":1},\"1\":{\"1175\":1}}],[\"让他们保持同步\",{\"1\":{\"1160\":1}}],[\"让外部知道它需要哪些依赖对象\",{\"1\":{\"1133\":1}}],[\"让两张表的数据建立连接\",{\"1\":{\"919\":1,\"937\":1}}],[\"让前端得到更详细的业务报错\",{\"1\":{\"599\":1}}],[\"让多个不同参数的\",{\"1\":{\"542\":1}}],[\"让项目无法启动\",{\"1\":{\"526\":1}}],[\"让数据流动起来\",{\"1\":{\"438\":1}}],[\"让\",{\"1\":{\"255\":1,\"664\":1,\"1392\":1,\"1406\":2}}],[\"让终点出队k次\",{\"1\":{\"223\":1}}],[\"指令开放给我们使用\",{\"1\":{\"1482\":1}}],[\"指令肯定有神奇的地方\",{\"1\":{\"1454\":1}}],[\"指令级并行的重排序\",{\"1\":{\"1418\":1}}],[\"指令\",{\"1\":{\"1384\":1,\"1431\":3,\"1439\":1,\"1486\":1}}],[\"指令后\",{\"1\":{\"1282\":1}}],[\"指令实现\",{\"1\":{\"1266\":1,\"1383\":1,\"1437\":1}}],[\"指的是单线程程序和正确同步的多线程程序\",{\"1\":{\"1420\":1,\"1423\":1}}],[\"指的是\",{\"1\":{\"1223\":1}}],[\"指的是两个斜着相邻节点之间的移动代价\",{\"1\":{\"219\":1}}],[\"指明\",{\"1\":{\"1107\":1}}],[\"指示索引或者为负\",{\"1\":{\"1045\":1}}],[\"指示存在安全侵犯\",{\"1\":{\"1045\":1}}],[\"指示某排序索引\",{\"1\":{\"1045\":1}}],[\"指向刚分配的内存地址\",{\"1\":{\"1485\":1}}],[\"指向了索引为\",{\"1\":{\"1316\":1}}],[\"指向了\",{\"1\":{\"1284\":2}}],[\"指向了队列真正的队尾节点\",{\"1\":{\"1283\":1}}],[\"指向的头结点不为\",{\"1\":{\"1506\":1}}],[\"指向的\",{\"1\":{\"1284\":3}}],[\"指向的节点设置为哨兵节点\",{\"1\":{\"1285\":1}}],[\"指向的节点已经发生了改变\",{\"1\":{\"1284\":1}}],[\"指向的节点转换为哨兵节点并且\",{\"1\":{\"1284\":1}}],[\"指向的节点在\",{\"1\":{\"1284\":1}}],[\"指向的节点以及构造哨兵节点\",{\"1\":{\"1284\":1}}],[\"指向的节点并不一定是队列的队头节点\",{\"1\":{\"1284\":1}}],[\"指向的节点的\",{\"1\":{\"1283\":1,\"1284\":2,\"1285\":1,\"1286\":2}}],[\"指向的节点的下一个节点为\",{\"1\":{\"1286\":1}}],[\"指向的节点的下一个节点不为\",{\"1\":{\"1286\":1}}],[\"指向的节点的下一个节点\",{\"1\":{\"1283\":2}}],[\"指向的节点不相同\",{\"1\":{\"1283\":1}}],[\"指向的节点不是队列的真正队尾节点\",{\"1\":{\"1283\":1}}],[\"指向的节点不为\",{\"1\":{\"1283\":1}}],[\"指向的节点即为队列真正的队尾节点\",{\"1\":{\"1283\":1}}],[\"指向的节点由\",{\"1\":{\"1283\":1}}],[\"指向的节点为哨兵节点\",{\"1\":{\"1285\":1}}],[\"指向的节点为\",{\"1\":{\"1283\":1}}],[\"指向的节点依然还是\",{\"1\":{\"1283\":1}}],[\"指向的下一节点\",{\"1\":{\"403\":1}}],[\"指向同一个节点呢\",{\"1\":{\"1284\":1}}],[\"指向同一个节点\",{\"1\":{\"1281\":1}}],[\"指向当前的\",{\"1\":{\"1251\":1}}],[\"指向它\",{\"1\":{\"1069\":2}}],[\"指向节点的变化\",{\"1\":{\"1283\":1}}],[\"指向节点的同时找到新对应新节点的\",{\"1\":{\"888\":1}}],[\"指向节点\",{\"1\":{\"888\":1}}],[\"指向头节点\",{\"1\":{\"887\":1}}],[\"指向\",{\"1\":{\"875\":1,\"887\":1,\"1284\":2,\"1285\":1}}],[\"指向链表头结点\",{\"1\":{\"777\":1}}],[\"指向链表的头结点\",{\"1\":{\"777\":1}}],[\"指定当所有线程都到达时执行的业务功能\",{\"1\":{\"1394\":1}}],[\"指定必须有6个运动员到达才行\",{\"1\":{\"1393\":1}}],[\"指定时间单位\",{\"1\":{\"1359\":1}}],[\"指定文件路径\",{\"1\":{\"1103\":1}}],[\"指定\",{\"1\":{\"1087\":1}}],[\"指定数据存放位置\",{\"1\":{\"1087\":1}}],[\"指定minio密码\",{\"1\":{\"1087\":1}}],[\"指定minio的用户名\",{\"1\":{\"1087\":1}}],[\"指定容量的空数组列表\",{\"1\":{\"1072\":1}}],[\"指定注解可以用在哪些地方\",{\"1\":{\"1053\":1}}],[\"指定注解的作用范围\",{\"1\":{\"1053\":1}}],[\"指定列下相同的数据归为一类\",{\"1\":{\"933\":1}}],[\"指定字段\",{\"1\":{\"925\":1}}],[\"指定的顺序来执行的\",{\"1\":{\"1420\":1}}],[\"指定的线程全部都到达了指定点的时候\",{\"1\":{\"1394\":1}}],[\"指定的字段顺序需要与值的顺序是一一对应的\",{\"1\":{\"925\":1}}],[\"指定的长度为最大占用长度\",{\"1\":{\"920\":1}}],[\"指定的部分应该是提前排好序的\",{\"1\":{\"423\":1}}],[\"指定的部分上执行二分查找\",{\"1\":{\"423\":1}}],[\"指定的部分进行快速排序\",{\"1\":{\"423\":1}}],[\"指定长度多长\",{\"1\":{\"920\":1}}],[\"指定驱动器号\",{\"1\":{\"676\":1}}],[\"指定域名\",{\"1\":{\"672\":1}}],[\"指定接口全局路径前缀\",{\"1\":{\"576\":1}}],[\"指定了字段映射关系\",{\"1\":{\"567\":1}}],[\"指定雪花算法生成\",{\"1\":{\"515\":1}}],[\"指定主键策略为\",{\"1\":{\"515\":1}}],[\"指边相对于点不多\",{\"1\":{\"351\":1}}],[\"指针没有发生改变所以\",{\"1\":{\"1285\":1}}],[\"指针指向了同一个节点\",{\"1\":{\"1283\":1}}],[\"指针往前递进去找到队尾节点\",{\"1\":{\"1283\":1}}],[\"指针会指向一个\",{\"1\":{\"1281\":1}}],[\"指针引用新的\",{\"1\":{\"1267\":1}}],[\"指针域\",{\"1\":{\"958\":1}}],[\"指针也都应指向复制链表中的新节点\",{\"1\":{\"886\":1}}],[\"指针和\",{\"1\":{\"886\":1}}],[\"指针不断前进\",{\"1\":{\"789\":1}}],[\"指针\",{\"1\":{\"255\":1,\"423\":3,\"888\":1,\"958\":1,\"1266\":1,\"1281\":1,\"1283\":1}}],[\"功能更加强大\",{\"1\":{\"1393\":1}}],[\"功能同方法\",{\"1\":{\"1259\":3}}],[\"功能上两者类似\",{\"1\":{\"1205\":1}}],[\"功能\",{\"1\":{\"254\":1,\"931\":2,\"932\":1}}],[\"功能模块\",{\"0\":{\"45\":1}}],[\"容量等于\",{\"1\":{\"1326\":1}}],[\"容量迅速增\",{\"1\":{\"1326\":1}}],[\"容量不能改变\",{\"1\":{\"1326\":1}}],[\"容量不足的时候\",{\"1\":{\"1274\":1}}],[\"容量为之前的两倍\",{\"1\":{\"1274\":1}}],[\"容量为0时\",{\"1\":{\"308\":2}}],[\"容斥原理\",{\"0\":{\"392\":1}}],[\"容器只能保证数据的最终一致性\",{\"1\":{\"1295\":1}}],[\"容器有很多优点\",{\"1\":{\"1295\":1}}],[\"容器也是一种读写分离的思想\",{\"1\":{\"1291\":1}}],[\"容器进行并发的读的时候\",{\"1\":{\"1291\":1}}],[\"容器可以保证线程安全\",{\"1\":{\"1290\":1}}],[\"容器内部的数据结构\",{\"1\":{\"1139\":1}}],[\"容器创建后注入到被注入的对象中\",{\"1\":{\"1129\":1}}],[\"容器控制对象\",{\"1\":{\"1129\":1}}],[\"容器来控制\",{\"1\":{\"1129\":1}}],[\"容器来负责对象的生命周期和对象之间的关系\",{\"1\":{\"1129\":1}}],[\"容器后\",{\"1\":{\"1129\":1}}],[\"容器化\",{\"1\":{\"1095\":1}}],[\"容器部署\",{\"0\":{\"608\":1}}],[\"容器\",{\"1\":{\"557\":1,\"1088\":1,\"1137\":1,\"1140\":1,\"1295\":1}}],[\"容器的首尾地址\",{\"1\":{\"256\":2}}],[\"容器中登记\",{\"1\":{\"1131\":1}}],[\"容器中以前的内容\",{\"1\":{\"254\":1}}],[\"容器中\",{\"1\":{\"254\":2}}],[\"容器大小\",{\"1\":{\"254\":1}}],[\"容易引发数据库的死锁问题\",{\"1\":{\"937\":1}}],[\"容易受到干扰而崩溃停止\",{\"1\":{\"671\":1}}],[\"容易想到首先构造出\",{\"1\":{\"119\":1}}],[\"容易导致服务\",{\"1\":{\"48\":1}}],[\"容易造成db抖动\",{\"1\":{\"28\":1}}],[\"容易造成整个系统的腐化\",{\"1\":{\"25\":1}}],[\"成环形\",{\"1\":{\"1306\":1}}],[\"成员变量来表示同步状态以及通过一个\",{\"1\":{\"1494\":1}}],[\"成员变量等\",{\"1\":{\"1054\":1}}],[\"成员变量\",{\"0\":{\"1465\":1},\"1\":{\"1027\":2}}],[\"成功则线程执行\",{\"1\":{\"1503\":1}}],[\"成功则返回\",{\"1\":{\"1325\":1}}],[\"成功释放同步状态\",{\"1\":{\"1251\":1}}],[\"成功返回队首元素\",{\"1\":{\"1076\":2}}],[\"成功返回true\",{\"1\":{\"1076\":1}}],[\"成功\",{\"1\":{\"954\":1,\"1503\":1}}],[\"成了一个环\",{\"1\":{\"875\":1}}],[\"成本\",{\"1\":{\"957\":1}}],[\"成本和稳定性之间的取舍与思考\",{\"1\":{\"622\":1}}],[\"成本会加速飙升\",{\"1\":{\"438\":1}}],[\"成立\",{\"1\":{\"248\":1,\"383\":1}}],[\"成为某个业务领域的专家\",{\"1\":{\"45\":1}}],[\"裴蜀定理\",{\"0\":{\"248\":1,\"383\":1}}],[\"进去代码块\",{\"1\":{\"1406\":4}}],[\"进去看是不是符合我们的猜想\",{\"1\":{\"1250\":1}}],[\"进场\",{\"1\":{\"1393\":7}}],[\"进一步知道了\",{\"1\":{\"1429\":1}}],[\"进一步减小了锁粒度\",{\"1\":{\"1276\":1}}],[\"进一步说明\",{\"1\":{\"1250\":1}}],[\"进一步优化空间\",{\"1\":{\"852\":1}}],[\"进一步空间优化\",{\"1\":{\"828\":1}}],[\"进阶\",{\"0\":{\"711\":1},\"1\":{\"723\":1,\"850\":1}}],[\"进而会继续执行\",{\"1\":{\"1370\":1}}],[\"进而会导致头节点丢失\",{\"1\":{\"699\":1}}],[\"进而决定他们能访问哪些系统资源\",{\"1\":{\"470\":1}}],[\"进入终端\",{\"1\":{\"1089\":1}}],[\"进入到同步代码块中\",{\"1\":{\"1407\":1}}],[\"进入到\",{\"1\":{\"1089\":1,\"1431\":1}}],[\"进入到目录\",{\"1\":{\"559\":1}}],[\"进入\",{\"1\":{\"559\":2,\"1284\":1,\"1407\":1}}],[\"进入刷题页面\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"进制数\",{\"1\":{\"421\":1}}],[\"进制的数转化为十进制\",{\"1\":{\"245\":1}}],[\"进位值为\",{\"1\":{\"699\":1}}],[\"进位\",{\"1\":{\"327\":1}}],[\"进行入队操作\",{\"1\":{\"1506\":1}}],[\"进行重试\",{\"1\":{\"1504\":1}}],[\"进行等待时会先释放锁\",{\"1\":{\"1493\":1}}],[\"进行访问就可以出现这样的操作顺序\",{\"1\":{\"1482\":1}}],[\"进行通信\",{\"1\":{\"1433\":1}}],[\"进行通信的对象\",{\"1\":{\"1158\":1}}],[\"进行通信的\",{\"1\":{\"1157\":1}}],[\"进行加一的操作\",{\"1\":{\"1482\":1}}],[\"进行加一操作后\",{\"1\":{\"1433\":1}}],[\"进行加一\",{\"1\":{\"1432\":1}}],[\"进行加锁的时候线程切换的是\",{\"1\":{\"1334\":1}}],[\"进行同步\",{\"1\":{\"1431\":1}}],[\"进行同步到\",{\"1\":{\"46\":1}}],[\"进行wait\",{\"1\":{\"1409\":5,\"1410\":9}}],[\"进行封装\",{\"1\":{\"1387\":1}}],[\"进行封装的话\",{\"1\":{\"1290\":1}}],[\"进行下一次尝试\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"进行下一次循环\",{\"1\":{\"1284\":1}}],[\"进行了重排序的话\",{\"1\":{\"1485\":1}}],[\"进行了了解\",{\"1\":{\"1370\":1}}],[\"进行了隔离\",{\"1\":{\"46\":1}}],[\"进行相应的封装\",{\"1\":{\"1369\":1}}],[\"进行数据存储的\",{\"1\":{\"1346\":1}}],[\"进行数据读写\",{\"1\":{\"1094\":1}}],[\"进行包装然后\",{\"1\":{\"1330\":1}}],[\"进行垃圾回收\",{\"1\":{\"1319\":1}}],[\"进行清理\",{\"1\":{\"1317\":1}}],[\"进行脏\",{\"1\":{\"1317\":1}}],[\"进行交换\",{\"1\":{\"1317\":2}}],[\"进行交换再进行下一步计算\",{\"1\":{\"705\":1}}],[\"进行处理\",{\"1\":{\"1307\":1,\"1314\":1,\"1318\":1}}],[\"进行赋值的时候会创建初始大小为\",{\"1\":{\"1306\":1}}],[\"进行维护的\",{\"1\":{\"1301\":1}}],[\"进行获取\",{\"1\":{\"1301\":1,\"1431\":1}}],[\"进行归类\",{\"1\":{\"1299\":1}}],[\"进行才利用\",{\"1\":{\"1286\":1}}],[\"进行试探\",{\"1\":{\"1284\":1}}],[\"进行扩容\",{\"1\":{\"1274\":1}}],[\"进行一次\",{\"1\":{\"1272\":1}}],[\"进行一致性\",{\"1\":{\"61\":1}}],[\"进行初始化\",{\"1\":{\"1272\":1}}],[\"进行判断的\",{\"1\":{\"1284\":1}}],[\"进行判断\",{\"1\":{\"1271\":1,\"1283\":1,\"1485\":1}}],[\"进行再一次封装的话\",{\"1\":{\"1290\":1}}],[\"进行再一次封装\",{\"1\":{\"1267\":1}}],[\"进行修饰\",{\"1\":{\"1388\":1}}],[\"进行修饰的\",{\"1\":{\"1267\":1}}],[\"进行修改\",{\"1\":{\"596\":1}}],[\"进行线程安全的控制\",{\"1\":{\"1264\":1}}],[\"进行注册了\",{\"1\":{\"1194\":1}}],[\"进行注册的\",{\"1\":{\"1194\":1}}],[\"进行实现\",{\"1\":{\"1141\":1}}],[\"进行解析\",{\"1\":{\"1141\":1}}],[\"进行解析和渲染\",{\"1\":{\"531\":1,\"533\":2}}],[\"进行纵向计算\",{\"1\":{\"932\":1}}],[\"进行进程守护\",{\"1\":{\"671\":1}}],[\"进行更详细的配置\",{\"1\":{\"670\":1}}],[\"进行构建\",{\"1\":{\"592\":1}}],[\"进行组合\",{\"1\":{\"568\":1}}],[\"进行转换\",{\"1\":{\"526\":1}}],[\"进行的\",{\"1\":{\"513\":1}}],[\"进行关联分析\",{\"1\":{\"436\":1}}],[\"进行\",{\"1\":{\"362\":1,\"1284\":2,\"1285\":1,\"1286\":3}}],[\"进行异或运算\",{\"1\":{\"338\":1}}],[\"进行按位或运算\",{\"1\":{\"338\":1}}],[\"进行按位与运算\",{\"1\":{\"338\":1}}],[\"进行缓存的异步构建\",{\"1\":{\"58\":1}}],[\"进行索引的缓存\",{\"1\":{\"58\":1}}],[\"进行运营测的\",{\"1\":{\"50\":1}}],[\"进行控制来达到线程安全的目的\",{\"1\":{\"1380\":1}}],[\"进行控制\",{\"1\":{\"31\":1}}],[\"秦九韶算法\",{\"0\":{\"245\":1}}],[\"③\",{\"1\":{\"243\":1}}],[\"②赋\",{\"1\":{\"254\":1}}],[\"②\",{\"1\":{\"243\":1,\"324\":1,\"380\":1}}],[\"①将区间\",{\"1\":{\"254\":1}}],[\"①\",{\"1\":{\"243\":1,\"324\":1,\"380\":1}}],[\"异步多线程是真的优雅\",{\"1\":{\"643\":1}}],[\"异步处理\",{\"1\":{\"28\":1}}],[\"异或\",{\"1\":{\"337\":1}}],[\"异常原因分析\",{\"1\":{\"1407\":1}}],[\"异常2\",{\"0\":{\"1171\":1}}],[\"异常1\",{\"0\":{\"1170\":1}}],[\"异常处理可以允许我们在程序运行时进行诊断和补救\",{\"1\":{\"1041\":1}}],[\"异常处理\",{\"0\":{\"1041\":1}}],[\"异常\",{\"1\":{\"243\":1,\"526\":1,\"1044\":1,\"1045\":2,\"1290\":1,\"1325\":3,\"1359\":1,\"1404\":1}}],[\"条跑道\",{\"1\":{\"1393\":1}}],[\"条记录\",{\"1\":{\"958\":1}}],[\"条数据\",{\"1\":{\"958\":1}}],[\"条数\",{\"1\":{\"935\":1}}],[\"条件的判断\",{\"1\":{\"1408\":1}}],[\"条件已经发生了变化\",{\"1\":{\"1407\":1}}],[\"条件进行判断\",{\"1\":{\"1407\":1}}],[\"条件满足\",{\"1\":{\"1254\":1}}],[\"条件表达式\",{\"0\":{\"985\":1}}],[\"条件查询\",{\"0\":{\"931\":1},\"1\":{\"929\":1}}],[\"条件列表\",{\"1\":{\"929\":1,\"931\":2,\"934\":1}}],[\"条件\",{\"1\":{\"926\":1,\"927\":1,\"933\":2,\"944\":1}}],[\"条件为\",{\"1\":{\"851\":1}}],[\"条件语句\",{\"1\":{\"471\":1}}],[\"条件由\",{\"1\":{\"237\":1}}],[\"条边为止\",{\"1\":{\"361\":1}}],[\"条边\",{\"1\":{\"351\":1,\"359\":1}}],[\"条边的有向图\",{\"1\":{\"223\":1}}],[\"减\",{\"1\":{\"1392\":2}}],[\"减到\",{\"1\":{\"1392\":3}}],[\"减库存\",{\"1\":{\"1218\":1}}],[\"减一\",{\"1\":{\"869\":1,\"1392\":1}}],[\"减轻了服务器的压力\",{\"1\":{\"532\":1}}],[\"减轻服务器压力\",{\"1\":{\"532\":1}}],[\"减少写状态\",{\"1\":{\"1240\":1}}],[\"减少浏览器默认样式的影响\",{\"1\":{\"540\":1}}],[\"减少样式冲突\",{\"1\":{\"540\":1}}],[\"减少表间联接\",{\"1\":{\"436\":1}}],[\"减少冗余\",{\"1\":{\"40\":1}}],[\"减枝\",{\"1\":{\"236\":1}}],[\"迷宫数组\",{\"1\":{\"236\":1,\"237\":1}}],[\"迷宫地图数组\",{\"1\":{\"235\":1}}],[\"迷宫有墙和道路\",{\"1\":{\"180\":1}}],[\"逃出这种迷宫\",{\"1\":{\"235\":1}}],[\"逃出迷宫的最短路径\",{\"0\":{\"236\":1},\"1\":{\"234\":1}}],[\"队头元素是队列中存在时间最长的数据元素\",{\"1\":{\"1326\":1}}],[\"队头的值\",{\"1\":{\"409\":1}}],[\"队头不断出队\",{\"1\":{\"355\":1}}],[\"队头终点\",{\"1\":{\"221\":2}}],[\"队列头结点引用指向当前节点\",{\"1\":{\"1505\":1}}],[\"队列头指针用指向当前节点\",{\"1\":{\"1504\":1}}],[\"队列的实现方式无外乎两者一是通过数组的形式\",{\"1\":{\"1501\":1}}],[\"队列构成等待队列\",{\"1\":{\"1494\":1}}],[\"队列已满的话\",{\"1\":{\"1359\":1}}],[\"队列默认大小为\",{\"1\":{\"1349\":1}}],[\"队列通常被视作线程间操作的数据容器\",{\"1\":{\"1324\":1}}],[\"队列出队操作后的状态\",{\"1\":{\"1284\":1}}],[\"队列初始状态\",{\"1\":{\"1284\":1}}],[\"队列进行入队操作后\",{\"1\":{\"1283\":1}}],[\"队列为空队列\",{\"1\":{\"1283\":1}}],[\"队列长度会越来越长\",{\"1\":{\"1283\":1}}],[\"队列长度为\",{\"1\":{\"1160\":1}}],[\"队列也是我们常用的一种数据结构\",{\"1\":{\"1280\":1}}],[\"队列中元素数量\",{\"1\":{\"1078\":1}}],[\"队列中元素个数\",{\"1\":{\"1077\":1}}],[\"队列实现\",{\"1\":{\"749\":1}}],[\"队列里面存的是下标\",{\"1\":{\"410\":1}}],[\"队列\",{\"0\":{\"408\":1,\"1038\":1,\"1076\":1},\"1\":{\"234\":1,\"422\":1,\"1283\":1}}],[\"缺点\",{\"0\":{\"973\":1},\"1\":{\"484\":1,\"534\":1,\"937\":1,\"957\":1,\"1056\":1}}],[\"缺口迷宫\",{\"0\":{\"237\":1},\"1\":{\"234\":1}}],[\"缺失了一个订单号\",{\"1\":{\"114\":1}}],[\"缺失的订单号\",{\"0\":{\"114\":1}}],[\"能保证其原子性\",{\"1\":{\"1439\":1}}],[\"能支持处理器提供的\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"能否直接将新值插入到\",{\"1\":{\"1272\":1}}],[\"能否逃出迷宫\",{\"0\":{\"235\":1},\"1\":{\"234\":1}}],[\"能从\",{\"1\":{\"1259\":1}}],[\"能被100整除时\",{\"1\":{\"984\":1}}],[\"能抢到的最大值\",{\"1\":{\"827\":1}}],[\"能抢到的钱显然是\",{\"1\":{\"827\":1}}],[\"能访问到网页就成功了\",{\"1\":{\"538\":1}}],[\"能简单快速的实现按钮级别的权限判断\",{\"1\":{\"457\":1}}],[\"能走多远\",{\"1\":{\"411\":1}}],[\"能更快一点点\",{\"1\":{\"291\":1}}],[\"能逃出迷宫输出\",{\"1\":{\"235\":1}}],[\"能够正确赋值\",{\"1\":{\"1475\":1}}],[\"能够获取到对象锁\",{\"1\":{\"1407\":1}}],[\"能够获得的最大数组和\",{\"1\":{\"104\":1}}],[\"能够保证线程安全\",{\"1\":{\"1388\":1}}],[\"能够保证数据更新的时候是线程安全的\",{\"1\":{\"1385\":1}}],[\"能够保证在找到路径时是最短的\",{\"1\":{\"180\":1}}],[\"能够延时执行异步任务以及能够周期执行任务\",{\"1\":{\"1369\":1}}],[\"能够延时执行任务和能周期执行任务的特性\",{\"1\":{\"1370\":1}}],[\"能够延时执行任务和周期执行任务的功能\",{\"1\":{\"1365\":1}}],[\"能够延时执行任务以及能够周期性执行任务\",{\"1\":{\"1368\":1}}],[\"能够可阻塞式的插入和删除队列元素\",{\"1\":{\"1345\":1}}],[\"能够拥有一次时间片的机会\",{\"1\":{\"1340\":1}}],[\"能够做到被多个读线程读取的话\",{\"1\":{\"1290\":1}}],[\"能够让\",{\"1\":{\"1285\":1}}],[\"能够从\",{\"1\":{\"1253\":1}}],[\"能够有机会获取\",{\"1\":{\"1253\":1}}],[\"能够有机会移入到同步队列中\",{\"1\":{\"1253\":1}}],[\"能够访问到\",{\"1\":{\"1250\":1}}],[\"能够支持超时时间的设置\",{\"1\":{\"1248\":1}}],[\"能够支持多个等待队列\",{\"1\":{\"1248\":1}}],[\"能够支持不响应中断\",{\"1\":{\"1248\":1}}],[\"能够把以\",{\"1\":{\"681\":1}}],[\"能够实现灵活的权限控制\",{\"1\":{\"445\":1}}],[\"能够受到的最少总伤害\",{\"1\":{\"110\":1}}],[\"⽤\",{\"1\":{\"229\":1}}],[\"靠边的陆地不算作封闭岛屿\",{\"1\":{\"229\":1}}],[\"淹了\",{\"1\":{\"820\":1}}],[\"淹了变成海水\",{\"1\":{\"228\":1}}],[\"淹掉\",{\"1\":{\"820\":1}}],[\"淹没\",{\"1\":{\"821\":1}}],[\"淹没岛屿\",{\"1\":{\"230\":1}}],[\"淹没与\",{\"1\":{\"230\":1}}],[\"淹\",{\"1\":{\"228\":1,\"229\":1,\"235\":1}}],[\"垂直\",{\"1\":{\"228\":1}}],[\"水\",{\"1\":{\"819\":1}}],[\"水平\",{\"1\":{\"228\":1}}],[\"水滴笔试\",{\"0\":{\"132\":1}}],[\"四\",{\"0\":{\"995\":1,\"1185\":1}}],[\"四大特性\",{\"0\":{\"955\":1}}],[\"四个方向\",{\"1\":{\"870\":1}}],[\"四个方向上连在一起的一片陆地组成一座岛屿\",{\"1\":{\"280\":1}}],[\"四个方向模拟即可\",{\"1\":{\"77\":1}}],[\"四周环绕\",{\"1\":{\"228\":1}}],[\"纵轴y方向\",{\"1\":{\"228\":1}}],[\"横轴x方向\",{\"1\":{\"228\":1}}],[\"横版游戏由\",{\"1\":{\"110\":1}}],[\"岛屿总是被水包围\",{\"1\":{\"819\":1}}],[\"岛屿边缘一个像素的范围会被海水淹没\",{\"1\":{\"280\":1}}],[\"岛屿问题\",{\"1\":{\"235\":1}}],[\"岛屿的最大面积\",{\"0\":{\"230\":1},\"1\":{\"227\":1,\"230\":1}}],[\"岛屿数量\",{\"0\":{\"228\":1,\"818\":1},\"1\":{\"227\":1,\"228\":3,\"818\":1}}],[\"恢复现场\",{\"1\":{\"279\":1,\"288\":1,\"289\":1,\"876\":1}}],[\"恢复\",{\"1\":{\"224\":1}}],[\"交出来的时间片其他线程都可以去竞争\",{\"1\":{\"1339\":1}}],[\"交集\",{\"1\":{\"1283\":2}}],[\"交集部分数据\",{\"1\":{\"943\":1}}],[\"交给实例信息管理器来管理\",{\"1\":{\"1180\":1}}],[\"交由它来管理\",{\"1\":{\"1155\":1}}],[\"交由其他的线程池并发执行\",{\"1\":{\"33\":1}}],[\"交替路\",{\"1\":{\"363\":1}}],[\"交互式的内容和功能需要等待客户端的\",{\"1\":{\"531\":1}}],[\"交互器将立即终止\",{\"1\":{\"249\":1}}],[\"交互题\",{\"0\":{\"249\":1}}],[\"交换之后脏\",{\"1\":{\"1317\":2}}],[\"交换a\",{\"1\":{\"1020\":1}}],[\"交换后得到\",{\"1\":{\"852\":1}}],[\"交换状态与状态值\",{\"1\":{\"852\":1}}],[\"交换两个点\",{\"1\":{\"417\":1}}],[\"交换两个方程的位置\",{\"1\":{\"385\":1}}],[\"交换两个数\",{\"1\":{\"338\":1}}],[\"交换某两行\",{\"1\":{\"385\":1}}],[\"交换位置\",{\"1\":{\"279\":1}}],[\"交换\",{\"1\":{\"224\":1}}],[\"交换过程如下\",{\"1\":{\"224\":1,\"279\":1}}],[\"恰好拼成\",{\"1\":{\"308\":1}}],[\"恰好不重不漏地分布在这\",{\"1\":{\"224\":1,\"279\":1}}],[\"恰好移动\",{\"1\":{\"72\":1}}],[\"短短十几年的时间\",{\"1\":{\"1218\":1}}],[\"短文本字符串\",{\"1\":{\"920\":1}}],[\"短链接生成器\",{\"1\":{\"634\":1}}],[\"短链接系统\",{\"1\":{\"634\":2}}],[\"短链文章\",{\"1\":{\"634\":1}}],[\"短连接有效期设置\",{\"1\":{\"634\":1}}],[\"短路原则\",{\"1\":{\"808\":1}}],[\"短路不存在\",{\"1\":{\"223\":1}}],[\"短路\",{\"1\":{\"223\":1}}],[\"短路的长度\",{\"1\":{\"223\":2}}],[\"短时间内点赞率高\",{\"1\":{\"39\":1}}],[\"↓\",{\"1\":{\"221\":1}}],[\"↑\",{\"1\":{\"221\":1}}],[\"证书后\",{\"1\":{\"672\":1}}],[\"证书\",{\"1\":{\"672\":1}}],[\"证明这种推论\",{\"1\":{\"1221\":1}}],[\"证明端口能连接\",{\"1\":{\"663\":1}}],[\"证明终点第一次出队列即最优解\",{\"1\":{\"221\":1}}],[\"证毕\",{\"1\":{\"221\":1}}],[\"矛盾\",{\"1\":{\"221\":1}}],[\"估计\",{\"1\":{\"221\":1}}],[\"估计距离\",{\"1\":{\"221\":1}}],[\"真正是存放在\",{\"1\":{\"1301\":1}}],[\"真正对头节点做处理的逻辑在\",{\"1\":{\"1252\":1}}],[\"真正的并行也只能出现在拥有多个\",{\"1\":{\"1224\":1}}],[\"真正的配置项在哪\",{\"0\":{\"1150\":1}}],[\"真正编码的时间只有5\",{\"1\":{\"45\":1}}],[\"真实性\",{\"1\":{\"434\":1}}],[\"真实值\",{\"1\":{\"223\":1}}],[\"真实值+估计值\",{\"1\":{\"223\":1}}],[\"真实\",{\"1\":{\"221\":1}}],[\"真实距离\",{\"1\":{\"221\":1}}],[\"←\",{\"1\":{\"221\":1}}],[\"补充题目列表分页\",{\"1\":{\"523\":1}}],[\"补充\",{\"0\":{\"221\":1}}],[\"补充说明\",{\"1\":{\"70\":1,\"71\":1,\"72\":1,\"110\":1,\"128\":1,\"135\":1}}],[\"通俗点说\",{\"1\":{\"1496\":1}}],[\"通俗的理解是当我们往一个容器添加元素的时候\",{\"1\":{\"1291\":1}}],[\"通信是指线程之间以何种机制来交换信息\",{\"1\":{\"1416\":1}}],[\"通知处于\",{\"1\":{\"1408\":1}}],[\"通知是没有任何响应的\",{\"1\":{\"1406\":1}}],[\"通知的遗漏很容易理解\",{\"1\":{\"1406\":1}}],[\"通知被阻塞的生产者线程\",{\"1\":{\"1348\":1}}],[\"通知被阻塞的线程\",{\"1\":{\"1345\":1}}],[\"通知消费者线程\",{\"1\":{\"1347\":1}}],[\"通知插入数据的线程\",{\"1\":{\"1345\":1}}],[\"通知后\",{\"1\":{\"1338\":1}}],[\"通知方\",{\"1\":{\"1253\":1}}],[\"通知\",{\"1\":{\"1252\":1,\"1348\":1}}],[\"通知机制总结三\",{\"1\":{\"1408\":1}}],[\"通知机制总结二\",{\"1\":{\"1407\":1}}],[\"通知机制总结一\",{\"1\":{\"1406\":1}}],[\"通知机制时\",{\"1\":{\"1406\":1,\"1407\":1}}],[\"通知机制来实现可阻塞式插入和删除元素\",{\"1\":{\"1353\":1}}],[\"通知机制使用\",{\"1\":{\"1258\":1}}],[\"通知机制\",{\"1\":{\"1248\":3,\"1253\":1}}],[\"通配符\",{\"1\":{\"930\":1}}],[\"通用信息\",{\"0\":{\"1194\":1}}],[\"通用语法\",{\"0\":{\"908\":1}}],[\"通用返回对象\",{\"0\":{\"598\":1}}],[\"通讯协议\",{\"1\":{\"663\":1}}],[\"通常显示使用\",{\"1\":{\"1492\":1}}],[\"通常每个类中的成员变量可以分为类变量\",{\"1\":{\"1465\":1}}],[\"通常会采用共享的数据区域\",{\"1\":{\"1402\":1}}],[\"通常会降低吞吐量\",{\"1\":{\"1326\":1}}],[\"通常可以使用\",{\"1\":{\"1392\":1}}],[\"通常可以用如下方式避免死锁的情况\",{\"1\":{\"1221\":1}}],[\"通常也可以利用\",{\"1\":{\"1330\":1}}],[\"通常在创建\",{\"1\":{\"1326\":1}}],[\"通常在生产环境中\",{\"1\":{\"484\":1}}],[\"通常我们可以使用在\",{\"1\":{\"1264\":1}}],[\"通常使用\",{\"1\":{\"1237\":1}}],[\"通常减少上下文切换可以采用无锁并发编程\",{\"1\":{\"1220\":1}}],[\"通常通过基于\",{\"1\":{\"1094\":1}}],[\"通常情况下\",{\"1\":{\"1020\":1}}],[\"通常是用来做单表的拆分\",{\"1\":{\"938\":1}}],[\"通常是一个固定的常数\",{\"1\":{\"218\":1}}],[\"通常封装到\",{\"1\":{\"935\":1}}],[\"通常需要先初始化一个虚拟头节点\",{\"1\":{\"699\":1}}],[\"通常需要满足以下要求\",{\"1\":{\"438\":1}}],[\"通常不接受用户输入\",{\"1\":{\"671\":1}}],[\"通常用于展示版权信息\",{\"1\":{\"549\":1}}],[\"通常以对象存储为基础\",{\"1\":{\"437\":1}}],[\"通常包括以下四个特征\",{\"1\":{\"434\":1}}],[\"通常给定一个\",{\"1\":{\"235\":1}}],[\"通常比所给数据范围大一点\",{\"1\":{\"228\":1}}],[\"通常来说如果\",{\"1\":{\"1504\":1}}],[\"通常来说\",{\"1\":{\"228\":1}}],[\"通过可重写的方法\",{\"1\":{\"1496\":1}}],[\"通过之前对\",{\"1\":{\"1486\":1}}],[\"通过主内存中的共享变量和线程\",{\"1\":{\"1433\":1}}],[\"通过这个现象我们就可以看出来被\",{\"1\":{\"1469\":1}}],[\"通过这个实验我们就可以看出来当\",{\"1\":{\"1467\":1}}],[\"通过这个关系我们可以得出什么\",{\"1\":{\"1432\":1}}],[\"通过这篇文章对\",{\"1\":{\"1320\":1}}],[\"通过传递性规则进一步推导的\",{\"1\":{\"1432\":1}}],[\"通过传入其他参数\",{\"1\":{\"1069\":1}}],[\"通过参数最多的构造方法来理解创建线程池有哪些需要配置的参数\",{\"1\":{\"1359\":1}}],[\"通过复用线程\",{\"1\":{\"1357\":1}}],[\"通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗\",{\"1\":{\"1357\":1}}],[\"通过一个整型成员变量\",{\"1\":{\"1339\":1}}],[\"通过一个连接起来\",{\"1\":{\"359\":1}}],[\"通过线程池创建\",{\"1\":{\"1330\":1}}],[\"通过继承\",{\"1\":{\"1330\":1}}],[\"通过源码以及示例图\",{\"1\":{\"1317\":1}}],[\"通过源码我们知道\",{\"1\":{\"1301\":1}}],[\"通过往后环形查找到与指定\",{\"1\":{\"1308\":1}}],[\"通过注释可以看出\",{\"1\":{\"1305\":1}}],[\"通过注释就很清楚了\",{\"1\":{\"1270\":1}}],[\"通过当前线程\",{\"1\":{\"1302\":1}}],[\"通过当前线程对象\",{\"1\":{\"1301\":1}}],[\"通过当前线程实例获取到threadlocalmap对象\",{\"1\":{\"1301\":1}}],[\"通过第\",{\"1\":{\"1295\":1}}],[\"通过延时更新的策略来实现数据的最终一致性\",{\"1\":{\"1291\":1}}],[\"通过牺牲数据实时性满足数据的最终一致性\",{\"1\":{\"1291\":1}}],[\"通过读写共享变量实现两个线程间协作\",{\"1\":{\"1416\":1}}],[\"通过读写锁\",{\"1\":{\"1290\":1}}],[\"通过读写分离的思想\",{\"1\":{\"1290\":1}}],[\"通过上面的讨论大概能了解\",{\"1\":{\"1434\":1}}],[\"通过上面的例子我们能够看出\",{\"1\":{\"1467\":1}}],[\"通过上面的例子\",{\"1\":{\"1416\":1}}],[\"通过上面的分析\",{\"1\":{\"1407\":1}}],[\"通过上面对\",{\"1\":{\"1286\":1}}],[\"通过上面五个体系\",{\"1\":{\"1141\":1}}],[\"通过让\",{\"1\":{\"1284\":1}}],[\"通过对单线程执行角度进行分析\",{\"1\":{\"1283\":1}}],[\"通过对敏感数据进行修改或者替换的方\",{\"1\":{\"574\":1}}],[\"通过看节点的\",{\"1\":{\"1273\":1}}],[\"通过底层\",{\"1\":{\"1266\":1}}],[\"通过分别调用这两个方法然后\",{\"1\":{\"1259\":1}}],[\"通过分析之后可以看出\",{\"1\":{\"1431\":1}}],[\"通过分析\",{\"1\":{\"1232\":1,\"1250\":1}}],[\"通过分析新增定时任务的源码\",{\"1\":{\"482\":1}}],[\"通过分析每一步的移动情况\",{\"1\":{\"72\":1}}],[\"通过使用散列函数\",{\"1\":{\"1306\":1}}],[\"通过使用\",{\"1\":{\"1253\":1}}],[\"通过我们的猜想然后进行实验验证\",{\"1\":{\"1250\":1}}],[\"通过持有头尾指针管理同步队列\",{\"1\":{\"1501\":1}}],[\"通过持有头尾指针进行管理队列\",{\"1\":{\"1281\":1}}],[\"通过持有等待队列的头尾指针来管理等待队列\",{\"1\":{\"1250\":1}}],[\"通过持续演进架构设计\",{\"1\":{\"21\":1}}],[\"通过获取自增\",{\"1\":{\"1231\":1}}],[\"通过并发编程的形式可以将多核cpu的计算能力发挥到极致\",{\"1\":{\"1218\":1}}],[\"通过调用\",{\"1\":{\"1184\":1,\"1508\":1}}],[\"通过调节启发函数我们可以控制算法的速度和精确度\",{\"1\":{\"216\":1}}],[\"通过接口来获取配置信息\",{\"1\":{\"1178\":1}}],[\"通过接口的\",{\"1\":{\"1153\":1}}],[\"通过官方注释可以知道这个类的作用\",{\"1\":{\"1160\":1}}],[\"通过名字可以知道是\",{\"1\":{\"1160\":1}}],[\"通过数学算法将数据分割成多个数据块和校验块\",{\"1\":{\"1095\":1}}],[\"通过数据库的优化来提高数据库的访问性能\",{\"1\":{\"910\":1}}],[\"通过数据权限控制\",{\"1\":{\"470\":1}}],[\"通过引用找到变量的真正地址\",{\"1\":{\"1018\":1}}],[\"通过下标访问数组\",{\"1\":{\"999\":1}}],[\"通过下式\",{\"1\":{\"263\":1}}],[\"通过索引列对数据进行排序\",{\"1\":{\"957\":1}}],[\"通过逻辑外键\",{\"1\":{\"937\":1}}],[\"通过指令\",{\"1\":{\"912\":1}}],[\"通过观察\",{\"1\":{\"894\":1}}],[\"通过以上三步\",{\"1\":{\"766\":1}}],[\"通过多种存储策略的支持\",{\"1\":{\"669\":1}}],[\"通过多级冗余与跨级合并\",{\"1\":{\"40\":1}}],[\"通过反向代理到请求\",{\"1\":{\"586\":1}}],[\"通过命令安装整合包\",{\"1\":{\"539\":1}}],[\"通过水合\",{\"1\":{\"535\":1}}],[\"通过配置的再生成间隔\",{\"1\":{\"534\":1}}],[\"通过在服务器端生成页面的初始\",{\"1\":{\"533\":1}}],[\"通过在客户端浏览器执行\",{\"1\":{\"532\":1}}],[\"通过异步请求和前端\",{\"1\":{\"532\":1}}],[\"通过关联表转换为了多个题目\",{\"1\":{\"525\":1}}],[\"通过万用模板已完成用户模块的开发\",{\"1\":{\"521\":1}}],[\"通过访问\",{\"1\":{\"520\":1}}],[\"通过给题库\",{\"1\":{\"513\":1}}],[\"通过流量控制\",{\"1\":{\"493\":1}}],[\"通过jobbuilder类创建\",{\"1\":{\"479\":1}}],[\"通过实现callable接口\",{\"1\":{\"1330\":1}}],[\"通过实现\",{\"1\":{\"471\":1,\"1330\":2}}],[\"通过角色部门表\",{\"1\":{\"471\":1}}],[\"通过添加如下语句\",{\"1\":{\"471\":1}}],[\"通过路由\",{\"1\":{\"463\":1}}],[\"通过定理求组合数c\",{\"1\":{\"389\":1}}],[\"通过预处理逆元的方式求组和数\",{\"0\":{\"388\":1}}],[\"通过初等行变换把\",{\"1\":{\"385\":1}}],[\"通过替换旧值为向量元素分配新值\",{\"1\":{\"254\":1}}],[\"通过\",{\"1\":{\"251\":3,\"390\":1,\"511\":1,\"525\":1,\"532\":1,\"592\":1,\"670\":1,\"1250\":2,\"1253\":1,\"1272\":1,\"1283\":1,\"1284\":3,\"1307\":1,\"1313\":1,\"1359\":1,\"1368\":1,\"1375\":1,\"1386\":1,\"1407\":1,\"1458\":1,\"1496\":1,\"1508\":1}}],[\"通过填充这个数组\",{\"1\":{\"127\":1}}],[\"通过维护一个计数器来跟踪当前连续字符的数量\",{\"1\":{\"82\":1}}],[\"通过计算\",{\"1\":{\"72\":1}}],[\"通过增量加载的方式逐渐预热填充缓存\",{\"1\":{\"58\":1}}],[\"通过冗余数据的方式\",{\"1\":{\"50\":1}}],[\"通过冗余校验\",{\"1\":{\"36\":1}}],[\"通过组合与继承\",{\"1\":{\"40\":1}}],[\"通过梳理依赖关系和推导计算\",{\"1\":{\"40\":1}}],[\"通过召回机制来实现想要的\",{\"1\":{\"40\":1}}],[\"通过前面列出的公式\",{\"1\":{\"33\":1}}],[\"曼哈顿距离\",{\"0\":{\"218\":1},\"1\":{\"216\":1,\"218\":1}}],[\"产生了循环依赖\",{\"1\":{\"875\":1}}],[\"产生效果\",{\"1\":{\"216\":1}}],[\"产品上\",{\"1\":{\"56\":1,\"437\":1}}],[\"产品侧定义是\",{\"1\":{\"30\":1}}],[\"产品形态上\",{\"1\":{\"30\":1}}],[\"始终小于等于节点\",{\"1\":{\"216\":1}}],[\"始终为0\",{\"1\":{\"216\":1}}],[\"决定了一个线程对共享变量的写入何时对其他线程是可见的\",{\"1\":{\"1417\":1}}],[\"决定后面的逻辑走向的\",{\"1\":{\"1283\":1}}],[\"决定节点的优先级\",{\"1\":{\"216\":1}}],[\"决策豁免等\",{\"1\":{\"40\":1}}],[\"距离最近的点\",{\"1\":{\"360\":1}}],[\"距离都初始化为无穷大\",{\"1\":{\"352\":1}}],[\"距离终点的预计代价\",{\"1\":{\"215\":1}}],[\"距离起点的代价\",{\"1\":{\"215\":1}}],[\"值也是相等的\",{\"1\":{\"1472\":1}}],[\"值为\",{\"1\":{\"1301\":3,\"1305\":1}}],[\"值为value进行存入\",{\"1\":{\"1301\":1}}],[\"值即可\",{\"1\":{\"1272\":1}}],[\"值相同的节点组成的链表的头节点\",{\"1\":{\"1272\":1}}],[\"值相同的节点构成链表的形式\",{\"1\":{\"1272\":1}}],[\"值相等并且\",{\"1\":{\"1272\":1}}],[\"值大于\",{\"1\":{\"1272\":1}}],[\"值是否为小于\",{\"1\":{\"1273\":1}}],[\"值是不是等于\",{\"1\":{\"1272\":1}}],[\"值是0x3f3f3f3f\",{\"1\":{\"360\":1}}],[\"值与数组的长度取模操作\",{\"1\":{\"1272\":1}}],[\"值能够分散能够均匀减小\",{\"1\":{\"1272\":1}}],[\"值分散的不够均匀的话会大大增加哈希冲突的概率\",{\"1\":{\"1272\":1}}],[\"值变为\",{\"1\":{\"1271\":1}}],[\"值得好好认识一番\",{\"1\":{\"1290\":1}}],[\"值得收藏的\",{\"0\":{\"1189\":1},\"1\":{\"1189\":1}}],[\"值得注意的是\",{\"1\":{\"846\":1}}],[\"值传递\",{\"0\":{\"1017\":1}}],[\"值2\",{\"1\":{\"925\":6,\"926\":1}}],[\"值1\",{\"1\":{\"925\":6,\"926\":1}}],[\"值\",{\"1\":{\"868\":3,\"1201\":1,\"1233\":1,\"1272\":1}}],[\"值最小\",{\"1\":{\"215\":2}}],[\"值等于另一个整数的平方\",{\"1\":{\"115\":1}}],[\"函数在类的每个对象中都有独立的一份\",{\"1\":{\"1027\":1}}],[\"函数在类中只有一份\",{\"1\":{\"1027\":1}}],[\"函数与普通成员变量\",{\"1\":{\"1027\":1}}],[\"函数完美地打包在一起\",{\"1\":{\"1024\":1}}],[\"函数递归\",{\"0\":{\"1023\":1}}],[\"函数名必须相同\",{\"1\":{\"1052\":1}}],[\"函数名和参数列表必须相同\",{\"1\":{\"1052\":1}}],[\"函数名称相同但参数列表不同\",{\"1\":{\"1022\":1}}],[\"函数名字是\",{\"1\":{\"1010\":1}}],[\"函数名字\",{\"1\":{\"1009\":1}}],[\"函数重载\",{\"0\":{\"1022\":1},\"1\":{\"1022\":1}}],[\"函数如果想在它的中间位置提前退出\",{\"1\":{\"1020\":1}}],[\"函数内定义的变量为局部变量\",{\"1\":{\"1015\":1}}],[\"函数及其区别会在下一章中介绍\",{\"1\":{\"1015\":1}}],[\"函数返回类型\",{\"0\":{\"1014\":1}}],[\"函数基础\",{\"0\":{\"1009\":1}}],[\"函数遍历到值为\",{\"1\":{\"820\":1}}],[\"函数使用\",{\"1\":{\"252\":1}}],[\"函数的区别\",{\"1\":{\"1027\":1}}],[\"函数的返回类型也可以是数组\",{\"1\":{\"1014\":1}}],[\"函数的返回值是统计以\",{\"1\":{\"881\":1}}],[\"函数的形参列表可以为空\",{\"1\":{\"1013\":1}}],[\"函数的形参列表\",{\"0\":{\"1013\":1}}],[\"函数的调用完成两项工作\",{\"1\":{\"1011\":1}}],[\"函数的头文件是\",{\"1\":{\"251\":1}}],[\"函数的第一个参数类型是\",{\"1\":{\"251\":1}}],[\"函数转换\",{\"1\":{\"251\":1}}],[\"函数输出字符串是针对\",{\"1\":{\"243\":1}}],[\"函数中迷宫出口的判断条件稍加修改即可\",{\"1\":{\"237\":1}}],[\"函数中判断能否找到出口\",{\"1\":{\"235\":1}}],[\"函数淹没岛屿的同时\",{\"1\":{\"230\":1}}],[\"函数\",{\"0\":{\"1008\":1},\"1\":{\"215\":1,\"251\":1,\"254\":1,\"596\":1,\"686\":1,\"688\":1,\"932\":1,\"1036\":1,\"1037\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1052\":1}}],[\"函数有以下三种声明\",{\"1\":{\"200\":1}}],[\"由原子性变量操作\",{\"1\":{\"1482\":1}}],[\"由此来确定这个值在\",{\"1\":{\"1272\":1}}],[\"由此就构成了一条路径\",{\"1\":{\"212\":1}}],[\"由所有参数构成的用空格隔开的字符串\",{\"1\":{\"1120\":1}}],[\"由安全管理器抛出的异常\",{\"1\":{\"1045\":1}}],[\"由0个或多个形参组成的列表以及函数体\",{\"1\":{\"1009\":1}}],[\"由题意可知\",{\"1\":{\"899\":1}}],[\"由它们之间边数表示\",{\"1\":{\"759\":1}}],[\"由\",{\"1\":{\"517\":1,\"1251\":1,\"1432\":1}}],[\"由数据库自动更新\",{\"1\":{\"510\":1}}],[\"由两名玩家交替行动\",{\"1\":{\"395\":1}}],[\"由抽屉原理一定有两个点相同\",{\"1\":{\"356\":1}}],[\"由抽屉原理\",{\"1\":{\"354\":1}}],[\"由上面这些信息我们可以知道\",{\"1\":{\"216\":1}}],[\"由于不会对有间接依赖性的操作重排序\",{\"1\":{\"1477\":1}}],[\"由于对\",{\"1\":{\"1476\":1}}],[\"由于这两个操作可以在一个线程之内\",{\"1\":{\"1420\":1}}],[\"由于这个数字可能很大\",{\"1\":{\"167\":1}}],[\"由于处理器使用缓存和读\",{\"1\":{\"1418\":1}}],[\"由于获取不到许可\",{\"1\":{\"1398\":1}}],[\"由于往线程池提交了\",{\"1\":{\"1392\":1}}],[\"由于它是基于堆结构的队列\",{\"1\":{\"1369\":1}}],[\"由于该队列实现了\",{\"1\":{\"1326\":1}}],[\"由于读写锁的特性\",{\"1\":{\"1290\":1}}],[\"由于独占式锁在同一时刻只有一个线程能够获取到对象监视器\",{\"1\":{\"1290\":1}}],[\"由于此时队列为空队列\",{\"1\":{\"1284\":1}}],[\"由于锁会被获取\",{\"1\":{\"1232\":1}}],[\"由于上下文切换也是个相对比较耗时的操作\",{\"1\":{\"1220\":1}}],[\"由于上文所述各类\",{\"1\":{\"33\":1}}],[\"由于业务之间相互关联\",{\"1\":{\"936\":1}}],[\"由于每个线程在同一时刻共享对象只能被一个线程访问造成整体上响应时间增加\",{\"1\":{\"1313\":1}}],[\"由于每个数\",{\"1\":{\"795\":1}}],[\"由于每个单元格只能放置一种花卉\",{\"1\":{\"141\":1}}],[\"由于可能会删除链表头部\",{\"1\":{\"778\":1}}],[\"由于是根据前序遍历的节点来确定中序遍历中节点的位置\",{\"1\":{\"766\":1}}],[\"由于是每个点同时向外出发\",{\"1\":{\"354\":1}}],[\"由于以当前结点为根结点的子树中的大于右子结点值的结点数等于\",{\"1\":{\"712\":1}}],[\"由于存在负数\",{\"1\":{\"705\":1}}],[\"由于存在性判定和增量追加不是原子化的\",{\"1\":{\"31\":1}}],[\"由于配置了\",{\"1\":{\"592\":1}}],[\"由于页面的渲染逻辑在服务器端执行\",{\"1\":{\"533\":1}}],[\"由于服务器仅需提供静态文件\",{\"1\":{\"534\":1}}],[\"由于服务器端已经生成了完整的\",{\"1\":{\"533\":1}}],[\"由于服务器在渲染过程中已经将页面的大部分内容生成\",{\"1\":{\"533\":1}}],[\"由于初次加载的页面内容较少\",{\"1\":{\"532\":1}}],[\"由于需要下载和执行\",{\"1\":{\"532\":1}}],[\"由于只需要获取基本的\",{\"1\":{\"532\":1}}],[\"由于在第二趟搜索中发现脏\",{\"1\":{\"1316\":1}}],[\"由于在写数据的时候\",{\"1\":{\"1294\":1}}],[\"由于在建表时\",{\"1\":{\"567\":1}}],[\"由于在题库题目关联表中已经添加了\",{\"1\":{\"526\":1}}],[\"由于在除法运算中\",{\"1\":{\"330\":1}}],[\"由于题目和题库是通过关联表维护关系的\",{\"1\":{\"525\":1}}],[\"由于同一个题库内的题目不会很多\",{\"1\":{\"525\":1}}],[\"由于关联表中的数据记录并没有那么重要\",{\"1\":{\"513\":1}}],[\"由于一个\",{\"1\":{\"1476\":1}}],[\"由于一个没有捕获到的异常终止了\",{\"1\":{\"1333\":1}}],[\"由于一个题库可以有多个题目\",{\"1\":{\"513\":1}}],[\"由于一般只查询\",{\"1\":{\"56\":1}}],[\"由于用户很可能按照标题搜索题库\",{\"1\":{\"511\":1}}],[\"由于某个点染色成功并不代表整个图就是二分图\",{\"1\":{\"362\":1}}],[\"由于全球变暖导致了海面上升\",{\"1\":{\"280\":1}}],[\"由于答案可能很大\",{\"1\":{\"196\":1}}],[\"由于答案过大所以你需要返回答案对\",{\"1\":{\"135\":1}}],[\"由于结果可能非常大\",{\"1\":{\"182\":1}}],[\"由于地图规模较小\",{\"1\":{\"180\":1}}],[\"由于数组中的元素大小都满足\",{\"1\":{\"178\":1}}],[\"由于数值相同的两个数被视为不同的数\",{\"1\":{\"126\":1}}],[\"由于广告点击量大\",{\"1\":{\"151\":1}}],[\"由于体力限制和路径最短的要求\",{\"1\":{\"142\":1}}],[\"由于本题输出较多\",{\"1\":{\"128\":2}}],[\"由于字典序要求最小\",{\"1\":{\"119\":1}}],[\"由于种种限制\",{\"1\":{\"66\":1}}],[\"由于排序问题的解决方案是探索型的\",{\"1\":{\"40\":1}}],[\"由于\",{\"1\":{\"40\":1,\"182\":1,\"540\":1,\"795\":1,\"814\":1,\"820\":1,\"1140\":1,\"1283\":1,\"1284\":3,\"1285\":2,\"1330\":1,\"1333\":1,\"1375\":1,\"1407\":1,\"1411\":1,\"1418\":1,\"1422\":1,\"1475\":1}}],[\"由于扫描行数约等于\",{\"1\":{\"40\":1}}],[\"由于评论业务的下游依赖较多\",{\"1\":{\"33\":1}}],[\"由于评论内容是大字段\",{\"1\":{\"30\":1}}],[\"由于大量接口都需要读取评论区基础信息\",{\"1\":{\"33\":1}}],[\"由于列表是分页的\",{\"1\":{\"28\":1}}],[\"反应到\",{\"1\":{\"1482\":1}}],[\"反制面试官\",{\"1\":{\"1145\":1}}],[\"反射\",{\"0\":{\"1054\":1},\"1\":{\"1054\":1}}],[\"反复利用同一个长为\",{\"1\":{\"797\":1}}],[\"反复思考\",{\"1\":{\"45\":1}}],[\"反转区间\",{\"1\":{\"682\":1}}],[\"反转前\",{\"1\":{\"682\":1}}],[\"反过来去拿就好\",{\"1\":{\"1302\":1}}],[\"反过来\",{\"1\":{\"438\":1}}],[\"反过来顺着父节点的顺序找到起点\",{\"1\":{\"212\":1}}],[\"反之亦然\",{\"1\":{\"755\":1}}],[\"反之则为\",{\"1\":{\"392\":1}}],[\"反之\",{\"1\":{\"383\":1,\"1306\":1,\"1383\":1,\"1437\":1,\"1504\":1}}],[\"反之为\",{\"1\":{\"381\":1}}],[\"反证法证明\",{\"1\":{\"368\":1}}],[\"反向代理通常由服务器管理员配置\",{\"1\":{\"586\":1}}],[\"反向代理主要用于服务器端的负载均衡\",{\"1\":{\"586\":1}}],[\"反向代理靠近服务器端\",{\"1\":{\"586\":1}}],[\"反向代理\",{\"1\":{\"586\":1}}],[\"反向搜索\",{\"1\":{\"223\":1}}],[\"反向建边求终点到各点的距离作为估计值\",{\"1\":{\"223\":1}}],[\"便会一直阻塞等待\",{\"1\":{\"1406\":1}}],[\"便于数据的排序及区间范围查询\",{\"1\":{\"958\":1}}],[\"便于后续的获取题目列表接口复用\",{\"1\":{\"525\":1}}],[\"便于后续求出\",{\"1\":{\"174\":1}}],[\"便于直接对余数进行处理\",{\"1\":{\"330\":1}}],[\"便可以从终点开始\",{\"1\":{\"212\":1}}],[\"广搜需要通过队列实现\",{\"1\":{\"821\":1}}],[\"广度优先搜索以广度做为优先级进行搜索\",{\"1\":{\"212\":1}}],[\"广度优先搜索\",{\"0\":{\"212\":1}}],[\"广告等\",{\"1\":{\"22\":1}}],[\"念做\",{\"1\":{\"210\":1}}],[\"背包的递推公式为\",{\"1\":{\"772\":1}}],[\"背包的体积为\",{\"1\":{\"772\":1}}],[\"背包就装满了\",{\"1\":{\"772\":1}}],[\"背包中每一个元素是不可重复放入\",{\"1\":{\"772\":1}}],[\"背包如果正好装满\",{\"1\":{\"772\":1}}],[\"背包要放入的商品\",{\"1\":{\"772\":1}}],[\"背包容量为\",{\"1\":{\"296\":1,\"297\":1,\"298\":1,\"893\":1}}],[\"背包\",{\"0\":{\"296\":1}}],[\"背包问题常用枚举方法\",{\"1\":{\"295\":1}}],[\"背包问题\",{\"0\":{\"295\":1},\"1\":{\"772\":1},\"2\":{\"208\":1,\"774\":1,\"799\":1,\"896\":1}}],[\"背景\",{\"0\":{\"21\":1}}],[\"购买会员后\",{\"1\":{\"475\":1}}],[\"购买商品种类和购买数量\",{\"1\":{\"168\":1}}],[\"购物\",{\"0\":{\"204\":1}}],[\"拼插入到目的\",{\"1\":{\"200\":1}}],[\"拼接字符串\",{\"1\":{\"1007\":1,\"1069\":1,\"1070\":1}}],[\"拼接的功能\",{\"1\":{\"200\":1}}],[\"拼接\",{\"0\":{\"888\":1},\"1\":{\"181\":1}}],[\"变得不可使用\",{\"1\":{\"1072\":1}}],[\"变长字符串\",{\"1\":{\"920\":1}}],[\"变长数组\",{\"1\":{\"422\":1,\"1036\":1}}],[\"变换\",{\"1\":{\"385\":1}}],[\"变换串\",{\"1\":{\"279\":1}}],[\"变\",{\"1\":{\"338\":2}}],[\"变量不需要与其他的状态变量共同参与不变约束\",{\"1\":{\"1482\":1}}],[\"变量初始化后的值\",{\"1\":{\"1475\":1}}],[\"变量未进行初始化\",{\"1\":{\"1466\":1}}],[\"变量未初始化时系统不会进行隐式初始化\",{\"1\":{\"1465\":1}}],[\"变量时就指定了初始值\",{\"1\":{\"1467\":1}}],[\"变量时就像是接收了线程\",{\"1\":{\"1456\":1}}],[\"变量时\",{\"1\":{\"1456\":1}}],[\"变量可以通过缓存一致性协议保证每个线程都能获得最新值\",{\"1\":{\"1455\":1}}],[\"变量通过这样的机制就使得每个线程都能获得该变量的最新值\",{\"1\":{\"1454\":1}}],[\"变量当作一个普通变量来对待\",{\"1\":{\"1423\":1}}],[\"变量只会被单个线程访问\",{\"1\":{\"1423\":1}}],[\"变量规则\",{\"1\":{\"1421\":1,\"1455\":1}}],[\"变量都能够强制刷新到主存\",{\"1\":{\"1417\":1}}],[\"变量值\",{\"1\":{\"1406\":1}}],[\"变量赋值\",{\"1\":{\"1305\":1}}],[\"变量的不可更改性\",{\"1\":{\"1467\":1}}],[\"变量的内存变化示意图\",{\"1\":{\"1456\":1}}],[\"变量的读\",{\"1\":{\"1455\":1}}],[\"变量的写\",{\"1\":{\"1455\":1}}],[\"变量的修改会立刻被其他线程所感知\",{\"1\":{\"1453\":1}}],[\"变量的更新类\",{\"1\":{\"1385\":1}}],[\"变量的值\",{\"1\":{\"1301\":1,\"1302\":1,\"1406\":1}}],[\"变量的变化吗\",{\"1\":{\"1295\":1}}],[\"变量的作用域\",{\"0\":{\"1015\":1}}],[\"变量写后\",{\"1\":{\"1456\":1}}],[\"变量写\",{\"1\":{\"1295\":1}}],[\"变量定义成了\",{\"1\":{\"1145\":1}}],[\"变量定义的方式\",{\"1\":{\"978\":1}}],[\"变量类型\",{\"0\":{\"1116\":1}}],[\"变量必须先定义\",{\"1\":{\"978\":1}}],[\"变量\",{\"0\":{\"978\":1,\"1111\":1,\"1464\":1},\"1\":{\"255\":2,\"1027\":3,\"1147\":1,\"1164\":1,\"1385\":2,\"1407\":1,\"1438\":1,\"1455\":1,\"1458\":1}}],[\"变为了成\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"变为海水\",{\"1\":{\"230\":1}}],[\"变为\",{\"1\":{\"199\":1,\"306\":1,\"1387\":1}}],[\"变成了哈希数组的长度\",{\"1\":{\"1315\":1}}],[\"变成线程安全的也可以使用\",{\"1\":{\"1280\":1}}],[\"变成b\",{\"1\":{\"306\":1}}],[\"变成\",{\"1\":{\"120\":2}}],[\"染色失败\",{\"1\":{\"362\":1}}],[\"染色可以使用\",{\"1\":{\"362\":1}}],[\"染色法判别二分图\",{\"0\":{\"362\":1}}],[\"染色\",{\"0\":{\"198\":1}}],[\"查看字节码文件\",{\"1\":{\"1431\":1}}],[\"查看元素\",{\"1\":{\"1325\":1}}],[\"查看栈顶元素\",{\"1\":{\"1075\":1}}],[\"查看索引\",{\"1\":{\"959\":1}}],[\"查看指定表结构\",{\"1\":{\"921\":1}}],[\"查看状态\",{\"1\":{\"671\":1}}],[\"查看当前所有\",{\"1\":{\"663\":1}}],[\"查看防火墙端口\",{\"1\":{\"663\":1}}],[\"查看防火墙规则\",{\"1\":{\"663\":1}}],[\"查看防火墙状态并开启\",{\"1\":{\"663\":1}}],[\"查看端口是否放行成功\",{\"1\":{\"663\":1}}],[\"查看端口号命令\",{\"1\":{\"663\":1}}],[\"查看\",{\"1\":{\"592\":1,\"663\":1,\"958\":1}}],[\"查看版本情况\",{\"1\":{\"538\":1}}],[\"查看题目详情\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"查看题库详情\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"查看题库列表\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"查找到则返回该节点的value\",{\"1\":{\"1273\":1}}],[\"查找等算法\",{\"1\":{\"1272\":1}}],[\"查找一个节点会出现时间复杂度为\",{\"1\":{\"1272\":1}}],[\"查找一个数\",{\"1\":{\"422\":1}}],[\"查找\",{\"1\":{\"1005\":1}}],[\"查找和删除操作\",{\"1\":{\"972\":1}}],[\"查找操作\",{\"1\":{\"971\":1}}],[\"查找字典树是否包含word前缀\",{\"1\":{\"803\":1}}],[\"查找前缀\",{\"1\":{\"802\":1}}],[\"查找每个键值对的元素\",{\"1\":{\"422\":1}}],[\"查找父节点\",{\"1\":{\"274\":1}}],[\"查找根节点\",{\"1\":{\"273\":1}}],[\"查找符合条件的格子即可\",{\"1\":{\"197\":1}}],[\"查询同步队列中等待线程情况\",{\"1\":{\"1495\":1}}],[\"查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法\",{\"1\":{\"1375\":1}}],[\"查询快\",{\"1\":{\"1072\":1}}],[\"查询两表或多表中交集部分数据\",{\"1\":{\"944\":1}}],[\"查询右表所有数据\",{\"1\":{\"943\":1}}],[\"查询左表所有数据\",{\"1\":{\"943\":1}}],[\"查询页码\",{\"1\":{\"935\":1}}],[\"查询记录数\",{\"1\":{\"935\":1}}],[\"查询其他字段无任何意义\",{\"1\":{\"933\":1}}],[\"查询的字段一般为聚合函数和分组字段\",{\"1\":{\"933\":1}}],[\"查询所有字段\",{\"1\":{\"930\":1}}],[\"查询所有数据库\",{\"1\":{\"912\":1}}],[\"查询多个字段\",{\"1\":{\"930\":1}}],[\"查询分为以下几种类型\",{\"1\":{\"929\":1}}],[\"查询语句\",{\"1\":{\"929\":1}}],[\"查询指定表的建表语句\",{\"1\":{\"921\":1}}],[\"查询表\",{\"1\":{\"916\":1}}],[\"查询当前数据库所有表\",{\"1\":{\"921\":1}}],[\"查询当前数据库\",{\"1\":{\"912\":1}}],[\"查询用户表和部门表中的数据\",{\"1\":{\"942\":1}}],[\"查询用户\",{\"0\":{\"578\":1},\"1\":{\"578\":1}}],[\"查询用户是否存在\",{\"1\":{\"575\":1}}],[\"查询关联表的时候\",{\"1\":{\"525\":1}}],[\"查询题库内的题目列表\",{\"1\":{\"525\":1}}],[\"查询题库封装类\",{\"1\":{\"523\":1}}],[\"查询从题目表查询到题目的完整信息\",{\"1\":{\"525\":1}}],[\"查询数据库当中是否存在相同用户名\",{\"1\":{\"568\":1}}],[\"查询数据库\",{\"0\":{\"912\":1},\"1\":{\"523\":1,\"525\":2}}],[\"查询时从多张表中获取所需数据\",{\"1\":{\"942\":1}}],[\"查询时\",{\"1\":{\"523\":1}}],[\"查询时间序一级评论列表\",{\"1\":{\"30\":1}}],[\"查询条件等代码\",{\"1\":{\"519\":1}}],[\"查询底部标签添加数据范围过滤\",{\"1\":{\"471\":1}}],[\"查询菜单树信息\",{\"1\":{\"462\":1}}],[\"查询该用户权限\",{\"1\":{\"456\":1}}],[\"查询该用户角色集合\",{\"1\":{\"456\":1}}],[\"查询字符串出现的次数\",{\"1\":{\"412\":1}}],[\"查询一定要进行路径压缩\",{\"1\":{\"270\":1}}],[\"查询排名至少\",{\"1\":{\"129\":1}}],[\"查询排名\",{\"1\":{\"129\":1}}],[\"查询还需要回表\",{\"1\":{\"57\":1}}],[\"查询\",{\"0\":{\"270\":1,\"921\":1},\"1\":{\"40\":1,\"129\":1,\"267\":1,\"911\":1}}],[\"查询性能也天差万别\",{\"1\":{\"40\":1}}],[\"查询压力也会非常大\",{\"1\":{\"40\":1}}],[\"查询xxx评论基础信息\",{\"1\":{\"31\":1}}],[\"查询xxx评论列表\",{\"1\":{\"31\":1}}],[\"查询评论区基础信息\",{\"1\":{\"30\":1,\"31\":1}}],[\"五\",{\"0\":{\"1003\":1}}],[\"五条\",{\"1\":{\"196\":1}}],[\"五个整数\",{\"1\":{\"156\":1}}],[\"棋盘\",{\"0\":{\"195\":1}}],[\"斤草\",{\"1\":{\"193\":1}}],[\"块中释放锁\",{\"1\":{\"1492\":1}}],[\"块中执行\",{\"1\":{\"1340\":1}}],[\"块中的代码\",{\"1\":{\"1340\":1,\"1506\":1}}],[\"块中的语句\",{\"1\":{\"1340\":1}}],[\"块中\",{\"1\":{\"1340\":1}}],[\"块\",{\"1\":{\"1284\":1}}],[\"块盘\",{\"1\":{\"1095\":2}}],[\"块的量\",{\"1\":{\"194\":1}}],[\"块能吃的量\",{\"1\":{\"194\":1}}],[\"块草地能吃的最大值\",{\"1\":{\"194\":1}}],[\"块草地上时\",{\"1\":{\"193\":1}}],[\"块草地上有\",{\"1\":{\"193\":1}}],[\"块草地\",{\"1\":{\"193\":3}}],[\"块地块\",{\"1\":{\"128\":1}}],[\"无任何引用方便\",{\"1\":{\"1505\":1}}],[\"无疑内存会大很多\",{\"1\":{\"1299\":1}}],[\"无疑如果一个\",{\"1\":{\"1290\":1}}],[\"无疑可以大大提升入队的操作效率\",{\"1\":{\"1286\":1}}],[\"无非就是类似对对象的一个标志\",{\"1\":{\"1440\":1}}],[\"无非就是一个死循环\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"无非就是多循环几次通过\",{\"1\":{\"1283\":1}}],[\"无非就是将配置文件\",{\"1\":{\"1141\":1}}],[\"无锁状态\",{\"1\":{\"1440\":1}}],[\"无锁操作是使用\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"无锁操作以保证\",{\"1\":{\"1264\":1}}],[\"无锁并发编程\",{\"1\":{\"1220\":1}}],[\"无论为\",{\"1\":{\"1371\":1}}],[\"无论是标准输出还是错误输出\",{\"1\":{\"1087\":1}}],[\"无论如何操作\",{\"1\":{\"394\":1}}],[\"无返回值函数\",{\"0\":{\"1020\":1}}],[\"无符号\",{\"1\":{\"920\":1}}],[\"无重复节点值\",{\"1\":{\"766\":1}}],[\"无需计算\",{\"1\":{\"797\":1}}],[\"无需额外定义数据结构\",{\"1\":{\"713\":1}}],[\"无需复杂的前后端交互逻辑\",{\"1\":{\"534\":1}}],[\"无解\",{\"1\":{\"385\":1}}],[\"无向图\",{\"1\":{\"352\":1}}],[\"无向图是没有拓扑序列的\",{\"1\":{\"349\":1}}],[\"无向图就再写一遍\",{\"1\":{\"345\":1}}],[\"无法结束\",{\"1\":{\"988\":1}}],[\"无法完成所有课程\",{\"1\":{\"875\":1}}],[\"无法和前面对字符组成有效括号对\",{\"1\":{\"846\":1}}],[\"无法和其之前的元素组成有效的括号对\",{\"1\":{\"846\":1}}],[\"无法继续向下处理了\",{\"1\":{\"730\":1}}],[\"无法返回结果\",{\"1\":{\"699\":1}}],[\"无法使用其他应用程序\",{\"1\":{\"671\":1}}],[\"无法查阅到想要的\",{\"1\":{\"661\":1}}],[\"无法删除元素\",{\"1\":{\"613\":2}}],[\"无法直接注入\",{\"1\":{\"446\":1}}],[\"无法存储上一节点\",{\"1\":{\"403\":1}}],[\"无法移动者判负\",{\"1\":{\"396\":1}}],[\"无法形成最短路\",{\"1\":{\"352\":1}}],[\"无法通过一个\",{\"1\":{\"1313\":1}}],[\"无法通过\",{\"1\":{\"235\":1}}],[\"无法与\",{\"1\":{\"187\":1}}],[\"无限制访问所有数据\",{\"1\":{\"470\":1}}],[\"无限\",{\"1\":{\"72\":1}}],[\"母牛问题\",{\"1\":{\"182\":1}}],[\"母牛开始生小母牛\",{\"1\":{\"182\":1}}],[\"矩阵快速幂技巧练习\",{\"1\":{\"182\":1}}],[\"待执行时间越靠近的任务放置队头\",{\"1\":{\"1371\":1}}],[\"待删除节点\",{\"1\":{\"1284\":1}}],[\"待更新\",{\"1\":{\"182\":1}}],[\"待匹配的字符串\",{\"1\":{\"127\":1}}],[\"待匹配字符串的长度不超过\",{\"1\":{\"127\":1}}],[\"年龄值以及锁标志位等信息\",{\"1\":{\"1440\":1}}],[\"年份值\",{\"1\":{\"920\":1}}],[\"年已经成熟并且可以生小母牛\",{\"1\":{\"182\":1}}],[\"年的所有牛\",{\"1\":{\"182\":2}}],[\"年的牛的数量由以下几部分组成\",{\"1\":{\"182\":1}}],[\"年牛的数量\",{\"1\":{\"182\":1}}],[\"年后牛的数量对\",{\"1\":{\"182\":1}}],[\"年后牛的数量\",{\"1\":{\"182\":1}}],[\"年之后成熟\",{\"1\":{\"182\":1}}],[\"年卡\",{\"1\":{\"65\":1}}],[\"语义就要求线程在访问读写共享变量时只能\",{\"1\":{\"1484\":1}}],[\"语义表示锁在同一时刻只能由一个线程进行获取\",{\"1\":{\"1484\":1}}],[\"语义和\",{\"1\":{\"1420\":1}}],[\"语义给编写单线程程序的程序员创造了一个幻境\",{\"1\":{\"1420\":1}}],[\"语义保证单线程内程序的执行结果不被改变\",{\"1\":{\"1420\":1}}],[\"语义是一回事\",{\"1\":{\"1420\":1}}],[\"语义使程序员不必担心单线程中重排序的问题干扰他们\",{\"1\":{\"1418\":1}}],[\"语义的编译器\",{\"1\":{\"1418\":1}}],[\"语义的意思是\",{\"1\":{\"1418\":1}}],[\"语义把单线程程序保护了起来\",{\"1\":{\"1418\":1}}],[\"语义\",{\"1\":{\"1418\":2}}],[\"语言开发的一款高性能的分布式式存储方案的开源项目\",{\"1\":{\"1095\":1}}],[\"语言风格的变量名\",{\"1\":{\"98\":1}}],[\"语言风格使用下划线分隔多个单词\",{\"1\":{\"98\":1}}],[\"语音mp3文件\",{\"1\":{\"1093\":1}}],[\"语音数据\",{\"1\":{\"1093\":1}}],[\"语法糖来打开资源\",{\"1\":{\"1049\":1}}],[\"语法基础\",{\"0\":{\"977\":1}}],[\"语法如下\",{\"1\":{\"930\":1}}],[\"语法结构如下\",{\"1\":{\"929\":1}}],[\"语法\",{\"0\":{\"918\":1,\"929\":1,\"959\":1,\"1106\":1},\"1\":{\"538\":1,\"542\":2,\"913\":1,\"914\":1,\"915\":1,\"925\":1,\"926\":1,\"927\":1,\"931\":1,\"932\":1,\"933\":1,\"934\":1,\"937\":1}}],[\"语句改为\",{\"1\":{\"1407\":1}}],[\"语句返回值的类型必须与函数的返回类型相同\",{\"1\":{\"1021\":1}}],[\"语句都必须返回一个值\",{\"1\":{\"1021\":1}}],[\"语句退出循环\",{\"1\":{\"1020\":1}}],[\"语句只能用在返回类型是\",{\"1\":{\"1020\":1}}],[\"语句有两种形式\",{\"1\":{\"1019\":1}}],[\"语句终止当前正在执行的函数并将控制权返回到调用该函数的地方\",{\"1\":{\"1019\":1}}],[\"语句负责结束\",{\"1\":{\"1010\":1}}],[\"语句类似\",{\"1\":{\"993\":1}}],[\"语句搭配\",{\"1\":{\"992\":1}}],[\"语句限制性循环体后检查条件\",{\"1\":{\"989\":1}}],[\"语句非常相似\",{\"1\":{\"989\":1}}],[\"语句是判断一次\",{\"1\":{\"988\":1}}],[\"语句内部也可以是\",{\"1\":{\"984\":1}}],[\"语句提交一次事务\",{\"1\":{\"954\":1}}],[\"语句全部执行失败\",{\"1\":{\"953\":1}}],[\"语句全部执行成功\",{\"1\":{\"953\":1}}],[\"语句失败\",{\"1\":{\"953\":1}}],[\"语句给数据库执行\",{\"1\":{\"953\":1}}],[\"语句中进行\",{\"1\":{\"1408\":1}}],[\"语句中如果不加\",{\"1\":{\"986\":1}}],[\"语句中嵌套\",{\"1\":{\"947\":1}}],[\"语句中表的先后顺序就可以了\",{\"1\":{\"945\":1}}],[\"语句中\",{\"1\":{\"930\":1}}],[\"语句不能删除某一个字段的值\",{\"1\":{\"927\":1}}],[\"语句不区分大小写\",{\"1\":{\"908\":1}}],[\"语句的条件可以有\",{\"1\":{\"927\":1}}],[\"语句根据其功能被分为四大类\",{\"1\":{\"909\":1}}],[\"语句可以省略\",{\"1\":{\"984\":1}}],[\"语句可以使用空格\",{\"1\":{\"908\":1}}],[\"语句可以单行或多行书写\",{\"1\":{\"908\":1}}],[\"语句去编写请求包装类\",{\"1\":{\"517\":1}}],[\"语句会存放到\",{\"1\":{\"471\":1}}],[\"语句后面拼接一个\",{\"1\":{\"471\":1}}],[\"语句\",{\"0\":{\"984\":1,\"986\":1,\"1019\":1},\"1\":{\"181\":1,\"942\":1,\"947\":1,\"954\":1,\"984\":2,\"985\":1,\"986\":1,\"988\":1,\"1020\":2,\"1021\":1,\"1026\":2}}],[\"击杀怪物并且消耗自己的血量\",{\"1\":{\"180\":1}}],[\"道路上可能会有一些怪物\",{\"1\":{\"180\":1}}],[\"飞鱼科技笔试\",{\"0\":{\"177\":1}}],[\"双重检验锁\",{\"1\":{\"1425\":1}}],[\"双重检测\",{\"1\":{\"1145\":1}}],[\"双引号字符串\",{\"1\":{\"1117\":1}}],[\"双引号中的内容可以执行\",{\"1\":{\"1117\":1}}],[\"双引号定义字符串\",{\"1\":{\"1112\":1}}],[\"双精度浮点数值\",{\"1\":{\"920\":1}}],[\"双端队列\",{\"0\":{\"1077\":1},\"1\":{\"422\":1,\"1075\":1}}],[\"双链表\",{\"0\":{\"404\":1},\"1\":{\"1036\":1,\"1038\":1}}],[\"双指针\",{\"2\":{\"780\":1}}],[\"双指针算法\",{\"0\":{\"340\":1}}],[\"双指针遍历两个列表\",{\"1\":{\"70\":1}}],[\"双方都会执行最优策略\",{\"1\":{\"174\":1}}],[\"她们会玩\",{\"1\":{\"174\":1}}],[\"她记录了若干个人的名字\",{\"1\":{\"172\":1}}],[\"超时时间是\",{\"1\":{\"1508\":1}}],[\"超时时间结束\",{\"1\":{\"1508\":1}}],[\"超时等待\",{\"0\":{\"1512\":1}}],[\"超时等待式获取锁\",{\"0\":{\"1508\":1}}],[\"超时等待锁获取这些特性的实现\",{\"1\":{\"1500\":1}}],[\"超时获取锁\",{\"1\":{\"1493\":1}}],[\"超时机制的支持\",{\"1\":{\"1251\":1}}],[\"超时控制和服务限流方案\",{\"1\":{\"25\":1}}],[\"超出淘汰\",{\"1\":{\"1204\":1,\"1207\":1}}],[\"超出范围时抛出\",{\"1\":{\"1045\":1}}],[\"超出地图边界\",{\"1\":{\"230\":1}}],[\"超过了话则取最大值\",{\"1\":{\"1270\":1}}],[\"超过了就得使用\",{\"1\":{\"688\":1}}],[\"超过范围\",{\"1\":{\"795\":1,\"796\":1}}],[\"超过则缩小\",{\"1\":{\"173\":1}}],[\"超级管理员拥有所有权限\",{\"1\":{\"467\":1}}],[\"棵树\",{\"1\":{\"173\":3}}],[\"牛客网\",{\"1\":{\"634\":1}}],[\"牛客模考题\",{\"0\":{\"191\":1}}],[\"牛牛在一次吃草之旅中\",{\"1\":{\"193\":1}}],[\"牛牛可以从任意一块草地开始不断的吃草并移动到下一个草地\",{\"1\":{\"193\":1}}],[\"牛牛吃草\",{\"0\":{\"192\":1}}],[\"牛牛商店里只卖两种商品\",{\"1\":{\"168\":1}}],[\"牛牛商店\",{\"0\":{\"168\":1}}],[\"牛马克\",{\"1\":{\"168\":3}}],[\"牛可乐\",{\"1\":{\"168\":3}}],[\"平时为\",{\"1\":{\"1266\":1}}],[\"平衡树\",{\"1\":{\"1039\":1,\"1040\":1}}],[\"平衡二叉树\",{\"1\":{\"813\":1,\"958\":1}}],[\"平衡\",{\"1\":{\"813\":1}}],[\"平台的具体实现必须要按照\",{\"1\":{\"1420\":1}}],[\"平台\",{\"1\":{\"557\":1}}],[\"平台化之后增加一个评论区\",{\"1\":{\"30\":1}}],[\"平台化\",{\"1\":{\"21\":1}}],[\"平均值\",{\"1\":{\"932\":1}}],[\"平均情况下\",{\"1\":{\"355\":1}}],[\"平均分配剩余的操作次数\",{\"1\":{\"167\":1}}],[\"平均分配到\",{\"1\":{\"167\":1}}],[\"足够\",{\"1\":{\"167\":1}}],[\"增大循环次数\",{\"1\":{\"1316\":1}}],[\"增大为数组的长度\",{\"1\":{\"1316\":1}}],[\"增大\",{\"1\":{\"1315\":1}}],[\"增量静态生成\",{\"1\":{\"534\":1}}],[\"增量追加前可能出现缓存过期\",{\"1\":{\"31\":1}}],[\"增加了超时时间\",{\"1\":{\"1399\":1}}],[\"增加了超时等待的功能\",{\"1\":{\"1334\":1}}],[\"增加了超时返回的特性\",{\"1\":{\"1259\":1}}],[\"增加无非就是多增加了循环次数\",{\"1\":{\"1315\":1}}],[\"增加写状态\",{\"1\":{\"1239\":1}}],[\"增加\",{\"0\":{\"925\":1},\"1\":{\"1476\":1}}],[\"增加数组长度\",{\"1\":{\"613\":1}}],[\"增加题库题目关联请求类\",{\"1\":{\"526\":1}}],[\"增加字段\",{\"1\":{\"523\":1}}],[\"增加到\",{\"1\":{\"167\":3}}],[\"增删改查\",{\"1\":{\"496\":3,\"507\":3,\"521\":3}}],[\"增删改查的时间复杂度是\",{\"1\":{\"422\":1}}],[\"增广矩阵\",{\"1\":{\"385\":1}}],[\"增广路\",{\"1\":{\"363\":1}}],[\"应当调用\",{\"1\":{\"1330\":1}}],[\"应插入的位置\",{\"1\":{\"1081\":1}}],[\"应该保证用\",{\"1\":{\"1472\":1}}],[\"应该从哪些方面考虑\",{\"1\":{\"1422\":1}}],[\"应该使用\",{\"1\":{\"1275\":1}}],[\"应该使用st表找到当前区间的最大值的下标\",{\"1\":{\"174\":1}}],[\"应该都知道\",{\"1\":{\"1272\":1}}],[\"应该了解的概念\",{\"0\":{\"1222\":1}}],[\"应该在字段的规定范围内\",{\"1\":{\"925\":1}}],[\"应该是\",{\"1\":{\"676\":1}}],[\"应该将所有的操作次数用在最小的数字上\",{\"1\":{\"167\":1}}],[\"应用\",{\"1\":{\"1340\":1}}],[\"应用的支持\",{\"1\":{\"1140\":1}}],[\"应用可观测实践\",{\"1\":{\"621\":1}}],[\"应用有一类不可缺少的\",{\"1\":{\"475\":1}}],[\"应用程序编程接口\",{\"1\":{\"1094\":1}}],[\"应用程序试图加载类时\",{\"1\":{\"1045\":1}}],[\"应用程序没有处于请求操作所要求的适当状态下\",{\"1\":{\"1045\":1}}],[\"应用程序的安全性\",{\"1\":{\"446\":1}}],[\"应用程序服务器中间件\",{\"1\":{\"14\":1}}],[\"应用数据解决实际问题等\",{\"1\":{\"437\":1}}],[\"应用场景\",{\"1\":{\"221\":1,\"1376\":1}}],[\"应用层补偿\",{\"1\":{\"34\":1}}],[\"累加所有移动的距离即可\",{\"1\":{\"166\":1}}],[\"离线实时一网打尽\",{\"1\":{\"638\":1}}],[\"离线数据\",{\"1\":{\"40\":1}}],[\"离散化\",{\"0\":{\"341\":1}}],[\"离终点最近\",{\"1\":{\"214\":1}}],[\"离\",{\"1\":{\"166\":1}}],[\"放弃数据实时性达到数据的最终一致性\",{\"1\":{\"1291\":1}}],[\"放行端口的步骤\",{\"0\":{\"663\":1},\"1\":{\"662\":1}}],[\"放在该页面的\",{\"1\":{\"544\":1}}],[\"放在\",{\"1\":{\"544\":1,\"1416\":1}}],[\"放在前面符合查询模式\",{\"1\":{\"513\":1}}],[\"放到了\",{\"1\":{\"1178\":1}}],[\"放到集合里面\",{\"1\":{\"1165\":1}}],[\"放到集合中\",{\"1\":{\"525\":1}}],[\"放到\",{\"1\":{\"543\":2}}],[\"放到前面\",{\"1\":{\"513\":1}}],[\"放到编号为\",{\"1\":{\"103\":1}}],[\"放进去并更新右端点\",{\"1\":{\"429\":1}}],[\"放不进去则新开一组\",{\"1\":{\"429\":1}}],[\"放入\",{\"1\":{\"1078\":1}}],[\"放入高位\",{\"1\":{\"327\":1}}],[\"放入优先队列中会按照代价进行排序\",{\"1\":{\"213\":1}}],[\"放瓶子\",{\"0\":{\"166\":1}}],[\"技术像齐达内之类的\",{\"1\":{\"1131\":1}}],[\"技术选型\",{\"0\":{\"498\":1,\"557\":1},\"1\":{\"555\":1}}],[\"技术\",{\"1\":{\"165\":1,\"171\":1}}],[\"怀疑是数据有问题\",{\"1\":{\"162\":1}}],[\"优缺点\",{\"0\":{\"1056\":1}}],[\"优雅掌握\",{\"1\":{\"639\":1}}],[\"优点的算法\",{\"1\":{\"1205\":1}}],[\"优点\",{\"0\":{\"972\":1},\"1\":{\"534\":1,\"957\":1,\"1056\":1}}],[\"优先级不同的任务可以使用优先级队列\",{\"1\":{\"1361\":1}}],[\"优先级高的线程相较于优先级低的线程优先获得处理器时间片\",{\"1\":{\"1339\":1}}],[\"优先级的范围从\",{\"1\":{\"1339\":1}}],[\"优先级队列\",{\"1\":{\"789\":1}}],[\"优先级最高\",{\"1\":{\"215\":2}}],[\"优先队列在添加元素的时候对元素的大小排序后再保存\",{\"1\":{\"1078\":1}}],[\"优先队列\",{\"0\":{\"789\":1,\"857\":1,\"1078\":1},\"1\":{\"422\":1,\"1038\":1},\"2\":{\"792\":1,\"860\":1}}],[\"优先队列的队头\",{\"1\":{\"221\":1}}],[\"优先安排消费金额高的客人\",{\"1\":{\"162\":1}}],[\"优化手段\",{\"1\":{\"910\":1}}],[\"优化技巧\",{\"1\":{\"852\":1}}],[\"优化\",{\"0\":{\"188\":1},\"1\":{\"534\":1}}],[\"优化产品功能及其技术实现\",{\"1\":{\"37\":1}}],[\"优化调用编排甚至技术方案重构等方式持续优化提升非核心功能的可用性\",{\"1\":{\"34\":1}}],[\"范围为\",{\"1\":{\"1080\":1}}],[\"范围遍历\",{\"1\":{\"1001\":2,\"1005\":1}}],[\"范围\",{\"1\":{\"920\":3}}],[\"范围从\",{\"1\":{\"886\":1}}],[\"范围缩小到\",{\"1\":{\"852\":4}}],[\"范围开大一点防止数组越界\",{\"1\":{\"235\":1}}],[\"范围内\",{\"1\":{\"162\":1}}],[\"范围均在\",{\"1\":{\"162\":1}}],[\"范围是\",{\"1\":{\"110\":1}}],[\"批量添加数据\",{\"1\":{\"925\":2}}],[\"批量插入的终极优化技巧\",{\"1\":{\"619\":1}}],[\"批量删除题目\",{\"1\":{\"497\":1,\"508\":1}}],[\"批量从题库移除题目\",{\"1\":{\"497\":1,\"508\":1}}],[\"批量向题库添加题目\",{\"1\":{\"497\":1,\"508\":1}}],[\"批量查询楼中楼评论基础信息\",{\"1\":{\"30\":1}}],[\"批量查询根评论基础信息\",{\"1\":{\"30\":1}}],[\"批客人的人数和预计消费金额以空格分隔\",{\"1\":{\"162\":1}}],[\"批客人\",{\"1\":{\"162\":1}}],[\"张原理图\",{\"1\":{\"1145\":1}}],[\"张三\",{\"1\":{\"926\":2,\"1207\":2,\"1211\":2}}],[\"张桌子\",{\"1\":{\"162\":1}}],[\"张表\",{\"1\":{\"56\":3}}],[\"某些特殊的\",{\"1\":{\"543\":1}}],[\"某一个操作\",{\"1\":{\"394\":1}}],[\"某餐馆有\",{\"1\":{\"162\":1}}],[\"某个公司的共享单车单次骑行\",{\"1\":{\"65\":1}}],[\"某个数据项读取失败这一类的轻量级操作\",{\"1\":{\"37\":1}}],[\"餐馆\",{\"0\":{\"162\":1}}],[\"想办法认识她们\",{\"1\":{\"1131\":1}}],[\"想当然地初始化上下界为\",{\"1\":{\"899\":1}}],[\"想要学习课程\",{\"1\":{\"874\":1}}],[\"想象自己站在它的右侧\",{\"1\":{\"735\":1}}],[\"想象一下曝光数作为排序特征的变态要求\",{\"1\":{\"40\":1}}],[\"想把每位的数变成\",{\"1\":{\"161\":1}}],[\"颜色编号为\",{\"1\":{\"157\":1}}],[\"李华有一块很长的画布\",{\"1\":{\"157\":1}}],[\"百度百科中最近公共祖先的定义为\",{\"1\":{\"753\":1}}],[\"百度笔试\",{\"0\":{\"155\":1}}],[\"百度评论中台的设计与探索\",{\"1\":{\"41\":1}}],[\"出队操作\",{\"0\":{\"1505\":1}}],[\"出\",{\"1\":{\"1284\":1}}],[\"出口就只剩下两个地方\",{\"1\":{\"1251\":1}}],[\"出口处不一定有像\",{\"1\":{\"237\":1}}],[\"出一个\",{\"1\":{\"1250\":1}}],[\"出现冲突就重试当前操作直到没有冲突为止\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"出现逻辑错误\",{\"1\":{\"1318\":1}}],[\"出现\",{\"1\":{\"1306\":2}}],[\"出现线程安全的问题一般是因为主内存和工作内存数据不一致性和重排序导致的\",{\"1\":{\"1415\":1}}],[\"出现线程安全的问题\",{\"1\":{\"1221\":1}}],[\"出现了多少次\",{\"1\":{\"324\":1}}],[\"出栈一个元素\",{\"1\":{\"1075\":1}}],[\"出错\",{\"1\":{\"533\":1}}],[\"出来的数据放置在数据容器中\",{\"1\":{\"1324\":1}}],[\"出来一个\",{\"1\":{\"1270\":1}}],[\"出来\",{\"1\":{\"152\":1}}],[\"出发的点不算\",{\"1\":{\"363\":1}}],[\"出发\",{\"1\":{\"72\":1}}],[\"例外就是\",{\"1\":{\"1482\":1}}],[\"例二\",{\"0\":{\"274\":1},\"1\":{\"324\":1}}],[\"例一\",{\"0\":{\"273\":1}}],[\"例题二\",{\"1\":{\"339\":1}}],[\"例题一\",{\"1\":{\"339\":1}}],[\"例题\",{\"0\":{\"222\":1,\"339\":1},\"1\":{\"985\":1,\"992\":1,\"993\":1}}],[\"例子中通过\",{\"1\":{\"1496\":1}}],[\"例子很简单\",{\"1\":{\"1385\":1}}],[\"例子\",{\"1\":{\"152\":1}}],[\"例如用来配置应用程序的任何切面\",{\"1\":{\"1051\":1}}],[\"例如标记过时的功能\",{\"1\":{\"1051\":1}}],[\"例如对数组\",{\"1\":{\"1045\":1}}],[\"例如对于\",{\"1\":{\"99\":1}}],[\"例如在\",{\"1\":{\"1344\":1}}],[\"例如在一间教室中\",{\"1\":{\"1025\":1}}],[\"例如在批量查询评论发布人的粉丝勋章数据之后\",{\"1\":{\"25\":1}}],[\"例如自动补完和拼写检查\",{\"1\":{\"801\":1}}],[\"例如有三个链表\",{\"1\":{\"789\":1}}],[\"例如常见的常见的守护进程包括系统日志进程\",{\"1\":{\"671\":1}}],[\"例如测试\",{\"1\":{\"574\":1}}],[\"例如下面\",{\"1\":{\"471\":1}}],[\"例如求长度\",{\"1\":{\"340\":1}}],[\"例如求\",{\"1\":{\"339\":1,\"990\":1}}],[\"例如上图中的海域未来会变成如下样子\",{\"1\":{\"280\":1}}],[\"例如上图就有\",{\"1\":{\"280\":1}}],[\"例如超过\",{\"1\":{\"243\":1}}],[\"例如分数和排名情况为\",{\"1\":{\"129\":1}}],[\"例如排序提权\",{\"1\":{\"40\":1}}],[\"例如单个\",{\"1\":{\"40\":1}}],[\"例如视频表的评论数\",{\"1\":{\"37\":1}}],[\"例如依据评论的状态来做评论区的计数更新\",{\"1\":{\"37\":1}}],[\"例如评论计数\",{\"1\":{\"37\":1}}],[\"例如评论点赞点踩\",{\"1\":{\"37\":1}}],[\"例如评论列表的露出\",{\"1\":{\"36\":1}}],[\"例如审核删除的有害评论\",{\"1\":{\"36\":1}}],[\"例如\",{\"1\":{\"36\":1,\"83\":1,\"98\":2,\"120\":1,\"133\":1,\"193\":1,\"196\":1,\"213\":1,\"224\":3,\"279\":3,\"289\":1,\"327\":1,\"328\":1,\"338\":2,\"422\":1,\"479\":1,\"794\":1,\"838\":1,\"845\":1,\"850\":1,\"874\":1,\"886\":1,\"1005\":1,\"1018\":1,\"1045\":1,\"1110\":1,\"1112\":1,\"1119\":1,\"1122\":1,\"1123\":1,\"1124\":1,\"1125\":1,\"1191\":1,\"1423\":1}}],[\"例如查询评论列表\",{\"1\":{\"27\":1}}],[\"例如up主点赞等\",{\"1\":{\"30\":1}}],[\"例如up主点赞\",{\"1\":{\"22\":1}}],[\"例如表情\",{\"1\":{\"22\":1}}],[\"例如音乐会\",{\"1\":{\"21\":1}}],[\"例如电影\",{\"1\":{\"21\":1}}],[\"咖啡套餐里价格最接近的两种咖啡饮品的价格差就是这个套餐的风味差异度\",{\"1\":{\"152\":1}}],[\"瑞幸有各种不同价格的咖啡饮品\",{\"1\":{\"152\":1}}],[\"瑞幸笔试\",{\"0\":{\"150\":1}}],[\"回过头再来看看\",{\"1\":{\"1301\":1}}],[\"回到业务场景中\",{\"1\":{\"1290\":1}}],[\"回\",{\"1\":{\"1284\":1}}],[\"回车等空白字符时停止输入\",{\"1\":{\"1006\":1}}],[\"回车也是一个字符\",{\"1\":{\"982\":1}}],[\"回车之后\",{\"1\":{\"906\":1}}],[\"回滚事务\",{\"1\":{\"954\":2}}],[\"回退状态\",{\"1\":{\"875\":1}}],[\"回溯返回根节点\",{\"1\":{\"767\":1}}],[\"回推路径\",{\"1\":{\"224\":1}}],[\"回传成功后\",{\"1\":{\"151\":1}}],[\"回复数\",{\"1\":{\"39\":1}}],[\"定位待删除的队头节点的过程为\",{\"1\":{\"1284\":1}}],[\"定位删除的队头节点\",{\"1\":{\"1284\":1}}],[\"定位队列真正的对尾节点\",{\"1\":{\"1283\":1}}],[\"定位节点时要先定位到具体的\",{\"1\":{\"1276\":1}}],[\"定时清理过期缓存\",{\"1\":{\"1201\":1}}],[\"定时器线程池\",{\"1\":{\"1201\":1}}],[\"定时任务状态修改\",{\"0\":{\"482\":1},\"1\":{\"482\":1}}],[\"定时任务执行时需要取出最近要执行的任务\",{\"1\":{\"1369\":1}}],[\"定时任务执行\",{\"0\":{\"480\":1}}],[\"定时任务处理类\",{\"1\":{\"477\":2}}],[\"定时任务工具类\",{\"1\":{\"477\":1}}],[\"定时任务的场景可以说非常广泛\",{\"1\":{\"475\":1}}],[\"定时任务\",{\"0\":{\"474\":1},\"1\":{\"481\":1,\"482\":1}}],[\"定时任务或事件驱动机制从数据库中读取未回传的点击数据\",{\"1\":{\"151\":1}}],[\"定制排序\",{\"1\":{\"1074\":1}}],[\"定长字符串\",{\"1\":{\"920\":1}}],[\"定理\",{\"1\":{\"389\":1,\"394\":1,\"399\":1}}],[\"定理求组合数\",{\"0\":{\"389\":1}}],[\"定义的默认值\",{\"1\":{\"1150\":1}}],[\"定义环境变量\",{\"1\":{\"1116\":1}}],[\"定义变量\",{\"0\":{\"1112\":1},\"1\":{\"1112\":1,\"1116\":1}}],[\"定义成类\",{\"1\":{\"1025\":1}}],[\"定义成小根堆的方式\",{\"1\":{\"422\":1}}],[\"定义在类中的变量为成员变量\",{\"1\":{\"1015\":1}}],[\"定义外键关联另外一张表\",{\"1\":{\"937\":1}}],[\"定义操作所有关系型数据库的统一标准\",{\"1\":{\"907\":1}}],[\"定义递归函数\",{\"1\":{\"784\":1}}],[\"定义业务异常类\",{\"1\":{\"599\":1}}],[\"定义列对应后端字段\",{\"1\":{\"592\":1}}],[\"定义表格有哪些列\",{\"1\":{\"592\":1}}],[\"定义请求的路径\",{\"1\":{\"576\":1}}],[\"定义了一个继承\",{\"1\":{\"1496\":1}}],[\"定义了一个静态的私有的\",{\"1\":{\"1164\":1}}],[\"定义了一些变量和一个内部类\",{\"1\":{\"1275\":1}}],[\"定义了配置项的名称\",{\"1\":{\"1151\":1}}],[\"定义了\",{\"1\":{\"567\":1}}],[\"定义了整个项目用到的一些接口\",{\"1\":{\"559\":1}}],[\"定义了优先级\",{\"1\":{\"36\":1}}],[\"定义工作日和非工作日\",{\"1\":{\"484\":1}}],[\"定义有向图游戏g\",{\"1\":{\"399\":1}}],[\"定义sg\",{\"1\":{\"398\":1}}],[\"定义mex\",{\"1\":{\"397\":1}}],[\"定义区间为闭区间\",{\"1\":{\"323\":1}}],[\"定义时初始化\",{\"1\":{\"242\":1}}],[\"定义终点坐标\",{\"1\":{\"236\":1}}],[\"定义起点坐标\",{\"1\":{\"236\":1,\"237\":1}}],[\"定义方向数组\",{\"1\":{\"228\":1,\"229\":1,\"235\":1}}],[\"定义行\",{\"1\":{\"228\":1,\"237\":1}}],[\"定义地图范围\",{\"1\":{\"228\":1,\"235\":1}}],[\"定义为\",{\"1\":{\"152\":1}}],[\"定义三维\",{\"1\":{\"120\":1}}],[\"定义dp数组\",{\"1\":{\"110\":1}}],[\"定义商品的选择状态\",{\"1\":{\"109\":1}}],[\"定义\",{\"0\":{\"1122\":1,\"1420\":1},\"1\":{\"104\":1,\"115\":1,\"178\":1,\"182\":1,\"261\":1,\"338\":2,\"772\":1,\"783\":1,\"795\":1,\"840\":1,\"846\":1,\"864\":1,\"893\":1,\"1421\":1}}],[\"定义一个小根堆\",{\"1\":{\"353\":1}}],[\"定义一个借位的情况\",{\"1\":{\"328\":1}}],[\"定义一个二维动态数组\",{\"1\":{\"242\":1}}],[\"定义一个二维dp数组\",{\"1\":{\"72\":1}}],[\"定义一个dp数组\",{\"1\":{\"135\":1}}],[\"定义一个长度为\",{\"1\":{\"65\":1}}],[\"描述\",{\"0\":{\"193\":1,\"196\":1,\"199\":1,\"202\":1,\"205\":1},\"1\":{\"151\":1,\"337\":1,\"466\":1,\"471\":1,\"479\":1,\"484\":1,\"511\":2,\"919\":1,\"920\":3,\"949\":1,\"954\":1,\"979\":1,\"1045\":2}}],[\"描述的是正常\",{\"1\":{\"30\":1}}],[\"场景题\",{\"0\":{\"151\":1}}],[\"思维是主要的\",{\"1\":{\"987\":1}}],[\"思维题\",{\"1\":{\"147\":1}}],[\"思考\",{\"1\":{\"958\":1}}],[\"思路三\",{\"0\":{\"822\":1,\"901\":1}}],[\"思路二\",{\"0\":{\"188\":1,\"688\":1,\"725\":1,\"731\":1,\"737\":1,\"749\":1,\"784\":1,\"790\":1,\"796\":1,\"821\":1,\"828\":1,\"846\":1,\"858\":1,\"888\":1,\"894\":1,\"900\":1}}],[\"思路一\",{\"0\":{\"187\":1,\"687\":1,\"724\":1,\"730\":1,\"736\":1,\"748\":1,\"783\":1,\"789\":1,\"795\":1,\"820\":1,\"827\":1,\"845\":1,\"857\":1,\"887\":1,\"893\":1,\"899\":1}}],[\"思路\",{\"0\":{\"681\":1,\"693\":1,\"699\":1,\"705\":1,\"710\":1,\"712\":1,\"718\":1,\"742\":1,\"754\":1,\"760\":1,\"766\":1,\"772\":1,\"777\":1,\"802\":1,\"808\":1,\"814\":1,\"833\":1,\"839\":1,\"851\":1,\"863\":1,\"869\":1,\"875\":1,\"881\":1},\"1\":{\"151\":1,\"261\":1,\"262\":1,\"263\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"339\":2,\"371\":1,\"380\":1,\"384\":1}}],[\"思路与代码\",{\"1\":{\"65\":1,\"66\":1,\"70\":1,\"71\":1,\"72\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"92\":1,\"93\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"108\":1,\"109\":1,\"110\":1,\"114\":1,\"115\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"133\":1,\"134\":1,\"135\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"152\":1,\"156\":1,\"157\":1,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1}}],[\"摆放为\",{\"1\":{\"147\":2}}],[\"∣t∣≤100\",{\"1\":{\"202\":1}}],[\"∣ai​∣≤100\",{\"1\":{\"202\":1}}],[\"∣3∣=3\",{\"1\":{\"147\":1}}],[\"∣−5∣=5\",{\"1\":{\"147\":1}}],[\"∣x∣表示\",{\"1\":{\"147\":1}}],[\"∣i−j∣\",{\"1\":{\"108\":1}}],[\"∑i=1n​ai​=m\",{\"1\":{\"147\":1}}],[\"∑i=2n​∣ai​−ai−1​∣\",{\"1\":{\"147\":1}}],[\"相信大家都做过这样的事情吧\",{\"1\":{\"1399\":1}}],[\"相加\",{\"1\":{\"1385\":1}}],[\"相应的方法分别为\",{\"1\":{\"1367\":1}}],[\"相应的递推式\",{\"1\":{\"796\":1}}],[\"相互影响分析时队列初始状态\",{\"1\":{\"1285\":1}}],[\"相与\",{\"1\":{\"1239\":1}}],[\"相比\",{\"1\":{\"1326\":1}}],[\"相比起来具有更高的吞吐量\",{\"1\":{\"1326\":1}}],[\"相比自己编写的缓存服务\",{\"1\":{\"1202\":1}}],[\"相比于构造器注入\",{\"1\":{\"1133\":1}}],[\"相比于使用哈希表\",{\"1\":{\"888\":1}}],[\"相对来说\",{\"1\":{\"920\":1}}],[\"相对于任务调度的\",{\"1\":{\"1365\":1}}],[\"相对于武断而直接的结束线程\",{\"1\":{\"1336\":1}}],[\"相对于\",{\"1\":{\"599\":1,\"1264\":1}}],[\"相对而言评论文本更长\",{\"1\":{\"21\":1}}],[\"相关的一些方法\",{\"0\":{\"1275\":1}}],[\"相关的处理技术包括\",{\"1\":{\"434\":1}}],[\"相关联的\",{\"1\":{\"1251\":1}}],[\"相关插件\",{\"0\":{\"658\":1}}],[\"相关项目和教程推荐\",{\"1\":{\"634\":1}}],[\"相关信息\",{\"1\":{\"531\":1,\"537\":1,\"539\":1,\"662\":1,\"671\":1}}],[\"相关概念\",{\"0\":{\"435\":1},\"1\":{\"363\":1}}],[\"相当于\",{\"1\":{\"1274\":1}}],[\"相当于每个\",{\"1\":{\"1250\":1}}],[\"相当于文件\",{\"1\":{\"1100\":1}}],[\"相当于存放文件的顶层文件夹\",{\"1\":{\"1100\":1}}],[\"相当于存在两个相邻的点染成了相同的颜色\",{\"1\":{\"362\":1}}],[\"相当于给了key在map中的一个初试值\",{\"1\":{\"1074\":1}}],[\"相当于返回原数组的一个片段\",{\"1\":{\"1072\":1}}],[\"相当于子查询结果是一张表\",{\"1\":{\"947\":1}}],[\"相当于查询\",{\"1\":{\"943\":1}}],[\"相当于是一个文件服务器\",{\"1\":{\"671\":1}}],[\"相当于是每次考虑合并两个式子\",{\"1\":{\"384\":1}}],[\"相当于拥有最高权限的通行证\",{\"1\":{\"470\":1}}],[\"相当于该数除以\",{\"1\":{\"338\":1}}],[\"相当于该数乘以\",{\"1\":{\"338\":1}}],[\"相当于结构体\",{\"1\":{\"257\":1}}],[\"相异或值不变\",{\"1\":{\"338\":1}}],[\"相同时\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"相同点\",{\"1\":{\"1295\":1,\"1353\":1}}],[\"相同返回true\",{\"1\":{\"1069\":1}}],[\"相同的\",{\"1\":{\"1307\":1,\"1308\":1}}],[\"相同的话就直接返回这个\",{\"1\":{\"1307\":1}}],[\"相同的可覆盖\",{\"1\":{\"1306\":1}}],[\"相同的节点\",{\"1\":{\"1272\":2}}],[\"相同的域名\",{\"1\":{\"575\":1}}],[\"相同的个数\",{\"1\":{\"261\":1}}],[\"相同\",{\"1\":{\"423\":1,\"1266\":1,\"1272\":1,\"1317\":8}}],[\"相同数量级的数即可\",{\"1\":{\"354\":1}}],[\"相同为\",{\"1\":{\"338\":1}}],[\"相等\",{\"1\":{\"261\":1}}],[\"相邻两个数用一个空格隔开\",{\"1\":{\"289\":1}}],[\"相邻两个数用恰好\",{\"1\":{\"287\":1}}],[\"相邻两个格子收藏品数量之差越大就越美\",{\"1\":{\"147\":1}}],[\"相邻的陆地\",{\"1\":{\"230\":1}}],[\"相较于\",{\"1\":{\"216\":1,\"1264\":1,\"1507\":1}}],[\"满足原子性\",{\"1\":{\"1482\":1}}],[\"满足以下条件则可以成为不可变类\",{\"1\":{\"1472\":1}}],[\"满足插入数据的要求\",{\"1\":{\"1347\":1}}],[\"满足条件则返回该entry\",{\"1\":{\"1307\":1}}],[\"满足条件就吃\",{\"1\":{\"194\":1}}],[\"满足数据实时性\",{\"1\":{\"1291\":1}}],[\"满足总金额恰好等于\",{\"1\":{\"893\":3}}],[\"满足严格递增\",{\"1\":{\"852\":1}}],[\"满足元素和恰好等于\",{\"1\":{\"795\":3,\"796\":1}}],[\"满足匹配条件\",{\"1\":{\"411\":1}}],[\"满足任意前缀中0的个数都不少于1的个数的序列的数量为\",{\"1\":{\"391\":1}}],[\"满足\",{\"1\":{\"146\":1,\"328\":1,\"384\":1,\"753\":1,\"1233\":1,\"1407\":1}}],[\"满足第奇数个元素都是奇数\",{\"1\":{\"87\":1}}],[\"理想散列表的示意图\",{\"1\":{\"1306\":1}}],[\"理想状态下\",{\"1\":{\"1306\":1}}],[\"理想情况下\",{\"1\":{\"971\":1}}],[\"理解起来很容易\",{\"1\":{\"1399\":1}}],[\"理解这就很容易了\",{\"1\":{\"1366\":1}}],[\"理解\",{\"1\":{\"1366\":1}}],[\"理解了\",{\"1\":{\"1132\":1}}],[\"理解了本质就可以傻瓜式地套用模板\",{\"1\":{\"231\":1}}],[\"理解函数\",{\"1\":{\"1008\":1}}],[\"理解为\",{\"1\":{\"564\":1}}],[\"理解之后方才能从容不迫\",{\"1\":{\"234\":1}}],[\"理解整个产品体系在系统中的定位\",{\"1\":{\"45\":1}}],[\"理论\",{\"0\":{\"1129\":1}}],[\"理论+实战\",{\"1\":{\"638\":1}}],[\"理论上来说\",{\"1\":{\"162\":1}}],[\"理论最佳速通时问指\",{\"1\":{\"146\":1}}],[\"滴滴笔试\",{\"0\":{\"145\":1}}],[\"玩家只能上下左右移动\",{\"1\":{\"142\":1}}],[\"玩家位于\",{\"1\":{\"142\":1}}],[\"玩家不存在\",{\"1\":{\"129\":1}}],[\"花括号是可选的\",{\"1\":{\"1113\":1}}],[\"花坛的美观度等于花坛中所有边长为\",{\"1\":{\"141\":1}}],[\"花卉的花朵数量为\",{\"1\":{\"141\":1}}],[\"滑动窗口中的最大值\",{\"1\":{\"856\":1}}],[\"滑动窗口每次只向右移动一位\",{\"1\":{\"856\":1}}],[\"滑动窗口最大值\",{\"0\":{\"855\":1},\"1\":{\"855\":1}}],[\"滑动窗口\",{\"1\":{\"140\":1},\"2\":{\"860\":1}}],[\"深拷贝应该正好由\",{\"1\":{\"886\":1}}],[\"深拷贝\",{\"1\":{\"886\":1}}],[\"深入浅出concurrenthashmap1\",{\"1\":{\"1276\":1}}],[\"深入理解java虚拟机\",{\"1\":{\"1415\":1}}],[\"深入理解读写锁\",{\"0\":{\"1236\":1}}],[\"深入理解\",{\"0\":{\"1128\":1,\"1499\":1}}],[\"深入理解守护进程\",{\"1\":{\"671\":1}}],[\"深入\",{\"1\":{\"643\":1}}],[\"深入到业务里面\",{\"1\":{\"45\":1}}],[\"深度优先遍历\",{\"0\":{\"347\":1}}],[\"深信服笔试\",{\"0\":{\"138\":1}}],[\"归还了笔\",{\"1\":{\"1398\":11}}],[\"归并的一般写法如下\",{\"1\":{\"318\":1}}],[\"归并每次都将中点作为分界点\",{\"1\":{\"318\":1,\"833\":1}}],[\"归并\",{\"1\":{\"200\":1,\"318\":1}}],[\"归并排序详情\",{\"1\":{\"833\":1}}],[\"归并排序\",{\"0\":{\"318\":1},\"1\":{\"833\":1}}],[\"归并排序在链表上实现时可以保持时间复杂度为\",{\"1\":{\"134\":1}}],[\"归并排序模板题\",{\"1\":{\"134\":1}}],[\"归纳而言\",{\"1\":{\"28\":1}}],[\"空闲时间就越长\",{\"1\":{\"1361\":1}}],[\"空闲线程存活时间\",{\"1\":{\"1359\":1}}],[\"空形参列表\",{\"1\":{\"1013\":1}}],[\"空语句表示true\",{\"1\":{\"990\":1}}],[\"空语句\",{\"1\":{\"990\":1}}],[\"空间换时间\",{\"1\":{\"1299\":1,\"1313\":1}}],[\"空间效率\",{\"1\":{\"973\":1}}],[\"空间优化\",{\"0\":{\"797\":1,\"894\":1}}],[\"空间复杂度为\",{\"1\":{\"851\":1,\"852\":2}}],[\"空间复杂度\",{\"1\":{\"134\":1,\"724\":1}}],[\"空字符也可以被表示\",{\"1\":{\"783\":1}}],[\"空字符串匹配空模式\",{\"1\":{\"127\":1}}],[\"空\",{\"1\":{\"471\":2}}],[\"空表示不捕获任何变量\",{\"1\":{\"255\":1}}],[\"$$\",{\"1\":{\"1120\":1}}],[\"$4\",{\"1\":{\"1119\":1,\"1120\":2}}],[\"$3\",{\"1\":{\"1119\":1,\"1120\":2}}],[\"$2\",{\"1\":{\"1119\":2,\"1120\":2}}],[\"$1\",{\"1\":{\"1119\":2,\"1120\":2}}],[\"$name\",{\"1\":{\"1113\":1,\"1115\":1,\"1117\":3}}],[\"$http\",{\"1\":{\"672\":1}}],[\"$proxy\",{\"1\":{\"672\":1}}],[\"$gcd\",{\"1\":{\"383\":1}}],[\"$\",{\"1\":{\"133\":2,\"383\":1,\"471\":2,\"568\":1,\"575\":1,\"587\":1,\"795\":2,\"1112\":1,\"1113\":4,\"1117\":2,\"1120\":5,\"1123\":5,\"1124\":4,\"1125\":4}}],[\"$0\",{\"1\":{\"133\":1,\"1119\":2}}],[\"排它性\",{\"1\":{\"1434\":1}}],[\"排列并返回\",{\"1\":{\"832\":1}}],[\"排列\",{\"1\":{\"813\":1}}],[\"排在\",{\"1\":{\"289\":1}}],[\"排成一排\",{\"1\":{\"281\":1}}],[\"排名\",{\"1\":{\"129\":1}}],[\"排序在日常开发中是非常常见的一个操作\",{\"1\":{\"934\":1}}],[\"排序查询\",{\"0\":{\"934\":1},\"1\":{\"929\":1}}],[\"排序字段列表\",{\"1\":{\"929\":1}}],[\"排序后的链表\",{\"1\":{\"832\":1}}],[\"排序链表\",{\"0\":{\"831\":1},\"1\":{\"831\":1}}],[\"排序确保\",{\"1\":{\"167\":1}}],[\"排序\",{\"1\":{\"140\":1,\"422\":1,\"423\":2,\"766\":2,\"1074\":1}}],[\"排序方式2\",{\"1\":{\"934\":1}}],[\"排序方式1\",{\"1\":{\"934\":1}}],[\"排序方式\",{\"1\":{\"58\":1,\"934\":1}}],[\"排序等\",{\"1\":{\"46\":1}}],[\"排序策略\",{\"1\":{\"40\":1}}],[\"排序过程可解释等等\",{\"1\":{\"40\":1}}],[\"排序我们往往都希望是个性化的\",{\"1\":{\"40\":1}}],[\"排序很像\",{\"1\":{\"40\":1}}],[\"积分\",{\"1\":{\"129\":1}}],[\"姓名\",{\"1\":{\"129\":1,\"926\":1,\"938\":1}}],[\"踢人\",{\"1\":{\"129\":2}}],[\"生产数据452445380\",{\"1\":{\"1410\":1}}],[\"生产数据482766516\",{\"1\":{\"1409\":1}}],[\"生产数据571277922\",{\"1\":{\"1409\":1}}],[\"生产数据2146351766\",{\"1\":{\"1410\":1}}],[\"生产数据253569900\",{\"1\":{\"1409\":1}}],[\"生产数据2065211573\",{\"1\":{\"1409\":1}}],[\"生产数据324882560\",{\"1\":{\"1409\":1}}],[\"生产数据1979746693\",{\"1\":{\"1410\":1}}],[\"生产数据1695168334\",{\"1\":{\"1410\":1}}],[\"生产数据1622323863\",{\"1\":{\"1409\":1}}],[\"生产数据1177554422\",{\"1\":{\"1409\":1}}],[\"生产数据1442969724\",{\"1\":{\"1409\":1}}],[\"生产数据1432164130\",{\"1\":{\"1409\":1}}],[\"生产数据1201395916\",{\"1\":{\"1409\":1}}],[\"生产数据1057090222\",{\"1\":{\"1409\":1}}],[\"生产数据\",{\"1\":{\"1409\":3,\"1410\":5,\"1411\":1}}],[\"生产\",{\"1\":{\"1324\":1}}],[\"生产者pool\",{\"1\":{\"1409\":16,\"1410\":18,\"1411\":19}}],[\"生产者生产数据之后直接放置在共享数据区中\",{\"1\":{\"1402\":1}}],[\"生产者线程\",{\"1\":{\"1345\":1}}],[\"生产者线程才能够返回\",{\"1\":{\"1326\":1}}],[\"生产者线程就会将数据插入到队尾\",{\"1\":{\"1326\":1}}],[\"生产者线程可以调用\",{\"1\":{\"1326\":1}}],[\"生产者线程会被阻塞\",{\"1\":{\"1324\":1}}],[\"生产者插入数据到队列容器中\",{\"1\":{\"1326\":1}}],[\"生产者将\",{\"1\":{\"1324\":1}}],[\"生产者\",{\"1\":{\"1324\":2,\"1344\":1,\"1402\":1,\"1409\":3,\"1410\":3,\"1411\":1}}],[\"生产者消费者问题\",{\"1\":{\"1253\":1}}],[\"生产者与消费者问题\",{\"1\":{\"1253\":1}}],[\"生命周期实际上和\",{\"1\":{\"1319\":1}}],[\"生命周期里会尽可能的保证不出现内存泄漏的问题\",{\"1\":{\"1318\":1}}],[\"生日\",{\"1\":{\"938\":1}}],[\"生日会上有游戏活动\",{\"1\":{\"129\":1}}],[\"生成了两个对应的\",{\"1\":{\"1350\":1}}],[\"生成订单等等这些操作\",{\"1\":{\"1218\":1}}],[\"生成该pair的哈希值\",{\"1\":{\"1082\":1}}],[\"生成新的字符串\",{\"1\":{\"1069\":1}}],[\"生成序列化\",{\"1\":{\"576\":1}}],[\"生成初始的静态页面\",{\"1\":{\"534\":1}}],[\"生成大量静态页面时\",{\"1\":{\"534\":1}}],[\"生成静态页面可能不够灵活\",{\"1\":{\"534\":1}}],[\"生成页面\",{\"1\":{\"534\":1}}],[\"生成页面的\",{\"1\":{\"532\":1}}],[\"生成完整的\",{\"1\":{\"533\":1}}],[\"生成代码\",{\"1\":{\"516\":1}}],[\"生成后移动到项目对应位置\",{\"1\":{\"515\":1}}],[\"生成\",{\"1\":{\"451\":1}}],[\"生成的新数据集可以插入到数仓中的表内\",{\"1\":{\"438\":1}}],[\"生成丰富的数据集\",{\"1\":{\"438\":1}}],[\"生效时间可累加\",{\"1\":{\"65\":1}}],[\"过早通知造成遗漏的情况\",{\"1\":{\"1406\":1}}],[\"过于频繁反而无法发挥出多线程编程的优势\",{\"1\":{\"1220\":1}}],[\"过期就从缓存map删除这个元素\",{\"1\":{\"1201\":1}}],[\"过期时间\",{\"1\":{\"1201\":2,\"1204\":1}}],[\"过期时间为\",{\"1\":{\"577\":1}}],[\"过期和状态变更\",{\"1\":{\"1160\":1}}],[\"过滤条件\",{\"1\":{\"471\":1}}],[\"过滤请求\",{\"1\":{\"446\":1}}],[\"过滤器添加等\",{\"1\":{\"446\":1}}],[\"过程如下\",{\"1\":{\"586\":1}}],[\"过程\",{\"1\":{\"274\":1,\"535\":1}}],[\"过生日\",{\"0\":{\"129\":1}}],[\"过大\",{\"1\":{\"40\":1}}],[\"长\",{\"1\":{\"1361\":1}}],[\"长时间阻塞的线程依然无法访问到\",{\"1\":{\"1326\":1}}],[\"长文本数据\",{\"1\":{\"920\":1}}],[\"长网址转短网址\",{\"1\":{\"634\":1}}],[\"长得非常平衡\",{\"1\":{\"417\":1}}],[\"长度是\",{\"1\":{\"839\":1}}],[\"长度不定\",{\"1\":{\"920\":1}}],[\"长度不能小于8\",{\"1\":{\"587\":2}}],[\"长度不超过\",{\"1\":{\"179\":1}}],[\"长度+左端点\",{\"1\":{\"307\":1}}],[\"长度修改为5\",{\"1\":{\"243\":1}}],[\"长度\",{\"1\":{\"243\":2,\"759\":2,\"840\":1,\"851\":2,\"852\":1,\"922\":3}}],[\"长度无限长的公路上\",{\"1\":{\"173\":1}}],[\"长度为1的区间为0\",{\"1\":{\"307\":1}}],[\"长度为\",{\"1\":{\"128\":1,\"784\":1,\"840\":1}}],[\"长远来看\",{\"1\":{\"56\":1}}],[\"栈中的锁记录和对象头的\",{\"1\":{\"1443\":1}}],[\"栈中存储元素的下标\",{\"1\":{\"128\":1}}],[\"栈是否为空\",{\"1\":{\"1037\":1}}],[\"栈模拟\",{\"0\":{\"845\":1}}],[\"栈顶的值\",{\"1\":{\"406\":1}}],[\"栈顶元素就是右侧第一个比当前元素高的地块\",{\"1\":{\"128\":2}}],[\"栈顶元素就是当前元素右侧第一个比它大的元素\",{\"1\":{\"128\":1}}],[\"栈数组从0开始\",{\"1\":{\"406\":1}}],[\"栈\",{\"0\":{\"405\":1,\"1037\":1,\"1075\":1},\"1\":{\"234\":1,\"422\":1},\"2\":{\"848\":1}}],[\"野猪骑士要想知道自己在每个地块上的下一块的目标的高度\",{\"1\":{\"128\":1}}],[\"野猪骑士要在在一条路上狩猎\",{\"1\":{\"128\":1}}],[\"野猪骑士在地块\",{\"1\":{\"128\":1}}],[\"野猪骑士\",{\"0\":{\"128\":1}}],[\"|\",{\"1\":{\"206\":5,\"311\":1,\"337\":1,\"338\":6,\"388\":1,\"422\":1,\"446\":13,\"591\":1,\"634\":1,\"663\":1,\"672\":1,\"766\":8,\"1144\":1}}],[\"|=\",{\"1\":{\"127\":1,\"1270\":5}}],[\"||\",{\"1\":{\"76\":1,\"82\":1,\"83\":1,\"88\":1,\"93\":4,\"127\":6,\"134\":1,\"139\":4,\"157\":1,\"172\":1,\"187\":3,\"224\":1,\"228\":3,\"229\":4,\"230\":4,\"235\":1,\"236\":1,\"237\":6,\"291\":3,\"311\":1,\"327\":1,\"329\":1,\"352\":1,\"360\":1,\"363\":1,\"423\":1,\"429\":1,\"526\":1,\"568\":1,\"578\":1,\"589\":2,\"596\":1,\"694\":1,\"700\":2,\"755\":2,\"784\":1,\"809\":1,\"820\":3,\"821\":4,\"834\":1,\"846\":1,\"876\":1,\"900\":1,\"901\":1,\"931\":1,\"985\":2,\"1239\":2,\"1242\":1,\"1243\":1,\"1251\":1,\"1252\":1,\"1271\":2,\"1272\":4,\"1273\":2,\"1274\":3,\"1275\":8,\"1368\":1,\"1370\":1,\"1506\":1,\"1508\":1}}],[\"接近\",{\"1\":{\"1264\":1}}],[\"接受一个集合容器\",{\"1\":{\"1072\":1}}],[\"接受原链表的头节点\",{\"1\":{\"886\":1}}],[\"接到结果链表中\",{\"1\":{\"789\":1}}],[\"接到后面\",{\"1\":{\"694\":1}}],[\"接收到通知条件满足\",{\"1\":{\"1254\":1}}],[\"接收请求并解析参数\",{\"1\":{\"576\":1}}],[\"接收参数\",{\"1\":{\"256\":2,\"573\":1}}],[\"接管已经渲染的静态内容\",{\"1\":{\"535\":1}}],[\"接着\",{\"1\":{\"1407\":1}}],[\"接着调用\",{\"1\":{\"1272\":1}}],[\"接着我们编写一个缓存操作的工具类\",{\"1\":{\"1201\":1}}],[\"接着我们来一步一步分析\",{\"1\":{\"1175\":1}}],[\"接着会访问根节点的右子树节点\",{\"1\":{\"724\":1}}],[\"接着按照\",{\"1\":{\"539\":1}}],[\"接着使用\",{\"1\":{\"538\":1}}],[\"接着修改生成的数据库实体类的字段配置\",{\"1\":{\"515\":1}}],[\"接着全局替换模块名和包名\",{\"1\":{\"514\":1}}],[\"接下来就去研究一下加入队列的方式\",{\"1\":{\"1504\":1}}],[\"接下来要对这些模板方法的逻辑进行学习\",{\"1\":{\"1500\":1}}],[\"接下来执行的操作由\",{\"1\":{\"1393\":1}}],[\"接下来看下\",{\"1\":{\"1305\":1}}],[\"接下来走到第\",{\"1\":{\"1283\":1}}],[\"接下来我们用一个\",{\"1\":{\"1250\":1}}],[\"接下来在\",{\"1\":{\"576\":1}}],[\"接下来一行\",{\"1\":{\"193\":1,\"199\":1}}],[\"接下来一行一个整数\",{\"1\":{\"166\":1,\"196\":1}}],[\"接下来\",{\"1\":{\"146\":1,\"156\":1,\"162\":1,\"166\":1,\"174\":1,\"196\":2,\"199\":1,\"202\":2,\"223\":1,\"263\":1,\"274\":1,\"278\":1,\"305\":1,\"875\":1,\"1251\":1,\"1284\":1,\"1346\":1,\"1350\":1,\"1501\":1}}],[\"接下来的\",{\"1\":{\"140\":1,\"180\":1}}],[\"接下来的每一行包括两个字符串\",{\"1\":{\"127\":1}}],[\"接口中的方法也只是调用了\",{\"1\":{\"1496\":1}}],[\"接口中定义的方法\",{\"1\":{\"1493\":1}}],[\"接口中不添加修饰符时\",{\"1\":{\"1031\":1}}],[\"接口出现之前\",{\"1\":{\"1492\":1}}],[\"接口外\",{\"1\":{\"1376\":1}}],[\"接口和\",{\"1\":{\"1371\":1}}],[\"接口和实现类\",{\"1\":{\"516\":1,\"519\":1}}],[\"接口而\",{\"1\":{\"1326\":1}}],[\"接口里面定义很多\",{\"1\":{\"1150\":1}}],[\"接口方式注入显得比较霸道\",{\"1\":{\"1133\":1}}],[\"接口方式注入\",{\"1\":{\"1133\":1}}],[\"接口注入\",{\"1\":{\"1133\":2}}],[\"接口协议\",{\"1\":{\"1095\":1}}],[\"接口实际上扩展自\",{\"1\":{\"1077\":1}}],[\"接口或者是\",{\"1\":{\"1074\":1}}],[\"接口时\",{\"1\":{\"1045\":1}}],[\"接口的类\",{\"1\":{\"1371\":1}}],[\"接口的类转换成\",{\"1\":{\"1370\":1}}],[\"接口的数据的无界阻塞队列\",{\"1\":{\"1326\":1}}],[\"接口的有\",{\"1\":{\"1326\":1}}],[\"接口的容器类\",{\"1\":{\"1324\":1}}],[\"接口的一个类\",{\"1\":{\"1231\":1}}],[\"接口的\",{\"1\":{\"1150\":1,\"1237\":2,\"1324\":3,\"1326\":1}}],[\"接口的多态\",{\"0\":{\"1034\":1}}],[\"接口的实现类\",{\"1\":{\"1371\":1}}],[\"接口的实现\",{\"0\":{\"1033\":1}}],[\"接口的继承\",{\"0\":{\"1032\":1}}],[\"接口的定义\",{\"0\":{\"1031\":1}}],[\"接口也可以继承其他接口\",{\"1\":{\"1030\":1}}],[\"接口设计关键\",{\"1\":{\"577\":1}}],[\"接口设计\",{\"0\":{\"573\":1}}],[\"接口文档来测试增删改查接口能否正常执行\",{\"1\":{\"520\":1}}],[\"接口文档测试\",{\"0\":{\"520\":1}}],[\"接口\",{\"0\":{\"1030\":1,\"1493\":1},\"1\":{\"518\":1,\"580\":1,\"596\":1,\"1036\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1059\":1,\"1074\":3,\"1076\":2,\"1078\":2,\"1094\":1,\"1140\":2,\"1151\":1,\"1178\":1,\"1267\":1,\"1325\":1,\"1326\":1,\"1330\":5,\"1365\":1,\"1367\":1,\"1375\":1,\"1376\":1,\"1492\":1}}],[\"接口开发\",{\"0\":{\"518\":1}}],[\"接口错误导致用户操作失败\",{\"1\":{\"37\":1}}],[\"接口qps与cpu\",{\"1\":{\"33\":1}}],[\"创建型\",{\"0\":{\"1532\":1}}],[\"创建型模式\",{\"2\":{\"965\":1,\"969\":1}}],[\"创建线程的工程类\",{\"1\":{\"1359\":1}}],[\"创建线程池后\",{\"1\":{\"1359\":1}}],[\"创建线程池主要是\",{\"1\":{\"1359\":1}}],[\"创建线程池demo\",{\"1\":{\"1330\":1}}],[\"创建新的数组\",{\"1\":{\"1294\":1}}],[\"创建新账号\",{\"1\":{\"675\":1}}],[\"创建cache实例\",{\"1\":{\"1211\":1}}],[\"创建上下文的持有者\",{\"0\":{\"1164\":1}}],[\"创建这个对象时\",{\"1\":{\"1153\":1}}],[\"创建了一个支持\",{\"1\":{\"1158\":1}}],[\"创建了一个支持缓存刷新的线程池\",{\"1\":{\"1158\":1}}],[\"创建了一个支持心跳检测的线程池\",{\"1\":{\"1158\":1}}],[\"创建了一个支持任务调度的线程池\",{\"1\":{\"1158\":1}}],[\"创建了一个\",{\"1\":{\"1153\":1,\"1158\":1,\"1160\":1,\"1162\":1,\"1163\":1,\"1164\":1,\"1178\":1}}],[\"创建默认的\",{\"0\":{\"1148\":1}}],[\"创建文件\",{\"1\":{\"1119\":1}}],[\"创建存储桶的时候\",{\"1\":{\"1102\":1}}],[\"创建对象\",{\"1\":{\"1070\":1}}],[\"创建索引\",{\"1\":{\"959\":1}}],[\"创建表时指定\",{\"1\":{\"937\":1}}],[\"创建表\",{\"1\":{\"916\":1}}],[\"创建表的\",{\"1\":{\"517\":1}}],[\"创建数据库\",{\"0\":{\"913\":1}}],[\"创建完成后系统会为此账号自动生成密码\",{\"1\":{\"675\":1}}],[\"创建供\",{\"1\":{\"675\":1}}],[\"创建证书\",{\"1\":{\"672\":1}}],[\"创建配置文件\",{\"1\":{\"671\":1}}],[\"创建分享链接等等\",{\"1\":{\"670\":1}}],[\"创建项目\",{\"0\":{\"538\":1}}],[\"创建题库题目关联接口\",{\"1\":{\"526\":1}}],[\"创建题库题目关联请求\",{\"1\":{\"526\":1}}],[\"创建题库题目关联\",{\"1\":{\"526\":3}}],[\"创建题目请求\",{\"1\":{\"517\":1}}],[\"创建用户\",{\"1\":{\"511\":1,\"512\":1,\"513\":1}}],[\"创建时间\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"566\":2,\"592\":1}}],[\"创建登录用户对象\",{\"1\":{\"451\":1}}],[\"创建方式二\",{\"1\":{\"257\":1}}],[\"创建方式一\",{\"1\":{\"257\":1}}],[\"创建\",{\"0\":{\"917\":1},\"1\":{\"257\":1,\"675\":1,\"911\":1,\"1158\":1,\"1388\":1}}],[\"创建两个\",{\"1\":{\"129\":1}}],[\"创建两个dp数组\",{\"1\":{\"109\":1}}],[\"创建dp数组\",{\"1\":{\"126\":1}}],[\"创建一个缓存实例\",{\"1\":{\"1204\":1,\"1207\":1}}],[\"创建一个路由组\",{\"1\":{\"542\":1}}],[\"创建一个栈\",{\"1\":{\"128\":1}}],[\"创建一个二维布尔数组\",{\"1\":{\"127\":2}}],[\"创建一个\",{\"1\":{\"126\":1,\"1151\":1,\"1250\":1,\"1283\":1}}],[\"柠檬微趣笔试\",{\"0\":{\"125\":1}}],[\"令人钦佩\",{\"1\":{\"1434\":1}}],[\"令牌\",{\"1\":{\"447\":1}}],[\"令\",{\"1\":{\"122\":1,\"338\":3,\"705\":1,\"1316\":1}}],[\"要经历如下两步\",{\"1\":{\"1417\":1}}],[\"要等到程序退出同步块后\",{\"1\":{\"1404\":1}}],[\"要由线程调度器重新激活这个线程\",{\"1\":{\"1332\":1}}],[\"要由操作系统为线程提供具体的运行时间\",{\"1\":{\"1331\":1}}],[\"要确定一个线程的当前状态\",{\"1\":{\"1329\":1}}],[\"要想使用原子更新字段需要两步操作\",{\"1\":{\"1388\":1}}],[\"要想合理的配置线程池\",{\"1\":{\"1361\":1}}],[\"要想学习到\",{\"1\":{\"1300\":1}}],[\"要想先学习\",{\"1\":{\"1281\":1}}],[\"要想将\",{\"1\":{\"1280\":1}}],[\"要想向\",{\"1\":{\"1272\":1}}],[\"要想不响应中断可以调用\",{\"1\":{\"1251\":1}}],[\"要想能够深入的掌握\",{\"1\":{\"1250\":1}}],[\"要想能够彻底的理解读写锁必须能够理解这样几个问题\",{\"1\":{\"1237\":1}}],[\"要想支持重入性\",{\"1\":{\"1232\":1}}],[\"要想完完全全的弄懂\",{\"1\":{\"1231\":1}}],[\"要强大的多\",{\"1\":{\"1202\":1}}],[\"要么恢复到无锁或者标记对象不适合作为偏向锁\",{\"1\":{\"1443\":1}}],[\"要么重新偏向于其他线程\",{\"1\":{\"1443\":1}}],[\"要么全部执行成功要么全部执行失败\",{\"1\":{\"1482\":1}}],[\"要么全部成功\",{\"1\":{\"955\":1}}],[\"要么全部失败\",{\"1\":{\"955\":2}}],[\"要么全都失败\",{\"1\":{\"953\":1}}],[\"要么全都成功\",{\"1\":{\"953\":1}}],[\"要么同时失败\",{\"1\":{\"953\":1}}],[\"要么所有的\",{\"1\":{\"953\":1}}],[\"要么不在\",{\"1\":{\"839\":1}}],[\"要么在\",{\"1\":{\"839\":1}}],[\"要删除倒数第\",{\"1\":{\"777\":1}}],[\"要解决这个问题的话\",{\"1\":{\"725\":1}}],[\"要支持在任意位置快速插入和删除元素\",{\"1\":{\"687\":1}}],[\"要让\",{\"1\":{\"687\":1}}],[\"要先在后台管理面板为对应用户组开启\",{\"1\":{\"675\":1}}],[\"要先通过查询关联表得到题目\",{\"1\":{\"525\":1}}],[\"要在登录页面添加\",{\"1\":{\"588\":1}}],[\"要和数据库中的密文密码\",{\"1\":{\"574\":1}}],[\"要同时更新题库表的题目总数\",{\"1\":{\"526\":1}}],[\"要用\",{\"1\":{\"526\":1}}],[\"要进行\",{\"1\":{\"526\":1}}],[\"要满足企业能把所有原始数据都\",{\"1\":{\"437\":1}}],[\"要有足够的扩展性和可靠性\",{\"1\":{\"437\":1}}],[\"要上取整\",{\"1\":{\"322\":1}}],[\"要向下取整\",{\"1\":{\"321\":1}}],[\"要将该数组从中间截断\",{\"1\":{\"262\":1}}],[\"要输出行的末尾并刷新输出\",{\"1\":{\"249\":1}}],[\"要给出最终答案\",{\"1\":{\"249\":1}}],[\"要使用\",{\"1\":{\"243\":1,\"675\":1}}],[\"要求编译器和处理器必须禁止这种重排序\",{\"1\":{\"1423\":1}}],[\"要求非空且唯一\",{\"1\":{\"919\":1}}],[\"要求从所有递增子序列\",{\"1\":{\"851\":1}}],[\"要求分成若干组\",{\"1\":{\"429\":1}}],[\"要求求解这个方程组\",{\"1\":{\"385\":1}}],[\"要求边长之和最小\",{\"1\":{\"359\":1}}],[\"要求计算\",{\"1\":{\"329\":1,\"330\":1}}],[\"要求计算出所有\",{\"1\":{\"324\":1}}],[\"要求找出一条路径\",{\"1\":{\"301\":1}}],[\"要求将\",{\"1\":{\"291\":1}}],[\"要求你回答\",{\"1\":{\"196\":1}}],[\"要求这些元组的等级差不能超过\",{\"1\":{\"140\":1}}],[\"要求\",{\"1\":{\"134\":1,\"262\":1,\"1421\":1}}],[\"要求如下\",{\"1\":{\"129\":1}}],[\"要注意到图中并不一定所有节点都相连\",{\"1\":{\"875\":1}}],[\"要注意\",{\"1\":{\"121\":1}}],[\"要权衡社会价值观引导\",{\"1\":{\"39\":1}}],[\"解锁\",{\"0\":{\"1447\":1},\"1\":{\"1482\":1}}],[\"解压后将\",{\"1\":{\"672\":1}}],[\"解压获取到的主程序\",{\"1\":{\"670\":1}}],[\"解压并启动\",{\"1\":{\"670\":1}}],[\"解法\",{\"1\":{\"372\":1}}],[\"解析\",{\"1\":{\"182\":1}}],[\"解释\",{\"1\":{\"121\":1,\"122\":1,\"180\":1,\"200\":1}}],[\"解决办法\",{\"1\":{\"1408\":1}}],[\"解决办法就是\",{\"1\":{\"1407\":1}}],[\"解决脏entry的问题\",{\"1\":{\"1307\":1}}],[\"解决隐藏的内存泄漏的问题\",{\"1\":{\"1306\":1}}],[\"解决外键关联\",{\"1\":{\"937\":1}}],[\"解决岛屿题目最常见的就是\",{\"1\":{\"820\":1}}],[\"解决大\",{\"1\":{\"613\":1}}],[\"解决的问题是如何对数据进行分析\",{\"1\":{\"437\":1}}],[\"解决的问题是如何把数据\",{\"1\":{\"437\":1}}],[\"解决方案可以沿袭数据库中常用的乐观锁方式\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"解决方案\",{\"1\":{\"1170\":1,\"1407\":1}}],[\"解决方案是利用消息队列\",{\"1\":{\"28\":1}}],[\"解决方法之一是可以通过\",{\"1\":{\"613\":1}}],[\"解决方法\",{\"1\":{\"526\":1,\"1406\":1}}],[\"解决方法是额外使用一个\",{\"1\":{\"274\":1}}],[\"解决\",{\"1\":{\"126\":1,\"446\":1}}],[\"解决高赞永远高赞的马太效应\",{\"1\":{\"39\":1}}],[\"解决高赞高踩的负面热评问题\",{\"1\":{\"39\":1}}],[\"解决热评的有无问题\",{\"1\":{\"39\":1}}],[\"位到返回的\",{\"1\":{\"1316\":1}}],[\"位当前已经插入的\",{\"1\":{\"1315\":1}}],[\"位进行异或运算\",{\"1\":{\"1272\":1}}],[\"位进行翻转\",{\"1\":{\"338\":1}}],[\"位与高\",{\"1\":{\"1272\":1}}],[\"位表示\",{\"1\":{\"1240\":1}}],[\"位用来表示读锁被获取的次数\",{\"1\":{\"1239\":1,\"1242\":1}}],[\"位用来表示写锁的获取次数\",{\"1\":{\"1239\":1}}],[\"位代表什么呢\",{\"1\":{\"1239\":1}}],[\"位然后减\",{\"1\":{\"1239\":1}}],[\"位可以用单词表示\",{\"1\":{\"783\":1}}],[\"位是否可以用\",{\"1\":{\"783\":1}}],[\"位于\",{\"1\":{\"465\":1,\"1258\":1,\"1316\":1}}],[\"位于应用与操作系统\",{\"1\":{\"14\":1}}],[\"位整数范围内\",{\"1\":{\"384\":1}}],[\"位上的数是否为\",{\"1\":{\"381\":1}}],[\"位数字移动到最后一位\",{\"1\":{\"339\":1}}],[\"位数\",{\"1\":{\"339\":1}}],[\"位数中\",{\"1\":{\"121\":1}}],[\"位设置为\",{\"1\":{\"338\":1}}],[\"位为\",{\"1\":{\"338\":3}}],[\"位运算符作用于位\",{\"1\":{\"337\":1}}],[\"位运算符\",{\"0\":{\"337\":1}}],[\"位运算\",{\"0\":{\"336\":1}}],[\"位工人来种树\",{\"1\":{\"173\":1}}],[\"位\",{\"1\":{\"162\":1,\"338\":4,\"339\":1,\"568\":2,\"574\":2,\"704\":1,\"783\":1,\"1239\":2,\"1316\":1,\"1440\":1}}],[\"位置向后环形\",{\"1\":{\"1316\":1}}],[\"位置放入\",{\"1\":{\"1274\":1}}],[\"位置必然是有效的括号对\",{\"1\":{\"846\":1}}],[\"位置对字符是否可以组成有效括号对\",{\"1\":{\"846\":1}}],[\"位置的元素再进行判断\",{\"1\":{\"1274\":1}}],[\"位置的最长括号长度加上当前位置新增的\",{\"1\":{\"846\":1}}],[\"位置的最长有效括号长度为\",{\"1\":{\"846\":2}}],[\"位置的量\",{\"1\":{\"194\":1}}],[\"位置没有节点\",{\"1\":{\"802\":2}}],[\"位置上的脏\",{\"1\":{\"1317\":2}}],[\"位置上\",{\"1\":{\"166\":1}}],[\"位置\",{\"1\":{\"166\":2}}],[\"位置从左至右编号为\",{\"1\":{\"157\":1}}],[\"位置和剩余体力\",{\"1\":{\"142\":1}}],[\"问先手是否必胜\",{\"1\":{\"394\":1}}],[\"问区间\",{\"1\":{\"372\":1}}],[\"问完一个问题后\",{\"1\":{\"249\":1}}],[\"问玩家能否移动到终点\",{\"1\":{\"142\":1}}],[\"问\",{\"1\":{\"120\":1}}],[\"问题在于\",{\"1\":{\"1482\":1}}],[\"问题了\",{\"1\":{\"1439\":1}}],[\"问题中\",{\"1\":{\"1324\":2,\"1344\":1}}],[\"问题变成从前\",{\"1\":{\"795\":2,\"893\":2}}],[\"问题枚举时\",{\"1\":{\"307\":1}}],[\"问题的关键在于\",{\"1\":{\"274\":1}}],[\"问题\",{\"1\":{\"40\":1,\"249\":1,\"613\":4,\"1384\":1,\"1418\":1,\"1439\":1}}],[\"游刃有余\",{\"1\":{\"234\":1}}],[\"游游有一个长度为\",{\"1\":{\"122\":1}}],[\"游游有两个整数\",{\"1\":{\"119\":1}}],[\"游游喜欢数数\",{\"1\":{\"121\":1}}],[\"游戏中的一幅图\",{\"1\":{\"213\":1}}],[\"游戏中有一个长度为\",{\"1\":{\"174\":1}}],[\"游戏的地图是一个\",{\"1\":{\"180\":1}}],[\"游戏给出一个区间\",{\"1\":{\"174\":1}}],[\"游戏规则如下\",{\"1\":{\"174\":1}}],[\"游戏结束\",{\"1\":{\"99\":1}}],[\"游戏开始时\",{\"1\":{\"97\":1}}],[\"携程笔试\",{\"0\":{\"118\":1}}],[\"完美满足了我所需要的功能\",{\"1\":{\"669\":1}}],[\"完美匹配\",{\"1\":{\"363\":1}}],[\"完整代码如下\",{\"1\":{\"568\":1}}],[\"完整\",{\"1\":{\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1}}],[\"完整的\",{\"1\":{\"215\":1,\"237\":1}}],[\"完全交由\",{\"1\":{\"1371\":1}}],[\"完全可以看出当前死锁的情况\",{\"1\":{\"1221\":1}}],[\"完全\",{\"1\":{\"417\":1}}],[\"完全背包模板\",{\"1\":{\"795\":1}}],[\"完全背包\",{\"0\":{\"297\":1,\"893\":1},\"1\":{\"795\":1,\"893\":1}}],[\"完全等于节点\",{\"1\":{\"216\":1}}],[\"完全平方数是一个整数\",{\"1\":{\"115\":1}}],[\"完全平方数\",{\"0\":{\"115\":1,\"793\":1},\"1\":{\"793\":1,\"794\":1}}],[\"完成对同步队列的头结点初始化工作以及\",{\"1\":{\"1506\":1}}],[\"完成链式队列的头结点的初始化\",{\"1\":{\"1504\":1}}],[\"完成扩容\",{\"1\":{\"1274\":1}}],[\"完成文件夹\",{\"1\":{\"1095\":1}}],[\"完成\",{\"1\":{\"676\":1}}],[\"完成了自定义类型的数据权限过滤\",{\"1\":{\"471\":1}}],[\"完成热评排序系统的平台化\",{\"1\":{\"40\":1}}],[\"完成各个特征的差异化实现与维护\",{\"1\":{\"40\":1}}],[\"完成一次用户交互\",{\"1\":{\"28\":1}}],[\"两行不存在数据依赖性可能会进行重排序\",{\"1\":{\"1418\":1}}],[\"两种写法均可\",{\"1\":{\"1114\":1}}],[\"两种方案不同\",{\"1\":{\"196\":1}}],[\"两者主要的区别\",{\"1\":{\"1338\":1}}],[\"两者都是通过读写分离的思想实现\",{\"1\":{\"1295\":1}}],[\"两者更新触发时机为\",{\"1\":{\"1286\":1}}],[\"两者除了在使用方式上不同外\",{\"1\":{\"1248\":1}}],[\"两者及其他们的关系都是通过\",{\"1\":{\"1129\":1}}],[\"两者相等\",{\"1\":{\"899\":1}}],[\"两者之差即为缺失的订单号\",{\"1\":{\"114\":1}}],[\"两次遍历\",{\"1\":{\"887\":1}}],[\"两次密码不一致\",{\"1\":{\"587\":1}}],[\"两节点之间路径的\",{\"1\":{\"759\":1}}],[\"两数相加\",{\"0\":{\"697\":1},\"1\":{\"697\":1}}],[\"两两交换其中相邻的节点\",{\"1\":{\"692\":1}}],[\"两两交换链表中的节点\",{\"0\":{\"691\":1},\"1\":{\"691\":1}}],[\"两台服务的成本确实会有点点高\",{\"1\":{\"664\":1}}],[\"两名玩家交替地把这枚棋子沿有向边进行移动\",{\"1\":{\"396\":1}}],[\"两名玩家轮流行动\",{\"1\":{\"394\":1}}],[\"两人都采取最优策略\",{\"1\":{\"394\":1}}],[\"两点及其权值\",{\"1\":{\"361\":1}}],[\"两重\",{\"1\":{\"354\":1}}],[\"两边递归\",{\"1\":{\"318\":1}}],[\"两条原子操作\",{\"1\":{\"1482\":1}}],[\"两条\",{\"1\":{\"196\":1}}],[\"两个核心\",{\"1\":{\"1455\":2}}],[\"两个操作重排序\",{\"1\":{\"1421\":1}}],[\"两个操作的执行顺序对最终结果都不会产生影响\",{\"1\":{\"1421\":1}}],[\"两个操作之间存在\",{\"1\":{\"1420\":1}}],[\"两个线程就能交换彼此的数据\",{\"1\":{\"1399\":1}}],[\"两个线程就可以交换数据\",{\"1\":{\"1399\":1}}],[\"两个线段树\",{\"1\":{\"206\":1}}],[\"两个接口的功能是可以等价使用的\",{\"1\":{\"1326\":1}}],[\"两个方法都没有直接返回\",{\"1\":{\"1275\":1}}],[\"两个客户端实例\",{\"1\":{\"1191\":1}}],[\"两个实现类\",{\"1\":{\"1072\":1,\"1074\":1}}],[\"两个节点\",{\"1\":{\"886\":1}}],[\"两个字符串的公共子序列是这两个字符串所共同拥有的子序列\",{\"1\":{\"838\":1}}],[\"两个迭代器\",{\"1\":{\"423\":1}}],[\"两个集合\",{\"1\":{\"362\":1,\"942\":1}}],[\"两个位相同为0\",{\"1\":{\"337\":1}}],[\"两个位都为0时\",{\"1\":{\"337\":1}}],[\"两个位都为1时\",{\"1\":{\"337\":1}}],[\"两个if把两个数组相同位上的数相加\",{\"1\":{\"327\":1}}],[\"两个整数\",{\"1\":{\"289\":1}}],[\"两个格子相临当且仅当他们有一条公共的边\",{\"1\":{\"196\":1}}],[\"两个格子\",{\"1\":{\"147\":1}}],[\"两个正整数\",{\"1\":{\"119\":1}}],[\"两道编程题\",{\"1\":{\"86\":1}}],[\"它将一些方法开放给子类进行重写\",{\"1\":{\"1495\":1}}],[\"它将变成非阻塞状态\",{\"1\":{\"1332\":1}}],[\"它简化了锁的实现方式\",{\"1\":{\"1494\":1}}],[\"它定义了使用者与锁交互的接口\",{\"1\":{\"1494\":1}}],[\"它提供了与\",{\"1\":{\"1492\":1}}],[\"它提供了一个交换的同步点\",{\"1\":{\"1399\":1}}],[\"它把工作内存中一个变量的值传送给主内存中以便随后的\",{\"1\":{\"1482\":1}}],[\"它把工作内存中一个变量的值传递给执行引擎\",{\"1\":{\"1482\":1}}],[\"它把\",{\"1\":{\"1482\":2}}],[\"它把一个从执行引擎接收到的值赋给工作内存的变量\",{\"1\":{\"1482\":1}}],[\"它把一个变量的值从主内存传输到线程的工作内存中\",{\"1\":{\"1482\":1}}],[\"它把一个变量标识为一个线程独占的状态\",{\"1\":{\"1482\":1}}],[\"它把一个处于锁定状态的变量释放出来\",{\"1\":{\"1482\":1}}],[\"它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用\",{\"1\":{\"1494\":1}}],[\"它仅仅保存的是一个引用\",{\"1\":{\"1467\":1}}],[\"它仅仅只能用来存储\",{\"1\":{\"668\":1}}],[\"它最大的特征就是在同一时刻只有一个线程能够获得对象的监视器\",{\"1\":{\"1434\":1}}],[\"它避免\",{\"1\":{\"1424\":1}}],[\"它才执行\",{\"1\":{\"1394\":1}}],[\"它假设所有线程访问共享资源的时候不会出现冲突\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"它可以保证每次出队的任务都是当前队列中执行时间最靠前的\",{\"1\":{\"1369\":1}}],[\"它可以让优先级高的任务先得到执行\",{\"1\":{\"1361\":1}}],[\"它可以在任何时候进行注入\",{\"1\":{\"1133\":1}}],[\"它不一定始终保持运行\",{\"1\":{\"1331\":1}}],[\"它不会从注册列表中剔除因长时间没收到心跳导致租期过期的服务\",{\"1\":{\"1191\":1}}],[\"它认为在出现脏\",{\"1\":{\"1317\":1}}],[\"它会首先暂停拥有偏向锁的线程\",{\"1\":{\"1443\":1}}],[\"它会完成整个系统的业务操作\",{\"1\":{\"1340\":1}}],[\"它会使当前线程让出\",{\"1\":{\"1339\":1}}],[\"它会继续往后环形搜索\",{\"1\":{\"1316\":1}}],[\"它会修改矢量的大小\",{\"1\":{\"254\":1}}],[\"它能够保证\",{\"1\":{\"1306\":1}}],[\"它强调没有一个线程可以阻塞其他线程\",{\"1\":{\"1225\":1}}],[\"它只是基于认为观测数据后\",{\"1\":{\"1218\":1}}],[\"它自动退出自我保护模式\",{\"1\":{\"1191\":1}}],[\"它尝试着从集群节点去获取所有的注册信息\",{\"1\":{\"1160\":1}}],[\"它继承\",{\"1\":{\"1140\":1}}],[\"它叫做应用上下文\",{\"1\":{\"1140\":1}}],[\"它实现了所有接口\",{\"1\":{\"1137\":1}}],[\"它允许程序在运行的时候动态的生成对象\",{\"1\":{\"1132\":1}}],[\"它允许开发者在\",{\"1\":{\"465\":1}}],[\"它还有一个别名为\",{\"1\":{\"1129\":1}}],[\"它以对象为单位来处理\",{\"1\":{\"1094\":1}}],[\"它表示了一个运行中的线程是否被其他线程进行了中断操作\",{\"1\":{\"1336\":1}}],[\"它表示了该键在哈希表中存储的位置\",{\"1\":{\"971\":1}}],[\"它表示函数不返回任何值\",{\"1\":{\"1014\":1}}],[\"它作用于一个整型参数\",{\"1\":{\"1010\":1}}],[\"它对数据库中的数据的改变就是永久的\",{\"1\":{\"955\":1}}],[\"它对数据库的改变将是永久性的\",{\"1\":{\"955\":1}}],[\"它是系统的守护者\",{\"1\":{\"1340\":1}}],[\"它是暂时不活动的\",{\"1\":{\"1332\":1}}],[\"它是在构造\",{\"1\":{\"1184\":1}}],[\"它是一个不可变类\",{\"1\":{\"1462\":1}}],[\"它是一个不可分割的工作单位\",{\"1\":{\"953\":1}}],[\"它是一个抽象类\",{\"1\":{\"1184\":1}}],[\"它是一个帮助类\",{\"1\":{\"1162\":1}}],[\"它是\",{\"1\":{\"1137\":1}}],[\"它是对一列的值进行计算\",{\"1\":{\"932\":1}}],[\"它是由原字符串在不改变字符的相对顺序的情况下删除某些字符\",{\"1\":{\"838\":1}}],[\"它支持\",{\"1\":{\"789\":1}}],[\"它真的太方便了\",{\"1\":{\"670\":1}}],[\"它拥有如下方法\",{\"1\":{\"466\":1}}],[\"它有的二大核心概念\",{\"1\":{\"445\":1}}],[\"它有较好的性能和准确度\",{\"1\":{\"210\":1}}],[\"它描述的是一种架构\",{\"1\":{\"438\":1}}],[\"它们之间执行顺序可以重排序\",{\"1\":{\"1418\":1}}],[\"它们之间的关系可以用下面一个图来表现得更加贴切\",{\"1\":{\"1253\":1}}],[\"它们都是属于读多写少的场景\",{\"1\":{\"1290\":1}}],[\"它们都是独占式获取锁\",{\"1\":{\"1237\":1}}],[\"它们属于类相关的概念\",{\"1\":{\"1010\":1}}],[\"它们的设计思想也是完全将这三个关键要素进行了解耦\",{\"1\":{\"1371\":1}}],[\"它们的原理都是遍历线程池中所有的线程\",{\"1\":{\"1360\":1}}],[\"它们的\",{\"1\":{\"839\":1}}],[\"它们的类型为\",{\"1\":{\"114\":1}}],[\"它们每位数字都是按照\",{\"1\":{\"698\":1}}],[\"它们通常在系统启动时启动\",{\"1\":{\"671\":1}}],[\"它们按照某种顺序排成长度为2n的序列\",{\"1\":{\"391\":1}}],[\"它就会被淹没\",{\"1\":{\"280\":1}}],[\"它主要用于处理一些不相交集合的合并问题\",{\"1\":{\"267\":1}}],[\"它的子类必须重写\",{\"1\":{\"1494\":1}}],[\"它的实现主要依赖一个\",{\"1\":{\"1494\":1}}],[\"它的源码为\",{\"1\":{\"1370\":1}}],[\"它的构造方法实际上是调用了\",{\"1\":{\"1366\":1}}],[\"它的容量是原来的两倍\",{\"1\":{\"1274\":1}}],[\"它的每一个实现类都代表了一种资源的访问策略\",{\"1\":{\"1135\":1}}],[\"它的每个元素是含有20个数组的数组\",{\"1\":{\"1000\":1}}],[\"它的左右子树也为二叉搜索树\",{\"1\":{\"899\":1}}],[\"它的\",{\"1\":{\"729\":1}}],[\"它的值小于或等于链表的长度\",{\"1\":{\"680\":1}}],[\"它的影响遍及各个行业和领域\",{\"1\":{\"434\":1}}],[\"它的行动规则是任选某个有向图游戏gi\",{\"1\":{\"399\":1}}],[\"它的一个重要推论是\",{\"1\":{\"248\":1,\"383\":1}}],[\"它的计算方法如下\",{\"1\":{\"219\":1}}],[\"它的计算方法如下图所示\",{\"1\":{\"218\":1}}],[\"它直接使用\",{\"1\":{\"56\":1}}],[\"慧策笔试\",{\"0\":{\"113\":1}}],[\"参照上图\",{\"1\":{\"1284\":1}}],[\"参照\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"参照页面原型以及需求文档设计数据库表结构\",{\"1\":{\"910\":1}}],[\"参数关闭偏向锁\",{\"1\":{\"1444\":1}}],[\"参数来关闭延迟\",{\"1\":{\"1444\":1}}],[\"参数可为字符串常量\",{\"1\":{\"1069\":1}}],[\"参数可以是字符串常量\",{\"1\":{\"1069\":1}}],[\"参数列表必须不同\",{\"1\":{\"1052\":1}}],[\"参数传递\",{\"0\":{\"1016\":1}}],[\"参数之后直接指定\",{\"1\":{\"906\":1}}],[\"参数不加\",{\"1\":{\"906\":2}}],[\"参数解释\",{\"1\":{\"663\":1}}],[\"参数所在的位置\",{\"1\":{\"587\":1}}],[\"参数校验\",{\"1\":{\"526\":2}}],[\"参数表示ip地址\",{\"1\":{\"446\":1}}],[\"参数表示角色\",{\"1\":{\"446\":2}}],[\"参数表示权限\",{\"1\":{\"446\":2}}],[\"参数\",{\"1\":{\"362\":1,\"466\":1,\"471\":1,\"663\":1,\"1120\":1,\"1284\":1,\"1315\":1}}],[\"参数取值范围\",{\"1\":{\"110\":1}}],[\"参考对\",{\"1\":{\"1385\":1}}],[\"参考文章\",{\"1\":{\"1276\":1}}],[\"参考文档\",{\"1\":{\"547\":1}}],[\"参考题解\",{\"1\":{\"688\":1}}],[\"参考\",{\"1\":{\"540\":1,\"576\":1,\"1171\":1}}],[\"参考官方文档在\",{\"1\":{\"540\":1}}],[\"参考过百度的贴吧\",{\"1\":{\"58\":1}}],[\"参考资料\",{\"1\":{\"41\":1}}],[\"下课期间\",{\"1\":{\"1399\":1}}],[\"下图就以这种执行时序出现的一种情况来讨论\",{\"1\":{\"1476\":1}}],[\"下图就展示了线程\",{\"1\":{\"1456\":1}}],[\"下图是线程\",{\"1\":{\"1456\":1}}],[\"下图是两个线程同时争夺锁\",{\"1\":{\"1447\":1}}],[\"下图线程\",{\"1\":{\"1443\":1}}],[\"下图表现了对象\",{\"1\":{\"1431\":1}}],[\"下图总结了\",{\"1\":{\"1375\":1}}],[\"下图为\",{\"1\":{\"1359\":1}}],[\"下图来源\",{\"1\":{\"1140\":1}}],[\"下文为了叙述\",{\"1\":{\"1314\":1}}],[\"下文会逐步讲解\",{\"1\":{\"1175\":1}}],[\"下使用cas算法来更新数据\",{\"1\":{\"1220\":1}}],[\"下一篇\",{\"1\":{\"1186\":1}}],[\"下一个子问题\",{\"1\":{\"851\":1}}],[\"下一个位置为\",{\"1\":{\"110\":1}}],[\"下篇我们再来讲解\",{\"1\":{\"1184\":1}}],[\"下篇还会讲到这一块\",{\"1\":{\"1184\":1}}],[\"下边\",{\"1\":{\"822\":1}}],[\"下标为0的元素代表栈顶\",{\"1\":{\"1046\":1}}],[\"下标的元素初始化为\",{\"1\":{\"772\":1}}],[\"下标就要初始化为负无穷\",{\"1\":{\"772\":1}}],[\"下标都初始化为\",{\"1\":{\"772\":1}}],[\"下标从0开始\",{\"1\":{\"1121\":1}}],[\"下标从1开始\",{\"1\":{\"411\":1}}],[\"下标从1开始存\",{\"1\":{\"305\":1}}],[\"下标从\",{\"1\":{\"120\":1,\"122\":1,\"417\":1}}],[\"下载安装包\",{\"1\":{\"1087\":1}}],[\"下载证书\",{\"1\":{\"672\":1}}],[\"下载速度只和机器自身的性能相关\",{\"1\":{\"670\":1}}],[\"下载对应的\",{\"1\":{\"665\":2}}],[\"下载之后在\",{\"1\":{\"613\":1}}],[\"下载\",{\"1\":{\"613\":1,\"665\":1,\"1089\":1,\"1090\":1}}],[\"下新建用户管理页\",{\"1\":{\"592\":1}}],[\"下的阻塞队列以及\",{\"1\":{\"1491\":1}}],[\"下的等待通知机制\",{\"1\":{\"1253\":1}}],[\"下的值\",{\"1\":{\"919\":1}}],[\"下的初始化函数\",{\"1\":{\"591\":1}}],[\"下的\",{\"1\":{\"559\":1,\"1380\":1}}],[\"下有很多脚本\",{\"1\":{\"559\":1}}],[\"下家\",{\"1\":{\"363\":1}}],[\"下面使用一个例子来进一步理解下\",{\"1\":{\"1496\":1}}],[\"下面结合实例来看\",{\"1\":{\"1476\":1}}],[\"下面用具体的代码演示\",{\"1\":{\"1466\":1}}],[\"下面用具体的代码来演示\",{\"1\":{\"1465\":1}}],[\"下面用一个例子来说明这种情况\",{\"1\":{\"1407\":1}}],[\"下面用一个具体的例子来说明\",{\"1\":{\"1392\":1}}],[\"下面用一个具体的例子来说说\",{\"1\":{\"1337\":1}}],[\"下面用一个简单的例子来说明\",{\"1\":{\"1385\":1,\"1398\":1}}],[\"下面用一个实例来有个直观的感受\",{\"1\":{\"1317\":1}}],[\"下面举一个简单的例子\",{\"1\":{\"1386\":1}}],[\"下面通过源码来看一看\",{\"1\":{\"1359\":1}}],[\"下面对参数进行说明\",{\"1\":{\"1359\":1}}],[\"下面对这几种常见的阻塞队列进行说明\",{\"1\":{\"1326\":1}}],[\"下面我结合各种情况详细说一下该方法的执行过程\",{\"1\":{\"1317\":1}}],[\"下面我们结合具体的代码\",{\"1\":{\"1455\":1}}],[\"下面我们一个个来看\",{\"1\":{\"1300\":1}}],[\"下面我们来看看\",{\"1\":{\"1252\":1}}],[\"下面我们带着这三个问题\",{\"1\":{\"1237\":1}}],[\"下面我们就针对这个图进行简单的拆分和补充说明\",{\"1\":{\"1134\":1}}],[\"下面\",{\"1\":{\"1309\":1,\"1316\":1}}],[\"下面是一个\",{\"1\":{\"1387\":1}}],[\"下面是一个示意图\",{\"1\":{\"1306\":1}}],[\"下面是一些个人配置\",{\"1\":{\"670\":1}}],[\"下面会具体详细来看\",{\"1\":{\"1365\":1}}],[\"下面会具体说的\",{\"1\":{\"1301\":1}}],[\"下面会作为一个具体的方法进行讲解\",{\"1\":{\"1272\":1}}],[\"下面来看些\",{\"1\":{\"1392\":1}}],[\"下面来看看\",{\"1\":{\"1345\":1}}],[\"下面来看下\",{\"1\":{\"1184\":1,\"1393\":1,\"1398\":1}}],[\"下面来分析一下多线程的情况\",{\"1\":{\"1284\":1}}],[\"下面继续从队列中\",{\"1\":{\"1284\":1}}],[\"下面的代码主要是新增的一些功能\",{\"1\":{\"1242\":1}}],[\"下面看题中完整的写法\",{\"1\":{\"274\":1}}],[\"下面有\",{\"1\":{\"273\":1}}],[\"下面以一个具体的例子来讲下如何使用这些规则进行推论\",{\"1\":{\"1421\":1}}],[\"下面以一个简单的例子来表述\",{\"1\":{\"1340\":1}}],[\"下面以两个方面来说\",{\"1\":{\"1419\":1}}],[\"下面以\",{\"1\":{\"235\":1}}],[\"下面这幅图对比了这种情况\",{\"1\":{\"212\":1}}],[\"下\",{\"0\":{\"571\":1},\"1\":{\"166\":1,\"224\":2,\"278\":1,\"279\":2,\"571\":1,\"1334\":1}}],[\"下放到消息队列\",{\"1\":{\"49\":1}}],[\"记住最简单的方式\",{\"1\":{\"887\":1}}],[\"记忆化\",{\"1\":{\"827\":1}}],[\"记忆化搜索是基于递归来实现的\",{\"1\":{\"796\":1}}],[\"记忆化搜索\",{\"0\":{\"784\":1,\"795\":1,\"827\":1}}],[\"记\",{\"1\":{\"392\":1}}],[\"记为\",{\"1\":{\"379\":1,\"388\":1,\"874\":1}}],[\"记得加上它本身\",{\"1\":{\"230\":1}}],[\"记录图中是否有环\",{\"1\":{\"876\":1}}],[\"记录遍历过的节点\",{\"1\":{\"876\":1}}],[\"记录一次dfs经过的节点\",{\"1\":{\"876\":1}}],[\"记录下一层被扩散的烂橘子\",{\"1\":{\"870\":1}}],[\"记录初始岛屿数\",{\"1\":{\"822\":1}}],[\"记录状态\",{\"1\":{\"784\":1}}],[\"记录当前结果\",{\"1\":{\"784\":1}}],[\"记录当前层的深度\",{\"1\":{\"736\":1}}],[\"记录并更新遍历到的节点\",{\"1\":{\"710\":1}}],[\"记录用户的状态\",{\"1\":{\"580\":1}}],[\"记录日志\",{\"1\":{\"451\":1}}],[\"记录素数个数\",{\"1\":{\"373\":1}}],[\"记录前缀中各个数字个数\",{\"1\":{\"309\":1}}],[\"记录答案\",{\"1\":{\"309\":1}}],[\"记录每层烂橘子的数量\",{\"1\":{\"869\":1}}],[\"记录每棵树包含的节点数\",{\"1\":{\"274\":1}}],[\"记录每个状态下的最优解\",{\"1\":{\"109\":1}}],[\"记录个数\",{\"1\":{\"262\":1}}],[\"记录最短路径\",{\"1\":{\"236\":1}}],[\"记录岛屿的最大面积\",{\"1\":{\"230\":1}}],[\"记录逆序对的对数\",{\"1\":{\"224\":1}}],[\"记录原来到达该状态的距离\",{\"1\":{\"224\":1}}],[\"记录到达此状态的操作和上一步状态\",{\"1\":{\"224\":1}}],[\"记录的是上一次种到的边界\",{\"1\":{\"173\":1}}],[\"记录其编号\",{\"1\":{\"168\":1}}],[\"记他选择的区间为\",{\"1\":{\"66\":1}}],[\"依旧以上面计算圆面积的进行描述\",{\"1\":{\"1421\":1}}],[\"依然可达\",{\"1\":{\"1318\":1}}],[\"依然使用独占锁的话\",{\"1\":{\"1237\":1}}],[\"依然还是以非公平锁为例\",{\"1\":{\"1232\":1}}],[\"依靠这种无缝集成和数据移动机制\",{\"1\":{\"438\":1}}],[\"依次往后搜索空单元\",{\"1\":{\"1306\":1}}],[\"依次类推\",{\"1\":{\"1012\":1}}],[\"依次遍历每个区间\",{\"1\":{\"430\":1}}],[\"依次经过非匹配边\",{\"1\":{\"363\":1}}],[\"依次枚举第一个集合中的每个点能否匹配第二个集合中的点\",{\"1\":{\"363\":1}}],[\"依次枚举\",{\"1\":{\"324\":1}}],[\"依次枚举每个分支\",{\"1\":{\"288\":1}}],[\"依次输入三个数\",{\"1\":{\"142\":1}}],[\"依次输入两个数\",{\"1\":{\"139\":1}}],[\"依照科学家的预测\",{\"1\":{\"280\":1}}],[\"依此不断的做\",{\"1\":{\"109\":1}}],[\"依赖数据库连接池的任务\",{\"1\":{\"1361\":1}}],[\"依赖\",{\"0\":{\"1209\":1}}],[\"依赖注入的三种实现形式\",{\"1\":{\"1133\":1}}],[\"依赖注入的名字就这么来的\",{\"1\":{\"1132\":1}}],[\"依赖注入\",{\"1\":{\"1132\":1}}],[\"依赖注入框架\",{\"1\":{\"557\":1}}],[\"依赖的对象由原来的主动获取变成被动接受\",{\"1\":{\"1129\":1}}],[\"依赖于m\",{\"1\":{\"920\":2}}],[\"依赖其他\",{\"1\":{\"51\":1}}],[\"依赖服务多\",{\"1\":{\"25\":1}}],[\"获得当前节点的先驱节点\",{\"1\":{\"1504\":1}}],[\"获得依赖对象的方式反转了\",{\"1\":{\"1131\":1}}],[\"获得美观度2\",{\"1\":{\"147\":1}}],[\"获得美观度\",{\"1\":{\"147\":1}}],[\"获得18个优惠券\",{\"1\":{\"109\":1}}],[\"获得3个优惠券\",{\"1\":{\"109\":1}}],[\"获得优惠券\",{\"1\":{\"109\":1}}],[\"获取同步状态失败的线程会加入到队列中进行自旋\",{\"1\":{\"1506\":1}}],[\"获取同步状态失败\",{\"0\":{\"1504\":1}}],[\"获取失败就将当前线程加入同步队列\",{\"1\":{\"1503\":1}}],[\"获取与lock绑定的等待通知组件\",{\"1\":{\"1493\":1}}],[\"获取所有正在等待许可的线程集合\",{\"1\":{\"1398\":1}}],[\"获取许可\",{\"1\":{\"1398\":1}}],[\"获取任务结果可以通过\",{\"1\":{\"1371\":1}}],[\"获取结果为null\",{\"1\":{\"1367\":1}}],[\"获取数据\",{\"1\":{\"1348\":2,\"1352\":1}}],[\"获取数据的线程会被阻塞\",{\"1\":{\"1325\":1}}],[\"获取map中当前threadlocal实例为key的值的entry\",{\"1\":{\"1302\":1}}],[\"获取map中的所有对象的集合\",{\"1\":{\"1040\":1}}],[\"获取该\",{\"1\":{\"1301\":1,\"1302\":1}}],[\"获取该题库所包含的题目列表\",{\"1\":{\"525\":1}}],[\"获取旧数组引用\",{\"1\":{\"1294\":1}}],[\"获取等待队列中第一个节点\",{\"1\":{\"1252\":1}}],[\"获取成功并支持重入\",{\"1\":{\"1239\":1}}],[\"获取写锁获取的次数\",{\"1\":{\"1239\":1}}],[\"获取写锁当前的同步状态\",{\"1\":{\"1239\":1}}],[\"获取读锁再释放写锁的次序\",{\"1\":{\"1237\":1,\"1244\":1}}],[\"获取过期策略\",{\"1\":{\"1211\":1}}],[\"获取cache实例\",{\"1\":{\"1211\":1}}],[\"获取缓存\",{\"1\":{\"1201\":1}}],[\"获取配置文件配置\",{\"0\":{\"1178\":1}}],[\"获取配置文件\",{\"1\":{\"1149\":1}}],[\"获取配置项\",{\"1\":{\"1147\":1}}],[\"获取堆顶元素但不删除\",{\"1\":{\"1078\":1}}],[\"获取堆顶元素并删除\",{\"1\":{\"1078\":1}}],[\"获取队列中的数据\",{\"1\":{\"1348\":1}}],[\"获取队头数据的线程会被阻塞\",{\"1\":{\"1325\":1}}],[\"获取队头元素\",{\"1\":{\"1325\":2}}],[\"获取队尾元素但不删除\",{\"1\":{\"1077\":1}}],[\"获取队尾元素并删除\",{\"1\":{\"1077\":1}}],[\"获取队首元素但不删除\",{\"1\":{\"1077\":1}}],[\"获取队首元素并删除\",{\"1\":{\"1077\":1}}],[\"获取锁出队\",{\"1\":{\"1507\":1}}],[\"获取锁成功\",{\"0\":{\"1505\":1}}],[\"获取锁成功进行出队操作\",{\"1\":{\"1501\":1}}],[\"获取锁失败的话\",{\"1\":{\"1505\":1}}],[\"获取锁失败进入等待状态\",{\"1\":{\"1504\":1}}],[\"获取锁失败进行入队操作\",{\"1\":{\"1501\":1}}],[\"获取锁失败\",{\"1\":{\"1504\":1}}],[\"获取锁放回true反之返回fasle\",{\"1\":{\"1493\":1}}],[\"获取锁的节点出队的逻辑是\",{\"1\":{\"1505\":1}}],[\"获取锁的过程能够响应中断\",{\"1\":{\"1493\":1}}],[\"获取锁的时候同样会从主内存中共享变量\",{\"1\":{\"1433\":1}}],[\"获取锁的指令\",{\"1\":{\"1431\":1}}],[\"获取锁\",{\"1\":{\"1061\":1,\"1493\":1}}],[\"获取类中的单个构造函数的信息\",{\"1\":{\"1055\":1}}],[\"获取类或接口中的单个字段的信息\",{\"1\":{\"1055\":1}}],[\"获取类或接口中的单个方法的信息\",{\"1\":{\"1055\":1}}],[\"获取类的实例对象\",{\"1\":{\"1055\":1}}],[\"获取值\",{\"1\":{\"1040\":1}}],[\"获取关键字\",{\"1\":{\"1040\":1}}],[\"获取第i个元素\",{\"1\":{\"1036\":1}}],[\"获取最小节点\",{\"1\":{\"789\":1}}],[\"获取不到实际的存储大小\",{\"1\":{\"676\":1}}],[\"获取后端的数据\",{\"1\":{\"592\":1}}],[\"获取登录态\",{\"1\":{\"589\":1}}],[\"获取当前有多少个线程阻塞等待在临界点上\",{\"1\":{\"1393\":1}}],[\"获取当前\",{\"1\":{\"1392\":1}}],[\"获取当前线程的threadlocalmap\",{\"1\":{\"1302\":1,\"1303\":1}}],[\"获取当前线程的实例对象\",{\"1\":{\"1302\":1}}],[\"获取当前线程实例对象\",{\"1\":{\"1301\":1}}],[\"获取当前的用户\",{\"1\":{\"589\":1}}],[\"获取当前用户\",{\"1\":{\"589\":1}}],[\"获取当前登录用户\",{\"0\":{\"589\":1}}],[\"获取当前任务的配置信息\",{\"1\":{\"482\":1}}],[\"获取封装类\",{\"1\":{\"523\":1}}],[\"获取到对象锁后\",{\"1\":{\"1407\":1}}],[\"获取到\",{\"1\":{\"1305\":1}}],[\"获取到题目列表\",{\"1\":{\"523\":1}}],[\"获取到业务的原始\",{\"1\":{\"50\":1}}],[\"获取题库\",{\"1\":{\"523\":2}}],[\"获取题库详情\",{\"0\":{\"523\":1},\"1\":{\"523\":1}}],[\"获取题库详情接口\",{\"1\":{\"521\":1}}],[\"获取题目列表\",{\"0\":{\"525\":1}}],[\"获取题目列表接口\",{\"1\":{\"521\":1}}],[\"获取题目详情接口\",{\"1\":{\"521\":1}}],[\"获取拼接后的语句\",{\"1\":{\"471\":1}}],[\"获取动态菜单路由\",{\"0\":{\"458\":1}}],[\"获取用户角色和权限\",{\"0\":{\"452\":1}}],[\"获取字符串长度\",{\"1\":{\"243\":1,\"1117\":1}}],[\"获取\",{\"1\":{\"243\":1,\"1253\":1,\"1385\":1}}],[\"获取叶子节点的个数\",{\"1\":{\"203\":1}}],[\"获取的楼层号就是重复的\",{\"1\":{\"28\":1}}],[\"置为哈希表的长度\",{\"1\":{\"1316\":1}}],[\"置为\",{\"1\":{\"108\":1,\"1308\":3,\"1316\":1}}],[\"置顶\",{\"1\":{\"22\":1}}],[\"按gbk转换\",{\"1\":{\"1069\":1}}],[\"按gbk编码转换\",{\"1\":{\"1069\":1}}],[\"按utf\",{\"1\":{\"1069\":3}}],[\"按系统默认编码转换\",{\"1\":{\"1069\":1}}],[\"按顺序遍历\",{\"1\":{\"822\":1}}],[\"按下快捷键\",{\"1\":{\"576\":1}}],[\"按左端点排序\",{\"1\":{\"431\":1}}],[\"按左端点从小到大排序\",{\"1\":{\"429\":1}}],[\"按右端点从小到大排序\",{\"1\":{\"427\":1}}],[\"按字典序\",{\"1\":{\"422\":1}}],[\"按字典序输出所有排列方案\",{\"1\":{\"281\":1}}],[\"按快排的从小到大的顺序遍历每条边\",{\"1\":{\"361\":1}}],[\"按位取反\",{\"1\":{\"338\":1}}],[\"按位异或\",{\"1\":{\"338\":1}}],[\"按位或\",{\"1\":{\"338\":1}}],[\"按位与\",{\"1\":{\"338\":1}}],[\"按值捕获\",{\"1\":{\"255\":2}}],[\"按引用捕获\",{\"1\":{\"255\":1}}],[\"按\",{\"1\":{\"223\":1}}],[\"按数字递增排序返回\",{\"1\":{\"108\":1}}],[\"按照推荐的方式\",{\"1\":{\"1496\":1}}],[\"按照上面分析\",{\"1\":{\"1284\":1}}],[\"按照之前的\",{\"1\":{\"1272\":1}}],[\"按照之前对\",{\"1\":{\"1242\":1}}],[\"按照等待队列是先进先出\",{\"1\":{\"1252\":1}}],[\"按照所预测的速度\",{\"1\":{\"1218\":1}}],[\"按照某一列或者某几列\",{\"1\":{\"933\":1}}],[\"按照列去统计有多少行数据\",{\"1\":{\"932\":1}}],[\"按照这个过程继续思考\",{\"1\":{\"789\":1}}],[\"按照这种设计\",{\"1\":{\"513\":1}}],[\"按照从顶部到底部的顺序\",{\"1\":{\"735\":1}}],[\"按照从小到大的顺序输出所有方案\",{\"1\":{\"288\":1,\"289\":1}}],[\"按照中序遍历的过程\",{\"1\":{\"730\":1}}],[\"按照文档在\",{\"1\":{\"575\":1}}],[\"按照\",{\"1\":{\"559\":1,\"1315\":1,\"1476\":1}}],[\"按照题库查询题目\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"按照排序后的顺序\",{\"1\":{\"141\":1}}],[\"按照消息反压的思路\",{\"1\":{\"49\":1}}],[\"按照安全等级划分服务\",{\"1\":{\"46\":1}}],[\"按照分层设计的原则拆分为3个部分\",{\"1\":{\"40\":1}}],[\"按照点赞率排序\",{\"1\":{\"40\":1}}],[\"按照点赞绝对值排序\",{\"1\":{\"40\":1}}],[\"按照正负样本加权平均的\",{\"1\":{\"40\":1}}],[\"按照时间顺序将每个任务进行排序\",{\"1\":{\"1369\":1}}],[\"按照时间\",{\"1\":{\"22\":1,\"45\":1}}],[\"房子的编号按顺序为\",{\"1\":{\"108\":1}}],[\"街里有\",{\"1\":{\"108\":1}}],[\"找右端点\",{\"1\":{\"322\":1}}],[\"找左端点\",{\"1\":{\"321\":1}}],[\"找不到文件\",{\"1\":{\"1048\":1}}],[\"找不到相应的类\",{\"1\":{\"1045\":1}}],[\"找不到返回\",{\"1\":{\"1005\":1}}],[\"找不到则返回最后一个元素的下标+1\",{\"1\":{\"423\":1}}],[\"找不到解决方案则输出\",{\"1\":{\"279\":1}}],[\"找不到为假\",{\"1\":{\"235\":1}}],[\"找一个\",{\"1\":{\"166\":1}}],[\"找出最长有效\",{\"1\":{\"844\":1}}],[\"找出滑动窗口中的最大值\",{\"1\":{\"410\":1}}],[\"找出每个数左边离它最近的比它大\",{\"1\":{\"407\":1}}],[\"找出所有可能的咖啡套餐中\",{\"1\":{\"152\":1}}],[\"找出缺失的订单号\",{\"1\":{\"114\":1}}],[\"找出能获得最多和最少优惠券的方案\",{\"1\":{\"109\":1}}],[\"找结论\",{\"1\":{\"104\":1}}],[\"找到前面的脏\",{\"1\":{\"1317\":1}}],[\"找到和查询的key相同的entry则返回\",{\"1\":{\"1307\":1}}],[\"找到队头节点后完成删除之后才会通过\",{\"1\":{\"1286\":1}}],[\"找到队尾节点后完成插入之后才会通过\",{\"1\":{\"1286\":1}}],[\"找到数据域不为\",{\"1\":{\"1284\":1}}],[\"找到hash值相同的key\",{\"1\":{\"1272\":1}}],[\"找到这个启动类\",{\"1\":{\"1145\":1}}],[\"找到其中最长严格递增子序列的长度\",{\"1\":{\"850\":1}}],[\"找到中点\",{\"1\":{\"833\":1}}],[\"找到中间结点后\",{\"1\":{\"833\":1}}],[\"找到第一个节点\",{\"1\":{\"789\":1}}],[\"找到第一个大于等于x的位置\",{\"1\":{\"341\":1}}],[\"找到该树中两个指定节点的最近公共祖先\",{\"1\":{\"753\":1}}],[\"找到该点赋给\",{\"1\":{\"360\":1}}],[\"找到后处理并弹出\",{\"1\":{\"731\":1}}],[\"找到当前节点左子树的最右节点\",{\"1\":{\"724\":1}}],[\"找到当前列绝对值最大的一行\",{\"1\":{\"385\":1}}],[\"找到对应的\",{\"1\":{\"575\":1}}],[\"找到\",{\"1\":{\"541\":1,\"559\":2,\"663\":1,\"665\":1,\"676\":1}}],[\"找到每一个数左边离他最近的比它小的数\",{\"1\":{\"407\":1}}],[\"找到绝对值最大的行\",{\"1\":{\"385\":1}}],[\"找到最小整数解\",{\"1\":{\"384\":1}}],[\"找到不在集合当中的最小的点\",{\"1\":{\"360\":1}}],[\"找到一个未加入集合且距离最近的点\",{\"1\":{\"352\":1}}],[\"找到与起点最近的且未确定最短路径的点\",{\"1\":{\"352\":1}}],[\"找到j的根节点\",{\"1\":{\"271\":1}}],[\"找到i的根节点\",{\"1\":{\"271\":1}}],[\"找到出口\",{\"1\":{\"236\":1}}],[\"找到出现次数大于等于\",{\"1\":{\"179\":1}}],[\"找到入口\",{\"1\":{\"236\":1,\"237\":1}}],[\"找到了位于边界上的出口\",{\"1\":{\"237\":1}}],[\"找到了终点\",{\"1\":{\"236\":1}}],[\"找到了起点\",{\"1\":{\"235\":1}}],[\"找到则为真\",{\"1\":{\"235\":1}}],[\"找到能容纳他们的最小桌子\",{\"1\":{\"162\":1}}],[\"找到链表的中点\",{\"1\":{\"134\":1}}],[\"找到它们的共同交集\",{\"1\":{\"70\":1}}],[\"找到记录的\",{\"1\":{\"50\":1}}],[\"均为\",{\"0\":{\"507\":1,\"508\":1}}],[\"均衡\",{\"0\":{\"104\":1}}],[\"均支持多副本\",{\"1\":{\"34\":1}}],[\"qx\",{\"1\":{\"1201\":2}}],[\"qcon演讲实录|赵彦奇\",{\"1\":{\"622\":1}}],[\"qq号\",{\"1\":{\"1131\":1}}],[\"qq号码\",{\"1\":{\"922\":2}}],[\"qq\",{\"1\":{\"567\":1,\"576\":1,\"922\":6,\"1204\":2}}],[\"qbq\",{\"1\":{\"525\":3}}],[\"qrtz\",{\"1\":{\"484\":11}}],[\"qps\",{\"1\":{\"436\":1}}],[\"q≤2×105\",{\"1\":{\"174\":1}}],[\"q≤50000\",{\"1\":{\"103\":1}}],[\"quartz集群所需数据库表\",{\"1\":{\"484\":1}}],[\"quartz中的核心组件\",{\"1\":{\"479\":1}}],[\"quartz\",{\"0\":{\"478\":1,\"479\":1},\"1\":{\"477\":1,\"484\":2,\"486\":1,\"487\":1}}],[\"quick\",{\"1\":{\"317\":3}}],[\"quickpow\",{\"1\":{\"139\":2}}],[\"questioncontroller\",{\"1\":{\"525\":1}}],[\"questionlist\",{\"1\":{\"525\":3}}],[\"questionservice\",{\"1\":{\"523\":1,\"525\":2,\"526\":5}}],[\"questionqueryrequest\",{\"1\":{\"523\":5,\"525\":13}}],[\"questionpage\",{\"1\":{\"523\":3,\"525\":4}}],[\"questionaddrequest\",{\"1\":{\"517\":2}}],[\"questiongankid\",{\"1\":{\"513\":1}}],[\"questionbankquestionremoverequest\",{\"1\":{\"526\":7}}],[\"questionbankquestionaddrequest\",{\"1\":{\"526\":6}}],[\"questionbankquestionservicelmpl\",{\"1\":{\"526\":1}}],[\"questionbankquestionserviceimpl\",{\"1\":{\"526\":1}}],[\"questionbankquestionservice\",{\"1\":{\"525\":1,\"526\":4}}],[\"questionbankquestion\",{\"1\":{\"525\":4,\"526\":17}}],[\"questionbankqueryrequest\",{\"1\":{\"523\":8}}],[\"questionbankservice\",{\"1\":{\"523\":2,\"526\":3}}],[\"questionbank\",{\"1\":{\"523\":4,\"526\":3}}],[\"questionbankcontroller\",{\"1\":{\"523\":1}}],[\"questionbankvo\",{\"1\":{\"523\":5}}],[\"questionbankd\",{\"1\":{\"513\":1}}],[\"questionbankid\",{\"1\":{\"513\":3,\"525\":6,\"526\":8}}],[\"questionidset\",{\"1\":{\"525\":2}}],[\"questionid\",{\"1\":{\"513\":2,\"525\":2,\"526\":8,\"542\":5}}],[\"question\",{\"1\":{\"511\":1,\"512\":1,\"513\":2,\"515\":3,\"517\":1,\"525\":3,\"526\":3,\"542\":3}}],[\"queued\",{\"1\":{\"1346\":1,\"1359\":1}}],[\"queue当前是否为空队列\",{\"1\":{\"1284\":2}}],[\"queue\",{\"0\":{\"1076\":1},\"1\":{\"180\":1,\"355\":2,\"422\":2,\"1076\":2,\"1077\":2,\"1239\":1,\"1242\":1,\"1250\":2,\"1252\":1,\"1283\":4,\"1284\":4,\"1324\":2,\"1325\":1,\"1346\":1,\"1350\":2,\"1359\":1,\"1369\":1,\"1408\":1,\"1411\":13}}],[\"queue<e>\",{\"1\":{\"1076\":1}}],[\"queue<>\",{\"1\":{\"1038\":1}}],[\"queue<pair<int\",{\"1\":{\"857\":1}}],[\"queue<pair<integer\",{\"1\":{\"821\":1,\"870\":1}}],[\"queue<pis\",{\"1\":{\"224\":1}}],[\"queue<pii>\",{\"1\":{\"278\":1}}],[\"queue<piii\",{\"1\":{\"223\":1}}],[\"queue<pii\",{\"1\":{\"223\":1,\"353\":1}}],[\"queue<string>\",{\"1\":{\"279\":1}}],[\"queue<int>\",{\"1\":{\"348\":1,\"355\":1,\"356\":1}}],[\"queue<int\",{\"1\":{\"180\":1,\"422\":1,\"429\":1}}],[\"queue<treenode>\",{\"1\":{\"737\":1,\"743\":1}}],[\"queue<treenode\",{\"1\":{\"133\":1}}],[\"querycurrentuser\",{\"1\":{\"591\":1}}],[\"querywrapper<>\",{\"1\":{\"568\":1,\"575\":1,\"578\":1}}],[\"querywrapper<user>\",{\"1\":{\"568\":1,\"575\":1,\"578\":1}}],[\"querywrapper<question>\",{\"1\":{\"525\":1}}],[\"querywrapper\",{\"1\":{\"525\":4,\"568\":3,\"575\":4,\"578\":3}}],[\"query\",{\"1\":{\"157\":4,\"412\":1,\"587\":2,\"909\":1}}],[\"q\",{\"1\":{\"103\":3,\"133\":8,\"174\":6,\"180\":4,\"187\":6,\"196\":4,\"197\":3,\"199\":4,\"200\":3,\"202\":3,\"203\":3,\"221\":1,\"273\":6,\"278\":6,\"279\":6,\"302\":4,\"317\":8,\"348\":6,\"349\":3,\"355\":8,\"356\":6,\"409\":4,\"410\":3,\"422\":1,\"525\":10,\"737\":7,\"743\":7,\"749\":5,\"753\":2,\"755\":4,\"809\":6,\"821\":5,\"857\":7,\"870\":12,\"888\":7,\"1076\":1,\"1077\":1,\"1283\":17,\"1284\":21,\"1285\":4}}],[\"qmi\",{\"1\":{\"87\":3,\"381\":1,\"388\":2,\"389\":2}}],[\"希望能对在看的朋友有所帮助~\",{\"1\":{\"1411\":1}}],[\"希望能进面\",{\"1\":{\"86\":1}}],[\"希望都能够完整保存下来\",{\"1\":{\"437\":1}}],[\"希望从大量的应用系统\",{\"1\":{\"436\":1}}],[\"希望你能告诉他经过这个操作后宝石项链的样子\",{\"1\":{\"103\":1}}],[\"然队列不为空队列\",{\"1\":{\"1284\":1}}],[\"然而\",{\"1\":{\"973\":1}}],[\"然而经过一段时间操作\",{\"1\":{\"103\":1}}],[\"然后根据\",{\"1\":{\"1508\":1}}],[\"然后根据哈希值快速定位到元素在表中的位置\",{\"1\":{\"971\":1}}],[\"然后根据哈希值将元素存储在表中适当的位置\",{\"1\":{\"971\":1}}],[\"然后插入同步队列的过程了\",{\"1\":{\"1504\":1}}],[\"然后检查持有偏向锁的线程是否活着\",{\"1\":{\"1443\":1}}],[\"然后去纸币付款收银员找零\",{\"1\":{\"1434\":1}}],[\"然后用\",{\"1\":{\"1431\":1}}],[\"然后彼此交换信物\",{\"1\":{\"1399\":1}}],[\"然后等女孩出来\",{\"1\":{\"1399\":1}}],[\"然后填写表格\",{\"1\":{\"1398\":1}}],[\"然后这一组线程再同时执行\",{\"1\":{\"1394\":1}}],[\"然后这些配置项统一都交给\",{\"1\":{\"1149\":1}}],[\"然后才能继续执行\",{\"1\":{\"1393\":1}}],[\"然后是通过针对\",{\"1\":{\"1385\":1}}],[\"然后会在\",{\"1\":{\"1505\":1}}],[\"然后会调用\",{\"1\":{\"1370\":1}}],[\"然后会被全局异常处理器处理返回\",{\"1\":{\"526\":1}}],[\"然后中断所有没有正在执行任务的线程\",{\"1\":{\"1360\":1}}],[\"然后尝试停止所有的正在执行和未执行任务的线程\",{\"1\":{\"1360\":1}}],[\"然后依次中断线程\",{\"1\":{\"1360\":1}}],[\"然后通知被阻塞的消费者线程\",{\"1\":{\"1347\":1}}],[\"然后通过\",{\"1\":{\"559\":1,\"1251\":1,\"1283\":1,\"1371\":1}}],[\"然后通过迭代细分场景下的召回策略\",{\"1\":{\"40\":1}}],[\"然后又传给下一个线程\",{\"1\":{\"1337\":1}}],[\"然后分别对着两个线程进行中断操作\",{\"1\":{\"1336\":1}}],[\"然后继续调用\",{\"1\":{\"1316\":1}}],[\"然后遍历旧数组中的\",{\"1\":{\"1306\":1}}],[\"然后遍历链表查找对应的元素\",{\"1\":{\"1306\":1}}],[\"然后进行后向环形查找\",{\"1\":{\"1317\":1}}],[\"然后进行插入\",{\"1\":{\"1306\":1}}],[\"然后进入下一轮\",{\"1\":{\"99\":1}}],[\"然后以当前\",{\"1\":{\"1302\":1}}],[\"然后同样以当前\",{\"1\":{\"1301\":1}}],[\"然后新的容器里添加元素\",{\"1\":{\"1291\":1}}],[\"然后线程尝试使用\",{\"1\":{\"1446\":1}}],[\"然后线程\",{\"1\":{\"1284\":1,\"1455\":1,\"1456\":1,\"1476\":1}}],[\"然后执行引擎会基于工作内存中的数据进行操作处理\",{\"1\":{\"1453\":1}}],[\"然后执行\",{\"1\":{\"1284\":1}}],[\"然后执行该脚本\",{\"1\":{\"1119\":1}}],[\"然后直接到第\",{\"1\":{\"1284\":1}}],[\"然后两者相减为\",{\"1\":{\"1274\":1}}],[\"然后两个指针同时移动\",{\"1\":{\"777\":1}}],[\"然后利用\",{\"1\":{\"1274\":1}}],[\"然后利用模运算快速得到结果\",{\"1\":{\"139\":1}}],[\"然后乘以加载因子\",{\"1\":{\"1271\":1}}],[\"然后加入到等待队列中\",{\"1\":{\"1251\":1}}],[\"然后调用\",{\"1\":{\"1250\":1,\"1308\":1,\"1387\":1,\"1505\":1}}],[\"然后调用注册的方法\",{\"1\":{\"1184\":1}}],[\"然后清除掉即可\",{\"1\":{\"1201\":1}}],[\"然后开启一个定时调度\",{\"1\":{\"1201\":1}}],[\"然后使用\",{\"1\":{\"1185\":1}}],[\"然后使用滑动窗口来找到满足等级差不超过\",{\"1\":{\"140\":1}}],[\"然后放到注册表里面\",{\"1\":{\"1165\":1}}],[\"然后放到一个\",{\"1\":{\"1141\":1}}],[\"然后想要获取上下文的就调用\",{\"1\":{\"1164\":1}}],[\"然后停止执行过期应用\",{\"1\":{\"1160\":1}}],[\"然后还创建了一个实例信息的副本\",{\"1\":{\"1158\":1}}],[\"然后还要在服务器上\",{\"1\":{\"663\":1}}],[\"然后交给\",{\"1\":{\"1151\":1}}],[\"然后交换左右子节点\",{\"1\":{\"864\":1}}],[\"然后获取环境的配置文件的配置项并覆盖之前的默认配置项\",{\"1\":{\"1149\":1}}],[\"然后获取默认配置文件的配置项\",{\"1\":{\"1149\":1}}],[\"然后像打针一样\",{\"1\":{\"1132\":1}}],[\"然后婚介就会按照我们的要求\",{\"1\":{\"1131\":1}}],[\"然后嘿嘿\",{\"1\":{\"1131\":1}}],[\"然后打听她们的兴趣爱好\",{\"1\":{\"1131\":1}}],[\"然后查看字符串池中是否存在\",{\"1\":{\"1069\":1}}],[\"然后对地址中的值修改\",{\"1\":{\"1018\":1}}],[\"然后可以对分类完的数据进行合并计算\",{\"1\":{\"933\":1}}],[\"然后返回一个结果值\",{\"1\":{\"932\":1}}],[\"然后返回给前端\",{\"1\":{\"458\":1}}],[\"然后回车\",{\"1\":{\"906\":1}}],[\"然后递归更新\",{\"1\":{\"803\":1}}],[\"然后更新\",{\"1\":{\"802\":1}}],[\"然后不断弹出堆中最小节点\",{\"1\":{\"789\":1}}],[\"然后走\",{\"1\":{\"777\":1}}],[\"然后访问根节点\",{\"1\":{\"729\":2}}],[\"然后缩小查找第\",{\"1\":{\"712\":1}}],[\"然后重写其中的\",{\"1\":{\"688\":1}}],[\"然后重复\",{\"1\":{\"377\":1}}],[\"然后修改\",{\"1\":{\"672\":1}}],[\"然后系统代理选择\",{\"1\":{\"665\":1}}],[\"然后就可以双击\",{\"1\":{\"665\":1}}],[\"然后就可以通过评论\",{\"1\":{\"58\":1}}],[\"然后国内的\",{\"1\":{\"664\":1}}],[\"然后测试代理服务是否可用\",{\"1\":{\"664\":1}}],[\"然后点击生成用户\",{\"1\":{\"665\":1}}],[\"然后点击\",{\"1\":{\"663\":1}}],[\"然后下载一个\",{\"1\":{\"662\":1}}],[\"然后整合\",{\"1\":{\"560\":1}}],[\"然后按照既定的代码逻辑执行\",{\"1\":{\"1330\":1}}],[\"然后按需精简和修改\",{\"1\":{\"548\":1}}],[\"然后按产品名称对结果进行升序排序\",{\"1\":{\"181\":1}}],[\"然后创建定时任务\",{\"1\":{\"481\":1}}],[\"然后删去它们的所有的倍数\",{\"1\":{\"371\":1}}],[\"然后将之前的头结点的\",{\"1\":{\"1505\":1}}],[\"然后将这个对象做\",{\"1\":{\"1439\":1}}],[\"然后将该值拷贝到线程\",{\"1\":{\"1433\":1}}],[\"然后将下一次任务继续放入到阻塞队列中\",{\"1\":{\"1368\":1}}],[\"然后将当前线程对象的\",{\"1\":{\"1301\":1}}],[\"然后将当前元素的下标入栈\",{\"1\":{\"128\":1}}],[\"然后将原来的\",{\"1\":{\"1284\":1}}],[\"然后将一个标志位设置为\",{\"1\":{\"1184\":1}}],[\"然后将前者目录中的内容覆盖替换到后者目录中\",{\"1\":{\"665\":1}}],[\"然后将\",{\"1\":{\"338\":3}}],[\"然后判断\",{\"1\":{\"317\":1}}],[\"然后每次都\",{\"1\":{\"291\":1}}],[\"然后我们再求其前缀和\",{\"1\":{\"263\":1}}],[\"然后从该位置移除元素\",{\"1\":{\"971\":1}}],[\"然后从\",{\"1\":{\"262\":1,\"372\":1,\"1303\":1,\"1317\":1}}],[\"然后从标准输入中输入响应\",{\"1\":{\"249\":1}}],[\"然后从每个瓶子到目标位置的距离\",{\"1\":{\"166\":1}}],[\"然后拿起瓶子把它放到\",{\"1\":{\"166\":1}}],[\"然后令这个数加\",{\"1\":{\"156\":1}}],[\"然后逐层处理队列中的节点\",{\"1\":{\"133\":1}}],[\"然后逐步计算出最终结果\",{\"1\":{\"72\":1}}],[\"然后求这些数位的全排列\",{\"1\":{\"121\":1}}],[\"然后购买剩下的3个商品价格为\",{\"1\":{\"109\":1}}],[\"然后在调用\",{\"1\":{\"1503\":1}}],[\"然后在通过\",{\"1\":{\"1376\":1}}],[\"然后在以\",{\"1\":{\"1301\":1}}],[\"然后在2004年秋季\",{\"1\":{\"1218\":1}}],[\"然后在遍历左子树的时候\",{\"1\":{\"729\":1}}],[\"然后在客户端接管渲染和交互\",{\"1\":{\"535\":1}}],[\"然后在\",{\"1\":{\"174\":1,\"471\":1,\"662\":1,\"1178\":1}}],[\"然后在剩下的商品里再购买若干子集\",{\"1\":{\"109\":1}}],[\"然后在排序分计算阶段根据召回结果实现这样的效果\",{\"1\":{\"40\":1}}],[\"然后比较两个指针所指向的元素\",{\"1\":{\"92\":1}}],[\"然后得到压缩结果\",{\"1\":{\"82\":1}}],[\"然后其他的线程直接从这个缓存里拿数据即可\",{\"1\":{\"60\":1}}],[\"然后它们都会去\",{\"1\":{\"60\":1}}],[\"然后批量返回\",{\"1\":{\"60\":1}}],[\"然后再变成\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"然后再与\",{\"1\":{\"1317\":2}}],[\"然后再\",{\"1\":{\"1283\":1}}],[\"然后再在\",{\"1\":{\"1276\":1}}],[\"然后再拼接当前环境的配置文件\",{\"1\":{\"1149\":1}}],[\"然后再调用\",{\"1\":{\"1149\":1}}],[\"然后再跟婚介公司打招呼\",{\"1\":{\"1133\":1}}],[\"然后再使用如下指令\",{\"1\":{\"906\":1}}],[\"然后再判断图中是否存在环\",{\"1\":{\"875\":1}}],[\"然后再进行加密存储\",{\"1\":{\"568\":1}}],[\"然后再根据实际开发修改部分代码即可使用\",{\"1\":{\"516\":1}}],[\"然后再加上现在的前缀和\",{\"1\":{\"261\":1}}],[\"然后再加载个性化信息\",{\"1\":{\"33\":1}}],[\"然后再遍历已经遍历过的点邻近的点\",{\"1\":{\"212\":1}}],[\"然后再考虑第二小的数字\",{\"1\":{\"167\":1}}],[\"然后再通过\",{\"1\":{\"56\":1}}],[\"然后导入到\",{\"1\":{\"50\":1}}],[\"然后消息堆积\",{\"1\":{\"49\":1}}],[\"然后发送一条消息给\",{\"1\":{\"48\":1}}],[\"然后\",{\"1\":{\"33\":1,\"66\":1,\"389\":1,\"531\":1,\"1131\":1,\"1149\":1,\"1284\":1,\"1406\":1,\"1434\":1,\"1469\":1}}],[\"轮游戏\",{\"1\":{\"174\":1}}],[\"轮\",{\"1\":{\"99\":1}}],[\"剩余数字个数小于\",{\"1\":{\"99\":1}}],[\"剩下的工作只是在\",{\"1\":{\"1132\":1}}],[\"剩下的就是质数\",{\"1\":{\"371\":1}}],[\"剩下题库和题目两个模块\",{\"1\":{\"521\":1}}],[\"剩下\",{\"1\":{\"99\":4}}],[\"被广泛使用在\",{\"1\":{\"1324\":1}}],[\"被重置\",{\"1\":{\"1317\":1}}],[\"被映射到数组的同一个位置\",{\"1\":{\"1306\":1}}],[\"被\",{\"1\":{\"1301\":1,\"1453\":1}}],[\"被赋值为\",{\"1\":{\"1283\":1,\"1285\":1}}],[\"被认为队列真正的尾节点\",{\"1\":{\"1283\":1}}],[\"被初始化为\",{\"1\":{\"1283\":2}}],[\"被唤醒的线程就会进行新一轮的夺锁之争\",{\"1\":{\"1447\":1}}],[\"被唤醒\",{\"1\":{\"1260\":1}}],[\"被唤醒啦\",{\"1\":{\"1063\":1}}],[\"被注入的对象需要什么\",{\"1\":{\"1129\":1}}],[\"被注入的对象直接依赖于被依赖的对象\",{\"1\":{\"1129\":1}}],[\"被所有类的对象共享\",{\"1\":{\"1027\":1}}],[\"被调函数开始执行\",{\"1\":{\"1011\":1}}],[\"被4整除即可\",{\"1\":{\"984\":1}}],[\"被定义为一条节点序列\",{\"1\":{\"717\":1}}],[\"被问懵了\",{\"1\":{\"629\":1}}],[\"被保护的敏感数据通常会被替换成某种规则定义的非敏感数据或者格\",{\"1\":{\"574\":1}}],[\"被剪的对象\",{\"1\":{\"200\":1}}],[\"被删除\",{\"1\":{\"99\":1}}],[\"被高频次的访问\",{\"1\":{\"61\":1}}],[\"删\",{\"1\":{\"924\":1,\"937\":1}}],[\"删掉后空出来的地方由后面的数字递补\",{\"1\":{\"99\":1}}],[\"删数游戏每一轮删除位置编号为\",{\"1\":{\"99\":1}}],[\"删除了一个元素让\",{\"1\":{\"1407\":1}}],[\"删除变量\",{\"0\":{\"1115\":1}}],[\"删除失败会抛出异常\",{\"1\":{\"1102\":1}}],[\"删除最后元素\",{\"1\":{\"1072\":1}}],[\"删除最后元素为o\",{\"1\":{\"1072\":1}}],[\"删除最小值\",{\"1\":{\"417\":1}}],[\"删除位于index的元素\",{\"1\":{\"1072\":1}}],[\"删除关键字\",{\"1\":{\"1040\":1}}],[\"删除元素\",{\"1\":{\"1039\":1,\"1325\":1}}],[\"删除元素时\",{\"1\":{\"971\":1}}],[\"删除并返回队头\",{\"1\":{\"1038\":1}}],[\"删除索引\",{\"1\":{\"959\":1}}],[\"删除数据是从\",{\"1\":{\"1303\":1}}],[\"删除数据\",{\"1\":{\"924\":1,\"1325\":2}}],[\"删除数据库\",{\"0\":{\"915\":1}}],[\"删除一个元素之后已经为空了\",{\"1\":{\"1407\":1}}],[\"删除一张不存在的表\",{\"1\":{\"923\":1}}],[\"删除一级评论时\",{\"1\":{\"37\":1}}],[\"删除字段\",{\"1\":{\"922\":1}}],[\"删除表语法\",{\"1\":{\"923\":1}}],[\"删除表\",{\"1\":{\"916\":1}}],[\"删除后返回\",{\"1\":{\"777\":1}}],[\"删除链表的倒数第\",{\"1\":{\"776\":1}}],[\"删除链表的倒数第n个节点\",{\"0\":{\"775\":1},\"1\":{\"775\":1}}],[\"删除操作\",{\"1\":{\"711\":1,\"971\":1}}],[\"删除用户\",{\"0\":{\"579\":1},\"1\":{\"579\":1}}],[\"删除项目根路径下\",{\"1\":{\"559\":3}}],[\"删除项目路径下\",{\"1\":{\"559\":3}}],[\"删除对应的路由规则\",{\"1\":{\"559\":1}}],[\"删除前端路径下\",{\"1\":{\"559\":1}}],[\"删除前导0\",{\"1\":{\"328\":1,\"329\":1,\"330\":1}}],[\"删除国际化\",{\"1\":{\"559\":1}}],[\"删除这个迭代器\",{\"1\":{\"422\":1}}],[\"删除所有x\",{\"1\":{\"422\":1}}],[\"删除任意一个元素\",{\"1\":{\"417\":1}}],[\"删除第k个点\",{\"1\":{\"404\":1}}],[\"删除或替换算作一次操作\",{\"1\":{\"305\":1}}],[\"删除玩家\",{\"1\":{\"129\":1}}],[\"删除情况如下\",{\"1\":{\"99\":1}}],[\"删除等\",{\"1\":{\"46\":1}}],[\"删除等可见性状态\",{\"1\":{\"30\":1}}],[\"删除二级评论时\",{\"1\":{\"37\":1}}],[\"删除\",{\"0\":{\"923\":1,\"927\":1},\"1\":{\"22\":1,\"45\":1,\"306\":1,\"475\":1,\"526\":1,\"566\":1,\"575\":1,\"592\":1,\"850\":1,\"911\":1,\"915\":1,\"1272\":1,\"1283\":1}}],[\"删除评论等\",{\"1\":{\"27\":1}}],[\"删除评论\",{\"1\":{\"22\":1,\"45\":1}}],[\"包提高原子更新基本类型的工具类\",{\"1\":{\"1385\":1}}],[\"包提供了一系列的操作简单\",{\"1\":{\"1380\":1}}],[\"包中提供了\",{\"1\":{\"1439\":1}}],[\"包中的精华\",{\"1\":{\"1491\":1}}],[\"包中的实现类也几乎都是用\",{\"1\":{\"1438\":1}}],[\"包中的原子操作类总结\",{\"0\":{\"1379\":1}}],[\"包中利用\",{\"1\":{\"1438\":1}}],[\"包中只提供了对\",{\"1\":{\"1385\":1}}],[\"包中\",{\"1\":{\"1299\":1}}],[\"包中实现了\",{\"1\":{\"1237\":1}}],[\"包而在\",{\"1\":{\"1299\":1}}],[\"包装\",{\"1\":{\"1309\":1}}],[\"包装成一个\",{\"1\":{\"1283\":1}}],[\"包装成一个线程安全的类\",{\"1\":{\"1290\":1}}],[\"包装成一个线程安全的\",{\"1\":{\"1264\":1}}],[\"包装类需要根据前端实际传递的请求参数或需要的响应结果自行修改\",{\"1\":{\"517\":1}}],[\"包才能使用\",{\"1\":{\"540\":1}}],[\"包管理器网站\",{\"1\":{\"538\":1}}],[\"包的整体实现图如下图所示\",{\"1\":{\"1491\":1}}],[\"包的结构层次\",{\"0\":{\"1491\":1}}],[\"包的实现\",{\"1\":{\"1438\":1}}],[\"包的视图类\",{\"1\":{\"517\":1}}],[\"包的请求类和\",{\"1\":{\"517\":1}}],[\"包下提供能原子更新数组中元素的类有\",{\"1\":{\"1386\":1}}],[\"包下的一些具体类用来方便程序员能够迅速高效率的进行并发编程\",{\"1\":{\"1423\":1}}],[\"包下的原子操作类的也主要是通过\",{\"1\":{\"1385\":1}}],[\"包下的这些类都是采用的是乐观锁策略去原子更新数据\",{\"1\":{\"1380\":1}}],[\"包下这些原子操作类的实现原理\",{\"1\":{\"1381\":1}}],[\"包下新建两个对象\",{\"1\":{\"576\":1}}],[\"包下\",{\"1\":{\"516\":1,\"1258\":1,\"1385\":1,\"1491\":1}}],[\"包\",{\"1\":{\"515\":1,\"580\":1}}],[\"包含三个值分别为\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"包含了三个步骤\",{\"1\":{\"1482\":1}}],[\"包含了两个方面\",{\"1\":{\"1423\":1}}],[\"包含了\",{\"1\":{\"1330\":1}}],[\"包含达到78万6千多个像素\",{\"1\":{\"1218\":1}}],[\"包含路径\",{\"1\":{\"1119\":1}}],[\"包含一组变量和函数\",{\"1\":{\"1025\":1}}],[\"包含一个由字符\",{\"1\":{\"280\":1}}],[\"包含一个字符串\",{\"1\":{\"224\":1}}],[\"包含一个整数\",{\"1\":{\"223\":1,\"279\":1,\"281\":1}}],[\"包含一个\",{\"1\":{\"98\":1}}],[\"包含常用的增删改查\",{\"1\":{\"567\":1}}],[\"包含前导零\",{\"1\":{\"309\":1}}],[\"包含两个用空格隔开的整数\",{\"1\":{\"290\":1}}],[\"包含\",{\"1\":{\"152\":1,\"156\":1,\"339\":1,\"682\":1}}],[\"包含所有可能是网吧的房间的编号集合\",{\"1\":{\"108\":1}}],[\"包括怎样存怎样取等等\",{\"1\":{\"1300\":1}}],[\"包括偏向锁\",{\"1\":{\"1264\":1}}],[\"包括但不限于\",{\"1\":{\"1093\":1}}],[\"包括但不限于书籍\",{\"1\":{\"19\":1}}],[\"包括整数\",{\"1\":{\"972\":1}}],[\"包括两张表交集部分数据\",{\"1\":{\"943\":2}}],[\"包括文件的读取\",{\"1\":{\"676\":1}}],[\"包括了\",{\"1\":{\"539\":1}}],[\"包括数据获取\",{\"1\":{\"533\":1}}],[\"包括执行历史\",{\"1\":{\"484\":1}}],[\"包括任务的开始执行时间\",{\"1\":{\"476\":1}}],[\"包括用户注册\",{\"1\":{\"521\":1}}],[\"包括用户\",{\"1\":{\"451\":1}}],[\"包括认证\",{\"1\":{\"446\":1}}],[\"包括对数据进行查询\",{\"1\":{\"437\":1}}],[\"包括定义数据源\",{\"1\":{\"437\":1}}],[\"包括结构化数据\",{\"1\":{\"434\":1}}],[\"包括负权边\",{\"1\":{\"354\":1}}],[\"包括加人\",{\"1\":{\"129\":1}}],[\"包括一些已有的在线\",{\"1\":{\"40\":1}}],[\"包括算法和策略的快速迭代\",{\"1\":{\"40\":1}}],[\"包括算法题\",{\"1\":{\"2\":1}}],[\"包括缓存\",{\"1\":{\"36\":1}}],[\"包括\",{\"1\":{\"30\":1,\"128\":1,\"157\":1,\"516\":2,\"548\":1,\"1069\":1}}],[\"包括评论\",{\"1\":{\"30\":1}}],[\"包括总评论数\",{\"1\":{\"30\":1}}],[\"包括发布人\",{\"1\":{\"30\":1}}],[\"包括送审\",{\"1\":{\"28\":1}}],[\"包括编程语言\",{\"1\":{\"7\":1}}],[\"本篇也是\",{\"1\":{\"1411\":1}}],[\"本篇将会给大家讲解我在本地搭建的\",{\"1\":{\"1189\":1}}],[\"本篇接近尾声\",{\"1\":{\"1186\":1}}],[\"本章中我们只使用静态成员变量和静态成员函数\",{\"1\":{\"1015\":1}}],[\"本来看都是\",{\"1\":{\"899\":1}}],[\"本身的\",{\"1\":{\"676\":1}}],[\"本身就在国内\",{\"1\":{\"664\":1}}],[\"本身就是有序的\",{\"1\":{\"422\":1}}],[\"本机存储\",{\"1\":{\"670\":1}}],[\"本地变量\",{\"1\":{\"1299\":1}}],[\"本地可以通过访问\",{\"1\":{\"1190\":1}}],[\"本地访问端口\",{\"1\":{\"672\":1}}],[\"本地已自动配置\",{\"1\":{\"665\":1}}],[\"本地代理客户端\",{\"0\":{\"665\":1},\"1\":{\"664\":1}}],[\"本地缓存\",{\"1\":{\"500\":1}}],[\"本项目中使用的\",{\"1\":{\"538\":1}}],[\"本项目用的是新的开发模式\",{\"1\":{\"537\":1}}],[\"本项目我们使用的是\",{\"1\":{\"537\":1}}],[\"本文主要将这三种实现方式进行总结归纳\",{\"1\":{\"1402\":1}}],[\"本文主要针对常见的岛屿问题\",{\"1\":{\"227\":1}}],[\"本文方法只适用于\",{\"1\":{\"766\":1}}],[\"本文仅使用\",{\"1\":{\"234\":1}}],[\"本质上是子集型问题\",{\"1\":{\"851\":1}}],[\"本质上是由\",{\"1\":{\"437\":1}}],[\"本质上是一种并查集的思想\",{\"1\":{\"200\":1}}],[\"本质上是求每个元素右侧第一个比它大的元素\",{\"1\":{\"128\":1}}],[\"本题翻译过来\",{\"1\":{\"893\":1}}],[\"本题的递推公式为\",{\"1\":{\"772\":1}}],[\"本题中每一个元素的数值既是重量\",{\"1\":{\"772\":1}}],[\"本题中模式字符串包含的字符的范围为字母\",{\"1\":{\"127\":1}}],[\"本题是要找是否可以将这个数组分割成两个子集\",{\"1\":{\"772\":1}}],[\"本题可被转化为求中序遍历的第\",{\"1\":{\"710\":1}}],[\"本题有自定义校验器\",{\"1\":{\"287\":1}}],[\"本题估价函数使用\",{\"1\":{\"223\":1}}],[\"本题为多组测试数据\",{\"1\":{\"97\":1}}],[\"本周会以\",{\"1\":{\"44\":1}}],[\"宇信科技笔试\",{\"0\":{\"96\":1}}],[\"否则只能在该方法出阻塞等待\",{\"1\":{\"1398\":1}}],[\"否则每个线程都得阻塞等待\",{\"1\":{\"1393\":1}}],[\"否则为\",{\"1\":{\"1325\":1}}],[\"否则则返回\",{\"1\":{\"1325\":1}}],[\"否则的话执行\",{\"1\":{\"1368\":1}}],[\"否则的话就是在\",{\"1\":{\"1307\":1}}],[\"否则的话内存中会有多份被复制的数据\",{\"1\":{\"1294\":1}}],[\"否则就只能等待\",{\"1\":{\"1431\":1}}],[\"否则就返回null即可\",{\"1\":{\"1273\":1}}],[\"否则就向红黑树追加新节点\",{\"1\":{\"1272\":1}}],[\"否则依次向后遍历\",{\"1\":{\"1272\":1}}],[\"否则再对该值进一步处理\",{\"1\":{\"1270\":1}}],[\"否则会报\",{\"1\":{\"1340\":1}}],[\"否则会一直阻塞\",{\"1\":{\"1258\":1}}],[\"否则会出现解锁失败的情况\",{\"1\":{\"1221\":1}}],[\"否则会出现水合错误\",{\"1\":{\"546\":1}}],[\"否则可能阻塞\",{\"1\":{\"1258\":1}}],[\"否则获取成功利用\",{\"1\":{\"1242\":1}}],[\"否则锁仍未释放\",{\"1\":{\"1232\":1}}],[\"否则poll\",{\"1\":{\"1076\":1}}],[\"否则停止\",{\"1\":{\"988\":1}}],[\"否则执行另一些语句\",{\"1\":{\"984\":1}}],[\"否则将会报错\",{\"1\":{\"913\":1}}],[\"否则将会得到超过限制限制的结果\",{\"1\":{\"249\":1}}],[\"否则不需要更换\",{\"1\":{\"1078\":1}}],[\"否则不执行删除\",{\"1\":{\"915\":1}}],[\"否则不能操作\",{\"1\":{\"914\":1}}],[\"否则不是\",{\"1\":{\"900\":1}}],[\"否则不更新\",{\"1\":{\"857\":1}}],[\"否则不存在拓扑序列\",{\"1\":{\"349\":1}}],[\"否则修改\",{\"1\":{\"852\":1}}],[\"否则匹配成功返回node\",{\"1\":{\"803\":1}}],[\"否则更新\",{\"1\":{\"802\":1}}],[\"否则返回一个负数值\",{\"1\":{\"1081\":1}}],[\"否则返回null\",{\"1\":{\"1076\":2}}],[\"否则返回最小生成树的树边权重之和\",{\"1\":{\"360\":1}}],[\"否则返回\",{\"1\":{\"328\":1,\"686\":1,\"875\":1}}],[\"否则返回flase\",{\"1\":{\"328\":1}}],[\"否则返回false\",{\"1\":{\"328\":1,\"356\":1,\"1069\":1,\"1073\":2,\"1074\":3,\"1075\":1,\"1076\":2,\"1077\":1,\"1078\":1,\"1398\":1}}],[\"否则需要再加一辆车\",{\"1\":{\"290\":1}}],[\"否则一定是输的\",{\"1\":{\"174\":1}}],[\"否则容易超时\",{\"1\":{\"128\":2}}],[\"否则放到其后\",{\"1\":{\"103\":1}}],[\"否则输出no\",{\"1\":{\"984\":1}}],[\"否则输出一个正整数\",{\"1\":{\"180\":1}}],[\"否则输出\",{\"1\":{\"97\":1,\"235\":1,\"273\":1,\"274\":1}}],[\"否则\",{\"1\":{\"93\":2,\"99\":1,\"108\":1,\"128\":1,\"174\":1,\"186\":1,\"187\":1,\"302\":1,\"465\":1,\"801\":2,\"846\":1,\"874\":1,\"1239\":1,\"1251\":1,\"1270\":1,\"1358\":3,\"1393\":1,\"1398\":1,\"1496\":1,\"1506\":1,\"1510\":1}}],[\"否则两条同时发布的评论\",{\"1\":{\"28\":1}}],[\"匹配任意个字符\",{\"1\":{\"931\":1}}],[\"匹配任何单个字符\",{\"1\":{\"127\":1}}],[\"匹配单个字符\",{\"1\":{\"931\":1}}],[\"匹配所有请求路径\",{\"1\":{\"446\":1}}],[\"匹配完成后的具体操作\",{\"1\":{\"411\":1}}],[\"匹配完我输出一下\",{\"1\":{\"411\":1}}],[\"匹配操作\",{\"1\":{\"411\":1}}],[\"匹配时\",{\"1\":{\"411\":2}}],[\"匹配边\",{\"1\":{\"363\":1}}],[\"匹配一个或多个\",{\"1\":{\"127\":1}}],[\"匹配一个或多个前面的字符\",{\"1\":{\"127\":1}}],[\"匹配零个\",{\"1\":{\"127\":1}}],[\"匹配零个或多个前面的字符\",{\"1\":{\"127\":1}}],[\"匹配应该覆盖到整个输入的字符串\",{\"1\":{\"127\":1}}],[\"匹配\",{\"1\":{\"93\":1,\"187\":1,\"363\":3}}],[\"或停止自旋\",{\"1\":{\"1506\":1}}],[\"或其他能判断真假的条件\",{\"1\":{\"1407\":1}}],[\"或在通知被遗漏后\",{\"1\":{\"1406\":1}}],[\"或多或少是由于硬件设计者无计可施了导致的\",{\"1\":{\"1218\":1}}],[\"或实例\",{\"1\":{\"963\":1}}],[\"或从小到大\",{\"1\":{\"958\":1}}],[\"或不删除\",{\"1\":{\"850\":1}}],[\"或竖直方向上相邻的陆地连接形成\",{\"1\":{\"819\":1}}],[\"或组件\",{\"1\":{\"545\":1}}],[\"或静态生成\",{\"1\":{\"535\":1}}],[\"或静态服务器提供\",{\"1\":{\"534\":1}}],[\"或指针\",{\"1\":{\"423\":3}}],[\"或已经是海水了\",{\"1\":{\"230\":1}}],[\"或已经是海水了则返回\",{\"1\":{\"229\":1}}],[\"或\",{\"1\":{\"93\":2,\"127\":2,\"161\":1,\"228\":1,\"278\":2,\"323\":1,\"337\":1,\"362\":1,\"421\":1,\"467\":1,\"502\":1,\"533\":1,\"545\":1,\"668\":1,\"931\":4,\"985\":1,\"1094\":1,\"1107\":1,\"1361\":1}}],[\"或者能够确保只有一个线程修改变量的值\",{\"1\":{\"1482\":1}}],[\"或者能隐式地转换函数的返回类型\",{\"1\":{\"1021\":1}}],[\"或者其他能够判断真假的条件\",{\"1\":{\"1406\":1}}],[\"或者调用\",{\"1\":{\"1375\":1}}],[\"或者也可以使用优先级队列\",{\"1\":{\"1361\":1}}],[\"或者初始化时通过构造器参数\",{\"1\":{\"1326\":1}}],[\"或者用\",{\"1\":{\"1290\":1}}],[\"或者用更复杂的锁实现\",{\"1\":{\"28\":1}}],[\"或者在调用方进行任何其他的协调操作\",{\"1\":{\"1415\":1}}],[\"或者在执行任务期间抛出异常\",{\"1\":{\"1375\":1}}],[\"或者在等待时被中断会做中断处理\",{\"1\":{\"1251\":1}}],[\"或者在一个题库中查找特定问题\",{\"1\":{\"513\":1}}],[\"或者从\",{\"1\":{\"1131\":1}}],[\"或者是字符串\",{\"1\":{\"1074\":1}}],[\"或者是复杂的业务逻辑\",{\"1\":{\"526\":1}}],[\"或者超出字符串的大小\",{\"1\":{\"1045\":1}}],[\"或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程\",{\"1\":{\"1045\":1}}],[\"或者克隆图\",{\"1\":{\"887\":1}}],[\"或者说\",{\"1\":{\"801\":1}}],[\"或者直接回车\",{\"1\":{\"663\":1}}],[\"或者直接插入由数据湖托管的外部表中\",{\"1\":{\"438\":1}}],[\"或者重载\",{\"1\":{\"423\":1}}],[\"或者c++中的\",{\"1\":{\"249\":1}}],[\"或者问题用完了\",{\"1\":{\"249\":1}}],[\"或者关闭同步流\",{\"1\":{\"128\":1}}],[\"或者有状态层\",{\"1\":{\"49\":1}}],[\"或者\",{\"1\":{\"48\":1,\"255\":1,\"274\":1,\"321\":1,\"322\":1,\"338\":1,\"467\":1,\"538\":1,\"613\":1,\"663\":1,\"852\":2,\"931\":1,\"1113\":1,\"1114\":1,\"1237\":1,\"1253\":1,\"1299\":1,\"1302\":1,\"1326\":1,\"1334\":1,\"1359\":1,\"1376\":1,\"1410\":1,\"1418\":1}}],[\"或者高于多少等级的用户才能发表评论\",{\"1\":{\"45\":1}}],[\"判断之间返回\",{\"1\":{\"1508\":1}}],[\"判断相同的两个对象其\",{\"1\":{\"1472\":1}}],[\"判断后就不会执行\",{\"1\":{\"1406\":1}}],[\"判断线程池中所有的线程是否都在执行任务\",{\"1\":{\"1358\":1}}],[\"判断也为\",{\"1\":{\"1284\":1}}],[\"判断为\",{\"1\":{\"1271\":1,\"1283\":6,\"1284\":6,\"1285\":1,\"1317\":1,\"1508\":1}}],[\"判断该pair是否和对象元素e相等\",{\"1\":{\"1082\":1}}],[\"判断字符串是否为空\",{\"1\":{\"1069\":1}}],[\"判断字符串是否有效\",{\"1\":{\"93\":1}}],[\"判断两个字符串的字典序大小\",{\"1\":{\"1005\":1}}],[\"判断两个字符串是否相等\",{\"1\":{\"1005\":1}}],[\"判断两个指针当前节点值是否相等\",{\"1\":{\"808\":1}}],[\"判断一个大于\",{\"1\":{\"992\":1}}],[\"判断闰年\",{\"1\":{\"984\":1,\"985\":1}}],[\"判断语句\",{\"0\":{\"983\":1}}],[\"判断区间为\",{\"1\":{\"899\":1}}],[\"判断以\",{\"1\":{\"899\":1}}],[\"判断其是否是一个有效的二叉搜索树\",{\"1\":{\"898\":1}}],[\"判断对应的两个节点是否相等\",{\"1\":{\"809\":1}}],[\"判断条件不同\",{\"1\":{\"933\":1}}],[\"判断条件\",{\"1\":{\"772\":1,\"846\":1,\"875\":1}}],[\"判断分析本层递归返回值的具体值\",{\"1\":{\"713\":1}}],[\"判断用户是否拥有某个角色\",{\"1\":{\"466\":1}}],[\"判断当前任务是否是周期性任务\",{\"1\":{\"1368\":1}}],[\"判断当前阻塞队列是否已满\",{\"1\":{\"1358\":1}}],[\"判断当前\",{\"1\":{\"1272\":1}}],[\"判断当前线程能否获得锁为例\",{\"1\":{\"1232\":1}}],[\"判断当前最大值的位置\",{\"1\":{\"857\":1}}],[\"判断当前深度\",{\"1\":{\"736\":1}}],[\"判断当前元素与队尾元素是否满足单调性问题\",{\"1\":{\"410\":2}}],[\"判断当前a和c是否满足条件\",{\"1\":{\"291\":1}}],[\"判断队头是否滑出窗口\",{\"1\":{\"410\":1}}],[\"判断队头是否已经滑出窗口\",{\"1\":{\"410\":1}}],[\"判断队列是否为空\",{\"1\":{\"409\":1,\"1078\":1}}],[\"判断栈是否为空\",{\"1\":{\"406\":1}}],[\"判断这条边的两个顶点是否有相同的父节点\",{\"1\":{\"361\":1}}],[\"判断\",{\"1\":{\"354\":2,\"361\":1,\"712\":1,\"783\":1,\"808\":2,\"899\":1}}],[\"判断奇偶\",{\"1\":{\"338\":1}}],[\"判断b在这一位上有没有数\",{\"1\":{\"328\":1}}],[\"判断是否超过了允许的最大值\",{\"1\":{\"1270\":1}}],[\"判断是否过期\",{\"1\":{\"1201\":1}}],[\"判断是否要把自己注册到其他\",{\"1\":{\"1158\":1}}],[\"判断是否要获取注册表信息\",{\"1\":{\"1158\":1}}],[\"判断是否为空白字符串\",{\"1\":{\"1069\":1}}],[\"判断是否以某个后缀结尾\",{\"1\":{\"1005\":1}}],[\"判断是否以某个前缀开头\",{\"1\":{\"1005\":1}}],[\"判断是否符合预期结果\",{\"1\":{\"567\":1}}],[\"判断是否拥有该权限\",{\"1\":{\"465\":1}}],[\"判断是否全为0\",{\"1\":{\"422\":1}}],[\"判断是否至少有一个1\",{\"1\":{\"422\":1}}],[\"判断是否有其他线程进行了修改操作\",{\"1\":{\"1276\":1}}],[\"判断是否有\",{\"1\":{\"328\":1}}],[\"判断是否变成了目标串\",{\"1\":{\"279\":1}}],[\"判断可能的答案更新区间\",{\"1\":{\"323\":1}}],[\"判断每一位上的数字是否用过\",{\"1\":{\"291\":1}}],[\"判断每一个字符的首字母是否为大写即可\",{\"1\":{\"172\":1}}],[\"判断能否逃出迷宫\",{\"1\":{\"235\":1}}],[\"判断逻辑\",{\"1\":{\"173\":1}}],[\"判断小紫在落地的时刻是否在魔法水晶箭的爆炸范围内即可\",{\"1\":{\"97\":1}}],[\"判定存在后\",{\"1\":{\"31\":1}}],[\"合二为一\",{\"1\":{\"318\":1}}],[\"合法路径共有\",{\"1\":{\"196\":2}}],[\"合并排序后的两部分\",{\"1\":{\"834\":1}}],[\"合并岛屿\",{\"1\":{\"822\":1}}],[\"合并后的第二个节点\",{\"1\":{\"789\":1}}],[\"合并后的第一个节点\",{\"1\":{\"789\":1}}],[\"合并k个升序链表\",{\"1\":{\"787\":1}}],[\"合并a和b所在的两个集合\",{\"1\":{\"415\":1,\"416\":1}}],[\"合并x和y所在的两个集合\",{\"1\":{\"414\":1}}],[\"合并两步后\",{\"1\":{\"339\":1}}],[\"合并两个有序链表\",{\"1\":{\"134\":1}}],[\"合并区间\",{\"1\":{\"318\":1}}],[\"合并\",{\"0\":{\"271\":1,\"787\":1},\"1\":{\"267\":1,\"273\":1,\"274\":1}}],[\"合并到一个结果集中\",{\"1\":{\"181\":1}}],[\"合并时\",{\"1\":{\"134\":1}}],[\"合并链表\",{\"1\":{\"134\":1}}],[\"合并数组一般使用双指针实现\",{\"1\":{\"92\":1}}],[\"合并数组\",{\"0\":{\"92\":1}}],[\"合规性要求\",{\"1\":{\"36\":1}}],[\"好了\",{\"1\":{\"1186\":1,\"1283\":1}}],[\"好处是可以提供即时的交互体验和日志查看\",{\"1\":{\"671\":1}}],[\"好未来笔试\",{\"0\":{\"91\":1}}],[\"好友点赞等\",{\"1\":{\"22\":1}}],[\"该同步组件只能在同一时刻被线程占用\",{\"1\":{\"1496\":1}}],[\"该组件已经被线程占用返回\",{\"1\":{\"1496\":1}}],[\"该代码依然存在线程安全的问题\",{\"1\":{\"1478\":1}}],[\"该代码的\",{\"1\":{\"1432\":1}}],[\"该对象的\",{\"1\":{\"1476\":1,\"1478\":1}}],[\"该实例的实例变量是不可改变的\",{\"1\":{\"1472\":1}}],[\"该实参能自动转换成int类型\",{\"1\":{\"1012\":1}}],[\"该初始值在编译时就能够唯一指定\",{\"1\":{\"1467\":1}}],[\"该变量就会成为一个\",{\"1\":{\"1467\":1}}],[\"该怎么办了\",{\"1\":{\"1456\":1}}],[\"该图可以看出\",{\"1\":{\"1431\":1}}],[\"该图为\",{\"1\":{\"1134\":1}}],[\"该示例代码如下\",{\"1\":{\"1398\":1}}],[\"该示例代码中设置了两个\",{\"1\":{\"1392\":1}}],[\"该接口定义了可延时执行异步任务和可周期执行异步任务的特有功能\",{\"1\":{\"1367\":1}}],[\"该接口定义了\",{\"1\":{\"1365\":1}}],[\"该接口本质上还是查询题目列表\",{\"1\":{\"525\":1}}],[\"该线程就进入同步状态\",{\"1\":{\"1431\":1}}],[\"该线程就会被阻塞\",{\"1\":{\"1332\":1}}],[\"该线程才能继续往下执行\",{\"1\":{\"1398\":1}}],[\"该线程会退出\",{\"1\":{\"1325\":1}}],[\"该队列命令元素\",{\"1\":{\"1326\":1}}],[\"该情形如下图所示\",{\"1\":{\"1317\":4}}],[\"该操作源码为\",{\"1\":{\"1306\":1}}],[\"该操作最多进行一次\",{\"1\":{\"66\":1}}],[\"该节点\",{\"1\":{\"1281\":1}}],[\"该节点的下一个节点指向真正的头结点\",{\"1\":{\"699\":1}}],[\"该构造器源码为\",{\"1\":{\"1270\":1}}],[\"该成员变量的获取是在静态代码块中\",{\"1\":{\"1266\":1}}],[\"该属性用来控制\",{\"1\":{\"1266\":1}}],[\"该类继承了\",{\"1\":{\"1371\":1}}],[\"该类提供了一些可以直接操控内存和线程的底层操作\",{\"1\":{\"1266\":1}}],[\"该类基本上所有的方法都采用\",{\"1\":{\"1264\":1}}],[\"该类的方法并不是很多\",{\"1\":{\"1258\":1}}],[\"该类是\",{\"1\":{\"1250\":1,\"1282\":1}}],[\"该方法源码如下\",{\"1\":{\"1508\":1}}],[\"该方法源码为\",{\"1\":{\"1239\":1,\"1251\":1,\"1252\":2,\"1317\":1}}],[\"该方法是用来阻塞当前线程的\",{\"1\":{\"1505\":1}}],[\"该方法是获取读锁被获取的次数\",{\"1\":{\"1239\":1}}],[\"该方法与\",{\"1\":{\"1404\":1}}],[\"该方法任意从\",{\"1\":{\"1404\":1}}],[\"该方法也要在同步方法或同步块中调用\",{\"1\":{\"1404\":1}}],[\"该方法返回的也是相加之前的数为\",{\"1\":{\"1386\":1}}],[\"该方法实际上是调用了\",{\"1\":{\"1385\":1}}],[\"该方法实际上总是用一个\",{\"1\":{\"1306\":1}}],[\"该方法主要功能\",{\"1\":{\"1370\":1}}],[\"该方法主要是通过\",{\"1\":{\"1284\":1}}],[\"该方法主要是将\",{\"1\":{\"1272\":1}}],[\"该方法可以将数据立即传送给消费者线程\",{\"1\":{\"1326\":1}}],[\"该方法就以\",{\"1\":{\"1316\":1}}],[\"该方法就是\",{\"1\":{\"1301\":1}}],[\"该方法逻辑请看注释\",{\"1\":{\"1316\":1}}],[\"该方法逻辑很简单\",{\"1\":{\"1308\":1}}],[\"该方法为\",{\"1\":{\"1306\":1,\"1317\":1}}],[\"该方法直接返回的就是当前线程对象\",{\"1\":{\"1301\":1}}],[\"该方法在上面已经讲过了\",{\"1\":{\"1272\":1}}],[\"该方法会调用\",{\"1\":{\"1508\":1}}],[\"该方法会在三种情况下才会返回\",{\"1\":{\"1508\":1}}],[\"该方法会唤醒该节点的后继节点所包装的线程\",{\"1\":{\"1506\":1}}],[\"该方法会唤醒在同步队列中的下一个节点\",{\"1\":{\"1500\":1}}],[\"该方法会原子更新引用的\",{\"1\":{\"1387\":1}}],[\"该方法会清除中断标志位\",{\"1\":{\"1336\":1}}],[\"该方法会有一个超时时间\",{\"1\":{\"1325\":1}}],[\"该方法会将当前索引为\",{\"1\":{\"1316\":1}}],[\"该方法会将调用构造器方法时指定的大小转换成一个\",{\"1\":{\"1270\":1}}],[\"该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列\",{\"1\":{\"1252\":1}}],[\"该方法用来将当前线程置入休眠状态\",{\"1\":{\"1404\":1}}],[\"该方法用来设置\",{\"1\":{\"1268\":1}}],[\"该方法用来获取\",{\"1\":{\"1268\":1}}],[\"该方法只不过是将等待队列中的每一个节点都移入到同步队列中\",{\"1\":{\"1252\":1}}],[\"该方法的关键是会调用\",{\"1\":{\"1505\":1}}],[\"该方法的逻辑很简单\",{\"1\":{\"1347\":1}}],[\"该方法的逻辑请看注释\",{\"1\":{\"1317\":1}}],[\"该方法的源码为\",{\"1\":{\"1251\":1,\"1301\":1,\"1315\":1,\"1317\":1,\"1505\":1,\"1510\":1}}],[\"该方法的作用是在自旋过程中线程不断尝试获取同步状态\",{\"1\":{\"1251\":1}}],[\"该方法执行前\",{\"1\":{\"465\":1}}],[\"该锁未完全释放返回\",{\"1\":{\"1232\":1}}],[\"该锁能被当前线程获取\",{\"1\":{\"1232\":1}}],[\"该锁才算是完全释放成功\",{\"1\":{\"1232\":1}}],[\"该干嘛就干嘛去了\",{\"1\":{\"1223\":1}}],[\"该模式被激活后\",{\"1\":{\"1191\":1}}],[\"该值取值应该考虑到内存使用率和\",{\"1\":{\"1306\":1}}],[\"该值默认是\",{\"1\":{\"1190\":1}}],[\"该值表示\",{\"1\":{\"252\":1}}],[\"该命令也会继续执行\",{\"1\":{\"1087\":1}}],[\"该注解只能用于函数\",{\"1\":{\"1052\":2}}],[\"该注解即可\",{\"1\":{\"468\":1}}],[\"该行不会被统计在其中\",{\"1\":{\"932\":1}}],[\"该指针可以指向链表中的任何节点或空节点\",{\"1\":{\"886\":1}}],[\"该路径\",{\"1\":{\"717\":1}}],[\"该子数组中至少包含一个数字\",{\"1\":{\"704\":1}}],[\"该用户名可能已经被使用了\",{\"1\":{\"613\":1}}],[\"该插件是\",{\"1\":{\"613\":1}}],[\"该功能要抽象成\",{\"1\":{\"525\":1}}],[\"该游戏被称为有向图游戏\",{\"1\":{\"396\":1}}],[\"该点到它本身的路径赋为0\",{\"1\":{\"355\":1}}],[\"该表格的初始值要赋为极大值\",{\"1\":{\"355\":1}}],[\"该式被称为三角不等式\",{\"1\":{\"354\":1}}],[\"该人从左上角移动至右下角\",{\"1\":{\"278\":1}}],[\"该如何想办法避免树的不平衡呢\",{\"1\":{\"274\":1}}],[\"该函数常用于离散化\",{\"1\":{\"423\":1}}],[\"该函数有唯一的返回类型\",{\"1\":{\"252\":1}}],[\"该函数返回字符串的首字符的地址\",{\"1\":{\"243\":1}}],[\"该函数返回在重新分配内存之前\",{\"1\":{\"243\":1}}],[\"该二叉树层序遍历的结果是\",{\"1\":{\"133\":1}}],[\"该网站会给出以下提示\",{\"1\":{\"88\":1}}],[\"已全部总结完成\",{\"1\":{\"1411\":1}}],[\"已完成\",{\"1\":{\"1375\":1}}],[\"已启动\",{\"1\":{\"1375\":1}}],[\"已注册的实例列表会显示在\",{\"1\":{\"1193\":1}}],[\"已注册的实例列表\",{\"0\":{\"1193\":1}}],[\"已过时\",{\"1\":{\"1052\":1}}],[\"已过滤数据权限的情况\",{\"1\":{\"471\":1}}],[\"已经超时返回false\",{\"1\":{\"1508\":1}}],[\"已经\",{\"1\":{\"1406\":1}}],[\"已经做出了哪些改进\",{\"0\":{\"1314\":1}}],[\"已经插入了值为\",{\"1\":{\"1284\":1}}],[\"已经将执行完\",{\"1\":{\"1284\":1}}],[\"已经指向了\",{\"1\":{\"1284\":1}}],[\"已经运行了多长时间\",{\"1\":{\"1190\":1}}],[\"已经过状态压缩\",{\"1\":{\"772\":1}}],[\"已经存在\",{\"1\":{\"686\":1}}],[\"已经换成了\",{\"1\":{\"672\":1}}],[\"已有的创建题库题目关联请求类\",{\"1\":{\"526\":1}}],[\"已生成的创建题库题目关联接口\",{\"1\":{\"526\":1}}],[\"已生成\",{\"1\":{\"521\":5}}],[\"已存入\",{\"1\":{\"489\":1}}],[\"已访问\",{\"1\":{\"314\":1}}],[\"已路径压缩\",{\"0\":{\"270\":1}}],[\"已知该人每次可以向上\",{\"1\":{\"278\":1}}],[\"已知每位工人会将自己所在位置的右侧一段长度的区间种满树\",{\"1\":{\"173\":1}}],[\"已知两个有序整形数组\",{\"1\":{\"92\":1}}],[\"已知当小红进行注册时\",{\"1\":{\"88\":1}}],[\"已简化\",{\"1\":{\"30\":1}}],[\"偶数数量\",{\"1\":{\"87\":1}}],[\"偶数的数量为\",{\"1\":{\"87\":1}}],[\"×a2xt​=a2x1​+2x2​+\",{\"1\":{\"381\":1}}],[\"×pm​pm​−1​\",{\"1\":{\"379\":1}}],[\"×\",{\"1\":{\"87\":1,\"180\":1,\"235\":1,\"329\":3,\"851\":1,\"1266\":1,\"1306\":1}}],[\"^=\",{\"1\":{\"121\":2,\"338\":3,\"394\":1}}],[\"^\",{\"1\":{\"87\":2,\"221\":1,\"337\":1,\"338\":7,\"394\":3,\"399\":3,\"422\":1,\"568\":1,\"575\":1,\"1272\":1}}],[\"种操作都是原子的\",{\"1\":{\"1482\":1}}],[\"种状态\",{\"1\":{\"1329\":1,\"1440\":1}}],[\"种构造器\",{\"1\":{\"1270\":1}}],[\"种构造器方法\",{\"1\":{\"1270\":1}}],[\"种情况的条件是当前等待的线程被中断后代码会走到\",{\"1\":{\"1251\":1}}],[\"种设计模式详解\",{\"1\":{\"623\":1}}],[\"种开发模式\",{\"1\":{\"537\":1}}],[\"种调用接口\",{\"1\":{\"525\":1}}],[\"种实现方式\",{\"1\":{\"525\":1}}],[\"种类多\",{\"1\":{\"434\":1}}],[\"种表示法\",{\"1\":{\"291\":1}}],[\"种颜色\",{\"1\":{\"157\":1}}],[\"种咖啡饮品的套餐\",{\"1\":{\"152\":1}}],[\"种咖啡饮品的价格\",{\"1\":{\"152\":1}}],[\"种不同的咖啡饮品\",{\"1\":{\"152\":1}}],[\"种不同的花卉品种\",{\"1\":{\"141\":1}}],[\"种\",{\"1\":{\"141\":1}}],[\"种选择\",{\"1\":{\"87\":2}}],[\"种从\",{\"1\":{\"72\":1}}],[\"答案就显得非常明显了\",{\"1\":{\"1129\":1}}],[\"答案就是使用双指针中的\",{\"1\":{\"777\":1}}],[\"答案就是\",{\"1\":{\"152\":1}}],[\"答案是可以添加内存屏障\",{\"1\":{\"1457\":1}}],[\"答案是不必的\",{\"1\":{\"1431\":1}}],[\"答案是\",{\"1\":{\"1100\":1}}],[\"答案为\",{\"1\":{\"796\":1,\"797\":1}}],[\"答案存在右子树中\",{\"1\":{\"713\":1}}],[\"答案含\",{\"1\":{\"632\":1}}],[\"答案在哪一侧\",{\"1\":{\"323\":1}}],[\"答案在右边界\",{\"1\":{\"322\":1}}],[\"答案在左边界\",{\"1\":{\"321\":1}}],[\"答案\",{\"1\":{\"249\":1,\"958\":1}}],[\"答案请对\",{\"1\":{\"87\":1}}],[\"答案可能会很大\",{\"1\":{\"72\":1}}],[\"开运动会时\",{\"1\":{\"1393\":1}}],[\"开源的\",{\"1\":{\"1094\":1}}],[\"开源协议\",{\"1\":{\"1093\":1}}],[\"开源项目\",{\"0\":{\"18\":1}}],[\"开立方\",{\"1\":{\"1080\":1}}],[\"开平方\",{\"1\":{\"1080\":1}}],[\"开区间\",{\"1\":{\"852\":2}}],[\"开区间写法\",{\"1\":{\"852\":2}}],[\"开头的三个问题我们通过阅读源码的方式已经完全找到了答案\",{\"1\":{\"1251\":1}}],[\"开头的\",{\"1\":{\"681\":1}}],[\"开头的特殊情况\",{\"1\":{\"127\":2}}],[\"开头\",{\"1\":{\"671\":1,\"698\":1}}],[\"开放给我们使用\",{\"1\":{\"1482\":1}}],[\"开放指定端口\",{\"1\":{\"663\":1}}],[\"开放端口很重要\",{\"1\":{\"662\":1}}],[\"开放寻址法示意图\",{\"1\":{\"1306\":1}}],[\"开放寻址法不会创建链表\",{\"1\":{\"1306\":1}}],[\"开放寻址法\",{\"0\":{\"420\":1},\"1\":{\"971\":1,\"1306\":2}}],[\"开发才会继续跟进\",{\"1\":{\"1337\":1}}],[\"开发人员倍感幸福\",{\"1\":{\"1264\":1}}],[\"开发的短链系统\",{\"1\":{\"634\":1}}],[\"开发工具中生成\",{\"1\":{\"560\":1}}],[\"开发框架ant\",{\"1\":{\"557\":1}}],[\"开发框架\",{\"1\":{\"557\":2}}],[\"开发时要严格注意\",{\"1\":{\"546\":1}}],[\"开发规范\",{\"0\":{\"541\":1}}],[\"开发\",{\"0\":{\"536\":1},\"1\":{\"574\":1}}],[\"开发和维护的复杂度相对较高\",{\"1\":{\"533\":1}}],[\"开发复杂度较高\",{\"1\":{\"533\":1}}],[\"开发前端服务端渲染网站模板\",{\"1\":{\"529\":1}}],[\"开发面试吧后端基础功能\",{\"1\":{\"505\":1}}],[\"开启\",{\"1\":{\"1429\":1,\"1449\":1,\"1482\":1}}],[\"开启了两个线程分别为\",{\"1\":{\"1336\":1}}],[\"开启了两个线程\",{\"1\":{\"1221\":1,\"1254\":1}}],[\"开启一个线程\",{\"1\":{\"1060\":1}}],[\"开启事务\",{\"1\":{\"954\":2}}],[\"开启手动控制事务\",{\"1\":{\"954\":1}}],[\"开启右子树递归\",{\"1\":{\"767\":1}}],[\"开启左子树递归\",{\"1\":{\"767\":1}}],[\"开启直链后的效果如下\",{\"1\":{\"670\":1}}],[\"开启后每个文件都会生成一个链接\",{\"1\":{\"670\":1}}],[\"开启防火墙并开放指定端口\",{\"1\":{\"663\":1}}],[\"开启配置\",{\"0\":{\"487\":1}}],[\"开启方法级别的权限控制\",{\"1\":{\"446\":1}}],[\"开一个单链表\",{\"1\":{\"345\":1}}],[\"开递递归枚举\",{\"1\":{\"291\":1}}],[\"开栈空间代码\",{\"0\":{\"246\":1}}],[\"开始添加元素\",{\"1\":{\"1407\":3}}],[\"开始notify\",{\"1\":{\"1406\":2}}],[\"开始wait\",{\"1\":{\"1406\":2}}],[\"开始向后搜索脏\",{\"1\":{\"1316\":1}}],[\"开始完成插入操作\",{\"1\":{\"1285\":1}}],[\"开始指定大小capacity\",{\"1\":{\"1078\":1}}],[\"开始时间\",{\"1\":{\"938\":1}}],[\"开始自增\",{\"1\":{\"919\":1}}],[\"开始遍历\",{\"1\":{\"893\":1}}],[\"开始扩散\",{\"1\":{\"870\":2}}],[\"开始进行广度优先搜索\",{\"1\":{\"821\":1}}],[\"开始左右子树递归\",{\"1\":{\"766\":1}}],[\"开始计数\",{\"1\":{\"709\":1}}],[\"开始计算\",{\"1\":{\"87\":1}}],[\"开始下载所需的\",{\"1\":{\"532\":1}}],[\"开始枚举前缀和数组\",{\"1\":{\"262\":1}}],[\"开始搜索\",{\"1\":{\"235\":1,\"236\":1,\"237\":1}}],[\"开始\",{\"1\":{\"120\":1,\"122\":1,\"229\":1,\"273\":2,\"307\":1,\"417\":1,\"840\":1,\"935\":1,\"1306\":1}}],[\"小数\",{\"1\":{\"980\":1}}],[\"小数值\",{\"1\":{\"920\":1}}],[\"小整数值\",{\"1\":{\"920\":1}}],[\"小码公众号助手\",{\"1\":{\"634\":1}}],[\"小码短链接\",{\"1\":{\"634\":1}}],[\"小码短连接\",{\"1\":{\"634\":1}}],[\"小码至营官网\",{\"1\":{\"634\":1}}],[\"小时\",{\"1\":{\"577\":1}}],[\"小技巧\",{\"1\":{\"421\":1,\"699\":1}}],[\"小于0直接抛异常\",{\"1\":{\"1270\":1}}],[\"小于\",{\"1\":{\"898\":1,\"931\":1,\"984\":1}}],[\"小于号\",{\"1\":{\"423\":2}}],[\"小于eps视为0\",{\"1\":{\"385\":1}}],[\"小于等于\",{\"1\":{\"140\":1,\"931\":1,\"984\":1}}],[\"小方格的种类数\",{\"1\":{\"311\":1}}],[\"小沐沐要你来告诉奶牛什么是最长公共上升子序列\",{\"1\":{\"304\":1}}],[\"小沐沐说\",{\"1\":{\"304\":1}}],[\"小沐沐先让奶牛研究了最长上升子序列\",{\"1\":{\"304\":1}}],[\"小猫们终于爬上了山顶\",{\"1\":{\"290\":1}}],[\"小猫们要去爬山\",{\"1\":{\"290\":1}}],[\"小树接在大树下面\",{\"1\":{\"274\":1}}],[\"小结\",{\"0\":{\"231\":1,\"238\":1,\"1141\":1,\"1155\":1}}],[\"小的元素一定在右子树中\",{\"1\":{\"712\":1}}],[\"小的元素一定在左子树中\",{\"1\":{\"712\":1}}],[\"小的元素的范围\",{\"1\":{\"712\":1}}],[\"小的元素\",{\"1\":{\"709\":1,\"712\":3}}],[\"小的合并到大的中\",{\"1\":{\"431\":1}}],[\"小的数\",{\"1\":{\"407\":1}}],[\"小的d\",{\"1\":{\"221\":1}}],[\"小的值\",{\"1\":{\"221\":1,\"711\":1}}],[\"小根堆\",{\"1\":{\"221\":1,\"223\":1}}],[\"小团在\",{\"1\":{\"174\":1}}],[\"小乐乐喜欢数字\",{\"1\":{\"161\":1}}],[\"小乐的数字\",{\"0\":{\"161\":1}}],[\"小美将区间扩展为\",{\"1\":{\"174\":1}}],[\"小美和小团选择的数字较大的一方获胜\",{\"1\":{\"174\":1}}],[\"小美和小团在玩一个游戏\",{\"1\":{\"174\":1}}],[\"小美和小团的游戏\",{\"0\":{\"174\":1}}],[\"小美雇佣了\",{\"1\":{\"173\":1}}],[\"小美种树\",{\"0\":{\"173\":1}}],[\"小美写单词喜欢横着写\",{\"1\":{\"172\":1}}],[\"小美的姓名统计\",{\"0\":{\"172\":1}}],[\"小美想知道自她每一轮的输赢状态\",{\"1\":{\"174\":1}}],[\"小美想知道\",{\"1\":{\"167\":1}}],[\"小美有三个数字\",{\"1\":{\"167\":1}}],[\"小美有一个漂亮的收藏架\",{\"1\":{\"147\":1}}],[\"小美需要移动到第一个瓶子的位置上\",{\"1\":{\"166\":1}}],[\"小美每次可以向上\",{\"1\":{\"166\":1}}],[\"小美初始位于\",{\"1\":{\"166\":1}}],[\"小美觉得有些格子不放藏品也可以接受\",{\"1\":{\"147\":1}}],[\"小美认为有对比才有美感\",{\"1\":{\"147\":1}}],[\"小美打算把她的\",{\"1\":{\"147\":1}}],[\"小美正在摆放她的收藏品\",{\"1\":{\"147\":1}}],[\"小c在每两个相邻的游戏节点之间所花费的时间均达到了历史最佳记录\",{\"1\":{\"146\":1}}],[\"小c准备参加某个游戏的速通比赛\",{\"1\":{\"146\":1}}],[\"小黑盒笔试\",{\"0\":{\"107\":1}}],[\"小牛的任务是找到经过任意次数\",{\"1\":{\"104\":1}}],[\"小明回家后看到纸条如愿吃到妈妈做的饭菜\",{\"1\":{\"1416\":1}}],[\"小明妈妈要去上班了十分紧急这个时候手机又没有电了\",{\"1\":{\"1416\":1}}],[\"小明妈妈在家里做饭\",{\"1\":{\"1416\":1}}],[\"小明在外面玩耍\",{\"1\":{\"1416\":1}}],[\"小明在研究一个有趣的数组翻转操作问题\",{\"1\":{\"104\":1}}],[\"小明在正式进行调整前\",{\"1\":{\"103\":1}}],[\"小明觉得他应该把项链左右翻转一下了\",{\"1\":{\"103\":1}}],[\"小明正在玩弄他的一串宝石项链\",{\"1\":{\"103\":1}}],[\"小米笔试\",{\"0\":{\"102\":1}}],[\"小紫以\",{\"1\":{\"97\":1}}],[\"小紫坐标为\",{\"1\":{\"97\":1}}],[\"小红不可能击杀掉所有怪物\",{\"1\":{\"180\":1}}],[\"小红不能经过\",{\"1\":{\"180\":1}}],[\"小红只可以上下左右四个方向移动\",{\"1\":{\"180\":1}}],[\"小红可以经过\",{\"1\":{\"180\":1}}],[\"小红消耗的血量等同于该怪物的战斗力\",{\"1\":{\"180\":1}}],[\"小红就会和怪物战斗\",{\"1\":{\"180\":1}}],[\"小红初始的血量是\",{\"1\":{\"180\":1}}],[\"小红正在玩一个游戏\",{\"1\":{\"180\":1}}],[\"小红向坐标\",{\"1\":{\"97\":1}}],[\"小红坐标为\",{\"1\":{\"97\":1}}],[\"小红和小紫在玩一个游戏\",{\"1\":{\"97\":1}}],[\"小红准备在一个网站注册一批账号和密码\",{\"1\":{\"88\":1}}],[\"小红的密码\",{\"0\":{\"88\":1}}],[\"小红的方案数\",{\"0\":{\"87\":1}}],[\"小红想知道\",{\"1\":{\"88\":1,\"180\":1}}],[\"小红想知道一共有多少种不同的方案\",{\"1\":{\"87\":1}}],[\"小红想构造一个大小为\",{\"1\":{\"87\":1}}],[\"小a在未来\",{\"1\":{\"65\":1}}],[\"🤗\",{\"1\":{\"86\":1}}],[\"考虑构建\",{\"1\":{\"888\":1}}],[\"考虑第\",{\"1\":{\"795\":1,\"893\":1}}],[\"考虑新的右子树的根节点\",{\"1\":{\"724\":1}}],[\"考虑这样一种场景\",{\"1\":{\"213\":1}}],[\"考虑到需要适配多种不同的情况\",{\"1\":{\"523\":1}}],[\"考虑到数据规模\",{\"1\":{\"168\":1}}],[\"考虑到查询排名需要\",{\"1\":{\"129\":1}}],[\"考虑从\",{\"1\":{\"110\":1}}],[\"考虑每种情况\",{\"1\":{\"65\":1}}],[\"考了很多多线程和操作系统方面的知识\",{\"1\":{\"86\":1}}],[\"至此\",{\"1\":{\"1184\":1,\"1272\":1,\"1316\":1}}],[\"至关重要\",{\"1\":{\"987\":1}}],[\"至多出现一次\",{\"1\":{\"717\":1}}],[\"至于为什么不用\",{\"1\":{\"1264\":1}}],[\"至于这个\",{\"1\":{\"1132\":1}}],[\"至于\",{\"1\":{\"687\":1}}],[\"至少能看到写线程\",{\"1\":{\"1476\":1}}],[\"至少有一个不在\",{\"1\":{\"840\":1}}],[\"至少包含一个\",{\"1\":{\"717\":1}}],[\"至少选中一个集合\",{\"1\":{\"392\":1}}],[\"至少需要进行多少次操作\",{\"1\":{\"306\":1}}],[\"至少需要移动多少次\",{\"1\":{\"278\":1}}],[\"至\",{\"1\":{\"83\":2,\"920\":5}}],[\"−n\",{\"1\":{\"1266\":1}}],[\"−231\",{\"1\":{\"899\":1}}],[\"−263\",{\"1\":{\"83\":2}}],[\"−\",{\"1\":{\"383\":1,\"712\":5,\"795\":2,\"797\":1,\"846\":19,\"881\":1}}],[\"−109≤xi​\",{\"1\":{\"166\":1}}],[\"−109≤a\",{\"1\":{\"166\":1}}],[\"−109\",{\"1\":{\"134\":1}}],[\"−10000⩽ai​⩽10000\",{\"1\":{\"262\":1}}],[\"−1000000000<a\",{\"1\":{\"104\":1}}],[\"−100100≤n≤<=10100\",{\"1\":{\"76\":1}}],[\"−15\",{\"1\":{\"83\":1}}],[\"−1\",{\"1\":{\"66\":1,\"128\":1,\"168\":2,\"180\":1,\"223\":1,\"237\":1,\"279\":1,\"846\":1,\"869\":2,\"1266\":1,\"1271\":2,\"1272\":1}}],[\"求斐波那切数列第n项\",{\"1\":{\"1023\":1}}],[\"求斐波那契数列的第\",{\"1\":{\"988\":1,\"990\":1}}],[\"求和\",{\"1\":{\"932\":1}}],[\"求和方式\",{\"0\":{\"126\":1}}],[\"求组成总金额所需的最少硬币数\",{\"1\":{\"893\":1}}],[\"求组合数\",{\"0\":{\"386\":1}}],[\"求该二叉树里节点值之和等于\",{\"1\":{\"880\":1}}],[\"求该表达式的计算结果\",{\"1\":{\"83\":1}}],[\"求分成的最小组数\",{\"1\":{\"429\":1}}],[\"求集合当中的最小值\",{\"1\":{\"417\":1}}],[\"求滑动窗口里的最大值和最小值\",{\"1\":{\"410\":1}}],[\"求每个质因数的次数\",{\"1\":{\"390\":1}}],[\"求每个质数的次数\",{\"1\":{\"390\":1}}],[\"求next\",{\"1\":{\"411\":1}}],[\"求n\",{\"1\":{\"390\":1}}],[\"求x\",{\"1\":{\"383\":1}}],[\"求x的欧拉函数\",{\"1\":{\"379\":1}}],[\"求整数\",{\"1\":{\"383\":1}}],[\"求欧拉函数\",{\"0\":{\"379\":1}}],[\"求1到n的最短路距离\",{\"1\":{\"354\":1}}],[\"求1号点到n号点的最短距离\",{\"1\":{\"353\":1}}],[\"求1号点到n号点的最短路距离\",{\"1\":{\"355\":1}}],[\"求1号点到n号点的最短路\",{\"1\":{\"352\":1}}],[\"求从一个点到其他所有点的最短距离\",{\"1\":{\"351\":1}}],[\"求从起点\",{\"1\":{\"223\":1}}],[\"求最大匹配数\",{\"1\":{\"363\":1}}],[\"求最大权值和\",{\"1\":{\"314\":1}}],[\"求最小生成树的\",{\"1\":{\"267\":1}}],[\"求起点\",{\"1\":{\"312\":1}}],[\"求方案数\",{\"1\":{\"308\":1}}],[\"求既是\",{\"1\":{\"303\":1}}],[\"求所选物品的总体积不超过背包容量的条件下\",{\"1\":{\"296\":1}}],[\"求一个最小的非负整数\",{\"1\":{\"384\":1}}],[\"求一个序列中严格递增的子序列的最大长度\",{\"1\":{\"302\":1}}],[\"求一个数列\",{\"1\":{\"128\":1}}],[\"求一颗炸弹最多能炸掉地图上总价值为多少的目标\",{\"1\":{\"263\":1}}],[\"求区间和\",{\"1\":{\"261\":1}}],[\"求区间\",{\"1\":{\"261\":1}}],[\"求出\",{\"1\":{\"182\":1}}],[\"求出李华每完成一次染色后画布上的颜色种类数\",{\"1\":{\"157\":1}}],[\"求操作后这四个正整数的乘积\",{\"1\":{\"156\":1}}],[\"求\",{\"0\":{\"247\":1},\"1\":{\"139\":1,\"224\":1,\"309\":1,\"381\":1,\"387\":1,\"390\":1,\"411\":2,\"988\":1,\"990\":1,\"993\":1}}],[\"求有多少种组合的和为\",{\"1\":{\"126\":1}}],[\"求解将哪些物品装入背包里物品价值总和最大\",{\"1\":{\"772\":1}}],[\"求解将哪些物品装入背包\",{\"1\":{\"299\":1}}],[\"求解\",{\"1\":{\"72\":1}}],[\"华宇信息笔试\",{\"0\":{\"81\":1}}],[\"三条性质\",{\"1\":{\"1455\":1}}],[\"三大性质总结\",{\"0\":{\"1481\":1}}],[\"三大性质\",{\"1\":{\"1455\":1}}],[\"三件套\",{\"1\":{\"557\":1}}],[\"三重循环\",{\"1\":{\"358\":1}}],[\"三个实现类\",{\"1\":{\"1073\":1}}],[\"三个元素\",{\"1\":{\"1000\":1}}],[\"三个节点\",{\"1\":{\"766\":1}}],[\"三个数的位数可能都不一样\",{\"1\":{\"291\":1}}],[\"三个数\",{\"1\":{\"291\":1}}],[\"三个子数组内各元素之和都相等\",{\"1\":{\"262\":1}}],[\"三\",{\"0\":{\"987\":1,\"1172\":1,\"1183\":1},\"1\":{\"200\":1,\"302\":1}}],[\"三种常见的岛屿问题\",{\"1\":{\"231\":1}}],[\"三种岛屿问题的\",{\"1\":{\"227\":1}}],[\"三种\",{\"1\":{\"83\":2}}],[\"三角形的成立条件\",{\"1\":{\"78\":1}}],[\"三角形\",{\"0\":{\"78\":1}}],[\"三张表\",{\"1\":{\"56\":1}}],[\"行处打上断点\",{\"1\":{\"1295\":1}}],[\"行执行成功进入到第\",{\"1\":{\"1284\":1}}],[\"行依然通过\",{\"1\":{\"1283\":1}}],[\"行中直接返回\",{\"1\":{\"1284\":1}}],[\"行中\",{\"1\":{\"1283\":1,\"1284\":1}}],[\"行使用\",{\"1\":{\"1283\":1}}],[\"行变量\",{\"1\":{\"1283\":1}}],[\"行为\",{\"1\":{\"1283\":1}}],[\"行为一个整数\",{\"1\":{\"129\":1}}],[\"行代码先覆盖当前位置的\",{\"1\":{\"1317\":2}}],[\"行代码的理解\",{\"1\":{\"1285\":1}}],[\"行代码\",{\"1\":{\"1284\":5,\"1285\":1,\"1317\":2}}],[\"行代码中更新\",{\"1\":{\"1317\":2}}],[\"行代码中\",{\"1\":{\"1284\":1,\"1317\":4}}],[\"行代码定位到队尾节点\",{\"1\":{\"1283\":1}}],[\"行代码就是找出队列真正的尾节点\",{\"1\":{\"1283\":1}}],[\"行代码将数组引用指向新的数组\",{\"1\":{\"1295\":1}}],[\"行代码将\",{\"1\":{\"1283\":1}}],[\"行代码会对是否为\",{\"1\":{\"1283\":1}}],[\"行子查询\",{\"0\":{\"950\":1},\"1\":{\"947\":1}}],[\"行row\",{\"1\":{\"385\":1}}],[\"行包含两个整数\",{\"1\":{\"384\":1}}],[\"行包含整数\",{\"1\":{\"384\":1}}],[\"行的断点放开后\",{\"1\":{\"1295\":1}}],[\"行的操作同上述\",{\"1\":{\"1284\":1}}],[\"行的\",{\"1\":{\"1284\":2}}],[\"行的代码我们没有分析\",{\"1\":{\"1283\":1}}],[\"行的时候\",{\"1\":{\"1283\":1}}],[\"行的整数表示第\",{\"1\":{\"290\":1}}],[\"行的第\",{\"1\":{\"146\":1}}],[\"行询问\",{\"1\":{\"273\":1}}],[\"行有\",{\"1\":{\"273\":1}}],[\"行每行包含一个整数\",{\"1\":{\"261\":1}}],[\"行每行一个仅包含小写字母的字符串\",{\"1\":{\"202\":1}}],[\"行每行一个仅包含小写字母的字符串表示\",{\"1\":{\"202\":1}}],[\"行每行两个整数\",{\"1\":{\"196\":1,\"199\":1,\"205\":1}}],[\"行每行\",{\"1\":{\"196\":2}}],[\"行第\",{\"1\":{\"196\":1}}],[\"行输出至多\",{\"1\":{\"168\":1}}],[\"行输入四个整数\",{\"1\":{\"168\":1}}],[\"行数据\",{\"1\":{\"146\":1}}],[\"行是元组的具体数值\",{\"1\":{\"140\":1}}],[\"行\",{\"1\":{\"77\":1,\"129\":1,\"146\":1,\"156\":2,\"162\":1,\"166\":1,\"168\":2,\"174\":1,\"180\":1,\"196\":1,\"223\":1,\"263\":1,\"274\":1,\"278\":1,\"280\":3,\"290\":2,\"305\":3,\"384\":1,\"1283\":9,\"1284\":4}}],[\"代理服务修改为\",{\"1\":{\"664\":1}}],[\"代理客户端\",{\"1\":{\"662\":1,\"664\":1}}],[\"代理的位置\",{\"0\":{\"586\":1},\"1\":{\"586\":1}}],[\"代码抛出被中断异常\",{\"1\":{\"1507\":1}}],[\"代码首先获取当前节点的先驱节点\",{\"1\":{\"1504\":1}}],[\"代码中就是\",{\"1\":{\"1482\":1}}],[\"代码中\",{\"1\":{\"1430\":1}}],[\"代码中主要是通过\",{\"1\":{\"1283\":1}}],[\"代码块后\",{\"1\":{\"1406\":1}}],[\"代码块时\",{\"1\":{\"1334\":1}}],[\"代码会走到第\",{\"1\":{\"1283\":1}}],[\"代码走到第\",{\"1\":{\"1283\":1}}],[\"代码逻辑请看注释\",{\"1\":{\"1274\":1,\"1302\":1}}],[\"代码为\",{\"1\":{\"1272\":1}}],[\"代码的逻辑见注释\",{\"1\":{\"1271\":1}}],[\"代码的逻辑请看注释\",{\"1\":{\"1232\":1,\"1242\":1,\"1273\":1}}],[\"代码的主要逻辑请看注释\",{\"1\":{\"1251\":1}}],[\"代码执行顺序\",{\"1\":{\"987\":1}}],[\"代码执行完成后才能实现\",{\"1\":{\"531\":1,\"533\":1}}],[\"代码评审\",{\"1\":{\"555\":1}}],[\"代码提交\",{\"1\":{\"555\":1}}],[\"代码美化\",{\"1\":{\"539\":1}}],[\"代码规范\",{\"1\":{\"539\":1}}],[\"代码来请求数据\",{\"1\":{\"531\":1}}],[\"代码生成插件快速得到\",{\"1\":{\"515\":1}}],[\"代码流程图\",{\"1\":{\"481\":1,\"482\":1}}],[\"代码段\",{\"1\":{\"328\":1}}],[\"代码如下\",{\"1\":{\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"327\":1,\"329\":1,\"330\":1,\"339\":2,\"517\":1,\"523\":1,\"1485\":1}}],[\"代码\",{\"0\":{\"682\":1,\"694\":1,\"700\":1,\"713\":1,\"719\":1,\"743\":1,\"755\":1,\"761\":1,\"767\":1,\"778\":1,\"803\":1,\"809\":1,\"815\":1,\"834\":1,\"840\":1,\"864\":1,\"870\":1,\"876\":1,\"882\":1},\"1\":{\"187\":1,\"223\":1,\"224\":1,\"261\":1,\"262\":1,\"263\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"304\":1,\"306\":1,\"307\":1,\"531\":1,\"687\":1,\"688\":1,\"705\":1,\"710\":1,\"724\":1,\"725\":1,\"730\":1,\"731\":1,\"736\":1,\"737\":1,\"748\":1,\"749\":1,\"772\":1,\"789\":1,\"795\":1,\"796\":1,\"820\":1,\"822\":1,\"827\":1,\"828\":1,\"845\":1,\"846\":1,\"851\":1,\"857\":1,\"887\":1,\"893\":1,\"899\":1,\"900\":1,\"901\":1,\"1157\":1,\"1317\":1,\"1454\":1}}],[\"代码不完全正确\",{\"1\":{\"109\":1}}],[\"代表男生和女生\",{\"1\":{\"1399\":1}}],[\"代表集群信息\",{\"1\":{\"1192\":1}}],[\"代表文件传入的参数个数\",{\"1\":{\"1120\":1}}],[\"代表腐烂的橘子\",{\"1\":{\"868\":1}}],[\"代表新鲜橘子\",{\"1\":{\"868\":1}}],[\"代表空单元格\",{\"1\":{\"868\":1}}],[\"代表一个job实例\",{\"1\":{\"479\":1}}],[\"代表一张海域照片\",{\"1\":{\"280\":1}}],[\"代表一颗炸弹最多能炸掉地图上目标的总价值数目\",{\"1\":{\"263\":1}}],[\"代表陆地\",{\"1\":{\"228\":1,\"229\":2}}],[\"代表海水\",{\"1\":{\"228\":1,\"229\":2}}],[\"代表顾客名称\",{\"1\":{\"181\":1}}],[\"代表产品名称\",{\"1\":{\"181\":1}}],[\"代表该位置是个道路\",{\"1\":{\"180\":1}}],[\"代表墙体\",{\"1\":{\"180\":1}}],[\"代表道路\",{\"1\":{\"180\":1}}],[\"代表工人们最短的种树区间长度\",{\"1\":{\"173\":1}}],[\"代表人名的个数\",{\"1\":{\"172\":1}}],[\"代表小红走的路径长度最小值\",{\"1\":{\"180\":1}}],[\"代表小红的操作\",{\"1\":{\"88\":1}}],[\"代表小红的注册次数\",{\"1\":{\"88\":1}}],[\"代表小美的全部单词\",{\"1\":{\"172\":1}}],[\"代表他想要买\",{\"1\":{\"168\":2}}],[\"代表第\",{\"1\":{\"168\":2}}],[\"代表\",{\"1\":{\"168\":2,\"261\":1,\"1272\":1}}],[\"代表商品的种类\",{\"1\":{\"168\":1}}],[\"代表商品的保质期\",{\"1\":{\"168\":1}}],[\"代表来牛牛商店购物的人数和商品数量\",{\"1\":{\"168\":1}}],[\"代表子网格的边长\",{\"1\":{\"141\":1}}],[\"代表行列数\",{\"1\":{\"141\":1}}],[\"代表字符串的长度\",{\"1\":{\"120\":1}}],[\"代表构造的排列\",{\"1\":{\"119\":1}}],[\"代表构造的方案数对\",{\"1\":{\"87\":1}}],[\"代表测试数据组数\",{\"1\":{\"97\":1}}],[\"代表网格板的大小以及操作的次数\",{\"1\":{\"77\":1}}],[\"代替\",{\"1\":{\"37\":1,\"338\":1,\"1051\":1,\"1275\":1}}],[\"注入形式\",{\"0\":{\"1133\":1}}],[\"注入到\",{\"1\":{\"1132\":1}}],[\"注射到\",{\"1\":{\"1132\":1}}],[\"注定注解是否出出现在\",{\"1\":{\"1053\":1}}],[\"注释内容\",{\"1\":{\"908\":2}}],[\"注释内容或\",{\"1\":{\"908\":1}}],[\"注释\",{\"0\":{\"1108\":1},\"1\":{\"663\":1,\"908\":1,\"922\":2}}],[\"注释或删除掉原有的权限注解\",{\"1\":{\"468\":1}}],[\"注销\",{\"1\":{\"592\":1}}],[\"注册一个定时线程任务\",{\"1\":{\"1201\":1}}],[\"注册请求\",{\"1\":{\"1184\":1}}],[\"注册时就是发送的\",{\"1\":{\"1184\":1}}],[\"注册时加密后的\",{\"1\":{\"574\":1}}],[\"注册是通过\",{\"1\":{\"1184\":1}}],[\"注册流程\",{\"0\":{\"1184\":1}}],[\"注册的服务\",{\"1\":{\"1191\":1}}],[\"注册的过程\",{\"1\":{\"1185\":1}}],[\"注册的方法里面发送了\",{\"1\":{\"1184\":1}}],[\"注册的代码隐藏的比较深\",{\"1\":{\"1184\":1}}],[\"注册的\",{\"1\":{\"1182\":1,\"1184\":1}}],[\"注册到\",{\"1\":{\"1175\":1,\"1182\":1}}],[\"注册过程\",{\"0\":{\"1175\":1},\"1\":{\"1175\":1}}],[\"注册信息获取下\",{\"1\":{\"1165\":1}}],[\"注册对象\",{\"0\":{\"1160\":1}}],[\"注册为\",{\"1\":{\"1100\":1}}],[\"注册为一个进程\",{\"1\":{\"671\":1}}],[\"注册链接\",{\"1\":{\"588\":1}}],[\"注册失败\",{\"1\":{\"587\":1}}],[\"注册成功\",{\"1\":{\"587\":1}}],[\"注册页面\",{\"0\":{\"587\":1},\"1\":{\"588\":1}}],[\"注册逻辑设计\",{\"0\":{\"568\":1}}],[\"注册校验\",{\"1\":{\"556\":1}}],[\"注册\",{\"0\":{\"1183\":1},\"1\":{\"556\":1,\"587\":3,\"588\":1,\"1160\":1}}],[\"注册register\",{\"1\":{\"446\":1}}],[\"注解时\",{\"1\":{\"1175\":1}}],[\"注解的使用目的比较简单\",{\"1\":{\"1051\":1}}],[\"注解的方法\",{\"1\":{\"471\":1}}],[\"注解不影响程序逻辑\",{\"1\":{\"1051\":1}}],[\"注解与反射\",{\"0\":{\"1050\":1}}],[\"注解解决\",{\"1\":{\"526\":1}}],[\"注解\",{\"0\":{\"1051\":1},\"1\":{\"471\":1,\"575\":1,\"1051\":1}}],[\"注解用于配置接口要求用户拥有某些权限才可访问\",{\"1\":{\"466\":1}}],[\"注解被应用于某个方法时\",{\"1\":{\"465\":1}}],[\"注\",{\"1\":{\"77\":1,\"114\":1,\"115\":1}}],[\"注意此时\",{\"1\":{\"1315\":1}}],[\"注意上图中的实线表示强引用\",{\"1\":{\"1305\":1}}],[\"注意这里的是\",{\"1\":{\"1476\":1}}],[\"注意这里修饰的仅是数组引用\",{\"1\":{\"1292\":1}}],[\"注意这里是\",{\"1\":{\"795\":1,\"893\":1}}],[\"注意不同点\",{\"1\":{\"1458\":1}}],[\"注意不是stdout\",{\"1\":{\"1120\":1}}],[\"注意不能直接用==\",{\"1\":{\"1005\":1}}],[\"注意不加小括号\",{\"1\":{\"1002\":1}}],[\"注意需要抛异常\",{\"1\":{\"981\":1,\"982\":1}}],[\"注意余数可能为负数\",{\"1\":{\"979\":1}}],[\"注意事项\",{\"1\":{\"926\":1,\"927\":1,\"933\":1,\"934\":1,\"935\":1,\"944\":1,\"945\":1,\"959\":1}}],[\"注意是开区间\",{\"1\":{\"899\":1}}],[\"注意是左闭右开\",{\"1\":{\"682\":1}}],[\"注意区间范围\",{\"1\":{\"899\":1}}],[\"注意本题是一定有解的\",{\"1\":{\"795\":1}}],[\"注意保证客户端渲染页面和服务端渲染页面的一致性\",{\"1\":{\"546\":1}}],[\"注意查看和处理构建中的报错信息\",{\"1\":{\"546\":1}}],[\"注意判断通过关联表查询到的题目列表\",{\"1\":{\"525\":1}}],[\"注意multimap不支持此操作\",{\"1\":{\"422\":1}}],[\"注意乘除的先后顺序\",{\"1\":{\"377\":1}}],[\"注意特征\",{\"1\":{\"291\":1}}],[\"注意空格\",{\"1\":{\"172\":1}}],[\"注意每次运算都需要取模\",{\"1\":{\"87\":1}}],[\"注意\",{\"1\":{\"47\":1,\"72\":1,\"122\":1,\"147\":1,\"213\":1,\"223\":2,\"263\":1,\"338\":1,\"410\":1,\"465\":1,\"525\":2,\"526\":2,\"537\":2,\"539\":1,\"542\":1,\"543\":1,\"559\":1,\"573\":1,\"662\":1,\"664\":1,\"671\":1,\"766\":1,\"772\":1,\"782\":1,\"797\":1,\"913\":1,\"918\":1,\"919\":1,\"932\":1,\"986\":1,\"1004\":1,\"1090\":1,\"1182\":1,\"1295\":1,\"1330\":1,\"1336\":1,\"1420\":1,\"1467\":1,\"1475\":1,\"1482\":1}}],[\"除非调用\",{\"1\":{\"1375\":1}}],[\"除非关闭否则无法使用其他\",{\"1\":{\"671\":1}}],[\"除零错误\",{\"1\":{\"1047\":1}}],[\"除\",{\"1\":{\"1018\":1}}],[\"除上面外的所有请求全部需要鉴权认证\",{\"1\":{\"446\":1}}],[\"除最后一层节点\",{\"1\":{\"417\":1}}],[\"除以零\",{\"1\":{\"1045\":1}}],[\"除以\",{\"0\":{\"247\":1},\"1\":{\"389\":1}}],[\"除此之外\",{\"1\":{\"172\":1}}],[\"除首个单词以外\",{\"1\":{\"98\":1}}],[\"除去低两位即可\",{\"1\":{\"76\":1}}],[\"除了一个无参的构造方法外\",{\"1\":{\"1399\":1}}],[\"除了实现\",{\"1\":{\"1376\":1}}],[\"除了使用\",{\"1\":{\"1324\":1}}],[\"除了在初始进行系统配置的时候需要写入数据\",{\"1\":{\"1290\":1}}],[\"除了通过传统的命令行进行操作之外\",{\"1\":{\"1095\":1}}],[\"除了自己\",{\"1\":{\"356\":1}}],[\"除了大家点开评论区看到的\",{\"1\":{\"40\":1}}],[\"除了数据安全法所要求的以外\",{\"1\":{\"36\":1}}],[\"除了写热点\",{\"1\":{\"33\":1}}],[\"除了批判性评论之外\",{\"1\":{\"21\":1}}],[\"转byte\",{\"1\":{\"1069\":1}}],[\"转化一下\",{\"1\":{\"760\":1}}],[\"转化为递推\",{\"1\":{\"828\":1}}],[\"转化为求中序遍历的第k个节点\",{\"1\":{\"710\":1}}],[\"转化为\",{\"1\":{\"291\":1}}],[\"转化为数字\",{\"1\":{\"291\":1}}],[\"转化为背包问题\",{\"1\":{\"115\":1}}],[\"转化为字符串解决\",{\"1\":{\"76\":1}}],[\"转转数仓评估体系实践\",{\"1\":{\"639\":1}}],[\"转转技术\",{\"1\":{\"625\":1}}],[\"转转度量平台技术建设实践\",{\"1\":{\"622\":1}}],[\"转为\",{\"1\":{\"517\":1}}],[\"转换成\",{\"1\":{\"1330\":1,\"1368\":1}}],[\"转换成线程安全的\",{\"1\":{\"1280\":1}}],[\"转换的这些方式是不合理的\",{\"1\":{\"1290\":1}}],[\"转换为string\",{\"1\":{\"1069\":1}}],[\"转换\",{\"1\":{\"251\":3}}],[\"转\",{\"0\":{\"1214\":1},\"1\":{\"251\":2}}],[\"转移方程根据\",{\"1\":{\"104\":1}}],[\"转到下载的文件夹目录\",{\"1\":{\"670\":1}}],[\"转到\",{\"1\":{\"98\":1}}],[\"转载自悟空聊架构\",{\"1\":{\"1144\":1,\"1175\":1,\"1189\":1}}],[\"转载自stormspirit\",{\"1\":{\"44\":1,\"54\":1}}],[\"转载自哔哩哔哩技术\",{\"1\":{\"20\":1}}],[\"之所以采用不同的方式主要是因为\",{\"1\":{\"1306\":1}}],[\"之前的方式是\",{\"1\":{\"1434\":1}}],[\"之前改变该\",{\"1\":{\"1406\":1}}],[\"之前学习过\",{\"1\":{\"1251\":1}}],[\"之前\",{\"1\":{\"875\":2,\"1276\":1,\"1404\":1,\"1420\":1,\"1475\":1}}],[\"之外\",{\"1\":{\"698\":1}}],[\"之外的类调用\",{\"1\":{\"576\":1}}],[\"之道\",{\"1\":{\"647\":1}}],[\"之一\",{\"1\":{\"467\":1}}],[\"之和是\",{\"1\":{\"261\":1}}],[\"之迷宫问题\",{\"1\":{\"234\":1}}],[\"之内\",{\"1\":{\"134\":1}}],[\"之间可以插入其他指令\",{\"1\":{\"1482\":1}}],[\"之间进行了一次通信\",{\"1\":{\"1456\":1}}],[\"之间进行分析\",{\"1\":{\"1237\":1}}],[\"之间存在数据竞争\",{\"1\":{\"1476\":1}}],[\"之间存在\",{\"1\":{\"1420\":1}}],[\"之间存在有向边\",{\"1\":{\"223\":1}}],[\"之间没有数据依赖性\",{\"1\":{\"1418\":1,\"1475\":1,\"1478\":1}}],[\"之间没有任何关系\",{\"1\":{\"1418\":1}}],[\"之间要完成通信的话\",{\"1\":{\"1417\":1}}],[\"之间以及\",{\"1\":{\"1237\":1}}],[\"之间的关系如下图所示\",{\"1\":{\"1313\":1}}],[\"之间的关系\",{\"1\":{\"1305\":1}}],[\"之间的数据是相互隔离的\",{\"1\":{\"1100\":1}}],[\"之间的所有数字中\",{\"1\":{\"309\":1}}],[\"之间的顺序任意\",{\"1\":{\"287\":1}}],[\"之间的转化\",{\"0\":{\"251\":1}}],[\"之间\",{\"1\":{\"83\":2,\"899\":1,\"1237\":1}}],[\"之间有多少个数是\",{\"1\":{\"76\":2}}],[\"之后将数据重新写回到主内存中\",{\"1\":{\"1417\":1}}],[\"之后调用\",{\"1\":{\"1392\":1}}],[\"之后后面也会用单独的一篇文章进行解析\",{\"1\":{\"1253\":1}}],[\"之后一个重要特征是反射\",{\"1\":{\"1132\":1}}],[\"之后一个整数\",{\"1\":{\"202\":1}}],[\"之后的读写操作均使用位于工作内存的变量副本\",{\"1\":{\"1417\":1}}],[\"之后的操作的\",{\"1\":{\"1252\":1}}],[\"之后的操作都是针对这个节点\",{\"1\":{\"1252\":1}}],[\"之后的内容均是注释\",{\"1\":{\"1109\":1}}],[\"之后的尾迭代器\",{\"1\":{\"423\":1}}],[\"之后还是不行\",{\"1\":{\"559\":1}}],[\"之后用户注册成功之后\",{\"1\":{\"613\":1}}],[\"之后用\",{\"1\":{\"373\":1}}],[\"之后\",{\"1\":{\"196\":1,\"777\":1,\"789\":1,\"947\":3,\"1049\":1,\"1285\":1,\"1388\":1,\"1492\":1}}],[\"之后每行输入一个长度不超过\",{\"1\":{\"88\":1}}],[\"之后使用小顶堆计算\",{\"1\":{\"61\":1}}],[\"之后统计所有未过期的\",{\"1\":{\"61\":1}}],[\"之后根据\",{\"1\":{\"56\":1}}],[\"之后事务更新其他表\",{\"1\":{\"56\":1}}],[\"之后再在\",{\"1\":{\"48\":1}}],[\"~$\",{\"1\":{\"1107\":5,\"1116\":5,\"1119\":2}}],[\"~x\",{\"1\":{\"339\":1}}],[\"~0\",{\"1\":{\"338\":1}}],[\"~1\",{\"1\":{\"338\":3}}],[\"~i\",{\"1\":{\"223\":2}}],[\"~\",{\"0\":{\"508\":1},\"1\":{\"76\":2,\"88\":1,\"99\":1,\"119\":1,\"309\":1,\"312\":1,\"337\":1,\"338\":2,\"368\":1,\"371\":1,\"380\":1,\"392\":2,\"421\":1,\"422\":1,\"423\":4,\"568\":1,\"575\":1,\"1004\":2,\"1107\":1,\"1339\":1}}],[\"防止上面的\",{\"1\":{\"1457\":1}}],[\"防止数据库中的字段泄露\",{\"1\":{\"574\":1}}],[\"防止数组越界\",{\"1\":{\"242\":1}}],[\"防止题目被重复添加到同一个题库中\",{\"1\":{\"513\":1}}],[\"防止敏感数据泄露给未授权的人员\",{\"1\":{\"470\":1}}],[\"防止外部广告平台的计费重复\",{\"1\":{\"151\":1}}],[\"防止溢出\",{\"1\":{\"72\":1,\"377\":1}}],[\"防止缓存击穿\",{\"1\":{\"31\":1}}],[\"取值增大\",{\"1\":{\"1315\":1}}],[\"取一个辨识度更高的方法名即可\",{\"1\":{\"1147\":1}}],[\"取一个数的指定位\",{\"1\":{\"338\":1}}],[\"取队首元素但不删除\",{\"1\":{\"1076\":1}}],[\"取队首元素并删除\",{\"1\":{\"1076\":1}}],[\"取到合法的状态\",{\"1\":{\"795\":1}}],[\"取消重定向后并在下面的\",{\"1\":{\"587\":1}}],[\"取这两个值的冲突概率低\",{\"1\":{\"421\":1}}],[\"取走最后一件物品者获胜\",{\"1\":{\"394\":1}}],[\"取走任意多个物品\",{\"1\":{\"394\":1}}],[\"取出第一个元素为\",{\"1\":{\"1407\":2}}],[\"取出当前最外层的烂橘子\",{\"1\":{\"870\":1}}],[\"取出这一层的烂橘子开始遍历\",{\"1\":{\"870\":1}}],[\"取出遍历到的节点\",{\"1\":{\"742\":1}}],[\"取出题目id集合\",{\"1\":{\"525\":1}}],[\"取出作为\",{\"1\":{\"355\":1}}],[\"取出b的每一位\",{\"1\":{\"291\":1}}],[\"取反\",{\"1\":{\"337\":1}}],[\"取决于题目对精度的要求\",{\"1\":{\"325\":1}}],[\"取根节点两种方案的最大值\",{\"1\":{\"314\":1}}],[\"取最大\",{\"1\":{\"166\":1}}],[\"取最小值\",{\"1\":{\"146\":1}}],[\"取模运算符\",{\"1\":{\"979\":1}}],[\"取模的数用\",{\"1\":{\"421\":1}}],[\"取模的值即可\",{\"1\":{\"196\":1}}],[\"取模的值\",{\"1\":{\"87\":1,\"182\":1}}],[\"取模加模再取模\",{\"1\":{\"384\":1}}],[\"取模操作\",{\"1\":{\"182\":1}}],[\"取模后的结果\",{\"1\":{\"167\":1}}],[\"取模之后的值\",{\"1\":{\"135\":1}}],[\"取模\",{\"1\":{\"72\":1,\"87\":1,\"167\":1,\"1272\":1}}],[\"取余的结果\",{\"1\":{\"72\":1}}],[\"向程序员提供的\",{\"1\":{\"1423\":1}}],[\"向程序员保证\",{\"1\":{\"1420\":1}}],[\"向线程池提交任务\",{\"1\":{\"1371\":1}}],[\"向后环形未搜索可覆盖\",{\"1\":{\"1317\":1}}],[\"向后环形查找到可覆盖的\",{\"1\":{\"1317\":1}}],[\"向后端发送请求\",{\"1\":{\"447\":1}}],[\"向前环形搜索到脏\",{\"1\":{\"1317\":1}}],[\"向前找到第一个脏entry\",{\"1\":{\"1317\":1}}],[\"向前缀树中插入字符串\",{\"1\":{\"801\":1}}],[\"向\",{\"1\":{\"1184\":1,\"1185\":1,\"1407\":1}}],[\"向零整除后的余数\",{\"1\":{\"979\":1}}],[\"向哈希表中添加元素时\",{\"1\":{\"971\":1}}],[\"向哈希表中插入一个数\",{\"1\":{\"419\":1}}],[\"向指定字段添加数据\",{\"1\":{\"925\":1}}],[\"向上返回结果\",{\"1\":{\"730\":1}}],[\"向上寻找\",{\"1\":{\"77\":1}}],[\"向导模式编辑\",{\"1\":{\"670\":1}}],[\"向数据库插入用户数据\",{\"1\":{\"568\":1}}],[\"向栈顶插入一个元素\",{\"1\":{\"422\":1}}],[\"向栈顶插入一个数\",{\"1\":{\"406\":1}}],[\"向队尾插入一个元素\",{\"1\":{\"422\":1}}],[\"向队尾插入一个数\",{\"1\":{\"409\":1}}],[\"向中间移动\",{\"1\":{\"317\":1}}],[\"向下寻找\",{\"1\":{\"77\":1}}],[\"向右寻找\",{\"1\":{\"77\":1}}],[\"向右移动和从\",{\"1\":{\"72\":1}}],[\"向左寻找\",{\"1\":{\"77\":1}}],[\"向左移动的方法数之和\",{\"1\":{\"72\":1}}],[\"遍历偏向对象的锁记录\",{\"1\":{\"1443\":1}}],[\"遍历过程中如果遇到脏entry的话直接令value为null\",{\"1\":{\"1306\":1}}],[\"遍历过所有的节点以后就完成了复制工作\",{\"1\":{\"1274\":1}}],[\"遍历执行\",{\"1\":{\"888\":1}}],[\"遍历至原链表下一节点\",{\"1\":{\"887\":2}}],[\"遍历建好的图\",{\"1\":{\"875\":1}}],[\"遍历到\",{\"1\":{\"852\":3}}],[\"遍历整个二维数组\",{\"1\":{\"821\":1,\"822\":1}}],[\"遍历上下左右四个方向\",{\"1\":{\"820\":1}}],[\"遍历剩下区间\",{\"1\":{\"784\":1}}],[\"遍历字符串\",{\"1\":{\"783\":1}}],[\"遍历背包放在内层\",{\"1\":{\"772\":1}}],[\"遍历顺序是\",{\"1\":{\"725\":1}}],[\"遍历一遍链表顺便把每两个节点翻转\",{\"1\":{\"693\":1}}],[\"遍历一次字符串\",{\"1\":{\"82\":1}}],[\"遍历无需认证即可访问的url列表\",{\"1\":{\"446\":1}}],[\"遍历所有左端点在l的左边的区间\",{\"1\":{\"430\":1}}],[\"遍历所有点\",{\"1\":{\"362\":1,\"363\":1}}],[\"遍历n个点\",{\"1\":{\"352\":1}}],[\"遍历节点\",{\"1\":{\"215\":1}}],[\"遍历添加字符串\",{\"1\":{\"203\":1}}],[\"遍历数组时计算当前最大值\",{\"1\":{\"705\":1}}],[\"遍历数组\",{\"1\":{\"179\":1}}],[\"遍历填充\",{\"1\":{\"127\":1}}],[\"遍历\",{\"1\":{\"108\":1,\"729\":1}}],[\"遍历每个游戏节点\",{\"1\":{\"146\":1}}],[\"遍历每个房子\",{\"1\":{\"108\":1}}],[\"遍历每次速通记录\",{\"1\":{\"146\":1}}],[\"遍历每一座山\",{\"1\":{\"66\":1}}],[\"遍历每一天\",{\"1\":{\"65\":1}}],[\"遍历变量名中的每一个字符\",{\"1\":{\"98\":1}}],[\"遍历输入字符串\",{\"1\":{\"93\":1}}],[\"遍历步数\",{\"1\":{\"72\":1}}],[\"尝试获取许可\",{\"1\":{\"1398\":2}}],[\"尝试从一个空队列中取一个元素也会同样阻塞\",{\"1\":{\"1326\":1}}],[\"尝试使用定时锁\",{\"1\":{\"1221\":1}}],[\"尝试抓取注册表信息\",{\"1\":{\"1182\":1}}],[\"尝试直接在原来的节点上改变指向\",{\"1\":{\"725\":1}}],[\"尝试将元素放入队列将导致操作阻塞\",{\"1\":{\"1326\":1}}],[\"尝试将\",{\"1\":{\"167\":1}}],[\"尝试用所有小于等于\",{\"1\":{\"115\":1}}],[\"尝试用数学的方法\",{\"1\":{\"72\":1}}],[\"尝试通过修改一次任意一座山的高度\",{\"1\":{\"66\":1}}],[\"步增加了对中断的检测\",{\"1\":{\"1508\":1}}],[\"步会先计算出按照现在时间和超时时间计算出理论上的截止时间\",{\"1\":{\"1508\":1}}],[\"步中的\",{\"1\":{\"1508\":2}}],[\"步中会进一步计算数组中可用的大小\",{\"1\":{\"1271\":1}}],[\"步中会先通过\",{\"1\":{\"1271\":1}}],[\"步中调用\",{\"1\":{\"1251\":1}}],[\"步\",{\"1\":{\"110\":2,\"777\":2,\"778\":1,\"1272\":1,\"1316\":1,\"1358\":2,\"1508\":1}}],[\"步骤5\",{\"1\":{\"167\":1}}],[\"步骤4\",{\"1\":{\"167\":1}}],[\"步骤3\",{\"1\":{\"167\":1}}],[\"步骤2\",{\"1\":{\"167\":1}}],[\"步骤1\",{\"1\":{\"167\":1}}],[\"步骤\",{\"1\":{\"72\":1,\"115\":1,\"134\":1,\"178\":1,\"291\":1,\"390\":1,\"410\":1,\"559\":1}}],[\"步到达位置\",{\"1\":{\"72\":1}}],[\"步的方法\",{\"1\":{\"72\":1}}],[\"步并到达\",{\"1\":{\"72\":1}}],[\"返回后能够退出\",{\"1\":{\"1406\":1}}],[\"返回正在等待获取许可证的线程数\",{\"1\":{\"1398\":1}}],[\"返回为止\",{\"1\":{\"1504\":1}}],[\"返回为\",{\"1\":{\"1336\":1}}],[\"返回特殊值\",{\"1\":{\"1326\":1}}],[\"返回当前可用的许可证个数\",{\"1\":{\"1398\":1}}],[\"返回当前获取读锁的次数\",{\"1\":{\"1242\":1}}],[\"返回当前结点值\",{\"1\":{\"712\":1}}],[\"返回的是原来的\",{\"1\":{\"1387\":1}}],[\"返回的是自增前的旧值\",{\"1\":{\"1385\":1}}],[\"返回的是任务的最终计算结果\",{\"1\":{\"1367\":1}}],[\"返回的是异步执行的结果\",{\"1\":{\"1330\":1}}],[\"返回的是\",{\"1\":{\"1284\":1}}],[\"返回的\",{\"1\":{\"1184\":1}}],[\"返回存储桶的列表\",{\"1\":{\"1102\":1}}],[\"返回布尔值\",{\"1\":{\"1102\":1}}],[\"返回list1中最后一个等于list2的子列表的索引\",{\"1\":{\"1081\":1}}],[\"返回list1中第一个等于list2的子列表的索引\",{\"1\":{\"1081\":1}}],[\"返回集合中最小的元素\",{\"1\":{\"1081\":1}}],[\"返回集合中最大的元素\",{\"1\":{\"1081\":1}}],[\"返回栈中元素个数\",{\"1\":{\"1075\":1}}],[\"返回栈顶元素\",{\"1\":{\"422\":1,\"1037\":1}}],[\"返回出栈元素e\",{\"1\":{\"1075\":1}}],[\"返回这个映射的值\",{\"1\":{\"1074\":1}}],[\"返回这个映射的键\",{\"1\":{\"1074\":1}}],[\"返回这两个字符串的最长公共子序列的长度\",{\"1\":{\"838\":1}}],[\"返回map中中键值对<k\",{\"1\":{\"1074\":1}}],[\"返回map中key对应的value\",{\"1\":{\"1074\":2}}],[\"返回map\",{\"1\":{\"1074\":1}}],[\"返回value值\",{\"1\":{\"1074\":1}}],[\"返回有序集合中第一个元素\",{\"1\":{\"1073\":1}}],[\"返回有多少个1\",{\"1\":{\"422\":1}}],[\"返回false\",{\"1\":{\"1073\":1,\"1232\":1}}],[\"返回动态数组所存元素个数\",{\"1\":{\"1072\":1}}],[\"返回之前的内容\",{\"1\":{\"1072\":1}}],[\"返回缓冲字符串长度\",{\"1\":{\"1070\":1}}],[\"返回index位置的char\",{\"1\":{\"1070\":1}}],[\"返回index位置的字符char\",{\"1\":{\"1069\":1}}],[\"返回str最后出现的位置\",{\"1\":{\"1069\":1}}],[\"返回str第一个出现的位置\",{\"1\":{\"1069\":1}}],[\"返回字符片段\",{\"1\":{\"1069\":1}}],[\"返回字符串所在字符数组的起始地址\",{\"1\":{\"422\":1}}],[\"返回字符串长度\",{\"1\":{\"422\":1,\"1069\":1}}],[\"返回与arr类型相同的一个数组\",{\"1\":{\"1067\":1}}],[\"返回此\",{\"1\":{\"1046\":1}}],[\"返回关于发生的异常的详细信息\",{\"1\":{\"1046\":1}}],[\"返回关键字对应的值\",{\"1\":{\"1040\":1}}],[\"返回小于等于key的最大元素\",{\"1\":{\"1039\":1,\"1040\":1}}],[\"返回元素位置在index的元素e\",{\"1\":{\"1072\":1}}],[\"返回元素数\",{\"1\":{\"1039\":1,\"1040\":1}}],[\"返回元素个数\",{\"1\":{\"422\":1}}],[\"返回长度\",{\"1\":{\"1005\":1,\"1036\":1,\"1037\":1,\"1038\":1}}],[\"返回数组长度\",{\"1\":{\"1002\":1}}],[\"返回到上面的while循环中\",{\"1\":{\"1274\":1}}],[\"返回到原始状态\",{\"1\":{\"955\":1}}],[\"返回到表格\",{\"1\":{\"592\":1}}],[\"返回复制链表的头节点\",{\"1\":{\"886\":1}}],[\"返回翻转后的二叉树的根节点\",{\"1\":{\"864\":1}}],[\"返回每次的根节点即可\",{\"1\":{\"863\":1}}],[\"返回头结点\",{\"1\":{\"834\":1}}],[\"返回头结点即可\",{\"1\":{\"681\":1}}],[\"返回临时链表头结点\",{\"1\":{\"833\":1}}],[\"返回不为空\",{\"1\":{\"803\":1}}],[\"返回不为空且节点标记为尾节点\",{\"1\":{\"803\":1}}],[\"返回最后\",{\"1\":{\"796\":1}}],[\"返回链表即可\",{\"1\":{\"789\":1}}],[\"返回合并后的链表\",{\"1\":{\"788\":1}}],[\"返回根节点\",{\"1\":{\"767\":1}}],[\"返回该pair的字符串表示\",{\"1\":{\"1082\":1}}],[\"返回该pair的value值\",{\"1\":{\"1082\":1}}],[\"返回该pair的key值\",{\"1\":{\"1082\":1}}],[\"返回该节点的最大深度\",{\"1\":{\"761\":1}}],[\"返回该树的\",{\"1\":{\"759\":1}}],[\"返回该二叉树层序遍历的结果\",{\"1\":{\"133\":1}}],[\"返回其最大深度\",{\"1\":{\"747\":1}}],[\"返回其节点值的\",{\"1\":{\"741\":1}}],[\"返回其\",{\"1\":{\"717\":1}}],[\"返回结果为头结点时\",{\"1\":{\"699\":1}}],[\"返回结果数组\",{\"1\":{\"128\":1}}],[\"返回新链表的头节点\",{\"1\":{\"887\":1,\"888\":1}}],[\"返回新的头节点\",{\"1\":{\"694\":1}}],[\"返回新写入的数据\",{\"1\":{\"526\":1}}],[\"返回反转后的头结点\",{\"1\":{\"682\":1}}],[\"返回类型和\",{\"0\":{\"1019\":1}}],[\"返回类型\",{\"1\":{\"1009\":1}}],[\"返回类型为double\",{\"1\":{\"1080\":1}}],[\"返回类型为\",{\"1\":{\"589\":1}}],[\"返回类支持返回正常和错误\",{\"1\":{\"598\":1}}],[\"返回给前端\",{\"1\":{\"575\":2}}],[\"返回脱敏后的用户信息\",{\"1\":{\"574\":1}}],[\"返回值大于等于\",{\"1\":{\"1510\":1}}],[\"返回值大于0\",{\"1\":{\"1078\":1}}],[\"返回值为栈顶元素e\",{\"1\":{\"1075\":1}}],[\"返回值为元素e\",{\"1\":{\"1075\":1}}],[\"返回值默认为\",{\"1\":{\"576\":1}}],[\"返回值\",{\"1\":{\"573\":1,\"887\":1}}],[\"返回渲染结果\",{\"1\":{\"533\":1}}],[\"返回一个随机数\",{\"1\":{\"1080\":1}}],[\"返回一个collection<v>\",{\"1\":{\"1074\":1}}],[\"返回一个set\",{\"1\":{\"1074\":1}}],[\"返回一个与构建起或缓冲器内容相同的字符串\",{\"1\":{\"1070\":1}}],[\"返回一个新的字符串全部转成大写\",{\"1\":{\"1069\":1}}],[\"返回一个新的字符串全部转成小写\",{\"1\":{\"1069\":1}}],[\"返回一个新字符串string\",{\"1\":{\"1069\":1}}],[\"返回一个字符串\",{\"1\":{\"1067\":1}}],[\"返回一个包含堆栈层次的数组\",{\"1\":{\"1046\":1}}],[\"返回一个包含基本\",{\"1\":{\"532\":1}}],[\"返回一个\",{\"1\":{\"1046\":1}}],[\"返回一个整型值\",{\"1\":{\"1010\":1}}],[\"返回一个整型数组\",{\"1\":{\"108\":1}}],[\"返回指向第一个大于等于\",{\"1\":{\"423\":1}}],[\"返回去重\",{\"1\":{\"423\":1}}],[\"返回大于等于key的最小元素\",{\"1\":{\"1039\":1,\"1040\":1}}],[\"返回大于等于x的最小的数的迭代器\",{\"1\":{\"422\":1}}],[\"返回大于x的最小的数的迭代器\",{\"1\":{\"422\":1}}],[\"返回某一个数的个数\",{\"1\":{\"422\":1}}],[\"返回前驱和后继\",{\"1\":{\"422\":1}}],[\"返回堆顶元素\",{\"1\":{\"422\":1}}],[\"返回队中元素个数\",{\"1\":{\"1076\":1}}],[\"返回队头\",{\"1\":{\"1038\":1}}],[\"返回队头元素\",{\"1\":{\"422\":1}}],[\"返回队尾元素\",{\"1\":{\"422\":1}}],[\"返回子串\",{\"1\":{\"422\":1}}],[\"返回是否为空\",{\"1\":{\"422\":1}}],[\"返回x应该插入的位置\",{\"1\":{\"420\":1}}],[\"返回x的下标\",{\"1\":{\"420\":1}}],[\"返回x的祖宗节点\",{\"1\":{\"414\":1,\"415\":1,\"416\":1}}],[\"返回a的b次方\",{\"1\":{\"1080\":1}}],[\"返回a的绝对值\",{\"1\":{\"1080\":1}}],[\"返回a和b的最小值\",{\"1\":{\"1080\":1}}],[\"返回a和b的最大值\",{\"1\":{\"1080\":1}}],[\"返回a\",{\"1\":{\"328\":1}}],[\"返回true\",{\"1\":{\"328\":2,\"1232\":1}}],[\"返回父亲节点\",{\"1\":{\"270\":1}}],[\"返回按照查找规则找到的第一个字符或者子串的位置\",{\"1\":{\"252\":1}}],[\"返回c风格字符串长度\",{\"1\":{\"243\":1}}],[\"返回答案\",{\"1\":{\"223\":1}}],[\"返回找到的结果路径\",{\"1\":{\"215\":1}}],[\"返回即可\",{\"1\":{\"139\":1,\"710\":1}}],[\"返回和为\",{\"1\":{\"115\":1,\"794\":1}}],[\"返回\",{\"1\":{\"93\":4,\"127\":1,\"186\":2,\"187\":3,\"243\":3,\"252\":1,\"256\":2,\"339\":1,\"568\":1,\"729\":1,\"801\":4,\"827\":1,\"838\":1,\"856\":1,\"864\":1,\"868\":2,\"869\":1,\"874\":2,\"875\":1,\"892\":1,\"1005\":1,\"1020\":1,\"1120\":2,\"1232\":2,\"1283\":2,\"1284\":1,\"1316\":1,\"1325\":1,\"1337\":1,\"1383\":1,\"1437\":1,\"1496\":1,\"1505\":1,\"1507\":1}}],[\"返回对\",{\"1\":{\"72\":1}}],[\"返回从begin开始后面所有的字符片段\",{\"1\":{\"1069\":1}}],[\"返回从右侧所能看到的节点值\",{\"1\":{\"735\":1}}],[\"返回从\",{\"1\":{\"72\":1}}],[\"方式达到超时等待获取锁的效果\",{\"1\":{\"1508\":1}}],[\"方式更改\",{\"1\":{\"1283\":1}}],[\"方式只能支持一个\",{\"1\":{\"1248\":1}}],[\"方式不支持\",{\"1\":{\"1248\":1}}],[\"方式注入会显得比较宽松灵活些\",{\"1\":{\"1133\":1}}],[\"方式2\",{\"1\":{\"981\":1,\"982\":1}}],[\"方式1\",{\"1\":{\"981\":1,\"982\":1}}],[\"方程的两边同时乘上一个非00数不改变方程的解\",{\"1\":{\"385\":1}}],[\"方程组中的系数为实数\",{\"1\":{\"385\":1}}],[\"方法再调用\",{\"1\":{\"1503\":1}}],[\"方法再来看\",{\"1\":{\"1273\":1}}],[\"方法基础上增加了能响应中断的功能\",{\"1\":{\"1500\":1}}],[\"方法基本一致\",{\"1\":{\"1251\":1}}],[\"方法另一个线程执行\",{\"1\":{\"1478\":1}}],[\"方法定义参数和异常处理器参数不会在线程间共享\",{\"1\":{\"1416\":1}}],[\"方法替换成\",{\"1\":{\"1408\":2}}],[\"方法阻塞等待\",{\"1\":{\"1408\":1}}],[\"方法阻塞线程会致使线程进入到\",{\"1\":{\"1259\":1}}],[\"方法可能承担两个任务\",{\"1\":{\"1504\":1}}],[\"方法可能会出现\",{\"1\":{\"1408\":1}}],[\"方法可以做这样的总结\",{\"1\":{\"1504\":1}}],[\"方法可以看做是线程间协作的一种方式\",{\"1\":{\"1337\":1}}],[\"方法可以将等待队列中等待时间最长的节点移动到同步队列中\",{\"1\":{\"1252\":1}}],[\"方法出退出\",{\"1\":{\"1407\":1}}],[\"方法通知处于\",{\"1\":{\"1407\":1}}],[\"方法通知所有的等待线程\",{\"1\":{\"1337\":1}}],[\"方法之后\",{\"1\":{\"1404\":1}}],[\"方法之前会先对状态变量进行判断\",{\"1\":{\"1406\":1}}],[\"方法之前\",{\"1\":{\"1375\":1}}],[\"方法处\",{\"1\":{\"1406\":1}}],[\"方法处阻塞\",{\"1\":{\"1406\":1}}],[\"方法处退出\",{\"1\":{\"1404\":1}}],[\"方法处成功返回\",{\"1\":{\"1404\":1}}],[\"方法处返回\",{\"1\":{\"1404\":1}}],[\"方法处理登录逻辑\",{\"1\":{\"451\":1}}],[\"方法或\",{\"1\":{\"1404\":2}}],[\"方法或者\",{\"1\":{\"1334\":1}}],[\"方法或者像被阻塞或等待时才失去控制权\",{\"1\":{\"1331\":1}}],[\"方法或者具有超时特性的\",{\"1\":{\"1326\":1}}],[\"方法或者可延时的\",{\"1\":{\"1326\":1}}],[\"方法或者当前线程被中断\",{\"1\":{\"1259\":1}}],[\"方法比较少\",{\"1\":{\"1394\":1}}],[\"方法功能一致\",{\"1\":{\"1392\":1}}],[\"方法用下图进行总结\",{\"1\":{\"1375\":1}}],[\"方法用于设置在当前线程中\",{\"1\":{\"1301\":1}}],[\"方法用于在用户导航到不同路由之前进行一些预处理\",{\"1\":{\"453\":1,\"459\":1}}],[\"方法取消任务\",{\"1\":{\"1375\":1}}],[\"方法被执行的过程中\",{\"1\":{\"1375\":1}}],[\"方法还没有被执行之前\",{\"1\":{\"1375\":1}}],[\"方法启动线程\",{\"1\":{\"1371\":1}}],[\"方法新建了\",{\"1\":{\"1371\":1}}],[\"方法很容易理解\",{\"1\":{\"1370\":1}}],[\"方法重设下一次任务执行的时间\",{\"1\":{\"1368\":1}}],[\"方法才会返回\",{\"1\":{\"1360\":1}}],[\"方法都会返回\",{\"1\":{\"1360\":1}}],[\"方法执行结束\",{\"1\":{\"1375\":1,\"1407\":1}}],[\"方法执行结束退出\",{\"1\":{\"1316\":1}}],[\"方法执行逻辑有这样几种情况\",{\"1\":{\"1359\":1}}],[\"方法执行逻辑请见注释\",{\"1\":{\"1359\":1}}],[\"方法一样\",{\"1\":{\"1351\":1}}],[\"方法一共提供如下这些方法\",{\"1\":{\"1337\":1}}],[\"方法主要逻辑是使用\",{\"1\":{\"1505\":1}}],[\"方法主要包含了三个操作\",{\"1\":{\"1475\":1}}],[\"方法主要是通过\",{\"1\":{\"1348\":1}}],[\"方法主要有这样几点\",{\"1\":{\"1316\":1}}],[\"方法详解\",{\"0\":{\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1}}],[\"方法在休眠时间达到后如果再次获得\",{\"1\":{\"1338\":1}}],[\"方法在消费数据\",{\"1\":{\"1326\":2}}],[\"方法没有这个限制可以在任何地方种使用\",{\"1\":{\"1338\":1}}],[\"方法必须等待\",{\"1\":{\"1338\":1}}],[\"方法必须要在同步方法或者同步块中调用\",{\"1\":{\"1338\":1}}],[\"方法必须是已经获得了\",{\"1\":{\"1251\":1}}],[\"方法经常拿来与\",{\"1\":{\"1338\":1}}],[\"方法并不会失去锁\",{\"1\":{\"1338\":1}}],[\"方法并且当前线程获取\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"方法外围加一层\",{\"1\":{\"1406\":1}}],[\"方法外\",{\"1\":{\"1337\":1}}],[\"方法线程会进入到\",{\"1\":{\"1334\":1}}],[\"方法正常退出\",{\"1\":{\"1333\":1}}],[\"方法能够立即返回结果退出\",{\"1\":{\"1326\":1}}],[\"方法相同\",{\"1\":{\"1500\":1}}],[\"方法相比\",{\"1\":{\"1326\":1}}],[\"方法相较于无参的\",{\"1\":{\"1259\":1}}],[\"方法不同的是\",{\"1\":{\"1325\":1}}],[\"方法看出\",{\"1\":{\"1317\":1}}],[\"方法向后环形去找\",{\"1\":{\"1317\":1}}],[\"方法从阻塞队列中不断的去获取任务进行执行\",{\"1\":{\"1370\":1}}],[\"方法从\",{\"1\":{\"1317\":4}}],[\"方法清理掉当前脏\",{\"1\":{\"1316\":1}}],[\"方法结束退出\",{\"1\":{\"1316\":1}}],[\"方法结尾处调用了\",{\"1\":{\"1275\":1}}],[\"方法做个总结\",{\"1\":{\"1375\":1}}],[\"方法做一下总结\",{\"1\":{\"1316\":1}}],[\"方法做了些什么事情\",{\"1\":{\"1252\":1}}],[\"方法搜索基本上清楚了\",{\"1\":{\"1316\":1}}],[\"方法插入新的\",{\"1\":{\"1315\":1}}],[\"方法检测并清除脏\",{\"1\":{\"1314\":1}}],[\"方法逻辑几乎一致\",{\"1\":{\"1507\":1}}],[\"方法逻辑很简单\",{\"1\":{\"1307\":1}}],[\"方法逻辑请看注释\",{\"1\":{\"1306\":1}}],[\"方法解决脏\",{\"1\":{\"1306\":1}}],[\"方法解决\",{\"1\":{\"1306\":1}}],[\"方法前先判断状态是否已经改变\",{\"1\":{\"1406\":1}}],[\"方法前\",{\"1\":{\"1306\":1}}],[\"方法实际上会调用\",{\"1\":{\"1503\":1}}],[\"方法实际上具体是通过\",{\"1\":{\"1304\":1}}],[\"方法实现超时等待的效果\",{\"1\":{\"1508\":1}}],[\"方法实现自己的同步语义\",{\"1\":{\"1496\":1}}],[\"方法实现往前环形搜索脏\",{\"1\":{\"1317\":1}}],[\"方法实现了存数据和读数据\",{\"1\":{\"1303\":1}}],[\"方法实现非常简单\",{\"1\":{\"1293\":1}}],[\"方法实现原理\",{\"0\":{\"1293\":1,\"1294\":1}}],[\"方法实现\",{\"1\":{\"1251\":1}}],[\"方法实现的\",{\"1\":{\"1239\":1,\"1242\":1,\"1304\":1,\"1306\":1}}],[\"方法几乎一致\",{\"1\":{\"1302\":1}}],[\"方法只允许与当前线程具有相同优先级的线程能够获得释放出来的\",{\"1\":{\"1339\":1}}],[\"方法只是会让出cpu并不会释放掉对象锁\",{\"1\":{\"1338\":1}}],[\"方法只会在同一个线程中执行这个任务\",{\"1\":{\"1330\":1}}],[\"方法只会对等待队列的头节点进行操作\",{\"1\":{\"1252\":1}}],[\"方法只需要带着逆向思维去看就好\",{\"1\":{\"1302\":1}}],[\"方法核心代码为\",{\"1\":{\"1295\":1}}],[\"方法更新\",{\"1\":{\"1284\":1}}],[\"方法运行结束\",{\"1\":{\"1284\":1}}],[\"方法源码\",{\"1\":{\"1506\":1}}],[\"方法源码如下\",{\"1\":{\"1284\":1,\"1347\":1,\"1348\":1,\"1359\":1}}],[\"方法源码为\",{\"1\":{\"1251\":1,\"1252\":1,\"1264\":1,\"1273\":1,\"1307\":1,\"1347\":1,\"1348\":1,\"1351\":1,\"1505\":1}}],[\"方法设置为队列的头结点\",{\"1\":{\"1505\":1}}],[\"方法设置\",{\"1\":{\"1283\":1,\"1306\":1}}],[\"方法开始运行\",{\"1\":{\"1334\":1}}],[\"方法开始执行\",{\"1\":{\"1330\":1}}],[\"方法开始\",{\"1\":{\"1283\":1}}],[\"方法类似\",{\"1\":{\"1275\":1}}],[\"方法获得当前设备的\",{\"1\":{\"1361\":1}}],[\"方法获得\",{\"1\":{\"1274\":1}}],[\"方法获取该许可证\",{\"1\":{\"1398\":1}}],[\"方法获取该位置上的元素\",{\"1\":{\"1272\":1}}],[\"方法获取锁成功后调用了\",{\"1\":{\"1253\":2}}],[\"方法获取所有大于该积分的玩家数量\",{\"1\":{\"129\":2}}],[\"方法对其进行中断操作\",{\"1\":{\"1336\":1}}],[\"方法对\",{\"1\":{\"1272\":1}}],[\"方法整体流程\",{\"1\":{\"1272\":1}}],[\"方法判断为\",{\"1\":{\"1272\":1}}],[\"方法完成向红黑树插入新节点\",{\"1\":{\"1272\":1}}],[\"方法为例\",{\"1\":{\"1368\":1,\"1370\":1,\"1385\":1}}],[\"方法为\",{\"1\":{\"1272\":1,\"1307\":1,\"1505\":1}}],[\"方法进行修改同步状态\",{\"1\":{\"1495\":1}}],[\"方法进行通知之后\",{\"1\":{\"1404\":1}}],[\"方法进行执行任务\",{\"1\":{\"1370\":1}}],[\"方法进行设置\",{\"1\":{\"1339\":1}}],[\"方法进行比价\",{\"1\":{\"1338\":1}}],[\"方法进行处理\",{\"1\":{\"1307\":1}}],[\"方法进行扩容\",{\"1\":{\"1306\":1}}],[\"方法进行总结一下\",{\"1\":{\"1301\":1}}],[\"方法进行判断\",{\"1\":{\"1284\":1}}],[\"方法进行了一次重\",{\"1\":{\"1272\":1}}],[\"方法进入等待队列\",{\"1\":{\"1253\":1}}],[\"方法是获取独占式锁\",{\"1\":{\"1503\":1}}],[\"方法是获取当前线程中\",{\"1\":{\"1302\":1}}],[\"方法是可以被重载的\",{\"1\":{\"1470\":1}}],[\"方法是不能够被子类重写的\",{\"1\":{\"1470\":1}}],[\"方法是\",{\"1\":{\"1338\":1,\"1370\":1}}],[\"方法是必须等到有消费者线程消费数据时\",{\"1\":{\"1326\":1}}],[\"方法是怎样实现的\",{\"1\":{\"1272\":1,\"1346\":1}}],[\"方法是将头节点移动到同步队列中\",{\"1\":{\"1252\":1}}],[\"方法是将同步状态\",{\"1\":{\"1239\":1}}],[\"方法了吧\",{\"1\":{\"1272\":1}}],[\"方法将许可证归还\",{\"1\":{\"1398\":1}}],[\"方法将位置为\",{\"1\":{\"1386\":1}}],[\"方法将返回\",{\"1\":{\"1375\":1}}],[\"方法将以中断线程的方式来阻止任务继续进行\",{\"1\":{\"1375\":1}}],[\"方法将此任务永远不会执行\",{\"1\":{\"1375\":1}}],[\"方法将导致调用线程立即返回结果或者抛出异常\",{\"1\":{\"1375\":1}}],[\"方法将导致调用线程阻塞\",{\"1\":{\"1375\":1}}],[\"方法将下一次待执行的任务放置到\",{\"1\":{\"1368\":1}}],[\"方法将数据传递给消费者线程\",{\"1\":{\"1326\":1}}],[\"方法将对象实例保存在每个线程自己所拥有的\",{\"1\":{\"1313\":1}}],[\"方法将这个变量移除\",{\"1\":{\"1309\":1}}],[\"方法将其\",{\"1\":{\"1308\":1}}],[\"方法将新值插入即可\",{\"1\":{\"1272\":1}}],[\"方法将\",{\"1\":{\"1271\":1,\"1272\":1,\"1280\":1,\"1284\":2,\"1308\":1}}],[\"方法唤醒后继节点\",{\"1\":{\"1506\":1}}],[\"方法唤醒\",{\"1\":{\"1260\":1}}],[\"方法会利用\",{\"1\":{\"1504\":1}}],[\"方法会对\",{\"1\":{\"1392\":1}}],[\"方法会将指定的字段加上输入的值\",{\"1\":{\"1388\":1}}],[\"方法会将正在执行的任务继续执行完\",{\"1\":{\"1360\":1}}],[\"方法会释放占有的对象锁\",{\"1\":{\"1338\":1}}],[\"方法会有线程安全的问题\",{\"1\":{\"1309\":1}}],[\"方法会增加\",{\"1\":{\"1259\":1}}],[\"方法会加载\",{\"1\":{\"1151\":1}}],[\"方法使得线程阻塞\",{\"1\":{\"1506\":1}}],[\"方法使得当前线程阻塞\",{\"1\":{\"1505\":1}}],[\"方法使得当前线程进入等待状态\",{\"1\":{\"1251\":1}}],[\"方法使其具有可延时执行和可周期性执行任务的特性\",{\"1\":{\"1371\":1}}],[\"方法使线程转换到\",{\"1\":{\"1334\":1}}],[\"方法使该线程进入等待状态同时释放锁\",{\"1\":{\"1254\":1}}],[\"方法上\",{\"1\":{\"1252\":1}}],[\"方法也主要做了两件事情\",{\"1\":{\"1348\":1}}],[\"方法也主要做了两步\",{\"1\":{\"1348\":1}}],[\"方法也是基于该节点\",{\"1\":{\"1252\":1}}],[\"方法也相同\",{\"1\":{\"1075\":1}}],[\"方法首先会检测当前线程是否已经获取\",{\"1\":{\"1252\":1}}],[\"方法抛被中断的异常\",{\"1\":{\"1251\":1}}],[\"方法抛出\",{\"1\":{\"1045\":1}}],[\"方法如出一辙\",{\"1\":{\"1251\":1}}],[\"方法示意图如下图\",{\"1\":{\"1251\":1}}],[\"方法当前节点移动到了同步队列后\",{\"1\":{\"1251\":1}}],[\"方法第一个前提条件自然而然的是要先退出这个\",{\"1\":{\"1251\":1}}],[\"方法有这样一段逻辑\",{\"1\":{\"1251\":1}}],[\"方法释放锁\",{\"1\":{\"1492\":1}}],[\"方法释放锁将当前线程加入到等待队列中\",{\"1\":{\"1250\":1}}],[\"方法释放\",{\"1\":{\"1251\":1}}],[\"方法退出之后没有再次对\",{\"1\":{\"1407\":1}}],[\"方法退出\",{\"1\":{\"1251\":2,\"1407\":1}}],[\"方法后会对状态变量进行更新\",{\"1\":{\"1406\":1}}],[\"方法后会使得当前获取\",{\"1\":{\"1251\":1}}],[\"方法后\",{\"1\":{\"1251\":1,\"1394\":1,\"1407\":1}}],[\"方法后线程依次尾插入到等待队列中\",{\"1\":{\"1250\":1}}],[\"方法返回一个\",{\"1\":{\"1376\":1}}],[\"方法返回的话一定是该线程获取了与\",{\"1\":{\"1251\":1}}],[\"方法返回\",{\"1\":{\"1248\":1,\"1251\":1,\"1410\":1,\"1505\":1}}],[\"方法返回null时\",{\"1\":{\"1076\":1}}],[\"方法和类\",{\"1\":{\"1462\":1}}],[\"方法和\",{\"1\":{\"1242\":1,\"1258\":1,\"1283\":1,\"1326\":1,\"1350\":1,\"1371\":1,\"1375\":3,\"1404\":1,\"1505\":1}}],[\"方法的开始\",{\"1\":{\"1421\":1}}],[\"方法的调用先行于被中断线程的代码检测到中断时间的发生\",{\"1\":{\"1421\":1}}],[\"方法的工作方式相同\",{\"1\":{\"1404\":1}}],[\"方法的同步点的时候\",{\"1\":{\"1399\":1}}],[\"方法的实际上也是先转换成\",{\"1\":{\"1385\":1}}],[\"方法的实现\",{\"1\":{\"1292\":1,\"1350\":1}}],[\"方法的主要逻辑请看注释\",{\"1\":{\"1370\":1}}],[\"方法的主要逻辑请见于注释\",{\"1\":{\"1352\":1}}],[\"方法的执行流程如下图所示\",{\"1\":{\"1505\":1}}],[\"方法的执行的时机\",{\"1\":{\"1375\":1}}],[\"方法的执行示意图\",{\"1\":{\"1359\":1}}],[\"方法的执行过程后\",{\"1\":{\"1283\":1}}],[\"方法的使用\",{\"1\":{\"1337\":1}}],[\"方法的功能是一样的\",{\"1\":{\"1326\":1}}],[\"方法的功能实现则是靠\",{\"1\":{\"1259\":1}}],[\"方法的关键部分请看上面的注释\",{\"1\":{\"1306\":1}}],[\"方法的逻辑也同样很容易理解\",{\"1\":{\"1351\":1}}],[\"方法的逻辑也比较容易理解\",{\"1\":{\"1294\":1}}],[\"方法的逻辑同样也很简单\",{\"1\":{\"1347\":1}}],[\"方法的逻辑\",{\"1\":{\"1302\":1}}],[\"方法的逻辑很清晰\",{\"1\":{\"1301\":1}}],[\"方法的逻辑就基本说的差不多了\",{\"1\":{\"1272\":1}}],[\"方法的分析\",{\"1\":{\"1286\":1}}],[\"方法的分别是指向\",{\"1\":{\"1284\":1}}],[\"方法的第\",{\"1\":{\"1285\":1}}],[\"方法的源码如下\",{\"1\":{\"1352\":1}}],[\"方法的源码\",{\"1\":{\"1284\":1}}],[\"方法的源码为\",{\"1\":{\"1284\":1,\"1293\":1,\"1294\":1,\"1306\":1}}],[\"方法的\",{\"1\":{\"1284\":1,\"1306\":1}}],[\"方法的时候\",{\"1\":{\"1317\":1}}],[\"方法的时候我们还留下了一个问题\",{\"1\":{\"1285\":1}}],[\"方法的时候像\",{\"1\":{\"1275\":1}}],[\"方法的时间复杂度为\",{\"1\":{\"687\":1}}],[\"方法的代码量有点长\",{\"1\":{\"1272\":1}}],[\"方法的每一个线程\",{\"1\":{\"1252\":1}}],[\"方法的区别体现在\",{\"1\":{\"1252\":1}}],[\"方法的线程能够从\",{\"1\":{\"1404\":1}}],[\"方法的线程从等待队列移入到同步队列中\",{\"1\":{\"1404\":1}}],[\"方法的线程继续执行\",{\"1\":{\"1392\":1}}],[\"方法的线程\",{\"1\":{\"1330\":1,\"1392\":1}}],[\"方法的线程成功退出\",{\"1\":{\"1252\":1}}],[\"方法的线程必须是已经获得了\",{\"1\":{\"1251\":1}}],[\"方法的线程会加入到等待队列中\",{\"1\":{\"1250\":1}}],[\"方法的理解加深\",{\"1\":{\"1251\":1}}],[\"方法的前提条件\",{\"1\":{\"1251\":1}}],[\"方法的注释为独占式锁获取的次数即写锁被获取的次数\",{\"1\":{\"1239\":1}}],[\"方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断\",{\"1\":{\"1233\":1}}],[\"方法初始化了\",{\"1\":{\"1177\":1}}],[\"方法方法看起\",{\"1\":{\"1175\":1}}],[\"方法时出现报错\",{\"1\":{\"1469\":1}}],[\"方法时就会对计数器的值减一\",{\"1\":{\"1392\":1}}],[\"方法时实际具体实现是\",{\"1\":{\"1272\":1}}],[\"方法时\",{\"1\":{\"1151\":1,\"1251\":1,\"1317\":1,\"1368\":1,\"1392\":1,\"1404\":1,\"1407\":1}}],[\"方法就不是被\",{\"1\":{\"1469\":1}}],[\"方法就是\",{\"1\":{\"1469\":1}}],[\"方法就是将这些属性放到一个\",{\"1\":{\"1149\":1}}],[\"方法就无法再获取到相应的通知\",{\"1\":{\"1406\":1}}],[\"方法就会将\",{\"1\":{\"1305\":1}}],[\"方法就很容易了\",{\"1\":{\"1273\":1}}],[\"方法就像一个开关控制着线程\",{\"1\":{\"1253\":1}}],[\"方法就可以实现这种机制\",{\"1\":{\"1253\":1}}],[\"方法就可以获取到配置文件中的配置项了\",{\"1\":{\"1150\":1}}],[\"方法创建多个\",{\"1\":{\"1250\":1}}],[\"方法创建了一个\",{\"1\":{\"1147\":1}}],[\"方法创建一个类的实例\",{\"1\":{\"1045\":1}}],[\"方法中都会通过\",{\"1\":{\"1392\":1}}],[\"方法中都会先通过\",{\"1\":{\"1392\":1}}],[\"方法中都有相应的处理\",{\"1\":{\"1314\":1}}],[\"方法中会调用\",{\"1\":{\"1370\":1}}],[\"方法中会先\",{\"1\":{\"1368\":1}}],[\"方法中是一个\",{\"1\":{\"1340\":1}}],[\"方法中调用\",{\"1\":{\"1315\":1}}],[\"方法中可以看出当\",{\"1\":{\"1306\":1}}],[\"方法中第\",{\"1\":{\"1285\":1}}],[\"方法中部分线程\",{\"0\":{\"1285\":1}}],[\"方法中考虑\",{\"1\":{\"1283\":1}}],[\"方法中退出执行后续操作\",{\"1\":{\"1253\":1}}],[\"方法中返回\",{\"1\":{\"1252\":1,\"1259\":1}}],[\"方法中的\",{\"1\":{\"1252\":1,\"1284\":1}}],[\"方法中\",{\"1\":{\"1146\":1,\"1150\":1,\"1314\":1,\"1370\":1,\"1505\":1}}],[\"方法来实现线程间的通信\",{\"1\":{\"1404\":1}}],[\"方法来实现的\",{\"1\":{\"1399\":1}}],[\"方法来指定元素排序规则\",{\"1\":{\"1326\":1}}],[\"方法来总结一下\",{\"1\":{\"1302\":1}}],[\"方法来表达自己的同步语义\",{\"1\":{\"1232\":1}}],[\"方法来初始化\",{\"1\":{\"1165\":1}}],[\"方法来获取异步任务的结果\",{\"1\":{\"1375\":1}}],[\"方法来获取\",{\"1\":{\"1164\":1}}],[\"方法来获取配置信息\",{\"1\":{\"1153\":1}}],[\"方法来访问和设置对象的属性\",{\"1\":{\"1133\":1}}],[\"方法来拼接\",{\"1\":{\"1068\":1}}],[\"方法注入\",{\"1\":{\"1133\":1}}],[\"方法克隆对象\",{\"1\":{\"1045\":1}}],[\"方法即可\",{\"1\":{\"526\":1}}],[\"方法调用得以继续\",{\"1\":{\"465\":1}}],[\"方法级别\",{\"1\":{\"465\":1}}],[\"方法接收前端获取路由信息请求\",{\"1\":{\"461\":1}}],[\"方法接收前端获取用户信息请求\",{\"1\":{\"455\":1}}],[\"方法接收前端登录请求\",{\"1\":{\"450\":1}}],[\"方法\",{\"0\":{\"1271\":1,\"1272\":1,\"1273\":1,\"1274\":1,\"1283\":1,\"1284\":1,\"1301\":1,\"1302\":1,\"1303\":1,\"1306\":1,\"1307\":1,\"1308\":1,\"1468\":1},\"1\":{\"390\":1,\"448\":3,\"453\":2,\"459\":2,\"466\":1,\"525\":1,\"1046\":1,\"1051\":1,\"1133\":1,\"1146\":1,\"1148\":1,\"1149\":1,\"1150\":2,\"1151\":3,\"1158\":1,\"1164\":1,\"1184\":1,\"1233\":1,\"1239\":1,\"1240\":1,\"1242\":2,\"1248\":3,\"1251\":2,\"1252\":1,\"1253\":1,\"1258\":2,\"1259\":3,\"1272\":1,\"1275\":4,\"1283\":1,\"1301\":2,\"1302\":1,\"1306\":2,\"1316\":3,\"1317\":2,\"1319\":1,\"1320\":1,\"1329\":1,\"1330\":4,\"1331\":1,\"1333\":1,\"1339\":1,\"1340\":1,\"1368\":4,\"1370\":3,\"1371\":3,\"1375\":4,\"1376\":1,\"1385\":2,\"1387\":1,\"1392\":1,\"1394\":1,\"1399\":2,\"1404\":2,\"1406\":3,\"1407\":2,\"1408\":2,\"1410\":2,\"1455\":2,\"1456\":2,\"1469\":1,\"1472\":3,\"1475\":3,\"1476\":3,\"1478\":1,\"1495\":2,\"1503\":3,\"1504\":4,\"1505\":3,\"1506\":2,\"1507\":2,\"1510\":2,\"1511\":1}}],[\"方法数目\",{\"1\":{\"72\":1}}],[\"方便进行问题排查\",{\"1\":{\"1259\":3}}],[\"方便进行业务拆分\",{\"1\":{\"1218\":1}}],[\"方便复用\",{\"1\":{\"1107\":1}}],[\"方便使用和管理数据\",{\"1\":{\"1094\":1}}],[\"方便求每一个元素下一个更大的元素的下标\",{\"1\":{\"174\":1}}],[\"方便\",{\"1\":{\"56\":1}}],[\"方便统一和准入平台\",{\"1\":{\"51\":1}}],[\"你真的了解\",{\"0\":{\"1461\":1}}],[\"你现在的值都是旧的了\",{\"1\":{\"1456\":1}}],[\"你妈喊你回家吃饭了\",{\"1\":{\"1416\":1}}],[\"你才能继续去收银台付款\",{\"1\":{\"1223\":1}}],[\"你得等仓库人员跟你调货\",{\"1\":{\"1223\":1}}],[\"你这个学期必须选修\",{\"1\":{\"874\":1}}],[\"你只可以看到在滑动窗口内的\",{\"1\":{\"856\":1}}],[\"你只需要输出它对\",{\"1\":{\"196\":1}}],[\"你只需考虑业务逻辑如何实现即可\",{\"1\":{\"129\":1}}],[\"你面前房子的索引就是状态\",{\"1\":{\"827\":1}}],[\"你是个什么东西\",{\"1\":{\"1131\":1}}],[\"你是一个专业的小偷\",{\"1\":{\"826\":1}}],[\"你是谁\",{\"1\":{\"445\":1}}],[\"你将如何优化算法\",{\"1\":{\"711\":1}}],[\"你将会获得一些配置参数和\",{\"1\":{\"662\":1}}],[\"你必须在不修改节点内部的值的情况下完成本题\",{\"1\":{\"692\":1}}],[\"你不能只是单纯的改变节点内部的值\",{\"1\":{\"680\":1}}],[\"你每次使用代理客户端时\",{\"1\":{\"664\":1}}],[\"你可能会用到的一些插件\",{\"1\":{\"658\":1}}],[\"你可以要林志玲款式的\",{\"1\":{\"1133\":1}}],[\"你可以继续执行其他命令\",{\"1\":{\"1087\":1}}],[\"你可以认为每种硬币的数量是无限的\",{\"1\":{\"892\":1}}],[\"你可以假设该网格的四条边均被水包围\",{\"1\":{\"819\":1}}],[\"你可以假设除了数字\",{\"1\":{\"698\":1}}],[\"你可以使用原地算法\",{\"1\":{\"723\":1}}],[\"你可以选择一个与他相临的格子到达\",{\"1\":{\"196\":1}}],[\"你可以进行至多\",{\"1\":{\"156\":1}}],[\"你可以同时购买其中若干子集\",{\"1\":{\"109\":1}}],[\"你可以获得\",{\"1\":{\"109\":1}}],[\"你可以向左或者向右移动一个位置\",{\"1\":{\"72\":1}}],[\"你有没有备胎\",{\"1\":{\"363\":1}}],[\"你有一张某海域\",{\"1\":{\"280\":1}}],[\"你就没得抢了\",{\"1\":{\"827\":1}}],[\"你就去问问她男朋友\",{\"1\":{\"363\":1}}],[\"你就能够获得一个随机的优惠券\",{\"1\":{\"109\":1}}],[\"你能将算法的时间复杂度降低到\",{\"1\":{\"850\":1}}],[\"你能求出数列中总共有多少个\",{\"1\":{\"261\":1}}],[\"你能告诉牛牛每个人买走的商品编号吗\",{\"1\":{\"168\":1}}],[\"你的终端或\",{\"1\":{\"1087\":1}}],[\"你的代码\",{\"1\":{\"886\":1}}],[\"你的程序将得到一个判断错误的答案\",{\"1\":{\"249\":1}}],[\"你的任务是\",{\"1\":{\"152\":1}}],[\"你在网上付款下单后\",{\"1\":{\"1223\":1}}],[\"你在玩一个横版游戏\",{\"1\":{\"110\":1}}],[\"你在这条街里询问每一个房子询问\",{\"1\":{\"108\":1}}],[\"你需要什么东西\",{\"1\":{\"1131\":1}}],[\"你需要先完成课程\",{\"1\":{\"874\":1}}],[\"你需要完成合并和查询操作\",{\"1\":{\"274\":1}}],[\"你需要按照从小到大的顺序依次输出\",{\"1\":{\"168\":1}}],[\"你需要设计一个广告信息回传系统\",{\"1\":{\"151\":1}}],[\"你需要购买这里的所有商品且每个只买一份\",{\"1\":{\"109\":1}}],[\"你需要寻找这里的有且仅有一个的网吧\",{\"1\":{\"108\":1}}],[\"你喜欢的一个商店开始了促销活动\",{\"1\":{\"109\":1}}],[\"你站在\",{\"1\":{\"72\":1}}],[\"处于中间层\",{\"1\":{\"1423\":1}}],[\"处于已完成状态时\",{\"1\":{\"1375\":1}}],[\"处于已完成状态\",{\"1\":{\"1375\":1}}],[\"处于已启动状态时\",{\"1\":{\"1375\":1}}],[\"处于已启动状态\",{\"1\":{\"1375\":1}}],[\"处于未启动或已启动状态时\",{\"1\":{\"1375\":1}}],[\"处于未启动状态时\",{\"1\":{\"1375\":1}}],[\"处于未启动状态\",{\"1\":{\"1375\":2}}],[\"处插入新\",{\"1\":{\"1317\":1}}],[\"处即可\",{\"1\":{\"1317\":2}}],[\"处执行\",{\"1\":{\"1284\":1}}],[\"处的\",{\"1\":{\"1316\":1}}],[\"处的结果即可\",{\"1\":{\"796\":1}}],[\"处的数字为\",{\"1\":{\"278\":1}}],[\"处和\",{\"1\":{\"278\":1}}],[\"处\",{\"1\":{\"72\":1,\"278\":2,\"1252\":1,\"1272\":1,\"1316\":1,\"1317\":3,\"1393\":1}}],[\"处理当前同步队列尾节点为\",{\"1\":{\"1504\":1}}],[\"处理当前节点是treebin时的情况\",{\"1\":{\"1274\":1}}],[\"处理当前节点为链表的头结点的情况\",{\"1\":{\"1274\":1}}],[\"处理为例\",{\"1\":{\"1477\":1}}],[\"处理器中\",{\"1\":{\"1477\":1}}],[\"处理器会在读\",{\"1\":{\"1475\":1}}],[\"处理器和编译为了性能优化会对指令序列有编译器和处理器重排序\",{\"1\":{\"1473\":1}}],[\"处理器不直接和内存进行通信\",{\"1\":{\"1454\":1}}],[\"处理器可以改变语句对应机器指令的执行顺序\",{\"1\":{\"1418\":1}}],[\"处理rehash的情况\",{\"1\":{\"1316\":1}}],[\"处理被中断的情况\",{\"1\":{\"1251\":1}}],[\"处理在第二步中cas操作失败的自旋已经实现重入性\",{\"1\":{\"1242\":1}}],[\"处理所有的拷贝操作到其他节点\",{\"1\":{\"1160\":1}}],[\"处理注册相关的流程\",{\"0\":{\"1159\":1}}],[\"处理冲突\",{\"1\":{\"971\":1}}],[\"处理进位情况\",{\"1\":{\"700\":1}}],[\"处理字段不一致的问题\",{\"1\":{\"518\":1,\"519\":1}}],[\"处理查询\",{\"1\":{\"458\":1}}],[\"处理登录逻辑\",{\"1\":{\"447\":1}}],[\"处理数仓内的热数据与数据湖中的历史数据\",{\"1\":{\"438\":1}}],[\"处理\",{\"1\":{\"434\":1,\"532\":1,\"568\":1}}],[\"处理剩余的1或2次操作\",{\"1\":{\"167\":1}}],[\"处理流程设计\",{\"1\":{\"151\":1}}],[\"处理模式\",{\"1\":{\"127\":1}}],[\"处理模式串\",{\"1\":{\"127\":1}}],[\"处理之前的回源消息也是类似的思路\",{\"1\":{\"49\":1}}],[\"处理发评论请求是无法实现这种串行的\",{\"1\":{\"28\":1}}],[\"右表\",{\"1\":{\"945\":1}}],[\"右外连接相当于查询表2\",{\"1\":{\"945\":1}}],[\"右外连接语法结构\",{\"1\":{\"945\":1}}],[\"右外连接\",{\"1\":{\"943\":1,\"945\":1}}],[\"右对左\",{\"1\":{\"809\":1}}],[\"右指针先向右走\",{\"1\":{\"778\":1}}],[\"右子节点索引为\",{\"1\":{\"766\":1}}],[\"右子树下界\",{\"1\":{\"899\":1}}],[\"右子树范围\",{\"1\":{\"766\":1}}],[\"右子树根节点\",{\"1\":{\"766\":1}}],[\"右子树的深度\",{\"1\":{\"748\":1}}],[\"右子树\",{\"1\":{\"724\":1,\"725\":1,\"766\":5,\"767\":1}}],[\"右子字符串\",{\"1\":{\"71\":5}}],[\"右上角\",{\"1\":{\"670\":1}}],[\"右儿子相比最小的元素\",{\"1\":{\"417\":1}}],[\"右儿子是2x\",{\"1\":{\"417\":1}}],[\"右补0\",{\"1\":{\"338\":1}}],[\"右边的子节点比父节点大\",{\"1\":{\"958\":1}}],[\"右边\",{\"1\":{\"822\":1}}],[\"右边丢弃\",{\"1\":{\"338\":1}}],[\"右边补0\",{\"1\":{\"338\":1}}],[\"右边界\",{\"1\":{\"173\":1}}],[\"右半边剩下的\",{\"1\":{\"318\":1}}],[\"右移一位相当于\",{\"1\":{\"1274\":1,\"1315\":1}}],[\"右移一位表示\",{\"1\":{\"1274\":1}}],[\"右移\",{\"1\":{\"337\":1,\"338\":2,\"339\":1,\"1239\":1}}],[\"右移和\",{\"1\":{\"317\":1}}],[\"右移动一格\",{\"1\":{\"166\":1}}],[\"右端点\",{\"1\":{\"307\":1}}],[\"右任意一个方向移动一个位置\",{\"1\":{\"278\":1}}],[\"右三个方向的数字交换成功得到正确排列\",{\"1\":{\"224\":1,\"279\":1}}],[\"右四个方向之一的数字交换\",{\"1\":{\"224\":1,\"279\":1}}],[\"右孩子\",{\"1\":{\"206\":1}}],[\"右\",{\"1\":{\"71\":1,\"766\":1}}],[\"左表\",{\"1\":{\"945\":1}}],[\"左外连接和右外连接是可以相互替换的\",{\"1\":{\"945\":1}}],[\"左外连接相当于查询表1\",{\"1\":{\"945\":1}}],[\"左外连接语法结构\",{\"1\":{\"945\":1}}],[\"左外连接\",{\"1\":{\"943\":1,\"945\":1}}],[\"左儿子就不会继续往下递归了\",{\"1\":{\"899\":1}}],[\"左边的子节点比父节点小\",{\"1\":{\"958\":1}}],[\"左边的二进制位丢弃\",{\"1\":{\"338\":1}}],[\"左边\",{\"1\":{\"822\":1}}],[\"左对右\",{\"1\":{\"809\":1}}],[\"左指针的下一个节点就是倒数第\",{\"1\":{\"778\":1}}],[\"左指针为\",{\"1\":{\"725\":1}}],[\"左右\",{\"1\":{\"958\":1,\"1295\":1}}],[\"左右指针一起走\",{\"1\":{\"778\":1}}],[\"左右子树返回信息只需要节点数\",{\"1\":{\"713\":1}}],[\"左子树根节点\",{\"1\":{\"766\":1}}],[\"左子树的深度\",{\"1\":{\"748\":1}}],[\"左子树最后一个节点访问完后\",{\"1\":{\"724\":1}}],[\"左子树\",{\"1\":{\"724\":1,\"766\":4,\"767\":1}}],[\"左子字符串\",{\"1\":{\"71\":5}}],[\"左补\",{\"1\":{\"338\":2}}],[\"左半边剩下的\",{\"1\":{\"318\":1}}],[\"左半边的子集\",{\"1\":{\"296\":1}}],[\"左移2位\",{\"1\":{\"338\":1}}],[\"左移\",{\"1\":{\"317\":1,\"337\":1,\"338\":2,\"1239\":1}}],[\"左闭右开\",{\"1\":{\"254\":1}}],[\"左孩子\",{\"1\":{\"206\":1}}],[\"左括号必须以正确的顺序闭合\",{\"1\":{\"93\":1}}],[\"左括号必须用相同类型的右括号闭合\",{\"1\":{\"93\":1}}],[\"左\",{\"1\":{\"71\":1,\"166\":1,\"224\":1,\"278\":1,\"279\":1}}],[\"子类被推荐定义为自定义同步组件的静态内部类\",{\"1\":{\"1494\":1}}],[\"子类继承往往可以重写父类的方法和改变父类属性\",{\"1\":{\"1471\":1}}],[\"子类不能重写父类的该方法\",{\"1\":{\"1469\":1}}],[\"子类会继承父类的注解\",{\"1\":{\"1053\":1}}],[\"子进程可以访问的变量\",{\"1\":{\"1116\":1}}],[\"子进程不能访问的变量\",{\"1\":{\"1116\":1}}],[\"子查询返回的结果是多行多列\",{\"1\":{\"951\":1}}],[\"子查询返回的结果是一行\",{\"1\":{\"950\":1}}],[\"子查询返回的结果是一列\",{\"1\":{\"949\":1}}],[\"子查询返回的结果是单个值\",{\"1\":{\"948\":1}}],[\"子查询可以书写的位置\",{\"1\":{\"947\":1}}],[\"子查询结果为多行多列\",{\"1\":{\"947\":1}}],[\"子查询结果为一行\",{\"1\":{\"947\":1}}],[\"子查询结果为一列\",{\"1\":{\"947\":1}}],[\"子查询结果为单个值\",{\"1\":{\"947\":1}}],[\"子查询外部的语句可以是\",{\"1\":{\"947\":1}}],[\"子查询\",{\"0\":{\"946\":1},\"1\":{\"943\":1}}],[\"子问题\",{\"1\":{\"851\":1}}],[\"子问题合并\",{\"1\":{\"317\":2}}],[\"子序列\",{\"1\":{\"850\":1}}],[\"子序列是由数组派生而来的序列\",{\"1\":{\"850\":1}}],[\"子串\",{\"1\":{\"844\":1}}],[\"子串长度\",{\"1\":{\"422\":1}}],[\"子树的节点数量\",{\"1\":{\"766\":1}}],[\"子指针指向链表中下一个结点\",{\"1\":{\"723\":1}}],[\"子数组\",{\"1\":{\"704\":3}}],[\"子公司的经理可能需要有更广阔的视野\",{\"1\":{\"470\":1}}],[\"子节点列表\",{\"1\":{\"803\":1}}],[\"子节点不能选\",{\"1\":{\"314\":1}}],[\"子节点依附在根节点上\",{\"1\":{\"273\":1}}],[\"子字符串和\",{\"1\":{\"71\":1}}],[\"子字符串\",{\"1\":{\"71\":2}}],[\"子评论之间也可以互相评论\",{\"1\":{\"56\":1}}],[\"子评论数等\",{\"1\":{\"30\":1}}],[\"给对象补充一些信息\",{\"1\":{\"598\":1}}],[\"给\",{\"1\":{\"523\":1}}],[\"给字段传入不同的值\",{\"1\":{\"523\":1}}],[\"给以\",{\"1\":{\"335\":1}}],[\"给区间\",{\"1\":{\"334\":1}}],[\"给出答案\",{\"1\":{\"1458\":1}}],[\"给出了很详细的各个方面的知识\",{\"1\":{\"1313\":1}}],[\"给出了一些亲戚关系\",{\"1\":{\"273\":1}}],[\"给出\",{\"1\":{\"874\":1}}],[\"给出一串数以及一个数字\",{\"1\":{\"324\":1}}],[\"给父亲更新\",{\"1\":{\"314\":1}}],[\"给定map大小\",{\"1\":{\"1270\":1}}],[\"给定map的大小以及加载因子\",{\"1\":{\"1270\":1}}],[\"给定map的大小\",{\"1\":{\"1270\":1}}],[\"给定n堆物品\",{\"1\":{\"394\":1}}],[\"给定n个0和n个1\",{\"1\":{\"391\":1}}],[\"给定两个非负整数\",{\"1\":{\"329\":1,\"330\":1}}],[\"给定两个正整数\",{\"1\":{\"327\":1,\"328\":1,\"387\":1}}],[\"给定两个整数数组\",{\"1\":{\"765\":1}}],[\"给定两个整数\",{\"1\":{\"309\":1}}],[\"给定两个字符串\",{\"1\":{\"306\":1,\"838\":1}}],[\"给定两个长度分别为\",{\"1\":{\"303\":1}}],[\"给定一张\",{\"1\":{\"223\":1,\"312\":1}}],[\"给定一个map\",{\"1\":{\"1270\":1}}],[\"给定一个代表每个房屋存放金额的非负整数数组\",{\"1\":{\"826\":1}}],[\"给定一个二叉搜索树的根节点\",{\"1\":{\"709\":1}}],[\"给定一个二叉树的\",{\"1\":{\"735\":1}}],[\"给定一个二叉树的根节点\",{\"1\":{\"729\":1,\"880\":1}}],[\"给定一个二叉树\",{\"1\":{\"133\":1,\"747\":1,\"753\":1}}],[\"给定一个序列\",{\"1\":{\"407\":1}}],[\"给定一个有向无环图\",{\"1\":{\"396\":1}}],[\"给定一个包含\",{\"1\":{\"385\":1}}],[\"给定一个如下图所示的数字三角形\",{\"1\":{\"301\":1}}],[\"给定一个整数\",{\"1\":{\"281\":1,\"392\":1}}],[\"给定一个\",{\"1\":{\"278\":1}}],[\"给定一个数字\",{\"1\":{\"135\":1}}],[\"给定一个数列\",{\"1\":{\"128\":1}}],[\"给定一个节点数为\",{\"1\":{\"134\":1}}],[\"给定一个正整数\",{\"1\":{\"126\":1}}],[\"给定一个长度为\",{\"1\":{\"120\":1,\"178\":1,\"261\":1,\"262\":1,\"339\":1}}],[\"给定一个只包括\",{\"1\":{\"93\":1}}],[\"给定一个小为\",{\"1\":{\"77\":1}}],[\"给定整数\",{\"1\":{\"182\":1,\"372\":1}}],[\"给定四个正整数\",{\"1\":{\"156\":1}}],[\"给定\",{\"1\":{\"142\":1,\"305\":1,\"384\":1,\"389\":1,\"427\":1,\"429\":1,\"430\":1}}],[\"给定存在\",{\"1\":{\"140\":1}}],[\"给定的二叉树是\",{\"1\":{\"133\":1}}],[\"给你链表的头结点\",{\"1\":{\"832\":1}}],[\"给你链表的头节点\",{\"1\":{\"680\":1}}],[\"给你一棵二叉树的根节点\",{\"1\":{\"759\":1,\"862\":1}}],[\"给你一个只包含\",{\"1\":{\"844\":1}}],[\"给你一个由\",{\"1\":{\"819\":1}}],[\"给你一个由若干\",{\"1\":{\"71\":1}}],[\"给你一个字符串\",{\"1\":{\"782\":1}}],[\"给你一个\",{\"1\":{\"771\":1}}],[\"给你一个二叉树的根节点\",{\"1\":{\"717\":1,\"807\":1,\"898\":1}}],[\"给你一个链表数组\",{\"1\":{\"788\":1}}],[\"给你一个链表\",{\"1\":{\"692\":1,\"776\":1}}],[\"给你一个初始网格\",{\"1\":{\"224\":1,\"279\":1}}],[\"给你一个长度为\",{\"1\":{\"199\":1,\"886\":1}}],[\"给你一个整数数组\",{\"1\":{\"704\":1,\"813\":1,\"850\":1,\"856\":1,\"892\":1}}],[\"给你一个整数\",{\"1\":{\"76\":1,\"794\":1}}],[\"给你一个正整数\",{\"1\":{\"72\":1}}],[\"给你二叉树的根节点\",{\"1\":{\"741\":1}}],[\"给你二叉树的根结点\",{\"1\":{\"723\":1}}],[\"给你\",{\"1\":{\"202\":1}}],[\"给你两个\",{\"1\":{\"698\":1}}],[\"给你两个正整数\",{\"1\":{\"72\":1}}],[\"给你两棵二叉树\",{\"1\":{\"186\":1}}],[\"给这个列表记录一个长度\",{\"1\":{\"37\":1}}],[\"9正在消费数据\",{\"1\":{\"1411\":1}}],[\"9正在消费数据1994678907\",{\"1\":{\"1411\":1}}],[\"919544017\",{\"1\":{\"1411\":2}}],[\"9e0ebfcd82d7\",{\"1\":{\"1107\":5,\"1116\":5,\"1119\":2}}],[\"9<\",{\"1\":{\"1099\":1}}],[\"9是\",{\"1\":{\"1004\":1}}],[\"9000\",{\"1\":{\"1088\":2,\"1089\":1,\"1100\":1}}],[\"9001\",{\"1\":{\"1087\":3,\"1088\":3,\"1089\":1}}],[\"90\",{\"1\":{\"1004\":1}}],[\"967\",{\"1\":{\"920\":2}}],[\"94\",{\"1\":{\"728\":1}}],[\"994\",{\"1\":{\"867\":1}}],[\"99\",{\"1\":{\"309\":3}}],[\"99999999\",{\"1\":{\"237\":2}}],[\"9999\",{\"1\":{\"236\":2,\"920\":2}}],[\"999\",{\"1\":{\"41\":1}}],[\"9​\",{\"1\":{\"291\":1}}],[\"987\",{\"1\":{\"699\":2}}],[\"98\",{\"1\":{\"109\":1,\"897\":1}}],[\"9−8−76+5+43\",{\"1\":{\"83\":1}}],[\"9\",{\"0\":{\"250\":1,\"342\":1,\"392\":1,\"422\":1,\"631\":1,\"641\":1,\"1042\":1,\"1043\":1,\"1044\":1,\"1045\":1,\"1046\":1,\"1047\":1,\"1048\":1,\"1049\":1},\"1\":{\"70\":2,\"99\":4,\"115\":1,\"122\":2,\"133\":2,\"139\":2,\"140\":1,\"146\":1,\"167\":1,\"179\":1,\"180\":2,\"182\":1,\"193\":1,\"196\":1,\"273\":2,\"279\":1,\"280\":1,\"291\":5,\"309\":19,\"484\":1,\"794\":1,\"795\":1,\"990\":1,\"1000\":1,\"1001\":1,\"1206\":1,\"1209\":1,\"1283\":2,\"1284\":1,\"1398\":5,\"1410\":10}}],[\"题库不存在\",{\"1\":{\"526\":1}}],[\"题库和题目必须存在\",{\"1\":{\"526\":1}}],[\"题库id\",{\"1\":{\"526\":1}}],[\"题库里的题目列表\",{\"1\":{\"523\":1}}],[\"题库题目\",{\"1\":{\"513\":1}}],[\"题库题目表\",{\"1\":{\"513\":1}}],[\"题库题目关联表\",{\"0\":{\"513\":1}}],[\"题库\",{\"1\":{\"511\":1,\"513\":1,\"525\":2,\"526\":2}}],[\"题库表的核心是题库信息\",{\"1\":{\"511\":1}}],[\"题库表\",{\"0\":{\"511\":1},\"1\":{\"511\":1}}],[\"题库模块\",{\"0\":{\"522\":1},\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"题是比较简单的一道模板题\",{\"1\":{\"274\":1}}],[\"题目如果让你克隆带随机指针的二叉树\",{\"1\":{\"887\":1}}],[\"题目要求时间空间复杂度分别为\",{\"1\":{\"833\":1}}],[\"题目不存在\",{\"1\":{\"526\":1}}],[\"题目id\",{\"1\":{\"526\":1}}],[\"题目已加入该题库\",{\"1\":{\"526\":1}}],[\"题目未加入该题库\",{\"1\":{\"526\":1}}],[\"题目内容\",{\"1\":{\"512\":1}}],[\"题目可能有多个标签\",{\"1\":{\"512\":1}}],[\"题目标题\",{\"1\":{\"512\":1}}],[\"题目\",{\"1\":{\"512\":1,\"513\":1,\"515\":1,\"526\":2}}],[\"题目表查询条件\",{\"1\":{\"525\":1}}],[\"题目表的核心是题目信息\",{\"1\":{\"512\":1}}],[\"题目表\",{\"0\":{\"512\":1},\"1\":{\"512\":1}}],[\"题目批量管理\",{\"1\":{\"497\":1,\"508\":1}}],[\"题目搜索\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"题目模块中获取题目列表\",{\"1\":{\"523\":1}}],[\"题目模块\",{\"0\":{\"524\":1},\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"题目和题解\",{\"1\":{\"493\":1}}],[\"题目意思是说\",{\"1\":{\"291\":1}}],[\"题目描述\",{\"1\":{\"261\":1,\"262\":1,\"263\":1,\"274\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"324\":1}}],[\"题目确保\",{\"1\":{\"70\":1}}],[\"题中\",{\"1\":{\"236\":1,\"237\":1}}],[\"题中所给数据大多都是字符\",{\"1\":{\"228\":1}}],[\"题解\",{\"0\":{\"194\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1}}],[\"题意\",{\"0\":{\"186\":1,\"680\":1,\"686\":1,\"692\":1,\"698\":1,\"704\":1,\"709\":1,\"717\":1,\"723\":1,\"729\":1,\"735\":1,\"741\":1,\"747\":1,\"753\":1,\"759\":1,\"765\":1,\"771\":1,\"776\":1,\"782\":1,\"788\":1,\"794\":1,\"801\":1,\"807\":1,\"813\":1,\"819\":1,\"826\":1,\"832\":1,\"838\":1,\"844\":1,\"850\":1,\"856\":1,\"862\":1,\"868\":1,\"874\":1,\"880\":1,\"886\":1,\"892\":1,\"898\":1}}],[\"题面\",{\"1\":{\"65\":1,\"66\":1,\"70\":1,\"71\":1,\"72\":1,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"92\":1,\"93\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"108\":1,\"109\":1,\"110\":1,\"114\":1,\"115\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"133\":1,\"134\":1,\"135\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"152\":1,\"156\":1,\"157\":1,\"161\":1,\"162\":1,\"166\":1,\"167\":1,\"168\":1,\"172\":1,\"173\":1,\"174\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1}}],[\"请自行查阅\",{\"1\":{\"1306\":1}}],[\"请不要使用\",{\"1\":{\"1295\":1}}],[\"请看上面的注释\",{\"1\":{\"1294\":1}}],[\"请持续关注\",{\"1\":{\"1182\":1}}],[\"请构造二叉树并返回其根节点\",{\"1\":{\"765\":1}}],[\"请将其按\",{\"1\":{\"832\":1}}],[\"请将下一行注释符删除\",{\"1\":{\"672\":1}}],[\"请将两个数组合并成一个新的有序数组\",{\"1\":{\"92\":1}}],[\"请确认密码\",{\"1\":{\"587\":1}}],[\"请输入密码\",{\"1\":{\"587\":1}}],[\"请输入账号\",{\"1\":{\"587\":1}}],[\"请重试\",{\"1\":{\"587\":1,\"589\":1}}],[\"请写一个程序\",{\"1\":{\"273\":1}}],[\"请打印\",{\"1\":{\"249\":2}}],[\"请求的\",{\"1\":{\"1184\":1}}],[\"请求的方法不存在\",{\"1\":{\"1045\":1}}],[\"请求的变量不存在\",{\"1\":{\"1045\":1}}],[\"请求的数据在数据库中不存在\",{\"1\":{\"613\":1}}],[\"请求对象\",{\"1\":{\"575\":1,\"576\":1,\"578\":1,\"579\":1,\"589\":1,\"596\":2}}],[\"请求体很长时不建议用\",{\"1\":{\"573\":1}}],[\"请求体\",{\"1\":{\"573\":1}}],[\"请求类型\",{\"1\":{\"573\":1}}],[\"请求参数\",{\"1\":{\"525\":1}}],[\"请求\",{\"1\":{\"448\":1,\"1184\":3,\"1185\":1}}],[\"请求出\",{\"1\":{\"205\":1}}],[\"请求预过滤\",{\"1\":{\"34\":1}}],[\"请注意保管管理员密码\",{\"1\":{\"670\":1}}],[\"请注意\",{\"1\":{\"180\":1}}],[\"请注意选择方案\",{\"1\":{\"135\":1}}],[\"请帮小美想出最美观的摆放方案\",{\"1\":{\"147\":1}}],[\"请根据小c的速通记录计算出他的理论最佳速通时间\",{\"1\":{\"146\":1}}],[\"请选择美观度最大的种植方案\",{\"1\":{\"141\":1}}],[\"请问\",{\"1\":{\"199\":1,\"262\":1,\"278\":1}}],[\"请问最少需要多少代价才能把所有瓶子都放到\",{\"1\":{\"166\":1}}],[\"请问该预订消费金额最大是多少\",{\"1\":{\"162\":1}}],[\"请问有多少种选择方式\",{\"1\":{\"135\":1}}],[\"请问在第几轮的时候数字\",{\"1\":{\"99\":1}}],[\"请通过算法尽可能快地找出缺失的订单号\",{\"1\":{\"114\":1}}],[\"请计算从格子\",{\"1\":{\"110\":1}}],[\"请返回一个数组\",{\"1\":{\"109\":1}}],[\"请你实现\",{\"1\":{\"801\":1}}],[\"请你将其转换为一棵\",{\"1\":{\"813\":1}}],[\"请你将所有链表合并到一个升序链表中\",{\"1\":{\"788\":1}}],[\"请你将它展开为一个单链表\",{\"1\":{\"723\":1}}],[\"请你将两个数相加\",{\"1\":{\"698\":1}}],[\"请你找出数组中乘积最大的非空连续\",{\"1\":{\"704\":1}}],[\"请你找到出现次数大于等于数组长度一半的数\",{\"1\":{\"179\":1}}],[\"请你设计一个算法查找其中第\",{\"1\":{\"709\":1}}],[\"请你设计一个高效的算法来解决这个问题\",{\"1\":{\"70\":1}}],[\"请你设计并实现一个满足\",{\"1\":{\"686\":1}}],[\"请你返回修改后的链表\",{\"1\":{\"680\":1}}],[\"请你选择尽量少的区间\",{\"1\":{\"430\":1}}],[\"请你在数轴上选择尽量少的点\",{\"1\":{\"427\":1}}],[\"请你输出\",{\"1\":{\"389\":1}}],[\"请你求出数列中每个数的二进制表示中\",{\"1\":{\"339\":1}}],[\"请你求出\",{\"1\":{\"308\":1,\"392\":1}}],[\"请你求出给定的\",{\"1\":{\"305\":1}}],[\"请你求出得到正确排列至少需要进行多少次交换\",{\"1\":{\"279\":1}}],[\"请你按照字典序将所有的排列方法输出\",{\"1\":{\"281\":1}}],[\"请你通过最少的移动次数\",{\"1\":{\"224\":1}}],[\"请你回答他最后得到的数是多少\",{\"1\":{\"161\":1}}],[\"请你帮他求出\",{\"1\":{\"173\":1}}],[\"请你帮助她统计共有多少个人的名字\",{\"1\":{\"172\":1}}],[\"请你帮\",{\"1\":{\"98\":1}}],[\"请你计算网格中岛屿的数量\",{\"1\":{\"819\":1}}],[\"请你计算\",{\"1\":{\"280\":1}}],[\"请你计算出他是原来\",{\"1\":{\"202\":1}}],[\"请你计算最多能得到多少分\",{\"1\":{\"178\":1}}],[\"请你计算小紫是否会被魔法水晶箭攻击到\",{\"1\":{\"97\":1}}],[\"请你计算并返回将该字符串分割成两个\",{\"1\":{\"71\":1}}],[\"请你从中选出一个最长的子区间\",{\"1\":{\"78\":1}}],[\"请你判断是否可能完成所有课程的学习\",{\"1\":{\"874\":1}}],[\"请你判断是否可以将这个数组分割成两个子集\",{\"1\":{\"771\":1}}],[\"请你判断\",{\"1\":{\"76\":1}}],[\">3c\",{\"1\":{\"1439\":1}}],[\">a\",{\"1\":{\"1418\":1,\"1439\":1}}],[\">c\",{\"1\":{\"1418\":2}}],[\">6\",{\"1\":{\"789\":2}}],[\">4\",{\"1\":{\"789\":1}}],[\">5\",{\"1\":{\"789\":2}}],[\">2b\",{\"1\":{\"1439\":1}}],[\">2\",{\"1\":{\"789\":1}}],[\">根节点\",{\"1\":{\"725\":1}}],[\">左子树\",{\"1\":{\"725\":1}}],[\">没有账号\",{\"1\":{\"588\":1}}],[\">包含角色才能看到<\",{\"1\":{\"457\":1}}],[\">包含权限字符串才能看到<\",{\"1\":{\"457\":1}}],[\">管理员才能看到<\",{\"1\":{\"457\":1}}],[\">存在权限字符串才能看到<\",{\"1\":{\"457\":1}}],[\">1\",{\"1\":{\"368\":1}}],[\">b\",{\"1\":{\"345\":1,\"354\":1,\"1418\":1,\"1439\":1}}],[\">j\",{\"1\":{\"223\":1}}],[\">t\",{\"1\":{\"223\":3}}],[\">next\",{\"1\":{\"134\":15}}],[\">right\",{\"1\":{\"133\":2}}],[\">left\",{\"1\":{\"133\":2}}],[\">val\",{\"1\":{\"133\":1,\"134\":2}}],[\">=x\",{\"1\":{\"852\":2}}],[\">=0\",{\"1\":{\"309\":1}}],[\">=k\",{\"1\":{\"223\":1}}],[\">=\",{\"1\":{\"66\":1,\"77\":2,\"83\":1,\"97\":1,\"110\":1,\"126\":2,\"128\":1,\"162\":1,\"167\":2,\"173\":1,\"174\":4,\"179\":1,\"180\":3,\"197\":2,\"221\":2,\"224\":2,\"228\":2,\"229\":2,\"230\":2,\"235\":2,\"236\":3,\"237\":2,\"274\":2,\"278\":2,\"279\":2,\"290\":1,\"291\":2,\"296\":1,\"297\":1,\"298\":3,\"299\":3,\"301\":2,\"308\":1,\"317\":1,\"318\":1,\"321\":1,\"322\":1,\"327\":5,\"328\":12,\"329\":4,\"330\":4,\"339\":1,\"341\":1,\"356\":1,\"385\":3,\"429\":1,\"430\":1,\"687\":1,\"772\":1,\"820\":2,\"821\":2,\"827\":1,\"846\":3,\"852\":2,\"870\":2,\"893\":1,\"931\":1,\"984\":6,\"985\":4,\"999\":1,\"1270\":2,\"1272\":5,\"1274\":5,\"1275\":2,\"1306\":1,\"1314\":1,\"1510\":1}}],[\">\",{\"1\":{\"66\":1,\"70\":2,\"72\":10,\"87\":1,\"88\":1,\"92\":1,\"104\":1,\"109\":1,\"120\":2,\"121\":2,\"122\":1,\"127\":1,\"129\":2,\"133\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":2,\"147\":1,\"157\":1,\"162\":1,\"173\":1,\"174\":1,\"180\":1,\"194\":1,\"223\":1,\"224\":2,\"255\":3,\"288\":1,\"289\":1,\"298\":1,\"302\":1,\"304\":1,\"317\":2,\"325\":1,\"328\":5,\"329\":1,\"330\":2,\"345\":3,\"352\":1,\"353\":1,\"354\":3,\"355\":2,\"356\":1,\"360\":1,\"368\":1,\"376\":1,\"379\":1,\"385\":3,\"392\":1,\"406\":1,\"423\":1,\"427\":1,\"446\":1,\"463\":1,\"471\":5,\"540\":1,\"543\":1,\"548\":2,\"549\":3,\"559\":1,\"568\":2,\"576\":3,\"587\":11,\"588\":2,\"591\":1,\"592\":5,\"688\":1,\"700\":1,\"712\":1,\"737\":1,\"743\":1,\"767\":4,\"778\":1,\"789\":1,\"797\":1,\"815\":1,\"846\":1,\"869\":1,\"870\":5,\"876\":1,\"886\":2,\"887\":1,\"888\":4,\"931\":1,\"933\":2,\"984\":11,\"999\":1,\"1021\":1,\"1022\":2,\"1055\":2,\"1069\":2,\"1087\":2,\"1090\":1,\"1102\":1,\"1103\":1,\"1201\":3,\"1203\":1,\"1204\":2,\"1206\":1,\"1207\":2,\"1209\":1,\"1239\":1,\"1243\":1,\"1250\":1,\"1252\":1,\"1260\":1,\"1271\":2,\"1272\":1,\"1273\":1,\"1274\":4,\"1275\":1,\"1283\":6,\"1284\":4,\"1285\":2,\"1305\":5,\"1306\":4,\"1307\":3,\"1308\":1,\"1313\":5,\"1314\":2,\"1316\":1,\"1317\":5,\"1352\":1,\"1367\":3,\"1368\":2,\"1369\":2,\"1370\":3,\"1384\":4,\"1392\":1,\"1393\":2,\"1398\":1,\"1399\":2,\"1410\":2,\"1433\":2,\"1496\":1,\"1505\":2,\"1506\":1,\"1508\":1}}],[\">>>=\",{\"1\":{\"1315\":2}}],[\">>>\",{\"1\":{\"1239\":1,\"1270\":7,\"1271\":2,\"1272\":1,\"1274\":4,\"1275\":1}}],[\">>=\",{\"1\":{\"87\":1,\"139\":1,\"381\":1,\"388\":1,\"389\":1,\"417\":1}}],[\">>\",{\"0\":{\"253\":1},\"1\":{\"65\":3,\"66\":3,\"76\":1,\"77\":6,\"110\":4,\"119\":2,\"120\":2,\"121\":5,\"122\":4,\"139\":2,\"140\":4,\"141\":5,\"142\":3,\"146\":3,\"147\":3,\"173\":3,\"174\":5,\"194\":3,\"197\":7,\"200\":5,\"203\":4,\"206\":6,\"221\":1,\"223\":8,\"224\":1,\"228\":3,\"229\":3,\"230\":3,\"235\":3,\"236\":3,\"237\":3,\"253\":1,\"261\":3,\"262\":2,\"263\":5,\"273\":6,\"274\":5,\"278\":3,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":2,\"290\":3,\"291\":1,\"296\":4,\"297\":4,\"298\":15,\"299\":10,\"301\":2,\"302\":7,\"303\":4,\"304\":3,\"305\":5,\"306\":4,\"307\":2,\"308\":1,\"309\":2,\"311\":3,\"312\":3,\"314\":1,\"318\":1,\"321\":1,\"322\":1,\"323\":1,\"324\":3,\"327\":2,\"328\":2,\"329\":2,\"330\":2,\"337\":1,\"338\":2,\"339\":5,\"341\":1,\"345\":2,\"352\":5,\"360\":5,\"376\":2,\"389\":4,\"392\":4,\"394\":2,\"411\":4,\"422\":1,\"427\":3,\"428\":3,\"429\":3,\"430\":5,\"431\":3,\"1305\":1}}],[\"则先调用\",{\"1\":{\"1503\":1}}],[\"则方法结束返回\",{\"1\":{\"1503\":1}}],[\"则实现了对同步状态的管理\",{\"1\":{\"1500\":1}}],[\"则尝试使用\",{\"1\":{\"1442\":1}}],[\"则使用\",{\"1\":{\"1442\":1}}],[\"则拒绝任务\",{\"1\":{\"1370\":1}}],[\"则没必要进行分解\",{\"1\":{\"1361\":1}}],[\"则配置尽可能多的线程\",{\"1\":{\"1361\":1}}],[\"则交给拒绝策略进行处理\",{\"1\":{\"1358\":1}}],[\"则创建新的线程来执行任务\",{\"1\":{\"1359\":1}}],[\"则创建一个新的线程来执行任务\",{\"1\":{\"1358\":1}}],[\"则创建该数据库\",{\"1\":{\"913\":1}}],[\"则进入第\",{\"1\":{\"1358\":2}}],[\"则新创建一个线程执行刚提交的任务\",{\"1\":{\"1358\":1}}],[\"则新建threadlocalmap并存入value\",{\"1\":{\"1301\":1}}],[\"则新建一个节点\",{\"1\":{\"802\":1}}],[\"则通知被阻塞的消费者线程\",{\"1\":{\"1352\":1}}],[\"则通知被阻塞的生产者线程\",{\"1\":{\"1351\":1}}],[\"则通过\",{\"1\":{\"1316\":1}}],[\"则通过冲突解决策略找到元素\",{\"1\":{\"971\":1}}],[\"则通过若干次操作一定变成\",{\"1\":{\"104\":1}}],[\"则通过若干次操作一定能都变成正数\",{\"1\":{\"104\":1}}],[\"则调度器会剥夺某个当前允许线程的运行权\",{\"1\":{\"1334\":1}}],[\"则调用\",{\"1\":{\"1258\":1}}],[\"则队列没有队头\",{\"1\":{\"1326\":1}}],[\"则更新\",{\"1\":{\"1317\":1}}],[\"则更新最大值\",{\"1\":{\"857\":1}}],[\"则在查找过程遇到脏entry的话\",{\"1\":{\"1317\":1}}],[\"则在新链表最前方添加节点\",{\"1\":{\"699\":1}}],[\"则被装载的越少\",{\"1\":{\"1306\":1}}],[\"则以\",{\"1\":{\"1301\":1}}],[\"则以当前threadlocl实例为key\",{\"1\":{\"1301\":1}}],[\"则完全放开了牺牲数据实时性而保证数据最终一致性\",{\"1\":{\"1295\":1}}],[\"则需要再测试一下\",{\"1\":{\"1442\":1}}],[\"则需要在每一次执行完后\",{\"1\":{\"1368\":1}}],[\"则需要等上一个任务执行完毕后立即执行\",{\"1\":{\"1367\":1}}],[\"则需要依次锁住所有的\",{\"1\":{\"1276\":1}}],[\"则需要检验是否需要进行扩容操作\",{\"1\":{\"1275\":1}}],[\"则需要全局搜索用到的地方\",{\"1\":{\"1147\":1}}],[\"则继续再看当前是不是树节点\",{\"1\":{\"1273\":1}}],[\"则只需要覆盖该结点的\",{\"1\":{\"1272\":1}}],[\"则只需要修改接口方法中引用常量的地方即可\",{\"1\":{\"1147\":1}}],[\"则得到的结点就是\",{\"1\":{\"1272\":1}}],[\"则表明该变量已经被其他线程做了处理\",{\"1\":{\"1266\":1}}],[\"则表明该变量没被其他线程进行修改\",{\"1\":{\"1266\":1}}],[\"则表示没有竞争发生\",{\"1\":{\"1447\":1}}],[\"则表示当前正有\",{\"1\":{\"1266\":1}}],[\"则表示\",{\"1\":{\"783\":1}}],[\"则表示该切割点不行\",{\"1\":{\"262\":1}}],[\"则写锁获取失败\",{\"1\":{\"1239\":1}}],[\"则是继承了\",{\"1\":{\"1365\":1}}],[\"则是在插入和删除分别采用了\",{\"1\":{\"1353\":1}}],[\"则是采用链表数据结构\",{\"1\":{\"1353\":1}}],[\"则是为了减少一部分上下文切换\",{\"1\":{\"1233\":1}}],[\"则是名副其实的高富帅\",{\"1\":{\"1140\":1}}],[\"则用默认值\",{\"1\":{\"1151\":1}}],[\"则用配置项的\",{\"1\":{\"1151\":1}}],[\"则用\",{\"1\":{\"1150\":1}}],[\"则k在map中的值加1\",{\"1\":{\"1074\":1}}],[\"则replace旧的value\",{\"1\":{\"1074\":1}}],[\"则阻塞等待直至能够获取为止\",{\"1\":{\"1398\":1}}],[\"则阻塞当前线程\",{\"1\":{\"1351\":1,\"1352\":1}}],[\"则阻塞\",{\"1\":{\"1061\":1}}],[\"则抛出该异常\",{\"1\":{\"1045\":1}}],[\"则该旧值\",{\"1\":{\"1383\":1}}],[\"则该索引为非法索引\",{\"1\":{\"1045\":1}}],[\"则该函数内的每个分支都必须有\",{\"1\":{\"1021\":1}}],[\"则会执行\",{\"1\":{\"1506\":1}}],[\"则会抛出\",{\"1\":{\"1404\":1}}],[\"则会使用拒绝策略\",{\"1\":{\"1359\":1}}],[\"则会将提交的任务存放到阻塞队列\",{\"1\":{\"1359\":1}}],[\"则会创建新的线程来执行任务\",{\"1\":{\"1359\":1}}],[\"则会创建新的线程来执行新的任务\",{\"1\":{\"1359\":1}}],[\"则会创建新的线程来执行所提交的任务\",{\"1\":{\"1359\":1}}],[\"则会严重影响\",{\"1\":{\"1272\":1}}],[\"则会显示其他服务\",{\"1\":{\"1192\":1}}],[\"则会删除整张表的所有数据\",{\"1\":{\"927\":1}}],[\"则会修改整张表的所有数据\",{\"1\":{\"926\":1}}],[\"则会优先从b这条路走到t\",{\"1\":{\"221\":1}}],[\"则采用尾插入\",{\"1\":{\"1504\":1}}],[\"则采用默认值\",{\"1\":{\"919\":1}}],[\"则采用一种叫骆驼命名法的规则\",{\"1\":{\"98\":1}}],[\"则右子树上所有节点的值均大于它的根节点的值\",{\"1\":{\"899\":1}}],[\"则左子树上所有节点的值均小于它的根节点的值\",{\"1\":{\"899\":1}}],[\"则左子节点索引为\",{\"1\":{\"766\":1}}],[\"则后面的不再进行计算\",{\"1\":{\"808\":1}}],[\"则后台自动生成新的静态页面并缓存\",{\"1\":{\"534\":1}}],[\"则包含了prefix前缀\",{\"1\":{\"803\":1}}],[\"则包含word这个完整的字符串\",{\"1\":{\"803\":1}}],[\"则可得到树的深度\",{\"1\":{\"749\":1}}],[\"则可以调用\",{\"1\":{\"1258\":1}}],[\"则可以从等待方法中返回\",{\"1\":{\"1248\":1}}],[\"则可以表示\",{\"1\":{\"783\":1}}],[\"则可以访问\",{\"1\":{\"446\":1}}],[\"则可以通过构造函数来指定后台线程的个数\",{\"1\":{\"1365\":1}}],[\"则可以通过扩展欧几里得来求解\",{\"1\":{\"383\":1}}],[\"则可以通过修改\",{\"1\":{\"66\":1}}],[\"则可以使用欧几里得距离\",{\"1\":{\"220\":1}}],[\"则可以使用\",{\"1\":{\"216\":3}}],[\"则计数器\",{\"1\":{\"749\":1}}],[\"则第一趟结束进行第二趟的搜索\",{\"1\":{\"1316\":1}}],[\"则第\",{\"1\":{\"712\":2,\"1317\":1}}],[\"则第二段也一定相等\",{\"1\":{\"262\":1}}],[\"则当前任务立即执行\",{\"1\":{\"1367\":1}}],[\"则当前结点值即为第\",{\"1\":{\"712\":1}}],[\"则当前最大值为\",{\"1\":{\"705\":1}}],[\"则应该\",{\"1\":{\"686\":1}}],[\"则向缓存中插入该组\",{\"1\":{\"686\":1}}],[\"则向高位借位\",{\"1\":{\"328\":1}}],[\"则变更其数据值\",{\"1\":{\"686\":1}}],[\"则执行循环体中的语句\",{\"1\":{\"988\":1}}],[\"则执行后面的语句\",{\"1\":{\"988\":1}}],[\"则执行\",{\"1\":{\"591\":1}}],[\"则修改题目所属题库时\",{\"1\":{\"526\":1}}],[\"则其角色可以访问\",{\"1\":{\"446\":1}}],[\"则其权限可以访问\",{\"1\":{\"446\":1}}],[\"则其中任何一个角色可以访问\",{\"1\":{\"446\":1}}],[\"则其中任何一个权限可以访问\",{\"1\":{\"446\":1}}],[\"则其值就是\",{\"1\":{\"219\":1}}],[\"则无解\",{\"1\":{\"430\":1}}],[\"则点数+1\",{\"1\":{\"427\":1}}],[\"则往下沉\",{\"1\":{\"417\":1}}],[\"则最小的数为右儿子\",{\"1\":{\"417\":1}}],[\"则最小的数为左二子\",{\"1\":{\"417\":1}}],[\"则最佳优先算法找到的很可能不是最短路径\",{\"1\":{\"214\":1}}],[\"则优先采取该行动\",{\"1\":{\"394\":1}}],[\"则系数应该是1\",{\"1\":{\"392\":1}}],[\"则n\",{\"1\":{\"392\":1}}],[\"则对于任意整数\",{\"1\":{\"389\":1}}],[\"则称该游戏为一个公平组合游戏\",{\"1\":{\"395\":1}}],[\"则称该局面必败\",{\"1\":{\"394\":1}}],[\"则称\",{\"1\":{\"388\":1}}],[\"则存在一个整数\",{\"1\":{\"388\":1}}],[\"则有可能导致其他线程永远无法获取到锁\",{\"1\":{\"1233\":1}}],[\"则有\",{\"1\":{\"388\":1}}],[\"则数据保证\",{\"1\":{\"384\":1}}],[\"则数组中有\",{\"1\":{\"87\":2}}],[\"则pj一定是i的最小公因子\",{\"1\":{\"373\":1}}],[\"则匹配成功\",{\"1\":{\"363\":1}}],[\"则这条交替路称为增广路\",{\"1\":{\"363\":1}}],[\"则这个数出现的次数就可以表示为\",{\"1\":{\"324\":1}}],[\"则加入这条边到集合中\",{\"1\":{\"361\":1}}],[\"则选择该点\",{\"1\":{\"360\":1}}],[\"则把该点加入到队尾\",{\"1\":{\"355\":1}}],[\"则每左移一位\",{\"1\":{\"338\":1}}],[\"则直接通过\",{\"1\":{\"1368\":1}}],[\"则直接调用run方法\",{\"1\":{\"1368\":1}}],[\"则直接返回\",{\"1\":{\"1273\":1,\"1276\":1}}],[\"则直接返回结果\",{\"1\":{\"784\":1}}],[\"则直接将新值插入到链表末尾即可\",{\"1\":{\"1272\":1}}],[\"则直接使用cas将值插入即可\",{\"1\":{\"1272\":1}}],[\"则直接由\",{\"1\":{\"1129\":1}}],[\"则直接令\",{\"1\":{\"1069\":1}}],[\"则直接减\",{\"1\":{\"328\":1}}],[\"则直接添加到结果字符串中\",{\"1\":{\"98\":1}}],[\"则减去b\",{\"1\":{\"328\":1}}],[\"则压入c数组中\",{\"1\":{\"327\":1}}],[\"则设\",{\"1\":{\"314\":1}}],[\"则不再重新创建线程\",{\"1\":{\"1359\":1}}],[\"则不会获取\",{\"1\":{\"1158\":1}}],[\"则不需要交换\",{\"1\":{\"1020\":1}}],[\"则不需要将j重复插入\",{\"1\":{\"355\":1}}],[\"则不执行删除操作\",{\"1\":{\"923\":1}}],[\"则不包含这个字符串\",{\"1\":{\"803\":1}}],[\"则不合法\",{\"1\":{\"291\":1}}],[\"则不能被均分为三份\",{\"1\":{\"262\":1}}],[\"则为树节点\",{\"1\":{\"1273\":1}}],[\"则为\",{\"1\":{\"381\":1,\"886\":1}}],[\"则为假\",{\"1\":{\"235\":1}}],[\"则为真\",{\"1\":{\"235\":1}}],[\"则也返回\",{\"1\":{\"228\":1}}],[\"则返回false\",{\"1\":{\"1398\":1}}],[\"则返回相应的索引\",{\"1\":{\"1081\":1}}],[\"则返回defaultvalue\",{\"1\":{\"1074\":1}}],[\"则返回null\",{\"1\":{\"1074\":1}}],[\"则返回关键字的值\",{\"1\":{\"686\":1}}],[\"则返回inf\",{\"1\":{\"360\":1}}],[\"则返回true\",{\"1\":{\"356\":1,\"784\":1,\"1073\":1,\"1074\":2,\"1398\":1}}],[\"则返回\",{\"1\":{\"228\":1,\"353\":1,\"354\":1,\"782\":1,\"784\":2,\"1067\":1,\"1302\":1}}],[\"则输入为\",{\"1\":{\"224\":1,\"279\":1}}],[\"则输出结果\",{\"1\":{\"410\":1}}],[\"则输出所有路径的数目\",{\"1\":{\"142\":1}}],[\"则输出\",{\"1\":{\"88\":4,\"97\":1,\"99\":1,\"142\":1,\"180\":1,\"223\":1,\"224\":1,\"236\":1,\"237\":1,\"273\":1,\"279\":1,\"384\":1}}],[\"则depth一定小于ans\",{\"1\":{\"736\":1}}],[\"则d\",{\"1\":{\"223\":1}}],[\"则说明该数据元素的延时期已满\",{\"1\":{\"1326\":1}}],[\"则说明该节点不是真正的待删除节点\",{\"1\":{\"1284\":1}}],[\"则说明存在环\",{\"1\":{\"356\":1}}],[\"则说明j已经出队k次了\",{\"1\":{\"223\":1}}],[\"则说明当前队列中存在点u\",{\"1\":{\"221\":1}}],[\"则此时的ver就是终点t\",{\"1\":{\"223\":1}}],[\"则此时只有\",{\"1\":{\"216\":1}}],[\"则启发函数可以使用对角距离\",{\"1\":{\"219\":1}}],[\"则启发函数可以使用曼哈顿距离\",{\"1\":{\"218\":1}}],[\"则从备用的注册表中获取\",{\"1\":{\"1182\":1}}],[\"则从0开始加1\",{\"1\":{\"1074\":1}}],[\"则从上到下匹配到第一个\",{\"1\":{\"986\":1}}],[\"则从\",{\"1\":{\"215\":1}}],[\"则我们可以利用这个信息更快的到达终点\",{\"1\":{\"214\":1}}],[\"则你下一步能够到达的格子上面的数字至少为\",{\"1\":{\"196\":1}}],[\"则递归往下判断\",{\"1\":{\"187\":1}}],[\"则和叶节点的空子节点匹配\",{\"1\":{\"187\":1}}],[\"则死亡\",{\"1\":{\"180\":1}}],[\"则记录该批客人的消费金额\",{\"1\":{\"162\":1}}],[\"则记为\",{\"1\":{\"128\":1}}],[\"则编号较大的颜色能完全覆盖编号较小的颜色\",{\"1\":{\"157\":1}}],[\"则将对象头设置成无锁状态\",{\"1\":{\"1443\":1}}],[\"则将任务存放在阻塞队列workqueue中\",{\"1\":{\"1359\":1}}],[\"则将提交的任务放置在阻塞队列中\",{\"1\":{\"1358\":1}}],[\"则将获取数据的消费者线程移入到等待队列中\",{\"1\":{\"1348\":1}}],[\"则将新的entry插入在脏entry\",{\"1\":{\"1317\":1}}],[\"则将剩余那部分直接接在临时链表后面\",{\"1\":{\"833\":1}}],[\"则将剩余那一部分直接接在临时序列的后面\",{\"1\":{\"318\":1}}],[\"则将这两个连通块合并\",{\"1\":{\"361\":1}}],[\"则将其拆分成一个\",{\"1\":{\"1361\":1}}],[\"则将其与相邻四个方向上的\",{\"1\":{\"822\":1}}],[\"则将其加入队列\",{\"1\":{\"821\":1}}],[\"则将其转化为\",{\"1\":{\"328\":1}}],[\"则将其变为\",{\"1\":{\"161\":2}}],[\"则将该元素入栈\",{\"1\":{\"302\":1}}],[\"则将由\",{\"1\":{\"216\":1}}],[\"则将\",{\"1\":{\"146\":1,\"1069\":1,\"1251\":1}}],[\"则给出能到达终点的最短路径的走法数目\",{\"1\":{\"142\":1}}],[\"则\",{\"1\":{\"127\":4,\"128\":1,\"178\":2,\"215\":5,\"216\":3,\"261\":1,\"339\":2,\"379\":1,\"613\":2,\"664\":1,\"846\":2,\"874\":1,\"1160\":1,\"1432\":1,\"1455\":1}}],[\"则它将在当前轮被删除\",{\"1\":{\"99\":1}}],[\"则跳过该字符\",{\"1\":{\"98\":1}}],[\"则认为两种方法不同\",{\"1\":{\"72\":1}}],[\"则一条子评论的发布\",{\"1\":{\"30\":1}}],[\"使所有原来在该对象上\",{\"1\":{\"1404\":1}}],[\"使线程意外终止\",{\"1\":{\"1333\":1}}],[\"使其能够发挥自身优势\",{\"1\":{\"1418\":1}}],[\"使其能够有机会获得\",{\"1\":{\"1348\":1}}],[\"使其由等待队列移入到同步队列中\",{\"1\":{\"1348\":1}}],[\"使其转换为一个脏\",{\"1\":{\"1308\":1}}],[\"使其可用\",{\"1\":{\"1258\":1}}],[\"使其全部二进制位为\",{\"1\":{\"338\":1}}],[\"使脚本具有可执行权限\",{\"1\":{\"1107\":1}}],[\"使一个数的最低位为\",{\"1\":{\"338\":1}}],[\"使路径上的数字的和最大\",{\"1\":{\"301\":1}}],[\"使\",{\"1\":{\"167\":1,\"248\":2,\"338\":1,\"383\":2,\"1392\":1}}],[\"使它们的和等于\",{\"1\":{\"126\":1}}],[\"使得当前线程阻塞\",{\"1\":{\"1508\":1}}],[\"使得后继节点的线程能够运行\",{\"1\":{\"1501\":1}}],[\"使得他们全部从等待队列中移入到同步队列中去\",{\"1\":{\"1404\":1}}],[\"使得他们的和为\",{\"1\":{\"135\":1}}],[\"使得调用\",{\"1\":{\"1404\":1}}],[\"使得与当前时间相比\",{\"1\":{\"1371\":1}}],[\"使得该线程阻塞\",{\"1\":{\"1505\":1}}],[\"使得该线程进入等待池中\",{\"1\":{\"1338\":1}}],[\"使得该节点能够有机会获得\",{\"1\":{\"1252\":1}}],[\"使得往后搜索的范围扩大\",{\"1\":{\"1315\":1}}],[\"使得同学之间不会产生冲突\",{\"1\":{\"1313\":1}}],[\"使得读读之间不会阻塞\",{\"1\":{\"1290\":1}}],[\"使得线程\",{\"1\":{\"1253\":1}}],[\"使得多线程技术能够得到重视\",{\"1\":{\"1218\":1}}],[\"使得数据的存储和检索更加灵活\",{\"1\":{\"972\":1}}],[\"使得两个子集的元素和相等\",{\"1\":{\"771\":1,\"772\":1}}],[\"使得这些记录在系统中看起来像已被删除\",{\"1\":{\"575\":1}}],[\"使得这些组合的和等于给定的数字\",{\"1\":{\"135\":1}}],[\"使得每组内部区间两两之间没有交集\",{\"1\":{\"429\":1}}],[\"使得每个区间内至少包含一个选出的点\",{\"1\":{\"427\":1}}],[\"使得行动后对面面临必败局面\",{\"1\":{\"394\":1}}],[\"使得ax\",{\"1\":{\"383\":1}}],[\"使得网格变为如下排列\",{\"1\":{\"224\":1,\"279\":1}}],[\"使得得分最大化\",{\"1\":{\"178\":2}}],[\"使得受到的总伤害最小\",{\"1\":{\"110\":1}}],[\"使得区间内任意三根木桩都能构成三角形\",{\"1\":{\"78\":1}}],[\"使得\",{\"1\":{\"66\":1,\"274\":1,\"362\":1,\"383\":2,\"388\":1}}],[\"使得它能够连接\",{\"1\":{\"66\":1}}],[\"使用同步器的模板方法实现自己的同步语义\",{\"1\":{\"1496\":1}}],[\"使用锁时\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"使用线程间消息通信机制也可以完成\",{\"1\":{\"1392\":1}}],[\"使用线程池管理线程主要有如下好处\",{\"1\":{\"1357\":1}}],[\"使用线段树维护每个队列的等待时间即可\",{\"1\":{\"206\":1}}],[\"使用弱引用的话在\",{\"1\":{\"1318\":1}}],[\"使用后给\",{\"1\":{\"1313\":1}}],[\"使用完这支笔后给\",{\"1\":{\"1313\":1}}],[\"使用完之后还要将对象销毁\",{\"1\":{\"1131\":1}}],[\"使用纯数组更加方便\",{\"1\":{\"1306\":1}}],[\"使用lock\",{\"1\":{\"1294\":1}}],[\"使用者可调用方法\",{\"1\":{\"1251\":1}}],[\"使用最少线程\",{\"1\":{\"1220\":1}}],[\"使用最少的线程和使用协程\",{\"1\":{\"1220\":1}}],[\"使用率\",{\"1\":{\"1194\":1}}],[\"使用了乐观锁\",{\"1\":{\"1220\":1}}],[\"使用了\",{\"1\":{\"1194\":1,\"1272\":1}}],[\"使用了一段时间\",{\"1\":{\"668\":1}}],[\"使用变量\",{\"0\":{\"1113\":1},\"1\":{\"1113\":1}}],[\"使用stream流读取文件\",{\"1\":{\"1103\":1}}],[\"使用st表预处理\",{\"1\":{\"174\":1}}],[\"使用的是强引用\",{\"1\":{\"1318\":1}}],[\"使用的存储桶\",{\"1\":{\"1100\":1}}],[\"使用的账号信息\",{\"1\":{\"675\":1}}],[\"使用公有云的\",{\"1\":{\"1094\":1}}],[\"使用上述命令将\",{\"1\":{\"1090\":1}}],[\"使用二分查找算法在有序数组arr中查找值\",{\"1\":{\"1081\":1}}],[\"使用稳定的快排队数组进行排序\",{\"1\":{\"1067\":1}}],[\"使用灵活\",{\"1\":{\"1056\":1}}],[\"使用arrays需要import\",{\"1\":{\"1002\":1}}],[\"使用auto编译器会自动判断数据是什么类型\",{\"1\":{\"327\":1}}],[\"使用final修饰\",{\"1\":{\"978\":1}}],[\"使用聚合函数查询是纵向查询\",{\"1\":{\"932\":1}}],[\"使用数组实现求斐波那契数列的第\",{\"1\":{\"999\":1}}],[\"使用数组列表作为队列\",{\"1\":{\"870\":1}}],[\"使用数据库\",{\"0\":{\"914\":1}}],[\"使用到的变量最少\",{\"1\":{\"900\":1}}],[\"使用递归函数\",{\"1\":{\"899\":1}}],[\"使用递归前序遍历\",{\"1\":{\"899\":1}}],[\"使用递归的方法将链表分割成两个子链表\",{\"1\":{\"134\":1}}],[\"使用邻接表建图\",{\"1\":{\"875\":1}}],[\"使用邻接矩阵存图\",{\"1\":{\"358\":1}}],[\"使用链表作为队列\",{\"1\":{\"870\":1}}],[\"使用优先队列\",{\"1\":{\"857\":1}}],[\"使用快慢指针\",{\"1\":{\"833\":1}}],[\"使用快排将所有边按权值从小到大排序\",{\"1\":{\"361\":1}}],[\"使用dfs将连通的陆地块淹掉\",{\"1\":{\"820\":1}}],[\"使用布尔字段\",{\"1\":{\"802\":1}}],[\"使用记忆化函数\",{\"1\":{\"784\":1}}],[\"使用队列存储每一层的节点\",{\"1\":{\"742\":1}}],[\"使用队列实现层序遍历二叉树\",{\"1\":{\"133\":1}}],[\"使用虚拟头节点的目的在于链表初始化时无可用节点值\",{\"1\":{\"699\":1}}],[\"使用权限\",{\"1\":{\"675\":1}}],[\"使用权限字符串\",{\"1\":{\"457\":1}}],[\"使用正向代理时\",{\"1\":{\"586\":1}}],[\"使用正则表达式进行校验\",{\"1\":{\"568\":1,\"575\":1}}],[\"使用控制器注解\",{\"1\":{\"576\":1}}],[\"使用统一的\",{\"1\":{\"576\":1}}],[\"使用该工具可以帮助我们快速生成页面\",{\"1\":{\"559\":1}}],[\"使用下面命令安装\",{\"1\":{\"540\":1}}],[\"使用脚手架可以帮助我们快速构建\",{\"1\":{\"539\":1}}],[\"使用脚手架创建项目后\",{\"1\":{\"539\":1}}],[\"使用万用模版的代码生成器工具\",{\"1\":{\"516\":1}}],[\"使用cron表达式定义执行计划的触发器\",{\"1\":{\"479\":1}}],[\"使用注解方式\",{\"1\":{\"468\":1}}],[\"使用示例\",{\"0\":{\"467\":1}}],[\"使用角色字符串\",{\"1\":{\"457\":1}}],[\"使用算法和技术从数据中发现模式和洞察\",{\"1\":{\"434\":1}}],[\"使用并查集\",{\"1\":{\"361\":1}}],[\"使用成员函数\",{\"1\":{\"243\":1}}],[\"使用分布式数据库\",{\"1\":{\"151\":1}}],[\"使用消息队列\",{\"1\":{\"151\":1}}],[\"使用降序排列\",{\"1\":{\"129\":1}}],[\"使用动态规划\",{\"1\":{\"126\":1}}],[\"使用一个栈\",{\"1\":{\"731\":1}}],[\"使用一个\",{\"1\":{\"108\":1,\"168\":1,\"179\":1}}],[\"使用双向链表来模拟项链的所有操作\",{\"1\":{\"103\":1}}],[\"使用栈解决\",{\"1\":{\"93\":1}}],[\"使用两个指针分别指向数组\",{\"1\":{\"92\":1}}],[\"使用两个栈分别存数字和符号来实现\",{\"1\":{\"83\":1}}],[\"使用归并回源的思路\",{\"1\":{\"60\":1}}],[\"使用自增\",{\"1\":{\"56\":1}}],[\"使用其他引擎来实现\",{\"1\":{\"50\":1}}],[\"使用\",{\"0\":{\"675\":1,\"676\":1,\"1410\":1,\"1411\":1},\"1\":{\"50\":1,\"58\":3,\"128\":3,\"129\":2,\"243\":3,\"251\":1,\"339\":1,\"514\":1,\"515\":1,\"525\":1,\"538\":1,\"542\":1,\"567\":1,\"576\":1,\"613\":1,\"668\":1,\"672\":1,\"710\":1,\"802\":1,\"869\":1,\"911\":1,\"937\":1,\"1074\":2,\"1095\":2,\"1100\":1,\"1114\":1,\"1221\":1,\"1264\":1,\"1272\":1,\"1276\":2,\"1290\":1,\"1320\":1,\"1384\":1,\"1402\":3,\"1408\":2,\"1411\":1,\"1420\":1,\"1431\":1,\"1439\":1,\"1467\":1,\"1472\":1,\"1482\":1,\"1495\":2,\"1505\":1}}],[\"使用json序列化方式存入\",{\"1\":{\"31\":1}}],[\"具有原子性\",{\"1\":{\"1487\":1}}],[\"具有可见性\",{\"1\":{\"1486\":2}}],[\"具有有序性和可见性\",{\"1\":{\"1487\":1}}],[\"具有有序性\",{\"1\":{\"1484\":1}}],[\"具有这三种状态\",{\"1\":{\"1375\":1}}],[\"具有延时执行任务和可周期性执行任务的特性\",{\"1\":{\"1371\":1}}],[\"具有双端队列的特性\",{\"1\":{\"1326\":1}}],[\"具有的特殊操作\",{\"1\":{\"1325\":1}}],[\"具有更高的可控制性和扩展性\",{\"1\":{\"1248\":1}}],[\"具有\",{\"1\":{\"919\":1}}],[\"具有非常多的功能\",{\"1\":{\"669\":1}}],[\"具有相同结构和节点值的子树\",{\"1\":{\"186\":1}}],[\"具体是否插入还是得看是什么处理器\",{\"1\":{\"1477\":1}}],[\"具体规则\",{\"0\":{\"1421\":1}}],[\"具体交换数据是通过\",{\"1\":{\"1399\":1}}],[\"具体源码为\",{\"1\":{\"1370\":1}}],[\"具体请看上面的注释\",{\"1\":{\"1301\":1}}],[\"具体请看注释\",{\"1\":{\"1232\":1,\"1251\":1}}],[\"具体原因看后面分析\",{\"1\":{\"1283\":1}}],[\"具体使用请看注释\",{\"1\":{\"1270\":1}}],[\"具体为\",{\"1\":{\"1266\":1}}],[\"具体逻辑请看注释\",{\"1\":{\"1252\":1}}],[\"具体地\",{\"1\":{\"1095\":1}}],[\"具体的就不再说了\",{\"1\":{\"1512\":1}}],[\"具体的大家可以使用一些工具去看一下\",{\"1\":{\"1454\":1}}],[\"具体的可以看上面的表格\",{\"1\":{\"1430\":1}}],[\"具体的一共有六项规则\",{\"1\":{\"1421\":1}}],[\"具体的定义为\",{\"1\":{\"1418\":1,\"1420\":1}}],[\"具体的性能测试可以去网上查阅一些资料\",{\"1\":{\"1264\":1}}],[\"具体的代码在\",{\"1\":{\"1150\":1}}],[\"具体的\",{\"1\":{\"851\":1}}],[\"具体的执行的流程如下图\",{\"1\":{\"451\":1,\"456\":1,\"462\":1}}],[\"具体解决缓存穿透的场景\",{\"1\":{\"613\":1}}],[\"具体可以到\",{\"1\":{\"539\":1}}],[\"具体实现\",{\"1\":{\"523\":1,\"525\":1,\"567\":1}}],[\"具体方法是\",{\"1\":{\"396\":1,\"1330\":1}}],[\"具体步骤\",{\"1\":{\"354\":1}}],[\"具体问题的逻辑\",{\"1\":{\"340\":1}}],[\"具体来说如果一块陆地像素与海洋相邻\",{\"1\":{\"280\":1}}],[\"具体来说\",{\"1\":{\"66\":2,\"796\":1}}],[\"具备水平扩容的弹性\",{\"1\":{\"34\":1}}],[\"vmstat\",{\"1\":{\"1220\":1}}],[\"vmess\",{\"1\":{\"665\":1}}],[\"v4\",{\"1\":{\"1095\":1}}],[\"v>的个数\",{\"1\":{\"1074\":1}}],[\"v>>\",{\"1\":{\"1074\":1}}],[\"v>多的函数\",{\"1\":{\"1040\":1}}],[\"v>\",{\"0\":{\"1082\":1},\"1\":{\"1040\":4,\"1082\":1,\"1210\":4,\"1264\":2,\"1266\":2,\"1267\":17,\"1268\":11,\"1270\":1,\"1271\":4,\"1272\":13,\"1273\":2,\"1274\":24,\"1275\":1}}],[\"vhost\",{\"1\":{\"672\":1}}],[\"vuespringbootapplicationtests\",{\"1\":{\"1201\":1}}],[\"vuepress\",{\"1\":{\"534\":1,\"658\":3}}],[\"vue\",{\"1\":{\"447\":1,\"448\":2,\"463\":2}}],[\"via\",{\"1\":{\"1275\":1,\"1292\":1}}],[\"vipaddressresolver\",{\"1\":{\"1154\":1}}],[\"vim\",{\"1\":{\"671\":1}}],[\"vivo\",{\"1\":{\"624\":1}}],[\"view\",{\"1\":{\"592\":1}}],[\"views\",{\"1\":{\"447\":1}}],[\"vitals\",{\"1\":{\"539\":1}}],[\"visited\",{\"1\":{\"820\":2}}],[\"vis\",{\"1\":{\"180\":4,\"228\":2,\"235\":5,\"236\":6,\"237\":5,\"288\":4,\"314\":3}}],[\"vs\",{\"0\":{\"1384\":1,\"1467\":1},\"1\":{\"437\":1,\"1233\":1,\"1295\":1,\"1338\":1,\"1420\":1,\"1437\":1}}],[\"var\",{\"1\":{\"1351\":1}}],[\"varchar\",{\"1\":{\"510\":8,\"511\":2,\"512\":2,\"566\":14,\"920\":4,\"922\":4}}],[\"variety\",{\"1\":{\"434\":1}}],[\"validpattern\",{\"1\":{\"568\":2,\"575\":2}}],[\"validquestionbankquestion\",{\"1\":{\"526\":3}}],[\"valid\",{\"1\":{\"311\":4,\"986\":1}}],[\"val\",{\"1\":{\"103\":5,\"187\":2,\"254\":2,\"324\":4,\"687\":3,\"700\":9,\"710\":1,\"713\":1,\"736\":1,\"737\":1,\"743\":1,\"789\":2,\"809\":2,\"834\":2,\"882\":1,\"886\":3,\"887\":1,\"888\":1,\"899\":4,\"900\":2,\"901\":1,\"1002\":1,\"1010\":2,\"1011\":2,\"1036\":1,\"1078\":2,\"1267\":1,\"1272\":8,\"1273\":3,\"1274\":2,\"1282\":6}}],[\"valuememory\",{\"1\":{\"1313\":1}}],[\"valueref\",{\"1\":{\"1313\":1}}],[\"value2\",{\"1\":{\"1201\":2,\"1204\":2,\"1207\":2,\"1211\":2}}],[\"value1\",{\"1\":{\"1201\":2,\"1204\":2,\"1207\":2,\"1211\":2}}],[\"value>\",{\"1\":{\"1074\":1}}],[\"valueenum\",{\"1\":{\"592\":3}}],[\"valuetype\",{\"1\":{\"592\":7}}],[\"values\",{\"1\":{\"587\":5,\"589\":2,\"592\":5,\"925\":4,\"1074\":4,\"1081\":1,\"1267\":1,\"1275\":1,\"1301\":1}}],[\"valueoffset\",{\"1\":{\"1385\":2}}],[\"valueof\",{\"1\":{\"161\":1,\"1069\":2}}],[\"value\",{\"1\":{\"31\":1,\"58\":1,\"252\":1,\"515\":1,\"575\":2,\"592\":3,\"686\":3,\"687\":3,\"688\":2,\"705\":1,\"795\":1,\"796\":1,\"797\":1,\"893\":2,\"894\":4,\"899\":5,\"900\":1,\"901\":5,\"1040\":1,\"1074\":4,\"1081\":1,\"1083\":16,\"1150\":1,\"1201\":4,\"1210\":3,\"1264\":2,\"1267\":4,\"1272\":12,\"1273\":1,\"1274\":1,\"1275\":7,\"1284\":2,\"1301\":9,\"1302\":7,\"1305\":9,\"1306\":7,\"1308\":1,\"1313\":3,\"1314\":5,\"1316\":6,\"1317\":7,\"1326\":2,\"1349\":2,\"1366\":5,\"1386\":2,\"1472\":3}}],[\"volitile\",{\"1\":{\"1295\":1}}],[\"volatile包含禁止指令重排序的语义\",{\"1\":{\"1485\":1}}],[\"volatiledemo\",{\"1\":{\"1458\":1}}],[\"volatileexample\",{\"1\":{\"1455\":1,\"1482\":1}}],[\"volatile\",{\"0\":{\"1452\":1,\"1453\":1,\"1454\":1,\"1455\":1,\"1456\":1,\"1457\":1,\"1485\":1},\"1\":{\"1145\":4,\"1254\":1,\"1266\":3,\"1267\":6,\"1275\":4,\"1276\":1,\"1281\":5,\"1292\":3,\"1294\":2,\"1295\":5,\"1388\":2,\"1417\":2,\"1421\":3,\"1423\":2,\"1453\":4,\"1454\":4,\"1455\":8,\"1456\":6,\"1457\":14,\"1458\":3,\"1476\":1,\"1482\":3,\"1485\":4,\"1486\":2,\"1487\":1,\"1491\":1,\"1501\":4}}],[\"volume\",{\"1\":{\"434\":1}}],[\"vo\",{\"1\":{\"471\":1,\"516\":1,\"517\":1,\"523\":1}}],[\"void\",{\"1\":{\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":4,\"157\":3,\"161\":1,\"162\":1,\"174\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":1,\"200\":3,\"203\":1,\"206\":3,\"223\":2,\"228\":1,\"229\":1,\"235\":1,\"236\":1,\"237\":1,\"255\":1,\"269\":1,\"271\":1,\"273\":2,\"274\":2,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":2,\"309\":2,\"314\":1,\"317\":1,\"318\":1,\"338\":1,\"342\":1,\"345\":2,\"353\":1,\"361\":2,\"368\":1,\"371\":1,\"372\":1,\"373\":1,\"380\":1,\"390\":1,\"403\":5,\"404\":3,\"412\":1,\"414\":2,\"417\":3,\"419\":1,\"431\":1,\"446\":2,\"526\":1,\"567\":1,\"568\":1,\"686\":1,\"687\":2,\"688\":1,\"710\":1,\"724\":1,\"725\":1,\"736\":1,\"801\":1,\"803\":1,\"820\":1,\"821\":1,\"822\":1,\"870\":1,\"876\":1,\"978\":1,\"980\":3,\"981\":2,\"982\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":4,\"989\":1,\"990\":4,\"992\":1,\"993\":1,\"994\":2,\"997\":1,\"998\":1,\"999\":4,\"1000\":2,\"1001\":1,\"1004\":2,\"1006\":1,\"1011\":1,\"1013\":1,\"1014\":2,\"1015\":4,\"1017\":2,\"1018\":3,\"1020\":5,\"1021\":2,\"1022\":1,\"1023\":1,\"1027\":2,\"1028\":1,\"1029\":1,\"1031\":2,\"1032\":1,\"1033\":3,\"1034\":4,\"1046\":1,\"1047\":2,\"1048\":2,\"1049\":1,\"1055\":1,\"1059\":5,\"1061\":2,\"1062\":5,\"1063\":2,\"1102\":4,\"1103\":6,\"1133\":1,\"1145\":1,\"1149\":1,\"1164\":1,\"1165\":1,\"1175\":1,\"1177\":1,\"1201\":4,\"1204\":1,\"1207\":1,\"1211\":1,\"1221\":4,\"1244\":1,\"1248\":3,\"1250\":1,\"1251\":2,\"1252\":3,\"1254\":3,\"1259\":7,\"1260\":1,\"1268\":1,\"1274\":1,\"1275\":1,\"1282\":1,\"1284\":2,\"1301\":2,\"1303\":1,\"1306\":3,\"1308\":1,\"1309\":2,\"1314\":1,\"1317\":2,\"1319\":1,\"1330\":3,\"1336\":3,\"1337\":5,\"1338\":1,\"1339\":1,\"1340\":2,\"1347\":2,\"1351\":1,\"1359\":1,\"1368\":1,\"1370\":2,\"1385\":1,\"1386\":1,\"1387\":1,\"1388\":1,\"1392\":1,\"1393\":2,\"1398\":5,\"1399\":1,\"1406\":6,\"1407\":6,\"1409\":3,\"1410\":6,\"1411\":3,\"1429\":2,\"1431\":2,\"1432\":2,\"1449\":2,\"1455\":2,\"1458\":2,\"1467\":1,\"1469\":1,\"1470\":2,\"1471\":1,\"1475\":2,\"1476\":3,\"1478\":2,\"1482\":2,\"1493\":2,\"1495\":1,\"1496\":5,\"1500\":4,\"1503\":1,\"1505\":1,\"1506\":1,\"1507\":2,\"1510\":2,\"1511\":1}}],[\"velocity\",{\"1\":{\"434\":1}}],[\"vector\",{\"0\":{\"242\":1},\"1\":{\"254\":4,\"422\":1,\"423\":3,\"431\":1,\"1075\":1,\"1280\":2,\"1290\":2}}],[\"vector<node>\",{\"1\":{\"423\":1}}],[\"vector<edge>\",{\"1\":{\"345\":1}}],[\"vector<good>\",{\"1\":{\"298\":1}}],[\"vector<pis>\",{\"1\":{\"224\":1}}],[\"vector<piii>\",{\"1\":{\"223\":1}}],[\"vector<pii>\",{\"1\":{\"223\":1,\"342\":2,\"353\":1,\"431\":1}}],[\"vector<long\",{\"1\":{\"142\":1}}],[\"vector<ll>\",{\"1\":{\"65\":1,\"110\":1,\"141\":2,\"206\":2}}],[\"vector<cell>\",{\"1\":{\"141\":1}}],[\"vector<tuple>\",{\"1\":{\"140\":1}}],[\"vector<vector<long\",{\"1\":{\"142\":1}}],[\"vector<vector<ll>>\",{\"1\":{\"141\":1}}],[\"vector<vector<vector<long\",{\"1\":{\"142\":1}}],[\"vector<vector<vector<int>>>\",{\"1\":{\"120\":1}}],[\"vector<vector<int>>\",{\"1\":{\"120\":1,\"121\":3,\"133\":2,\"141\":1,\"146\":1,\"174\":2,\"203\":2,\"242\":1,\"254\":1}}],[\"vector<vector<bool>>\",{\"1\":{\"77\":1}}],[\"vector<bool>\",{\"1\":{\"77\":1,\"108\":1}}],[\"vector<int>\",{\"1\":{\"65\":2,\"66\":2,\"92\":4,\"108\":3,\"109\":5,\"110\":1,\"119\":1,\"120\":1,\"121\":5,\"122\":1,\"133\":1,\"135\":1,\"141\":1,\"146\":2,\"173\":2,\"174\":7,\"203\":3,\"242\":2,\"250\":1,\"254\":3,\"255\":1,\"256\":1,\"302\":2,\"309\":8,\"311\":1,\"327\":5,\"328\":7,\"329\":4,\"330\":4,\"341\":1,\"369\":2,\"375\":2,\"390\":4,\"422\":1,\"423\":1,\"429\":1,\"857\":3}}],[\"version\",{\"1\":{\"1102\":1,\"1170\":2,\"1242\":2,\"1315\":1}}],[\"version>\",{\"1\":{\"568\":1,\"1099\":1,\"1203\":1,\"1206\":1,\"1209\":1}}],[\"veracity\",{\"1\":{\"434\":1}}],[\"ver\",{\"1\":{\"223\":9,\"353\":4}}],[\"vc40\",{\"0\":{\"204\":1}}],[\"vc35\",{\"0\":{\"201\":1}}],[\"vc28\",{\"0\":{\"198\":1}}],[\"vc2\",{\"0\":{\"195\":1}}],[\"vc1\",{\"0\":{\"192\":1}}],[\"v\",{\"1\":{\"173\":6,\"250\":1,\"255\":4,\"256\":11,\"296\":6,\"297\":6,\"298\":19,\"299\":8,\"422\":1,\"457\":6,\"537\":2,\"772\":2,\"1074\":3,\"1081\":9,\"1210\":2,\"1264\":2,\"1266\":3,\"1267\":1,\"1268\":4,\"1272\":3,\"1273\":1,\"1274\":1,\"1275\":3,\"1305\":2,\"1383\":7,\"1399\":4,\"1431\":1,\"1437\":7}}],[\"v2rayng\",{\"1\":{\"665\":1}}],[\"v2rayn\",{\"1\":{\"665\":4}}],[\"v2rayu\",{\"1\":{\"665\":3}}],[\"v2ray\",{\"1\":{\"662\":2,\"664\":2}}],[\"v2\",{\"1\":{\"97\":2,\"254\":2,\"255\":2,\"1013\":2,\"1093\":1,\"1095\":1,\"1177\":1,\"1184\":1}}],[\"v2​≤100\",{\"1\":{\"97\":1}}],[\"v2​\",{\"1\":{\"97\":2}}],[\"v1\",{\"1\":{\"97\":2,\"254\":3,\"255\":2,\"1013\":2}}],[\"v1​\",{\"1\":{\"97\":2}}],[\"u3000\",{\"1\":{\"1069\":1}}],[\"u用户名\",{\"1\":{\"906\":1}}],[\"uml\",{\"1\":{\"1365\":2}}],[\"umijs\",{\"1\":{\"559\":1}}],[\"umi\",{\"1\":{\"557\":2,\"559\":6,\"585\":1}}],[\"umbrella\",{\"1\":{\"181\":2}}],[\"utf\",{\"1\":{\"1069\":3}}],[\"utf8mb4\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1}}],[\"utils\",{\"1\":{\"448\":1}}],[\"util\",{\"0\":{\"1080\":1,\"1081\":1,\"1082\":1},\"1\":{\"70\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"152\":1,\"157\":1,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"517\":1,\"981\":1,\"984\":9,\"985\":2,\"986\":1,\"988\":1,\"990\":1,\"992\":1,\"999\":3,\"1001\":1,\"1002\":1,\"1004\":2,\"1006\":1,\"1014\":1,\"1018\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1036\":3,\"1037\":1,\"1038\":3,\"1039\":4,\"1040\":4,\"1047\":1,\"1048\":1,\"1061\":1,\"1258\":1,\"1259\":2,\"1299\":1,\"1334\":1,\"1491\":1}}],[\"uid\",{\"1\":{\"576\":1}}],[\"uindex\",{\"1\":{\"566\":1}}],[\"ui\",{\"1\":{\"446\":1,\"547\":1,\"559\":7}}],[\"urlparams\",{\"1\":{\"589\":2}}],[\"url\",{\"0\":{\"672\":1},\"1\":{\"446\":2,\"511\":1,\"542\":4,\"589\":1,\"592\":1,\"672\":1,\"1149\":1,\"1165\":2,\"1184\":1}}],[\"urdl\",{\"1\":{\"224\":1}}],[\"usual\",{\"1\":{\"1511\":1}}],[\"usage\",{\"1\":{\"1194\":1}}],[\"usr\",{\"1\":{\"671\":1,\"672\":2,\"1107\":3}}],[\"usebiasedlocking\",{\"1\":{\"1444\":1}}],[\"uses\",{\"1\":{\"1346\":1,\"1351\":1,\"1511\":1}}],[\"usestyles\",{\"1\":{\"587\":1}}],[\"usestate<string>\",{\"1\":{\"587\":1}}],[\"used\",{\"1\":{\"1275\":2,\"1351\":1,\"1472\":1}}],[\"use\",{\"1\":{\"539\":1,\"540\":1,\"545\":2,\"549\":1,\"914\":1,\"1158\":2,\"1244\":1,\"1267\":1,\"1306\":2,\"1314\":2,\"1482\":2}}],[\"usepermissionstore\",{\"1\":{\"459\":1}}],[\"useuserstore\",{\"1\":{\"448\":1,\"453\":1}}],[\"user2\",{\"1\":{\"1387\":2}}],[\"user1\",{\"1\":{\"1387\":3}}],[\"usercache\",{\"1\":{\"1211\":4}}],[\"usercontroller\",{\"1\":{\"576\":1,\"578\":1,\"596\":1}}],[\"userconstant\",{\"1\":{\"525\":1,\"526\":1,\"580\":2}}],[\"user=admin\",{\"1\":{\"1087\":2}}],[\"useref<actiontype>\",{\"1\":{\"592\":1}}],[\"useref\",{\"1\":{\"592\":1}}],[\"usermanage\",{\"1\":{\"592\":2}}],[\"usermapper\",{\"1\":{\"568\":4,\"575\":1}}],[\"userlogout\",{\"1\":{\"596\":3}}],[\"userloginrequest\",{\"1\":{\"576\":7}}],[\"userlogin\",{\"1\":{\"575\":1,\"576\":2}}],[\"userlist\",{\"1\":{\"578\":2,\"592\":2}}],[\"userld\",{\"1\":{\"511\":1,\"512\":1,\"513\":1,\"517\":1}}],[\"usernname\",{\"1\":{\"568\":14}}],[\"username=\",{\"1\":{\"1387\":5,\"1388\":1}}],[\"username\",{\"1\":{\"510\":1,\"566\":2,\"568\":8,\"575\":6,\"576\":8,\"578\":5,\"587\":3,\"589\":2,\"592\":1,\"920\":2,\"1207\":3,\"1211\":4,\"1387\":5,\"1388\":5}}],[\"usernamepasswordauthenticationfilter\",{\"1\":{\"446\":2}}],[\"userregisterrequest\",{\"1\":{\"576\":9}}],[\"userregister\",{\"1\":{\"568\":8,\"576\":2}}],[\"userrole\",{\"1\":{\"510\":1,\"566\":2,\"589\":1,\"592\":1}}],[\"user>\",{\"1\":{\"568\":1}}],[\"userserviceimpl\",{\"1\":{\"568\":1,\"596\":1}}],[\"userservice\",{\"1\":{\"526\":1,\"567\":1,\"568\":8,\"576\":4,\"578\":2,\"579\":1,\"589\":2,\"596\":1}}],[\"userid\",{\"1\":{\"511\":1,\"512\":3,\"513\":1,\"525\":1,\"566\":3,\"579\":4,\"589\":3}}],[\"userprofile\",{\"1\":{\"510\":1}}],[\"userpassword\",{\"1\":{\"510\":1,\"575\":2}}],[\"useravatar\",{\"1\":{\"510\":1}}],[\"useraccount\",{\"1\":{\"510\":1,\"566\":1,\"575\":2}}],[\"useralias\",{\"1\":{\"471\":2}}],[\"user\",{\"0\":{\"1524\":1,\"1525\":1},\"1\":{\"448\":1,\"453\":1,\"457\":3,\"467\":15,\"471\":6,\"510\":3,\"526\":1,\"543\":1,\"559\":3,\"566\":2,\"567\":13,\"568\":7,\"575\":14,\"576\":3,\"578\":6,\"580\":1,\"586\":2,\"587\":3,\"588\":1,\"589\":14,\"591\":2,\"592\":3,\"596\":3,\"671\":1,\"1100\":1,\"1387\":16,\"1388\":11}}],[\"userdetailsserviceimpl\",{\"1\":{\"451\":1}}],[\"userdetailsservice\",{\"1\":{\"446\":5}}],[\"userdetails\",{\"1\":{\"446\":1}}],[\"using\",{\"1\":{\"65\":1,\"66\":1,\"76\":1,\"77\":1,\"110\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"172\":1,\"173\":1,\"174\":1,\"194\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"311\":1,\"312\":1,\"314\":1,\"324\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"339\":2,\"352\":1,\"360\":1,\"361\":1,\"376\":1,\"384\":1,\"392\":1,\"394\":1,\"411\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1,\"1315\":1}}],[\"ull\",{\"1\":{\"421\":4}}],[\"ullddrurdllurdruldr\",{\"1\":{\"224\":1}}],[\"u表示当前节点\",{\"1\":{\"362\":1}}],[\"u表示第几位\",{\"1\":{\"289\":1}}],[\"u只猫\",{\"1\":{\"290\":1}}],[\"until\",{\"1\":{\"1316\":2}}],[\"untreefi\",{\"1\":{\"1274\":1}}],[\"untreeify\",{\"1\":{\"1274\":4}}],[\"uncaughtexceptionhandler\",{\"1\":{\"1319\":1}}],[\"unchanged\",{\"1\":{\"1283\":1}}],[\"unchecked\",{\"1\":{\"1271\":1,\"1274\":1,\"1302\":1,\"1348\":1}}],[\"uncontended\",{\"1\":{\"1275\":3}}],[\"unparksuccessor\",{\"1\":{\"1506\":5,\"1511\":3}}],[\"unpark\",{\"1\":{\"1252\":1,\"1258\":2,\"1259\":2,\"1260\":3,\"1506\":3}}],[\"unlike\",{\"1\":{\"1316\":1,\"1511\":1}}],[\"unlink\",{\"1\":{\"1267\":1}}],[\"unlinkcancelledwaiters\",{\"1\":{\"1251\":2}}],[\"unless\",{\"1\":{\"1315\":1,\"1351\":1}}],[\"unlocked\",{\"1\":{\"1496\":1}}],[\"unlock\",{\"1\":{\"1061\":2,\"1244\":4,\"1250\":1,\"1254\":2,\"1294\":1,\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1410\":2,\"1482\":4,\"1492\":2,\"1496\":2}}],[\"unmatchedunlockexception\",{\"1\":{\"1243\":1}}],[\"unused\",{\"1\":{\"1242\":1,\"1243\":1,\"1496\":2}}],[\"unavailable\",{\"1\":{\"1194\":1}}],[\"unauthorizedhandler\",{\"1\":{\"446\":2}}],[\"unknownhostexception\",{\"1\":{\"1175\":1,\"1177\":1}}],[\"undefined\",{\"1\":{\"591\":1}}],[\"undefined>\",{\"1\":{\"591\":1}}],[\"underscore\",{\"1\":{\"567\":1}}],[\"unsafer\",{\"1\":{\"1385\":1}}],[\"unsafe\",{\"1\":{\"1259\":4,\"1266\":3,\"1282\":6,\"1385\":11}}],[\"unset\",{\"1\":{\"1115\":2}}],[\"unsupportedoperationexception\",{\"1\":{\"1045\":1,\"1495\":1}}],[\"unsigned\",{\"1\":{\"421\":2,\"920\":1}}],[\"unsolvable\",{\"1\":{\"224\":2}}],[\"uninstall\",{\"1\":{\"1090\":1}}],[\"unix\",{\"1\":{\"1087\":1}}],[\"unit\",{\"1\":{\"671\":1,\"1242\":2,\"1243\":1,\"1248\":1,\"1325\":2,\"1326\":1,\"1359\":2,\"1367\":4,\"1368\":3,\"1370\":3,\"1392\":1,\"1393\":1,\"1398\":2,\"1399\":1,\"1410\":1,\"1493\":1,\"1496\":2}}],[\"unicode\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1}}],[\"unique\",{\"1\":{\"341\":1,\"422\":1,\"423\":3,\"513\":1,\"566\":1,\"919\":1,\"938\":1,\"959\":1}}],[\"unionld\",{\"1\":{\"510\":2}}],[\"unionid\",{\"1\":{\"510\":3}}],[\"union\",{\"1\":{\"181\":1,\"267\":1,\"271\":1,\"273\":2,\"274\":4,\"361\":2,\"414\":1,\"822\":3}}],[\"unordered\",{\"1\":{\"200\":1,\"224\":2,\"279\":1,\"376\":1,\"422\":4}}],[\"upon\",{\"1\":{\"1267\":1,\"1408\":1,\"1511\":1}}],[\"updating\",{\"1\":{\"1242\":1}}],[\"updater\",{\"1\":{\"1388\":3}}],[\"updatehead\",{\"1\":{\"1284\":9,\"1286\":1}}],[\"updates\",{\"1\":{\"1283\":1}}],[\"updatetime\",{\"1\":{\"510\":3,\"511\":1,\"512\":1,\"513\":1,\"525\":1,\"566\":2}}],[\"updatejob\",{\"1\":{\"481\":1}}],[\"update\",{\"0\":{\"926\":1},\"1\":{\"129\":5,\"157\":4,\"206\":4,\"481\":1,\"482\":1,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"924\":1,\"926\":5,\"927\":1,\"947\":1,\"957\":1,\"1239\":1,\"1385\":2,\"1386\":1}}],[\"uptime\",{\"1\":{\"1190\":1,\"1194\":1}}],[\"uploadobjectargs\",{\"1\":{\"1103\":1}}],[\"uploadobject\",{\"1\":{\"1103\":1}}],[\"upstream\",{\"1\":{\"664\":1}}],[\"up\",{\"1\":{\"417\":4,\"1191\":1,\"1193\":1,\"1251\":1,\"1252\":1,\"1317\":2}}],[\"upper\",{\"1\":{\"129\":1,\"174\":1,\"324\":3,\"422\":4,\"423\":3}}],[\"up主与用户的\",{\"1\":{\"39\":1}}],[\"up主回复\",{\"1\":{\"22\":1}}],[\"up主删除等\",{\"1\":{\"22\":1}}],[\"up主每天都会发布海量的视频\",{\"1\":{\"21\":1}}],[\"u\",{\"1\":{\"77\":1,\"221\":8,\"223\":2,\"224\":1,\"255\":6,\"281\":4,\"287\":8,\"288\":5,\"289\":6,\"290\":8,\"291\":7,\"314\":16,\"345\":11,\"347\":4,\"362\":3,\"412\":7,\"416\":2,\"417\":17,\"471\":40,\"1266\":3,\"1268\":3,\"1271\":2,\"1274\":2,\"1275\":4,\"1380\":1,\"1385\":2,\"1423\":1,\"1438\":1}}],[\"uxy\",{\"1\":{\"77\":1}}],[\"<v>\",{\"1\":{\"1367\":1}}],[\"<version>2\",{\"1\":{\"1206\":1}}],[\"<version>8\",{\"1\":{\"1099\":1}}],[\"<version>31\",{\"1\":{\"1203\":1}}],[\"<version>3\",{\"1\":{\"568\":1,\"1209\":1}}],[\"<vector>\",{\"1\":{\"65\":1,\"66\":1,\"77\":1,\"110\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"173\":1,\"174\":1,\"197\":1,\"203\":1,\"206\":1,\"298\":1,\"302\":1,\"311\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"376\":1,\"431\":1}}],[\"<k\",{\"1\":{\"1268\":3}}],[\"<0x048c2d18>\",{\"1\":{\"1259\":2}}],[\"<0x00000007d5ff53d8\",{\"1\":{\"1221\":2}}],[\"<0x00000007d5ff53a8\",{\"1\":{\"1221\":2}}],[\"<zipdateformat>yyyymmdd<\",{\"1\":{\"1090\":1}}],[\"<zipolderthannumdays>5<zipolderthannumdays>\",{\"1\":{\"1090\":1}}],[\"<executable>\",{\"1\":{\"1090\":1}}],[\"<el\",{\"1\":{\"457\":4}}],[\"<name>minio\",{\"1\":{\"1090\":1}}],[\"<nums\",{\"1\":{\"851\":1}}],[\"<footer\",{\"1\":{\"587\":1}}],[\"<pattern>yyyymmdd<\",{\"1\":{\"1090\":1}}],[\"<protable<api\",{\"1\":{\"592\":1}}],[\"<proformcheckbox\",{\"1\":{\"588\":1}}],[\"<proformtext\",{\"1\":{\"587\":3}}],[\"<pii>\",{\"1\":{\"431\":1}}],[\"<tabledropdown\",{\"1\":{\"592\":1}}],[\"<tabs\",{\"1\":{\"587\":1}}],[\"<title>\",{\"1\":{\"587\":1}}],[\"<log\",{\"1\":{\"1090\":1}}],[\"<logpath>\",{\"1\":{\"1090\":1}}],[\"<loginform\",{\"1\":{\"587\":1}}],[\"<link\",{\"1\":{\"588\":1}}],[\"<list>\",{\"1\":{\"200\":1}}],[\"<>\",{\"1\":{\"568\":1,\"575\":1,\"587\":1,\"931\":1,\"950\":1}}],[\"<groupid>com\",{\"1\":{\"1203\":1,\"1206\":1}}],[\"<groupid>io\",{\"1\":{\"1099\":1}}],[\"<groupid>org\",{\"1\":{\"568\":1,\"1209\":1}}],[\"<globalfooter\",{\"1\":{\"549\":1}}],[\"<description>minio文件存储服务<\",{\"1\":{\"1090\":1}}],[\"<dependency>\",{\"1\":{\"568\":1,\"1099\":1,\"1203\":1,\"1206\":1,\"1209\":1}}],[\"<deque>\",{\"1\":{\"110\":1}}],[\"<div>\",{\"1\":{\"549\":1,\"592\":1}}],[\"<div>©\",{\"1\":{\"549\":1}}],[\"<div>我的题目\",{\"1\":{\"542\":1}}],[\"<div\",{\"1\":{\"549\":1,\"587\":2}}],[\"<br>\",{\"1\":{\"1149\":1}}],[\"<basiclayout>\",{\"1\":{\"548\":1}}],[\"<body>\",{\"1\":{\"540\":1,\"548\":1}}],[\"<bit\",{\"1\":{\"314\":1}}],[\"<bits\",{\"1\":{\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"309\":1,\"360\":1,\"361\":1}}],[\"<helmet>\",{\"1\":{\"587\":1}}],[\"<html\",{\"1\":{\"540\":1,\"548\":1}}],[\"<hr​\",{\"1\":{\"66\":1}}],[\"<id>minio\",{\"1\":{\"1090\":1}}],[\"<img\",{\"1\":{\"587\":1}}],[\"<image\",{\"1\":{\"543\":1,\"592\":1}}],[\"<include\",{\"1\":{\"471\":1}}],[\"<iostream>\",{\"1\":{\"65\":1,\"66\":1,\"76\":1,\"77\":1,\"110\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"172\":1,\"173\":1,\"174\":1,\"194\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"224\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"311\":1,\"324\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"339\":2,\"352\":1,\"376\":1,\"384\":1,\"394\":1,\"411\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1}}],[\"<sizethreshold>10240<\",{\"1\":{\"1090\":1}}],[\"<service>\",{\"1\":{\"1090\":1}}],[\"<select\",{\"1\":{\"471\":1}}],[\"<string>\",{\"1\":{\"172\":1}}],[\"<queue>\",{\"1\":{\"223\":1,\"224\":1,\"278\":1,\"279\":1,\"429\":1}}],[\"<unordered\",{\"1\":{\"200\":1,\"224\":1,\"279\":1,\"376\":1}}],[\"<map>\",{\"1\":{\"174\":1}}],[\"<cstdlib>\",{\"1\":{\"273\":1}}],[\"<cstdio>\",{\"1\":{\"273\":1,\"274\":1,\"296\":1,\"297\":1,\"298\":1,\"302\":2,\"431\":1}}],[\"<cstring>\",{\"1\":{\"223\":1,\"224\":1,\"261\":1,\"262\":1,\"263\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"298\":2,\"299\":2,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"311\":1,\"352\":1}}],[\"<cmath>\",{\"1\":{\"174\":1,\"194\":1,\"197\":1}}],[\"<climits>\",{\"1\":{\"110\":1,\"146\":1,\"174\":1}}],[\"<autorollattime>00\",{\"1\":{\"1090\":1}}],[\"<artifactid>ehcache<\",{\"1\":{\"1209\":1}}],[\"<artifactid>caffeine<\",{\"1\":{\"1206\":1}}],[\"<artifactid>commons\",{\"1\":{\"568\":1}}],[\"<artifactid>guava<\",{\"1\":{\"1203\":1}}],[\"<artifactid>minio<\",{\"1\":{\"1099\":1}}],[\"<arguments>server\",{\"1\":{\"1090\":1}}],[\"<a\",{\"1\":{\"549\":1,\"588\":1,\"592\":2}}],[\"<antdregistry>\",{\"1\":{\"540\":1,\"548\":1}}],[\"<app\",{\"1\":{\"463\":1}}],[\"<algortihm>\",{\"1\":{\"352\":1}}],[\"<algorithm>\",{\"1\":{\"65\":1,\"66\":1,\"140\":1,\"141\":1,\"146\":1,\"173\":1,\"174\":1,\"206\":1,\"223\":1,\"224\":1,\"261\":1,\"262\":1,\"263\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"311\":1,\"324\":1,\"330\":1,\"376\":1,\"384\":1,\"394\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1}}],[\"<ai\",{\"1\":{\"146\":1}}],[\"<10000000000\",{\"1\":{\"104\":1}}],[\"<<abc\",{\"1\":{\"1110\":1}}],[\"<<eof\",{\"1\":{\"1110\":1}}],[\"<<\",{\"1\":{\"65\":2,\"66\":2,\"76\":4,\"77\":6,\"109\":3,\"110\":3,\"119\":3,\"120\":2,\"121\":6,\"122\":2,\"139\":2,\"140\":2,\"141\":2,\"142\":2,\"146\":2,\"147\":6,\"172\":2,\"173\":2,\"174\":18,\"194\":2,\"197\":2,\"200\":2,\"203\":2,\"206\":12,\"223\":2,\"224\":2,\"228\":2,\"229\":2,\"230\":2,\"235\":4,\"236\":4,\"237\":4,\"251\":5,\"261\":2,\"262\":4,\"263\":2,\"274\":4,\"278\":2,\"279\":2,\"287\":3,\"288\":2,\"289\":2,\"290\":2,\"291\":2,\"296\":4,\"297\":4,\"298\":8,\"299\":4,\"301\":4,\"302\":6,\"303\":2,\"304\":2,\"305\":2,\"306\":2,\"307\":2,\"308\":4,\"311\":7,\"312\":4,\"324\":2,\"330\":4,\"337\":1,\"338\":2,\"339\":3,\"352\":2,\"368\":9,\"376\":2,\"389\":2,\"392\":3,\"422\":1,\"427\":2,\"428\":2,\"429\":2,\"430\":2,\"431\":2,\"1110\":1,\"1239\":1,\"1242\":1,\"1268\":3,\"1274\":6,\"1275\":1}}],[\"<\",{\"1\":{\"65\":4,\"66\":7,\"70\":5,\"71\":1,\"72\":2,\"76\":1,\"77\":2,\"82\":1,\"83\":2,\"88\":2,\"92\":5,\"97\":1,\"99\":1,\"103\":3,\"104\":2,\"108\":3,\"109\":3,\"110\":1,\"119\":2,\"120\":1,\"121\":3,\"122\":3,\"126\":1,\"127\":1,\"128\":2,\"129\":1,\"133\":1,\"134\":1,\"140\":3,\"141\":12,\"142\":2,\"146\":5,\"157\":3,\"162\":3,\"172\":1,\"173\":3,\"174\":5,\"178\":1,\"179\":1,\"180\":3,\"194\":1,\"197\":1,\"203\":1,\"221\":1,\"223\":2,\"224\":7,\"228\":7,\"229\":9,\"230\":6,\"235\":7,\"236\":6,\"237\":6,\"244\":1,\"278\":1,\"279\":4,\"281\":1,\"287\":1,\"289\":1,\"290\":3,\"298\":2,\"299\":5,\"302\":8,\"305\":2,\"307\":1,\"309\":1,\"311\":5,\"312\":5,\"314\":1,\"317\":4,\"318\":1,\"321\":1,\"322\":1,\"324\":2,\"327\":4,\"328\":5,\"329\":2,\"340\":2,\"341\":1,\"342\":1,\"345\":2,\"352\":1,\"354\":2,\"360\":3,\"361\":4,\"367\":1,\"372\":5,\"384\":1,\"385\":7,\"387\":1,\"388\":1,\"389\":3,\"390\":4,\"392\":3,\"410\":1,\"414\":1,\"417\":3,\"423\":3,\"427\":2,\"428\":2,\"429\":4,\"430\":6,\"431\":2,\"471\":2,\"540\":3,\"542\":1,\"548\":4,\"549\":3,\"568\":6,\"575\":2,\"579\":1,\"587\":7,\"588\":2,\"592\":3,\"682\":1,\"705\":1,\"712\":1,\"713\":1,\"767\":5,\"772\":1,\"783\":1,\"795\":1,\"796\":1,\"803\":2,\"820\":4,\"821\":5,\"822\":6,\"828\":1,\"834\":1,\"845\":2,\"846\":1,\"851\":7,\"852\":6,\"857\":2,\"870\":9,\"875\":1,\"876\":2,\"893\":2,\"894\":4,\"899\":3,\"931\":1,\"984\":3,\"988\":2,\"989\":2,\"990\":3,\"992\":1,\"994\":3,\"999\":5,\"1000\":3,\"1005\":1,\"1007\":1,\"1018\":1,\"1047\":2,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":1,\"1069\":1,\"1090\":3,\"1099\":1,\"1203\":2,\"1206\":2,\"1209\":2,\"1232\":1,\"1233\":1,\"1242\":1,\"1250\":1,\"1270\":2,\"1271\":1,\"1273\":1,\"1274\":3,\"1275\":6,\"1306\":2,\"1309\":1,\"1351\":1,\"1359\":1,\"1370\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":2,\"1449\":2,\"1482\":2,\"1496\":1,\"1506\":1,\"1510\":1}}],[\"<=\",{\"1\":{\"56\":1,\"65\":1,\"72\":1,\"97\":1,\"103\":1,\"110\":2,\"115\":3,\"126\":2,\"127\":3,\"128\":1,\"135\":1,\"142\":4,\"152\":1,\"157\":2,\"162\":1,\"167\":2,\"174\":5,\"178\":1,\"180\":2,\"182\":1,\"194\":4,\"197\":7,\"200\":2,\"203\":1,\"206\":4,\"221\":2,\"245\":1,\"261\":1,\"262\":2,\"263\":5,\"269\":1,\"273\":3,\"274\":2,\"278\":4,\"281\":1,\"288\":2,\"289\":2,\"290\":1,\"291\":3,\"296\":5,\"297\":5,\"298\":11,\"299\":3,\"301\":7,\"302\":4,\"303\":2,\"304\":5,\"305\":5,\"306\":4,\"307\":6,\"308\":5,\"309\":13,\"311\":1,\"314\":2,\"318\":5,\"322\":2,\"323\":1,\"345\":2,\"349\":2,\"352\":2,\"354\":1,\"356\":1,\"358\":5,\"360\":3,\"361\":1,\"362\":1,\"363\":1,\"367\":1,\"368\":1,\"369\":3,\"371\":2,\"373\":2,\"375\":1,\"376\":1,\"379\":1,\"380\":2,\"385\":1,\"387\":1,\"389\":3,\"390\":2,\"407\":1,\"409\":1,\"410\":2,\"411\":2,\"414\":1,\"415\":1,\"416\":1,\"417\":2,\"421\":1,\"427\":2,\"428\":3,\"430\":1,\"523\":1,\"783\":1,\"784\":1,\"796\":2,\"797\":2,\"840\":2,\"857\":1,\"870\":2,\"893\":1,\"894\":2,\"900\":1,\"901\":2,\"931\":1,\"984\":3,\"988\":1,\"990\":1,\"993\":1,\"994\":1,\"999\":1,\"1010\":1,\"1011\":1,\"1023\":1,\"1201\":1,\"1243\":2,\"1274\":3,\"1275\":2,\"1337\":1,\"1346\":1,\"1506\":1,\"1508\":2}}],[\"输入一整行字符串\",{\"1\":{\"1006\":1}}],[\"输入一个\",{\"1\":{\"999\":1}}],[\"输入一个年份\",{\"1\":{\"984\":1}}],[\"输入一个0到100之间的分数\",{\"1\":{\"984\":1}}],[\"输入一个迭代器\",{\"1\":{\"422\":1}}],[\"输入一个二维数组\",{\"1\":{\"228\":1}}],[\"输入一个整数\",{\"1\":{\"115\":1,\"182\":1,\"287\":1,\"984\":1}}],[\"输入字符串\",{\"1\":{\"1006\":1}}],[\"输入与输出\",{\"0\":{\"1006\":1}}],[\"输入三个数\",{\"1\":{\"985\":1}}],[\"输入三个整数\",{\"1\":{\"984\":1}}],[\"输入两个整数\",{\"1\":{\"984\":1}}],[\"输入规模较大时使用\",{\"1\":{\"981\":1}}],[\"输入规模较小时使用\",{\"1\":{\"981\":1}}],[\"输入想要配置的域名\",{\"1\":{\"672\":1}}],[\"输入管理员账号密码进入\",{\"1\":{\"670\":1}}],[\"输入代理的\",{\"1\":{\"665\":1}}],[\"输入以下命令初始化前端\",{\"1\":{\"559\":1}}],[\"输入用户名和密码以及验证码后\",{\"1\":{\"447\":1}}],[\"输入的参数是pair或者迭代器\",{\"1\":{\"422\":1}}],[\"输入的第一行为需要检测匹配的用例数\",{\"1\":{\"127\":1}}],[\"输入的第一行给出一个整数\",{\"1\":{\"76\":1}}],[\"输入是一个数x\",{\"1\":{\"422\":1}}],[\"输入占一行\",{\"1\":{\"224\":1,\"279\":1}}],[\"输入样例3\",{\"1\":{\"262\":1}}],[\"输入样例2\",{\"1\":{\"262\":1,\"280\":1,\"291\":1}}],[\"输入样例1\",{\"1\":{\"262\":1,\"280\":1,\"291\":1}}],[\"输入样例\",{\"1\":{\"223\":1,\"224\":1,\"261\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"304\":1}}],[\"输入格式\",{\"1\":{\"223\":1,\"224\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"304\":1,\"305\":1,\"339\":1,\"384\":1}}],[\"输入包含一个整数\",{\"1\":{\"161\":1}}],[\"输入包含多组测试数据\",{\"1\":{\"156\":1}}],[\"输入第二行包含\",{\"1\":{\"157\":1}}],[\"输入第一行包含两个正整数\",{\"1\":{\"157\":1}}],[\"输入第一行包含一个正整数\",{\"1\":{\"156\":1}}],[\"输入为一个整型数组\",{\"1\":{\"108\":1}}],[\"输入为一个简单的数学表达式字符串\",{\"1\":{\"83\":1}}],[\"输入为一个简单的文本字符串\",{\"1\":{\"82\":1}}],[\"输入为\",{\"1\":{\"83\":1}}],[\"输入为简单的数学表达式字符串\",{\"1\":{\"83\":1}}],[\"输入\",{\"0\":{\"981\":1},\"1\":{\"70\":1,\"71\":1,\"72\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"92\":1,\"93\":1,\"97\":1,\"98\":1,\"99\":1,\"104\":1,\"108\":1,\"109\":1,\"119\":1,\"120\":1,\"121\":2,\"122\":2,\"134\":1,\"135\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"157\":1,\"161\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":1,\"193\":1,\"196\":1,\"199\":1,\"202\":1,\"205\":1,\"390\":1,\"559\":1,\"587\":1,\"663\":1,\"681\":1,\"999\":1}}],[\"输入中的每个日程区间为\",{\"1\":{\"70\":1}}],[\"输入描述\",{\"1\":{\"65\":1,\"66\":1,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"156\":1,\"157\":1,\"161\":1,\"162\":1,\"166\":1,\"167\":1,\"168\":1,\"172\":1,\"173\":1,\"174\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":1,\"193\":1,\"196\":1,\"199\":1,\"202\":1,\"205\":1}}],[\"输出3\",{\"1\":{\"1117\":1}}],[\"输出yxcacwing\",{\"1\":{\"1113\":1}}],[\"输出yxc\",{\"1\":{\"1113\":2}}],[\"输出yes\",{\"1\":{\"235\":1}}],[\"输出二维数组\",{\"1\":{\"1000\":1}}],[\"输出三个数中的最大值\",{\"1\":{\"985\":1}}],[\"输出三个数中最大的那个\",{\"1\":{\"984\":1}}],[\"输出c\",{\"1\":{\"984\":1}}],[\"输出b\",{\"1\":{\"984\":1}}],[\"输出a\",{\"1\":{\"984\":1}}],[\"输出两个数中较大的那个\",{\"1\":{\"984\":1}}],[\"输出这个数的绝对值\",{\"1\":{\"984\":1}}],[\"输出规模较大时使用\",{\"1\":{\"982\":1}}],[\"输出规模较小时使用\",{\"1\":{\"982\":1}}],[\"输出字符串\",{\"1\":{\"982\":2}}],[\"输出整数\",{\"1\":{\"982\":2}}],[\"输出中的链表\",{\"1\":{\"886\":1}}],[\"输出选择的点的最小数量\",{\"1\":{\"427\":1}}],[\"输出选取的元组最大的价格之和\",{\"1\":{\"140\":1}}],[\"输出以0开始的匹配子串的首字母下标\",{\"1\":{\"411\":1}}],[\"输出最小非负整数\",{\"1\":{\"384\":1}}],[\"输出最少操作次数\",{\"1\":{\"122\":1}}],[\"输出i的s次幂\",{\"1\":{\"368\":1}}],[\"输出即可\",{\"1\":{\"368\":1}}],[\"输出如下\",{\"1\":{\"339\":1}}],[\"输出共\",{\"1\":{\"305\":1}}],[\"输出输入数字用数码\",{\"1\":{\"291\":1}}],[\"输出方案\",{\"1\":{\"288\":1}}],[\"输出空行\",{\"1\":{\"287\":1,\"1115\":1}}],[\"输出所有可能的次序\",{\"1\":{\"288\":1}}],[\"输出所有可能的选择方案\",{\"1\":{\"287\":1,\"289\":1}}],[\"输出所得到的最大分数\",{\"1\":{\"178\":1}}],[\"输出不会被截断\",{\"1\":{\"243\":1}}],[\"输出时\",{\"1\":{\"243\":1}}],[\"输出no\",{\"1\":{\"235\":1}}],[\"输出任意一种合法方案即可\",{\"1\":{\"224\":1}}],[\"输出样例3\",{\"1\":{\"262\":1}}],[\"输出样例2\",{\"1\":{\"262\":1,\"280\":1,\"291\":1}}],[\"输出样例1\",{\"1\":{\"262\":1,\"280\":1,\"291\":1}}],[\"输出样例\",{\"1\":{\"223\":1,\"224\":1,\"261\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"304\":1}}],[\"输出占一行\",{\"1\":{\"223\":1,\"224\":1,\"279\":1}}],[\"输出格式\",{\"1\":{\"223\":1,\"224\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"304\":1,\"305\":1,\"339\":1,\"384\":1}}],[\"输出出现次数大于等于数组长度一半的数\",{\"1\":{\"179\":1}}],[\"输出编号较小的那个\",{\"1\":{\"168\":1}}],[\"输出包含一行\",{\"1\":{\"157\":1}}],[\"输出包含一行一个整数\",{\"1\":{\"120\":1}}],[\"输出包含\",{\"1\":{\"156\":1,\"196\":1}}],[\"输出个位数\",{\"1\":{\"139\":1}}],[\"输出大于\",{\"1\":{\"121\":1}}],[\"输出变量名相应的骆驼命名法\",{\"1\":{\"98\":1}}],[\"输出为\",{\"1\":{\"83\":2,\"115\":2}}],[\"输出为输入数学表达式计算结果\",{\"1\":{\"83\":1}}],[\"输出压缩后的字符串\",{\"1\":{\"82\":1}}],[\"输出左端点最小的区间\",{\"1\":{\"78\":1}}],[\"输出结果为\",{\"1\":{\"1254\":1,\"1284\":1,\"1337\":1,\"1340\":1}}],[\"输出结果\",{\"1\":{\"77\":1,\"126\":1,\"236\":1,\"237\":1,\"1207\":1,\"1211\":1,\"1336\":1,\"1385\":1,\"1386\":1,\"1387\":1,\"1388\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":1,\"1409\":1,\"1410\":1,\"1411\":1}}],[\"输出\",{\"0\":{\"982\":1},\"1\":{\"70\":1,\"71\":1,\"72\":1,\"76\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"92\":1,\"93\":1,\"97\":1,\"98\":1,\"99\":1,\"104\":1,\"108\":1,\"109\":1,\"119\":2,\"120\":1,\"121\":1,\"122\":1,\"126\":1,\"134\":1,\"135\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"157\":1,\"161\":1,\"168\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":2,\"193\":1,\"196\":1,\"199\":1,\"202\":1,\"205\":2,\"243\":2,\"262\":1,\"274\":1,\"984\":1,\"1117\":2}}],[\"输出一个正整数\",{\"1\":{\"263\":1}}],[\"输出一个正整数表示所查的排名\",{\"1\":{\"129\":1}}],[\"输出一个数\",{\"1\":{\"87\":1}}],[\"输出一个整数表示答案\",{\"1\":{\"126\":1,\"167\":1,\"202\":1}}],[\"输出一个整数\",{\"1\":{\"65\":1,\"104\":1,\"161\":1,\"162\":1,\"166\":1,\"261\":1,\"262\":1,\"278\":1,\"290\":1,\"304\":1}}],[\"输出一行\",{\"1\":{\"103\":1,\"147\":1,\"273\":1}}],[\"输出一行两个整数\",{\"1\":{\"78\":1}}],[\"输出一行一个正整数\",{\"1\":{\"66\":1}}],[\"输出描述\",{\"1\":{\"65\":1,\"66\":1,\"76\":1,\"77\":1,\"78\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"156\":1,\"157\":1,\"161\":1,\"162\":1,\"166\":1,\"167\":1,\"168\":1,\"172\":1,\"173\":1,\"174\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":1,\"193\":1,\"196\":1,\"199\":1,\"202\":1,\"205\":1}}],[\"个语句是原子操作\",{\"1\":{\"1482\":1}}],[\"个学生\",{\"1\":{\"1398\":1}}],[\"个同学能够拿到笔并填写表格\",{\"1\":{\"1398\":1}}],[\"个同学到讲台上来填写一个表格\",{\"1\":{\"1398\":1}}],[\"个同学需要填写一张表格但是只有一支笔\",{\"1\":{\"1313\":1}}],[\"个运动员\",{\"1\":{\"1393\":2}}],[\"个运动员就类比成线程的话\",{\"1\":{\"1393\":1}}],[\"个运动员在比赛开始的时候都站在起点\",{\"1\":{\"1393\":1}}],[\"个运动员可以类比成\",{\"1\":{\"1392\":1}}],[\"个运动员分别计时\",{\"1\":{\"1392\":1}}],[\"个运动员参与比赛\",{\"1\":{\"1392\":1}}],[\"个散列桶\",{\"1\":{\"1272\":1}}],[\"个线程就相当于\",{\"1\":{\"1393\":1}}],[\"个线程都必须到达指定点\",{\"1\":{\"1393\":1}}],[\"个线程进行扩容操作\",{\"1\":{\"1266\":1}}],[\"个线程的时候查看\",{\"1\":{\"1250\":1}}],[\"个线程\",{\"1\":{\"1250\":1,\"1337\":1,\"1392\":1,\"1393\":1,\"1398\":2,\"1407\":1,\"1429\":1,\"1449\":1,\"1482\":1,\"1496\":1}}],[\"个以上的内核\",{\"1\":{\"1218\":1}}],[\"个新注册的租约\",{\"1\":{\"1196\":1}}],[\"个取消的租约\",{\"0\":{\"1196\":1},\"1\":{\"1196\":1}}],[\"个奇偶校验块\",{\"1\":{\"1095\":1}}],[\"个奇数和\",{\"1\":{\"87\":2}}],[\"个指针\",{\"1\":{\"958\":1}}],[\"个硬币选或不选\",{\"1\":{\"893\":1}}],[\"个硬币中选一些硬币\",{\"1\":{\"893\":3}}],[\"个硬币\",{\"1\":{\"893\":2}}],[\"个符合要求的路径\",{\"1\":{\"881\":1}}],[\"个方向上相邻\",{\"1\":{\"868\":1}}],[\"个方程\",{\"1\":{\"385\":2}}],[\"个子节点\",{\"1\":{\"802\":1}}],[\"个完全平方数\",{\"1\":{\"795\":2}}],[\"个完全平方数中选一些数\",{\"1\":{\"795\":3,\"796\":1}}],[\"个升序链表\",{\"0\":{\"787\":1}}],[\"个结点的引用\",{\"1\":{\"777\":1}}],[\"个结点\",{\"1\":{\"776\":1,\"777\":5}}],[\"个节点组成的链表来表示输入\",{\"1\":{\"886\":1}}],[\"个节点\",{\"1\":{\"710\":1,\"777\":1,\"778\":1,\"875\":1}}],[\"个节点一组进行翻转\",{\"1\":{\"680\":1}}],[\"个待反转元素\",{\"1\":{\"682\":1}}],[\"个一组翻转链表\",{\"0\":{\"679\":1}}],[\"个系统设计中的取舍\",{\"1\":{\"620\":1}}],[\"个哈希值\",{\"1\":{\"613\":1}}],[\"个接口\",{\"1\":{\"526\":1}}],[\"个任务\",{\"1\":{\"484\":1,\"1392\":1}}],[\"个闭区间\",{\"1\":{\"430\":1}}],[\"个链表的头结点加入最小堆\",{\"1\":{\"789\":1}}],[\"个链表\",{\"1\":{\"403\":1}}],[\"个不同的质数\",{\"1\":{\"392\":1}}],[\"个未知数的多元线性方程组\",{\"1\":{\"385\":1}}],[\"个未知数的线性方程组\",{\"1\":{\"385\":1}}],[\"个式子合并\",{\"1\":{\"384\":1}}],[\"个质数\",{\"1\":{\"371\":1}}],[\"个顶点的连通块筛选出来\",{\"1\":{\"361\":1}}],[\"个顶点\",{\"1\":{\"359\":1}}],[\"个位\",{\"1\":{\"327\":1,\"328\":1}}],[\"个位置都是\",{\"1\":{\"613\":1}}],[\"个位置都设置为\",{\"1\":{\"613\":1}}],[\"个位置的正方形内的所有目标\",{\"1\":{\"263\":1}}],[\"个位置\",{\"1\":{\"157\":1}}],[\"个物品全不选也是一种方案\",{\"1\":{\"308\":2}}],[\"个长度不超过\",{\"1\":{\"305\":1}}],[\"个空格隔开\",{\"1\":{\"287\":1}}],[\"个空格隔开的整数\",{\"1\":{\"103\":2}}],[\"个操作\",{\"1\":{\"274\":1}}],[\"个目标\",{\"1\":{\"263\":1}}],[\"个值为\",{\"1\":{\"254\":1}}],[\"个点的带权无向图\",{\"1\":{\"312\":1}}],[\"个点\",{\"1\":{\"223\":1,\"351\":1}}],[\"个队列\",{\"1\":{\"205\":1}}],[\"个保质期最长的牛可乐或者牛马克走\",{\"1\":{\"168\":1}}],[\"个瓶子的位置\",{\"1\":{\"166\":1}}],[\"个瓶子\",{\"1\":{\"166\":1}}],[\"个人测试证书\",{\"1\":{\"672\":1}}],[\"个人来\",{\"1\":{\"314\":1}}],[\"个人来到商店购物\",{\"1\":{\"168\":1}}],[\"个人不来\",{\"1\":{\"314\":1}}],[\"个人需要多长时间购买完成\",{\"1\":{\"205\":2}}],[\"个人到达后会选择当前等待时间最少的队伍\",{\"1\":{\"205\":1}}],[\"个人在\",{\"1\":{\"205\":1}}],[\"个人购买的商品编号\",{\"1\":{\"168\":1}}],[\"个人有喜好区间\",{\"1\":{\"168\":1}}],[\"个人\",{\"1\":{\"162\":1,\"205\":1,\"670\":1}}],[\"个人介绍和档案放置在此\",{\"1\":{\"0\":1}}],[\"个小时\",{\"1\":{\"152\":1,\"672\":1}}],[\"个收藏品\",{\"1\":{\"147\":1}}],[\"个收藏品放进这\",{\"1\":{\"147\":1}}],[\"个格子里摆放了\",{\"1\":{\"147\":1}}],[\"个格子之中\",{\"1\":{\"147\":1}}],[\"个游戏节点所花费的时间\",{\"1\":{\"146\":1}}],[\"个游戏节点所花赛的时间\",{\"1\":{\"146\":1}}],[\"个游戏节点\",{\"1\":{\"146\":1}}],[\"个速通记录\",{\"1\":{\"146\":1}}],[\"个单元格的正方形子网格的美观度之和\",{\"1\":{\"141\":1}}],[\"个单元格组成的网格\",{\"1\":{\"141\":1}}],[\"个元素是什么\",{\"1\":{\"777\":1}}],[\"个元素作为\",{\"1\":{\"681\":1}}],[\"个元素和\",{\"1\":{\"274\":1}}],[\"个元素\",{\"1\":{\"269\":1,\"681\":1,\"682\":1,\"712\":1,\"958\":5}}],[\"个元素的和\",{\"1\":{\"261\":1}}],[\"个元素的总和不超过\",{\"1\":{\"122\":1}}],[\"个元素到第\",{\"1\":{\"261\":1}}],[\"个元组的集合\",{\"1\":{\"140\":1}}],[\"个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串\",{\"1\":{\"305\":1}}],[\"个字符串中多少字符串的前缀\",{\"1\":{\"202\":1}}],[\"个字符串\",{\"1\":{\"202\":1}}],[\"个字符\",{\"1\":{\"127\":1}}],[\"个字符是否能匹配模式串\",{\"1\":{\"127\":1}}],[\"个连续的格子组成\",{\"1\":{\"110\":1}}],[\"个房子\",{\"1\":{\"108\":1}}],[\"个数据块\",{\"1\":{\"1095\":1}}],[\"个数按从小到大的顺序输出\",{\"1\":{\"999\":1}}],[\"个数来组合\",{\"1\":{\"381\":1}}],[\"个数的二进制表示中\",{\"1\":{\"339\":1}}],[\"个数的最大和\",{\"1\":{\"104\":2}}],[\"个数表示数列中的第\",{\"1\":{\"339\":1}}],[\"个数必须不重不漏\",{\"1\":{\"291\":1}}],[\"个数划分给\",{\"1\":{\"291\":1}}],[\"个数字\",{\"1\":{\"856\":1}}],[\"个数字和一个\",{\"1\":{\"224\":1,\"279\":1}}],[\"个数字表示数组的各个元素值\",{\"1\":{\"178\":1}}],[\"个数得到和为\",{\"1\":{\"126\":1}}],[\"个数中选择若干个数\",{\"1\":{\"126\":1}}],[\"个数位\",{\"1\":{\"121\":1}}],[\"个数\",{\"1\":{\"99\":1,\"121\":1,\"122\":1,\"126\":1,\"146\":1,\"291\":1,\"381\":1,\"999\":1,\"1315\":1,\"1361\":1}}],[\"个数删除第\",{\"1\":{\"99\":1}}],[\"个偶数\",{\"1\":{\"87\":2}}],[\"个大小写英文字符\",{\"1\":{\"82\":1}}],[\"个整数逆序输出\",{\"1\":{\"999\":1}}],[\"个整数中随机选出\",{\"1\":{\"289\":1}}],[\"个整数中随机选取任意多个\",{\"1\":{\"287\":1}}],[\"个整数排成一行后随机打乱顺序\",{\"1\":{\"288\":1}}],[\"个整数表示\",{\"1\":{\"193\":2}}],[\"个整数表示第\",{\"1\":{\"157\":1}}],[\"个整数是\",{\"1\":{\"157\":1}}],[\"个整数分别为\",{\"1\":{\"147\":1}}],[\"个整数\",{\"1\":{\"78\":2,\"103\":1,\"104\":1,\"126\":1,\"141\":1,\"147\":1,\"157\":1,\"162\":1,\"168\":3,\"174\":1,\"196\":2,\"199\":2,\"262\":1,\"278\":1,\"304\":2,\"308\":1,\"339\":2,\"384\":1,\"999\":1}}],[\"个\",{\"1\":{\"77\":1,\"99\":3,\"174\":1,\"180\":1,\"288\":1,\"289\":2,\"308\":3,\"682\":1,\"886\":1,\"958\":1,\"1190\":2,\"1276\":1,\"1398\":2}}],[\"个正整数\",{\"1\":{\"65\":1,\"66\":1,\"119\":1,\"126\":1,\"128\":2,\"146\":1,\"157\":1,\"173\":1,\"179\":1}}],[\"他的下属所能获得的最大快乐值\",{\"1\":{\"314\":2}}],[\"他下一步就只能前往第\",{\"1\":{\"193\":1}}],[\"他向右走的距离必须是\",{\"1\":{\"193\":1}}],[\"他可以吃掉这个草地上所有的草\",{\"1\":{\"193\":1}}],[\"他会拿走区间中靠前的那个\",{\"1\":{\"168\":1}}],[\"他会同时翻转相邻两个数\",{\"1\":{\"104\":1}}],[\"他只看货架上位于区间里的商品\",{\"1\":{\"168\":1}}],[\"他每次操作可以选择一个数字将其\",{\"1\":{\"167\":1}}],[\"他现在得到了一个数\",{\"1\":{\"161\":1}}],[\"他希望位工人种树的区间长度可能短\",{\"1\":{\"173\":1}}],[\"他希望你来帮他狩猎\",{\"1\":{\"128\":1}}],[\"他希望构造出一个\",{\"1\":{\"119\":1}}],[\"他想知道由\",{\"1\":{\"121\":1}}],[\"他有一个长度为\",{\"1\":{\"104\":1}}],[\"他能够选择的区间最长是多少\",{\"1\":{\"66\":1}}],[\"他需要对当前所处的地形进行调查\",{\"1\":{\"66\":1}}],[\"他最少以要花多少钱\",{\"1\":{\"65\":1}}],[\"他们将摩尔定律的责任推给了软件开发者\",{\"1\":{\"1218\":1}}],[\"他们为了进一步提升计算速度\",{\"1\":{\"1218\":1}}],[\"他们两者之间一对一的关系\",{\"1\":{\"938\":1}}],[\"他们可能需要有更全面的数据访问权限\",{\"1\":{\"470\":1}}],[\"他们需要查看整个子公司的数据\",{\"1\":{\"470\":1}}],[\"他们只算一种方案\",{\"1\":{\"135\":1}}],[\"他们排名也相同\",{\"1\":{\"129\":1}}],[\"他们使用自己研发的拉链存储来组织索引\",{\"1\":{\"58\":1}}],[\"他们会共享服务层的存储层\",{\"1\":{\"46\":1}}],[\"现代处理器采用了指令级并行技术来将多条指令重叠执行\",{\"1\":{\"1418\":1}}],[\"现代操作系统基本采用时分的形式调度运行的线程\",{\"1\":{\"1339\":1}}],[\"现成的管理系统\",{\"1\":{\"557\":1}}],[\"现将花坛被划分成有\",{\"1\":{\"141\":1}}],[\"现购买了\",{\"1\":{\"141\":1}}],[\"现在看这段代码\",{\"1\":{\"1510\":1}}],[\"现在通过学习源码的方式\",{\"1\":{\"1506\":1}}],[\"现在将这几种情况归纳整理一下\",{\"1\":{\"1465\":1}}],[\"现在能够读出\",{\"1\":{\"1458\":1}}],[\"现在已经\",{\"1\":{\"1458\":1}}],[\"现在已经定位到队列真正的队尾节点\",{\"1\":{\"1283\":1}}],[\"现在大概的理解就是\",{\"1\":{\"1453\":1}}],[\"现在只需要扫描下就可以完成付款了\",{\"1\":{\"1434\":1}}],[\"现在对于文章开头的问题\",{\"1\":{\"1458\":1}}],[\"现在对\",{\"1\":{\"1316\":1}}],[\"现在写线程想往数组中添加数据\",{\"1\":{\"1295\":1}}],[\"现在回过头来看\",{\"1\":{\"1284\":1}}],[\"现在回过头再来看\",{\"1\":{\"1251\":1}}],[\"现在来看一看\",{\"1\":{\"1432\":1}}],[\"现在来看看共享锁是怎样实现的\",{\"1\":{\"1510\":1}}],[\"现在来看看\",{\"1\":{\"1258\":1}}],[\"现在来看看读锁\",{\"1\":{\"1242\":1}}],[\"现在来对\",{\"1\":{\"1301\":1}}],[\"现在来做一个总结\",{\"1\":{\"1284\":1}}],[\"现在来做一些总结\",{\"1\":{\"1272\":1}}],[\"现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的\",{\"1\":{\"1507\":1}}],[\"现在我们已经很清楚获取独占式锁失败的线程包装成\",{\"1\":{\"1504\":1}}],[\"现在我们来换一个角度进行考虑\",{\"1\":{\"1466\":1}}],[\"现在我们来重点关注2\",{\"1\":{\"1432\":1}}],[\"现在我们来看下\",{\"1\":{\"1370\":1}}],[\"现在我们对\",{\"1\":{\"1370\":1}}],[\"现在我们通过看源码的方式来理解\",{\"1\":{\"1292\":1}}],[\"现在我们可以得出结论\",{\"1\":{\"1252\":1}}],[\"现在我们可以得出另外一个结论\",{\"1\":{\"1239\":1}}],[\"现在我们回过头来看写锁获取方法\",{\"1\":{\"1239\":1}}],[\"现在这个问题的答案就已经被我们弄清楚了\",{\"1\":{\"1239\":1}}],[\"现在就可以得出来一个结论\",{\"1\":{\"1239\":1}}],[\"现在是所有对象都被\",{\"1\":{\"1131\":1}}],[\"现在是需要什么东西让别人\",{\"1\":{\"1129\":1}}],[\"现在在看上面那四个问题\",{\"1\":{\"1129\":1}}],[\"现在整个链表都成功翻转了\",{\"1\":{\"694\":1}}],[\"现在请你求出\",{\"1\":{\"306\":1}}],[\"现在请问\",{\"1\":{\"193\":1}}],[\"现在要将\",{\"1\":{\"306\":1}}],[\"现在又让他们研究最长公共上升子序列了\",{\"1\":{\"304\":1}}],[\"现在又多了一个\",{\"1\":{\"261\":1}}],[\"现在小美希望公路上至少有\",{\"1\":{\"173\":1}}],[\"现在小a想知道\",{\"1\":{\"65\":1}}],[\"现在有若干家族图谱关系\",{\"1\":{\"273\":1}}],[\"现在有一种新型的激光炸弹\",{\"1\":{\"263\":1}}],[\"现在有一个并查集\",{\"1\":{\"274\":1}}],[\"现在有一个\",{\"1\":{\"196\":1}}],[\"现在有一排\",{\"1\":{\"193\":1}}],[\"现在有\",{\"1\":{\"168\":1,\"202\":1,\"1313\":1}}],[\"现在李华要对这块画布进行\",{\"1\":{\"157\":1}}],[\"现在你要搭配\",{\"1\":{\"152\":1}}],[\"现在你要搭配一些咖啡套餐\",{\"1\":{\"152\":1}}],[\"现在可以执行任意次修改\",{\"1\":{\"122\":1}}],[\"现在一个数组\",{\"1\":{\"114\":1}}],[\"现在给定一个正整数\",{\"1\":{\"308\":1}}],[\"现在给你\",{\"1\":{\"196\":1}}],[\"现在给你列出一个商品的价格集合\",{\"1\":{\"109\":1}}],[\"现在给出k个操作\",{\"1\":{\"77\":1}}],[\"现在\",{\"1\":{\"70\":1,\"224\":1,\"262\":1,\"279\":1,\"281\":1,\"1399\":1}}],[\"现象\",{\"1\":{\"48\":1,\"1233\":1,\"1408\":1,\"1417\":1}}],[\"次才算成功释放\",{\"1\":{\"1232\":1}}],[\"次磁盘\",{\"1\":{\"958\":1}}],[\"次哈希值的位置上都为\",{\"1\":{\"613\":1}}],[\"次哈希计算发现这\",{\"1\":{\"613\":1}}],[\"次后变为一个式子\",{\"1\":{\"384\":1}}],[\"次之后\",{\"1\":{\"354\":1,\"1232\":1}}],[\"次询问\",{\"1\":{\"196\":1,\"202\":1,\"305\":1}}],[\"次或直到无法找到更多符合条件的商品\",{\"1\":{\"168\":1}}],[\"次染色结束后画布上的颜色种类数\",{\"1\":{\"157\":1}}],[\"次染色将会把编号不大于\",{\"1\":{\"157\":1}}],[\"次染色\",{\"1\":{\"157\":1}}],[\"次速通记录中\",{\"1\":{\"146\":1}}],[\"次方\",{\"1\":{\"1270\":1}}],[\"次方这个可能非常大的数\",{\"1\":{\"139\":1}}],[\"次方的个位数是多少\",{\"1\":{\"139\":1}}],[\"次操作后数组变成了什么样子\",{\"1\":{\"199\":1}}],[\"次操作\",{\"1\":{\"103\":1,\"129\":1,\"156\":1,\"199\":1}}],[\"次\",{\"1\":{\"65\":1,\"104\":1,\"122\":1,\"146\":1,\"167\":1,\"354\":2,\"389\":1,\"1232\":3,\"1239\":1,\"1286\":1,\"1315\":1,\"1392\":1,\"1429\":1,\"1449\":1,\"1482\":1}}],[\"第3行的初始值\",{\"1\":{\"1000\":1}}],[\"第3批\",{\"1\":{\"75\":1}}],[\"第1行的初始值\",{\"1\":{\"1000\":1}}],[\"第1种情况\",{\"1\":{\"954\":1}}],[\"第2行的初始值\",{\"1\":{\"1000\":1}}],[\"第2种情况\",{\"1\":{\"954\":1}}],[\"第2版\",{\"1\":{\"655\":1}}],[\"第六期\",{\"0\":{\"603\":1}}],[\"第五期\",{\"0\":{\"595\":1}}],[\"第五题\",{\"0\":{\"182\":1}}],[\"第i堆物品有ai个\",{\"1\":{\"394\":1}}],[\"第i行j列格子左上部分所有元素的和\",{\"1\":{\"333\":1}}],[\"第四种通过线程池新建线程后面单拎出来\",{\"1\":{\"1330\":1}}],[\"第四个参数\",{\"1\":{\"1119\":2}}],[\"第四期\",{\"0\":{\"583\":1}}],[\"第四步\",{\"1\":{\"174\":1}}],[\"第四场\",{\"1\":{\"171\":1}}],[\"第四题\",{\"0\":{\"122\":1,\"142\":1,\"181\":1}}],[\"第四轮删除了\",{\"1\":{\"99\":1}}],[\"第偶数个元素都是偶数\",{\"1\":{\"87\":1}}],[\"第三层由\",{\"1\":{\"958\":1}}],[\"第三方平台对文件的读取保存都和本地一模一样\",{\"1\":{\"676\":1}}],[\"第三期\",{\"0\":{\"529\":1,\"571\":1}}],[\"第三维枚举决策\",{\"1\":{\"295\":1}}],[\"第三段\",{\"1\":{\"262\":1}}],[\"第三步\",{\"1\":{\"174\":1,\"317\":1}}],[\"第三场\",{\"1\":{\"165\":1}}],[\"第三个参数\",{\"1\":{\"1119\":2}}],[\"第三个为\",{\"1\":{\"142\":1}}],[\"第三个维度表示权值是奇数还是偶数\",{\"1\":{\"120\":1}}],[\"第三轮删除了\",{\"1\":{\"99\":1}}],[\"第三题\",{\"0\":{\"72\":1,\"99\":1,\"110\":1,\"121\":1,\"141\":1,\"180\":1}}],[\"第三行注释\",{\"1\":{\"1110\":3}}],[\"第三行一个整数\",{\"1\":{\"199\":1}}],[\"第三行输入\",{\"1\":{\"168\":1}}],[\"第三行包含\",{\"1\":{\"141\":1,\"304\":1}}],[\"第三行\",{\"1\":{\"65\":1}}],[\"第二趟搜索结束\",{\"1\":{\"1316\":1}}],[\"第二趟所搜先通过\",{\"1\":{\"1316\":1}}],[\"第二部分就是将原来\",{\"1\":{\"1274\":1}}],[\"第二部分是以\",{\"1\":{\"273\":1}}],[\"第二层一共是\",{\"1\":{\"958\":1}}],[\"第二层节点就是记录了字符串索引\",{\"1\":{\"802\":1}}],[\"第二次查询结果\",{\"1\":{\"1201\":2,\"1204\":2,\"1207\":2,\"1211\":2}}],[\"第二次复制\",{\"1\":{\"887\":1}}],[\"第二次专门组装节点\",{\"1\":{\"887\":1}}],[\"第二期\",{\"0\":{\"505\":1,\"563\":1}}],[\"第二维枚举起点\",{\"1\":{\"307\":1}}],[\"第二维枚举体积\",{\"1\":{\"295\":1}}],[\"第二元素\",{\"1\":{\"224\":1}}],[\"第二步调用了\",{\"1\":{\"1146\":1}}],[\"第二步\",{\"1\":{\"174\":1,\"317\":1,\"567\":1}}],[\"第二个参数\",{\"1\":{\"1119\":2}}],[\"第二个实参初始化第二个形参\",{\"1\":{\"1012\":1}}],[\"第二个节点不是另一个链表的头节点\",{\"1\":{\"789\":1}}],[\"第二个元素\",{\"1\":{\"422\":1}}],[\"第二个行动的称为后手\",{\"1\":{\"394\":1}}],[\"第二个为\",{\"1\":{\"139\":1,\"142\":1}}],[\"第二个维度表示长度是奇数还是偶数\",{\"1\":{\"120\":1}}],[\"第二个数字为\",{\"1\":{\"109\":1}}],[\"第二个用户群体的日程区间列表记为\",{\"1\":{\"70\":1}}],[\"第二种情况是当前节点被移动到了同步队列中\",{\"1\":{\"1251\":1}}],[\"第二种方法\",{\"1\":{\"1116\":1}}],[\"第二种写法\",{\"1\":{\"298\":1,\"299\":1,\"1124\":2,\"1125\":2}}],[\"第二种用法\",{\"1\":{\"254\":1}}],[\"第二种\",{\"1\":{\"104\":1}}],[\"第二轮删除了\",{\"1\":{\"99\":1}}],[\"第二行注释\",{\"1\":{\"1110\":3}}],[\"第二行输出所求余数\",{\"1\":{\"330\":1}}],[\"第二行输出达到最终状态所需的区间长度的最小值\",{\"1\":{\"174\":1}}],[\"第二行输入字符串\",{\"1\":{\"120\":1}}],[\"第二行输入\",{\"1\":{\"66\":1,\"122\":1,\"168\":1,\"173\":1,\"174\":1,\"178\":1}}],[\"第二行为\",{\"1\":{\"162\":1}}],[\"第二行包含一个整数\",{\"1\":{\"141\":1}}],[\"第二行包含\",{\"1\":{\"104\":1,\"128\":1,\"262\":1,\"304\":1,\"339\":1}}],[\"第二行\",{\"1\":{\"78\":1,\"103\":1,\"126\":1,\"179\":1}}],[\"第二行四个正整数\",{\"1\":{\"65\":1}}],[\"第二题\",{\"0\":{\"66\":1,\"71\":1,\"98\":1,\"109\":1,\"120\":1,\"140\":1,\"179\":1}}],[\"第一部分是构建一个\",{\"1\":{\"1274\":1}}],[\"第一部分是以\",{\"1\":{\"273\":1}}],[\"第一件事自然而然就是\",{\"1\":{\"1270\":1}}],[\"第一张表存放的是用户的基本信息\",{\"1\":{\"938\":1}}],[\"第一期\",{\"0\":{\"492\":1,\"554\":1}}],[\"第一次查询结果\",{\"1\":{\"1201\":2,\"1204\":2,\"1207\":2,\"1211\":2}}],[\"第一次复制\",{\"1\":{\"887\":1}}],[\"第一次遍历专门克隆节点\",{\"1\":{\"887\":1}}],[\"第一次申请的时候要填个人信息\",{\"1\":{\"672\":1}}],[\"第一次出现的位置\",{\"1\":{\"324\":1}}],[\"第一次循环不能有0\",{\"1\":{\"309\":1}}],[\"第一维通常是枚举区间长度\",{\"1\":{\"307\":1}}],[\"第一维枚举物品\",{\"1\":{\"295\":1}}],[\"第一段\",{\"1\":{\"262\":1}}],[\"第一元素\",{\"1\":{\"224\":1}}],[\"第一年农场中有一只成熟的母牛\",{\"1\":{\"182\":1}}],[\"第一步就是加载配置文件\",{\"1\":{\"1146\":1}}],[\"第一步\",{\"1\":{\"174\":1,\"317\":1,\"567\":1}}],[\"第一个\",{\"1\":{\"1392\":1}}],[\"第一个参数\",{\"1\":{\"1119\":2}}],[\"第一个实参初始化第一个形参\",{\"1\":{\"1012\":1}}],[\"第一个对第二个数取余数\",{\"1\":{\"979\":1}}],[\"第一个数除以第二个数\",{\"1\":{\"979\":1}}],[\"第一个数乘以第二个数\",{\"1\":{\"979\":1}}],[\"第一个数减去第二个数\",{\"1\":{\"979\":1}}],[\"第一个数加上第二个数\",{\"1\":{\"979\":1}}],[\"第一个数字为\",{\"1\":{\"109\":1}}],[\"第一个访问的一定是最右边的节点\",{\"1\":{\"736\":1}}],[\"第一个元素\",{\"1\":{\"422\":1}}],[\"第一个为\",{\"1\":{\"139\":1,\"142\":1}}],[\"第一个维度表示下标\",{\"1\":{\"120\":1}}],[\"第一个用户群体的空闲日程区间列表记为\",{\"1\":{\"70\":1}}],[\"第一种情况是\",{\"1\":{\"1284\":1}}],[\"第一种方法\",{\"1\":{\"1116\":1}}],[\"第一种写法\",{\"1\":{\"298\":1,\"299\":1,\"1124\":2,\"1125\":2}}],[\"第一种用法\",{\"1\":{\"254\":1}}],[\"第一种\",{\"1\":{\"104\":1}}],[\"第一轮删除了\",{\"1\":{\"99\":1}}],[\"第一行又是初始化了一个配置\",{\"1\":{\"1157\":1}}],[\"第一行注释\",{\"1\":{\"1110\":3}}],[\"第一行输出所求的商\",{\"1\":{\"330\":1}}],[\"第一行输入正整数\",{\"1\":{\"263\":1}}],[\"第一行输入两个正整数\",{\"1\":{\"173\":1}}],[\"第一行输入两个整数\",{\"1\":{\"168\":1,\"174\":1}}],[\"第一行输入一个正整数\",{\"1\":{\"88\":1,\"97\":1,\"120\":1,\"178\":1}}],[\"第一行三个正整数\",{\"1\":{\"180\":1}}],[\"第一行四个正整数\",{\"1\":{\"167\":1}}],[\"第一行四个整数\",{\"1\":{\"166\":1}}],[\"第一行包含整数\",{\"1\":{\"141\":1,\"262\":1,\"339\":1}}],[\"第一行包含两个整数\",{\"1\":{\"140\":1,\"223\":1,\"261\":1,\"274\":1,\"278\":1,\"305\":1}}],[\"第一行包含一个正整数\",{\"1\":{\"128\":1}}],[\"第一行包含一个整数\",{\"1\":{\"104\":1,\"280\":1,\"304\":1}}],[\"第一行两个整数\",{\"1\":{\"126\":1,\"162\":1,\"196\":1,\"205\":1}}],[\"第一行两个正整数\",{\"1\":{\"87\":1,\"146\":1}}],[\"第一行\",{\"1\":{\"103\":1,\"121\":1,\"122\":1}}],[\"第一行给出正整数\",{\"1\":{\"77\":1}}],[\"第一行一个整数\",{\"1\":{\"78\":1,\"147\":1,\"193\":1,\"199\":1,\"202\":1}}],[\"第一行一个正整数\",{\"1\":{\"66\":2,\"179\":1}}],[\"第一行一正整数\",{\"1\":{\"65\":1}}],[\"第一题\",{\"0\":{\"65\":1,\"70\":1,\"97\":1,\"108\":1,\"119\":1,\"139\":1,\"178\":1}}],[\"第\",{\"1\":{\"65\":1,\"78\":2,\"129\":2,\"141\":1,\"146\":1,\"157\":3,\"168\":3,\"182\":3,\"193\":1,\"194\":2,\"205\":2,\"280\":3,\"290\":2,\"384\":2,\"772\":1,\"1272\":1,\"1283\":8,\"1284\":4,\"1316\":1,\"1317\":2}}],[\"天的最小花费\",{\"1\":{\"65\":1}}],[\"天需要骑行\",{\"1\":{\"65\":1}}],[\"天都需要骑共享单车\",{\"1\":{\"65\":1}}],[\"天不收费\",{\"1\":{\"65\":4}}],[\"每调用一次就会创建一个新的对象\",{\"1\":{\"1069\":1}}],[\"每页显示条数\",{\"1\":{\"935\":1}}],[\"每页显示记录数\",{\"1\":{\"935\":1}}],[\"每有一个新鲜橘子被腐烂\",{\"1\":{\"869\":1}}],[\"每分钟\",{\"1\":{\"868\":1}}],[\"每间房内都藏有一定的现金\",{\"1\":{\"826\":1}}],[\"每走过一个节点\",{\"1\":{\"821\":1}}],[\"每发现一个新岛屿\",{\"1\":{\"820\":1}}],[\"每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",{\"1\":{\"1482\":1}}],[\"每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作\",{\"1\":{\"1482\":1}}],[\"每当掌握一个新功能时\",{\"1\":{\"983\":1}}],[\"每当我们找到一个节点值最小的节点\",{\"1\":{\"789\":1}}],[\"每当小红经过一个有怪物的道路时\",{\"1\":{\"180\":1}}],[\"每遍历一层时间+1\",{\"1\":{\"870\":1}}],[\"每遍历一层\",{\"1\":{\"749\":1}}],[\"每遍历一个节点就将当前节点的右指针更新为上一个节点\",{\"1\":{\"725\":1}}],[\"每遍历一个节点\",{\"1\":{\"725\":1}}],[\"每两个一组进行递归处理\",{\"1\":{\"693\":1}}],[\"每月会给会员送一些电影券\",{\"1\":{\"475\":1}}],[\"每天会给会员送成长值\",{\"1\":{\"475\":1}}],[\"每天都允许购入任意张vip卡\",{\"1\":{\"65\":1}}],[\"每秒读写数\",{\"1\":{\"436\":1}}],[\"每秒事务数\",{\"1\":{\"436\":1}}],[\"每秒查询数\",{\"1\":{\"436\":1}}],[\"每\",{\"1\":{\"384\":1,\"680\":1}}],[\"每组询问给定三个整数\",{\"1\":{\"389\":1}}],[\"每组物品有若干个\",{\"1\":{\"299\":1}}],[\"每组数据包括三个整数\",{\"1\":{\"263\":1}}],[\"每组数据一行\",{\"1\":{\"98\":1}}],[\"每件物品只能用一次\",{\"1\":{\"772\":1}}],[\"每件物品只能使用无限次\",{\"1\":{\"297\":1,\"893\":1}}],[\"每件物品只能使用一次\",{\"1\":{\"296\":1}}],[\"每件物品有有限个\",{\"1\":{\"298\":1}}],[\"每辆车所搭载的重量\",{\"1\":{\"290\":1}}],[\"每辆缆车上的小猫的重量之和不能超过\",{\"1\":{\"290\":1}}],[\"每只猫的重量\",{\"1\":{\"290\":1}}],[\"每只小母牛\",{\"1\":{\"182\":1}}],[\"每租用一辆缆车\",{\"1\":{\"290\":1}}],[\"每找到一个数量加一\",{\"1\":{\"229\":1}}],[\"每条最短路中至少要包含一条边\",{\"1\":{\"223\":1}}],[\"每块草地\",{\"1\":{\"194\":1}}],[\"每轮游戏都是独立的\",{\"1\":{\"174\":1}}],[\"每批客人人数为\",{\"1\":{\"162\":1}}],[\"每张桌子可以最多容纳\",{\"1\":{\"162\":1}}],[\"每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程\",{\"1\":{\"1506\":1}}],[\"每一次讨论都只有选与不选两种选择\",{\"1\":{\"894\":1}}],[\"每一个\",{\"1\":{\"1218\":1}}],[\"每一个节点\",{\"1\":{\"958\":1}}],[\"每一个格子中有一个数字\",{\"1\":{\"196\":1}}],[\"每一层的节点并不是直接存储了某个字符\",{\"1\":{\"802\":1}}],[\"每一层的节点处理时\",{\"1\":{\"133\":1}}],[\"每一层都从左到右遍历\",{\"1\":{\"737\":1}}],[\"每一位计算的同时需要考虑上一位的进位问题\",{\"1\":{\"699\":1}}],[\"每一行为一个元组的两个值\",{\"1\":{\"140\":1}}],[\"每次使用完\",{\"1\":{\"1320\":1}}],[\"每次\",{\"1\":{\"1315\":1}}],[\"每次重新获取都会对同步状态进行加一的操作\",{\"1\":{\"1232\":1}}],[\"每次插入新的行记录时\",{\"1\":{\"919\":1}}],[\"每次遇到一个岛屿中的陆地\",{\"1\":{\"820\":1}}],[\"每次访问\",{\"1\":{\"687\":1}}],[\"每次请求都不会命中缓存\",{\"1\":{\"613\":1}}],[\"每次构建会越来越慢\",{\"1\":{\"534\":1}}],[\"每次可以移动一步\",{\"1\":{\"396\":1}}],[\"每次可以任选一堆\",{\"1\":{\"394\":1}}],[\"每次异或操作\",{\"1\":{\"394\":1}}],[\"每次将\",{\"1\":{\"362\":1}}],[\"每次将区间长度缩小一半\",{\"1\":{\"320\":1}}],[\"每次迭代选择一条不在集合内的权值最短的边\",{\"1\":{\"361\":1}}],[\"每次迭代找到不在连通块中的距离最近的点\",{\"1\":{\"360\":1}}],[\"每次循环取最大的\",{\"1\":{\"846\":1}}],[\"每次循环遍历所有边\",{\"1\":{\"354\":1}}],[\"每次循环都先将\",{\"1\":{\"317\":1}}],[\"每次备份一下\",{\"1\":{\"354\":1}}],[\"每次只能通过一个线程\",{\"1\":{\"1434\":1}}],[\"每次只能向上下左右四个方向移动\",{\"1\":{\"235\":1}}],[\"每次只有一个线程能够获取对象监视器锁\",{\"1\":{\"1264\":1}}],[\"每次只需判断答案是否需要更新\",{\"1\":{\"323\":1}}],[\"每次比较\",{\"1\":{\"318\":1,\"833\":1}}],[\"每次递归的同时也对\",{\"1\":{\"291\":1}}],[\"每次递归之后都要回溯\",{\"1\":{\"235\":1}}],[\"每次当第三段符合时\",{\"1\":{\"262\":1}}],[\"每次前缀和都取模\",{\"1\":{\"261\":1}}],[\"每次用\",{\"1\":{\"261\":1}}],[\"每次都要执行\",{\"1\":{\"1286\":1}}],[\"每次都让较大的数对较小数取模\",{\"1\":{\"377\":1}}],[\"每次都将面积加一\",{\"1\":{\"230\":1}}],[\"每次都从优先队列中选出代价最小的作为下一个遍历的节点\",{\"1\":{\"213\":1}}],[\"每次从优先队列中选取\",{\"1\":{\"215\":1}}],[\"每次始终选取到终点移动代价最小\",{\"1\":{\"214\":1}}],[\"每次询问给出一个字符串和一个操作次数上限\",{\"1\":{\"305\":1}}],[\"每次询问给你一个字符串\",{\"1\":{\"202\":1}}],[\"每次询问给定一个格子\",{\"1\":{\"196\":1}}],[\"每次询问时房子的主人都会回答\",{\"1\":{\"108\":1}}],[\"每次选择一个元素\",{\"1\":{\"178\":1}}],[\"每次二分后判断\",{\"1\":{\"173\":1}}],[\"每次最多只能拿一个瓶子\",{\"1\":{\"166\":1}}],[\"每次移动的代价为\",{\"1\":{\"166\":1}}],[\"每次操作给定两个数\",{\"1\":{\"199\":1}}],[\"每次操作你可以选择数组中的任意一个元素\",{\"1\":{\"178\":1}}],[\"每次操作将最小的数\",{\"1\":{\"156\":1}}],[\"每次操作可以从\",{\"1\":{\"156\":1}}],[\"每次操作可以选择一个下标\",{\"1\":{\"120\":1}}],[\"每次速通记录可以用一个数组\",{\"1\":{\"146\":1}}],[\"每次修改选择一个下标\",{\"1\":{\"122\":1}}],[\"每次你最多可以往右移动\",{\"1\":{\"110\":1}}],[\"每次你在商店里花费了\",{\"1\":{\"109\":1}}],[\"每隔500毫秒执行一次\",{\"1\":{\"1201\":1}}],[\"每隔一定时间\",{\"1\":{\"1165\":1}}],[\"每隔一定时间执行一次\",{\"1\":{\"479\":1}}],[\"每隔\",{\"1\":{\"99\":1,\"1201\":1}}],[\"每行中\",{\"1\":{\"1109\":1}}],[\"每行包含一个字符串和一个整数\",{\"1\":{\"305\":1}}],[\"每行包含一个字符串\",{\"1\":{\"305\":1}}],[\"每行包含一个大写字母\",{\"1\":{\"274\":1}}],[\"每行包含\",{\"1\":{\"278\":1}}],[\"每行包含三个整数\",{\"1\":{\"223\":1,\"274\":1}}],[\"每行为\",{\"1\":{\"273\":1}}],[\"每行有两个数\",{\"1\":{\"273\":1}}],[\"每行输出一个整数作为结果\",{\"1\":{\"305\":1}}],[\"每行输出一种方案\",{\"1\":{\"287\":1}}],[\"每行输出对应的操作后的坐标\",{\"1\":{\"77\":1}}],[\"每行输入一组数据\",{\"1\":{\"263\":1}}],[\"每行输入两个整数\",{\"1\":{\"174\":1}}],[\"每行两个整数\",{\"1\":{\"162\":1,\"166\":1}}],[\"每行描述一组测试数据\",{\"1\":{\"156\":1}}],[\"每行\",{\"1\":{\"146\":1,\"288\":1,\"289\":1}}],[\"每行一个整数\",{\"1\":{\"290\":1}}],[\"每行一个整数表示对应询问的答案\",{\"1\":{\"196\":1}}],[\"每行一个长度为\",{\"1\":{\"180\":1}}],[\"每行一个\",{\"1\":{\"139\":1,\"142\":1}}],[\"每行一个操作命令\",{\"1\":{\"77\":1}}],[\"每行代表一次操作\",{\"1\":{\"129\":1}}],[\"每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了\",{\"1\":{\"1454\":1}}],[\"每个处理器可以运行一个线程\",{\"1\":{\"1331\":1}}],[\"每个任务最多只能被执行一次\",{\"1\":{\"1376\":1}}],[\"每个任务的执行时间都不同\",{\"1\":{\"1369\":1}}],[\"每个插入操作必须等待另一个线程进行相应的删除操作\",{\"1\":{\"1326\":1}}],[\"每个线程在原值上累加\",{\"1\":{\"1449\":1}}],[\"每个线程执行的\",{\"1\":{\"1392\":1}}],[\"每个线程都自加\",{\"1\":{\"1482\":1}}],[\"每个线程都累加了\",{\"1\":{\"1429\":1}}],[\"每个线程都有属于自己的工作内存\",{\"1\":{\"1417\":1}}],[\"每个线程都有一个优先级\",{\"1\":{\"1339\":1}}],[\"每个线程都会等待前一个线程结束才会继续运行\",{\"1\":{\"1337\":1}}],[\"每个线程都会都拥有自己的\",{\"1\":{\"1299\":1}}],[\"每个线程各用各的\",{\"1\":{\"1313\":1}}],[\"每个线程实例中可以通过\",{\"1\":{\"1305\":1}}],[\"每个桶由\",{\"1\":{\"1264\":1}}],[\"每个方法都会新增一个带有\",{\"1\":{\"1259\":1}}],[\"每个方案占一行\",{\"1\":{\"281\":1}}],[\"每个使用\",{\"1\":{\"1258\":1}}],[\"每个参数分别用双引号括起来的字符串\",{\"1\":{\"1120\":1}}],[\"每个\",{\"1\":{\"1100\":1,\"1417\":1}}],[\"每个对象拥有一个计数器\",{\"1\":{\"1431\":1}}],[\"每个对象都包含了数据本身以及元数据\",{\"1\":{\"1094\":1}}],[\"每个对字符串进行的单个字符的插入\",{\"1\":{\"305\":1}}],[\"每个类可以实现多个接口\",{\"1\":{\"1033\":1}}],[\"每个类只能继承一个类\",{\"1\":{\"1028\":1}}],[\"每个接口可以继承多个接口\",{\"1\":{\"1032\":1}}],[\"每个源文件中\",{\"1\":{\"1026\":1}}],[\"每个常用字符都对应一个\",{\"1\":{\"1004\":1}}],[\"每个元素均匀的分布在哈希桶数组中\",{\"1\":{\"1272\":1}}],[\"每个元素都是大小为4的数组\",{\"1\":{\"1000\":1}}],[\"每个元素是含有4个整数的数组\",{\"1\":{\"1000\":1}}],[\"每个元组里面的值为\",{\"1\":{\"140\":1}}],[\"每个哈希表的槽位\",{\"1\":{\"971\":1}}],[\"每个子节点也会存储\",{\"1\":{\"958\":1}}],[\"每个硬币都可以使用无限次\",{\"1\":{\"893\":1}}],[\"每个节点拥有其前驱和后继节点\",{\"1\":{\"1501\":1}}],[\"每个节点用一个\",{\"1\":{\"886\":1}}],[\"每个节点包含一个额外增加的随机指针\",{\"1\":{\"886\":1}}],[\"每个节点存储该区间内的最大保质期和对应的最小商品编号\",{\"1\":{\"168\":1}}],[\"每个烂橘子都会去扩散腐烂周边的新鲜橘子\",{\"1\":{\"869\":1}}],[\"每个状态都由前面抢与不抢来决定\",{\"1\":{\"828\":1}}],[\"每个搜索到的\",{\"1\":{\"821\":1}}],[\"每个链表都已经按升序排列\",{\"1\":{\"788\":1}}],[\"每个用户的盐值都是随机生成的\",{\"1\":{\"568\":1}}],[\"每个用户群体的日程区间都是成对出现且不相交的\",{\"1\":{\"70\":1}}],[\"每个页面都会生效\",{\"1\":{\"547\":1}}],[\"每个页面\",{\"1\":{\"545\":1}}],[\"每个页面的根元素必须有\",{\"1\":{\"545\":1}}],[\"每个组件根元素必须有\",{\"1\":{\"545\":1}}],[\"每个组件目录内添加\",{\"1\":{\"544\":1}}],[\"每个微信用户在同一家公司\",{\"1\":{\"510\":1}}],[\"每个角色可以被赋予不同的菜单权限和数据权限\",{\"1\":{\"470\":1}}],[\"每个正整数都能够以唯一的方式表示成它的质因数的乘积\",{\"1\":{\"368\":1}}],[\"每个人只有两种状态\",{\"1\":{\"314\":1}}],[\"每个人看到的都不相同\",{\"1\":{\"40\":1}}],[\"每个数都要用到且只出现一次\",{\"1\":{\"291\":1}}],[\"每个数最多使用一次\",{\"1\":{\"121\":1}}],[\"每个目标都有一个价值\",{\"1\":{\"263\":1}}],[\"每个点需要记录达到该点的前一个点的位置\",{\"1\":{\"212\":1}}],[\"每个点最多种一棵树\",{\"1\":{\"173\":1}}],[\"每个单元格可以有以下三个值之一\",{\"1\":{\"868\":1}}],[\"每个单元格中最多只能有一种花卉\",{\"1\":{\"141\":1}}],[\"每个单词之间使用空格间隔\",{\"1\":{\"172\":1}}],[\"每个瓶子的位置为\",{\"1\":{\"166\":1}}],[\"每个套餐里必须包含\",{\"1\":{\"152\":1}}],[\"每个速通记录有\",{\"1\":{\"146\":1}}],[\"每个地块有自己的高度\",{\"1\":{\"128\":1}}],[\"每个变量名长度不超过\",{\"1\":{\"98\":1}}],[\"十一\",{\"0\":{\"1057\":1}}],[\"十\",{\"0\":{\"1050\":1}}],[\"十年卡\",{\"1\":{\"65\":1}}],[\"十二\",{\"1\":{\"60\":1}}],[\"月卡\",{\"1\":{\"65\":1}}],[\"元老级的\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"元注解\",{\"0\":{\"1053\":1}}],[\"元素总是从队列的队头\",{\"1\":{\"1283\":1}}],[\"元素之间用空格隔开\",{\"1\":{\"1122\":1}}],[\"元素就不必实现\",{\"1\":{\"1078\":1}}],[\"元素按自然顺序排序\",{\"1\":{\"1073\":1}}],[\"元素乱序\",{\"1\":{\"1073\":1}}],[\"元素的值均为0\",{\"1\":{\"998\":1}}],[\"元素的数值\",{\"1\":{\"772\":1}}],[\"元素分别是0\",{\"1\":{\"998\":1}}],[\"元素序列\",{\"1\":{\"704\":1}}],[\"元素\",{\"1\":{\"547\":1,\"1268\":1}}],[\"元素存放在下标\",{\"1\":{\"423\":4}}],[\"元数据能够无缝打通\",{\"1\":{\"438\":1}}],[\"元的咖啡饮品的套餐\",{\"1\":{\"152\":1}}],[\"元的咖啡\",{\"1\":{\"152\":3}}],[\"元和\",{\"1\":{\"152\":5}}],[\"元\",{\"1\":{\"65\":5,\"109\":2,\"152\":3}}],[\"到工作内存后\",{\"1\":{\"1482\":1}}],[\"到赛道起点时会报数进行统计\",{\"1\":{\"1393\":1}}],[\"到达终点\",{\"1\":{\"1392\":8}}],[\"到达右下角时血量为1\",{\"1\":{\"180\":1}}],[\"到目前为止\",{\"1\":{\"1251\":2,\"1307\":1}}],[\"到尾部时\",{\"1\":{\"777\":1}}],[\"到这一步之后\",{\"1\":{\"664\":2}}],[\"到这个阶段\",{\"1\":{\"40\":1}}],[\"到终点和我说声\",{\"1\":{\"411\":1}}],[\"到终点\",{\"1\":{\"223\":1,\"312\":1}}],[\"到终点的代价要大\",{\"1\":{\"216\":1}}],[\"到终点的代价\",{\"1\":{\"216\":2}}],[\"到给定数字\",{\"1\":{\"135\":1}}],[\"到第\",{\"1\":{\"129\":1}}],[\"到\",{\"1\":{\"72\":2,\"110\":3,\"126\":2,\"128\":1,\"157\":2,\"166\":1,\"200\":1,\"312\":1,\"371\":1,\"389\":1,\"392\":1,\"434\":1,\"777\":1,\"874\":1,\"886\":1}}],[\"到本地缓存\",{\"1\":{\"61\":1}}],[\"维护的数值进行减一\",{\"1\":{\"1392\":1}}],[\"维护的数值\",{\"1\":{\"1392\":2}}],[\"维护的值最终会变为\",{\"1\":{\"1392\":1}}],[\"维护的值\",{\"1\":{\"1392\":1}}],[\"维护了哈希散列表的若干个桶\",{\"1\":{\"1264\":1}}],[\"维护值和下标\",{\"1\":{\"857\":1}}],[\"维护多个指针\",{\"1\":{\"693\":1}}],[\"维护成本更高\",{\"1\":{\"534\":1}}],[\"维护到祖宗节点距离的并查集\",{\"0\":{\"416\":1}}],[\"维护size的并查集\",{\"0\":{\"415\":1}}],[\"维护某种次序\",{\"1\":{\"340\":1}}],[\"维护两个数组\",{\"1\":{\"66\":1}}],[\"维护办卡和不办卡的情况下每天的最小花费\",{\"1\":{\"65\":1}}],[\"维护一个同步队列\",{\"1\":{\"1506\":1}}],[\"维护一个数组集合\",{\"1\":{\"417\":1}}],[\"维护一个动态数组\",{\"0\":{\"242\":1}}],[\"维护一个dp数组\",{\"1\":{\"142\":1}}],[\"维护一个单调递减的栈\",{\"1\":{\"128\":1}}],[\"维护一个\",{\"1\":{\"61\":1}}],[\"维基百科\",{\"1\":{\"41\":1}}],[\"维基百科对\",{\"1\":{\"21\":1}}],[\"统称为处理器重排序\",{\"1\":{\"1418\":1}}],[\"统计数量\",{\"1\":{\"932\":1}}],[\"统计数组中每个元素出现的频率\",{\"1\":{\"178\":1}}],[\"统计从根节点到当前节点的路径上各个前缀和出现的次数\",{\"1\":{\"881\":1}}],[\"统计新鲜橘子个数\",{\"1\":{\"870\":1}}],[\"统计新鲜橘子数\",{\"1\":{\"870\":1}}],[\"统计叶子节点\",{\"1\":{\"309\":1}}],[\"统计大于10\",{\"1\":{\"309\":1}}],[\"统计1\",{\"1\":{\"309\":1}}],[\"统计封闭岛屿的数目\",{\"1\":{\"229\":1}}],[\"统计每个元素出现的次数\",{\"1\":{\"179\":1}}],[\"统计每个\",{\"1\":{\"61\":1}}],[\"统一的开发规范是至关重要的\",{\"1\":{\"541\":1}}],[\"统一的平台业务逻辑在\",{\"1\":{\"46\":1}}],[\"统一\",{\"1\":{\"61\":1}}],[\"附加一个短时的\",{\"1\":{\"61\":1}}],[\"单线程程序是按程序的顺序来执行的\",{\"1\":{\"1418\":1,\"1420\":1}}],[\"单线程执行角度分析\",{\"1\":{\"1283\":1}}],[\"单线程\",{\"1\":{\"1283\":1,\"1293\":1,\"1418\":1}}],[\"单位秒\",{\"1\":{\"1201\":1}}],[\"单位字节\",{\"1\":{\"243\":3}}],[\"单机情况下\",{\"1\":{\"1158\":1}}],[\"单机\",{\"1\":{\"1158\":1}}],[\"单例的时候\",{\"1\":{\"1150\":1}}],[\"单例的实现方法用的是\",{\"1\":{\"1145\":1}}],[\"单例中\",{\"1\":{\"1149\":1,\"1150\":1}}],[\"单例模式的定义\",{\"0\":{\"963\":1}}],[\"单例模式\",{\"0\":{\"962\":1}}],[\"单引号字符串\",{\"1\":{\"1117\":1}}],[\"单引号中的内容会原样输出\",{\"1\":{\"1117\":1}}],[\"单引号与双引号的区别\",{\"1\":{\"1117\":1}}],[\"单引号定义字符串\",{\"1\":{\"1112\":1}}],[\"单表查询的\",{\"1\":{\"942\":1}}],[\"单精度浮点数值\",{\"1\":{\"920\":1}}],[\"单行注释\",{\"0\":{\"1109\":1},\"1\":{\"908\":1}}],[\"单词拆分\",{\"0\":{\"781\":1},\"1\":{\"781\":1}}],[\"单词查找树\",{\"1\":{\"412\":1}}],[\"单点登录\",{\"1\":{\"648\":1}}],[\"单点故障\",{\"1\":{\"484\":1}}],[\"单元测试库\",{\"1\":{\"557\":1}}],[\"单元测试\",{\"1\":{\"555\":1}}],[\"单链表只能存储当前节点的值和指向下一节点的指针\",{\"1\":{\"403\":1}}],[\"单链表\",{\"0\":{\"403\":1}}],[\"单源最短路\",{\"0\":{\"351\":1}}],[\"单调队列\",{\"0\":{\"410\":1,\"858\":1},\"2\":{\"860\":1}}],[\"单调队列思维\",{\"1\":{\"302\":1}}],[\"单调队列写法\",{\"1\":{\"302\":1}}],[\"单调栈\",{\"0\":{\"407\":1},\"1\":{\"174\":1}}],[\"单进程自适应发现热点\",{\"1\":{\"61\":1}}],[\"单个线程\",{\"1\":{\"1283\":1}}],[\"单个状态的计算时间\",{\"1\":{\"851\":1}}],[\"单个\",{\"1\":{\"457\":2}}],[\"单个页面只有二级列表\",{\"1\":{\"30\":1}}],[\"单个评论列表\",{\"1\":{\"28\":1}}],[\"标量子查询\",{\"0\":{\"948\":1},\"1\":{\"947\":1}}],[\"标度\",{\"1\":{\"920\":2}}],[\"标签列表\",{\"1\":{\"512\":1,\"517\":1}}],[\"标签\",{\"1\":{\"512\":1}}],[\"标题\",{\"1\":{\"511\":2,\"512\":2,\"517\":1}}],[\"标注\",{\"1\":{\"471\":1}}],[\"标号\",{\"1\":{\"312\":1}}],[\"标准兼容\",{\"1\":{\"1095\":1}}],[\"标准库函数\",{\"1\":{\"243\":1}}],[\"标准件\",{\"1\":{\"14\":1}}],[\"标记走过\",{\"1\":{\"876\":1}}],[\"标记了\",{\"1\":{\"875\":1}}],[\"标记当前节点搜索时遍历过的节点\",{\"1\":{\"875\":1}}],[\"标记当前节点对应一个完整字符串\",{\"1\":{\"802\":1}}],[\"标记所有走过的点\",{\"1\":{\"875\":1}}],[\"标记变成烂橘子\",{\"1\":{\"870\":2}}],[\"标记是否尾节点\",{\"1\":{\"803\":1}}],[\"标记是否使用过\",{\"1\":{\"288\":1}}],[\"标记\",{\"1\":{\"373\":1,\"845\":2}}],[\"标记点是否在队列中\",{\"1\":{\"355\":1}}],[\"标记入口已走过\",{\"1\":{\"236\":1,\"237\":1}}],[\"标记默认为0\",{\"1\":{\"235\":1}}],[\"标记为已加入到集合中\",{\"1\":{\"352\":1}}],[\"标记为已访问\",{\"1\":{\"235\":1,\"236\":1,\"237\":1}}],[\"标记为0\",{\"1\":{\"328\":1}}],[\"标记为1\",{\"1\":{\"235\":1,\"328\":1}}],[\"标记数组\",{\"1\":{\"235\":1,\"236\":1,\"237\":1}}],[\"标记最近有一个人投递了同一个\",{\"1\":{\"60\":1}}],[\"跨域问题\",{\"0\":{\"610\":1}}],[\"跨域过滤器\",{\"1\":{\"446\":1}}],[\"跨部门权限\",{\"1\":{\"470\":1}}],[\"跨站请求伪造\",{\"1\":{\"446\":1}}],[\"跨进程的数据回源到存储层\",{\"1\":{\"60\":1}}],[\"跨机房重试\",{\"1\":{\"34\":1}}],[\"利用同步器实现锁的语义\",{\"1\":{\"1494\":1}}],[\"利用程序顺序规则\",{\"1\":{\"1421\":1}}],[\"利用当前\",{\"1\":{\"1306\":1}}],[\"利用独占式锁来保证线程安全的\",{\"1\":{\"1290\":1}}],[\"利用cas方法更新basecount的值\",{\"1\":{\"1275\":1}}],[\"利用cas锁进行更新\",{\"1\":{\"1275\":1}}],[\"利用红黑树快速增删改查的特点提高\",{\"1\":{\"1272\":1}}],[\"利用函数定义\",{\"1\":{\"864\":1}}],[\"利用给出的函数定义\",{\"1\":{\"863\":1}}],[\"利用先序遍历的代码\",{\"1\":{\"725\":1}}],[\"利用二叉搜索树的重要性质\",{\"1\":{\"710\":1}}],[\"利用递归\",{\"1\":{\"694\":1}}],[\"利用已有的函数\",{\"1\":{\"693\":1}}],[\"利用迭代器\",{\"1\":{\"423\":1}}],[\"利用\",{\"1\":{\"58\":1,\"1094\":1,\"1136\":1,\"1220\":1,\"1268\":1,\"1409\":1,\"1467\":1,\"1472\":1}}],[\"利用客户端提供的布局能力\",{\"1\":{\"25\":1}}],[\"我也很喜欢你\",{\"1\":{\"1399\":2}}],[\"我其实暗恋你很久了\",{\"1\":{\"1399\":2}}],[\"我把它理解为\",{\"1\":{\"1306\":1}}],[\"我想这样做的目的不仅仅是为了满足\",{\"1\":{\"1274\":1}}],[\"我可以向婚介提出一个列表\",{\"1\":{\"1131\":1}}],[\"我做了一款vuepress的音乐可视化播放插件\",{\"1\":{\"658\":1}}],[\"我用数组记录一下你的位置\",{\"1\":{\"411\":1}}],[\"我认为\",{\"1\":{\"58\":1}}],[\"我们学习到了独占式锁的获取和释放的过程以及同步队列\",{\"1\":{\"1506\":1}}],[\"我们依旧先是通过看源码的方式\",{\"1\":{\"1501\":1}}],[\"我们再来分析\",{\"1\":{\"1475\":1}}],[\"我们想这个\",{\"1\":{\"1454\":1}}],[\"我们俩的共享数据现在为\",{\"1\":{\"1433\":1}}],[\"我们接下来看看基于\",{\"1\":{\"1433\":1}}],[\"我们接下来就来依次看看几个常用的方法是怎样实现的\",{\"1\":{\"1269\":1}}],[\"我们分析完\",{\"1\":{\"1433\":1}}],[\"我们分这四种情况来充分理解这个方法\",{\"1\":{\"1317\":1}}],[\"我们从三个方面做个总结\",{\"1\":{\"1422\":1}}],[\"我们从控制台的返回看到输出结果和我们的预期一致\",{\"1\":{\"1201\":1,\"1204\":1}}],[\"我们通过模拟上面的运动员的例子\",{\"1\":{\"1393\":1}}],[\"我们通常是把它当作一个结构体使用\",{\"1\":{\"257\":1}}],[\"我们也同样来看看\",{\"1\":{\"1350\":1}}],[\"我们也使用一个优先队列\",{\"1\":{\"214\":1}}],[\"我们自己来写一个例子\",{\"1\":{\"1309\":1}}],[\"我们自然而然最关心的就是读写的时候\",{\"1\":{\"1292\":1}}],[\"我们已经知道了\",{\"1\":{\"1455\":1}}],[\"我们已经知道使用\",{\"1\":{\"1306\":1}}],[\"我们已经找到了答案\",{\"1\":{\"1285\":1}}],[\"我们发现\",{\"1\":{\"1286\":1}}],[\"我们回过头再来看\",{\"1\":{\"1283\":1}}],[\"我们是不是应该最开始做的就是找到队列当前的尾节点在哪里才能插入\",{\"1\":{\"1283\":1}}],[\"我们是如何找女朋友的\",{\"1\":{\"1131\":1}}],[\"我们知道\",{\"1\":{\"1295\":1,\"1417\":1,\"1457\":1,\"1507\":1}}],[\"我们知道对于一个\",{\"1\":{\"1272\":1}}],[\"我们知道在锁机制的实现上\",{\"1\":{\"1250\":1}}],[\"我们按照上面的分解的步骤一步步来看\",{\"1\":{\"1272\":1}}],[\"我们用一个很简单的例子说说\",{\"1\":{\"1254\":1}}],[\"我们用一个数组\",{\"1\":{\"269\":1}}],[\"我们还得看下如何删数据\",{\"1\":{\"1303\":1}}],[\"我们还是先将变量\",{\"1\":{\"1284\":1}}],[\"我们还是先站在单线程的角度去理清该方法的基本逻辑\",{\"1\":{\"1284\":1}}],[\"我们还是从源码的角度去看\",{\"1\":{\"1251\":1}}],[\"我们还可以引入\",{\"1\":{\"540\":1}}],[\"我们几乎会高频率的使用到独占式锁\",{\"1\":{\"1237\":1}}],[\"我们之前说过\",{\"1\":{\"1150\":1}}],[\"我们之所以需要中序遍历前\",{\"1\":{\"712\":1}}],[\"我们必须自己设计和面对每个环节\",{\"1\":{\"1131\":1}}],[\"我们必须要对这个系统的功能以及定位有一个清晰的了解\",{\"1\":{\"44\":1}}],[\"我们到处去看哪里有长得漂亮身材又好的mm\",{\"1\":{\"1131\":1}}],[\"我们来画下存在的一种可能执行时序图\",{\"1\":{\"1475\":1}}],[\"我们来模拟这样一个情景\",{\"1\":{\"1399\":1}}],[\"我们来模拟这样一样场景\",{\"1\":{\"1398\":1}}],[\"我们来模拟下运动员入场时的情况\",{\"1\":{\"1393\":1}}],[\"我们来通过\",{\"1\":{\"1295\":1}}],[\"我们来通过看源码的方式来看这样的猜想是不是对的\",{\"1\":{\"1252\":1}}],[\"我们来写一下\",{\"1\":{\"1284\":1}}],[\"我们来分析一下这行代码\",{\"1\":{\"1283\":1}}],[\"我们来看看第\",{\"1\":{\"1270\":1}}],[\"我们来看看公平锁的处理逻辑是怎样的\",{\"1\":{\"1233\":1}}],[\"我们来看看\",{\"1\":{\"1232\":1,\"1472\":1}}],[\"我们来看下\",{\"1\":{\"1186\":1}}],[\"我们来测试一下缓存服务\",{\"1\":{\"1201\":1}}],[\"我们来细看下\",{\"1\":{\"1158\":1}}],[\"我们来编写一个求阶乘的程序\",{\"1\":{\"1010\":1}}],[\"我们来对这部分的源码进行分析\",{\"1\":{\"481\":1}}],[\"我们都知道如果使用\",{\"1\":{\"1259\":1}}],[\"我们都知道当当前线程调用\",{\"1\":{\"1251\":1}}],[\"我们都是采用直接\",{\"1\":{\"1129\":1}}],[\"我们都要至少执行一次循环\",{\"1\":{\"989\":1}}],[\"我们都在\",{\"1\":{\"51\":1}}],[\"我们平常所说的索引\",{\"1\":{\"958\":1}}],[\"我们写的递归函数\",{\"1\":{\"899\":1}}],[\"我们无需知道\",{\"1\":{\"846\":1}}],[\"我们在第\",{\"1\":{\"1295\":1}}],[\"我们在插入字符串的时候将最后一个字符对应的节点的标志位置为\",{\"1\":{\"802\":1}}],[\"我们在不同阶段对热评的理解\",{\"1\":{\"40\":1}}],[\"我们如何知道找到的这部分是一个完整的字符串还是某个字符串的前缀呢\",{\"1\":{\"802\":1}}],[\"我们先来分析一下不加\",{\"1\":{\"1485\":1}}],[\"我们先来看这样一个例子\",{\"1\":{\"1482\":1}}],[\"我们先来看看什么是不可变类\",{\"1\":{\"1472\":1}}],[\"我们先来看看\",{\"1\":{\"1272\":1}}],[\"我们先来回顾下关于散列表相关的知识\",{\"1\":{\"1306\":1}}],[\"我们先看看\",{\"1\":{\"1283\":1}}],[\"我们先看\",{\"1\":{\"1129\":1}}],[\"我们先让快指针\",{\"1\":{\"777\":1}}],[\"我们先将它们的父节点设为自己\",{\"1\":{\"269\":1}}],[\"我们要避免写出死循环\",{\"1\":{\"988\":1}}],[\"我们要操作某一个数据库下的表时\",{\"1\":{\"914\":1}}],[\"我们要操作某一个数据库\",{\"1\":{\"912\":1}}],[\"我们要在\",{\"1\":{\"687\":1}}],[\"我们要充分利用这个递归函数的定义\",{\"1\":{\"681\":1}}],[\"我们要记录用户的登录态\",{\"1\":{\"574\":1}}],[\"我们新建一个\",{\"1\":{\"580\":1}}],[\"我们每个页面目录内需要添加\",{\"1\":{\"544\":1}}],[\"我们根据需要移动到对应的位置\",{\"1\":{\"516\":1}}],[\"我们会发现\",{\"1\":{\"1250\":1}}],[\"我们会部署多台服务器\",{\"1\":{\"484\":1}}],[\"我们会持续优化产品功能\",{\"1\":{\"41\":1}}],[\"我们只关心\",{\"1\":{\"411\":1}}],[\"我们只需要去和她谈恋爱\",{\"1\":{\"1131\":1}}],[\"我们只需要在任意一方来添加一个外键就可以了\",{\"1\":{\"938\":1}}],[\"我们只需要找到和\",{\"1\":{\"846\":1}}],[\"我们只需要搜索距离区间最近的最大值即可\",{\"1\":{\"174\":1}}],[\"我们只需要记录到达该位置时的最小体力消耗\",{\"1\":{\"142\":1}}],[\"我们关心对于每个不同的下标\",{\"1\":{\"411\":1}}],[\"我们讨论的博弈问题一般都只考虑理想情况\",{\"1\":{\"394\":1}}],[\"我们把这种游戏称为nim博弈\",{\"1\":{\"394\":1}}],[\"我们把咖啡套餐的\",{\"1\":{\"152\":1}}],[\"我们就可以重写\",{\"1\":{\"1469\":1}}],[\"我们就不能重写该方法\",{\"1\":{\"1469\":1}}],[\"我们就只需要告诉\",{\"1\":{\"1132\":1}}],[\"我们就会抛出异常\",{\"1\":{\"1131\":1}}],[\"我们就找到了目标值\",{\"1\":{\"320\":1}}],[\"我们就称这个区间\",{\"1\":{\"261\":1}}],[\"我们其实是希望\",{\"1\":{\"274\":1}}],[\"我们直接用二维数组读入数据\",{\"1\":{\"263\":1}}],[\"我们不能像\",{\"1\":{\"235\":1}}],[\"我们的计算能力会按照指数级别的速度增长\",{\"1\":{\"1218\":1}}],[\"我们的网盘服务将变得不可用\",{\"1\":{\"671\":1}}],[\"我们的目的是通过交换\",{\"1\":{\"224\":1,\"279\":1}}],[\"我们的查询sql可能是\",{\"1\":{\"30\":1}}],[\"我们可能习惯性地认为树的高度就是\",{\"1\":{\"274\":1}}],[\"我们可能未必需要最短路径\",{\"1\":{\"216\":1}}],[\"我们可以知道操作\",{\"1\":{\"1455\":1}}],[\"我们可以完全理解\",{\"1\":{\"1320\":1}}],[\"我们可以尝试使用\",{\"1\":{\"1309\":1}}],[\"我们可以了解到\",{\"1\":{\"1283\":1}}],[\"我们可以多次调用\",{\"1\":{\"1250\":1}}],[\"我们可以理清\",{\"1\":{\"1232\":1}}],[\"我们可以看出\",{\"1\":{\"1141\":1}}],[\"我们可以把题目的输入转化成一幅有向图\",{\"1\":{\"875\":1}}],[\"我们可以统计初始新鲜橘子的个数\",{\"1\":{\"869\":1}}],[\"我们可以将每一个字符串存储到树中\",{\"1\":{\"802\":1}}],[\"我们可以记录每个子树的结点数\",{\"1\":{\"712\":1}}],[\"我们可以总结出\",{\"1\":{\"687\":1}}],[\"我们可以部署多个服务器节点\",{\"1\":{\"484\":1}}],[\"我们可以通过\",{\"1\":{\"261\":1,\"1175\":1,\"1361\":1}}],[\"我们可以使用一个大小为\",{\"1\":{\"178\":1}}],[\"我们可以使用\",{\"1\":{\"129\":1}}],[\"我们可以使用平衡二叉搜索树来实现\",{\"1\":{\"129\":1}}],[\"我们可以使用单调栈来解决\",{\"1\":{\"128\":1}}],[\"我们可以使用滑动窗口和单调队列的思想来解决这个问题\",{\"1\":{\"78\":1}}],[\"我们可以得出这样的结论\",{\"1\":{\"1369\":1}}],[\"我们可以得出等待队列的示意图如下图所示\",{\"1\":{\"1250\":1}}],[\"我们可以得出状态转移方程\",{\"1\":{\"72\":1}}],[\"我们可以得到最终的匹配结果\",{\"1\":{\"127\":1}}],[\"我们可以在进程内设置一个过期时间为\",{\"1\":{\"60\":1}}],[\"我们很难确切算出距离终点还有多远\",{\"1\":{\"216\":1}}],[\"我们总会选取综合优先级最高\",{\"1\":{\"215\":1}}],[\"我们认为如果第\",{\"1\":{\"147\":1}}],[\"我们实际上是在寻找一种最优的花卉分配方案\",{\"1\":{\"141\":1}}],[\"我们遍历从当前数字\",{\"1\":{\"135\":1}}],[\"我们弹出栈中所有比它小的元素\",{\"1\":{\"128\":1}}],[\"我们需要解决三个问题\",{\"1\":{\"1501\":1}}],[\"我们需要一个数据结构\",{\"1\":{\"789\":1}}],[\"我们需要一个能够在\",{\"1\":{\"168\":1}}],[\"我们需要找出\",{\"1\":{\"411\":1}}],[\"我们需要找到从左上角到右下角的最短路径\",{\"1\":{\"180\":1}}],[\"我们需要对结果取模\",{\"1\":{\"182\":1}}],[\"我们需要计算小美从初始位置到每个瓶子的距离\",{\"1\":{\"166\":1}}],[\"我们需要计算从给定的\",{\"1\":{\"126\":1}}],[\"我们需要考虑两个维度\",{\"1\":{\"142\":1}}],[\"我们需要将花朵数量最多的花卉放在能够被最多子网格覆盖的位置\",{\"1\":{\"141\":1}}],[\"我们需要检查\",{\"1\":{\"66\":1}}],[\"我们检查栈顶元素是否与\",{\"1\":{\"93\":1}}],[\"我们检查栈是否为空\",{\"1\":{\"93\":1}}],[\"我们将这种情况称为散列冲突\",{\"1\":{\"1306\":1}}],[\"我们将这样的一种表示称为正整数\",{\"1\":{\"308\":1}}],[\"我们将栈顶元素弹出\",{\"1\":{\"93\":1}}],[\"我们将它压入栈中\",{\"1\":{\"93\":1}}],[\"我们将整个业务数据模型组装\",{\"1\":{\"25\":1}}],[\"我们正在为一个日程安排管理系统开发一个关键功能\",{\"1\":{\"70\":1}}],[\"我们前面讲过使用\",{\"1\":{\"58\":1}}],[\"我们一般都是通过\",{\"1\":{\"1133\":1}}],[\"我们一般使用\",{\"1\":{\"61\":1}}],[\"我们一开始是\",{\"1\":{\"47\":1}}],[\"我们一方面在异常情况下坚决限流熔断\",{\"1\":{\"34\":1}}],[\"我们使用了消息队列来进行逻辑异步化\",{\"1\":{\"48\":1}}],[\"我们使用\",{\"1\":{\"46\":1,\"1186\":1}}],[\"我们往小里做就是视频评论系统\",{\"1\":{\"45\":1}}],[\"我们同样应用了这套热评系统\",{\"1\":{\"40\":1}}],[\"我们仍然在持续优化\",{\"1\":{\"40\":1}}],[\"我们更多依赖\",{\"1\":{\"40\":1}}],[\"我们对\",{\"1\":{\"39\":1}}],[\"我们做了重要级别划分\",{\"1\":{\"34\":1}}],[\"我们进行系统容量设计\",{\"1\":{\"33\":1}}],[\"我们利用这条规则推导下\",{\"1\":{\"1455\":1}}],[\"我们利用\",{\"1\":{\"33\":1}}],[\"我们剖析瓶颈并做了如下优化\",{\"1\":{\"33\":1}}],[\"我们逐步迁移到tidb\",{\"1\":{\"30\":1}}],[\"我们采用的是mysql分表来满足这两个需求\",{\"1\":{\"30\":1}}],[\"我们基于数据库设计进行缓存设计\",{\"1\":{\"31\":1}}],[\"我们基于\",{\"1\":{\"26\":1}}],[\"得出数组的大小\",{\"1\":{\"1271\":1}}],[\"得出每个节点的直径\",{\"1\":{\"760\":1}}],[\"得看被移数是正还是负\",{\"1\":{\"338\":1}}],[\"得到对象锁后\",{\"1\":{\"1407\":1}}],[\"得到状态转移表达式\",{\"1\":{\"851\":1}}],[\"得到状态转移方程\",{\"1\":{\"110\":1}}],[\"得到的价值是\",{\"1\":{\"772\":1}}],[\"得到\",{\"1\":{\"613\":1,\"672\":1,\"675\":1}}],[\"得到了登录成功的\",{\"1\":{\"575\":1}}],[\"得到一个\",{\"1\":{\"575\":1}}],[\"得到该位的被除数\",{\"1\":{\"330\":1}}],[\"得到总区间的最小代价\",{\"1\":{\"307\":1}}],[\"得到三个非空子数组\",{\"1\":{\"262\":1}}],[\"得到正确排列\",{\"1\":{\"224\":1}}],[\"得到在循环中的位置\",{\"1\":{\"139\":1}}],[\"得到排序过后的评论\",{\"1\":{\"58\":1}}],[\"得分\",{\"1\":{\"71\":5}}],[\"得以复用\",{\"1\":{\"40\":1}}],[\"总体来说\",{\"1\":{\"1506\":1}}],[\"总会调用\",{\"1\":{\"1368\":1}}],[\"总之这是一个很有意思的事情\",{\"1\":{\"1283\":1}}],[\"总大小是\",{\"1\":{\"958\":1}}],[\"总记录数\",{\"1\":{\"935\":3}}],[\"总金额为\",{\"1\":{\"893\":1}}],[\"总点数\",{\"1\":{\"356\":1}}],[\"总点数和总边数\",{\"1\":{\"355\":1}}],[\"总共可用的内存\",{\"1\":{\"1194\":1}}],[\"总共第k大变为总共第k+1大\",{\"1\":{\"223\":1}}],[\"总共的笔试时间只有\",{\"1\":{\"152\":1}}],[\"总草数为3+20=23\",{\"1\":{\"193\":1}}],[\"总的来说\",{\"1\":{\"1496\":1}}],[\"总的方案数为\",{\"1\":{\"87\":1}}],[\"总的作用是为处于自己上层的应用软件提供运行与开发的环境\",{\"1\":{\"14\":1}}],[\"总结果必然会是小于\",{\"1\":{\"1482\":1}}],[\"总结下\",{\"1\":{\"1251\":1}}],[\"总结出相应的模板\",{\"1\":{\"234\":1}}],[\"总结出相应的\",{\"1\":{\"227\":1}}],[\"总结\",{\"0\":{\"57\":1,\"1172\":1,\"1185\":1,\"1276\":1,\"1295\":1,\"1371\":1,\"1422\":1,\"1487\":1}}],[\"类继承了\",{\"1\":{\"1493\":1}}],[\"类都是不可变类\",{\"1\":{\"1472\":1}}],[\"类变量\",{\"1\":{\"1465\":1}}],[\"类变量有两个时机赋初值\",{\"1\":{\"1465\":1}}],[\"类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值\",{\"1\":{\"1465\":1}}],[\"类就是一个\",{\"1\":{\"1462\":1}}],[\"类是怎样实现更新的呢\",{\"1\":{\"1385\":1}}],[\"类提供的\",{\"1\":{\"1385\":1}}],[\"类提供了一些底层操作\",{\"1\":{\"1385\":1}}],[\"类来完成\",{\"1\":{\"1359\":1}}],[\"类来注册的\",{\"1\":{\"1184\":1}}],[\"类除了提供\",{\"1\":{\"1337\":1}}],[\"类或\",{\"1\":{\"1330\":1}}],[\"类实现如下\",{\"1\":{\"1493\":1}}],[\"类实现了\",{\"1\":{\"1267\":1,\"1365\":1}}],[\"类实现的\",{\"1\":{\"1266\":1}}],[\"类有这样一个属性\",{\"1\":{\"1250\":1}}],[\"类复用了在\",{\"1\":{\"1250\":1}}],[\"类图如下\",{\"1\":{\"1136\":1}}],[\"类图\",{\"1\":{\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":1,\"1139\":1,\"1140\":1,\"1178\":1}}],[\"类在\",{\"1\":{\"1075\":1,\"1385\":1}}],[\"类却要调用一个\",{\"1\":{\"1068\":1}}],[\"类使用\",{\"1\":{\"1068\":1}}],[\"类用来表示内容可变的字符串\",{\"1\":{\"1068\":1}}],[\"类用来表示那些创建后就不会再改变的字符串\",{\"1\":{\"1068\":1}}],[\"类及其子类\",{\"1\":{\"1044\":1}}],[\"类及其子类异常\",{\"1\":{\"1044\":1}}],[\"类定义一种全新的数据类型\",{\"1\":{\"1025\":1}}],[\"类与对象\",{\"0\":{\"1025\":1}}],[\"类与接口\",{\"0\":{\"1024\":1}}],[\"类可以将变量\",{\"1\":{\"1024\":1}}],[\"类比于\",{\"1\":{\"772\":1}}],[\"类微博点赞系统设计\",{\"1\":{\"649\":1}}],[\"类下编写查询用户接口\",{\"1\":{\"578\":1}}],[\"类中定义的\",{\"1\":{\"1150\":1}}],[\"类中\",{\"1\":{\"1146\":1}}],[\"类中的方法\",{\"1\":{\"1370\":1}}],[\"类中的\",{\"1\":{\"1045\":2,\"1150\":1}}],[\"类中的一个方法\",{\"1\":{\"465\":1}}],[\"类中添加\",{\"1\":{\"465\":1}}],[\"类\",{\"0\":{\"1005\":1,\"1471\":1},\"1\":{\"456\":1,\"462\":1,\"686\":1,\"801\":1,\"1026\":2,\"1037\":1,\"1052\":1,\"1059\":1,\"1075\":2,\"1082\":1,\"1178\":1,\"1248\":1,\"1250\":1,\"1264\":1,\"1267\":1,\"1282\":1,\"1283\":1,\"1330\":1,\"1365\":1,\"1368\":2,\"1370\":1,\"1371\":7,\"1495\":1}}],[\"类的静态方法\",{\"1\":{\"1385\":1}}],[\"类的源码为\",{\"1\":{\"1281\":1}}],[\"类的构造函数调用了一个工具类\",{\"1\":{\"1178\":1}}],[\"类的构造函数中初始化了\",{\"1\":{\"1046\":1}}],[\"类的效率更高\",{\"1\":{\"1068\":1}}],[\"类的多态\",{\"0\":{\"1029\":1}}],[\"类的继承\",{\"0\":{\"1028\":1}}],[\"类的定义\",{\"0\":{\"1027\":1}}],[\"类的类名保持一致\",{\"1\":{\"1026\":1}}],[\"类的一个对象\",{\"1\":{\"1025\":1}}],[\"类的\",{\"1\":{\"450\":1,\"451\":1,\"455\":1,\"461\":1,\"1267\":1,\"1365\":1,\"1392\":1,\"1472\":1}}],[\"类似的还有很多业务场景\",{\"1\":{\"1290\":1}}],[\"类似的图存储思路\",{\"1\":{\"56\":1}}],[\"类似这种方法\",{\"1\":{\"1178\":1}}],[\"类似这样的带分数\",{\"1\":{\"291\":1}}],[\"类似\",{\"1\":{\"1030\":1}}],[\"类似地\",{\"1\":{\"772\":1}}],[\"类似于字符串\",{\"1\":{\"1125\":1}}],[\"类似于\",{\"1\":{\"1082\":1,\"1369\":1}}],[\"类似于c++中的sprintf\",{\"1\":{\"1005\":1}}],[\"类似于栈中的先进后出\",{\"1\":{\"731\":1}}],[\"类似于逆波兰表达式的计算\",{\"1\":{\"83\":1}}],[\"类型的类\",{\"1\":{\"1462\":1}}],[\"类型的\",{\"1\":{\"1150\":1,\"1305\":1}}],[\"类型的对象不止包含字符串\",{\"1\":{\"243\":1}}],[\"类型转换\",{\"1\":{\"1069\":1}}],[\"类型转化\",{\"1\":{\"978\":1}}],[\"类型上都属于\",{\"1\":{\"1044\":1}}],[\"类型校验\",{\"1\":{\"539\":1}}],[\"类型等采用值传递\",{\"1\":{\"1017\":1}}],[\"类型等\",{\"1\":{\"484\":1}}],[\"类型复杂多样\",{\"1\":{\"434\":1}}],[\"类型对象所能包含的最大字符数\",{\"1\":{\"243\":1}}],[\"类型对象最多包含的字符数\",{\"1\":{\"243\":1}}],[\"类型对象中的字符个数\",{\"1\":{\"243\":1}}],[\"类型\",{\"1\":{\"31\":2,\"243\":1,\"471\":1,\"512\":1,\"566\":2,\"576\":1,\"899\":2,\"920\":3,\"922\":2,\"978\":1,\"1239\":1}}],[\"二元组\",{\"1\":{\"1082\":1}}],[\"二者之间可以相互转化\",{\"1\":{\"1004\":1}}],[\"二次探测和双重散列\",{\"1\":{\"971\":1}}],[\"二进制形式的极大文本数据\",{\"1\":{\"920\":1}}],[\"二进制形式的中等长度文本数据\",{\"1\":{\"920\":1}}],[\"二进制形式的长文本数据\",{\"1\":{\"920\":1}}],[\"二进制中1的个数\",{\"1\":{\"339\":1}}],[\"二叉查找树\",{\"1\":{\"958\":3}}],[\"二叉搜索树定义如下\",{\"1\":{\"898\":1}}],[\"二叉搜索树\",{\"1\":{\"813\":1}}],[\"二叉搜索树的中序遍历为递增序列\",{\"1\":{\"710\":1}}],[\"二叉搜索树中第k小的元素\",{\"0\":{\"708\":1},\"1\":{\"708\":1}}],[\"二叉树层序遍历使用\",{\"1\":{\"742\":1}}],[\"二叉树展开为链表\",{\"0\":{\"722\":1},\"1\":{\"722\":1}}],[\"二叉树中的\",{\"1\":{\"717\":1}}],[\"二叉树中的最大路径和\",{\"0\":{\"716\":1},\"1\":{\"716\":1}}],[\"二叉树\",{\"1\":{\"186\":1,\"417\":1},\"2\":{\"190\":1,\"715\":1,\"721\":1,\"727\":1,\"733\":1,\"739\":1,\"745\":1,\"751\":1,\"757\":1,\"763\":1,\"769\":1,\"811\":1,\"817\":1,\"866\":1,\"884\":1,\"903\":1}}],[\"二叉树的直径\",{\"0\":{\"758\":1},\"1\":{\"758\":1}}],[\"二叉树的最近公共祖先\",{\"0\":{\"752\":1},\"1\":{\"752\":1}}],[\"二叉树的最大深度\",{\"0\":{\"746\":1},\"1\":{\"746\":1}}],[\"二叉树的右视图\",{\"0\":{\"734\":1},\"1\":{\"734\":1}}],[\"二叉树的\",{\"1\":{\"729\":1,\"747\":1,\"759\":1}}],[\"二叉树的中序遍历\",{\"0\":{\"728\":1},\"1\":{\"728\":1}}],[\"二叉树的结点数\",{\"1\":{\"133\":1}}],[\"二叉树的层序遍历\",{\"0\":{\"133\":1,\"740\":1},\"1\":{\"740\":1}}],[\"二级域名\",{\"1\":{\"672\":1}}],[\"二级列表\",{\"1\":{\"56\":1}}],[\"二维差分\",{\"0\":{\"335\":1}}],[\"二维前缀和\",{\"0\":{\"333\":1}}],[\"二维会爆栈\",{\"1\":{\"263\":1}}],[\"二维\",{\"1\":{\"254\":1,\"296\":1,\"297\":1}}],[\"二\",{\"0\":{\"983\":1,\"1146\":1,\"1181\":1},\"1\":{\"200\":1,\"299\":1,\"302\":1}}],[\"二分优化\",{\"0\":{\"852\":1}}],[\"二分图\",{\"1\":{\"362\":2}}],[\"二分求出x对应的离散化的值\",{\"1\":{\"341\":1}}],[\"二分模板一共有两个\",{\"1\":{\"320\":1}}],[\"二分查找算法模板\",{\"0\":{\"320\":1}}],[\"二分算法\",{\"0\":{\"319\":1}}],[\"二分写法\",{\"1\":{\"302\":1}}],[\"二分\",{\"1\":{\"174\":1,\"423\":1}}],[\"二分枚举种树区间\",{\"1\":{\"173\":1}}],[\"二分答案可以用来处理\",{\"1\":{\"323\":1}}],[\"二分答案模板\",{\"0\":{\"323\":1}}],[\"二分答案\",{\"1\":{\"173\":1}}],[\"二是将控制权转移给被调用函数\",{\"1\":{\"1011\":1}}],[\"二是\",{\"1\":{\"235\":1}}],[\"二是数据组装\",{\"1\":{\"25\":1}}],[\"二是基于评论系统做二次开发或存在业务关联的其他业务后端\",{\"1\":{\"25\":1}}],[\"上图中\",{\"1\":{\"1313\":1}}],[\"上图黄色部分\",{\"1\":{\"670\":1}}],[\"上一个任务执行结束后到下一次\",{\"1\":{\"1367\":1}}],[\"上一篇文章\",{\"1\":{\"1313\":1}}],[\"上一条命令的退出状态\",{\"1\":{\"1120\":1}}],[\"上的线程\",{\"1\":{\"1248\":2,\"1410\":2}}],[\"上去的\",{\"1\":{\"1184\":1}}],[\"上对\",{\"0\":{\"1130\":1}}],[\"上启动\",{\"1\":{\"1090\":1}}],[\"上用二分查找快速找到第一个大于\",{\"1\":{\"852\":1}}],[\"上边\",{\"1\":{\"822\":1}}],[\"上边说了布隆过滤器可能存在\",{\"1\":{\"613\":1}}],[\"上搭建\",{\"1\":{\"662\":1}}],[\"上进一步封装的前端组件\",{\"1\":{\"592\":1}}],[\"上右键选择\",{\"1\":{\"576\":1}}],[\"上次登录时间\",{\"1\":{\"566\":1}}],[\"上述其他几条性质也是吻合的\",{\"1\":{\"1472\":1}}],[\"上述情况\",{\"1\":{\"1315\":1}}],[\"上述语法中的\",{\"1\":{\"915\":1}}],[\"上述指令\",{\"1\":{\"906\":1}}],[\"上述代码中的\",{\"1\":{\"513\":1}}],[\"上述写法会报栈溢出错误\",{\"1\":{\"182\":1}}],[\"上声明特定的安全约束\",{\"1\":{\"465\":1}}],[\"上浮\",{\"1\":{\"417\":1}}],[\"上了\",{\"1\":{\"372\":1}}],[\"上下左右四个相邻像素中有海洋\",{\"1\":{\"280\":1}}],[\"上下左右\",{\"1\":{\"280\":1}}],[\"上\",{\"0\":{\"554\":1},\"1\":{\"167\":1,\"554\":1,\"1158\":1}}],[\"上面一共有八条原子操作\",{\"1\":{\"1482\":1}}],[\"上面这四个语句中只有第\",{\"1\":{\"1482\":1}}],[\"上面这些步骤执行后\",{\"1\":{\"663\":1}}],[\"上面对\",{\"1\":{\"1478\":1}}],[\"上面我们提到过\",{\"1\":{\"1477\":1}}],[\"上面用黄色高亮的部分就是需要注意的部分了\",{\"1\":{\"1431\":1}}],[\"上面的这个例子实现了独占锁的语义\",{\"1\":{\"1496\":1}}],[\"上面的这些指令操作是相当底层的\",{\"1\":{\"1482\":1}}],[\"上面的实例代码对应的\",{\"1\":{\"1455\":1}}],[\"上面的\",{\"1\":{\"1431\":1,\"1496\":1}}],[\"上面的代码中有一个同步代码块\",{\"1\":{\"1431\":1}}],[\"上面的代码与之前的代码仅仅只是将\",{\"1\":{\"1407\":1}}],[\"上面的第\",{\"1\":{\"1420\":2}}],[\"上面的重排序原则\",{\"1\":{\"1419\":1}}],[\"上面的例子中\",{\"1\":{\"1340\":1}}],[\"上面已经解释了\",{\"1\":{\"1283\":1}}],[\"上面可以看到\",{\"1\":{\"1150\":1}}],[\"上面五个体系可以说是\",{\"1\":{\"1141\":1}}],[\"上面有\",{\"1\":{\"157\":1}}],[\"上面查询出来的\",{\"1\":{\"56\":1}}],[\"上文提到\",{\"1\":{\"34\":1}}],[\"yield\",{\"0\":{\"1339\":1},\"1\":{\"1271\":2,\"1331\":1,\"1339\":3}}],[\"yi​⩽50000⩽wi​⩽1000\",{\"1\":{\"263\":1}}],[\"yi​≤109\",{\"1\":{\"166\":1}}],[\"yi​\",{\"1\":{\"166\":2,\"263\":2,\"274\":3}}],[\"yujin753\",{\"1\":{\"1140\":1}}],[\"yuan\",{\"1\":{\"517\":1}}],[\"youngman\",{\"1\":{\"1133\":2}}],[\"your\",{\"1\":{\"246\":1,\"542\":1,\"543\":1,\"1069\":2}}],[\"yxc\",{\"1\":{\"982\":1,\"1005\":1,\"1055\":3,\"1063\":1,\"1112\":2,\"1117\":3,\"1122\":1,\"1123\":1,\"1124\":1,\"1125\":1}}],[\"yet\",{\"1\":{\"1505\":1}}],[\"year\",{\"1\":{\"920\":1,\"984\":4,\"985\":4}}],[\"yes\",{\"1\":{\"97\":3,\"235\":2,\"273\":4,\"394\":1,\"984\":2,\"985\":1,\"992\":1}}],[\"y方向数组\",{\"1\":{\"870\":1}}],[\"yanue\",{\"1\":{\"665\":1}}],[\"yarn\",{\"1\":{\"559\":2}}],[\"yml\",{\"1\":{\"575\":2,\"576\":1,\"1100\":1}}],[\"yk\",{\"1\":{\"398\":3}}],[\"y是分母\",{\"1\":{\"389\":1}}],[\"y=x\",{\"1\":{\"383\":1}}],[\"y=0\",{\"1\":{\"383\":1}}],[\"y2\",{\"1\":{\"333\":3,\"335\":3,\"398\":3}}],[\"y1\",{\"1\":{\"333\":3,\"335\":3,\"398\":1}}],[\"y≤n\",{\"1\":{\"199\":1}}],[\"yyyy\",{\"1\":{\"920\":4,\"1309\":1}}],[\"yy\",{\"1\":{\"180\":10,\"197\":6,\"224\":5,\"228\":2,\"229\":2,\"235\":9,\"236\":9,\"237\":8,\"279\":5,\"821\":6,\"870\":6}}],[\"y++\",{\"1\":{\"141\":2}}],[\"y\",{\"1\":{\"56\":1,\"77\":27,\"139\":19,\"141\":8,\"180\":3,\"196\":2,\"197\":13,\"199\":3,\"200\":5,\"218\":2,\"219\":2,\"220\":2,\"223\":5,\"224\":5,\"228\":7,\"229\":6,\"230\":9,\"235\":3,\"236\":3,\"237\":9,\"248\":3,\"263\":4,\"271\":2,\"273\":7,\"274\":23,\"278\":7,\"279\":2,\"309\":2,\"338\":17,\"361\":2,\"377\":1,\"383\":10,\"384\":4,\"389\":4,\"414\":2,\"423\":4,\"821\":2,\"870\":2,\"886\":4,\"978\":1,\"980\":5,\"981\":1,\"989\":3,\"1021\":2,\"1027\":9,\"1028\":2}}],[\"x86\",{\"1\":{\"1477\":4}}],[\"x64\",{\"1\":{\"1090\":1}}],[\"x方向数组\",{\"1\":{\"870\":1}}],[\"xml\",{\"1\":{\"471\":1,\"543\":1,\"567\":1,\"1051\":1,\"1090\":3,\"1141\":2}}],[\"x的左儿子是2x\",{\"1\":{\"417\":1}}],[\"x<y\",{\"1\":{\"407\":1}}],[\"x属于自然数\",{\"1\":{\"397\":1}}],[\"x是分子\",{\"1\":{\"389\":1}}],[\"x≡mi​\",{\"1\":{\"384\":1}}],[\"x2\",{\"1\":{\"333\":3,\"335\":3}}],[\"x1\",{\"1\":{\"333\":3,\"335\":3}}],[\"x=y\",{\"1\":{\"383\":1}}],[\"x=1\",{\"1\":{\"383\":1}}],[\"x=\",{\"1\":{\"273\":1}}],[\"xxx\",{\"1\":{\"542\":2,\"1069\":5}}],[\"xxxxlist\",{\"1\":{\"468\":1}}],[\"xxxx\",{\"1\":{\"468\":2}}],[\"xx\",{\"1\":{\"180\":10,\"197\":6,\"224\":5,\"228\":2,\"229\":2,\"235\":9,\"236\":9,\"237\":8,\"279\":5,\"821\":6,\"870\":6,\"1147\":3,\"1444\":2}}],[\"xstr\",{\"1\":{\"157\":2}}],[\"xi\",{\"1\":{\"157\":1}}],[\"xi​\",{\"1\":{\"157\":1,\"166\":2,\"263\":2,\"274\":3}}],[\"x++\",{\"1\":{\"141\":2}}],[\"x+1\",{\"1\":{\"110\":1}}],[\"xy\",{\"1\":{\"139\":1,\"1147\":1}}],[\"x0\",{\"1\":{\"97\":5}}],[\"x0​≤1000\",{\"1\":{\"97\":1}}],[\"x0​\",{\"1\":{\"97\":1}}],[\"x0​​\",{\"1\":{\"97\":2}}],[\"x\",{\"0\":{\"253\":1},\"1\":{\"56\":1,\"65\":1,\"77\":27,\"87\":5,\"97\":1,\"108\":3,\"110\":5,\"119\":5,\"121\":2,\"135\":5,\"139\":24,\"140\":6,\"141\":8,\"147\":1,\"157\":3,\"161\":2,\"173\":4,\"178\":2,\"179\":3,\"180\":3,\"196\":3,\"197\":13,\"199\":3,\"200\":11,\"218\":2,\"219\":2,\"220\":2,\"223\":2,\"224\":22,\"228\":7,\"229\":6,\"230\":9,\"235\":3,\"236\":3,\"237\":9,\"248\":3,\"250\":2,\"253\":2,\"254\":1,\"263\":4,\"270\":12,\"271\":2,\"273\":13,\"274\":25,\"278\":7,\"279\":17,\"291\":4,\"309\":13,\"317\":3,\"321\":1,\"322\":4,\"325\":1,\"338\":14,\"339\":18,\"341\":2,\"354\":1,\"356\":2,\"361\":8,\"363\":3,\"367\":5,\"368\":7,\"371\":1,\"373\":1,\"375\":5,\"376\":7,\"377\":1,\"379\":9,\"380\":1,\"383\":9,\"384\":9,\"388\":4,\"389\":4,\"394\":3,\"397\":1,\"398\":2,\"403\":3,\"404\":2,\"406\":1,\"409\":1,\"414\":8,\"415\":6,\"416\":10,\"417\":5,\"419\":6,\"420\":3,\"422\":2,\"423\":12,\"500\":1,\"540\":1,\"663\":1,\"672\":2,\"753\":3,\"789\":4,\"821\":2,\"828\":2,\"852\":7,\"868\":1,\"870\":2,\"876\":7,\"886\":4,\"894\":3,\"899\":6,\"901\":5,\"978\":2,\"980\":5,\"981\":1,\"984\":4,\"988\":2,\"989\":3,\"1001\":2,\"1005\":1,\"1015\":5,\"1017\":5,\"1021\":2,\"1027\":9,\"1028\":2,\"1047\":2,\"1048\":2,\"1116\":1,\"1275\":6,\"1347\":3,\"1348\":2,\"1350\":2,\"1352\":3,\"1399\":2}}],[\"=new\",{\"1\":{\"1306\":1}}],[\"=n×p1​p1​−1​×p2​p2​−1​×\",{\"1\":{\"379\":1}}],[\"=yxc\",{\"1\":{\"1122\":1}}],[\"=abc\",{\"1\":{\"1122\":1}}],[\"=2\",{\"1\":{\"988\":1,\"990\":1}}],[\"=<>>>=<<=\",{\"1\":{\"948\":1}}],[\"=max\",{\"1\":{\"851\":2}}],[\"=min\",{\"1\":{\"65\":1,\"128\":1,\"797\":1}}],[\"=p\",{\"1\":{\"411\":1}}],[\"=>\",{\"1\":{\"372\":1,\"540\":1,\"549\":1,\"575\":1,\"587\":4,\"589\":1,\"591\":2,\"592\":12,\"954\":6,\"1049\":2}}],[\"=∑u=sons​dp\",{\"1\":{\"314\":1}}],[\"=∑u=sons​max\",{\"1\":{\"314\":1}}],[\"=0\",{\"1\":{\"312\":1}}],[\"=f\",{\"1\":{\"308\":1,\"988\":1,\"990\":1}}],[\"=10\",{\"1\":{\"309\":2}}],[\"=1\",{\"1\":{\"142\":1,\"383\":1,\"988\":2,\"990\":2,\"1122\":1}}],[\"=−1\",{\"1\":{\"128\":1}}],[\"==null时结束\",{\"1\":{\"1316\":1}}],[\"===================================================\",{\"1\":{\"1221\":1}}],[\"===\",{\"1\":{\"587\":2,\"592\":1}}],[\"==>\",{\"1\":{\"446\":1}}],[\"==\",{\"1\":{\"65\":3,\"71\":2,\"76\":1,\"77\":7,\"82\":3,\"83\":6,\"87\":1,\"93\":6,\"98\":1,\"99\":1,\"103\":1,\"108\":1,\"120\":2,\"121\":4,\"122\":1,\"127\":14,\"129\":1,\"139\":8,\"147\":2,\"157\":1,\"161\":1,\"167\":3,\"172\":2,\"174\":3,\"180\":2,\"182\":1,\"187\":6,\"194\":1,\"200\":1,\"203\":3,\"206\":2,\"223\":2,\"224\":2,\"228\":2,\"229\":2,\"230\":2,\"235\":4,\"236\":8,\"237\":15,\"244\":2,\"250\":1,\"255\":1,\"261\":5,\"262\":2,\"270\":2,\"273\":2,\"274\":6,\"278\":2,\"279\":1,\"281\":1,\"287\":2,\"290\":1,\"303\":2,\"304\":1,\"305\":1,\"306\":2,\"307\":1,\"311\":1,\"328\":1,\"329\":1,\"330\":1,\"338\":3,\"349\":2,\"352\":2,\"353\":1,\"354\":1,\"355\":1,\"358\":1,\"360\":3,\"361\":3,\"362\":3,\"363\":1,\"367\":1,\"368\":2,\"369\":3,\"373\":2,\"375\":1,\"376\":1,\"379\":2,\"380\":2,\"390\":1,\"411\":3,\"419\":1,\"420\":1,\"422\":1,\"423\":1,\"523\":2,\"525\":1,\"526\":7,\"575\":2,\"576\":2,\"578\":1,\"587\":2,\"589\":1,\"596\":1,\"682\":2,\"694\":2,\"710\":3,\"713\":2,\"725\":1,\"736\":2,\"737\":2,\"743\":1,\"748\":1,\"749\":1,\"755\":5,\"761\":1,\"767\":1,\"772\":2,\"789\":1,\"795\":2,\"803\":2,\"809\":4,\"820\":2,\"821\":2,\"822\":6,\"833\":1,\"834\":3,\"840\":1,\"845\":2,\"846\":16,\"852\":2,\"864\":1,\"870\":6,\"882\":1,\"887\":1,\"899\":1,\"900\":1,\"901\":1,\"984\":6,\"985\":2,\"988\":1,\"992\":1,\"993\":1,\"994\":1,\"1020\":1,\"1048\":1,\"1145\":2,\"1232\":3,\"1233\":2,\"1239\":2,\"1240\":1,\"1242\":4,\"1243\":4,\"1251\":1,\"1252\":1,\"1271\":4,\"1272\":15,\"1273\":4,\"1274\":9,\"1275\":5,\"1283\":5,\"1284\":5,\"1285\":3,\"1306\":3,\"1307\":3,\"1308\":1,\"1309\":2,\"1314\":3,\"1315\":2,\"1316\":1,\"1317\":10,\"1318\":1,\"1347\":5,\"1348\":3,\"1350\":2,\"1351\":3,\"1352\":2,\"1359\":2,\"1368\":2,\"1370\":3,\"1409\":1,\"1410\":1,\"1485\":3,\"1496\":4,\"1504\":3,\"1505\":1,\"1506\":1,\"1507\":1,\"1508\":1,\"1510\":1,\"1511\":3}}],[\"=\",{\"1\":{\"56\":3,\"65\":8,\"66\":10,\"70\":11,\"71\":29,\"72\":12,\"76\":2,\"77\":15,\"82\":7,\"83\":15,\"87\":12,\"88\":5,\"92\":2,\"93\":4,\"97\":10,\"98\":6,\"99\":7,\"103\":39,\"104\":14,\"108\":8,\"109\":14,\"110\":16,\"114\":2,\"115\":9,\"119\":6,\"120\":2,\"121\":10,\"122\":10,\"126\":13,\"127\":23,\"128\":15,\"129\":16,\"133\":3,\"134\":16,\"135\":6,\"139\":10,\"140\":7,\"141\":15,\"142\":7,\"146\":10,\"152\":4,\"157\":36,\"161\":5,\"162\":24,\"167\":14,\"172\":3,\"173\":15,\"174\":30,\"178\":15,\"179\":6,\"180\":23,\"182\":12,\"194\":12,\"197\":14,\"200\":4,\"203\":14,\"206\":15,\"218\":3,\"219\":3,\"220\":3,\"221\":8,\"223\":25,\"224\":27,\"228\":15,\"229\":13,\"230\":7,\"235\":14,\"236\":18,\"237\":15,\"243\":1,\"244\":3,\"245\":5,\"248\":3,\"250\":3,\"251\":8,\"252\":1,\"255\":8,\"256\":9,\"257\":1,\"261\":6,\"262\":9,\"263\":9,\"269\":2,\"270\":1,\"271\":3,\"273\":8,\"274\":14,\"278\":11,\"279\":14,\"281\":6,\"287\":6,\"288\":7,\"289\":5,\"290\":8,\"291\":12,\"296\":9,\"297\":9,\"298\":28,\"299\":13,\"301\":17,\"302\":26,\"303\":7,\"304\":12,\"305\":16,\"306\":13,\"307\":18,\"308\":16,\"309\":29,\"311\":15,\"312\":10,\"314\":6,\"317\":5,\"318\":12,\"320\":1,\"321\":5,\"322\":5,\"323\":4,\"324\":5,\"325\":4,\"327\":12,\"328\":20,\"329\":8,\"330\":8,\"332\":2,\"333\":1,\"334\":1,\"335\":2,\"338\":31,\"339\":10,\"340\":3,\"341\":5,\"342\":8,\"345\":14,\"347\":5,\"348\":7,\"349\":10,\"352\":12,\"353\":14,\"354\":8,\"355\":15,\"356\":11,\"358\":8,\"360\":17,\"361\":19,\"362\":8,\"363\":8,\"367\":1,\"368\":3,\"369\":8,\"371\":5,\"372\":10,\"373\":6,\"375\":2,\"376\":11,\"379\":5,\"380\":11,\"381\":5,\"383\":9,\"384\":10,\"385\":16,\"387\":4,\"388\":8,\"389\":10,\"390\":17,\"391\":1,\"392\":12,\"394\":2,\"397\":1,\"398\":2,\"399\":1,\"403\":10,\"404\":10,\"406\":2,\"407\":3,\"409\":3,\"410\":4,\"411\":12,\"412\":9,\"414\":9,\"415\":6,\"416\":8,\"417\":10,\"419\":8,\"420\":4,\"421\":4,\"422\":1,\"423\":4,\"427\":6,\"428\":7,\"429\":4,\"430\":13,\"431\":9,\"446\":3,\"465\":3,\"471\":9,\"481\":2,\"482\":3,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"515\":2,\"517\":1,\"523\":7,\"525\":13,\"526\":17,\"540\":1,\"549\":1,\"567\":2,\"568\":30,\"575\":7,\"576\":7,\"578\":4,\"580\":3,\"587\":11,\"589\":10,\"591\":4,\"592\":8,\"672\":2,\"682\":14,\"687\":4,\"688\":1,\"694\":5,\"699\":2,\"700\":16,\"705\":12,\"710\":3,\"712\":1,\"713\":3,\"724\":9,\"725\":4,\"736\":1,\"737\":7,\"743\":7,\"748\":2,\"749\":6,\"755\":2,\"761\":4,\"767\":19,\"772\":10,\"777\":2,\"778\":8,\"783\":8,\"784\":7,\"789\":8,\"795\":9,\"796\":9,\"797\":8,\"803\":17,\"815\":4,\"820\":8,\"821\":17,\"822\":12,\"827\":4,\"828\":9,\"833\":1,\"834\":20,\"840\":9,\"845\":11,\"846\":15,\"851\":8,\"852\":22,\"857\":4,\"864\":4,\"869\":1,\"870\":31,\"874\":1,\"875\":6,\"876\":13,\"882\":3,\"887\":9,\"888\":22,\"893\":11,\"894\":13,\"899\":3,\"900\":2,\"901\":4,\"926\":2,\"931\":2,\"935\":1,\"942\":1,\"947\":1,\"950\":1,\"958\":1,\"978\":7,\"979\":15,\"980\":7,\"981\":8,\"982\":1,\"984\":28,\"985\":7,\"986\":10,\"988\":12,\"989\":2,\"990\":14,\"992\":5,\"993\":2,\"994\":7,\"995\":1,\"997\":4,\"998\":3,\"999\":26,\"1000\":7,\"1001\":1,\"1004\":5,\"1005\":13,\"1006\":3,\"1007\":2,\"1010\":3,\"1011\":4,\"1014\":1,\"1015\":2,\"1017\":2,\"1018\":7,\"1020\":4,\"1021\":3,\"1023\":2,\"1027\":4,\"1028\":2,\"1029\":2,\"1033\":1,\"1034\":2,\"1047\":8,\"1048\":2,\"1049\":4,\"1055\":8,\"1059\":5,\"1061\":5,\"1062\":11,\"1063\":6,\"1069\":16,\"1070\":1,\"1072\":4,\"1073\":3,\"1074\":4,\"1075\":2,\"1076\":1,\"1077\":1,\"1078\":4,\"1083\":14,\"1100\":1,\"1102\":5,\"1103\":8,\"1122\":1,\"1133\":2,\"1145\":3,\"1147\":1,\"1149\":6,\"1153\":1,\"1154\":2,\"1157\":2,\"1158\":4,\"1160\":5,\"1162\":1,\"1163\":1,\"1164\":1,\"1167\":1,\"1175\":3,\"1177\":2,\"1179\":1,\"1180\":1,\"1182\":1,\"1184\":2,\"1191\":1,\"1201\":7,\"1204\":3,\"1207\":3,\"1210\":1,\"1211\":8,\"1221\":4,\"1232\":7,\"1233\":5,\"1239\":8,\"1240\":3,\"1242\":11,\"1243\":8,\"1244\":2,\"1250\":2,\"1251\":27,\"1252\":15,\"1254\":6,\"1260\":1,\"1266\":1,\"1267\":4,\"1270\":3,\"1271\":9,\"1272\":44,\"1273\":15,\"1274\":83,\"1275\":27,\"1281\":2,\"1283\":31,\"1284\":23,\"1285\":3,\"1294\":5,\"1295\":4,\"1301\":5,\"1302\":10,\"1303\":2,\"1305\":2,\"1306\":36,\"1307\":9,\"1308\":7,\"1309\":5,\"1313\":1,\"1314\":12,\"1315\":11,\"1316\":21,\"1317\":42,\"1319\":9,\"1326\":1,\"1330\":5,\"1336\":2,\"1337\":5,\"1340\":1,\"1346\":4,\"1347\":5,\"1348\":7,\"1350\":6,\"1351\":5,\"1352\":5,\"1359\":3,\"1368\":2,\"1369\":4,\"1370\":2,\"1375\":7,\"1385\":4,\"1386\":4,\"1387\":6,\"1388\":5,\"1392\":4,\"1393\":3,\"1398\":3,\"1399\":4,\"1406\":12,\"1407\":14,\"1409\":10,\"1410\":15,\"1411\":9,\"1418\":3,\"1429\":4,\"1432\":2,\"1433\":2,\"1444\":2,\"1449\":4,\"1454\":1,\"1455\":5,\"1458\":3,\"1467\":4,\"1475\":6,\"1476\":7,\"1478\":4,\"1482\":8,\"1485\":2,\"1492\":1,\"1496\":4,\"1501\":5,\"1504\":16,\"1505\":9,\"1506\":12,\"1507\":5,\"1508\":8,\"1510\":8,\"1511\":4}}],[\"+2\",{\"1\":{\"828\":1}}],[\"+2xt​​\",{\"1\":{\"381\":1}}],[\"+x\",{\"1\":{\"670\":1,\"1087\":1,\"1107\":1,\"1116\":1,\"1119\":1}}],[\"+|\",{\"1\":{\"568\":1,\"575\":1}}],[\"+inf\",{\"1\":{\"360\":1}}],[\"+happy\",{\"1\":{\"314\":1}}],[\"+size\",{\"1\":{\"246\":1}}],[\"+f\",{\"1\":{\"221\":1,\"223\":1,\"308\":1,\"988\":1,\"990\":1}}],[\"+=|\",{\"1\":{\"568\":1,\"575\":1}}],[\"+=\",{\"1\":{\"114\":2,\"120\":13,\"122\":2,\"126\":2,\"129\":1,\"135\":1,\"140\":1,\"141\":2,\"142\":3,\"146\":1,\"162\":1,\"167\":10,\"173\":2,\"197\":1,\"203\":1,\"224\":4,\"255\":1,\"261\":2,\"262\":2,\"263\":2,\"274\":4,\"279\":1,\"290\":1,\"298\":4,\"309\":4,\"311\":1,\"314\":2,\"324\":1,\"327\":2,\"329\":1,\"334\":1,\"335\":2,\"360\":1,\"361\":1,\"371\":1,\"372\":2,\"390\":2,\"392\":1,\"414\":2,\"415\":1,\"416\":1,\"700\":2,\"772\":1,\"882\":3,\"979\":2,\"988\":1,\"990\":2,\"993\":1,\"1005\":1,\"1275\":1}}],[\"++takeindex\",{\"1\":{\"1348\":1}}],[\"++tt\",{\"1\":{\"349\":2,\"406\":1,\"407\":1,\"409\":1,\"410\":1}}],[\"++putindex\",{\"1\":{\"1347\":1}}],[\"++hc\",{\"1\":{\"1274\":1}}],[\"++bincount\",{\"1\":{\"1272\":2}}],[\"++a\",{\"1\":{\"979\":1}}],[\"++size\",{\"1\":{\"417\":1,\"1306\":1,\"1314\":1}}],[\"++res\",{\"1\":{\"369\":1}}],[\"++right\",{\"1\":{\"140\":1}}],[\"++y\",{\"1\":{\"263\":1}}],[\"++x\",{\"1\":{\"263\":1}}],[\"++mx\",{\"1\":{\"250\":1}}],[\"++lc\",{\"1\":{\"1274\":1}}],[\"++l\",{\"1\":{\"142\":2}}],[\"++\",{\"1\":{\"120\":2,\"141\":1,\"178\":1,\"203\":1,\"223\":1,\"261\":2,\"308\":5,\"309\":2,\"311\":6,\"314\":1,\"345\":4,\"352\":3,\"354\":2,\"356\":1,\"361\":1,\"362\":1,\"363\":1,\"376\":3,\"380\":3,\"385\":7,\"388\":1,\"389\":1,\"390\":7,\"403\":1,\"412\":4,\"415\":1,\"416\":1,\"419\":1,\"421\":1,\"422\":1,\"851\":1,\"979\":1,\"980\":2,\"988\":3,\"990\":4,\"992\":1,\"993\":1,\"994\":5,\"999\":6,\"1000\":3,\"1005\":1,\"1007\":1,\"1010\":1,\"1011\":1,\"1018\":1,\"1047\":2,\"1059\":3,\"1061\":2,\"1062\":4,\"1063\":1}}],[\"++j\",{\"1\":{\"65\":1,\"142\":1,\"146\":3,\"174\":1,\"1306\":1}}],[\"++i\",{\"1\":{\"65\":3,\"66\":4,\"110\":2,\"135\":1,\"140\":1,\"142\":1,\"146\":2,\"173\":1,\"174\":5,\"1275\":1}}],[\"+r\",{\"1\":{\"65\":1}}],[\"+dp\",{\"1\":{\"65\":1}}],[\"+\",{\"0\":{\"888\":1},\"1\":{\"56\":1,\"58\":4,\"65\":8,\"66\":12,\"71\":6,\"72\":11,\"77\":10,\"83\":6,\"87\":2,\"88\":1,\"97\":2,\"103\":2,\"104\":5,\"109\":3,\"110\":8,\"115\":5,\"119\":1,\"121\":1,\"122\":1,\"126\":2,\"127\":2,\"129\":1,\"135\":3,\"140\":1,\"141\":8,\"142\":5,\"152\":1,\"157\":11,\"162\":2,\"166\":1,\"167\":1,\"173\":5,\"174\":15,\"178\":4,\"179\":2,\"180\":4,\"182\":3,\"194\":3,\"197\":3,\"200\":1,\"203\":1,\"206\":11,\"218\":1,\"219\":2,\"220\":1,\"221\":8,\"223\":8,\"224\":11,\"228\":2,\"229\":2,\"230\":6,\"235\":2,\"236\":3,\"237\":3,\"242\":3,\"245\":2,\"247\":1,\"248\":2,\"249\":2,\"254\":4,\"255\":1,\"256\":4,\"261\":2,\"262\":1,\"263\":5,\"278\":3,\"279\":5,\"281\":1,\"287\":3,\"288\":1,\"289\":3,\"290\":5,\"291\":4,\"296\":2,\"297\":2,\"298\":4,\"299\":2,\"301\":6,\"302\":6,\"303\":4,\"304\":1,\"305\":7,\"306\":8,\"307\":12,\"308\":10,\"309\":4,\"312\":2,\"314\":2,\"317\":5,\"318\":4,\"321\":4,\"322\":2,\"323\":2,\"324\":8,\"325\":1,\"327\":3,\"328\":2,\"330\":1,\"332\":4,\"333\":1,\"334\":1,\"335\":4,\"339\":1,\"340\":1,\"341\":3,\"345\":3,\"346\":1,\"351\":1,\"352\":2,\"353\":2,\"354\":4,\"355\":2,\"356\":3,\"358\":1,\"360\":2,\"361\":2,\"362\":1,\"371\":5,\"372\":1,\"373\":1,\"376\":11,\"383\":3,\"384\":2,\"385\":2,\"387\":1,\"389\":1,\"390\":3,\"391\":1,\"411\":4,\"417\":4,\"419\":2,\"420\":1,\"421\":2,\"422\":1,\"423\":13,\"427\":4,\"428\":4,\"429\":2,\"430\":2,\"431\":1,\"437\":1,\"471\":2,\"481\":12,\"493\":7,\"499\":2,\"500\":7,\"539\":2,\"567\":1,\"568\":1,\"575\":1,\"634\":6,\"668\":1,\"681\":1,\"699\":2,\"712\":1,\"713\":2,\"736\":2,\"748\":1,\"754\":1,\"761\":2,\"766\":5,\"767\":13,\"772\":4,\"777\":3,\"783\":3,\"795\":2,\"796\":2,\"797\":2,\"815\":2,\"820\":2,\"821\":2,\"822\":10,\"827\":3,\"828\":7,\"840\":3,\"846\":11,\"852\":4,\"870\":4,\"887\":1,\"893\":8,\"894\":7,\"958\":4,\"979\":3,\"980\":7,\"982\":2,\"984\":4,\"988\":1,\"990\":5,\"995\":1,\"999\":3,\"1004\":1,\"1005\":2,\"1007\":1,\"1015\":1,\"1023\":1,\"1033\":3,\"1034\":3,\"1049\":4,\"1055\":1,\"1059\":3,\"1063\":3,\"1068\":1,\"1074\":1,\"1102\":5,\"1145\":1,\"1149\":5,\"1150\":1,\"1177\":2,\"1201\":3,\"1204\":2,\"1207\":2,\"1211\":2,\"1232\":1,\"1233\":1,\"1239\":3,\"1242\":1,\"1254\":2,\"1260\":1,\"1268\":3,\"1270\":3,\"1274\":3,\"1275\":6,\"1284\":3,\"1294\":1,\"1295\":1,\"1306\":2,\"1309\":1,\"1336\":2,\"1337\":1,\"1351\":1,\"1387\":6,\"1388\":6,\"1392\":3,\"1393\":2,\"1398\":4,\"1399\":2,\"1406\":12,\"1407\":12,\"1409\":14,\"1410\":14,\"1411\":6,\"1429\":1,\"1449\":1,\"1467\":5,\"1482\":1,\"1508\":2}}],[\"+1\",{\"1\":{\"56\":1,\"156\":1,\"167\":1,\"221\":2,\"242\":1,\"291\":1,\"748\":1,\"749\":1,\"795\":1,\"796\":1,\"797\":1,\"851\":2,\"1275\":1}}],[\"耦合\",{\"1\":{\"56\":1}}],[\"去读取该对象时就会出错\",{\"1\":{\"1478\":1}}],[\"去收银台付款\",{\"1\":{\"1434\":1}}],[\"去访问到该\",{\"1\":{\"1313\":1}}],[\"去保证的\",{\"1\":{\"1309\":1}}],[\"去深入了解下读写锁\",{\"1\":{\"1237\":1}}],[\"去掉首尾的空白字符\",{\"1\":{\"1005\":1}}],[\"去掉重复元素\",{\"1\":{\"341\":1}}],[\"去除首尾空白字符\",{\"1\":{\"1069\":2}}],[\"去除重复记录\",{\"1\":{\"930\":1}}],[\"去除无效状态的优化写法\",{\"1\":{\"311\":1}}],[\"去数据库查询\",{\"1\":{\"589\":1}}],[\"去请求\",{\"1\":{\"575\":1}}],[\"去记录\",{\"1\":{\"574\":1}}],[\"去对比\",{\"1\":{\"574\":1}}],[\"去重\",{\"1\":{\"423\":2}}],[\"去重机制可以通过在分布式数据库中存储每个点击数据的唯一标识\",{\"1\":{\"151\":1}}],[\"去重机制\",{\"1\":{\"151\":1}}],[\"去筛合数时\",{\"1\":{\"373\":1}}],[\"去查询当前用户有权访问的动态菜单的路由列表\",{\"1\":{\"458\":1}}],[\"去查到这一行数据\",{\"1\":{\"56\":1}}],[\"去查必然需要先查到自己的主键\",{\"1\":{\"56\":1}}],[\"去平台业务的逻辑\",{\"1\":{\"46\":1}}],[\"另一种方式是\",{\"1\":{\"1416\":1}}],[\"另一种是消费者线程用于消费数据\",{\"1\":{\"1402\":1}}],[\"另一个操作\",{\"1\":{\"1420\":1}}],[\"另一个\",{\"1\":{\"1392\":1}}],[\"另一个是\",{\"1\":{\"1281\":1,\"1406\":1}}],[\"另一个是原链表的反序排列\",{\"1\":{\"1274\":1}}],[\"另一棵树的子树\",{\"0\":{\"185\":1},\"1\":{\"185\":1}}],[\"另一方面对工程侧的要求主要是\",{\"1\":{\"36\":1}}],[\"另一方面也通过超时控制\",{\"1\":{\"34\":1}}],[\"另一方面\",{\"1\":{\"28\":1,\"41\":1}}],[\"另外在\",{\"1\":{\"1491\":1}}],[\"另外在阻塞线程这一系列方法中还有一个很有意思的现象就是\",{\"1\":{\"1259\":1}}],[\"另外也验证了\",{\"1\":{\"1433\":1}}],[\"另外也提供了常见的云存储供应商选项\",{\"1\":{\"670\":1}}],[\"另外需要注意的是\",{\"1\":{\"1334\":1,\"1339\":1,\"1393\":1}}],[\"另外需要注意的是这里的\",{\"1\":{\"1305\":1}}],[\"另外当\",{\"1\":{\"1334\":1}}],[\"另外由于\",{\"1\":{\"1330\":1}}],[\"另外值得关注的是\",{\"1\":{\"1302\":1}}],[\"另外只用到了异或运算\",{\"1\":{\"1272\":1}}],[\"另外可以看出很多属性都是用\",{\"1\":{\"1267\":1}}],[\"另外注意到\",{\"1\":{\"1250\":1}}],[\"另外还会有另外一个问题\",{\"1\":{\"1504\":1}}],[\"另外还要一个特别有意思的事情就是关于重排序问题\",{\"1\":{\"1423\":1}}],[\"另外还提供了超时等待的方法\",{\"1\":{\"1337\":1}}],[\"另外还提供了另外一种方式\",{\"1\":{\"1233\":1}}],[\"另外还需要注意的是\",{\"1\":{\"1271\":1}}],[\"另外还保存了一些计数字段\",{\"1\":{\"56\":1}}],[\"另外一个参数是\",{\"1\":{\"1154\":1}}],[\"另外一种则是链表的形式\",{\"1\":{\"1501\":1}}],[\"另外一种方式通过\",{\"1\":{\"1264\":1}}],[\"另外一种\",{\"1\":{\"767\":1}}],[\"另外\",{\"1\":{\"215\":1,\"869\":1,\"1075\":1,\"1141\":1,\"1218\":1,\"1242\":1,\"1260\":1,\"1264\":1,\"1270\":1,\"1272\":1,\"1281\":1,\"1283\":1,\"1302\":1,\"1309\":1,\"1317\":2,\"1325\":1,\"1326\":1,\"1330\":1,\"1336\":2,\"1338\":1,\"1339\":1,\"1371\":1,\"1375\":1,\"1376\":1,\"1392\":1,\"1398\":1,\"1415\":1,\"1418\":1,\"1425\":2}}],[\"另外有一些操作\",{\"1\":{\"178\":1}}],[\"自旋不断尝试cas尾插入节点直至成功为止\",{\"1\":{\"1504\":1}}],[\"自旋时间过长\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"自旋等待获取到同步状态\",{\"1\":{\"1251\":1}}],[\"自身\",{\"1\":{\"1175\":1}}],[\"自我保护机制关闭了\",{\"1\":{\"1191\":1}}],[\"自我保护机制关闭时\",{\"1\":{\"1190\":1}}],[\"自我保护机制开启了\",{\"1\":{\"1191\":1}}],[\"自我保护机制开启之后为\",{\"1\":{\"1190\":1}}],[\"自我保护机制配置已经配置成关闭了\",{\"1\":{\"1191\":1}}],[\"自我保护机制\",{\"0\":{\"1191\":1},\"1\":{\"1160\":1}}],[\"自然而然会在\",{\"1\":{\"1508\":1}}],[\"自然而然是在\",{\"1\":{\"1504\":1}}],[\"自然而然是从\",{\"1\":{\"1283\":1}}],[\"自然而然就只能去主内存去取了\",{\"1\":{\"1456\":1}}],[\"自然而然可以将新值\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"自然而然内存使用率增加\",{\"1\":{\"1313\":1}}],[\"自然而然的我们会想到\",{\"1\":{\"1290\":1}}],[\"自然而然得先从它的节点类看起\",{\"1\":{\"1281\":1}}],[\"自然而然\",{\"1\":{\"1250\":1,\"1306\":1}}],[\"自然排序\",{\"1\":{\"1074\":1}}],[\"自然想到二分\",{\"1\":{\"833\":1}}],[\"自减\",{\"1\":{\"980\":1,\"1385\":1}}],[\"自减运算符\",{\"1\":{\"979\":1}}],[\"自建网盘兼图床\",{\"0\":{\"668\":1}}],[\"自带的系统和服务管理器\",{\"1\":{\"671\":1}}],[\"自带的\",{\"1\":{\"538\":1}}],[\"自主打造一套前端万用模版\",{\"1\":{\"536\":1}}],[\"自定义过期策略\",{\"1\":{\"1211\":1}}],[\"自定义过期策略实现\",{\"0\":{\"1210\":1},\"1\":{\"1210\":1}}],[\"自定义本地缓存工具类\",{\"1\":{\"1201\":1}}],[\"自定义缓存实体类\",{\"1\":{\"1201\":1}}],[\"自定义变量改成环境变量\",{\"1\":{\"1116\":1}}],[\"自定义变量\",{\"1\":{\"1116\":1}}],[\"自定义实现最小\",{\"1\":{\"1078\":1}}],[\"自定义排序算法\",{\"1\":{\"1078\":1}}],[\"自定义排序时\",{\"1\":{\"1074\":1}}],[\"自定义异常\",{\"1\":{\"1048\":1}}],[\"自定义域名\",{\"1\":{\"634\":1}}],[\"自定义构造函数\",{\"1\":{\"599\":1}}],[\"自定义错误码\",{\"1\":{\"598\":1}}],[\"自定义注解\",{\"1\":{\"471\":2}}],[\"自定义用户认证逻辑\",{\"1\":{\"446\":1}}],[\"自定数据权限\",{\"1\":{\"470\":1}}],[\"自由\",{\"1\":{\"438\":1}}],[\"自己\",{\"1\":{\"1131\":1}}],[\"自己的文件系统\",{\"1\":{\"1095\":1}}],[\"自己整合很容易出错\",{\"1\":{\"539\":1}}],[\"自己从左上角到右下角的最短行走路径的距离是多少\",{\"1\":{\"180\":1}}],[\"自己每次操作会得到什么样的返回\",{\"1\":{\"88\":1}}],[\"自动获取文件大小\",{\"1\":{\"1103\":1}}],[\"自动获得\",{\"1\":{\"307\":1}}],[\"自动提交事务\",{\"1\":{\"954\":1}}],[\"自动增长\",{\"1\":{\"919\":1}}],[\"自动配置系统代理\",{\"1\":{\"665\":1}}],[\"自动登录\",{\"1\":{\"588\":2}}],[\"自动转换为驼峰\",{\"1\":{\"567\":1}}],[\"自动生成器的使用\",{\"0\":{\"567\":1}}],[\"自动化测试工具\",{\"1\":{\"559\":1}}],[\"自动化策略放出\",{\"1\":{\"36\":1}}],[\"自动安装相关依赖\",{\"1\":{\"559\":1}}],[\"自动映射为\",{\"1\":{\"542\":1}}],[\"自动将对应的\",{\"1\":{\"542\":1}}],[\"自动校验\",{\"1\":{\"539\":1}}],[\"自动缓存热门题目\",{\"1\":{\"497\":1,\"508\":1}}],[\"自动得到右端点\",{\"1\":{\"307\":1}}],[\"自动进行热点识别\",{\"1\":{\"61\":1}}],[\"自增运算符\",{\"1\":{\"979\":1}}],[\"自增\",{\"1\":{\"56\":1}}],[\"直译为不新鲜的\",{\"1\":{\"1306\":1,\"1314\":1}}],[\"直至等到其他线程调用了调用\",{\"1\":{\"1404\":1}}],[\"直至凑齐一波\",{\"1\":{\"1393\":1}}],[\"直至阻塞队列中无法取到任务为止\",{\"1\":{\"1371\":1}}],[\"直至阻塞队列已经有空余的地方\",{\"1\":{\"1325\":1}}],[\"直至阻塞队列已经有空余的容量可供使用\",{\"1\":{\"1325\":1}}],[\"直至满足条件\",{\"1\":{\"1352\":1}}],[\"直至队列中未满\",{\"1\":{\"1411\":1}}],[\"直至队列未满时\",{\"1\":{\"1345\":1}}],[\"直至队列非空时\",{\"1\":{\"1345\":1}}],[\"直至队列非空时为止\",{\"1\":{\"1324\":1,\"1411\":1}}],[\"直至\",{\"1\":{\"1316\":1,\"1505\":1}}],[\"直至成功\",{\"1\":{\"1251\":1,\"1504\":1}}],[\"直至被\",{\"1\":{\"1251\":1}}],[\"直径\",{\"1\":{\"759\":2}}],[\"直到被别的线程打断\",{\"1\":{\"1406\":1}}],[\"直到被等待对象\",{\"1\":{\"1337\":1}}],[\"直到接到通知或被中断为止\",{\"1\":{\"1404\":1}}],[\"直到计数器的值为\",{\"1\":{\"1392\":1}}],[\"直到所有运动员都到达终点了\",{\"1\":{\"1392\":1}}],[\"直到所有的元素都被选择或者删除\",{\"1\":{\"178\":1}}],[\"直到所有的商品都购买为止\",{\"1\":{\"109\":1}}],[\"直到阻塞队列中已经没有了异步任务为止\",{\"1\":{\"1371\":1}}],[\"直到从阻塞队列中获取的任务为\",{\"1\":{\"1370\":1}}],[\"直到有消费者能够进行消费才能退出\",{\"1\":{\"1326\":1}}],[\"直到队列未满\",{\"1\":{\"1324\":1}}],[\"直到队列为空\",{\"1\":{\"133\":1,\"821\":1}}],[\"直到在整个搜索范围里都未发现脏\",{\"1\":{\"1316\":1}}],[\"直到哈希桶\",{\"1\":{\"1316\":1}}],[\"直到遇到哈希桶\",{\"1\":{\"1316\":1,\"1317\":2}}],[\"直到遇到table\",{\"1\":{\"1316\":1}}],[\"直到链表尾插入这个结点\",{\"1\":{\"1272\":1}}],[\"直到第一次插入数据的时候才会进行初始化操作\",{\"1\":{\"1266\":1}}],[\"直到第n个点\",{\"1\":{\"352\":1}}],[\"直到\",{\"1\":{\"1259\":1,\"1317\":1,\"1392\":2,\"1394\":1}}],[\"直到获得了\",{\"1\":{\"1251\":1}}],[\"直到仓库人员跟你把货物送过来\",{\"1\":{\"1223\":1}}],[\"直到心跳恢复正常之后\",{\"1\":{\"1191\":1}}],[\"直到单元格中没有新鲜橘子为止所必须经过的最小分钟数\",{\"1\":{\"868\":1}}],[\"直到遍历完成\",{\"1\":{\"749\":1}}],[\"直到新的右子树为\",{\"1\":{\"724\":1}}],[\"直到项目可以正常运行并符合预期\",{\"1\":{\"548\":1}}],[\"直到具有\",{\"1\":{\"361\":1}}],[\"直到字符串结尾\",{\"1\":{\"252\":1}}],[\"直到到达终点为止\",{\"1\":{\"213\":1}}],[\"直到找到一个空的单元\",{\"1\":{\"1306\":1}}],[\"直到找到一个白色单元格或到达边界\",{\"1\":{\"77\":1}}],[\"直到找到并处理完后\",{\"1\":{\"731\":1}}],[\"直到找到终点\",{\"1\":{\"212\":1}}],[\"直到它等于或超过第二小的数字\",{\"1\":{\"167\":1}}],[\"直到整个链表有序\",{\"1\":{\"134\":1}}],[\"直到每个子链表只有一个节点\",{\"1\":{\"134\":1}}],[\"直到剩余的数字少于\",{\"1\":{\"99\":1}}],[\"直到其中一个数组的所有元素都被处理完毕\",{\"1\":{\"92\":1}}],[\"直接上代码\",{\"1\":{\"1410\":1}}],[\"直接上源码\",{\"1\":{\"1271\":1}}],[\"直接拒绝所提交的任务\",{\"1\":{\"1359\":1}}],[\"直接进行入队操作\",{\"1\":{\"1347\":1}}],[\"直接调用\",{\"1\":{\"1330\":1}}],[\"直接调用红黑树的插入方法进行插入新的节点\",{\"1\":{\"1272\":1}}],[\"直接放在\",{\"1\":{\"1317\":2}}],[\"直接放上压缩包\",{\"1\":{\"670\":1}}],[\"直接插入新\",{\"1\":{\"1306\":1}}],[\"直接\",{\"1\":{\"1283\":1}}],[\"直接针对的是\",{\"1\":{\"1276\":1}}],[\"直接跳过\",{\"1\":{\"1274\":1}}],[\"直接看\",{\"1\":{\"1259\":1}}],[\"直接跟\",{\"1\":{\"1129\":1}}],[\"直接退出\",{\"1\":{\"1020\":1}}],[\"直接简写为\",{\"1\":{\"935\":1}}],[\"直接点击\",{\"1\":{\"927\":1}}],[\"直接加到\",{\"1\":{\"852\":1}}],[\"直接返回即可\",{\"1\":{\"1284\":1}}],[\"直接返回\",{\"1\":{\"887\":1}}],[\"直接返回此结点\",{\"1\":{\"833\":1}}],[\"直接返回空指针\",{\"1\":{\"803\":1}}],[\"直接获取用户信息的方式并不推荐\",{\"1\":{\"589\":1}}],[\"直接在\",{\"1\":{\"560\":1}}],[\"直接使用\",{\"1\":{\"548\":1}}],[\"直接整合\",{\"1\":{\"539\":1}}],[\"直接按照官方文档的指引\",{\"1\":{\"538\":1}}],[\"直接删掉对应的数据即可\",{\"1\":{\"513\":1}}],[\"直接将其指向下下个节点\",{\"1\":{\"403\":1}}],[\"直接异或运算进行整数交换后\",{\"1\":{\"338\":1}}],[\"直接搜索数组a和b\",{\"1\":{\"327\":1,\"328\":1}}],[\"直接递归判断\",{\"1\":{\"187\":1}}],[\"直接模拟\",{\"1\":{\"156\":1}}],[\"直接模拟即可\",{\"1\":{\"88\":1}}],[\"直接输出\",{\"1\":{\"147\":3}}],[\"直接遍历即可\",{\"1\":{\"71\":1}}],[\"直接基于主键检索\",{\"1\":{\"56\":1}}],[\"直接向端上提供接口\",{\"1\":{\"51\":1}}],[\"直播场景下\",{\"1\":{\"33\":1,\"41\":1}}],[\"整理如下\",{\"1\":{\"1500\":1}}],[\"整理\",{\"1\":{\"1066\":1}}],[\"整型变量的自增\",{\"1\":{\"980\":1}}],[\"整棵树是二叉搜索树\",{\"1\":{\"900\":1}}],[\"整体示意图为下图\",{\"1\":{\"1504\":1}}],[\"整体来看这是一个这又是一个自旋的过程\",{\"1\":{\"1504\":1}}],[\"整体设计思路采用模板方法设计模式\",{\"1\":{\"1496\":1}}],[\"整体上功能一致\",{\"1\":{\"1371\":1}}],[\"整体上时间效率要增加很多\",{\"1\":{\"1313\":1}}],[\"整体的执行过程\",{\"1\":{\"1370\":1}}],[\"整体\",{\"1\":{\"893\":1}}],[\"整体思路就是让快指针先移动\",{\"1\":{\"777\":1}}],[\"整合\",{\"0\":{\"1098\":1},\"1\":{\"539\":1}}],[\"整合时\",{\"1\":{\"539\":1}}],[\"整合统一平台测的逻辑\",{\"1\":{\"51\":1}}],[\"整局游戏第一个行动的称为先手\",{\"1\":{\"394\":1}}],[\"整数的加减乘除四则运算\",{\"1\":{\"980\":1}}],[\"整数\",{\"1\":{\"704\":1}}],[\"整数分解\",{\"1\":{\"369\":1}}],[\"整数二分\",{\"0\":{\"324\":1}}],[\"整条路可以被分作\",{\"1\":{\"128\":1}}],[\"整个过程即为\",{\"1\":{\"1433\":1}}],[\"整个过程不再由我自己控制\",{\"1\":{\"1131\":1}}],[\"整个扩容操作分为两个部分\",{\"1\":{\"1274\":1}}],[\"整个堆并不是有序的\",{\"1\":{\"1078\":1}}],[\"整个有向图游戏g的sg函数值被定义为有向图游戏起点s的sg函数值\",{\"1\":{\"398\":1}}],[\"整个评论服务还会依赖一些外部\",{\"1\":{\"46\":1}}],[\"整个数据的展示都是通过\",{\"1\":{\"46\":1}}],[\"内存语义进行了分析\",{\"1\":{\"1486\":1}}],[\"内存语义\",{\"1\":{\"1457\":1}}],[\"内存屏障分类表\",{\"1\":{\"1457\":1}}],[\"内存屏障分为四类见下图\",{\"1\":{\"1457\":1}}],[\"内存抽象模型的\",{\"1\":{\"1433\":1}}],[\"内存系统的重排序\",{\"1\":{\"1418\":1}}],[\"内存模型只是要求上述两个操作是顺序执行的并不是连续执行的\",{\"1\":{\"1482\":1}}],[\"内存模型中说过\",{\"1\":{\"1485\":1}}],[\"内存模型中定义了\",{\"1\":{\"1482\":1}}],[\"内存模型中我们知道\",{\"1\":{\"1473\":1}}],[\"内存模型就是一弱内存数据模型\",{\"1\":{\"1473\":1}}],[\"内存模型为了能让处理器和编译器底层发挥他们的最大优势\",{\"1\":{\"1473\":1}}],[\"内存模型告诉我们\",{\"1\":{\"1453\":1}}],[\"内存模型的一些知识\",{\"1\":{\"1429\":1}}],[\"内存模型向程序员做出的保证\",{\"1\":{\"1420\":1}}],[\"内存模型将向程序员保证\",{\"1\":{\"1420\":1}}],[\"内存模型是共享内存的并发模型\",{\"1\":{\"1416\":1}}],[\"内存模型\",{\"1\":{\"1415\":1,\"1423\":1,\"1455\":1}}],[\"内存模型及\",{\"0\":{\"1414\":1}}],[\"内存地址存放的实际值\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"内存泄漏的前因后果\",{\"1\":{\"1320\":1}}],[\"内存泄漏就值得我们关注\",{\"1\":{\"1313\":1}}],[\"内存泄漏\",{\"1\":{\"1306\":1}}],[\"内存泄漏问题\",{\"0\":{\"1312\":1},\"1\":{\"1305\":1}}],[\"内存就会占用\",{\"1\":{\"1295\":1}}],[\"内存里会同时驻扎两个对象的内存\",{\"1\":{\"1295\":1}}],[\"内存里设置一个过期时间很短的比如\",{\"1\":{\"60\":1}}],[\"内存占用问题\",{\"1\":{\"1295\":1}}],[\"内存中的数据会全部清除\",{\"1\":{\"1200\":1}}],[\"内存的读写性能远超磁盘的读写性能\",{\"1\":{\"1200\":1}}],[\"内置异常方法\",{\"0\":{\"1046\":1}}],[\"内置异常类\",{\"0\":{\"1045\":1}}],[\"内置数据类型\",{\"1\":{\"978\":1}}],[\"内置工具类应有尽有\",{\"1\":{\"639\":1}}],[\"内完成插入\",{\"1\":{\"972\":1}}],[\"内连接从语法上可以分为\",{\"1\":{\"944\":1}}],[\"内连接查询\",{\"1\":{\"944\":1}}],[\"内连接\",{\"0\":{\"944\":1},\"1\":{\"943\":1}}],[\"内含q\",{\"1\":{\"647\":1}}],[\"内部实现就附加了两个阻塞操作\",{\"1\":{\"1411\":1}}],[\"内部是采用数组\",{\"1\":{\"1346\":1}}],[\"内部也是使用同样的方式\",{\"1\":{\"1250\":1}}],[\"内部维护的就是一个数组\",{\"1\":{\"1292\":1}}],[\"内部维护了一个\",{\"1\":{\"1305\":1}}],[\"内部维护了一个等待队列\",{\"1\":{\"1250\":1}}],[\"内部维护了一个同步队列\",{\"1\":{\"1250\":1}}],[\"内部维护着一个beandefinition\",{\"1\":{\"1137\":1}}],[\"内部\",{\"1\":{\"643\":1}}],[\"内部消化\",{\"1\":{\"599\":1}}],[\"内部运营体系基本都是基于\",{\"1\":{\"50\":1}}],[\"内的素数了\",{\"1\":{\"372\":1}}],[\"内的最大保质期商品\",{\"1\":{\"168\":1}}],[\"内有多少个素数\",{\"1\":{\"372\":1}}],[\"内\",{\"1\":{\"87\":3}}],[\"内容如下\",{\"1\":{\"1090\":1,\"1107\":1}}],[\"内容为\",{\"1\":{\"663\":1}}],[\"内容基本不变的网站\",{\"1\":{\"534\":1}}],[\"内容生成并发送给客户端\",{\"1\":{\"531\":1}}],[\"内容\",{\"1\":{\"512\":1,\"517\":1,\"533\":1,\"548\":1}}],[\"内容表的主键直接使用评论\",{\"1\":{\"57\":1}}],[\"内容分离\",{\"1\":{\"56\":1}}],[\"内容相关\",{\"1\":{\"39\":1}}],[\"内容的观点\",{\"1\":{\"21\":1}}],[\"逻辑几乎和独占式锁的获取一模一样\",{\"1\":{\"1510\":1}}],[\"逻辑走到\",{\"1\":{\"1251\":1}}],[\"逻辑外键\",{\"1\":{\"937\":1}}],[\"逻辑运算符\",{\"1\":{\"931\":2}}],[\"逻辑运算符和其他运算符都高\",{\"1\":{\"338\":1}}],[\"逻辑数据平台的\",{\"1\":{\"647\":1}}],[\"逻辑删除是指在数据库中不是真正删除记录\",{\"1\":{\"575\":1}}],[\"逻辑删除\",{\"1\":{\"515\":1,\"566\":1,\"575\":1}}],[\"逻辑右移\",{\"1\":{\"337\":1}}],[\"逻辑\",{\"1\":{\"50\":1,\"995\":1}}],[\"全场欢呼\",{\"1\":{\"1393\":2}}],[\"全称为\",{\"1\":{\"1129\":1}}],[\"全称\",{\"1\":{\"909\":1}}],[\"全新\",{\"1\":{\"886\":1}}],[\"全23种\",{\"1\":{\"623\":1}}],[\"全局变量\",{\"1\":{\"1116\":1}}],[\"全局请求日志和登录校验\",{\"1\":{\"599\":1}}],[\"全局逻辑删除字段名\",{\"1\":{\"575\":1}}],[\"全局顶部导航栏\",{\"0\":{\"550\":1}}],[\"全局底部栏\",{\"0\":{\"549\":1},\"1\":{\"549\":1}}],[\"全局布局文件中引入\",{\"1\":{\"548\":1}}],[\"全局通用布局\",{\"0\":{\"547\":1}}],[\"全局并行\",{\"1\":{\"49\":1}}],[\"全部为\",{\"1\":{\"1267\":1}}],[\"全部用大写字符\",{\"1\":{\"1005\":1}}],[\"全部用小写字符\",{\"1\":{\"1005\":1}}],[\"全部字段\",{\"1\":{\"925\":1}}],[\"全部字段添加数据\",{\"1\":{\"925\":1}}],[\"全部弹出后\",{\"1\":{\"731\":1}}],[\"全部数据权限\",{\"1\":{\"470\":1}}],[\"全部加起来\",{\"1\":{\"308\":1}}],[\"全程无需执行任何数据移动操作\",{\"1\":{\"438\":1}}],[\"全为\",{\"1\":{\"338\":2}}],[\"全量更新时\",{\"1\":{\"40\":1}}],[\"概论\",{\"0\":{\"1107\":1}}],[\"概述\",{\"0\":{\"941\":1,\"1093\":1}}],[\"概念\",{\"0\":{\"1200\":1},\"1\":{\"919\":1,\"937\":2}}],[\"概念的\",{\"1\":{\"49\":1}}],[\"概要设计\",{\"1\":{\"555\":1}}],[\"概览\",{\"0\":{\"24\":1}}],[\"透穿到存储层\",{\"1\":{\"49\":1}}],[\"里的死循环\",{\"1\":{\"1458\":1}}],[\"里缓存了该内存地址的数据无效\",{\"1\":{\"1454\":1}}],[\"里是默认启用的\",{\"1\":{\"1444\":1}}],[\"里是否存储着指向当前线程的偏向锁\",{\"1\":{\"1442\":1}}],[\"里默认的存放的对象的\",{\"1\":{\"1440\":1}}],[\"里到底装了多少东西其实是个不确定的数量\",{\"1\":{\"1275\":1}}],[\"里实际运行一遍\",{\"1\":{\"1107\":1}}],[\"里\",{\"1\":{\"613\":1,\"1318\":1}}],[\"里面有\",{\"1\":{\"1469\":1}}],[\"里面有很多获取配置项的方法\",{\"1\":{\"1151\":1}}],[\"里面\",{\"1\":{\"1184\":1,\"1301\":1}}],[\"里面的核心代码就是\",{\"1\":{\"1184\":1}}],[\"里面的类似这样的\",{\"1\":{\"1150\":1}}],[\"里面做了什么事情\",{\"1\":{\"1175\":1}}],[\"里面获取到的\",{\"1\":{\"1154\":1}}],[\"里面通过\",{\"1\":{\"1151\":1}}],[\"里面定义了很多获取配置项的方法\",{\"1\":{\"1147\":1}}],[\"里面主要的操作分为六步\",{\"1\":{\"1146\":1}}],[\"里面就差不多了\",{\"1\":{\"1141\":1}}],[\"里面是访问策略\",{\"1\":{\"1102\":1}}],[\"里面全是对应的每一个value\",{\"1\":{\"1074\":1}}],[\"里面配置站点\",{\"1\":{\"672\":1}}],[\"里面各个数字有多少个\",{\"1\":{\"309\":1}}],[\"里面只包含\",{\"1\":{\"82\":1}}],[\"里查了\",{\"1\":{\"60\":1}}],[\"里查到了数据就更新这个缓存\",{\"1\":{\"60\":1}}],[\"里查询数据写缓存\",{\"1\":{\"60\":1}}],[\"里拿出对应的数据再更新到缓存里\",{\"1\":{\"48\":1}}],[\"里消费消息\",{\"1\":{\"48\":1}}],[\"了同步状态的修改\",{\"1\":{\"1496\":1}}],[\"了在读\",{\"1\":{\"1475\":1}}],[\"了解flink\",{\"1\":{\"645\":1}}],[\"了解业务本身的本质\",{\"1\":{\"45\":1}}],[\"了\",{\"1\":{\"48\":1,\"228\":1,\"229\":1,\"235\":1,\"635\":1,\"820\":1,\"1283\":1,\"1406\":1,\"1485\":1}}],[\"把当前\",{\"1\":{\"1275\":1}}],[\"把处理的结果分别放在\",{\"1\":{\"1274\":1}}],[\"把他们分别放在\",{\"1\":{\"1274\":1}}],[\"把里面的配置项都放到一个\",{\"1\":{\"1151\":1}}],[\"把你要的东西主动给你\",{\"1\":{\"1131\":1}}],[\"把控制循环次数的变量从循环体中剥离\",{\"1\":{\"990\":1}}],[\"把两个数相乘\",{\"1\":{\"979\":1}}],[\"把两个数相加\",{\"1\":{\"979\":1}}],[\"把克隆节点的指针组装起来\",{\"1\":{\"887\":1}}],[\"把剩余部分接上\",{\"1\":{\"834\":1}}],[\"把岛屿\",{\"1\":{\"820\":1}}],[\"把二维数组中的每个格子看做\",{\"1\":{\"820\":1}}],[\"把弹出的节点按顺序接在链表后面\",{\"1\":{\"789\":1}}],[\"把原问题分解成规模更小的子问题进行求解\",{\"1\":{\"681\":1}}],[\"把题库\",{\"1\":{\"525\":1}}],[\"把数据湖作为中央存储库\",{\"1\":{\"438\":1}}],[\"把数据湖和数据仓库集成起来只是第一步\",{\"1\":{\"438\":1}}],[\"把数据拿出来返回\",{\"1\":{\"48\":1}}],[\"把一个变量从主内存中复制到工作内存中就需要执行\",{\"1\":{\"1482\":1}}],[\"把一个数组去重\",{\"1\":{\"423\":1}}],[\"把一个\",{\"1\":{\"423\":2}}],[\"把一个方程的若干倍加到另一个方程上去\",{\"1\":{\"385\":1}}],[\"把第k位取反\",{\"1\":{\"422\":1}}],[\"把所有位变成0\",{\"1\":{\"422\":1}}],[\"把所有位置成1\",{\"1\":{\"422\":1}}],[\"把每个局面看成图中的一个节点\",{\"1\":{\"396\":1}}],[\"把游戏过程中面临的状态称为局面\",{\"1\":{\"394\":1}}],[\"把这个对象赋值给成员变量\",{\"1\":{\"1475\":1}}],[\"把这个岛屿\",{\"1\":{\"820\":1}}],[\"把这个让给我好吧\",{\"1\":{\"363\":1}}],[\"把这一行换到最上面\",{\"1\":{\"385\":1}}],[\"把某行的若干倍加到另一行上去\",{\"1\":{\"385\":1}}],[\"把某一行乘一个非00的数\",{\"1\":{\"385\":1}}],[\"把找到的符合条件的点的长度加上\",{\"1\":{\"360\":1}}],[\"把b加入\",{\"1\":{\"355\":1}}],[\"把相同的数据进行合并输出\",{\"1\":{\"933\":1}}],[\"把相加后的结果除以10求余\",{\"1\":{\"327\":1}}],[\"把相应的依赖划分为强依赖\",{\"1\":{\"34\":1}}],[\"把集合选\",{\"1\":{\"308\":1}}],[\"把下边的岛屿淹掉\",{\"1\":{\"229\":1}}],[\"把上边的岛屿淹掉\",{\"1\":{\"229\":1}}],[\"把靠右边的岛屿淹掉\",{\"1\":{\"229\":1}}],[\"把靠左边的岛屿淹掉\",{\"1\":{\"229\":1}}],[\"把\",{\"1\":{\"61\":1,\"200\":1,\"224\":1,\"288\":1,\"795\":1}}],[\"把单表变宽预处理好\",{\"1\":{\"50\":1}}],[\"把对存储的直接冲击\",{\"1\":{\"49\":1}}],[\"触发器\",{\"1\":{\"479\":1}}],[\"触发\",{\"1\":{\"48\":1}}],[\"惊群问题\",{\"1\":{\"48\":1}}],[\"预备知识\",{\"0\":{\"1404\":1}}],[\"预期的值\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"预计同时操作数据的线程\",{\"1\":{\"1270\":1}}],[\"预计消费金额为\",{\"1\":{\"162\":1}}],[\"预分配空间\",{\"1\":{\"743\":1}}],[\"预处理范围内的所有质数\",{\"1\":{\"390\":1}}],[\"预处理阶乘的余数和阶乘逆元的余数\",{\"1\":{\"388\":1}}],[\"预处理出\",{\"1\":{\"381\":1}}],[\"预处理\",{\"1\":{\"178\":1}}],[\"预处理最长递增子序列\",{\"1\":{\"66\":1}}],[\"预加载少量数据\",{\"1\":{\"58\":1}}],[\"预读\",{\"1\":{\"48\":1}}],[\"预先计算好排序分数并写入\",{\"1\":{\"40\":1}}],[\"非阻塞式响应中断能立即返回\",{\"1\":{\"1493\":1}}],[\"非公平锁\",{\"1\":{\"1233\":1}}],[\"非结构化数据\",{\"1\":{\"1093\":1}}],[\"非结构性修改\",{\"1\":{\"1072\":1}}],[\"非检查性异常\",{\"1\":{\"1045\":1}}],[\"非运行时异常是\",{\"1\":{\"1044\":1}}],[\"非静态成员变量\",{\"1\":{\"1015\":1}}],[\"非叶子节点都是由\",{\"1\":{\"958\":1}}],[\"非叶子节点\",{\"1\":{\"958\":2}}],[\"非\",{\"1\":{\"931\":1,\"985\":1}}],[\"非做不可\",{\"1\":{\"506\":1}}],[\"非remember\",{\"1\":{\"446\":1}}],[\"非常适合存储大容量的数据\",{\"1\":{\"1093\":1}}],[\"非常方便使用\",{\"1\":{\"1095\":1}}],[\"非常方便\",{\"1\":{\"670\":1,\"1100\":1}}],[\"非常有意思的说法是\",{\"1\":{\"411\":1}}],[\"非常不利于迭代\",{\"1\":{\"47\":1}}],[\"非匹配边\",{\"1\":{\"363\":1}}],[\"非空返回true\",{\"1\":{\"1077\":1}}],[\"非空约束\",{\"1\":{\"919\":1}}],[\"非空校验\",{\"1\":{\"568\":1,\"575\":1}}],[\"非空\",{\"1\":{\"71\":1,\"568\":1,\"574\":1,\"698\":1,\"704\":1,\"771\":1}}],[\"非数据库写操作的其他业务逻辑\",{\"1\":{\"33\":1}}],[\"业务代码逻辑\",{\"1\":{\"1309\":1}}],[\"业务逻辑执行成功做出响应\",{\"1\":{\"576\":1}}],[\"业务逻辑层\",{\"0\":{\"516\":1}}],[\"业务层实现更灵活\",{\"1\":{\"525\":1}}],[\"业务层分步查询\",{\"1\":{\"525\":1}}],[\"业务数据中\",{\"1\":{\"436\":1}}],[\"业务数据模型是最为复杂的\",{\"1\":{\"25\":1}}],[\"业务耦合和功能耦合在一起\",{\"1\":{\"47\":1}}],[\"尽可能地提高程序执行的并行度\",{\"1\":{\"1420\":1}}],[\"尽可能提高并行度\",{\"1\":{\"1418\":1}}],[\"尽可能保证极端情况下用户无感\",{\"1\":{\"34\":1}}],[\"尽管依然满足了\",{\"1\":{\"1478\":1}}],[\"尽管\",{\"1\":{\"1420\":1,\"1430\":1,\"1482\":1}}],[\"尽管会出现内存泄漏的问题\",{\"1\":{\"1318\":1}}],[\"尽管有可能中间间隔了好几秒才感知到\",{\"1\":{\"1295\":1}}],[\"尽管此时队列由于\",{\"1\":{\"1284\":1}}],[\"尽量保证每个锁只占用一个资源\",{\"1\":{\"1221\":1}}],[\"尽量避免\",{\"1\":{\"46\":1}}],[\"梳理清楚数据的走向和逻辑\",{\"1\":{\"46\":1}}],[\"ds\",{\"1\":{\"1192\":2}}],[\"dserver\",{\"1\":{\"488\":1}}],[\"dl\",{\"1\":{\"1087\":1,\"1089\":1}}],[\"dcl等这些问题\",{\"1\":{\"1221\":1}}],[\"dcl\",{\"1\":{\"909\":2,\"1418\":1,\"1425\":1}}],[\"dcdn\",{\"1\":{\"617\":1}}],[\"dmin\",{\"1\":{\"1083\":1}}],[\"dmax\",{\"1\":{\"1083\":1}}],[\"dml英文全称是\",{\"1\":{\"924\":1}}],[\"dml\",{\"0\":{\"924\":1},\"1\":{\"909\":2}}],[\"dmg\",{\"1\":{\"665\":1}}],[\"dd\",{\"1\":{\"870\":2,\"920\":3,\"1309\":1}}],[\"ddl\",{\"0\":{\"910\":1},\"1\":{\"517\":1,\"909\":2,\"911\":2}}],[\"due\",{\"1\":{\"1317\":1}}],[\"dump\",{\"1\":{\"1259\":5}}],[\"dummp\",{\"1\":{\"699\":1,\"834\":2}}],[\"dummy\",{\"1\":{\"134\":3,\"700\":3,\"777\":3,\"778\":4,\"789\":3,\"888\":4}}],[\"duration>\",{\"1\":{\"1210\":1}}],[\"duration\",{\"1\":{\"1201\":1,\"1210\":10,\"1211\":1}}],[\"durability\",{\"1\":{\"955\":2}}],[\"duplicatekeyexception\",{\"1\":{\"526\":1}}],[\"dto\",{\"1\":{\"516\":1,\"517\":2,\"526\":1}}],[\"dkd\",{\"1\":{\"446\":5,\"447\":1,\"458\":1,\"471\":1,\"487\":1}}],[\"d2\",{\"1\":{\"219\":2}}],[\"d2​\",{\"1\":{\"128\":1}}],[\"dynamicpropertyfactory\",{\"1\":{\"1149\":2,\"1150\":3,\"1151\":2,\"1157\":1}}],[\"dynamicstringproperty\",{\"1\":{\"1149\":1}}],[\"dy\",{\"1\":{\"197\":2,\"218\":2,\"219\":3,\"220\":3,\"224\":2,\"228\":4,\"229\":2,\"235\":2,\"236\":2,\"237\":2,\"278\":2,\"279\":2,\"821\":2,\"870\":2}}],[\"dx\",{\"1\":{\"197\":2,\"218\":2,\"219\":3,\"220\":3,\"224\":2,\"228\":4,\"229\":2,\"235\":2,\"236\":2,\"237\":2,\"278\":2,\"279\":2,\"821\":2,\"870\":2}}],[\"dxy\",{\"1\":{\"77\":1}}],[\"druid\",{\"1\":{\"446\":1,\"493\":1,\"500\":1}}],[\"draw\",{\"1\":{\"174\":2}}],[\"drop\",{\"1\":{\"60\":1,\"915\":2,\"922\":1,\"923\":1,\"959\":1}}],[\"d≤109\",{\"1\":{\"166\":1}}],[\"d≤107\",{\"1\":{\"65\":1}}],[\"dn​\",{\"1\":{\"128\":1}}],[\"d1​\",{\"1\":{\"128\":1}}],[\"died\",{\"1\":{\"1359\":1}}],[\"didn\",{\"1\":{\"1317\":1}}],[\"did\",{\"1\":{\"1244\":1}}],[\"di\",{\"0\":{\"1130\":1,\"1132\":1},\"1\":{\"1129\":1,\"1132\":3}}],[\"diameterofbinarytree\",{\"1\":{\"761\":1}}],[\"digestutils\",{\"1\":{\"568\":1,\"575\":1}}],[\"displaced\",{\"1\":{\"1446\":1,\"1447\":1}}],[\"discardoldestpolicy\",{\"1\":{\"1359\":1}}],[\"discardpolicy\",{\"1\":{\"1359\":1}}],[\"discoveryclient\",{\"1\":{\"1157\":1,\"1158\":5,\"1182\":4,\"1184\":4,\"1185\":1}}],[\"disallow\",{\"1\":{\"543\":1}}],[\"disable\",{\"1\":{\"446\":3}}],[\"distributing\",{\"1\":{\"1275\":1}}],[\"distinct\",{\"1\":{\"930\":1}}],[\"distance+w\",{\"1\":{\"223\":1}}],[\"distance\",{\"1\":{\"223\":5,\"305\":2,\"345\":3,\"353\":3,\"416\":1}}],[\"dist\",{\"1\":{\"180\":3,\"221\":4,\"223\":14,\"224\":7,\"279\":3,\"345\":7,\"352\":11,\"353\":9,\"354\":19,\"355\":10,\"356\":6,\"360\":10}}],[\"div>\",{\"1\":{\"542\":1,\"549\":3,\"587\":2,\"592\":1}}],[\"divisors\",{\"1\":{\"375\":1}}],[\"divisor\",{\"1\":{\"369\":1}}],[\"divide\",{\"1\":{\"368\":1}}],[\"div\",{\"1\":{\"330\":2}}],[\"dijkstra算法\",{\"0\":{\"352\":1}}],[\"dijkstra\",{\"0\":{\"213\":1},\"1\":{\"213\":3,\"214\":1,\"216\":1,\"223\":3,\"352\":2,\"353\":1}}],[\"direct\",{\"1\":{\"1158\":2}}],[\"directive\",{\"1\":{\"457\":2}}],[\"dir\",{\"1\":{\"180\":2}}],[\"di​\",{\"1\":{\"128\":3}}],[\"differ\",{\"1\":{\"1275\":1}}],[\"different\",{\"1\":{\"1149\":1,\"1239\":1}}],[\"diff\",{\"1\":{\"122\":2,\"167\":6}}],[\"dfs思路\",{\"1\":{\"362\":1}}],[\"dfs之迷宫问题\",{\"0\":{\"234\":1}}],[\"dfs之岛屿问题\",{\"0\":{\"227\":1}}],[\"dfs\",{\"0\":{\"281\":1,\"820\":1},\"1\":{\"121\":3,\"197\":4,\"203\":3,\"227\":2,\"228\":4,\"229\":7,\"230\":7,\"234\":2,\"235\":4,\"236\":3,\"237\":4,\"238\":1,\"255\":3,\"281\":3,\"287\":4,\"288\":3,\"289\":3,\"290\":4,\"291\":6,\"314\":3,\"345\":4,\"347\":2,\"362\":4,\"710\":4,\"736\":4,\"761\":4,\"784\":5,\"795\":17,\"796\":2,\"815\":4,\"820\":10,\"851\":2,\"875\":1,\"876\":3,\"881\":2,\"882\":4,\"901\":4},\"2\":{\"208\":1,\"233\":1,\"240\":1,\"285\":1,\"824\":1,\"878\":1}}],[\"dql\",{\"0\":{\"928\":1},\"1\":{\"909\":2,\"929\":1,\"930\":1}}],[\"dq\",{\"1\":{\"110\":10,\"122\":10}}],[\"daemodthread\",{\"1\":{\"1340\":1}}],[\"daemonthread\",{\"1\":{\"1340\":6}}],[\"daemondemo\",{\"1\":{\"1340\":3}}],[\"daemon\",{\"0\":{\"1340\":1},\"1\":{\"671\":2,\"1340\":1}}],[\"das\",{\"1\":{\"1095\":1}}],[\"day\",{\"1\":{\"986\":2}}],[\"days\",{\"1\":{\"65\":4}}],[\"dao\",{\"1\":{\"526\":1}}],[\"dateutil\",{\"1\":{\"1309\":3}}],[\"dateformatter=\",{\"1\":{\"592\":1}}],[\"datetime\",{\"1\":{\"510\":3,\"511\":3,\"512\":3,\"513\":2,\"566\":3,\"592\":2,\"920\":1}}],[\"date\",{\"1\":{\"471\":2,\"549\":1,\"589\":1,\"920\":1,\"1248\":1,\"1309\":8,\"1410\":1}}],[\"datacenter\",{\"1\":{\"1145\":2}}],[\"database\",{\"0\":{\"1531\":1},\"1\":{\"912\":2,\"913\":3,\"915\":3}}],[\"databases\",{\"1\":{\"912\":1}}],[\"dataindex\",{\"1\":{\"592\":11}}],[\"datascopeaspect\",{\"1\":{\"471\":1}}],[\"datascope\",{\"1\":{\"471\":7}}],[\"data\",{\"0\":{\"1521\":1},\"1\":{\"434\":1,\"515\":1,\"517\":2,\"526\":2,\"574\":1,\"576\":2,\"592\":1,\"598\":1,\"909\":4,\"911\":1,\"924\":1,\"935\":1,\"1087\":7,\"1088\":1,\"1089\":2,\"1090\":1,\"1100\":1,\"1190\":1,\"1201\":1,\"1244\":2}}],[\"datapage\",{\"1\":{\"56\":1}}],[\"dave\",{\"1\":{\"129\":1}}],[\"debug\",{\"1\":{\"1250\":3,\"1283\":1,\"1284\":1,\"1295\":1,\"1317\":1}}],[\"deeptostring\",{\"1\":{\"1002\":1}}],[\"decoratetask\",{\"1\":{\"1368\":2,\"1370\":1}}],[\"decrease\",{\"1\":{\"1351\":1}}],[\"decimal\",{\"1\":{\"920\":1}}],[\"declare\",{\"1\":{\"589\":1,\"1114\":2,\"1116\":2}}],[\"deadline\",{\"1\":{\"1248\":1,\"1259\":3,\"1410\":1,\"1508\":5}}],[\"deadlock\",{\"1\":{\"1221\":3}}],[\"deadlockdemo$1\",{\"1\":{\"1221\":1}}],[\"deadlockdemo$2\",{\"1\":{\"1221\":1}}],[\"deadlockdemo\",{\"1\":{\"1221\":3}}],[\"dead\",{\"1\":{\"663\":1}}],[\"demos\",{\"1\":{\"592\":1}}],[\"demo\",{\"1\":{\"555\":1,\"1149\":1,\"1221\":1,\"1250\":1,\"1284\":1,\"1387\":1,\"1431\":2,\"1475\":3}}],[\"dev\",{\"1\":{\"538\":1,\"539\":2,\"1089\":2}}],[\"development文件设置了统一请求路径前缀\",{\"1\":{\"448\":1}}],[\"deserializes\",{\"1\":{\"1496\":1}}],[\"desired\",{\"1\":{\"1270\":1}}],[\"design\",{\"0\":{\"1516\":1,\"1533\":1},\"1\":{\"499\":1,\"540\":12,\"548\":1,\"557\":2,\"559\":3,\"585\":1,\"587\":1,\"592\":4}}],[\"desc\",{\"1\":{\"921\":1,\"934\":1}}],[\"description>\",{\"1\":{\"1090\":1}}],[\"description=cloudreve\",{\"1\":{\"671\":1}}],[\"description\",{\"1\":{\"511\":1}}],[\"details\",{\"1\":{\"484\":1,\"576\":1,\"1140\":1,\"1171\":1}}],[\"deployment\",{\"1\":{\"1149\":1}}],[\"deprecated\",{\"1\":{\"1052\":1}}],[\"depth\",{\"1\":{\"736\":4}}],[\"dept\",{\"1\":{\"471\":17,\"942\":4}}],[\"deptalias\",{\"1\":{\"471\":3}}],[\"dependency>\",{\"1\":{\"568\":1,\"1099\":1,\"1203\":1,\"1206\":1,\"1209\":1}}],[\"dependency\",{\"1\":{\"46\":1,\"1129\":1,\"1132\":1}}],[\"denyall\",{\"1\":{\"446\":1}}],[\"denormalized\",{\"1\":{\"436\":1}}],[\"dequeue\",{\"1\":{\"1348\":5,\"1352\":1}}],[\"deque接口\",{\"1\":{\"1075\":1}}],[\"deque\",{\"0\":{\"1077\":1},\"1\":{\"422\":1,\"1075\":3,\"1077\":2}}],[\"deque<e>\",{\"1\":{\"1075\":1,\"1077\":1}}],[\"deque<integer>\",{\"1\":{\"845\":1}}],[\"deque<int>\",{\"1\":{\"110\":1}}],[\"deque<pair<int\",{\"1\":{\"122\":1}}],[\"definition\",{\"1\":{\"909\":1,\"911\":1}}],[\"define\",{\"1\":{\"65\":1,\"110\":1,\"122\":1,\"206\":1,\"223\":4,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"261\":1,\"262\":1,\"263\":1,\"278\":1,\"324\":1,\"353\":1,\"360\":1,\"372\":1,\"384\":1,\"392\":1,\"431\":1}}],[\"defaultreadobject\",{\"1\":{\"1496\":1}}],[\"defaulteurekaservercontext\",{\"1\":{\"1163\":2}}],[\"defaulteurekaserverconfig\",{\"1\":{\"1147\":1,\"1148\":2,\"1150\":6,\"1151\":3}}],[\"defaulteurekatransportconfig\",{\"1\":{\"1157\":1}}],[\"defaulteurekaclientconfig\",{\"1\":{\"1157\":1,\"1175\":1}}],[\"defaultconfigfilename\",{\"1\":{\"1149\":1}}],[\"defaultlistablebeanfactory\",{\"1\":{\"1137\":1}}],[\"defaultvalue\",{\"1\":{\"1074\":1}}],[\"defaultsettings\",{\"1\":{\"591\":2}}],[\"default\",{\"1\":{\"510\":5,\"511\":4,\"512\":4,\"513\":2,\"540\":1,\"542\":1,\"548\":1,\"549\":1,\"566\":6,\"580\":1,\"592\":3,\"919\":1,\"986\":1,\"1150\":1,\"1190\":1,\"1271\":2,\"1306\":1}}],[\"def\",{\"1\":{\"167\":1,\"1122\":2,\"1123\":1,\"1124\":1,\"1125\":1}}],[\"delay\",{\"1\":{\"1367\":3,\"1368\":2,\"1370\":2}}],[\"delayedexecute\",{\"1\":{\"1368\":1,\"1370\":4}}],[\"delayedworkqueue是基于堆的数据结构\",{\"1\":{\"1369\":1}}],[\"delayedworkqueue是由一个大小为16的数组组成\",{\"1\":{\"1369\":1}}],[\"delayedworkqueue\",{\"0\":{\"1369\":1},\"1\":{\"1365\":2,\"1366\":6,\"1368\":1,\"1369\":9,\"1370\":1,\"1371\":1}}],[\"delayed\",{\"1\":{\"1326\":2}}],[\"delayqueue\",{\"1\":{\"1326\":3,\"1369\":1}}],[\"delight\",{\"1\":{\"1270\":1}}],[\"deletion\",{\"1\":{\"1267\":1}}],[\"deleteuser\",{\"1\":{\"579\":1}}],[\"deletemapping\",{\"1\":{\"579\":1}}],[\"delete\",{\"0\":{\"927\":1},\"1\":{\"129\":5,\"575\":4,\"579\":1,\"592\":1,\"924\":1,\"927\":4,\"947\":1,\"957\":1}}],[\"delta\",{\"1\":{\"129\":3,\"1385\":1,\"1386\":1}}],[\"del\",{\"1\":{\"99\":2,\"471\":4}}],[\"dp\",{\"1\":{\"65\":12,\"72\":18,\"104\":19,\"109\":17,\"110\":12,\"115\":17,\"120\":31,\"126\":17,\"127\":29,\"135\":11,\"142\":9,\"178\":15,\"182\":17,\"307\":7,\"309\":3,\"314\":14,\"772\":22,\"783\":11,\"827\":5,\"846\":37,\"851\":9,\"852\":1}}],[\"dp数组的转移如代码所示\",{\"1\":{\"120\":1}}],[\"dp数组\",{\"1\":{\"65\":1}}],[\"d\",{\"1\":{\"65\":2,\"77\":1,\"97\":3,\"156\":4,\"166\":7,\"180\":3,\"218\":1,\"219\":2,\"220\":1,\"221\":13,\"223\":1,\"224\":1,\"248\":3,\"251\":2,\"255\":1,\"257\":1,\"273\":5,\"278\":8,\"279\":5,\"281\":1,\"309\":1,\"314\":4,\"327\":1,\"328\":2,\"329\":1,\"345\":4,\"349\":3,\"358\":7,\"360\":1,\"383\":5,\"384\":7,\"411\":1,\"416\":6,\"422\":1,\"471\":9,\"559\":1,\"589\":2,\"870\":3,\"978\":1,\"982\":1,\"984\":25,\"994\":1,\"997\":1,\"998\":1,\"999\":5,\"1000\":1,\"1001\":1,\"1005\":2,\"1011\":1,\"1020\":2,\"1027\":2,\"1028\":2,\"1069\":3,\"1089\":2,\"1103\":3,\"1158\":3}}],[\"dgraph\",{\"1\":{\"56\":1}}],[\"db01\",{\"1\":{\"915\":1}}],[\"db\",{\"1\":{\"48\":2,\"56\":1,\"575\":1,\"670\":1}}],[\"doing\",{\"1\":{\"1511\":1}}],[\"doreleaseshared\",{\"1\":{\"1511\":3}}],[\"doacquireshared\",{\"1\":{\"1510\":3}}],[\"doacquirenanos\",{\"1\":{\"1508\":3}}],[\"doacquireinterruptibly\",{\"1\":{\"1507\":3}}],[\"don\",{\"1\":{\"1306\":1,\"1314\":1,\"1505\":1}}],[\"donaldervinknuth\",{\"1\":{\"1218\":1}}],[\"doug\",{\"1\":{\"1491\":1}}],[\"douglea\",{\"1\":{\"1264\":1,\"1280\":1,\"1286\":1,\"1290\":1,\"1324\":1}}],[\"doule\",{\"1\":{\"1385\":1}}],[\"double\",{\"1\":{\"97\":2,\"325\":6,\"920\":1,\"978\":2,\"980\":1,\"981\":1,\"982\":1,\"997\":2,\"1005\":2,\"1022\":4,\"1083\":2,\"1306\":1,\"1359\":1,\"1418\":3,\"1482\":1,\"1485\":1}}],[\"dosignalall\",{\"1\":{\"1252\":3}}],[\"dosignal\",{\"1\":{\"1252\":5}}],[\"does\",{\"1\":{\"1242\":1,\"1496\":1,\"1511\":1}}],[\"doocs\",{\"1\":{\"766\":1}}],[\"dom\",{\"1\":{\"532\":3}}],[\"domain\",{\"1\":{\"37\":1,\"567\":1,\"576\":1}}],[\"document\",{\"1\":{\"1053\":1}}],[\"documentation=https\",{\"1\":{\"671\":1}}],[\"doc\",{\"1\":{\"520\":1}}],[\"docs\",{\"1\":{\"446\":1,\"537\":1,\"538\":1,\"539\":2,\"540\":1,\"542\":1,\"543\":2,\"588\":1,\"671\":1,\"1095\":1,\"1275\":1}}],[\"docker镜像构建优化\",{\"1\":{\"628\":1}}],[\"docker\",{\"0\":{\"16\":1,\"608\":1,\"1088\":1},\"1\":{\"1088\":4}}],[\"docker等等\",{\"1\":{\"7\":1}}],[\"downgrade\",{\"1\":{\"1244\":1}}],[\"download\",{\"1\":{\"1086\":1}}],[\"down和up只会执行其中一个\",{\"1\":{\"417\":1}}],[\"down\",{\"1\":{\"417\":6,\"1359\":2}}],[\"do\",{\"0\":{\"989\":1},\"1\":{\"317\":2,\"989\":4,\"1252\":2,\"1315\":1,\"1408\":1,\"1505\":1}}],[\"订阅\",{\"1\":{\"46\":1}}],[\"尤其注意参数名的修改\",{\"1\":{\"583\":1}}],[\"尤其是\",{\"1\":{\"539\":1}}],[\"尤其是热评的头部\",{\"1\":{\"41\":1}}],[\"尤其喜欢\",{\"1\":{\"161\":1}}],[\"尤其划分运营平台\",{\"1\":{\"46\":1}}],[\"加一\",{\"1\":{\"1482\":1}}],[\"加\",{\"1\":{\"1388\":1}}],[\"加到函数上\",{\"1\":{\"1062\":1}}],[\"加到代码块上\",{\"1\":{\"1062\":1}}],[\"加到集合当中去\",{\"1\":{\"360\":1}}],[\"加速\",{\"1\":{\"668\":1}}],[\"加密后的数据如何进行模糊查询\",{\"1\":{\"629\":1}}],[\"加锁线程\",{\"1\":{\"1455\":1}}],[\"加锁和解锁必须在一个数据库连接里\",{\"1\":{\"1221\":1}}],[\"加锁\",{\"0\":{\"1446\":1},\"1\":{\"526\":1,\"1432\":1,\"1433\":1}}],[\"加1\",{\"1\":{\"411\":1}}],[\"加边法\",{\"1\":{\"361\":1}}],[\"加点法\",{\"1\":{\"360\":1}}],[\"加上\",{\"1\":{\"327\":1,\"328\":1,\"1306\":1}}],[\"加上剩余的字符\",{\"1\":{\"82\":1}}],[\"加入同步队列的线程引用\",{\"1\":{\"1501\":1}}],[\"加入答案\",{\"1\":{\"881\":1}}],[\"加入新的一层\",{\"1\":{\"870\":1}}],[\"加入进来\",{\"1\":{\"820\":1}}],[\"加入下一个字符\",{\"1\":{\"802\":1}}],[\"加入到集合中\",{\"1\":{\"361\":1}}],[\"加入到连通块中\",{\"1\":{\"360\":1}}],[\"加入到结果数组中即可\",{\"1\":{\"108\":1}}],[\"加入i后更新当前a的值\",{\"1\":{\"291\":1}}],[\"加入\",{\"1\":{\"215\":1,\"789\":1}}],[\"加人\",{\"1\":{\"129\":1}}],[\"加载因子为\",{\"1\":{\"1306\":1}}],[\"加载因子越大\",{\"1\":{\"1306\":1}}],[\"加载因子是衡量哈希表密集程度的一个参数\",{\"1\":{\"1306\":1}}],[\"加载因子以及并发度\",{\"1\":{\"1270\":1}}],[\"加载因子\",{\"1\":{\"1266\":1,\"1271\":1,\"1272\":2,\"1306\":1}}],[\"加载配置文件小结\",{\"0\":{\"1151\":1}}],[\"加载配置文件\",{\"0\":{\"1149\":1},\"1\":{\"1182\":1}}],[\"加载模式\",{\"1\":{\"58\":1}}],[\"加载\",{\"0\":{\"1147\":1},\"1\":{\"46\":1}}],[\"加权平均高\",{\"1\":{\"39\":1}}],[\"层序遍历\",{\"0\":{\"737\":1,\"749\":1},\"1\":{\"741\":1}}],[\"层实现接口\",{\"1\":{\"596\":1}}],[\"层实现业务请求\",{\"1\":{\"576\":1}}],[\"层已经写好了注册和登录的业务逻辑\",{\"1\":{\"576\":1}}],[\"层是对业务逻辑的校验\",{\"1\":{\"576\":1}}],[\"层倾向于对请求参数本身的校验\",{\"1\":{\"576\":1}}],[\"层中\",{\"1\":{\"526\":1}}],[\"层中逻辑非常简单\",{\"1\":{\"526\":1}}],[\"层中讲究的是复用性\",{\"1\":{\"526\":1}}],[\"层子楼层\",{\"1\":{\"56\":1}}],[\"层收敛\",{\"1\":{\"46\":1}}],[\"层\",{\"1\":{\"46\":1,\"596\":1}}],[\"keepalivetime\",{\"1\":{\"1359\":4}}],[\"keyexpiremap\",{\"1\":{\"1210\":4}}],[\"key已过期\",{\"1\":{\"1207\":3}}],[\"key过期\",{\"1\":{\"1204\":3}}],[\"keys\",{\"1\":{\"1074\":1}}],[\"keyset\",{\"1\":{\"687\":1,\"1074\":2}}],[\"key存放路径\",{\"1\":{\"672\":1}}],[\"key=\",{\"1\":{\"592\":3}}],[\"key\",{\"1\":{\"31\":2,\"40\":1,\"48\":1,\"50\":2,\"58\":2,\"60\":2,\"61\":5,\"422\":1,\"493\":1,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"566\":1,\"587\":1,\"589\":1,\"592\":3,\"596\":1,\"613\":3,\"672\":3,\"686\":5,\"687\":15,\"688\":5,\"919\":2,\"937\":5,\"958\":7,\"971\":1,\"1039\":2,\"1040\":6,\"1074\":7,\"1201\":12,\"1207\":2,\"1210\":12,\"1264\":2,\"1267\":4,\"1272\":20,\"1273\":9,\"1274\":2,\"1301\":4,\"1302\":2,\"1303\":1,\"1305\":7,\"1306\":10,\"1307\":9,\"1308\":6,\"1313\":2,\"1314\":6,\"1316\":3,\"1317\":20,\"1318\":1}}],[\"know\",{\"1\":{\"1359\":1,\"1511\":1}}],[\"known\",{\"1\":{\"1315\":1,\"1316\":1}}],[\"knuth\",{\"1\":{\"1316\":2}}],[\"ksh\",{\"1\":{\"1107\":1}}],[\"k8s\",{\"1\":{\"1095\":1}}],[\"kthsmallest\",{\"1\":{\"710\":1,\"713\":3}}],[\"k个一组翻转链表\",{\"1\":{\"679\":1}}],[\"killmode=mixed\",{\"1\":{\"671\":1}}],[\"ki​\",{\"1\":{\"168\":4}}],[\"kmp\",{\"0\":{\"411\":1}}],[\"k指向的下一节点指向新节点\",{\"1\":{\"403\":1}}],[\"k2\",{\"1\":{\"384\":2}}],[\"k1\",{\"1\":{\"384\":7}}],[\"k表示走到j这个点之前\",{\"1\":{\"312\":1}}],[\"k辆车\",{\"1\":{\"290\":1}}],[\"kruskal\",{\"0\":{\"361\":1},\"1\":{\"267\":1,\"361\":1}}],[\"k==0\",{\"1\":{\"261\":1}}],[\"k=2\",{\"1\":{\"99\":1,\"152\":1}}],[\"k⩽1000001⩽ai​⩽100000\",{\"1\":{\"261\":1}}],[\"k++\",{\"1\":{\"223\":1,\"298\":2,\"299\":2,\"307\":2,\"309\":3,\"312\":1,\"318\":4,\"358\":1,\"420\":1,\"821\":1,\"870\":1}}],[\"k≤2×105\",{\"1\":{\"173\":1}}],[\"k≤20\",{\"1\":{\"156\":1}}],[\"k≤1018\",{\"1\":{\"167\":1}}],[\"k≤1000\",{\"1\":{\"72\":1}}],[\"k−1\",{\"1\":{\"99\":1,\"119\":1}}],[\"k\",{\"0\":{\"679\":1,\"787\":1},\"1\":{\"72\":11,\"77\":5,\"99\":12,\"110\":2,\"119\":9,\"120\":1,\"121\":6,\"122\":5,\"129\":2,\"141\":13,\"142\":17,\"152\":4,\"156\":2,\"167\":16,\"173\":9,\"223\":9,\"261\":16,\"279\":5,\"290\":8,\"298\":22,\"299\":10,\"307\":8,\"309\":12,\"311\":2,\"312\":7,\"318\":1,\"322\":1,\"338\":2,\"339\":9,\"345\":1,\"358\":4,\"373\":1,\"381\":9,\"388\":4,\"389\":4,\"403\":6,\"404\":11,\"417\":8,\"419\":5,\"420\":6,\"421\":2,\"422\":3,\"613\":5,\"680\":3,\"681\":2,\"682\":6,\"709\":2,\"710\":8,\"711\":1,\"712\":10,\"713\":5,\"767\":1,\"789\":1,\"821\":4,\"856\":2,\"857\":4,\"870\":4,\"994\":3,\"1047\":2,\"1074\":5,\"1107\":1,\"1210\":6,\"1264\":1,\"1267\":1,\"1270\":1,\"1272\":3,\"1273\":1,\"1274\":1,\"1305\":3,\"1306\":6,\"1307\":3,\"1314\":3,\"1316\":3,\"1317\":6}}],[\"kv\",{\"1\":{\"56\":1,\"57\":1}}],[\"kafka\",{\"1\":{\"48\":1,\"49\":3,\"58\":2,\"60\":4}}],[\"kong\",{\"1\":{\"46\":1}}],[\"ncpu\",{\"1\":{\"1274\":2}}],[\"n为str长度\",{\"1\":{\"1069\":2}}],[\"n为选修课程数\",{\"1\":{\"876\":1}}],[\"n为模式串长度\",{\"1\":{\"411\":1}}],[\"ng++\",{\"1\":{\"852\":1}}],[\"ng\",{\"1\":{\"852\":4}}],[\"nginx\",{\"1\":{\"46\":1,\"586\":1,\"664\":1,\"672\":15}}],[\"nlong\",{\"1\":{\"852\":1}}],[\"nlog\",{\"1\":{\"850\":1}}],[\"nlogn\",{\"1\":{\"134\":2,\"324\":1,\"833\":1}}],[\"n​\",{\"1\":{\"795\":1,\"796\":1}}],[\"nxt\",{\"1\":{\"682\":4}}],[\"nt\",{\"1\":{\"1271\":2,\"1274\":3,\"1275\":3}}],[\"ntulp\",{\"1\":{\"663\":1}}],[\"ntlp\",{\"1\":{\"663\":1}}],[\"nid=0x6c0\",{\"1\":{\"1259\":1}}],[\"nid=0x2b48\",{\"1\":{\"1259\":1}}],[\"nickname\",{\"1\":{\"566\":1,\"589\":1,\"592\":1}}],[\"nim博弈属于公平组合游戏\",{\"1\":{\"395\":1}}],[\"nim博弈先手必胜\",{\"1\":{\"394\":1}}],[\"nim博弈不存在平局\",{\"1\":{\"394\":1}}],[\"nim游戏\",{\"0\":{\"394\":1}}],[\"npx\",{\"1\":{\"538\":3}}],[\"npmmirror\",{\"1\":{\"538\":1}}],[\"npm\",{\"1\":{\"537\":1,\"538\":5,\"539\":2,\"540\":4,\"559\":1}}],[\"npos是这样定义的\",{\"1\":{\"252\":1}}],[\"npos是一个静态成员常量\",{\"1\":{\"252\":1}}],[\"npos\",{\"0\":{\"252\":1},\"1\":{\"252\":2}}],[\"nvm\",{\"1\":{\"537\":2}}],[\"nanotime\",{\"1\":{\"1508\":5}}],[\"nanoseconds\",{\"1\":{\"1326\":1,\"1366\":4}}],[\"nanostimeout\",{\"1\":{\"1248\":1,\"1410\":1,\"1500\":2,\"1508\":10}}],[\"nanos\",{\"1\":{\"1248\":1,\"1259\":3,\"1337\":1}}],[\"native\",{\"1\":{\"1259\":2,\"1338\":1,\"1339\":1}}],[\"nas\",{\"1\":{\"1095\":1}}],[\"naccl\",{\"1\":{\"634\":1}}],[\"nacos\",{\"1\":{\"500\":1}}],[\"name3=yxc\",{\"1\":{\"1112\":1}}],[\"name2=\",{\"1\":{\"1112\":1}}],[\"name1=\",{\"1\":{\"1112\":1}}],[\"name>\",{\"1\":{\"1090\":1}}],[\"name=abc\",{\"1\":{\"1114\":1}}],[\"name=yxc\",{\"1\":{\"1113\":1,\"1114\":1,\"1115\":1,\"1116\":2,\"1117\":1}}],[\"name=\",{\"1\":{\"587\":3,\"588\":1,\"926\":1,\"1117\":2}}],[\"name\",{\"1\":{\"181\":17,\"471\":4,\"592\":3,\"672\":1,\"926\":1,\"986\":10,\"1005\":1,\"1033\":4,\"1034\":4,\"1055\":5,\"1102\":1,\"1113\":2,\"1114\":2,\"1115\":1,\"1116\":3,\"1117\":2,\"1157\":1,\"1177\":1,\"1178\":1,\"1201\":3,\"1204\":3}}],[\"namespace\",{\"1\":{\"65\":1,\"66\":1,\"76\":1,\"77\":1,\"110\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"172\":1,\"173\":1,\"174\":1,\"194\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"311\":1,\"312\":1,\"314\":1,\"324\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"339\":2,\"352\":1,\"360\":1,\"361\":1,\"376\":1,\"384\":1,\"392\":1,\"394\":1,\"411\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1,\"589\":1,\"1150\":1}}],[\"n个闭区间\",{\"1\":{\"427\":1,\"429\":1}}],[\"n个格子\",{\"1\":{\"147\":1}}],[\"n1表示第一个集合中的点数\",{\"1\":{\"363\":1}}],[\"n1\",{\"1\":{\"363\":2}}],[\"n是点数\",{\"1\":{\"361\":1}}],[\"n次迭代\",{\"1\":{\"360\":1}}],[\"n^3\",{\"1\":{\"358\":1,\"385\":1}}],[\"n表示点数\",{\"1\":{\"354\":1,\"360\":1,\"362\":1}}],[\"n2表示第二个集合中的点数\",{\"1\":{\"363\":1}}],[\"n2\",{\"1\":{\"351\":1,\"352\":1,\"360\":1,\"363\":1,\"851\":1}}],[\"n代表点数\",{\"1\":{\"345\":1}}],[\"n<=0\",{\"1\":{\"309\":1}}],[\"n共有多少种不同的划分方法\",{\"1\":{\"308\":1}}],[\"n=10\",{\"1\":{\"613\":1,\"1316\":1}}],[\"n=1000\",{\"1\":{\"613\":1}}],[\"n=13\",{\"1\":{\"99\":1}}],[\"n=p1a1​​p2a2​​\",{\"1\":{\"379\":1}}],[\"n=a+cb​\",{\"1\":{\"291\":2}}],[\"n−41​n=43​n\",{\"1\":{\"1271\":1}}],[\"n−2\",{\"1\":{\"988\":1,\"990\":1}}],[\"n−m\",{\"1\":{\"289\":1}}],[\"n−1\",{\"1\":{\"108\":1,\"114\":1,\"119\":1,\"128\":1,\"312\":3,\"988\":1,\"990\":1,\"1232\":1,\"1266\":1}}],[\"n>0\",{\"1\":{\"289\":1}}],[\"n×n\",{\"1\":{\"280\":2}}],[\"n×m\",{\"1\":{\"77\":2,\"196\":1,\"278\":1,\"311\":1}}],[\"nm\",{\"1\":{\"157\":3,\"351\":2,\"354\":1,\"355\":1,\"356\":1,\"363\":1}}],[\"n都为正整数\",{\"1\":{\"142\":1}}],[\"n∗m\",{\"1\":{\"141\":1}}],[\"n+m\",{\"1\":{\"349\":1}}],[\"n+\",{\"1\":{\"289\":1}}],[\"n++\",{\"1\":{\"121\":1}}],[\"n+1\",{\"1\":{\"110\":1,\"127\":1,\"129\":1,\"384\":1,\"797\":1,\"1361\":1}}],[\"normally\",{\"1\":{\"1506\":1}}],[\"normal\",{\"1\":{\"1375\":1}}],[\"noreferrer\",{\"1\":{\"588\":1,\"592\":1}}],[\"now\",{\"1\":{\"1243\":1}}],[\"non\",{\"1\":{\"1242\":1,\"1275\":1,\"1293\":1,\"1506\":1}}],[\"nonzero\",{\"1\":{\"1239\":3}}],[\"nonfairsync\",{\"1\":{\"1233\":2,\"1495\":3}}],[\"nonfairtryacquire\",{\"1\":{\"1232\":2,\"1233\":2,\"1495\":1}}],[\"none\",{\"1\":{\"422\":1,\"1359\":1}}],[\"nohup\",{\"1\":{\"1087\":1}}],[\"nohub\",{\"1\":{\"1087\":1}}],[\"noargsconstructor\",{\"1\":{\"935\":1}}],[\"noetl\",{\"1\":{\"647\":1}}],[\"noexcept\",{\"1\":{\"243\":2}}],[\"noopener\",{\"1\":{\"592\":1}}],[\"nosuchelementexception\",{\"1\":{\"1325\":2}}],[\"nosuchmethodexception\",{\"1\":{\"1045\":1,\"1055\":1}}],[\"nosuchfieldexception\",{\"1\":{\"1045\":1,\"1048\":4,\"1055\":1}}],[\"nostyle\",{\"1\":{\"588\":1}}],[\"nosql\",{\"1\":{\"438\":1}}],[\"node3\",{\"1\":{\"1284\":4}}],[\"node2\",{\"1\":{\"1283\":2,\"1284\":5}}],[\"node1\",{\"1\":{\"1283\":6,\"1284\":10,\"1285\":2}}],[\"node0\",{\"1\":{\"1281\":1,\"1283\":4,\"1285\":3}}],[\"node<e>\",{\"1\":{\"1281\":5,\"1282\":3,\"1283\":7,\"1284\":3,\"1350\":4,\"1351\":2}}],[\"node<\",{\"1\":{\"1271\":1,\"1274\":2}}],[\"node<k\",{\"1\":{\"1266\":2,\"1267\":7,\"1268\":8,\"1271\":4,\"1272\":11,\"1273\":2,\"1274\":14,\"1275\":1}}],[\"node>\",{\"1\":{\"887\":1}}],[\"nodejs\",{\"1\":{\"559\":1}}],[\"nodeb\",{\"1\":{\"103\":11}}],[\"nodea\",{\"1\":{\"103\":15}}],[\"nodes\",{\"1\":{\"103\":4,\"203\":7,\"1267\":1,\"1272\":1,\"1283\":2,\"1284\":1,\"1286\":1}}],[\"node\",{\"0\":{\"1281\":1,\"1282\":1},\"1\":{\"103\":18,\"133\":6,\"157\":30,\"203\":11,\"206\":24,\"218\":3,\"219\":3,\"220\":3,\"345\":4,\"423\":3,\"427\":2,\"428\":2,\"502\":1,\"537\":4,\"586\":1,\"737\":6,\"743\":6,\"749\":5,\"766\":2,\"767\":4,\"789\":4,\"802\":8,\"803\":14,\"881\":5,\"886\":1,\"887\":4,\"888\":10,\"899\":9,\"901\":5,\"1250\":8,\"1251\":34,\"1252\":13,\"1266\":1,\"1267\":3,\"1268\":1,\"1271\":1,\"1272\":3,\"1274\":1,\"1276\":4,\"1281\":2,\"1282\":1,\"1283\":6,\"1350\":5,\"1351\":2,\"1495\":1,\"1501\":5,\"1503\":1,\"1504\":31,\"1505\":15,\"1506\":11,\"1507\":8,\"1508\":8,\"1510\":8,\"1511\":5}}],[\"no\",{\"1\":{\"97\":2,\"235\":2,\"273\":3,\"394\":1,\"591\":2,\"984\":2,\"985\":1,\"992\":1,\"1243\":1,\"1272\":1,\"1350\":1,\"1457\":1}}],[\"notfull\",{\"1\":{\"1346\":4,\"1347\":2,\"1348\":2,\"1350\":2,\"1351\":2}}],[\"notift\",{\"1\":{\"1338\":1}}],[\"notifythread\",{\"1\":{\"1406\":15}}],[\"notifyall方法\",{\"1\":{\"1410\":1}}],[\"notifyall\",{\"0\":{\"1409\":1},\"1\":{\"1063\":1,\"1248\":4,\"1334\":1,\"1337\":1,\"1338\":1,\"1404\":4,\"1406\":1,\"1407\":3,\"1408\":2,\"1409\":3,\"1410\":1}}],[\"notify\",{\"0\":{\"1063\":1,\"1403\":1,\"1405\":1,\"1406\":1},\"1\":{\"1248\":4,\"1334\":1,\"1402\":1,\"1404\":6,\"1406\":9,\"1408\":4,\"1410\":3}}],[\"notempty\",{\"1\":{\"1346\":4,\"1347\":2,\"1348\":1,\"1350\":2,\"1352\":2}}],[\"note\",{\"0\":{\"1519\":1,\"1544\":1},\"1\":{\"1239\":1,\"1242\":1,\"1315\":1,\"1351\":2}}],[\"not\",{\"1\":{\"41\":2,\"406\":1,\"409\":1,\"510\":8,\"511\":6,\"512\":6,\"513\":6,\"523\":1,\"526\":2,\"566\":4,\"575\":1,\"913\":3,\"919\":1,\"931\":1,\"949\":1,\"950\":1,\"986\":1,\"1171\":1,\"1191\":4,\"1242\":3,\"1306\":1,\"1314\":1,\"1315\":1,\"1317\":1,\"1351\":1,\"1511\":1,\"1515\":1}}],[\"nu\",{\"1\":{\"875\":1}}],[\"numcourses\",{\"1\":{\"874\":2}}],[\"numislands\",{\"1\":{\"820\":1,\"821\":1,\"822\":1}}],[\"numberformatexception\",{\"1\":{\"1045\":1}}],[\"number\",{\"1\":{\"549\":1,\"589\":4,\"592\":2,\"1275\":2,\"1315\":1,\"1346\":1,\"1350\":1}}],[\"numberofways\",{\"1\":{\"72\":1}}],[\"numguests\",{\"1\":{\"162\":4}}],[\"num=−num\",{\"1\":{\"104\":1}}],[\"num\",{\"1\":{\"83\":6,\"180\":3,\"251\":8,\"431\":5,\"772\":2,\"922\":2,\"1194\":1}}],[\"numsquares\",{\"1\":{\"115\":1,\"795\":1,\"796\":1,\"797\":1}}],[\"nums\",{\"1\":{\"83\":10,\"121\":6,\"126\":7,\"146\":3,\"167\":2,\"206\":6,\"309\":5,\"431\":7,\"704\":1,\"705\":11,\"771\":1,\"772\":8,\"813\":1,\"815\":7,\"827\":8,\"828\":6,\"850\":1,\"851\":14,\"852\":18,\"856\":1,\"857\":4}}],[\"null操作\",{\"1\":{\"1318\":1}}],[\"nullpointerexception\",{\"1\":{\"1044\":1,\"1045\":1,\"1272\":1,\"1351\":1,\"1359\":1,\"1368\":1,\"1370\":1}}],[\"nullptr\",{\"1\":{\"134\":1}}],[\"null\",{\"1\":{\"82\":1,\"103\":3,\"129\":3,\"187\":4,\"420\":1,\"510\":12,\"511\":8,\"512\":9,\"513\":5,\"523\":2,\"525\":2,\"526\":9,\"566\":14,\"575\":8,\"576\":6,\"578\":1,\"589\":2,\"596\":1,\"682\":4,\"694\":2,\"700\":4,\"710\":1,\"713\":1,\"723\":1,\"724\":5,\"725\":4,\"736\":1,\"737\":3,\"743\":3,\"748\":1,\"749\":3,\"755\":3,\"761\":1,\"767\":4,\"777\":1,\"778\":1,\"789\":3,\"803\":5,\"809\":2,\"815\":1,\"833\":2,\"834\":8,\"846\":1,\"864\":2,\"882\":1,\"886\":1,\"887\":5,\"888\":4,\"899\":1,\"900\":1,\"901\":1,\"919\":1,\"927\":1,\"931\":1,\"932\":1,\"1045\":1,\"1049\":1,\"1145\":3,\"1201\":3,\"1210\":1,\"1211\":1,\"1232\":1,\"1240\":1,\"1242\":1,\"1243\":2,\"1251\":4,\"1252\":8,\"1266\":3,\"1267\":4,\"1271\":2,\"1272\":23,\"1273\":9,\"1274\":16,\"1275\":9,\"1281\":4,\"1283\":12,\"1284\":24,\"1285\":2,\"1286\":4,\"1301\":5,\"1302\":9,\"1303\":1,\"1305\":5,\"1306\":9,\"1307\":4,\"1308\":4,\"1309\":2,\"1313\":4,\"1314\":5,\"1315\":3,\"1316\":31,\"1317\":23,\"1318\":1,\"1319\":10,\"1325\":1,\"1326\":2,\"1347\":1,\"1348\":3,\"1350\":3,\"1351\":1,\"1359\":2,\"1368\":3,\"1370\":6,\"1476\":1,\"1478\":1,\"1485\":3,\"1496\":1,\"1504\":7,\"1505\":5,\"1506\":7,\"1507\":1,\"1508\":1,\"1510\":1,\"1511\":1}}],[\"necessary\",{\"1\":{\"1305\":1,\"1359\":1}}],[\"negative\",{\"1\":{\"1275\":1,\"1351\":1,\"1506\":1}}],[\"negativearraysizeexception\",{\"1\":{\"1045\":1}}],[\"nebula\",{\"1\":{\"1170\":2}}],[\"needs\",{\"1\":{\"1511\":1}}],[\"needing\",{\"1\":{\"1506\":1}}],[\"needed\",{\"1\":{\"1267\":1}}],[\"needwait\",{\"1\":{\"1063\":5}}],[\"need\",{\"1\":{\"591\":2,\"1283\":1,\"1317\":1,\"1359\":1,\"1505\":2,\"1511\":1}}],[\"needqueryquestionlist\",{\"1\":{\"523\":4}}],[\"network\",{\"1\":{\"1191\":2}}],[\"netflixoss\",{\"1\":{\"1170\":2}}],[\"netflix\",{\"1\":{\"1145\":1}}],[\"netstat\",{\"1\":{\"663\":2}}],[\"net\",{\"1\":{\"576\":1,\"1140\":1,\"1171\":1}}],[\"ne\",{\"1\":{\"221\":1,\"223\":4,\"345\":2,\"347\":1,\"348\":1,\"349\":1,\"353\":3,\"355\":3,\"356\":2,\"362\":2,\"363\":2,\"403\":10,\"411\":5,\"419\":3}}],[\"nexthashcode\",{\"1\":{\"1306\":5}}],[\"nextoffset\",{\"1\":{\"1282\":2}}],[\"next域为\",{\"1\":{\"1281\":1}}],[\"nextbound\",{\"1\":{\"1274\":3}}],[\"nextindex\",{\"1\":{\"1274\":6,\"1306\":3,\"1307\":2,\"1308\":1,\"1314\":1,\"1315\":2,\"1316\":6,\"1317\":4}}],[\"nextint\",{\"1\":{\"87\":2,\"88\":1,\"97\":6,\"99\":1,\"103\":5,\"104\":2,\"126\":3,\"129\":1,\"161\":1,\"162\":5,\"178\":2,\"179\":2,\"180\":3,\"981\":1,\"984\":13,\"985\":4,\"986\":1,\"988\":1,\"990\":1,\"992\":1,\"999\":5,\"1021\":2,\"1023\":1,\"1047\":2,\"1048\":1,\"1409\":1,\"1410\":1,\"1411\":1}}],[\"nextn\",{\"1\":{\"1274\":2}}],[\"nexttab\",{\"1\":{\"1274\":12}}],[\"nexttable\",{\"1\":{\"1266\":2,\"1267\":3,\"1274\":7,\"1275\":1}}],[\"nextwaiter\",{\"1\":{\"1250\":1,\"1251\":2,\"1252\":4,\"1501\":1}}],[\"nextc\",{\"1\":{\"1232\":3,\"1233\":3,\"1240\":4,\"1243\":3}}],[\"nextdouble\",{\"1\":{\"981\":1}}],[\"nextfloat\",{\"1\":{\"981\":1}}],[\"nextjs\",{\"1\":{\"537\":1,\"538\":1,\"540\":2,\"542\":1,\"543\":2}}],[\"nextlong\",{\"1\":{\"99\":1}}],[\"nextline\",{\"1\":{\"82\":1,\"83\":1,\"88\":2,\"98\":1,\"127\":2,\"129\":2,\"180\":2,\"981\":1,\"1005\":1,\"1006\":1}}],[\"next\",{\"0\":{\"536\":1,\"541\":1},\"1\":{\"98\":4,\"103\":16,\"134\":1,\"411\":4,\"493\":1,\"499\":1,\"537\":3,\"538\":6,\"539\":3,\"540\":3,\"541\":1,\"542\":3,\"543\":3,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"682\":4,\"687\":1,\"694\":6,\"700\":5,\"777\":2,\"778\":8,\"789\":7,\"833\":3,\"834\":15,\"886\":1,\"887\":6,\"888\":24,\"981\":1,\"1006\":1,\"1252\":2,\"1267\":3,\"1272\":4,\"1273\":1,\"1274\":6,\"1281\":2,\"1283\":12,\"1284\":10,\"1285\":1,\"1306\":1,\"1316\":2,\"1346\":2,\"1350\":3,\"1501\":1,\"1504\":3,\"1505\":3,\"1506\":2,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"newupdater\",{\"1\":{\"1388\":2}}],[\"newtab\",{\"1\":{\"1306\":4}}],[\"newlen\",{\"1\":{\"1306\":5}}],[\"newly\",{\"1\":{\"1196\":1,\"1317\":1}}],[\"newelements\",{\"1\":{\"1294\":3,\"1295\":3}}],[\"newnode\",{\"1\":{\"1283\":5}}],[\"newcondition\",{\"1\":{\"1250\":2,\"1254\":1,\"1346\":2,\"1350\":2,\"1410\":2,\"1493\":1,\"1496\":3}}],[\"newcachemanagerbuilder\",{\"1\":{\"1211\":1}}],[\"newcacheconfigurationbuilder\",{\"1\":{\"1211\":1}}],[\"newchar\",{\"1\":{\"1005\":1,\"1069\":1}}],[\"newbuilder\",{\"1\":{\"1154\":1,\"1204\":1,\"1207\":1}}],[\"newvalue\",{\"1\":{\"1074\":1,\"1081\":1,\"1210\":1,\"1385\":1}}],[\"newinstance\",{\"1\":{\"1045\":1,\"1055\":2}}],[\"newsinglethreadexecutor\",{\"1\":{\"1330\":1}}],[\"newsinglethreadscheduledexecutor\",{\"1\":{\"1201\":1}}],[\"newscheduledthreadpool\",{\"1\":{\"1158\":1}}],[\"newscore\",{\"1\":{\"129\":3}}],[\"newstring\",{\"1\":{\"1014\":2}}],[\"newarray\",{\"1\":{\"1014\":2}}],[\"newregex\",{\"1\":{\"1005\":1}}],[\"newfixedthreadpool\",{\"1\":{\"1309\":1,\"1313\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":1,\"1409\":1,\"1410\":1,\"1411\":1}}],[\"newf\",{\"1\":{\"828\":2}}],[\"newhead\",{\"1\":{\"682\":2}}],[\"newhealth\",{\"1\":{\"180\":5}}],[\"newquestionbankquestionid\",{\"1\":{\"526\":2}}],[\"newjob\",{\"1\":{\"482\":3}}],[\"new\",{\"1\":{\"70\":2,\"72\":1,\"82\":2,\"83\":3,\"87\":1,\"88\":2,\"97\":1,\"98\":2,\"99\":1,\"103\":5,\"104\":3,\"115\":1,\"126\":3,\"127\":2,\"128\":6,\"129\":6,\"157\":8,\"161\":2,\"162\":4,\"178\":4,\"179\":3,\"180\":6,\"182\":1,\"446\":1,\"481\":2,\"523\":1,\"525\":1,\"526\":1,\"549\":1,\"567\":1,\"568\":2,\"575\":2,\"578\":2,\"587\":1,\"589\":1,\"592\":1,\"687\":1,\"700\":2,\"736\":1,\"737\":3,\"743\":3,\"749\":2,\"767\":6,\"772\":1,\"778\":1,\"783\":1,\"784\":1,\"789\":2,\"795\":1,\"796\":1,\"797\":1,\"803\":2,\"815\":1,\"821\":3,\"822\":1,\"827\":1,\"828\":1,\"834\":1,\"840\":1,\"845\":2,\"846\":1,\"851\":1,\"852\":1,\"870\":7,\"875\":2,\"876\":4,\"882\":1,\"887\":2,\"888\":2,\"893\":1,\"894\":2,\"901\":3,\"981\":3,\"982\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":1,\"990\":1,\"992\":1,\"997\":4,\"998\":1,\"999\":6,\"1000\":2,\"1006\":1,\"1007\":1,\"1018\":1,\"1021\":1,\"1023\":1,\"1029\":2,\"1034\":2,\"1038\":1,\"1047\":2,\"1048\":3,\"1049\":4,\"1055\":3,\"1059\":9,\"1061\":3,\"1062\":6,\"1063\":4,\"1069\":4,\"1070\":1,\"1072\":4,\"1073\":3,\"1074\":4,\"1075\":2,\"1076\":1,\"1077\":1,\"1078\":4,\"1103\":4,\"1129\":1,\"1131\":1,\"1147\":1,\"1148\":1,\"1153\":2,\"1157\":2,\"1158\":8,\"1160\":3,\"1163\":1,\"1164\":1,\"1175\":3,\"1178\":1,\"1179\":1,\"1180\":1,\"1182\":1,\"1201\":2,\"1210\":1,\"1211\":1,\"1221\":4,\"1232\":2,\"1233\":4,\"1239\":1,\"1240\":1,\"1248\":1,\"1250\":2,\"1251\":3,\"1252\":1,\"1254\":5,\"1260\":1,\"1266\":1,\"1270\":2,\"1271\":2,\"1272\":4,\"1274\":8,\"1281\":1,\"1283\":3,\"1284\":2,\"1301\":2,\"1306\":5,\"1309\":3,\"1314\":2,\"1317\":2,\"1326\":1,\"1329\":1,\"1330\":4,\"1336\":2,\"1337\":1,\"1340\":2,\"1346\":3,\"1350\":3,\"1351\":2,\"1359\":4,\"1366\":4,\"1368\":2,\"1369\":2,\"1370\":2,\"1375\":1,\"1385\":1,\"1386\":3,\"1387\":3,\"1388\":1,\"1392\":2,\"1393\":1,\"1398\":1,\"1399\":1,\"1406\":4,\"1407\":8,\"1409\":4,\"1410\":5,\"1411\":4,\"1429\":2,\"1430\":1,\"1449\":2,\"1454\":1,\"1458\":2,\"1467\":1,\"1475\":1,\"1476\":2,\"1478\":1,\"1482\":2,\"1485\":2,\"1492\":1,\"1495\":1,\"1496\":5,\"1504\":3,\"1507\":2,\"1508\":2,\"1511\":1}}],[\"n\",{\"1\":{\"49\":1,\"65\":12,\"66\":14,\"76\":3,\"77\":5,\"78\":3,\"82\":4,\"83\":3,\"87\":11,\"99\":12,\"103\":9,\"104\":13,\"108\":7,\"109\":3,\"110\":12,\"114\":1,\"115\":11,\"119\":12,\"120\":7,\"121\":9,\"122\":9,\"126\":12,\"127\":9,\"128\":13,\"129\":5,\"134\":2,\"135\":8,\"140\":9,\"141\":10,\"142\":10,\"146\":11,\"147\":8,\"152\":2,\"157\":12,\"161\":3,\"162\":7,\"166\":3,\"168\":5,\"172\":3,\"173\":10,\"174\":19,\"178\":6,\"179\":7,\"180\":11,\"182\":9,\"193\":4,\"194\":10,\"196\":3,\"197\":12,\"199\":4,\"200\":6,\"202\":4,\"203\":6,\"205\":6,\"206\":11,\"215\":13,\"216\":12,\"223\":12,\"228\":8,\"229\":10,\"230\":8,\"235\":12,\"236\":9,\"237\":11,\"242\":3,\"244\":1,\"245\":1,\"246\":1,\"254\":7,\"255\":1,\"261\":9,\"262\":16,\"263\":9,\"269\":6,\"273\":10,\"274\":16,\"278\":14,\"280\":5,\"281\":10,\"287\":8,\"288\":10,\"289\":8,\"290\":13,\"291\":8,\"296\":11,\"297\":11,\"298\":26,\"299\":19,\"301\":14,\"302\":21,\"303\":10,\"304\":16,\"305\":13,\"306\":10,\"307\":13,\"308\":16,\"309\":6,\"311\":11,\"312\":13,\"314\":6,\"324\":9,\"327\":1,\"339\":14,\"340\":1,\"341\":1,\"345\":13,\"346\":2,\"349\":3,\"351\":2,\"352\":13,\"353\":10,\"354\":13,\"355\":7,\"356\":11,\"358\":5,\"359\":2,\"360\":14,\"361\":14,\"362\":6,\"363\":4,\"367\":1,\"368\":10,\"369\":15,\"371\":16,\"372\":2,\"373\":5,\"376\":5,\"379\":3,\"380\":8,\"384\":8,\"385\":21,\"387\":1,\"388\":3,\"389\":8,\"390\":14,\"391\":3,\"392\":11,\"394\":3,\"403\":3,\"404\":3,\"406\":1,\"407\":1,\"409\":1,\"410\":1,\"411\":5,\"412\":2,\"414\":4,\"415\":3,\"416\":3,\"417\":6,\"419\":9,\"420\":5,\"421\":3,\"423\":8,\"427\":7,\"428\":7,\"429\":7,\"430\":9,\"431\":4,\"613\":2,\"724\":2,\"737\":4,\"743\":3,\"772\":3,\"776\":1,\"777\":12,\"778\":4,\"783\":8,\"784\":4,\"794\":2,\"795\":5,\"796\":9,\"797\":6,\"803\":4,\"820\":4,\"821\":4,\"822\":6,\"828\":6,\"840\":6,\"845\":4,\"846\":4,\"850\":1,\"851\":4,\"852\":2,\"857\":2,\"868\":1,\"870\":7,\"875\":3,\"876\":6,\"886\":4,\"893\":7,\"894\":3,\"958\":2,\"978\":1,\"982\":4,\"984\":14,\"988\":4,\"990\":4,\"992\":3,\"999\":21,\"1006\":1,\"1011\":1,\"1020\":1,\"1023\":6,\"1049\":1,\"1067\":1,\"1069\":12,\"1070\":2,\"1072\":3,\"1080\":1,\"1095\":2,\"1232\":4,\"1266\":4,\"1270\":14,\"1271\":7,\"1272\":7,\"1273\":3,\"1274\":24,\"1275\":10,\"1315\":27,\"1316\":7,\"1361\":2,\"1383\":4,\"1392\":9,\"1437\":4}}],[\"girl\",{\"1\":{\"1399\":2}}],[\"given\",{\"1\":{\"1270\":1,\"1359\":1}}],[\"gitee\",{\"1\":{\"1086\":1}}],[\"gitee镜像\",{\"1\":{\"1086\":1}}],[\"github\",{\"1\":{\"537\":1,\"539\":2,\"549\":1,\"560\":1,\"634\":1,\"658\":1,\"665\":4,\"670\":1,\"766\":1,\"1086\":2,\"1090\":1,\"1095\":3,\"1206\":1}}],[\"git\",{\"0\":{\"15\":1},\"1\":{\"7\":1}}],[\"gbk\",{\"1\":{\"1069\":2}}],[\"gzip\",{\"1\":{\"1184\":1}}],[\"gz\",{\"1\":{\"670\":3}}],[\"gfw\",{\"1\":{\"664\":5}}],[\"guards\",{\"1\":{\"1351\":1}}],[\"guard\",{\"1\":{\"1351\":1}}],[\"guarding\",{\"1\":{\"1346\":1}}],[\"guava<\",{\"1\":{\"1203\":1}}],[\"guava\",{\"0\":{\"1202\":1},\"1\":{\"1202\":1,\"1203\":1,\"1205\":1}}],[\"gugva\",{\"0\":{\"1203\":1}}],[\"guides\",{\"1\":{\"575\":1}}],[\"guests\",{\"1\":{\"162\":6}}],[\"global\",{\"1\":{\"549\":2,\"575\":1,\"958\":1}}],[\"globalfooter\",{\"1\":{\"549\":2}}],[\"globals\",{\"1\":{\"540\":1}}],[\"gender\",{\"1\":{\"566\":2,\"589\":1,\"592\":1}}],[\"generate\",{\"1\":{\"576\":2}}],[\"generateroutes\",{\"1\":{\"459\":1}}],[\"generation\",{\"1\":{\"534\":1}}],[\"generator\",{\"1\":{\"516\":1}}],[\"getdelay\",{\"1\":{\"1326\":1}}],[\"getdatatable\",{\"1\":{\"465\":1}}],[\"getholdcount\",{\"1\":{\"1347\":1,\"1348\":1}}],[\"gethostname\",{\"1\":{\"1177\":1}}],[\"getheartbeatexecutorthreadpoolsize\",{\"1\":{\"1158\":1}}],[\"getwaittimeinmswhensyncempty\",{\"1\":{\"1150\":1}}],[\"gettask\",{\"1\":{\"1370\":1}}],[\"getthreadid\",{\"1\":{\"1242\":1,\"1243\":1}}],[\"getter\",{\"1\":{\"1133\":1,\"1472\":1}}],[\"getting\",{\"1\":{\"537\":1,\"538\":1,\"539\":1}}],[\"getobjectvolatile\",{\"1\":{\"1268\":1}}],[\"getobjectargs\",{\"1\":{\"1103\":1}}],[\"getobjectresponse\",{\"1\":{\"1103\":3}}],[\"getobject\",{\"1\":{\"1102\":1,\"1103\":2}}],[\"getordefault\",{\"1\":{\"179\":1,\"688\":2,\"882\":1,\"1074\":2}}],[\"getentryaftermiss\",{\"1\":{\"1307\":4,\"1317\":2}}],[\"getentry\",{\"0\":{\"1307\":1},\"1\":{\"1302\":1,\"1304\":1,\"1307\":3,\"1317\":1,\"1318\":1}}],[\"getendpoint\",{\"1\":{\"1100\":1}}],[\"getexclusiveownerthread\",{\"1\":{\"1232\":2,\"1233\":1,\"1239\":1,\"1242\":1}}],[\"getexpirypolicy\",{\"1\":{\"1211\":1}}],[\"getexpiryforupdate\",{\"1\":{\"1210\":1}}],[\"getexpiryforaccess\",{\"1\":{\"1210\":1}}],[\"getexpiryforcreation\",{\"1\":{\"1210\":1}}],[\"getexpirebykey\",{\"1\":{\"1210\":4}}],[\"getexpiretime\",{\"1\":{\"1201\":2}}],[\"geteurekaclientconfig\",{\"1\":{\"1160\":1,\"1162\":1}}],[\"getemail\",{\"1\":{\"575\":1}}],[\"getnumberwaiting\",{\"1\":{\"1393\":1,\"1394\":1}}],[\"getname\",{\"1\":{\"1059\":1,\"1063\":1,\"1254\":2,\"1260\":1,\"1284\":1,\"1337\":1,\"1392\":3,\"1393\":2,\"1398\":4,\"1406\":12,\"1407\":12,\"1409\":6,\"1410\":6,\"1411\":2}}],[\"getnickname\",{\"1\":{\"575\":1}}],[\"getfield\",{\"1\":{\"1055\":1}}],[\"getfullyear\",{\"1\":{\"549\":1}}],[\"gety\",{\"1\":{\"1027\":1,\"1028\":1}}],[\"getxx\",{\"1\":{\"1150\":1,\"1153\":1,\"1178\":1}}],[\"getx\",{\"1\":{\"1027\":1,\"1028\":1}}],[\"getandset\",{\"1\":{\"1385\":1,\"1387\":2}}],[\"getanddecrement\",{\"1\":{\"1352\":1}}],[\"getandincrement\",{\"1\":{\"1351\":1,\"1385\":4,\"1386\":1}}],[\"getandaddint\",{\"1\":{\"1385\":2}}],[\"getandadd\",{\"1\":{\"1306\":1,\"1386\":2,\"1388\":2}}],[\"getarray\",{\"1\":{\"1292\":1,\"1293\":2,\"1294\":1,\"1295\":1}}],[\"getawssecretkey\",{\"1\":{\"1147\":1}}],[\"getawsaccessid\",{\"1\":{\"1147\":1}}],[\"getaccesskey\",{\"1\":{\"1100\":1}}],[\"getattribute\",{\"1\":{\"578\":1,\"589\":1}}],[\"getavatar\",{\"1\":{\"575\":1}}],[\"getruntime\",{\"1\":{\"1361\":1}}],[\"getruntimeconfiguration\",{\"1\":{\"1211\":1}}],[\"getremark\",{\"1\":{\"575\":1}}],[\"getrouters\",{\"1\":{\"459\":1,\"461\":1}}],[\"getrolepermission\",{\"1\":{\"456\":1}}],[\"getpeereurekanodes\",{\"1\":{\"1162\":1}}],[\"getprobe\",{\"1\":{\"1275\":1}}],[\"getpropertiesfromfile\",{\"1\":{\"1149\":1}}],[\"getpresignedobjecturlargs\",{\"1\":{\"1103\":1}}],[\"getpresignedobjecturl\",{\"1\":{\"1103\":2}}],[\"getpassword\",{\"1\":{\"576\":2}}],[\"getpagesize\",{\"1\":{\"525\":1}}],[\"getphone\",{\"1\":{\"575\":1}}],[\"getgender\",{\"1\":{\"575\":1}}],[\"gets\",{\"1\":{\"1293\":1}}],[\"getstringproperty\",{\"1\":{\"1149\":1}}],[\"getstring\",{\"1\":{\"1145\":1,\"1149\":1}}],[\"getstate\",{\"1\":{\"1232\":2,\"1233\":1,\"1239\":1,\"1240\":2,\"1242\":1,\"1243\":1,\"1251\":1,\"1329\":1,\"1494\":1,\"1495\":1,\"1496\":3}}],[\"getstatus\",{\"1\":{\"482\":1,\"575\":1}}],[\"getstacktrace\",{\"1\":{\"1046\":1}}],[\"getservercontext\",{\"1\":{\"1164\":2}}],[\"getsecretkey\",{\"1\":{\"1100\":1}}],[\"getsession\",{\"1\":{\"575\":1,\"578\":1,\"589\":1,\"596\":1}}],[\"getspeed\",{\"1\":{\"1031\":1,\"1033\":1,\"1034\":1}}],[\"getsafetyuser\",{\"1\":{\"575\":2,\"578\":1,\"589\":1}}],[\"getbytes\",{\"1\":{\"568\":1,\"575\":1,\"1069\":4}}],[\"getbyid\",{\"1\":{\"523\":1,\"526\":2,\"589\":1}}],[\"getlocalhost\",{\"1\":{\"1177\":1}}],[\"getloginuser\",{\"1\":{\"526\":1}}],[\"getlasttime\",{\"1\":{\"575\":1}}],[\"getline\",{\"1\":{\"172\":1}}],[\"getqueuedthreads\",{\"1\":{\"1398\":1}}],[\"getqueuelength\",{\"1\":{\"1398\":1}}],[\"getqueue\",{\"1\":{\"1370\":1}}],[\"getquestionid\",{\"1\":{\"525\":2,\"526\":3}}],[\"getquestionbankid\",{\"1\":{\"525\":2,\"526\":3}}],[\"getquestionbankvo\",{\"1\":{\"523\":1}}],[\"getquestionbankvobyid\",{\"1\":{\"523\":1}}],[\"getquerywrapper\",{\"1\":{\"525\":1}}],[\"getclass\",{\"1\":{\"1469\":1}}],[\"getcount\",{\"1\":{\"1392\":1}}],[\"getconfiginstance\",{\"1\":{\"1145\":3,\"1149\":2}}],[\"getconstructor\",{\"1\":{\"1055\":1}}],[\"getcache\",{\"1\":{\"1211\":1}}],[\"getcacherefreshexecutorthreadpoolsize\",{\"1\":{\"1158\":1}}],[\"getcause\",{\"1\":{\"1046\":1}}],[\"getcheckpassword\",{\"1\":{\"576\":1}}],[\"getcurrentuser\",{\"1\":{\"589\":1}}],[\"getcurrent\",{\"1\":{\"525\":1}}],[\"getcronexpression\",{\"1\":{\"481\":1}}],[\"getid\",{\"1\":{\"523\":1,\"526\":2}}],[\"getintproperty\",{\"1\":{\"1150\":1}}],[\"getinteger\",{\"1\":{\"1069\":1}}],[\"getinstance\",{\"1\":{\"1149\":1,\"1164\":2,\"1485\":1}}],[\"getinitialstate\",{\"1\":{\"591\":2}}],[\"getinvoketarget\",{\"1\":{\"481\":5}}],[\"getinfo\",{\"1\":{\"453\":2,\"455\":1}}],[\"getjobid\",{\"1\":{\"482\":1}}],[\"getjobname\",{\"1\":{\"481\":6}}],[\"getunsafe\",{\"1\":{\"1266\":1,\"1385\":2}}],[\"getuserrole\",{\"1\":{\"575\":1,\"578\":1}}],[\"getuserid\",{\"1\":{\"567\":1,\"568\":1,\"575\":1,\"589\":1}}],[\"getusername\",{\"1\":{\"481\":1,\"575\":1,\"576\":2}}],[\"geturls\",{\"1\":{\"446\":1}}],[\"getmap\",{\"1\":{\"1301\":3,\"1302\":2,\"1303\":1}}],[\"getmapping\",{\"1\":{\"468\":1,\"523\":1,\"578\":1,\"589\":1}}],[\"getmethod\",{\"1\":{\"1055\":1}}],[\"getmessage\",{\"1\":{\"1046\":1,\"1049\":1}}],[\"getmenupermission\",{\"1\":{\"456\":1}}],[\"getkey\",{\"1\":{\"179\":1,\"821\":1,\"870\":1,\"1040\":1,\"1074\":1,\"1082\":1}}],[\"getvalue\",{\"1\":{\"129\":1,\"179\":1,\"821\":1,\"870\":1,\"1040\":1,\"1074\":1,\"1082\":1,\"1201\":3}}],[\"get\",{\"0\":{\"1273\":1,\"1293\":1,\"1302\":1},\"1\":{\"129\":4,\"245\":1,\"247\":1,\"371\":1,\"372\":1,\"373\":1,\"375\":1,\"380\":1,\"390\":6,\"421\":1,\"446\":1,\"523\":1,\"573\":1,\"589\":3,\"592\":1,\"686\":2,\"687\":5,\"688\":2,\"767\":3,\"784\":1,\"852\":1,\"887\":5,\"1036\":1,\"1040\":1,\"1055\":1,\"1072\":1,\"1074\":3,\"1103\":2,\"1147\":1,\"1149\":3,\"1150\":4,\"1151\":3,\"1153\":1,\"1179\":1,\"1201\":4,\"1204\":2,\"1207\":2,\"1210\":1,\"1211\":2,\"1221\":4,\"1242\":1,\"1243\":1,\"1272\":1,\"1273\":3,\"1276\":1,\"1292\":1,\"1293\":5,\"1302\":4,\"1303\":1,\"1304\":1,\"1306\":3,\"1307\":2,\"1308\":1,\"1309\":3,\"1314\":3,\"1315\":1,\"1316\":1,\"1317\":6,\"1330\":1,\"1351\":1,\"1352\":1,\"1359\":3,\"1367\":1,\"1370\":1,\"1375\":7,\"1376\":1,\"1385\":1,\"1386\":1,\"1387\":1,\"1388\":1}}],[\"g1\",{\"1\":{\"399\":1}}],[\"g被称为有向图游戏g1\",{\"1\":{\"399\":1}}],[\"gm的和\",{\"1\":{\"399\":1}}],[\"gm\",{\"1\":{\"399\":2}}],[\"g2\",{\"1\":{\"399\":3}}],[\"gc\",{\"1\":{\"1275\":1,\"1295\":2,\"1305\":1,\"1306\":1,\"1313\":1,\"1316\":1,\"1318\":1,\"1319\":1,\"1504\":1,\"1505\":2,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"gcd\",{\"1\":{\"248\":1,\"377\":3,\"383\":5}}],[\"gcost\",{\"1\":{\"215\":1}}],[\"governator\",{\"1\":{\"1171\":1}}],[\"google\",{\"1\":{\"1095\":1,\"1203\":1}}],[\"goods\",{\"1\":{\"298\":4}}],[\"good\",{\"1\":{\"298\":5}}],[\"golang\",{\"1\":{\"1095\":1}}],[\"go\",{\"1\":{\"663\":1,\"1095\":2}}],[\"goal\",{\"1\":{\"218\":2,\"219\":2,\"220\":2}}],[\"go并发编程\",{\"1\":{\"60\":1}}],[\"g\",{\"1\":{\"180\":7,\"215\":1,\"216\":2,\"221\":2,\"224\":3,\"242\":1,\"254\":2,\"278\":3,\"309\":7,\"345\":1,\"352\":9,\"360\":7,\"398\":1,\"399\":1,\"559\":1,\"820\":14,\"821\":10,\"822\":7,\"852\":26,\"870\":17,\"875\":4,\"876\":8,\"1408\":1}}],[\"garbage\",{\"1\":{\"1317\":1}}],[\"garden\",{\"1\":{\"141\":3}}],[\"gauss\",{\"1\":{\"385\":1}}],[\"gateway\",{\"1\":{\"46\":1}}],[\"group\",{\"1\":{\"929\":2,\"933\":1,\"934\":1,\"1319\":3}}],[\"groupid>\",{\"1\":{\"568\":1,\"1099\":1,\"1203\":1,\"1206\":1,\"1209\":1}}],[\"grant\",{\"1\":{\"1242\":1}}],[\"graph\",{\"1\":{\"875\":1}}],[\"graalvm\",{\"1\":{\"621\":1}}],[\"greet\",{\"1\":{\"1031\":1,\"1033\":1,\"1034\":2}}],[\"grep\",{\"1\":{\"663\":1,\"672\":1}}],[\"greater<int>\",{\"1\":{\"423\":1}}],[\"greater<int>>\",{\"1\":{\"422\":1,\"429\":1}}],[\"greater<pis>>\",{\"1\":{\"224\":1}}],[\"greater<piii>>\",{\"1\":{\"223\":1}}],[\"greater<pii>>\",{\"1\":{\"223\":1,\"353\":1}}],[\"greater\",{\"1\":{\"290\":1}}],[\"grps\",{\"1\":{\"484\":1}}],[\"grpc\",{\"1\":{\"46\":1,\"51\":2}}],[\"grid\",{\"1\":{\"77\":6,\"180\":1,\"868\":1}}],[\"ghost\",{\"1\":{\"56\":1}}],[\"网上有个流行语\",{\"1\":{\"1416\":1}}],[\"网上有很多\",{\"1\":{\"1306\":1}}],[\"网格\",{\"1\":{\"868\":1}}],[\"网格板的左上角的单元格坐标为\",{\"1\":{\"77\":1}}],[\"网格板是由\",{\"1\":{\"77\":1}}],[\"网盘\",{\"1\":{\"668\":1}}],[\"网速有点慢🤣\",{\"1\":{\"665\":1}}],[\"网站流量控制和熔断\",{\"1\":{\"497\":1,\"508\":1}}],[\"网吧离我距离为\",{\"1\":{\"108\":1}}],[\"网关层\",{\"1\":{\"46\":1}}],[\"网络传输组件都赋值给了\",{\"1\":{\"1182\":1}}],[\"网络板\",{\"0\":{\"77\":1}}],[\"网络吞吐的关系等\",{\"1\":{\"33\":1}}],[\"网络抖动等异常场景下的数据错乱\",{\"1\":{\"31\":1}}],[\"网络和数据库之上\",{\"1\":{\"14\":1}}],[\"作业类名等\",{\"1\":{\"484\":1}}],[\"作用于工作内存的变量\",{\"1\":{\"1482\":1}}],[\"作用于工作内存中的变量\",{\"1\":{\"1482\":3}}],[\"作用于主内存的变量\",{\"1\":{\"1482\":2}}],[\"作用于主内存中的变量\",{\"1\":{\"1482\":2}}],[\"作用与\",{\"1\":{\"993\":1}}],[\"作用域\",{\"1\":{\"663\":1}}],[\"作用\",{\"1\":{\"339\":1,\"417\":1,\"599\":1,\"919\":1}}],[\"作用等同于\",{\"1\":{\"243\":1}}],[\"作为数据容器\",{\"1\":{\"1344\":1}}],[\"作为起点执行cleansomeslots\",{\"1\":{\"1317\":1}}],[\"作为队列要删除真正的队头节点\",{\"1\":{\"1284\":1}}],[\"作为新的\",{\"1\":{\"1274\":1}}],[\"作为缓存数据存储服务\",{\"1\":{\"1201\":1}}],[\"作为可执行文件\",{\"1\":{\"1107\":1}}],[\"作为一个应用程序向\",{\"1\":{\"1153\":1}}],[\"作为一个网盘\",{\"1\":{\"671\":1}}],[\"作为一款基于\",{\"1\":{\"1095\":1}}],[\"作为传入参数\",{\"1\":{\"886\":1}}],[\"作为临时链表头部\",{\"1\":{\"833\":1}}],[\"作为字典\",{\"1\":{\"782\":1}}],[\"作为容量\",{\"1\":{\"686\":1}}],[\"作为切割点\",{\"1\":{\"262\":1}}],[\"作为返回值它通常被用作表明没有匹配\",{\"1\":{\"252\":1}}],[\"作为估计函数f\",{\"1\":{\"223\":1}}],[\"作为最终结果\",{\"1\":{\"127\":1}}],[\"作为标记\",{\"1\":{\"108\":1}}],[\"作为主力存储\",{\"1\":{\"58\":1}}],[\"作为主力缓存\",{\"1\":{\"31\":1}}],[\"作为主键去查询\",{\"1\":{\"56\":1}}],[\"作为主键\",{\"1\":{\"56\":1}}],[\"作为\",{\"1\":{\"51\":1,\"851\":2,\"1250\":1,\"1266\":1}}],[\"作者根据\",{\"1\":{\"1375\":1}}],[\"作者\",{\"1\":{\"549\":1}}],[\"作者置顶\",{\"1\":{\"45\":1}}],[\"作者删除\",{\"1\":{\"45\":1}}],[\"比赛结束\",{\"1\":{\"1392\":2}}],[\"比较交换的过程可以通俗的理解为\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"比较运算符\",{\"1\":{\"931\":2}}],[\"比较当前选的数字和下一个要选的数字\",{\"1\":{\"851\":1}}],[\"比较选与不选方案的最小值\",{\"1\":{\"796\":1,\"797\":1}}],[\"比较左右两半边\",{\"1\":{\"318\":1}}],[\"比较高度\",{\"1\":{\"274\":1}}],[\"比较路径是否最短\",{\"1\":{\"236\":1,\"237\":1}}],[\"比较\",{\"0\":{\"1353\":1,\"1394\":1},\"1\":{\"215\":1}}],[\"比较哪个更接近即可\",{\"1\":{\"174\":1}}],[\"比较两个链表的头节点\",{\"1\":{\"134\":1}}],[\"比方说先审后发或者先发后审\",{\"1\":{\"45\":1}}],[\"比如当前时间是\",{\"1\":{\"1508\":1}}],[\"比如能响应中断以及超时等待等特性\",{\"1\":{\"1507\":1}}],[\"比如能够通过\",{\"1\":{\"1394\":1}}],[\"比如对主内存中的\",{\"1\":{\"1482\":1}}],[\"比如对象\",{\"1\":{\"1132\":1}}],[\"比如获得锁的线程被阻塞住了\",{\"1\":{\"1447\":1}}],[\"比如获取\",{\"1\":{\"1147\":1}}],[\"比如数据依赖性\",{\"1\":{\"1418\":1}}],[\"比如数据库连接\",{\"1\":{\"1398\":1}}],[\"比如数据脏读\",{\"1\":{\"1221\":1}}],[\"比如垃圾回收线程\",{\"1\":{\"1340\":1}}],[\"比如固定大小的线程池\",{\"1\":{\"1305\":1}}],[\"比如说\",{\"1\":{\"1295\":1}}],[\"比如说我们要存储\",{\"1\":{\"613\":1}}],[\"比如系统配置的信息\",{\"1\":{\"1290\":1}}],[\"比如getreadholdcount\",{\"1\":{\"1242\":1}}],[\"比如一个很简单的\",{\"1\":{\"1454\":1}}],[\"比如一个很经典的问题就是\",{\"1\":{\"1425\":1}}],[\"比如一个旧值\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"比如一个线程占有了临界区资源\",{\"1\":{\"1225\":1}}],[\"比如一些需要定时清理数据的任务等\",{\"1\":{\"475\":1}}],[\"比如一些定时需要生成的报表\",{\"1\":{\"475\":1}}],[\"比如如何保证线程安全\",{\"1\":{\"1221\":1}}],[\"比如任务很少\",{\"1\":{\"1220\":1}}],[\"比如悟空我的机器上就是\",{\"1\":{\"1196\":1}}],[\"比如端口号\",{\"1\":{\"1177\":1}}],[\"比如订单服务\",{\"1\":{\"1175\":1}}],[\"比如长得像李嘉欣\",{\"1\":{\"1131\":1}}],[\"比如社交评论\",{\"1\":{\"1093\":1}}],[\"比如根节点左儿子的值大于根节点的值\",{\"1\":{\"899\":1}}],[\"比如根节点就是记录了字符串首个位置\",{\"1\":{\"802\":1}}],[\"比如我想实现一个图床\",{\"1\":{\"668\":1}}],[\"比如我们可以将多个参数整合为一个结构体传递到函数内部\",{\"1\":{\"257\":1}}],[\"比如需要存储\",{\"1\":{\"613\":1}}],[\"比如记录日志\",{\"1\":{\"599\":1}}],[\"比如封号等\",{\"1\":{\"589\":1}}],[\"比如用户信息\",{\"1\":{\"575\":1}}],[\"比如导航栏\",{\"1\":{\"547\":1}}],[\"比如网站的\",{\"1\":{\"543\":1}}],[\"比如同组路由使用同一套布局\",{\"1\":{\"542\":1}}],[\"比如使用\",{\"1\":{\"540\":1}}],[\"比如使用数据库连接池\",{\"1\":{\"493\":1}}],[\"比如个人博客\",{\"1\":{\"534\":1}}],[\"比如题目表的示例代码\",{\"1\":{\"515\":1}}],[\"比如査找某个题库中的所有问题\",{\"1\":{\"513\":1}}],[\"比如上面的\",{\"1\":{\"1423\":1}}],[\"比如上面的是\",{\"1\":{\"1150\":1}}],[\"比如上面计算圆面积的代码\",{\"1\":{\"1418\":1}}],[\"比如上面评论图红框里的就是根评论\",{\"1\":{\"56\":1}}],[\"比如上午\",{\"1\":{\"484\":1}}],[\"比如在上例\",{\"1\":{\"1475\":1}}],[\"比如在下面的示例代码中\",{\"1\":{\"1406\":1}}],[\"比如在该例中会继续输出\",{\"1\":{\"1392\":1}}],[\"比如在\",{\"1\":{\"1313\":1,\"1314\":1,\"1469\":1}}],[\"比如在图像处理领域\",{\"1\":{\"1218\":1}}],[\"比如在保证最终一致性的场景中\",{\"1\":{\"475\":1}}],[\"比如在漫画\",{\"1\":{\"45\":1}}],[\"比如某些视频网站\",{\"1\":{\"475\":1}}],[\"比如围棋\",{\"1\":{\"395\":1}}],[\"比如归并排序中合并两个有序序列的操作\",{\"1\":{\"340\":1}}],[\"比如将数\",{\"1\":{\"338\":2}}],[\"比如取数\",{\"1\":{\"338\":1}}],[\"比如你在位置\",{\"1\":{\"110\":1}}],[\"比如输入为\",{\"1\":{\"83\":1}}],[\"比如\",{\"1\":{\"56\":3,\"82\":2,\"109\":1,\"243\":1,\"261\":1,\"338\":2,\"339\":1,\"407\":1,\"470\":1,\"512\":1,\"517\":2,\"526\":1,\"535\":1,\"541\":1,\"542\":1,\"543\":1,\"613\":1,\"662\":1,\"699\":1,\"852\":1,\"875\":1,\"939\":1,\"1042\":1,\"1131\":1,\"1218\":1,\"1223\":1,\"1248\":1,\"1259\":1,\"1264\":1,\"1270\":1,\"1276\":1,\"1280\":2,\"1309\":1,\"1326\":1,\"1462\":1,\"1482\":1,\"1508\":1}}],[\"比如是不是根评论\",{\"1\":{\"56\":1}}],[\"比如两个服务互相调用\",{\"1\":{\"46\":1}}],[\"比如发布评论用户等级限定\",{\"1\":{\"51\":1}}],[\"比如发布\",{\"1\":{\"46\":1}}],[\"比如访问账号服务进行等级判定\",{\"1\":{\"46\":1}}],[\"比如评论总数等\",{\"1\":{\"56\":1}}],[\"比如评论区所有的评论都没有赞\",{\"1\":{\"40\":1}}],[\"比如评论列表\",{\"1\":{\"28\":1}}],[\"事实上\",{\"1\":{\"383\":1,\"1299\":1,\"1331\":1}}],[\"事情的初衷\",{\"1\":{\"45\":1}}],[\"事务的四大特性简称为\",{\"1\":{\"955\":1}}],[\"事务一旦提交或回滚\",{\"1\":{\"955\":1}}],[\"事务完成时\",{\"1\":{\"955\":1}}],[\"事务是不可分割的最小单元\",{\"1\":{\"955\":1}}],[\"事务是一组操作的集合\",{\"1\":{\"953\":1}}],[\"事务有哪些特性\",{\"1\":{\"955\":1}}],[\"事务中的操作要么全部成功\",{\"1\":{\"955\":1}}],[\"事务中间件\",{\"1\":{\"14\":1}}],[\"事务操作有关的\",{\"1\":{\"954\":1}}],[\"事务作用\",{\"1\":{\"953\":1}}],[\"事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求\",{\"1\":{\"953\":1}}],[\"事务\",{\"0\":{\"952\":1},\"1\":{\"439\":1}}],[\"事务处理\",{\"1\":{\"436\":1}}],[\"事务更新\",{\"1\":{\"56\":1}}],[\"事务加锁\",{\"1\":{\"37\":1}}],[\"搞清楚系统背后的背景\",{\"1\":{\"45\":1}}],[\"8h20min\",{\"1\":{\"1508\":1}}],[\"8h30min\",{\"1\":{\"1508\":1}}],[\"8h10min+10min=8h20min\",{\"1\":{\"1508\":1}}],[\"8h10min\",{\"1\":{\"1508\":1}}],[\"893487914\",{\"1\":{\"1411\":1}}],[\"892558288\",{\"1\":{\"1410\":2}}],[\"8正在消费数据504316513\",{\"1\":{\"1411\":1}}],[\"8的不同实现\",{\"1\":{\"1276\":1}}],[\"8762\",{\"1\":{\"1190\":1}}],[\"8转换\",{\"1\":{\"1069\":1}}],[\"8编码转换\",{\"1\":{\"1069\":2}}],[\"85\",{\"1\":{\"984\":1,\"1191\":1}}],[\"8+6\",{\"1\":{\"958\":1}}],[\"838\",{\"1\":{\"920\":2}}],[\"8388607\",{\"1\":{\"920\":1}}],[\"8388608\",{\"1\":{\"920\":1}}],[\"8bytes\",{\"1\":{\"920\":2}}],[\"86400\",{\"1\":{\"577\":1}}],[\"8101\",{\"1\":{\"520\":1}}],[\"800ms\",{\"1\":{\"1340\":1}}],[\"800\",{\"1\":{\"1340\":1}}],[\"8006\",{\"1\":{\"1193\":1}}],[\"8000\",{\"1\":{\"586\":1,\"587\":1,\"592\":1}}],[\"80px\",{\"1\":{\"592\":2}}],[\"8080\",{\"1\":{\"586\":1,\"1177\":2,\"1184\":1}}],[\"80\",{\"1\":{\"129\":2,\"1069\":1}}],[\"8=4+4\",{\"1\":{\"115\":1}}],[\"8\",{\"0\":{\"249\":1,\"341\":1,\"386\":1,\"387\":1,\"388\":1,\"389\":1,\"390\":1,\"391\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":1,\"632\":1,\"642\":1,\"956\":1,\"957\":1,\"958\":1,\"959\":1,\"1036\":1,\"1037\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1049\":1},\"1\":{\"41\":1,\"70\":2,\"99\":1,\"109\":1,\"139\":2,\"140\":1,\"146\":2,\"196\":2,\"224\":10,\"228\":2,\"273\":2,\"278\":1,\"279\":10,\"289\":1,\"301\":2,\"502\":1,\"568\":3,\"574\":1,\"575\":1,\"587\":2,\"670\":2,\"920\":1,\"958\":1,\"978\":2,\"990\":1,\"1000\":1,\"1001\":1,\"1069\":3,\"1082\":1,\"1158\":1,\"1218\":2,\"1250\":1,\"1264\":2,\"1270\":1,\"1272\":8,\"1275\":1,\"1276\":5,\"1284\":1,\"1337\":1,\"1398\":4,\"1409\":1,\"1410\":1,\"1482\":1,\"1496\":1}}],[\"hc\",{\"1\":{\"1274\":3}}],[\"hn\",{\"1\":{\"1274\":8}}],[\"hn​\",{\"1\":{\"66\":1,\"128\":1}}],[\"h数据库服务器的ip地址\",{\"1\":{\"906\":1}}],[\"hup\",{\"1\":{\"1087\":1}}],[\"hutool\",{\"1\":{\"634\":1}}],[\"hugo\",{\"1\":{\"534\":1}}],[\"hugegraph\",{\"1\":{\"56\":1}}],[\"hk\",{\"1\":{\"613\":1}}],[\"h2\",{\"1\":{\"613\":1}}],[\"h2​\",{\"1\":{\"66\":1,\"128\":1}}],[\"h1\",{\"1\":{\"613\":1}}],[\"h1​\",{\"1\":{\"66\":1,\"128\":1}}],[\"href\",{\"1\":{\"589\":1}}],[\"href=\",{\"1\":{\"549\":1,\"588\":1,\"592\":1}}],[\"hibernate\",{\"1\":{\"1309\":1}}],[\"hitail\",{\"1\":{\"1274\":4}}],[\"hierarchicalbeanfactory\",{\"1\":{\"1137\":1}}],[\"hi\",{\"1\":{\"1033\":1,\"1034\":1,\"1069\":2,\"1274\":4}}],[\"history\",{\"1\":{\"587\":5,\"589\":1,\"591\":2}}],[\"hi​\",{\"1\":{\"66\":1,\"128\":2}}],[\"hydration\",{\"1\":{\"535\":1}}],[\"hdfs\",{\"1\":{\"434\":1,\"1095\":1}}],[\"hp\",{\"1\":{\"417\":6}}],[\"hh++\",{\"1\":{\"349\":1,\"409\":1,\"410\":1}}],[\"hh\",{\"1\":{\"349\":2,\"409\":4,\"410\":4,\"920\":3,\"1117\":4,\"1309\":1}}],[\"hackers\",{\"1\":{\"1270\":1}}],[\"harmlessly\",{\"1\":{\"1252\":1}}],[\"hard\",{\"1\":{\"1151\":1,\"1496\":1}}],[\"have\",{\"1\":{\"1244\":1,\"1283\":1,\"1315\":1,\"1316\":3,\"1359\":1}}],[\"having\",{\"1\":{\"929\":1,\"933\":5,\"1242\":1}}],[\"happens\",{\"0\":{\"1414\":1,\"1419\":1,\"1420\":1,\"1424\":1,\"1432\":1,\"1455\":1},\"1\":{\"1294\":1,\"1295\":1,\"1420\":16,\"1421\":14,\"1422\":1,\"1423\":4,\"1424\":2,\"1429\":1,\"1432\":12,\"1433\":3,\"1455\":9,\"1456\":1}}],[\"happen\",{\"1\":{\"1239\":1,\"1455\":1}}],[\"handoff\",{\"1\":{\"1158\":2}}],[\"handler\",{\"1\":{\"1359\":2,\"1366\":4}}],[\"handlesubmit\",{\"1\":{\"587\":2,\"589\":1}}],[\"handlelogin\",{\"1\":{\"448\":1}}],[\"handle\",{\"1\":{\"446\":2}}],[\"hao\",{\"1\":{\"1095\":1}}],[\"hasdcode\",{\"1\":{\"1440\":1}}],[\"hasqueuedthreads\",{\"1\":{\"1398\":1,\"1496\":2}}],[\"hasqueuedpredecessors\",{\"1\":{\"1233\":2}}],[\"has\",{\"1\":{\"1243\":1,\"1252\":1,\"1505\":1}}],[\"hascycle\",{\"1\":{\"876\":4}}],[\"haspermi逻辑相反\",{\"1\":{\"466\":1}}],[\"haspermi=\",{\"1\":{\"457\":2}}],[\"haspermi\",{\"1\":{\"457\":2,\"465\":3,\"466\":1,\"467\":2,\"481\":1,\"482\":1}}],[\"hasrole逻辑相反\",{\"1\":{\"466\":1}}],[\"hasrole=\",{\"1\":{\"457\":2}}],[\"hasrole\",{\"1\":{\"446\":1,\"457\":2,\"466\":1,\"467\":2}}],[\"hasipaddress\",{\"1\":{\"446\":1}}],[\"hasauthority\",{\"1\":{\"446\":1}}],[\"hasanypermi\",{\"1\":{\"466\":1,\"467\":1}}],[\"hasanyroles\",{\"1\":{\"466\":1,\"467\":1}}],[\"hasanyrole\",{\"1\":{\"446\":1}}],[\"hasanyauthority\",{\"1\":{\"446\":1}}],[\"hashing\",{\"1\":{\"1306\":1}}],[\"hash冲突的时候使用线性探测\",{\"1\":{\"1306\":1}}],[\"hashentry\",{\"1\":{\"1264\":1}}],[\"hashtable\",{\"1\":{\"1264\":1}}],[\"hashcode\",{\"1\":{\"1082\":1,\"1272\":4,\"1273\":1,\"1306\":3,\"1440\":1,\"1469\":2,\"1472\":2}}],[\"hashset\",{\"1\":{\"1073\":2}}],[\"hashset<integer>\",{\"1\":{\"1072\":1}}],[\"hashset<k>\",{\"1\":{\"1039\":1}}],[\"hashset<>\",{\"1\":{\"88\":1,\"129\":2,\"157\":1,\"1073\":2}}],[\"hashmap<k\",{\"1\":{\"1040\":1}}],[\"hashmap<integer\",{\"1\":{\"767\":1}}],[\"hashmap<>\",{\"1\":{\"179\":1,\"767\":3,\"784\":1,\"882\":1,\"887\":1,\"1074\":4}}],[\"hashmap\",{\"1\":{\"61\":2,\"179\":1,\"1074\":2,\"1264\":4,\"1272\":1,\"1274\":1,\"1280\":1,\"1306\":5}}],[\"hash\",{\"1\":{\"49\":1,\"61\":1,\"958\":1,\"971\":1,\"1267\":2,\"1272\":34,\"1273\":4,\"1274\":4,\"1306\":13,\"1307\":1,\"1314\":1,\"1315\":1,\"1316\":1,\"1317\":1}}],[\"hadoop\",{\"1\":{\"434\":1,\"1095\":1}}],[\"hamilton\",{\"1\":{\"312\":1}}],[\"h>\",{\"1\":{\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"309\":1,\"314\":1,\"360\":1,\"361\":1}}],[\"h≤50\",{\"1\":{\"180\":1}}],[\"hj​>hi​\",{\"1\":{\"128\":2}}],[\"hj​∣j>i\",{\"1\":{\"128\":2}}],[\"hops\",{\"0\":{\"1286\":1},\"1\":{\"1283\":1,\"1286\":1}}],[\"hop\",{\"1\":{\"1283\":1,\"1284\":1,\"1286\":1}}],[\"holding\",{\"1\":{\"1267\":1,\"1351\":1}}],[\"holdcounter\",{\"1\":{\"1242\":1,\"1243\":1}}],[\"hold\",{\"1\":{\"1242\":1,\"1244\":1,\"1315\":1}}],[\"holder\",{\"1\":{\"1164\":10}}],[\"hotspot\",{\"1\":{\"1282\":1,\"1441\":1}}],[\"hot100\",{\"0\":{\"1529\":1},\"2\":{\"683\":1,\"689\":1,\"695\":1,\"701\":1,\"706\":1,\"714\":1,\"720\":1,\"726\":1,\"732\":1,\"738\":1,\"744\":1,\"750\":1,\"756\":1,\"762\":1,\"768\":1,\"773\":1,\"779\":1,\"785\":1,\"791\":1,\"798\":1,\"804\":1,\"810\":1,\"816\":1,\"823\":1,\"829\":1,\"835\":1,\"841\":1,\"847\":1,\"853\":1,\"859\":1,\"865\":1,\"871\":1,\"877\":1,\"883\":1,\"889\":1,\"895\":1,\"902\":1}}],[\"hotkey\",{\"1\":{\"493\":1,\"500\":1}}],[\"host\",{\"1\":{\"672\":2}}],[\"hosts\",{\"1\":{\"559\":1}}],[\"home\",{\"1\":{\"520\":1,\"1107\":1}}],[\"house\",{\"1\":{\"108\":9,\"438\":2}}],[\"how\",{\"1\":{\"41\":2}}],[\"hence\",{\"1\":{\"1191\":1}}],[\"heros\",{\"1\":{\"1034\":2}}],[\"hero\",{\"1\":{\"1032\":1,\"1033\":1,\"1034\":5}}],[\"herd\",{\"1\":{\"48\":1}}],[\"helper\",{\"1\":{\"1496\":1}}],[\"help\",{\"1\":{\"1306\":1,\"1504\":1,\"1505\":1,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"helptransfer\",{\"1\":{\"1272\":1}}],[\"held\",{\"1\":{\"1221\":2,\"1242\":1,\"1350\":2,\"1506\":1}}],[\"helmet>\",{\"1\":{\"587\":1}}],[\"helloworld\",{\"1\":{\"98\":2}}],[\"hello\",{\"1\":{\"98\":2,\"243\":2,\"982\":2,\"1005\":4,\"1007\":1,\"1012\":1,\"1014\":1,\"1018\":1,\"1059\":3,\"1069\":5,\"1107\":5,\"1109\":1,\"1117\":5}}],[\"height=\",{\"1\":{\"543\":1,\"592\":1,\"1467\":1}}],[\"height\",{\"1\":{\"540\":1,\"1467\":5}}],[\"heights\",{\"1\":{\"128\":8}}],[\"heuristic\",{\"1\":{\"218\":1,\"219\":1,\"220\":1}}],[\"hexo\",{\"1\":{\"534\":1}}],[\"hex\",{\"1\":{\"181\":2}}],[\"heartbeat\",{\"1\":{\"1182\":1}}],[\"heartbeatthread\",{\"1\":{\"1158\":1}}],[\"heartbeatexecutor\",{\"1\":{\"1158\":2}}],[\"heap\",{\"1\":{\"223\":12,\"224\":6,\"353\":6,\"417\":11,\"429\":7,\"1211\":1}}],[\"health\",{\"1\":{\"180\":3}}],[\"header\",{\"1\":{\"672\":2}}],[\"headertitle=\",{\"1\":{\"592\":1}}],[\"headers\",{\"1\":{\"446\":2}}],[\"head存储链表头\",{\"1\":{\"403\":1}}],[\"headmap\",{\"1\":{\"129\":3}}],[\"head\",{\"1\":{\"103\":4,\"134\":7,\"403\":6,\"680\":1,\"681\":4,\"682\":4,\"694\":7,\"699\":1,\"777\":2,\"778\":2,\"789\":3,\"832\":1,\"833\":1,\"834\":7,\"886\":1,\"887\":6,\"888\":4,\"1281\":4,\"1283\":2,\"1284\":10,\"1285\":8,\"1286\":8,\"1350\":4,\"1504\":3,\"1505\":1,\"1506\":2,\"1507\":1,\"1508\":1,\"1510\":1,\"1511\":4}}],[\"h\",{\"1\":{\"66\":11,\"97\":5,\"180\":8,\"215\":1,\"216\":7,\"223\":8,\"251\":1,\"345\":10,\"347\":1,\"348\":1,\"349\":1,\"353\":4,\"355\":4,\"356\":2,\"362\":2,\"363\":2,\"417\":11,\"419\":4,\"420\":3,\"421\":6,\"906\":1,\"1272\":3,\"1273\":5,\"1274\":3,\"1284\":23,\"1306\":5,\"1316\":6,\"1506\":4,\"1511\":8}}],[\"hl​<hl+1​<\",{\"1\":{\"66\":1}}],[\"httpresponse\",{\"1\":{\"1184\":2}}],[\"http2\",{\"1\":{\"672\":2}}],[\"httpd\",{\"1\":{\"671\":1}}],[\"httpdns\",{\"1\":{\"622\":1}}],[\"httpmethod\",{\"1\":{\"446\":2}}],[\"http\",{\"1\":{\"446\":2,\"481\":2,\"520\":1,\"560\":1,\"586\":2,\"587\":1,\"592\":1,\"670\":1,\"672\":2,\"674\":1,\"1089\":1,\"1093\":1,\"1094\":1,\"1100\":1,\"1177\":1,\"1184\":3,\"1190\":1}}],[\"httpservletrequest\",{\"1\":{\"523\":1,\"526\":1,\"575\":1,\"576\":1,\"578\":2,\"579\":1,\"589\":1,\"596\":2}}],[\"httpsecurity\",{\"1\":{\"446\":9}}],[\"https\",{\"0\":{\"672\":1},\"1\":{\"41\":7,\"481\":1,\"537\":2,\"538\":2,\"539\":4,\"540\":1,\"542\":1,\"543\":3,\"549\":1,\"560\":1,\"567\":1,\"568\":1,\"575\":1,\"576\":1,\"663\":1,\"665\":4,\"668\":1,\"672\":1,\"766\":1,\"1086\":3,\"1087\":1,\"1089\":1,\"1090\":1,\"1093\":1,\"1094\":1,\"1095\":4,\"1140\":1,\"1171\":1}}],[\"html+css+javascript\",{\"1\":{\"557\":1}}],[\"html>\",{\"1\":{\"540\":1,\"548\":1}}],[\"html\",{\"1\":{\"41\":1,\"446\":3,\"520\":1,\"531\":3,\"532\":3,\"533\":8,\"534\":3,\"539\":1,\"540\":1,\"672\":5}}],[\"p==q\",{\"1\":{\"1284\":1}}],[\"p=0\",{\"1\":{\"613\":3}}],[\"pv\",{\"1\":{\"1274\":3}}],[\"png\",{\"1\":{\"1043\":1}}],[\"png`\",{\"1\":{\"543\":1}}],[\"p端口号\",{\"1\":{\"906\":1}}],[\"p密码\",{\"1\":{\"906\":1}}],[\"pq\",{\"1\":{\"789\":5}}],[\"pk\",{\"1\":{\"1274\":3}}],[\"pki\",{\"1\":{\"672\":2}}],[\"pk^1\",{\"1\":{\"376\":1}}],[\"pk^0\",{\"1\":{\"376\":1}}],[\"pk^ck\",{\"1\":{\"376\":2}}],[\"ppr\",{\"1\":{\"535\":1}}],[\"p3\",{\"1\":{\"506\":1}}],[\"p3367\",{\"0\":{\"274\":1}}],[\"p0\",{\"0\":{\"507\":1},\"1\":{\"506\":1}}],[\"phone\",{\"1\":{\"566\":2,\"589\":1,\"592\":1,\"920\":2}}],[\"phonenumber\",{\"1\":{\"471\":2}}],[\"ph\",{\"1\":{\"417\":4,\"1274\":4}}],[\"phi\",{\"1\":{\"379\":1,\"380\":5}}],[\"p+1\",{\"1\":{\"411\":1}}],[\"p为匹配串\",{\"1\":{\"411\":1}}],[\"pm​​\",{\"1\":{\"392\":1}}],[\"pm​\",{\"1\":{\"392\":1}}],[\"pmam​​\",{\"1\":{\"379\":1}}],[\"p2\",{\"0\":{\"508\":1},\"1\":{\"506\":1,\"508\":5,\"700\":6}}],[\"p2​\",{\"1\":{\"392\":2}}],[\"p2^c2\",{\"1\":{\"376\":1}}],[\"p1\",{\"0\":{\"508\":1},\"1\":{\"506\":1,\"508\":3,\"700\":6}}],[\"p1​\",{\"1\":{\"392\":2}}],[\"p1^1\",{\"1\":{\"376\":1}}],[\"p1^0\",{\"1\":{\"376\":1}}],[\"p1^c1\",{\"1\":{\"376\":2}}],[\"p^k\",{\"1\":{\"421\":1}}],[\"p^3\",{\"1\":{\"390\":1}}],[\"p^2\",{\"1\":{\"390\":1}}],[\"p​∗cpa​pb​​\",{\"1\":{\"389\":1}}],[\"pj=0\",{\"1\":{\"373\":1}}],[\"pj一定是pj\",{\"1\":{\"373\":1}}],[\"pb\",{\"1\":{\"361\":2,\"389\":1,\"434\":1}}],[\"python\",{\"1\":{\"512\":1,\"1095\":1}}],[\"python中的\",{\"1\":{\"249\":1}}],[\"py\",{\"1\":{\"361\":6,\"414\":6,\"1095\":1}}],[\"px\",{\"1\":{\"361\":7,\"414\":6}}],[\"placeholder=\",{\"1\":{\"587\":3}}],[\"player\",{\"1\":{\"658\":1}}],[\"players\",{\"1\":{\"129\":6}}],[\"playwright\",{\"1\":{\"559\":2}}],[\"plugins\",{\"1\":{\"1170\":1}}],[\"plugin\",{\"1\":{\"539\":1,\"658\":1,\"1170\":1,\"1171\":1}}],[\"plus\",{\"1\":{\"255\":2,\"500\":1,\"557\":1,\"560\":1,\"567\":2,\"575\":2,\"619\":1}}],[\"pi\",{\"1\":{\"1418\":2}}],[\"picgo\",{\"1\":{\"668\":1}}],[\"picture\",{\"1\":{\"511\":2}}],[\"ping\",{\"1\":{\"663\":1}}],[\"pi​​\",{\"1\":{\"392\":1}}],[\"pis\",{\"1\":{\"224\":1}}],[\"pii>\",{\"1\":{\"223\":1}}],[\"piii\",{\"1\":{\"223\":1}}],[\"pii\",{\"1\":{\"223\":1,\"278\":1,\"353\":1,\"431\":1}}],[\"pipeline\",{\"1\":{\"40\":1}}],[\"ps\",{\"1\":{\"128\":1,\"672\":1}}],[\"pause\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"paused\",{\"1\":{\"484\":1}}],[\"padded\",{\"1\":{\"1275\":1}}],[\"padding\",{\"1\":{\"540\":1,\"549\":1,\"587\":1}}],[\"panel\",{\"1\":{\"672\":1}}],[\"pagination=\",{\"1\":{\"592\":1}}],[\"pagebean\",{\"1\":{\"935\":2}}],[\"pagesize\",{\"1\":{\"592\":1,\"935\":1}}],[\"pages\",{\"1\":{\"592\":1}}],[\"page<>\",{\"1\":{\"525\":1}}],[\"page<question>\",{\"1\":{\"523\":2,\"525\":3}}],[\"page\",{\"1\":{\"525\":2,\"542\":3,\"544\":1,\"592\":2,\"672\":2,\"935\":1,\"958\":1}}],[\"pagerequest\",{\"1\":{\"523\":1,\"525\":1}}],[\"pattern>\",{\"1\":{\"1090\":1}}],[\"pattern\",{\"1\":{\"568\":1,\"575\":1}}],[\"pathsum\",{\"1\":{\"882\":1}}],[\"pathname\",{\"1\":{\"587\":3,\"591\":1}}],[\"path\",{\"1\":{\"281\":3,\"463\":1,\"576\":1,\"592\":1,\"671\":3,\"1306\":2,\"1314\":2,\"1504\":1}}],[\"pathcount\",{\"1\":{\"142\":2}}],[\"pass\",{\"1\":{\"664\":1,\"672\":1}}],[\"passward\",{\"1\":{\"568\":11}}],[\"password=password\",{\"1\":{\"1087\":2}}],[\"password\",{\"1\":{\"471\":2,\"566\":2,\"568\":6,\"575\":5,\"576\":8,\"587\":5,\"589\":1}}],[\"passwordencoder\",{\"1\":{\"446\":1}}],[\"pascal中的\",{\"1\":{\"249\":1}}],[\"package\",{\"1\":{\"446\":1,\"517\":1,\"559\":2,\"1026\":1,\"1055\":2,\"1063\":1,\"1082\":1}}],[\"pa\",{\"1\":{\"361\":2}}],[\"pair\",{\"1\":{\"206\":1,\"257\":1,\"1082\":1}}],[\"pair<k\",{\"0\":{\"1082\":1},\"1\":{\"1082\":1}}],[\"pair<>\",{\"1\":{\"821\":2,\"870\":2}}],[\"pair<first\",{\"1\":{\"257\":1}}],[\"pair<string\",{\"1\":{\"224\":1}}],[\"pair<ll\",{\"1\":{\"206\":1}}],[\"pair<integer\",{\"1\":{\"821\":1,\"870\":1}}],[\"pair<int\",{\"1\":{\"122\":1,\"223\":2,\"224\":1,\"278\":1,\"353\":1,\"422\":1,\"431\":1}}],[\"parkandcheckinterrupt\",{\"1\":{\"1504\":1,\"1505\":3,\"1507\":2,\"1510\":1}}],[\"parkutil\",{\"1\":{\"1334\":1}}],[\"parkuntil\",{\"1\":{\"1259\":2}}],[\"parking\",{\"1\":{\"1259\":4,\"1505\":1}}],[\"parknanos\",{\"1\":{\"1259\":2,\"1334\":1,\"1508\":2}}],[\"park\",{\"1\":{\"1251\":4,\"1252\":1,\"1258\":3,\"1259\":13,\"1260\":2,\"1505\":5,\"1506\":1}}],[\"parameter\",{\"1\":{\"1315\":1}}],[\"parametertype=\",{\"1\":{\"471\":1}}],[\"param\",{\"1\":{\"523\":2,\"525\":1,\"526\":5,\"568\":3,\"575\":4,\"576\":3,\"578\":2,\"579\":2,\"589\":1,\"596\":2,\"1201\":5,\"1315\":2,\"1316\":1,\"1317\":3}}],[\"params\",{\"1\":{\"255\":2,\"471\":3,\"523\":2,\"525\":1,\"526\":4,\"542\":3,\"592\":1}}],[\"parseexception\",{\"1\":{\"1309\":1}}],[\"parse\",{\"1\":{\"1309\":2}}],[\"parseboolean\",{\"1\":{\"1069\":1}}],[\"parsedouble\",{\"1\":{\"1005\":1}}],[\"parselong\",{\"1\":{\"182\":1}}],[\"parseint\",{\"1\":{\"127\":1,\"128\":2,\"129\":2,\"157\":3,\"161\":1,\"1069\":1}}],[\"parties\",{\"1\":{\"1393\":1}}],[\"partial<layoutsettings>\",{\"1\":{\"591\":1}}],[\"partial\",{\"1\":{\"535\":1}}],[\"partitions\",{\"1\":{\"49\":1}}],[\"partition\",{\"1\":{\"49\":2}}],[\"parts\",{\"1\":{\"127\":3}}],[\"parent\",{\"1\":{\"56\":2,\"215\":3,\"822\":1,\"1267\":1}}],[\"peereurekanodes\",{\"1\":{\"1162\":3,\"1163\":1,\"1165\":4}}],[\"peerawareinstanceregistryimpl\",{\"1\":{\"1160\":3}}],[\"peeklast\",{\"1\":{\"1077\":1}}],[\"peekfirst\",{\"1\":{\"1077\":1}}],[\"peek\",{\"1\":{\"83\":1,\"128\":2,\"845\":1,\"1037\":1,\"1038\":1,\"1075\":1,\"1076\":1,\"1078\":1,\"1325\":1,\"1346\":1}}],[\"pem存放路径\",{\"1\":{\"672\":1}}],[\"pem\",{\"1\":{\"672\":2}}],[\"pe\",{\"1\":{\"663\":1}}],[\"periodic\",{\"1\":{\"1368\":4}}],[\"period\",{\"1\":{\"1367\":1}}],[\"period时间过去后\",{\"1\":{\"1367\":1}}],[\"pertaining\",{\"1\":{\"1301\":1}}],[\"permanent\",{\"1\":{\"663\":2}}],[\"permits\",{\"1\":{\"1398\":4}}],[\"permitall\",{\"1\":{\"446\":5}}],[\"permitallurl\",{\"1\":{\"446\":2}}],[\"permitallurlproperties\",{\"1\":{\"446\":2}}],[\"permissionservice\",{\"1\":{\"465\":2}}],[\"permission\",{\"1\":{\"453\":1,\"457\":2,\"458\":1,\"459\":2}}],[\"permute\",{\"1\":{\"121\":2}}],[\"person\",{\"1\":{\"1467\":9}}],[\"persistencetype\",{\"1\":{\"592\":1}}],[\"persistencekey\",{\"1\":{\"592\":1}}],[\"pers\",{\"1\":{\"121\":2}}],[\"pool\",{\"1\":{\"1359\":1,\"1392\":19,\"1393\":12,\"1398\":42}}],[\"policy\",{\"1\":{\"1239\":1,\"1242\":1}}],[\"policyjsonstring\",{\"1\":{\"1102\":2}}],[\"poll的为null\",{\"1\":{\"1284\":1}}],[\"poll节点总是在队列对头\",{\"1\":{\"1283\":1}}],[\"polllast\",{\"1\":{\"1077\":1}}],[\"pollfirst\",{\"1\":{\"1077\":1}}],[\"poll\",{\"0\":{\"1284\":1,\"1285\":1},\"1\":{\"180\":1,\"737\":1,\"743\":1,\"789\":1,\"821\":1,\"870\":1,\"1076\":1,\"1078\":1,\"1283\":19,\"1284\":17,\"1285\":6,\"1286\":1,\"1325\":2,\"1326\":3,\"1346\":1,\"1350\":1}}],[\"power\",{\"1\":{\"1270\":1,\"1275\":1,\"1305\":1,\"1306\":1}}],[\"pow\",{\"1\":{\"1080\":1}}],[\"point\",{\"1\":{\"1027\":2,\"1028\":1,\"1029\":5,\"1283\":1,\"1284\":1,\"1351\":1}}],[\"port\",{\"1\":{\"1177\":1}}],[\"ports\",{\"1\":{\"663\":1}}],[\"port=10123\",{\"1\":{\"663\":2}}],[\"port=8081\",{\"1\":{\"488\":1}}],[\"possibly\",{\"1\":{\"1316\":1,\"1506\":1}}],[\"possiblecafe\",{\"1\":{\"108\":3}}],[\"position\",{\"1\":{\"200\":5,\"549\":1,\"1315\":1}}],[\"pos\",{\"1\":{\"99\":6,\"173\":6,\"206\":6,\"870\":3}}],[\"postponed\",{\"1\":{\"1242\":1}}],[\"postmapping\",{\"1\":{\"525\":1,\"526\":2,\"576\":2,\"596\":1}}],[\"post\",{\"1\":{\"41\":1,\"573\":1,\"596\":2,\"1184\":3,\"1185\":1}}],[\"popcount\",{\"1\":{\"121\":1}}],[\"pop\",{\"1\":{\"83\":7,\"93\":1,\"110\":2,\"121\":1,\"122\":2,\"128\":1,\"133\":1,\"174\":2,\"223\":2,\"224\":1,\"278\":1,\"279\":1,\"328\":1,\"329\":1,\"330\":1,\"348\":1,\"353\":1,\"355\":2,\"356\":1,\"422\":6,\"429\":1,\"845\":2,\"857\":1,\"1037\":1,\"1075\":1}}],[\"pull\",{\"1\":{\"1088\":1}}],[\"putlock\",{\"1\":{\"1350\":3,\"1351\":4,\"1353\":1}}],[\"putindex\",{\"1\":{\"1346\":1,\"1347\":4}}],[\"putifabsent\",{\"1\":{\"1272\":1}}],[\"putorderedobject\",{\"1\":{\"1282\":1}}],[\"putobjectvolatile\",{\"1\":{\"1268\":1}}],[\"putobjectargs\",{\"1\":{\"1103\":1}}],[\"putobject\",{\"1\":{\"1103\":2}}],[\"puttreeval\",{\"1\":{\"1272\":3}}],[\"putval\",{\"1\":{\"1272\":2}}],[\"putall\",{\"1\":{\"1149\":2}}],[\"put函数即可\",{\"1\":{\"688\":1}}],[\"putmapping\",{\"1\":{\"481\":1,\"482\":1}}],[\"puts\",{\"1\":{\"224\":1,\"281\":1,\"288\":1,\"289\":1,\"309\":1,\"360\":1,\"384\":1,\"394\":2,\"1346\":1,\"1350\":1,\"1351\":1}}],[\"put\",{\"0\":{\"1272\":1,\"1347\":1,\"1351\":1},\"1\":{\"129\":2,\"179\":1,\"273\":2,\"686\":2,\"687\":6,\"688\":3,\"767\":3,\"784\":1,\"882\":1,\"887\":1,\"1040\":1,\"1074\":2,\"1201\":3,\"1204\":1,\"1207\":1,\"1210\":1,\"1211\":1,\"1264\":3,\"1272\":7,\"1273\":1,\"1275\":1,\"1276\":3,\"1317\":1,\"1325\":2,\"1346\":2,\"1347\":2,\"1348\":1,\"1350\":2,\"1351\":6,\"1408\":1,\"1411\":1}}],[\"pushup\",{\"1\":{\"206\":3}}],[\"push\",{\"1\":{\"83\":5,\"92\":6,\"93\":1,\"108\":1,\"110\":2,\"121\":3,\"122\":1,\"128\":1,\"133\":5,\"141\":1,\"174\":3,\"200\":1,\"223\":4,\"224\":2,\"278\":2,\"279\":2,\"298\":2,\"302\":2,\"309\":2,\"311\":1,\"327\":4,\"328\":3,\"329\":2,\"330\":2,\"342\":2,\"345\":2,\"348\":2,\"353\":2,\"355\":2,\"356\":2,\"369\":2,\"375\":2,\"390\":3,\"422\":6,\"429\":2,\"431\":3,\"587\":2,\"589\":1,\"591\":1,\"845\":1,\"857\":3,\"1037\":1,\"1075\":1}}],[\"publicread\",{\"1\":{\"1102\":1}}],[\"public\",{\"1\":{\"70\":2,\"71\":2,\"72\":1,\"82\":2,\"83\":4,\"87\":2,\"88\":2,\"97\":2,\"98\":2,\"99\":2,\"103\":2,\"104\":2,\"108\":1,\"109\":1,\"114\":1,\"115\":1,\"126\":2,\"127\":3,\"128\":3,\"129\":7,\"133\":1,\"134\":1,\"135\":1,\"152\":2,\"157\":2,\"161\":2,\"162\":2,\"178\":2,\"179\":2,\"180\":2,\"182\":2,\"187\":1,\"446\":3,\"465\":1,\"468\":1,\"471\":2,\"481\":1,\"482\":1,\"515\":1,\"517\":1,\"523\":3,\"525\":3,\"526\":5,\"543\":2,\"568\":2,\"575\":2,\"576\":5,\"578\":1,\"579\":1,\"580\":1,\"589\":1,\"596\":2,\"682\":1,\"687\":3,\"688\":3,\"694\":1,\"700\":1,\"705\":1,\"710\":1,\"713\":2,\"724\":1,\"725\":1,\"736\":1,\"737\":1,\"743\":1,\"748\":1,\"749\":1,\"755\":1,\"761\":1,\"767\":2,\"772\":1,\"778\":1,\"783\":1,\"784\":1,\"789\":1,\"795\":1,\"796\":1,\"797\":1,\"803\":4,\"809\":1,\"815\":1,\"820\":1,\"821\":1,\"822\":1,\"827\":1,\"828\":2,\"834\":1,\"840\":1,\"845\":1,\"846\":1,\"851\":1,\"852\":2,\"857\":1,\"864\":1,\"870\":2,\"876\":1,\"882\":1,\"887\":1,\"888\":1,\"893\":1,\"894\":2,\"899\":1,\"900\":1,\"901\":1,\"935\":1,\"978\":2,\"980\":6,\"981\":4,\"982\":4,\"984\":18,\"985\":4,\"986\":2,\"988\":8,\"989\":2,\"990\":8,\"992\":2,\"993\":2,\"994\":4,\"997\":2,\"998\":2,\"999\":8,\"1000\":4,\"1001\":2,\"1004\":4,\"1006\":2,\"1011\":2,\"1014\":2,\"1015\":2,\"1017\":2,\"1018\":2,\"1020\":2,\"1021\":2,\"1022\":2,\"1023\":2,\"1026\":3,\"1027\":7,\"1028\":3,\"1029\":2,\"1031\":4,\"1032\":1,\"1033\":4,\"1034\":6,\"1046\":6,\"1047\":2,\"1048\":2,\"1049\":2,\"1055\":7,\"1059\":7,\"1061\":4,\"1062\":10,\"1063\":4,\"1078\":1,\"1100\":3,\"1133\":2,\"1145\":2,\"1148\":1,\"1150\":2,\"1164\":3,\"1165\":1,\"1175\":1,\"1201\":5,\"1210\":7,\"1211\":2,\"1221\":5,\"1233\":2,\"1250\":1,\"1251\":2,\"1252\":1,\"1254\":4,\"1260\":2,\"1264\":1,\"1270\":1,\"1273\":1,\"1275\":2,\"1281\":1,\"1283\":1,\"1284\":2,\"1293\":1,\"1294\":1,\"1301\":1,\"1302\":1,\"1303\":1,\"1309\":4,\"1330\":5,\"1336\":4,\"1337\":7,\"1338\":1,\"1339\":1,\"1340\":3,\"1346\":1,\"1347\":1,\"1348\":1,\"1349\":1,\"1351\":1,\"1352\":1,\"1359\":1,\"1366\":4,\"1367\":4,\"1368\":2,\"1370\":1,\"1385\":4,\"1386\":2,\"1387\":4,\"1388\":6,\"1392\":3,\"1393\":3,\"1398\":2,\"1399\":2,\"1406\":12,\"1407\":12,\"1409\":6,\"1410\":6,\"1411\":6,\"1429\":3,\"1431\":2,\"1432\":3,\"1449\":3,\"1455\":3,\"1458\":3,\"1467\":4,\"1469\":2,\"1470\":3,\"1471\":2,\"1475\":4,\"1476\":5,\"1478\":4,\"1482\":3,\"1485\":2,\"1493\":1,\"1495\":1,\"1496\":11,\"1503\":1,\"1506\":1,\"1507\":1,\"1508\":1,\"1510\":1,\"1511\":1}}],[\"practices\",{\"1\":{\"541\":1}}],[\"progress\",{\"1\":{\"1511\":1}}],[\"provides\",{\"1\":{\"1496\":1}}],[\"provider\",{\"1\":{\"1129\":4,\"1133\":1,\"1154\":1}}],[\"probably\",{\"1\":{\"1252\":1}}],[\"problems\",{\"1\":{\"1191\":2}}],[\"processed\",{\"1\":{\"1274\":1}}],[\"processcacheddata\",{\"1\":{\"1244\":1}}],[\"proceeds\",{\"1\":{\"1511\":1}}],[\"proceed\",{\"1\":{\"1243\":1,\"1359\":1}}],[\"procolumns<api\",{\"1\":{\"592\":1}}],[\"procolumns\",{\"1\":{\"592\":1}}],[\"procomponents\",{\"1\":{\"540\":3,\"548\":1,\"592\":3}}],[\"proxy\",{\"1\":{\"664\":1,\"672\":4}}],[\"prometheus在b端门店回收系统中的应用\",{\"1\":{\"618\":1}}],[\"promise\",{\"1\":{\"592\":1}}],[\"promise<api\",{\"1\":{\"591\":1}}],[\"promise<\",{\"1\":{\"591\":1}}],[\"proformcheckbox>\",{\"1\":{\"588\":1}}],[\"profile=system\",{\"1\":{\"672\":1}}],[\"profile\",{\"1\":{\"446\":1}}],[\"pro\",{\"1\":{\"540\":2,\"557\":1,\"559\":4,\"587\":1,\"592\":4}}],[\"propagation\",{\"1\":{\"1511\":1}}],[\"propagates\",{\"1\":{\"1511\":1}}],[\"propagate\",{\"1\":{\"1501\":1,\"1505\":1,\"1511\":2}}],[\"properly\",{\"1\":{\"1496\":1}}],[\"propertiesinstanceconfig\",{\"1\":{\"1178\":2}}],[\"properties\",{\"1\":{\"446\":1,\"1149\":6,\"1150\":1,\"1151\":1,\"1157\":1,\"1178\":2}}],[\"prop\",{\"1\":{\"1149\":1}}],[\"props\",{\"1\":{\"1149\":8}}],[\"propswithchildren\",{\"1\":{\"540\":1}}],[\"protect\",{\"1\":{\"1191\":2}}],[\"protected\",{\"1\":{\"446\":2,\"688\":1,\"1027\":1,\"1232\":2,\"1233\":1,\"1239\":1,\"1240\":1,\"1242\":1,\"1243\":1,\"1302\":2,\"1351\":1,\"1494\":1,\"1495\":3,\"1496\":3}}],[\"protable\",{\"1\":{\"540\":1,\"592\":1}}],[\"protobuf\",{\"1\":{\"58\":2}}],[\"prod\",{\"1\":{\"181\":10}}],[\"productorconsumer\",{\"1\":{\"1409\":1,\"1410\":1,\"1411\":1}}],[\"productor\",{\"1\":{\"1407\":14,\"1409\":3,\"1410\":3,\"1411\":3}}],[\"products\",{\"1\":{\"181\":4}}],[\"product\",{\"1\":{\"167\":2}}],[\"preindex\",{\"1\":{\"1317\":1}}],[\"preceding\",{\"1\":{\"1317\":1}}],[\"pred\",{\"1\":{\"1272\":4,\"1504\":6,\"1505\":8}}],[\"predecessors\",{\"1\":{\"1505\":1}}],[\"predecessor\",{\"1\":{\"1252\":1,\"1504\":1,\"1505\":1,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"premap\",{\"1\":{\"767\":3}}],[\"preorder\",{\"1\":{\"765\":2,\"766\":1,\"767\":19}}],[\"prefer\",{\"1\":{\"672\":1}}],[\"prefix\",{\"1\":{\"587\":3,\"801\":2,\"803\":2,\"1100\":1}}],[\"prerequisites\",{\"1\":{\"874\":2,\"875\":1}}],[\"preread\",{\"1\":{\"664\":1}}],[\"prerendering\",{\"1\":{\"535\":1}}],[\"prestartallcorethreads\",{\"1\":{\"1359\":1}}],[\"prestartcorethread\",{\"1\":{\"1359\":1}}],[\"presto\",{\"1\":{\"1095\":1}}],[\"presto简介\",{\"1\":{\"641\":1}}],[\"present\",{\"1\":{\"1317\":1}}],[\"preservation\",{\"1\":{\"1191\":3}}],[\"preset\",{\"1\":{\"559\":1,\"1351\":1}}],[\"presignedobjecturl\",{\"1\":{\"1103\":2}}],[\"pretier\",{\"1\":{\"539\":1}}],[\"prettier\",{\"1\":{\"499\":1,\"539\":15}}],[\"prepostenabled\",{\"1\":{\"446\":1,\"465\":1}}],[\"preauthorize\",{\"1\":{\"446\":1,\"465\":6,\"466\":1,\"467\":6,\"468\":1,\"481\":1,\"482\":1}}],[\"pre\",{\"1\":{\"146\":3,\"682\":5,\"724\":5,\"725\":5,\"784\":2,\"900\":3,\"1505\":1}}],[\"prevents\",{\"1\":{\"1359\":1}}],[\"previousthread\",{\"1\":{\"1337\":3}}],[\"previndex\",{\"1\":{\"1317\":4}}],[\"prev\",{\"1\":{\"103\":12,\"224\":4,\"1267\":1,\"1274\":2,\"1501\":1,\"1504\":2,\"1505\":3,\"1506\":1}}],[\"prior\",{\"1\":{\"1317\":1}}],[\"priorityblockingqueue\",{\"1\":{\"1326\":3,\"1359\":1,\"1361\":1}}],[\"priorityqueue\",{\"0\":{\"1078\":1},\"1\":{\"1078\":4,\"1369\":1}}],[\"priorityqueue<e>\",{\"1\":{\"1078\":4}}],[\"priorityqueue<>\",{\"1\":{\"789\":1,\"1038\":2,\"1078\":2}}],[\"priorityqueue<listnode>\",{\"1\":{\"789\":1}}],[\"priority\",{\"1\":{\"223\":2,\"224\":1,\"353\":1,\"422\":2,\"429\":1,\"857\":1,\"1339\":1}}],[\"prio=0\",{\"1\":{\"1259\":2}}],[\"prio=5\",{\"1\":{\"1259\":2}}],[\"principal\",{\"1\":{\"1102\":1}}],[\"printstacktrace\",{\"1\":{\"1046\":1,\"1047\":2,\"1048\":2,\"1221\":1,\"1250\":1,\"1254\":1,\"1260\":1,\"1309\":1,\"1330\":2,\"1336\":1,\"1337\":1,\"1340\":2,\"1392\":1,\"1393\":2,\"1398\":1,\"1399\":2,\"1406\":4,\"1407\":2,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1,\"1496\":1}}],[\"printf\",{\"1\":{\"128\":1,\"243\":4,\"251\":1,\"281\":1,\"309\":1,\"314\":1,\"327\":1,\"328\":3,\"329\":1,\"345\":1,\"360\":1,\"384\":1,\"411\":1,\"982\":2,\"984\":14,\"994\":1,\"999\":3,\"1000\":1,\"1001\":1,\"1006\":1,\"1011\":1,\"1020\":1}}],[\"print\",{\"1\":{\"103\":1,\"167\":1,\"309\":2,\"982\":2,\"1005\":2}}],[\"println\",{\"1\":{\"82\":2,\"83\":1,\"87\":1,\"88\":4,\"97\":2,\"98\":1,\"99\":2,\"104\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"157\":1,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":2,\"467\":2,\"567\":1,\"980\":9,\"981\":1,\"982\":2,\"984\":16,\"985\":5,\"986\":1,\"988\":4,\"989\":2,\"990\":4,\"992\":2,\"993\":1,\"994\":2,\"999\":2,\"1000\":1,\"1001\":1,\"1004\":5,\"1006\":1,\"1007\":2,\"1014\":2,\"1015\":3,\"1017\":1,\"1018\":2,\"1021\":1,\"1022\":4,\"1023\":1,\"1029\":2,\"1033\":3,\"1034\":3,\"1047\":3,\"1048\":2,\"1049\":2,\"1055\":3,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":1,\"1069\":2,\"1102\":3,\"1103\":6,\"1201\":2,\"1204\":2,\"1207\":2,\"1211\":2,\"1221\":4,\"1254\":2,\"1260\":1,\"1284\":2,\"1309\":1,\"1330\":3,\"1336\":2,\"1337\":1,\"1340\":2,\"1385\":2,\"1386\":2,\"1387\":2,\"1388\":2,\"1392\":5,\"1393\":4,\"1398\":4,\"1399\":3,\"1406\":12,\"1407\":10,\"1409\":6,\"1410\":6,\"1411\":2,\"1429\":1,\"1449\":1,\"1467\":1,\"1482\":1}}],[\"primes2\",{\"1\":{\"372\":4}}],[\"primes\",{\"1\":{\"371\":4,\"372\":3,\"373\":17,\"376\":4,\"380\":21,\"390\":9}}],[\"prime\",{\"1\":{\"367\":1,\"369\":2,\"372\":2,\"373\":1}}],[\"prim\",{\"1\":{\"360\":2}}],[\"primary\",{\"1\":{\"50\":2,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"566\":1,\"919\":1}}],[\"price\",{\"1\":{\"140\":4,\"152\":5}}],[\"prices\",{\"1\":{\"65\":3,\"109\":4,\"152\":2}}],[\"private\",{\"1\":{\"87\":2,\"129\":2,\"162\":1,\"180\":1,\"446\":6,\"515\":2,\"517\":5,\"523\":2,\"525\":1,\"526\":8,\"543\":1,\"568\":2,\"576\":8,\"578\":1,\"687\":1,\"688\":1,\"784\":1,\"803\":3,\"827\":2,\"852\":2,\"935\":2,\"1010\":2,\"1011\":1,\"1014\":2,\"1015\":4,\"1017\":1,\"1018\":2,\"1020\":1,\"1021\":1,\"1022\":2,\"1023\":1,\"1027\":3,\"1028\":1,\"1033\":1,\"1034\":1,\"1047\":1,\"1048\":1,\"1061\":1,\"1062\":1,\"1063\":2,\"1100\":5,\"1133\":1,\"1149\":2,\"1164\":1,\"1177\":1,\"1201\":6,\"1210\":1,\"1221\":2,\"1250\":2,\"1251\":1,\"1252\":2,\"1254\":3,\"1270\":1,\"1271\":1,\"1274\":1,\"1275\":4,\"1281\":3,\"1292\":1,\"1293\":2,\"1302\":1,\"1305\":1,\"1306\":9,\"1307\":2,\"1308\":1,\"1309\":2,\"1314\":1,\"1315\":1,\"1316\":1,\"1317\":3,\"1319\":1,\"1326\":1,\"1337\":1,\"1346\":2,\"1347\":1,\"1348\":1,\"1350\":6,\"1369\":4,\"1370\":1,\"1375\":7,\"1385\":2,\"1386\":3,\"1387\":3,\"1388\":2,\"1392\":2,\"1393\":1,\"1398\":1,\"1399\":1,\"1406\":7,\"1407\":6,\"1409\":3,\"1410\":8,\"1411\":3,\"1429\":1,\"1431\":1,\"1432\":1,\"1449\":1,\"1455\":2,\"1458\":1,\"1467\":3,\"1472\":2,\"1475\":3,\"1476\":1,\"1478\":2,\"1482\":1,\"1485\":2,\"1496\":4,\"1504\":2,\"1505\":3,\"1506\":1,\"1507\":1,\"1508\":1,\"1510\":1,\"1511\":1}}],[\"p\",{\"1\":{\"41\":2,\"119\":3,\"121\":4,\"122\":2,\"127\":26,\"173\":5,\"187\":6,\"255\":2,\"361\":8,\"376\":3,\"381\":5,\"388\":5,\"389\":31,\"390\":8,\"392\":4,\"411\":7,\"412\":11,\"414\":8,\"415\":8,\"416\":9,\"421\":10,\"613\":2,\"700\":4,\"753\":2,\"755\":4,\"789\":5,\"809\":6,\"822\":8,\"888\":26,\"906\":3,\"1088\":2,\"1252\":3,\"1272\":8,\"1273\":3,\"1274\":22,\"1283\":32,\"1284\":35,\"1285\":7,\"1504\":5,\"1505\":1,\"1507\":4,\"1508\":4,\"1510\":4}}],[\"評論\",{\"1\":{\"41\":1}}],[\"two\",{\"1\":{\"1270\":1,\"1283\":2,\"1284\":1,\"1286\":1,\"1305\":1,\"1306\":1,\"1346\":1}}],[\"t2\",{\"1\":{\"947\":1}}],[\"t1\",{\"1\":{\"947\":1}}],[\"t1597\",{\"1\":{\"237\":1}}],[\"t1596\",{\"1\":{\"236\":1}}],[\"t1595\",{\"1\":{\"235\":1}}],[\"tmp\",{\"1\":{\"705\":2,\"749\":4,\"833\":1,\"834\":7,\"870\":2,\"1020\":2}}],[\"tcp\",{\"1\":{\"663\":4}}],[\"tco\",{\"1\":{\"438\":1}}],[\"ts\",{\"1\":{\"542\":1,\"559\":3,\"589\":3,\"591\":2,\"592\":3}}],[\"tsx\",{\"1\":{\"539\":1,\"540\":2,\"542\":2,\"544\":2,\"548\":2,\"549\":2,\"587\":1,\"589\":1,\"591\":1,\"596\":1}}],[\"terminated\",{\"1\":{\"1334\":1,\"1337\":11}}],[\"terminates\",{\"1\":{\"1329\":1}}],[\"terminal\",{\"1\":{\"559\":1,\"1107\":2}}],[\"tensorflow\",{\"1\":{\"1095\":1}}],[\"testcaffeine\",{\"1\":{\"1207\":1}}],[\"testguava\",{\"1\":{\"1204\":1}}],[\"test10\",{\"1\":{\"1103\":1}}],[\"test2\",{\"1\":{\"1103\":1}}],[\"test09\",{\"1\":{\"1103\":1}}],[\"test08\",{\"1\":{\"1103\":1}}],[\"test07\",{\"1\":{\"1103\":1}}],[\"test06\",{\"1\":{\"1103\":1}}],[\"test05\",{\"1\":{\"1103\":1}}],[\"test04\",{\"1\":{\"1102\":1}}],[\"test03\",{\"1\":{\"1102\":1}}],[\"test02\",{\"1\":{\"1102\":1}}],[\"test01\",{\"1\":{\"1102\":1}}],[\"testuserregister\",{\"1\":{\"568\":1}}],[\"testinsertuser\",{\"1\":{\"567\":1}}],[\"test\",{\"1\":{\"567\":1,\"568\":1,\"1103\":5,\"1107\":6,\"1119\":4,\"1149\":1,\"1190\":1,\"1194\":1,\"1201\":1,\"1204\":1,\"1207\":1,\"1469\":3,\"1470\":2,\"1471\":1}}],[\"tests\",{\"1\":{\"559\":2}}],[\"textbook\",{\"1\":{\"1346\":1}}],[\"text\",{\"1\":{\"511\":1,\"512\":3,\"549\":1,\"592\":8,\"920\":1,\"958\":1}}],[\"template\",{\"0\":{\"1520\":1}}],[\"temp\",{\"1\":{\"318\":6,\"1476\":1,\"1478\":1}}],[\"tps\",{\"1\":{\"436\":1}}],[\"tb\",{\"1\":{\"434\":1,\"922\":3,\"926\":2,\"942\":6}}],[\"t表示该元素与它的左\",{\"1\":{\"417\":1}}],[\"t为当前这种状态的集合数量\",{\"1\":{\"392\":1}}],[\"t为余数\",{\"1\":{\"330\":1}}],[\"tid=0x0069cc00\",{\"1\":{\"1259\":1}}],[\"tid=0x02cdcc00\",{\"1\":{\"1259\":1}}],[\"tid\",{\"1\":{\"1242\":1,\"1243\":1}}],[\"tinylfu\",{\"1\":{\"1205\":1}}],[\"tinytext\",{\"1\":{\"920\":1}}],[\"tinyblob\",{\"1\":{\"920\":1}}],[\"tinyint\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"566\":4,\"920\":1}}],[\"title=\",{\"1\":{\"587\":1}}],[\"title>\",{\"1\":{\"587\":1}}],[\"title\",{\"1\":{\"481\":1,\"482\":1,\"511\":4,\"512\":4,\"517\":1,\"525\":1,\"587\":1,\"592\":12}}],[\"timer\",{\"1\":{\"1365\":2}}],[\"timed\",{\"1\":{\"1329\":1,\"1334\":3}}],[\"timeunit\",{\"1\":{\"1103\":1,\"1158\":2,\"1201\":2,\"1204\":2,\"1207\":1,\"1248\":1,\"1325\":2,\"1326\":1,\"1359\":1,\"1367\":4,\"1368\":1,\"1370\":1,\"1392\":1,\"1393\":1,\"1398\":3,\"1399\":2,\"1410\":1,\"1493\":1,\"1496\":1,\"1508\":1}}],[\"time=now\",{\"1\":{\"926\":1}}],[\"time++\",{\"1\":{\"869\":1,\"870\":2}}],[\"timeoutexception\",{\"1\":{\"1393\":1,\"1399\":1}}],[\"timeout\",{\"1\":{\"577\":1,\"672\":1,\"1221\":1,\"1248\":2,\"1325\":2,\"1326\":1,\"1334\":1,\"1392\":2,\"1393\":1,\"1398\":2,\"1399\":1,\"1496\":2,\"1508\":1}}],[\"timestamp\",{\"1\":{\"510\":4,\"511\":4,\"512\":4,\"513\":3,\"566\":6,\"920\":1}}],[\"time\",{\"1\":{\"471\":2,\"592\":4,\"869\":3,\"870\":4,\"920\":1,\"926\":1,\"1090\":1,\"1190\":1,\"1248\":1,\"1283\":1,\"1284\":1,\"1286\":1,\"1317\":1,\"1410\":1,\"1493\":1}}],[\"tips\",{\"1\":{\"363\":1}}],[\"ti​=1\",{\"1\":{\"168\":1}}],[\"ti​=0\",{\"1\":{\"168\":1}}],[\"ti​\",{\"1\":{\"110\":1,\"168\":1}}],[\"tt表示队尾\",{\"1\":{\"409\":1}}],[\"tt表示栈顶\",{\"1\":{\"406\":1}}],[\"tt\",{\"1\":{\"349\":3,\"406\":4,\"407\":4,\"409\":3,\"410\":5}}],[\"ttl\",{\"1\":{\"61\":1}}],[\"t再除以10\",{\"1\":{\"327\":1}}],[\"turned\",{\"1\":{\"1191\":2}}],[\"ture\",{\"1\":{\"360\":1}}],[\"tuesday\",{\"1\":{\"986\":1}}],[\"tu\",{\"1\":{\"257\":3}}],[\"tuple<int\",{\"1\":{\"257\":2}}],[\"tuples\",{\"1\":{\"140\":9}}],[\"tuple\",{\"0\":{\"257\":1},\"1\":{\"140\":3,\"257\":2}}],[\"t的最大值\",{\"1\":{\"252\":1}}],[\"t这样的出口符号\",{\"1\":{\"237\":1}}],[\"typical\",{\"1\":{\"1242\":1}}],[\"typings\",{\"1\":{\"589\":2}}],[\"typora\",{\"1\":{\"668\":1}}],[\"typescript\",{\"1\":{\"499\":1,\"538\":1,\"539\":1,\"546\":1}}],[\"typedef\",{\"1\":{\"141\":1,\"311\":1,\"376\":1,\"421\":1}}],[\"type=\",{\"1\":{\"30\":3}}],[\"type\",{\"1\":{\"30\":1,\"56\":3,\"58\":1,\"252\":2,\"515\":1,\"587\":5,\"589\":4,\"592\":4}}],[\"ty\",{\"1\":{\"236\":3}}],[\"txt\",{\"1\":{\"543\":1,\"1049\":2}}],[\"tx\",{\"1\":{\"236\":3}}],[\"t≤n≤1000\",{\"1\":{\"223\":1}}],[\"task\",{\"1\":{\"1330\":2,\"1359\":4,\"1370\":6}}],[\"taskexception\",{\"1\":{\"481\":1}}],[\"takelock\",{\"1\":{\"1350\":3,\"1352\":4,\"1353\":1}}],[\"takes\",{\"1\":{\"1346\":1,\"1350\":1}}],[\"takeindex\",{\"1\":{\"1346\":1,\"1348\":5}}],[\"take\",{\"0\":{\"1348\":1,\"1352\":1},\"1\":{\"1325\":1,\"1326\":2,\"1346\":2,\"1348\":4,\"1350\":2,\"1351\":1,\"1352\":3,\"1408\":1,\"1411\":1}}],[\"tale\",{\"1\":{\"1276\":1}}],[\"tabel\",{\"1\":{\"1272\":1,\"1317\":1}}],[\"tab中索引为i的位置的元素为null\",{\"1\":{\"1272\":1}}],[\"tabat\",{\"1\":{\"1268\":2,\"1272\":3,\"1273\":1,\"1274\":3}}],[\"tab\",{\"1\":{\"1267\":2,\"1268\":6,\"1271\":7,\"1272\":11,\"1273\":4,\"1274\":7,\"1275\":5,\"1306\":5,\"1307\":3,\"1308\":4,\"1314\":5,\"1315\":3,\"1316\":10,\"1317\":17}}],[\"table数组的代码为\",{\"1\":{\"1274\":1}}],[\"tableb\",{\"1\":{\"944\":2}}],[\"tablea\",{\"1\":{\"944\":2}}],[\"tablesizefor\",{\"1\":{\"1270\":3}}],[\"tables\",{\"1\":{\"921\":1}}],[\"tabledropdown\",{\"1\":{\"592\":1}}],[\"tabledatainfo\",{\"1\":{\"465\":1}}],[\"tablefiled\",{\"1\":{\"567\":1}}],[\"tablelogic\",{\"1\":{\"515\":1,\"575\":1}}],[\"tableid\",{\"1\":{\"515\":1}}],[\"tablename\",{\"1\":{\"515\":2}}],[\"tablecapacity\",{\"1\":{\"162\":1}}],[\"tableused\",{\"1\":{\"162\":3}}],[\"table\",{\"1\":{\"162\":5,\"174\":8,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"540\":1,\"566\":1,\"592\":1,\"918\":1,\"921\":1,\"922\":7,\"923\":1,\"937\":2,\"971\":1,\"1266\":5,\"1267\":1,\"1268\":3,\"1270\":5,\"1271\":3,\"1272\":16,\"1273\":3,\"1274\":5,\"1275\":3,\"1305\":5,\"1306\":7,\"1307\":3,\"1308\":2,\"1314\":3,\"1315\":4,\"1316\":11,\"1317\":13}}],[\"table=\",{\"1\":{\"162\":1}}],[\"targetsum\",{\"1\":{\"880\":2,\"881\":2,\"882\":5}}],[\"target\",{\"1\":{\"671\":3,\"772\":9,\"852\":4,\"1053\":1,\"1319\":1}}],[\"target=\",{\"1\":{\"549\":1,\"588\":1,\"592\":1}}],[\"tar\",{\"1\":{\"670\":4}}],[\"tags\",{\"1\":{\"512\":1,\"517\":2,\"525\":1}}],[\"tail\",{\"1\":{\"103\":4,\"134\":7,\"1281\":4,\"1283\":28,\"1285\":3,\"1286\":11,\"1350\":1,\"1504\":4,\"1506\":2,\"1511\":1}}],[\"trailing\",{\"1\":{\"1316\":1,\"1317\":1}}],[\"trade\",{\"1\":{\"1272\":1,\"1291\":1}}],[\"transiently\",{\"1\":{\"1252\":1}}],[\"transient\",{\"1\":{\"1250\":2,\"1275\":4,\"1281\":2,\"1292\":1,\"1350\":2}}],[\"transport\",{\"1\":{\"1158\":1}}],[\"transferqueue\",{\"1\":{\"1326\":1}}],[\"transferindex\",{\"1\":{\"1274\":3,\"1275\":1}}],[\"transfer方法源码为\",{\"1\":{\"1274\":1}}],[\"transfer\",{\"0\":{\"1274\":1},\"1\":{\"1274\":3,\"1275\":2,\"1326\":5}}],[\"transferforsignal\",{\"1\":{\"1252\":4}}],[\"transferto\",{\"1\":{\"1103\":1}}],[\"transform\",{\"1\":{\"592\":1}}],[\"transaction\",{\"1\":{\"954\":1}}],[\"traverse\",{\"1\":{\"887\":1,\"1506\":1}}],[\"trying\",{\"1\":{\"1511\":1}}],[\"trytransfer\",{\"1\":{\"1326\":3}}],[\"tryacquirenanos\",{\"0\":{\"1508\":1},\"1\":{\"1496\":1,\"1500\":1,\"1508\":2}}],[\"tryacquiresharednanos\",{\"0\":{\"1512\":1},\"1\":{\"1500\":1}}],[\"tryacquireshared\",{\"1\":{\"1242\":2,\"1496\":1,\"1510\":4}}],[\"tryacquire\",{\"1\":{\"1233\":1,\"1239\":3,\"1251\":1,\"1398\":4,\"1495\":6,\"1496\":5,\"1503\":1,\"1504\":2,\"1507\":2,\"1508\":2}}],[\"tryrelease返回\",{\"1\":{\"1506\":1}}],[\"tryreleaseshared\",{\"1\":{\"1242\":1,\"1243\":2,\"1496\":1,\"1511\":2}}],[\"tryrelease\",{\"1\":{\"1232\":2,\"1240\":2,\"1496\":2,\"1506\":1}}],[\"trylock\",{\"1\":{\"1221\":1,\"1493\":2,\"1496\":2,\"1508\":1}}],[\"try\",{\"0\":{\"1049\":1},\"1\":{\"587\":1,\"589\":1,\"591\":1,\"801\":1,\"1047\":1,\"1048\":1,\"1049\":4,\"1059\":3,\"1061\":1,\"1063\":1,\"1103\":1,\"1149\":1,\"1221\":1,\"1242\":1,\"1244\":2,\"1250\":1,\"1251\":1,\"1252\":1,\"1254\":3,\"1260\":1,\"1266\":1,\"1271\":1,\"1274\":2,\"1294\":1,\"1309\":1,\"1330\":1,\"1336\":1,\"1337\":1,\"1340\":2,\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1359\":2,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":2,\"1406\":4,\"1407\":2,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1,\"1492\":1,\"1496\":1,\"1504\":2,\"1506\":1,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"triggertime\",{\"1\":{\"1368\":1,\"1370\":1}}],[\"triggers\",{\"1\":{\"484\":6}}],[\"triggerbuilder\",{\"1\":{\"479\":1}}],[\"trigger\",{\"1\":{\"479\":1,\"484\":2,\"489\":1}}],[\"trie\",{\"0\":{\"800\":1},\"1\":{\"412\":1,\"801\":2,\"803\":9}}],[\"trie树存储形式\",{\"1\":{\"412\":1}}],[\"trie树\",{\"0\":{\"412\":1}}],[\"trimtosize\",{\"1\":{\"1072\":1}}],[\"trim\",{\"1\":{\"128\":1,\"157\":1,\"1005\":1,\"1069\":1}}],[\"treeifybin\",{\"1\":{\"1272\":3}}],[\"treeify\",{\"1\":{\"1272\":3}}],[\"treebin<k\",{\"1\":{\"1267\":1,\"1272\":2,\"1274\":4}}],[\"treebins\",{\"1\":{\"1267\":1}}],[\"treebin\",{\"1\":{\"1267\":5,\"1272\":6,\"1274\":2}}],[\"treeset\",{\"1\":{\"1073\":2,\"1074\":1}}],[\"treeset多的函数\",{\"1\":{\"1039\":1}}],[\"treeset<k>\",{\"1\":{\"1039\":1}}],[\"tree\",{\"1\":{\"157\":10,\"186\":3,\"203\":2,\"1267\":1}}],[\"treenode<k\",{\"1\":{\"1267\":7,\"1274\":4}}],[\"treenode\",{\"1\":{\"133\":2,\"187\":4,\"710\":2,\"713\":2,\"723\":1,\"724\":2,\"725\":2,\"736\":2,\"737\":2,\"743\":2,\"748\":1,\"749\":2,\"755\":6,\"761\":2,\"767\":9,\"809\":3,\"815\":4,\"864\":4,\"882\":2,\"899\":2,\"900\":1,\"901\":2,\"1267\":5,\"1272\":2}}],[\"treemap<k\",{\"1\":{\"1040\":2}}],[\"treemap<>\",{\"1\":{\"129\":2}}],[\"treemap<integer\",{\"1\":{\"129\":1}}],[\"treemap<string\",{\"1\":{\"129\":1}}],[\"treemap\",{\"1\":{\"129\":3,\"1074\":3}}],[\"true\",{\"1\":{\"77\":2,\"93\":2,\"98\":1,\"99\":1,\"108\":3,\"127\":3,\"162\":1,\"180\":2,\"186\":1,\"187\":4,\"223\":1,\"281\":1,\"288\":1,\"291\":4,\"309\":1,\"311\":1,\"328\":1,\"347\":1,\"348\":2,\"352\":1,\"353\":1,\"355\":2,\"356\":3,\"360\":1,\"362\":2,\"363\":2,\"367\":1,\"371\":1,\"372\":4,\"373\":2,\"380\":1,\"381\":2,\"390\":1,\"419\":1,\"430\":1,\"446\":2,\"465\":2,\"526\":1,\"578\":1,\"587\":3,\"591\":1,\"592\":7,\"688\":1,\"782\":1,\"783\":5,\"784\":3,\"801\":2,\"802\":2,\"803\":1,\"808\":1,\"874\":1,\"875\":1,\"876\":3,\"899\":1,\"900\":1,\"978\":1,\"992\":1,\"994\":1,\"1063\":1,\"1067\":1,\"1158\":3,\"1184\":1,\"1190\":1,\"1211\":1,\"1232\":5,\"1233\":3,\"1239\":2,\"1244\":1,\"1251\":2,\"1252\":1,\"1254\":1,\"1271\":1,\"1272\":1,\"1274\":5,\"1275\":1,\"1283\":8,\"1284\":4,\"1285\":2,\"1294\":1,\"1315\":2,\"1317\":1,\"1325\":2,\"1326\":1,\"1336\":2,\"1340\":3,\"1359\":1,\"1360\":1,\"1370\":1,\"1375\":1,\"1406\":1,\"1409\":2,\"1410\":2,\"1411\":2,\"1455\":2,\"1458\":3,\"1485\":1,\"1496\":8,\"1504\":2,\"1505\":2,\"1506\":2,\"1507\":2,\"1508\":3,\"1510\":2,\"1511\":1}}],[\"though\",{\"1\":{\"1351\":1}}],[\"that\",{\"1\":{\"1242\":1,\"1252\":1,\"1351\":1,\"1359\":2,\"1505\":1,\"1511\":2}}],[\"than\",{\"1\":{\"1191\":2,\"1275\":1,\"1306\":1,\"1314\":1,\"1359\":1}}],[\"these\",{\"1\":{\"1319\":1}}],[\"them\",{\"1\":{\"1317\":1}}],[\"their\",{\"1\":{\"1275\":1}}],[\"then\",{\"1\":{\"1239\":1,\"1317\":2,\"1359\":2}}],[\"they\",{\"1\":{\"1191\":1}}],[\"there\",{\"1\":{\"1149\":1,\"1275\":1,\"1317\":1,\"1350\":1,\"1359\":1,\"1511\":1}}],[\"the\",{\"1\":{\"1149\":2,\"1175\":2,\"1191\":4,\"1221\":1,\"1242\":1,\"1243\":1,\"1252\":2,\"1270\":1,\"1275\":5,\"1283\":2,\"1284\":1,\"1292\":1,\"1293\":1,\"1301\":1,\"1305\":2,\"1306\":6,\"1308\":1,\"1315\":4,\"1316\":4,\"1317\":11,\"1319\":1,\"1346\":3,\"1350\":3,\"1359\":5,\"1408\":2,\"1472\":1,\"1496\":4,\"1504\":1,\"1506\":2,\"1511\":1}}],[\"threalocalmap\",{\"1\":{\"1305\":1}}],[\"threadfactory\",{\"1\":{\"1359\":3,\"1366\":6}}],[\"threadfactorybuilder\",{\"1\":{\"1158\":3}}],[\"threadterminated\",{\"1\":{\"1319\":1}}],[\"threadref会断掉\",{\"1\":{\"1313\":1}}],[\"threadref\",{\"1\":{\"1313\":1}}],[\"threadloclmap\",{\"1\":{\"1299\":1}}],[\"threadlocaldemo\",{\"1\":{\"1309\":1}}],[\"threadlocalhashcode\",{\"1\":{\"1306\":5,\"1307\":1,\"1308\":1,\"1314\":1,\"1316\":1,\"1317\":1}}],[\"threadlocalinstance\",{\"1\":{\"1305\":1,\"1313\":1,\"1318\":1}}],[\"threadlocal各引用间的关系\",{\"1\":{\"1305\":1}}],[\"threadlocal<>\",{\"1\":{\"1309\":1}}],[\"threadlocal<simpledateformat>\",{\"1\":{\"1309\":1}}],[\"threadlocal<\",{\"1\":{\"1305\":1,\"1306\":4,\"1307\":3,\"1308\":1,\"1314\":2,\"1316\":1,\"1317\":5}}],[\"threadlocals\",{\"1\":{\"1301\":5,\"1305\":1,\"1319\":2}}],[\"threadlocalmap\",{\"0\":{\"1304\":1},\"1\":{\"1301\":17,\"1302\":5,\"1303\":2,\"1304\":3,\"1305\":8,\"1306\":10,\"1309\":2,\"1313\":5,\"1314\":1,\"1317\":2,\"1318\":2,\"1319\":2}}],[\"threadlocal\",{\"0\":{\"1298\":1,\"1299\":1,\"1300\":1,\"1309\":1,\"1312\":1,\"1320\":1},\"1\":{\"1299\":2,\"1300\":1,\"1301\":8,\"1302\":4,\"1303\":1,\"1304\":2,\"1305\":15,\"1306\":9,\"1309\":5,\"1313\":14,\"1314\":2,\"1317\":4,\"1318\":11,\"1320\":5}}],[\"threadlocalrandom\",{\"1\":{\"1275\":1}}],[\"thread0\",{\"1\":{\"1284\":1}}],[\"thread2\",{\"1\":{\"1284\":6}}],[\"thread1\",{\"1\":{\"1284\":7,\"1330\":2}}],[\"threads\",{\"1\":{\"1221\":1,\"1359\":2}}],[\"threadb\",{\"1\":{\"1221\":6,\"1337\":5,\"1406\":3,\"1421\":4}}],[\"threada\",{\"1\":{\"1221\":6,\"1337\":3,\"1406\":2}}],[\"threadpoolexecutor\",{\"0\":{\"1356\":1},\"1\":{\"1158\":2,\"1359\":7,\"1365\":1,\"1366\":3,\"1370\":2,\"1371\":8}}],[\"thread\",{\"0\":{\"1319\":1},\"1\":{\"1059\":11,\"1060\":1,\"1061\":1,\"1062\":5,\"1063\":4,\"1207\":1,\"1211\":1,\"1221\":15,\"1232\":3,\"1233\":2,\"1239\":4,\"1242\":5,\"1243\":2,\"1244\":1,\"1250\":8,\"1251\":3,\"1252\":2,\"1254\":8,\"1259\":4,\"1260\":13,\"1267\":1,\"1271\":2,\"1283\":1,\"1284\":6,\"1301\":9,\"1302\":5,\"1303\":1,\"1305\":4,\"1309\":1,\"1319\":1,\"1330\":9,\"1336\":6,\"1337\":22,\"1338\":2,\"1340\":7,\"1359\":4,\"1371\":1,\"1392\":23,\"1393\":14,\"1398\":46,\"1406\":18,\"1407\":24,\"1409\":33,\"1410\":37,\"1411\":38,\"1429\":5,\"1449\":5,\"1458\":8,\"1482\":5,\"1496\":8,\"1501\":2,\"1504\":1,\"1505\":2,\"1506\":3,\"1507\":1,\"1508\":2}}],[\"threaddeath\",{\"1\":{\"1042\":1}}],[\"threshold\",{\"1\":{\"1190\":1,\"1191\":2,\"1272\":3,\"1274\":2,\"1306\":8,\"1314\":1}}],[\"throwable\",{\"1\":{\"1046\":5,\"1274\":1}}],[\"throw\",{\"1\":{\"587\":1,\"1048\":3,\"1059\":3,\"1063\":1,\"1103\":1,\"1232\":2,\"1233\":1,\"1239\":1,\"1240\":1,\"1243\":1,\"1251\":3,\"1252\":1,\"1266\":1,\"1270\":1,\"1272\":1,\"1346\":1,\"1351\":1,\"1359\":1,\"1368\":1,\"1370\":1,\"1495\":1,\"1496\":1,\"1507\":2,\"1508\":2}}],[\"throwif\",{\"1\":{\"523\":3,\"525\":1,\"526\":7}}],[\"throwutils\",{\"1\":{\"523\":3,\"525\":1,\"526\":7}}],[\"throws\",{\"1\":{\"128\":1,\"157\":1,\"446\":4,\"481\":1,\"482\":1,\"981\":2,\"982\":2,\"1048\":2,\"1055\":1,\"1061\":1,\"1062\":2,\"1063\":1,\"1102\":4,\"1103\":6,\"1165\":1,\"1175\":1,\"1177\":1,\"1201\":1,\"1204\":1,\"1207\":1,\"1211\":1,\"1248\":3,\"1251\":1,\"1330\":1,\"1336\":1,\"1337\":1,\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1392\":2,\"1393\":2,\"1398\":3,\"1399\":2,\"1410\":3,\"1493\":2,\"1496\":3,\"1507\":2,\"1508\":2}}],[\"thursday\",{\"1\":{\"986\":1}}],[\"thundering\",{\"1\":{\"48\":1}}],[\"thymeleaf\",{\"1\":{\"634\":1}}],[\"this\",{\"1\":{\"103\":1,\"157\":1,\"255\":3,\"525\":2,\"687\":2,\"688\":1,\"710\":1,\"767\":1,\"803\":2,\"821\":1,\"870\":1,\"882\":1,\"1027\":4,\"1028\":3,\"1055\":1,\"1059\":1,\"1062\":2,\"1063\":3,\"1133\":2,\"1149\":1,\"1160\":4,\"1164\":1,\"1191\":2,\"1239\":2,\"1242\":1,\"1251\":4,\"1252\":1,\"1267\":1,\"1270\":1,\"1271\":1,\"1274\":2,\"1275\":4,\"1282\":3,\"1283\":1,\"1284\":1,\"1294\":1,\"1301\":4,\"1302\":2,\"1303\":1,\"1305\":1,\"1309\":2,\"1315\":3,\"1316\":2,\"1319\":1,\"1337\":1,\"1346\":1,\"1347\":2,\"1348\":2,\"1349\":1,\"1350\":2,\"1351\":4,\"1352\":2,\"1359\":1,\"1385\":2,\"1387\":2,\"1388\":2,\"1406\":4,\"1407\":4,\"1409\":3,\"1410\":5,\"1411\":2,\"1467\":2,\"1478\":2,\"1505\":2,\"1506\":1,\"1508\":1,\"1511\":2}}],[\"tool\",{\"0\":{\"1528\":1}}],[\"tonanos\",{\"1\":{\"1496\":1}}],[\"tony\",{\"1\":{\"181\":2}}],[\"tolowercase\",{\"1\":{\"1005\":1,\"1069\":1}}],[\"tolist\",{\"1\":{\"578\":1}}],[\"to=\",{\"1\":{\"588\":1}}],[\"todo\",{\"1\":{\"526\":2,\"575\":1,\"589\":1,\"596\":1,\"599\":1}}],[\"toset\",{\"1\":{\"525\":1}}],[\"tostring\",{\"1\":{\"82\":1,\"98\":1,\"128\":1,\"157\":1,\"161\":1,\"1002\":1,\"1014\":1,\"1018\":1,\"1027\":1,\"1028\":1,\"1029\":2,\"1046\":1,\"1067\":1,\"1070\":1,\"1082\":1,\"1387\":1,\"1388\":1,\"1467\":2}}],[\"toajax\",{\"1\":{\"481\":1,\"482\":1}}],[\"token\",{\"1\":{\"447\":1,\"451\":1,\"493\":1,\"500\":1}}],[\"token认证过滤器\",{\"1\":{\"446\":1}}],[\"tot\",{\"1\":{\"324\":3}}],[\"total\",{\"1\":{\"109\":8,\"142\":3,\"935\":2,\"1194\":1}}],[\"tomillis\",{\"1\":{\"1201\":1}}],[\"tomcat\",{\"1\":{\"574\":1}}],[\"tom\",{\"1\":{\"181\":2}}],[\"touppercase\",{\"1\":{\"98\":1,\"1005\":1,\"1069\":1}}],[\"tochararray\",{\"1\":{\"71\":1,\"98\":1,\"161\":1,\"180\":1,\"1005\":2,\"1069\":2}}],[\"topsort\",{\"1\":{\"349\":1}}],[\"top\",{\"1\":{\"93\":5,\"223\":2,\"224\":1,\"353\":1,\"422\":2,\"429\":1,\"857\":3}}],[\"topk\",{\"1\":{\"61\":2}}],[\"topic\",{\"1\":{\"48\":1,\"49\":1}}],[\"to\",{\"1\":{\"41\":2,\"110\":1,\"251\":2,\"567\":1,\"671\":3,\"875\":3,\"876\":2,\"922\":1,\"1074\":2,\"1191\":1,\"1221\":4,\"1242\":5,\"1243\":1,\"1252\":4,\"1259\":2,\"1267\":1,\"1272\":1,\"1274\":2,\"1283\":5,\"1284\":1,\"1293\":1,\"1301\":1,\"1306\":5,\"1314\":3,\"1315\":3,\"1316\":1,\"1317\":8,\"1351\":2,\"1359\":4,\"1496\":3,\"1504\":1,\"1505\":3,\"1506\":3,\"1511\":6}}],[\"t\",{\"1\":{\"41\":1,\"66\":4,\"88\":3,\"97\":5,\"110\":9,\"147\":5,\"156\":3,\"202\":2,\"203\":5,\"221\":3,\"223\":15,\"224\":5,\"235\":3,\"236\":2,\"237\":1,\"243\":3,\"252\":1,\"278\":5,\"279\":11,\"309\":4,\"327\":7,\"328\":11,\"329\":5,\"330\":9,\"348\":2,\"349\":2,\"352\":7,\"353\":3,\"355\":9,\"356\":6,\"360\":16,\"376\":4,\"380\":4,\"385\":5,\"390\":7,\"392\":8,\"417\":8,\"429\":4,\"753\":1,\"821\":3,\"852\":4,\"870\":3,\"876\":2,\"999\":2,\"1018\":2,\"1069\":1,\"1251\":6,\"1274\":4,\"1283\":40,\"1285\":3,\"1301\":12,\"1302\":11,\"1306\":1,\"1314\":1,\"1317\":1,\"1330\":1,\"1359\":1,\"1368\":3,\"1370\":3,\"1504\":7,\"1505\":1,\"1506\":7}}],[\"逗乐每一个在互联网里冲浪的有缘人\",{\"1\":{\"41\":1}}],[\"都到达了指定的临界点\",{\"1\":{\"1393\":1}}],[\"都调用它的\",{\"1\":{\"1320\":1}}],[\"都指向\",{\"1\":{\"1284\":1}}],[\"都分别指向初始化时创建的\",{\"1\":{\"1283\":1}}],[\"都拥有所属同步器的引用\",{\"1\":{\"1250\":1}}],[\"都有一个\",{\"1\":{\"1150\":1}}],[\"都有一行输出\",{\"1\":{\"274\":1}}],[\"都改掉\",{\"1\":{\"1147\":1}}],[\"都链接一个链表\",{\"1\":{\"971\":1}}],[\"都可以理解成维护的就是一个计数器\",{\"1\":{\"1394\":1}}],[\"都可以描述字符串\",{\"1\":{\"920\":1}}],[\"都可以是\",{\"1\":{\"422\":1}}],[\"都会有缓存\",{\"1\":{\"1417\":1}}],[\"都会继续往下执行\",{\"1\":{\"1392\":1}}],[\"都会继续执行后面的代码\",{\"1\":{\"1223\":1}}],[\"都会针对\",{\"1\":{\"1318\":1}}],[\"都会通过\",{\"1\":{\"1317\":1}}],[\"都会被阻塞住\",{\"1\":{\"1447\":1}}],[\"都会被回收掉\",{\"1\":{\"1313\":1}}],[\"都会被写入到同一个日志文件中\",{\"1\":{\"1087\":1}}],[\"都会被写入到这个日志文件中\",{\"1\":{\"1087\":1}}],[\"都会被重新标记为\",{\"1\":{\"821\":1}}],[\"都会影响到彼此对方\",{\"1\":{\"1072\":1}}],[\"都会输掉游戏\",{\"1\":{\"394\":1}}],[\"都要用\",{\"1\":{\"820\":1}}],[\"都为空指针返回\",{\"1\":{\"808\":1}}],[\"都表示从前\",{\"1\":{\"796\":1}}],[\"都必须在开头显示编写\",{\"1\":{\"545\":1}}],[\"都支持\",{\"1\":{\"542\":1}}],[\"都存储在内存中\",{\"1\":{\"484\":1}}],[\"都在湖边建好了\",{\"1\":{\"438\":1}}],[\"都采取最优策略行动时游戏的结果\",{\"1\":{\"394\":1}}],[\"都采用删除缓存而非直接更新的方式\",{\"1\":{\"31\":1}}],[\"都加上第一段符合的个数即可\",{\"1\":{\"262\":1}}],[\"都符合条件\",{\"1\":{\"262\":1}}],[\"都一定是\",{\"1\":{\"248\":1,\"383\":1}}],[\"都是初始状态\",{\"1\":{\"1456\":1}}],[\"都是为了在不改变程序执行结果的前提下\",{\"1\":{\"1420\":1}}],[\"都是用于控制并发的工具类\",{\"1\":{\"1394\":1}}],[\"都是先将任务移入到阻塞队列中\",{\"1\":{\"1371\":1}}],[\"都是通过\",{\"1\":{\"1353\":1}}],[\"都是实现了一个接口\",{\"1\":{\"1153\":1}}],[\"都是空的\",{\"1\":{\"1150\":1}}],[\"都是指默认的\",{\"1\":{\"958\":1}}],[\"都是使用逻辑外键\",{\"1\":{\"937\":1}}],[\"都是一样的\",{\"1\":{\"887\":1}}],[\"都是挺不错的选择\",{\"1\":{\"661\":1}}],[\"都是主流的静态网站生成器\",{\"1\":{\"534\":1}}],[\"都是拿数据为业务服务\",{\"1\":{\"438\":1}}],[\"都是由男孩子指向女孩子\",{\"1\":{\"363\":1}}],[\"都是上下左右四个方向\",{\"1\":{\"228\":1}}],[\"都是完全平方数\",{\"1\":{\"115\":1,\"794\":1}}],[\"都非常简单\",{\"1\":{\"86\":1}}],[\"都具有非常强的头部效应\",{\"1\":{\"41\":1}}],[\"愿景与规划\",{\"0\":{\"41\":1}}],[\"支付宝解放了大家去钱包找钱的过程\",{\"1\":{\"1434\":1}}],[\"支笔\",{\"1\":{\"1313\":1,\"1398\":1}}],[\"支撑ai模型的快速部署快速迭代\",{\"1\":{\"40\":1}}],[\"支持自定义时间单位\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"支持可重复加锁\",{\"1\":{\"1239\":1}}],[\"支持重入\",{\"1\":{\"1237\":1}}],[\"支持重入性\",{\"1\":{\"1231\":1}}],[\"支持非公平性\",{\"1\":{\"1237\":1}}],[\"支持两种锁\",{\"1\":{\"1233\":1}}],[\"支持两种过期删除策略\",{\"1\":{\"1202\":1}}],[\"支持简单的统计功能\",{\"1\":{\"1202\":1}}],[\"支持最大容量限制\",{\"1\":{\"1202\":1}}],[\"支持很多特性如下\",{\"1\":{\"1202\":1}}],[\"支持多线程\",{\"1\":{\"1100\":1}}],[\"支持市面主流的开发语言并且可以通过\",{\"1\":{\"1095\":1}}],[\"支持全面\",{\"1\":{\"1095\":1}}],[\"支持全局根布局\",{\"1\":{\"547\":1}}],[\"支持从小到大或者从大到小查找\",{\"1\":{\"958\":1}}],[\"支持\",{\"1\":{\"669\":1}}],[\"支持分析报表\",{\"1\":{\"634\":2}}],[\"支持更多字段\",{\"1\":{\"599\":1}}],[\"支持比较运算\",{\"1\":{\"422\":2}}],[\"支持回复楼层\",{\"1\":{\"45\":1}}],[\"支持排序策略的叠加\",{\"1\":{\"40\":1}}],[\"支持入口层切流\",{\"1\":{\"34\":1}}],[\"支持无限盖楼回复\",{\"1\":{\"22\":1}}],[\"既然是旧的了\",{\"1\":{\"1456\":1}}],[\"既然每次只能通过一个\",{\"1\":{\"1434\":1}}],[\"既然不会出现冲突自然而然就不会阻塞其他线程的操作\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"既然我们说到要进行优化\",{\"1\":{\"1291\":1}}],[\"既能节省存储成本\",{\"1\":{\"1094\":1}}],[\"既实现\",{\"1\":{\"1076\":1}}],[\"既要能找到对应的节点\",{\"1\":{\"802\":1}}],[\"既可以将文件存储在本地\",{\"1\":{\"669\":1}}],[\"既可以直接操纵湖内数据\",{\"1\":{\"438\":1}}],[\"既有平地也有山脉\",{\"1\":{\"213\":1}}],[\"既支持传统的静态的经验算分公式\",{\"1\":{\"40\":1}}],[\"既包括类似\",{\"1\":{\"39\":1}}],[\"拦截了大部分低价值重排请求\",{\"1\":{\"40\":1}}],[\"活跃程度等\",{\"1\":{\"40\":1}}],[\"活动或表演\",{\"1\":{\"21\":1}}],[\"根\",{\"1\":{\"724\":1}}],[\"根节点为\",{\"1\":{\"766\":1}}],[\"根节点\",{\"1\":{\"766\":4}}],[\"根节点root\",{\"1\":{\"735\":1}}],[\"根节点小于等于左右两个子节点\",{\"1\":{\"417\":1}}],[\"根节点相同\",{\"1\":{\"187\":1}}],[\"根据超时时间和当前时间计算出截止时间\",{\"1\":{\"1508\":1}}],[\"根据重排序规则\",{\"1\":{\"1475\":1}}],[\"根据输出结果进行分析\",{\"1\":{\"1398\":1}}],[\"根据索引i获取entry\",{\"1\":{\"1307\":1}}],[\"根据源码可知\",{\"1\":{\"1306\":1}}],[\"根据threadlocal的hashcode确定entry应该存放的位置\",{\"1\":{\"1306\":1}}],[\"根据可达性分析\",{\"1\":{\"1305\":1}}],[\"根据上面我们的分析\",{\"1\":{\"1284\":1}}],[\"根据上述逻辑写代码即可\",{\"1\":{\"687\":1}}],[\"根据在临界点时\",{\"1\":{\"1283\":1}}],[\"根据运算得到当前遍历的数组的位置\",{\"1\":{\"1274\":1}}],[\"根据当前获得同步状态成功与否做了两件事情\",{\"1\":{\"1503\":1}}],[\"根据当前节点个数进行调整\",{\"1\":{\"1272\":1}}],[\"根据当前字符获取对应的子节点\",{\"1\":{\"803\":1}}],[\"根据是否初始化和是否正在扩容有几种情况\",{\"1\":{\"1266\":1}}],[\"根据公平性\",{\"1\":{\"1233\":1}}],[\"根据计算树的高度大概是\",{\"1\":{\"958\":1}}],[\"根据子查询结果的不同分为\",{\"1\":{\"947\":1}}],[\"根据业务功能的实现\",{\"1\":{\"910\":1}}],[\"根据题意可知中序遍历得到的序列一定是升序的\",{\"1\":{\"900\":1}}],[\"根据题库查询题目id列表\",{\"1\":{\"525\":1}}],[\"根据题库\",{\"1\":{\"521\":1,\"523\":1,\"525\":1,\"526\":1}}],[\"根据分治思想\",{\"1\":{\"766\":1}}],[\"根据中序遍历中的左\",{\"1\":{\"766\":1}}],[\"根据以上性质\",{\"1\":{\"766\":1}}],[\"根据id获取到用户信息\",{\"1\":{\"589\":1}}],[\"根据数据库表结构自动生成代码\",{\"1\":{\"567\":1}}],[\"根据文件夹的名称和嵌套层级\",{\"1\":{\"542\":1}}],[\"根据文件夹的结构和名称\",{\"1\":{\"542\":1}}],[\"根据请求的路由和数据\",{\"1\":{\"533\":1}}],[\"根据实际需求调整\",{\"1\":{\"523\":1}}],[\"根据核心业务业务流程\",{\"1\":{\"506\":1}}],[\"根据任务id查询数据库\",{\"1\":{\"482\":1}}],[\"根据用户\",{\"1\":{\"462\":1}}],[\"根据两者的特点\",{\"1\":{\"438\":1}}],[\"根据具体问题\",{\"1\":{\"416\":1}}],[\"根据容斥原理\",{\"1\":{\"392\":1}}],[\"根据\",{\"1\":{\"139\":1,\"521\":2,\"523\":2,\"525\":1,\"670\":1,\"1239\":1,\"1294\":1,\"1430\":1,\"1432\":1}}],[\"根据价格之和\",{\"1\":{\"109\":1}}],[\"根据房主的回答来验证每个可能的网吧位置是否符合已知的距离信息\",{\"1\":{\"108\":1}}],[\"根据评论区的评论数\",{\"1\":{\"40\":1}}],[\"根木桩的长度\",{\"1\":{\"78\":1}}],[\"根木桩的长度为\",{\"1\":{\"78\":1}}],[\"根木桩排成一列\",{\"1\":{\"78\":1}}],[\"根评论数\",{\"1\":{\"30\":1}}],[\"近实时大窗口聚合计数等多种性能优化手段\",{\"1\":{\"40\":1}}],[\"各个线程会将共享变量从主内存中拷贝到工作内存\",{\"1\":{\"1453\":1}}],[\"各个组件\",{\"0\":{\"1134\":1}}],[\"各引用间的关系\",{\"1\":{\"1313\":1}}],[\"各用各的互不影响\",{\"1\":{\"1313\":1}}],[\"各用各的这样就可以避免共享资源的竞争\",{\"1\":{\"1299\":1}}],[\"各自使用各自的\",{\"1\":{\"1299\":1}}],[\"各种锁的比较\",{\"0\":{\"1448\":1}}],[\"各种视频\",{\"1\":{\"1093\":1}}],[\"各种图片\",{\"1\":{\"1093\":1}}],[\"各种应用都可以连接到它\",{\"1\":{\"674\":1}}],[\"各种功能\",{\"1\":{\"446\":1}}],[\"各编译器处理方法不一样\",{\"1\":{\"337\":1}}],[\"各二进位全部右移若干位\",{\"1\":{\"337\":1}}],[\"各二进位全部左移若干位\",{\"1\":{\"337\":1}}],[\"各行\",{\"1\":{\"287\":1}}],[\"各类静态模型分存在4到5层冗余\",{\"1\":{\"40\":1}}],[\"各级缓存可能有功能上的略微差异\",{\"1\":{\"34\":1}}],[\"受限于成本并未持久化\",{\"1\":{\"40\":1}}],[\"举一个小例子\",{\"1\":{\"1471\":1}}],[\"举一个很通俗的例子\",{\"1\":{\"1392\":1}}],[\"举个简单的例子\",{\"1\":{\"1131\":1}}],[\"举个例子\",{\"1\":{\"40\":1,\"1495\":1}}],[\"举例来说\",{\"1\":{\"1496\":1}}],[\"举例\",{\"1\":{\"586\":1,\"978\":1}}],[\"举报等\",{\"1\":{\"22\":1}}],[\"所示\",{\"1\":{\"1495\":1}}],[\"所修饰的\",{\"1\":{\"1469\":1}}],[\"所读取到的\",{\"1\":{\"1432\":1}}],[\"所重写的\",{\"1\":{\"1370\":1}}],[\"所维护的\",{\"1\":{\"1301\":1}}],[\"所依赖对象的获取被反转了\",{\"1\":{\"1129\":1}}],[\"所依赖的对象直接由\",{\"1\":{\"1129\":1}}],[\"所查询到的数据列表\",{\"1\":{\"935\":1}}],[\"所使用的账号与\",{\"1\":{\"675\":1}}],[\"所含匹配边数最多的匹配\",{\"1\":{\"363\":1}}],[\"所得即为商在这一位的数字\",{\"1\":{\"330\":1}}],[\"所在的目录\",{\"1\":{\"1089\":1}}],[\"所在的集合合并\",{\"1\":{\"274\":1}}],[\"所在目录下启动\",{\"1\":{\"1087\":1}}],[\"所在树的根节点下面\",{\"1\":{\"271\":1}}],[\"所在树的根节点接到\",{\"1\":{\"271\":1}}],[\"所谓生产者\",{\"1\":{\"1402\":1}}],[\"所谓数据延时期满\",{\"1\":{\"1326\":1}}],[\"所谓公平性是指严格按照线程等待的绝对时间顺序\",{\"1\":{\"1326\":1}}],[\"所谓约束就是作用在表中字段上的规则\",{\"1\":{\"919\":1}}],[\"所谓二叉树的直径\",{\"1\":{\"760\":1}}],[\"所谓的全局通用布局\",{\"1\":{\"547\":1}}],[\"所谓采取最优策略是指\",{\"1\":{\"394\":1}}],[\"所谓缺口迷宫\",{\"1\":{\"237\":1}}],[\"所谓\",{\"1\":{\"229\":1,\"1129\":1,\"1131\":1}}],[\"所谓架构上的补充\",{\"1\":{\"28\":1}}],[\"所需的操作次数\",{\"1\":{\"167\":1}}],[\"所需要的最小操作次数\",{\"1\":{\"120\":1}}],[\"所有线程均可访问到\",{\"1\":{\"1416\":1}}],[\"所有运动员入场\",{\"1\":{\"1393\":2}}],[\"所有运动员到达终点\",{\"1\":{\"1392\":2}}],[\"所有现代桌面和服务器操作系统都是用抢占式调度\",{\"1\":{\"1331\":1}}],[\"所有传入\",{\"1\":{\"1284\":1}}],[\"所有要想能够彻底弄懂\",{\"1\":{\"1283\":1}}],[\"所有counter的值求和\",{\"1\":{\"1275\":1}}],[\"所有调用\",{\"1\":{\"1250\":1}}],[\"所有获取锁失败的线程的尾插入到同步队列\",{\"1\":{\"1250\":1}}],[\"所有普通成员变量\",{\"1\":{\"1027\":1}}],[\"所有\",{\"1\":{\"1027\":1}}],[\"所有对象均可以访问\",{\"1\":{\"1027\":1}}],[\"所有具有相同哈希值的元素都存储在这个链表中\",{\"1\":{\"971\":1}}],[\"所有左子树和右子树自身必须也是二叉搜索树\",{\"1\":{\"898\":1}}],[\"所有页面都以静态文件的形式存在\",{\"1\":{\"534\":1}}],[\"所有字段\",{\"1\":{\"525\":1}}],[\"所有节点均不为空\",{\"1\":{\"417\":1}}],[\"所有数的个数为各个集合的并集\",{\"1\":{\"392\":1}}],[\"所有边\",{\"1\":{\"354\":1,\"362\":1}}],[\"所有边权都是正数\",{\"1\":{\"351\":1}}],[\"所有将a\",{\"1\":{\"306\":1}}],[\"所有测试点满足\",{\"1\":{\"262\":1}}],[\"所有的操作都是无序的\",{\"1\":{\"1485\":1}}],[\"所有的操作都是有序的\",{\"1\":{\"1485\":1}}],[\"所有的读线程只是会读取数据容器中的数据\",{\"1\":{\"1293\":1}}],[\"所有的读线程和其他的写线程都会被阻塞\",{\"1\":{\"1237\":1}}],[\"所有的线程都会尝试地往前运行\",{\"1\":{\"1225\":1}}],[\"所有的类的创建\",{\"1\":{\"1131\":1}}],[\"所有的类都会在\",{\"1\":{\"1131\":1}}],[\"所有的数据都存储在叶子节点上\",{\"1\":{\"958\":2}}],[\"所有的\",{\"1\":{\"953\":1}}],[\"所有的任务数据就会丢失\",{\"1\":{\"484\":1}}],[\"所有的顶点都是匹配点\",{\"1\":{\"363\":1}}],[\"所有的区间\",{\"1\":{\"307\":1}}],[\"所有的邻近节点\",{\"1\":{\"215\":1}}],[\"所有的元素到剪接到要操作的\",{\"1\":{\"200\":1}}],[\"所有的因子可以构成一个有向无环图\",{\"1\":{\"40\":1}}],[\"所有等于\",{\"1\":{\"178\":1}}],[\"所有元素初始化为\",{\"1\":{\"128\":1}}],[\"所有单词的首字母大写\",{\"1\":{\"98\":1}}],[\"所有单元格都是白色\",{\"1\":{\"77\":1}}],[\"所有计算过程中都需要对\",{\"1\":{\"72\":1}}],[\"所能获得的最大得分\",{\"1\":{\"71\":1}}],[\"所以自然要使用优先级队列\",{\"1\":{\"1369\":1}}],[\"所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的\",{\"1\":{\"1369\":1}}],[\"所以将释放资源等操作不要放在\",{\"1\":{\"1340\":1}}],[\"所以为了一次处理到位\",{\"1\":{\"1317\":1}}],[\"所以为了减少红黑树的高度\",{\"1\":{\"958\":1}}],[\"所以哈希表可用大小为\",{\"1\":{\"1306\":1}}],[\"所以相与等同于一个取模的过程\",{\"1\":{\"1306\":1}}],[\"所以如果你希望写入的的数据\",{\"1\":{\"1295\":1}}],[\"所以如果仅使用读写锁对\",{\"1\":{\"1290\":1}}],[\"所以输出结果为\",{\"1\":{\"1284\":1}}],[\"所以就需要从\",{\"1\":{\"1284\":1}}],[\"所以等待队列的头节点必然会是等待时间最长的节点\",{\"1\":{\"1252\":1}}],[\"所以访问的速度非常快\",{\"1\":{\"1200\":1}}],[\"所以它是\",{\"1\":{\"1140\":1}}],[\"所以这种延迟更新的策略就被叫做\",{\"1\":{\"1286\":1}}],[\"所以这个类的名字起得不太好\",{\"1\":{\"1184\":1}}],[\"所以这叫控制反转\",{\"1\":{\"1131\":1}}],[\"所以这里只用存一个方向的边\",{\"1\":{\"363\":1}}],[\"所以是反转\",{\"1\":{\"1129\":1}}],[\"所以是乘\",{\"1\":{\"389\":1}}],[\"所以接下来讲解\",{\"1\":{\"1107\":1}}],[\"所以接下来对此功能的源码进行分析\",{\"1\":{\"482\":1}}],[\"所以基于对象的形式\",{\"1\":{\"1094\":1}}],[\"所以此时对形参的修改会影响实参的初始值\",{\"1\":{\"1018\":1}}],[\"所以此时应该退出循环\",{\"1\":{\"373\":1}}],[\"所以该操作等价于fact\",{\"1\":{\"1012\":1}}],[\"所以一个第三层一个节点大概可以存储\",{\"1\":{\"958\":1}}],[\"所以一直更新根就行了\",{\"1\":{\"314\":1}}],[\"所以各个表结构之间也存在着各种联系\",{\"1\":{\"936\":1}}],[\"所以初始化范围还要更大些\",{\"1\":{\"899\":1}}],[\"所以初始化为无穷大\",{\"1\":{\"312\":1}}],[\"所以完全可以只使用两个数组\",{\"1\":{\"894\":1}}],[\"所以不能将新值\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"所以不可能完成所有课程\",{\"1\":{\"875\":1}}],[\"所以不需要session\",{\"1\":{\"446\":1}}],[\"所以最后要返回\",{\"1\":{\"869\":1}}],[\"所以每次扩散需要考虑每一层\",{\"1\":{\"869\":1}}],[\"所以每个组件都比较大\",{\"1\":{\"540\":1}}],[\"所以只需要知道下标\",{\"1\":{\"851\":1}}],[\"所以只需要计算出这个周期\",{\"1\":{\"139\":1}}],[\"所以只要把经过的位置都设置为\",{\"1\":{\"820\":1}}],[\"所以选择序列的中间值作为根节点\",{\"1\":{\"814\":1}}],[\"所以递归入口为\",{\"1\":{\"795\":1}}],[\"所以本题等同于根据中序遍历的序列建立二叉搜索树\",{\"1\":{\"814\":1}}],[\"所以本题是一道标准的完全背包问题\",{\"1\":{\"795\":1}}],[\"所以本题中非\",{\"1\":{\"772\":1}}],[\"所以循环条件为\",{\"1\":{\"777\":1}}],[\"所以当其他线程尝试竞争偏向锁时\",{\"1\":{\"1443\":1}}],[\"所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"所以当\",{\"1\":{\"772\":1}}],[\"所以结合二者的长处\",{\"1\":{\"687\":1}}],[\"所以用的国外服务器配置很一般\",{\"1\":{\"665\":1}}],[\"所以先在后端添加获取当前登录用户信息的接口\",{\"1\":{\"589\":1}}],[\"所以先预处理好\",{\"1\":{\"372\":1}}],[\"所以实在不行可以跳过\",{\"1\":{\"559\":1}}],[\"所以可以缩小比较范围\",{\"1\":{\"899\":1}}],[\"所以可以优化为每次只搜\",{\"1\":{\"822\":1}}],[\"所以可以在\",{\"1\":{\"525\":1}}],[\"所以可以用str\",{\"1\":{\"412\":1}}],[\"所以在进行写操作的时候\",{\"1\":{\"1295\":1}}],[\"所以在开发的时候需要注意一下\",{\"1\":{\"1295\":1}}],[\"所以在\",{\"1\":{\"1220\":1,\"1477\":1}}],[\"所以在查询时\",{\"1\":{\"525\":1}}],[\"所以在回源的逻辑里\",{\"1\":{\"48\":1}}],[\"所以直接采用硬删除的方式\",{\"1\":{\"513\":1}}],[\"所以直接每次新增评论的时候就把相应字段\",{\"1\":{\"56\":1}}],[\"所以使用\",{\"1\":{\"512\":1,\"766\":1}}],[\"所以添加索引提升查询性能\",{\"1\":{\"512\":1}}],[\"所以给\",{\"1\":{\"511\":1}}],[\"所以采用集群模式不会产生额外的成本\",{\"1\":{\"484\":1}}],[\"所以数据仓库通过\",{\"1\":{\"436\":1}}],[\"所以idx从2开始\",{\"1\":{\"404\":1}}],[\"所以有两份对象内存\",{\"1\":{\"1295\":1}}],[\"所以有\",{\"1\":{\"383\":1}}],[\"所以存边的时候\",{\"1\":{\"363\":1}}],[\"所以存在环\",{\"1\":{\"356\":1}}],[\"所以需要进行修改\",{\"1\":{\"587\":1}}],[\"所以需要将\",{\"1\":{\"671\":1}}],[\"所以需要将用户的各种状态抽出来封装为常量\",{\"1\":{\"580\":1}}],[\"所以需要将其翻转\",{\"1\":{\"330\":1}}],[\"所以需要在配置文件中关闭\",{\"1\":{\"567\":1}}],[\"所以需要开发\",{\"1\":{\"526\":1}}],[\"所以需要使用\",{\"1\":{\"525\":1}}],[\"所以需要使用标记数组\",{\"1\":{\"235\":1}}],[\"所以需要关联表来实现\",{\"1\":{\"513\":1}}],[\"所以从后遍历\",{\"1\":{\"328\":1}}],[\"所以f\",{\"1\":{\"312\":1}}],[\"所以他们想知道\",{\"1\":{\"290\":1}}],[\"所以要复杂的多\",{\"1\":{\"1274\":1}}],[\"所以要用一个\",{\"1\":{\"875\":1}}],[\"所以要减一\",{\"1\":{\"840\":1}}],[\"所以要移动到该结点的前一个才能删除\",{\"1\":{\"777\":1}}],[\"所以要\",{\"1\":{\"261\":1}}],[\"所以我们可以知道\",{\"1\":{\"1150\":1}}],[\"所以我们可以先将地图边界的陆地\",{\"1\":{\"229\":1}}],[\"所以我们在遍历的时候实时检查当前节点的值是否大于前一个遍历到的节点的值即可\",{\"1\":{\"900\":1}}],[\"所以我们提供方便友好的\",{\"1\":{\"475\":1}}],[\"所以我们需要特别处理\",{\"1\":{\"182\":1}}],[\"所以常常定义字符数组\",{\"1\":{\"228\":1}}],[\"所以想请你实现排行榜主要业务逻辑\",{\"1\":{\"129\":1}}],[\"所以被当作无效\",{\"1\":{\"109\":1}}],[\"所以所有房间都可能为网吧\",{\"1\":{\"108\":1}}],[\"所以还需要\",{\"1\":{\"66\":1}}],[\"所以平台扩展的能力\",{\"1\":{\"51\":1}}],[\"所以\",{\"1\":{\"49\":1,\"152\":1,\"243\":1,\"373\":1,\"383\":1,\"438\":1,\"539\":1,\"795\":1,\"828\":1,\"846\":2,\"875\":1,\"1129\":2,\"1133\":1,\"1220\":1,\"1221\":1,\"1286\":1,\"1291\":1,\"1305\":1,\"1306\":1,\"1313\":1,\"1320\":1,\"1369\":1,\"1392\":1,\"1454\":1,\"1477\":1,\"1501\":1}}],[\"所以缓存会超前加载\",{\"1\":{\"48\":1}}],[\"所具备的商业化价值也是需要持续探索的\",{\"1\":{\"41\":1}}],[\"召回和排序两阶段都需要查询因子\",{\"1\":{\"40\":1}}],[\"召回处理中心\",{\"1\":{\"40\":1}}],[\"召回策略的工程设计\",{\"1\":{\"40\":1}}],[\"召回一批应该沉底的不良评论或者应该进前排的优秀评论\",{\"1\":{\"40\":1}}],[\"负载因子\",{\"1\":{\"973\":1}}],[\"负载因子的调整\",{\"1\":{\"973\":1}}],[\"负载均衡\",{\"1\":{\"484\":1}}],[\"负载压力大\",{\"1\":{\"484\":1}}],[\"负责同步状态的管理\",{\"1\":{\"1495\":1}}],[\"负责启动\",{\"1\":{\"479\":1}}],[\"负责接收前端发来的请求\",{\"1\":{\"458\":1}}],[\"负责接收前端的请求\",{\"1\":{\"447\":1}}],[\"负责实现用户登录界面和交互逻辑\",{\"1\":{\"447\":1}}],[\"负责建立一套热评调控体系化能力\",{\"1\":{\"40\":1}}],[\"负数表示小于\",{\"1\":{\"1005\":1}}],[\"负数左补\",{\"1\":{\"338\":1}}],[\"负数按补码形式参加按位与运算\",{\"1\":{\"338\":1}}],[\"负数变正数\",{\"1\":{\"104\":1}}],[\"负反馈数\",{\"1\":{\"39\":1}}],[\"图可以看出\",{\"1\":{\"1365\":1}}],[\"图如下\",{\"1\":{\"1365\":1}}],[\"图像数据\",{\"1\":{\"1093\":1}}],[\"图中每一个箭头两个节点就代码一个\",{\"1\":{\"1455\":1}}],[\"图中共有\",{\"1\":{\"875\":1}}],[\"图中有一个唯一的起点\",{\"1\":{\"396\":1}}],[\"图\",{\"1\":{\"820\":2}}],[\"图片摘自网络\",{\"1\":{\"1274\":1}}],[\"图片\",{\"1\":{\"434\":1,\"511\":2}}],[\"图的拓扑序列是针对于有向图而言的\",{\"1\":{\"349\":1}}],[\"图论\",{\"2\":{\"226\":1,\"232\":1,\"239\":1,\"364\":1,\"804\":1,\"823\":1,\"871\":1,\"877\":1}}],[\"图形中相邻节点之间的移动代价并不相等\",{\"1\":{\"213\":1}}],[\"图示的\",{\"1\":{\"40\":1}}],[\"图书\",{\"1\":{\"21\":1}}],[\"目的是为了提高获得锁和释放锁的效率\",{\"1\":{\"1440\":1}}],[\"目的\",{\"1\":{\"598\":1}}],[\"目前为止了解即可\",{\"1\":{\"1282\":1}}],[\"目前显示了一个\",{\"1\":{\"1193\":1}}],[\"目前悟空我的机器上显示的\",{\"1\":{\"1190\":2}}],[\"目前负数没有与之对应的字符\",{\"1\":{\"1004\":1}}],[\"目前能跑通即可\",{\"1\":{\"518\":1,\"519\":1}}],[\"目前\",{\"1\":{\"434\":1,\"470\":1,\"1095\":1}}],[\"目前形成的系统架构总体如下图所示\",{\"1\":{\"40\":1}}],[\"目标\",{\"1\":{\"506\":1,\"840\":1}}],[\"目标字符串不在白名单内\",{\"1\":{\"481\":1}}],[\"目标字符串不允许\",{\"1\":{\"481\":3}}],[\"目标字符串存在违规\",{\"1\":{\"481\":1}}],[\"目标和\",{\"1\":{\"126\":1}}],[\"目标是找到最少的物品数量使得它们的和等于\",{\"1\":{\"115\":1}}],[\"目录下引用\",{\"1\":{\"549\":1}}],[\"目录下\",{\"1\":{\"543\":2,\"544\":2,\"672\":1}}],[\"目录下存放静态资源\",{\"1\":{\"543\":1}}],[\"目录作为根路径\",{\"1\":{\"542\":1}}],[\"目录结构\",{\"0\":{\"477\":1}}],[\"目录\",{\"0\":{\"8\":1},\"1\":{\"543\":1,\"548\":1,\"549\":1}}],[\"保持不变\",{\"1\":{\"1316\":1}}],[\"保护数据免受硬件故障和无声数据损坏\",{\"1\":{\"1095\":1}}],[\"保护你的代理服务器\",{\"0\":{\"664\":1}}],[\"保护敏感信息\",{\"1\":{\"470\":1}}],[\"保存数据时\",{\"1\":{\"919\":1}}],[\"保存右半部分的头结点\",{\"1\":{\"833\":1}}],[\"保存计算结果\",{\"1\":{\"827\":1}}],[\"保存出现过的\",{\"1\":{\"784\":1}}],[\"保存到浏览器内\",{\"1\":{\"575\":1}}],[\"保存节点信息\",{\"1\":{\"314\":1}}],[\"保障个人隐私和数据隔离\",{\"1\":{\"470\":1}}],[\"保障用户的热评浏览体验\",{\"1\":{\"40\":1}}],[\"保证原子性\",{\"1\":{\"1482\":1}}],[\"保证每个线程都是操作的最新值\",{\"1\":{\"1449\":1}}],[\"保证每往下遍历新一层时\",{\"1\":{\"736\":1}}],[\"保证至少有一个线程启动\",{\"1\":{\"1370\":1}}],[\"保证同一时刻只有一个写线程正在进行数组的复制\",{\"1\":{\"1294\":1}}],[\"保证写线程在同一时刻只有一个\",{\"1\":{\"1294\":1}}],[\"保证读读之间在任何时候都不会被阻塞\",{\"1\":{\"1290\":1}}],[\"保证用到的是最新的\",{\"1\":{\"1284\":1}}],[\"保证只有一个线程正在进行初始化操作\",{\"1\":{\"1271\":1}}],[\"保证了系统更大的吞吐量\",{\"1\":{\"1233\":1}}],[\"保证了即使在最坏的情况\",{\"1\":{\"1095\":1}}],[\"保证请求资源时间上的绝对顺序\",{\"1\":{\"1233\":1}}],[\"保证可见性\",{\"1\":{\"1145\":1}}],[\"保证元素添加顺序\",{\"1\":{\"1073\":1}}],[\"保证事务在不受外部并发操作影响的独立环境下运行\",{\"1\":{\"955\":1}}],[\"保证数据的一致性和完整性\",{\"1\":{\"919\":1,\"937\":1}}],[\"保证字段的所有数据都是唯一\",{\"1\":{\"919\":1}}],[\"保证字符串的开头与结尾字符不为空格\",{\"1\":{\"172\":1}}],[\"保证在一个事务中多次操作数据库表中数据时\",{\"1\":{\"953\":1}}],[\"保证在\",{\"1\":{\"777\":1}}],[\"保证首次遍历的一定是最右边的节点\",{\"1\":{\"736\":1}}],[\"保证初始值足够大\",{\"1\":{\"236\":1,\"237\":1}}],[\"保证到达时间互不相同\",{\"1\":{\"205\":1}}],[\"保证左上角和右下角都是道路且没有怪物\",{\"1\":{\"180\":1}}],[\"保证输入是合法的\",{\"1\":{\"180\":1}}],[\"保证仅有一个数满足要求\",{\"1\":{\"179\":1}}],[\"保证花朵数量最多的花卉被放置到最多覆盖的位置\",{\"1\":{\"141\":1}}],[\"保证节点权值在\",{\"1\":{\"134\":1}}],[\"保证\",{\"1\":{\"103\":1,\"1340\":1,\"1511\":1}}],[\"保证答案存在\",{\"1\":{\"78\":1}}],[\"保证对同一个\",{\"1\":{\"31\":1}}],[\"保证单个评论区和单个评论的更新操作是串行的\",{\"1\":{\"31\":1}}],[\"保证少数弱依赖抖动甚至完全不可用情况下评论服务可用\",{\"1\":{\"25\":1}}],[\"多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的\",{\"1\":{\"1286\":1}}],[\"多核的\",{\"1\":{\"1218\":1}}],[\"多租户支持\",{\"1\":{\"1095\":1}}],[\"多租户架构\",{\"1\":{\"639\":1}}],[\"多线程中你真的了解\",{\"0\":{\"1473\":1}}],[\"多线程中消息通知机制最常用的是\",{\"1\":{\"1345\":1}}],[\"多线程就不能发挥优势\",{\"1\":{\"1429\":1}}],[\"多线程情况下可能会出现哪些问题\",{\"1\":{\"1422\":1}}],[\"多线程执行情况分析\",{\"1\":{\"1284\":1}}],[\"多线程执行角度分析\",{\"1\":{\"1283\":1}}],[\"多线程分析方式\",{\"1\":{\"1283\":1}}],[\"多线程编程中最难以把握的就是临界区线程安全问题\",{\"1\":{\"1221\":1}}],[\"多线程技术有这么多的好处\",{\"1\":{\"1219\":1}}],[\"多线程\",{\"0\":{\"1058\":1}}],[\"多线程与锁\",{\"0\":{\"1057\":1}}],[\"多态\",{\"1\":{\"1029\":1}}],[\"多维数组就是数组的数组\",{\"1\":{\"1000\":1}}],[\"多维数组\",{\"0\":{\"1000\":1}}],[\"多层循环\",{\"0\":{\"994\":1}}],[\"多路平衡搜索树\",{\"1\":{\"958\":1}}],[\"多表查询时给表起别名\",{\"1\":{\"944\":1}}],[\"多表查询可以分为\",{\"1\":{\"943\":1}}],[\"多表查询\",{\"0\":{\"940\":1},\"1\":{\"942\":2}}],[\"多表设计\",{\"0\":{\"936\":1}}],[\"多对多的关系在开发中属于也比较常见的\",{\"1\":{\"939\":1}}],[\"多对多\",{\"0\":{\"939\":1},\"1\":{\"936\":1}}],[\"多对一\",{\"1\":{\"936\":1}}],[\"多选一\",{\"1\":{\"931\":1,\"949\":1}}],[\"多行注释\",{\"0\":{\"1110\":1},\"1\":{\"908\":1}}],[\"多余的右括号是不需要的\",{\"1\":{\"845\":1}}],[\"多存储节点\",{\"1\":{\"669\":1}}],[\"多用户\",{\"1\":{\"669\":1}}],[\"多环境\",{\"0\":{\"604\":1}}],[\"多了权限校验\",{\"1\":{\"592\":1}}],[\"多了一步操作\",{\"1\":{\"56\":1}}],[\"多角度项目优化\",{\"1\":{\"500\":1}}],[\"多模块构建\",{\"1\":{\"500\":1}}],[\"多个实例对象\",{\"1\":{\"1430\":1}}],[\"多个线程肯定会相互协作完成一件事情\",{\"1\":{\"1415\":1}}],[\"多个线程poll\",{\"1\":{\"1284\":1}}],[\"多个线程\",{\"1\":{\"1283\":2}}],[\"多个并发的事务之间要相互隔离\",{\"1\":{\"955\":1}}],[\"多个用户并发的访问数据库时\",{\"1\":{\"955\":1}}],[\"多个条件任意一个成立\",{\"1\":{\"931\":1}}],[\"多个条件同时成立\",{\"1\":{\"931\":1}}],[\"多个服务器节点可以实现共享\",{\"1\":{\"489\":1}}],[\"多个节点就可以通过共享数据库来协调任务的执行\",{\"1\":{\"484\":1}}],[\"多个逗号分隔\",{\"1\":{\"466\":1}}],[\"多个\",{\"1\":{\"457\":2,\"1248\":1}}],[\"多个评论的操作相互影响\",{\"1\":{\"37\":1}}],[\"多么真实而实用的算法\",{\"1\":{\"363\":1}}],[\"多源汇最短路\",{\"0\":{\"357\":1}}],[\"多重背包\",{\"0\":{\"298\":1}}],[\"多多少少也会有点不足\",{\"1\":{\"238\":1}}],[\"多位数字的写法\",{\"1\":{\"83\":1}}],[\"多样化的数据源\",{\"1\":{\"40\":1}}],[\"读对象的普通域被重排序到了读对象引用的前面就会出现线程\",{\"1\":{\"1475\":1}}],[\"读对象的引用和读该对象的\",{\"1\":{\"1475\":1}}],[\"读对象引用\",{\"1\":{\"1475\":1}}],[\"读final域\",{\"1\":{\"1475\":1}}],[\"读普通域\",{\"1\":{\"1475\":1}}],[\"读重排序\",{\"1\":{\"1457\":2}}],[\"读操作是在后面插入两个内存屏障\",{\"1\":{\"1457\":1}}],[\"读操作的后面插入一个\",{\"1\":{\"1457\":2}}],[\"读这个\",{\"1\":{\"1456\":1}}],[\"读后写\",{\"1\":{\"1418\":1}}],[\"读到的是过期的数据\",{\"1\":{\"1417\":1}}],[\"读到完整的数据\",{\"1\":{\"1295\":1}}],[\"读线程不是能够感知到\",{\"1\":{\"1295\":1}}],[\"读线程才能感知到数据变化\",{\"1\":{\"1295\":1}}],[\"读线程依然会\",{\"1\":{\"1295\":1}}],[\"读线程会等待或者当读锁被获取后\",{\"1\":{\"1295\":1}}],[\"读线程间是互不阻塞的\",{\"1\":{\"1295\":1}}],[\"读锁释放\",{\"1\":{\"1243\":1}}],[\"读锁释放的实现主要通过方法\",{\"1\":{\"1243\":1}}],[\"读锁的释放\",{\"0\":{\"1243\":1}}],[\"读锁的获取实现方法为\",{\"1\":{\"1242\":1}}],[\"读锁的获取\",{\"0\":{\"1242\":1}}],[\"读锁获取失败\",{\"1\":{\"1242\":1}}],[\"读锁获取后能再次获取\",{\"1\":{\"1237\":1}}],[\"读锁不是独占式锁\",{\"1\":{\"1242\":1}}],[\"读锁详解\",{\"0\":{\"1241\":1}}],[\"读锁是怎样获取和释放的\",{\"1\":{\"1237\":1}}],[\"读写线程被阻塞\",{\"1\":{\"1291\":1}}],[\"读写线程都会被阻塞\",{\"1\":{\"1290\":1}}],[\"读写所允许同一时刻被多个读线程访问\",{\"1\":{\"1237\":1}}],[\"读写锁支持锁降级\",{\"1\":{\"1244\":1}}],[\"读写锁是怎样实现分别记录读锁和写锁的状态的\",{\"1\":{\"1239\":1}}],[\"读写锁是怎样实现分别记录读写状态的\",{\"1\":{\"1237\":1}}],[\"读写锁\",{\"1\":{\"1237\":1,\"1295\":1}}],[\"读写锁介绍\",{\"0\":{\"1237\":1}}],[\"读写性能都受影响\",{\"1\":{\"40\":1}}],[\"读入下一行\",{\"1\":{\"981\":1}}],[\"读入下一个双精度浮点数\",{\"1\":{\"981\":1}}],[\"读入下一个单精度浮点数\",{\"1\":{\"981\":1}}],[\"读入下一个整数\",{\"1\":{\"981\":1}}],[\"读入下一个字符串\",{\"1\":{\"981\":1}}],[\"读\",{\"1\":{\"436\":1,\"1295\":1,\"1457\":1,\"1475\":3,\"1477\":2}}],[\"读数据\",{\"1\":{\"56\":1}}],[\"读的核心逻辑\",{\"0\":{\"48\":1}}],[\"读取变量\",{\"1\":{\"1482\":2}}],[\"读取同一个\",{\"1\":{\"1456\":1}}],[\"读取缓存数据\",{\"1\":{\"1204\":2,\"1207\":2,\"1211\":2}}],[\"读取了配置文件\",{\"1\":{\"1178\":1}}],[\"读取整个数组\",{\"0\":{\"1124\":1}}],[\"读取数组中某个元素的值\",{\"0\":{\"1123\":1}}],[\"读取和写入字符\",{\"1\":{\"1007\":1}}],[\"读取测试用例数量\",{\"1\":{\"127\":1}}],[\"读取输入\",{\"1\":{\"126\":1,\"167\":1}}],[\"读取\",{\"1\":{\"36\":1,\"46\":1,\"1482\":2}}],[\"读取评论\",{\"1\":{\"22\":1,\"45\":1}}],[\"大师已经做了一些改进\",{\"1\":{\"1314\":1}}],[\"大师考虑到了这种情况\",{\"1\":{\"1306\":1}}],[\"大师为我们都准备了对应的线程安全的容器\",{\"1\":{\"1324\":1}}],[\"大师为我们提供了大量实用\",{\"1\":{\"1491\":1}}],[\"大师为我们提供了\",{\"1\":{\"1290\":1}}],[\"大师为我们准备了\",{\"1\":{\"1280\":1}}],[\"大师每间隔\",{\"1\":{\"1286\":1}}],[\"大师不遗余力的为我们创造了一些线程安全的并发容器\",{\"1\":{\"1264\":1}}],[\"大部分只是读数据\",{\"1\":{\"1237\":1}}],[\"大根堆\",{\"1\":{\"1078\":1}}],[\"大根堆写法\",{\"1\":{\"1038\":1}}],[\"大括号可以省略\",{\"1\":{\"984\":1}}],[\"大整数值\",{\"1\":{\"920\":3}}],[\"大概有个了解\",{\"1\":{\"1416\":1}}],[\"大概\",{\"1\":{\"672\":1}}],[\"大概率是因为后端传的变量名和前端没对上\",{\"1\":{\"591\":1}}],[\"大模型时代下的新一代广告系统\",{\"1\":{\"636\":1}}],[\"大模型加持下的linux操作系统开发和自动化维护实践\",{\"1\":{\"618\":1}}],[\"大不了就换一个用户名就好了\",{\"1\":{\"613\":1}}],[\"大幅减少构建时间\",{\"1\":{\"534\":1}}],[\"大家都去排队\",{\"1\":{\"1434\":1}}],[\"大家可以想到这是一个\",{\"1\":{\"1184\":1}}],[\"大家\",{\"1\":{\"438\":1}}],[\"大数据处理\",{\"1\":{\"438\":1}}],[\"大数据的处理和分析能力也在不断提升\",{\"1\":{\"434\":1}}],[\"大数据已经成为推动技术创新和业务发展的关键因素\",{\"1\":{\"434\":1}}],[\"大数据技术\",{\"1\":{\"434\":1}}],[\"大数据\",{\"1\":{\"434\":1},\"2\":{\"442\":1}}],[\"大数据概述\",{\"0\":{\"434\":1}}],[\"大致可以猜想到应该就是回答一部分线程\",{\"1\":{\"1283\":1}}],[\"大致相同\",{\"1\":{\"423\":1}}],[\"大致分为几个阶段\",{\"1\":{\"39\":1}}],[\"大体的思路都是一样的\",{\"1\":{\"231\":1}}],[\"大多数情况下\",{\"1\":{\"1441\":1}}],[\"大多数类型都能用作函数的返回类型\",{\"1\":{\"1014\":1}}],[\"大多数服务都是用守护进程实现的\",{\"1\":{\"671\":1}}],[\"大多数\",{\"1\":{\"228\":1}}],[\"大很多\",{\"1\":{\"216\":1}}],[\"大于等于\",{\"1\":{\"931\":1,\"984\":1}}],[\"大于某个与inf`\",{\"1\":{\"354\":1}}],[\"大于两个格子的时候\",{\"1\":{\"147\":1}}],[\"大于\",{\"1\":{\"121\":1,\"898\":1,\"931\":1,\"984\":1,\"1306\":1}}],[\"大小\",{\"1\":{\"920\":3}}],[\"大小为10的数组\",{\"1\":{\"1000\":1}}],[\"大小为3的数组\",{\"1\":{\"1000\":1}}],[\"大小为\",{\"1\":{\"114\":1}}],[\"大小写均可\",{\"1\":{\"88\":1}}],[\"大量的请求会在\",{\"1\":{\"48\":1}}],[\"大\",{\"1\":{\"40\":1,\"613\":1}}],[\"只保证这个引用类型变量所引用的地址不会发生改变\",{\"1\":{\"1467\":1}}],[\"只保留表关联部分的数据\",{\"1\":{\"942\":1}}],[\"只允许一个线程执行任务\",{\"1\":{\"1376\":1}}],[\"只用调用者所在的线程来执行任务\",{\"1\":{\"1359\":1}}],[\"只采用了一个\",{\"1\":{\"1353\":1}}],[\"只专注于自己的业务功能即可\",{\"1\":{\"1324\":1}}],[\"只适用于\",{\"1\":{\"1309\":1}}],[\"只具有弱一致性的原因\",{\"1\":{\"1295\":1}}],[\"只删除节点不更新\",{\"1\":{\"1286\":1}}],[\"只插入节点不更新\",{\"1\":{\"1286\":1}}],[\"只支持一维数组\",{\"1\":{\"1121\":1}}],[\"只读变量\",{\"0\":{\"1114\":1},\"1\":{\"1005\":1}}],[\"只\",{\"1\":{\"886\":1}}],[\"只遍历了一次链表\",{\"1\":{\"777\":1}}],[\"只包含正整数\",{\"1\":{\"771\":1}}],[\"只与文件名有关\",{\"1\":{\"670\":1}}],[\"只会用到\",{\"1\":{\"797\":1}}],[\"只会被抓到它在请求国内服务器\",{\"1\":{\"664\":1}}],[\"只会把\",{\"1\":{\"200\":1}}],[\"只取\",{\"1\":{\"525\":1}}],[\"只去掉相邻的相同元素\",{\"1\":{\"423\":1}}],[\"只是将线程池的状态设置为\",{\"1\":{\"1360\":1}}],[\"只是增加了超时特性\",{\"1\":{\"1326\":1}}],[\"只是该\",{\"1\":{\"1316\":1}}],[\"只是在写的时候会创建新对象添加到新容器里\",{\"1\":{\"1295\":1}}],[\"只是算出\",{\"1\":{\"1270\":1}}],[\"只是想说明下我们刚才所想的\",{\"1\":{\"1250\":1}}],[\"只是简单的获取了一下当前状态做了一些逻辑处理\",{\"1\":{\"1233\":1}}],[\"只是\",{\"1\":{\"380\":1}}],[\"只需简单地测试一下对象头的\",{\"1\":{\"1442\":1}}],[\"只需将基数\",{\"1\":{\"380\":1}}],[\"只需要同步组件表达的\",{\"1\":{\"1496\":1}}],[\"只需要同步组件返回的\",{\"1\":{\"1496\":1}}],[\"只需要调用同步组件提供的方法来实现并发编程即可\",{\"1\":{\"1496\":1}}],[\"只需要调用\",{\"1\":{\"1329\":1}}],[\"只需要调整连接查询时\",{\"1\":{\"945\":1}}],[\"只需要读取名单配置然后检测当前用户是否在该配置范围以内\",{\"1\":{\"1290\":1}}],[\"只需要通过\",{\"1\":{\"1284\":1}}],[\"只需要\",{\"1\":{\"1240\":1}}],[\"只需要创建\",{\"1\":{\"1100\":1}}],[\"只需要使用逗号分隔多张表即可\",{\"1\":{\"942\":1}}],[\"只需要一个参数\",{\"1\":{\"851\":1}}],[\"只需要补充数据不存在的校验\",{\"1\":{\"526\":1}}],[\"只需要修改生成参数即可\",{\"1\":{\"516\":1}}],[\"只需要在最后面加上\",{\"1\":{\"1087\":1}}],[\"只需要在\",{\"1\":{\"468\":1}}],[\"只需要跟一个父亲比较大小就行\",{\"1\":{\"417\":1}}],[\"只需要判断\",{\"1\":{\"371\":1}}],[\"只需要另找一个数\",{\"1\":{\"338\":3}}],[\"只需要枚举\",{\"1\":{\"291\":1}}],[\"只需要将\",{\"1\":{\"237\":1}}],[\"只需要稍加修改即可\",{\"1\":{\"227\":1}}],[\"只需要操作\",{\"1\":{\"122\":1}}],[\"只需要输出选出的区间端点即可\",{\"1\":{\"78\":1}}],[\"只需要设置不同的评论策略\",{\"1\":{\"45\":1}}],[\"只可能是此时\",{\"1\":{\"373\":1}}],[\"只判断能否被小于\",{\"1\":{\"367\":1}}],[\"只出现在集合之间\",{\"1\":{\"362\":1}}],[\"只考虑正数的情况\",{\"1\":{\"328\":1}}],[\"只小猫的重量\",{\"1\":{\"290\":1}}],[\"只小猫的重量分别是\",{\"1\":{\"290\":1}}],[\"只小猫都运送下山\",{\"1\":{\"290\":1}}],[\"只小猫\",{\"1\":{\"290\":1}}],[\"只能保证一个共享变量的原子操作\",{\"1\":{\"1439\":1}}],[\"只能保证同时只有\",{\"1\":{\"1398\":1}}],[\"只能阻塞等待\",{\"1\":{\"1398\":1}}],[\"只能通过静态方法\",{\"1\":{\"1388\":1}}],[\"只能通过切换时间片的方式交替进行\",{\"1\":{\"1224\":1}}],[\"只能使用一个后台线程执行任务\",{\"1\":{\"1365\":1}}],[\"只能在函数内部使用\",{\"1\":{\"1015\":1}}],[\"只能读取\",{\"1\":{\"1005\":1}}],[\"只能从父节点到子节点\",{\"1\":{\"880\":1}}],[\"只能不选\",{\"1\":{\"795\":1,\"796\":1}}],[\"只能进行节点交换\",{\"1\":{\"692\":1}}],[\"只能自己偷偷用哦\",{\"1\":{\"661\":1}}],[\"只能访问和操作自己的数据\",{\"1\":{\"470\":1}}],[\"只能访问自己所在部门的数据\",{\"1\":{\"470\":1}}],[\"只能输出c语言的内置数据类型\",{\"1\":{\"243\":1}}],[\"只能过\",{\"1\":{\"152\":1,\"157\":1,\"182\":1}}],[\"只不过这个方法同步等待的时候\",{\"1\":{\"1399\":1}}],[\"只不过这里能够获取多个许可\",{\"1\":{\"1398\":1}}],[\"只不过这里可以指定获取多个许可\",{\"1\":{\"1398\":1}}],[\"只不过这里有超时限制\",{\"1\":{\"1393\":1}}],[\"只不过这里有了时间限制\",{\"1\":{\"1392\":1}}],[\"只不过该方法可以一次获取多个许可\",{\"1\":{\"1398\":1}}],[\"只不过在\",{\"1\":{\"1386\":1}}],[\"只不过一个针对的是\",{\"1\":{\"1385\":1}}],[\"只不过会当做正常的用户线程执行\",{\"1\":{\"1340\":1}}],[\"只不过减少了对中断的处理\",{\"1\":{\"1251\":1}}],[\"只不过是遍历的方式从\",{\"1\":{\"887\":1}}],[\"只不过\",{\"1\":{\"230\":1}}],[\"只在高度相同时匹配\",{\"1\":{\"188\":1}}],[\"只过了\",{\"1\":{\"162\":1}}],[\"只通过了\",{\"1\":{\"109\":1}}],[\"只有源码会告诉我们答案\",{\"1\":{\"1504\":1}}],[\"只有守护线程的时候\",{\"1\":{\"1340\":1}}],[\"只有\",{\"1\":{\"1284\":1}}],[\"只有初始化条件没有循环结束条件\",{\"1\":{\"1283\":1}}],[\"只有在扩容的时候才为非\",{\"1\":{\"1266\":1}}],[\"只有熟悉了源码的逻辑我们的理解才是最深的\",{\"1\":{\"1251\":1}}],[\"只有被释放\",{\"1\":{\"1232\":1}}],[\"只有本类内部可以访问\",{\"1\":{\"1027\":1}}],[\"只有表名存在时才会删除该表\",{\"1\":{\"923\":1}}],[\"只有管理员才能够访问用户管理页\",{\"1\":{\"592\":1}}],[\"只有管理员才能管理用户\",{\"1\":{\"578\":1}}],[\"只有目录下直接包含\",{\"1\":{\"542\":1}}],[\"只有超级管理员有所有的权限\",{\"1\":{\"452\":1}}],[\"只有祖宗节点的有意义\",{\"1\":{\"415\":1}}],[\"只有先手必胜和先手必败两种情况\",{\"1\":{\"394\":1}}],[\"只有当数据对象的延时时间达到时才能插入到队列进行存储\",{\"1\":{\"1326\":1}}],[\"只有当写锁被释放后读线程才有机会获取到锁从而读到最新的数据\",{\"1\":{\"1291\":1}}],[\"只有当同步状态为0时\",{\"1\":{\"1232\":1}}],[\"只有当\",{\"1\":{\"361\":1}}],[\"只有a\",{\"1\":{\"302\":1}}],[\"只有一个线程会成功\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"只有一个实例\",{\"0\":{\"962\":1}}],[\"只有一个为空返回\",{\"1\":{\"808\":1}}],[\"只有一个格子\",{\"1\":{\"147\":1}}],[\"只有一个负数其他都是正数\",{\"1\":{\"104\":1}}],[\"只有重算排序的时候才会读取曝光数\",{\"1\":{\"40\":1}}],[\"只要不改变程序的执行结果\",{\"1\":{\"1420\":1,\"1423\":1}}],[\"只要不删除就能一直保留\",{\"1\":{\"670\":1}}],[\"只要这两个任务执行的时间相差不是太大\",{\"1\":{\"1361\":1}}],[\"只要函数的返回类型不是\",{\"1\":{\"1021\":1}}],[\"只要发现该节点已经被\",{\"1\":{\"875\":1}}],[\"只要当前节点为空\",{\"1\":{\"803\":1}}],[\"只要当前根节点是p和q中的任意一个\",{\"1\":{\"755\":1}}],[\"只要写一个构造函数即可\",{\"1\":{\"688\":1}}],[\"只要文件名不变\",{\"1\":{\"670\":1}}],[\"只要它不是\",{\"1\":{\"371\":1}}],[\"只要根据最未位是\",{\"1\":{\"338\":1}}],[\"只要\",{\"1\":{\"338\":1}}],[\"只要找到这个连续段的左端点和右端点即可\",{\"1\":{\"324\":1}}],[\"只要告诉奶牛它的长度就可以了\",{\"1\":{\"304\":1}}],[\"只要保证不会超过边界即可\",{\"1\":{\"173\":1}}],[\"只要有奇数个负数\",{\"1\":{\"104\":1}}],[\"只要有偶数个负数\",{\"1\":{\"104\":1}}],[\"只要小明觉得有必要\",{\"1\":{\"104\":1}}],[\"只重建一次缓存\",{\"1\":{\"28\":1}}],[\"量级非常大\",{\"1\":{\"40\":1}}],[\"曝光的数据来源是客户端上报的展现日志\",{\"1\":{\"40\":1}}],[\"曝光数使用\",{\"1\":{\"40\":1}}],[\"曝光数\",{\"1\":{\"40\":1}}],[\"威尔逊排序\",{\"1\":{\"40\":1}}],[\"来看看\",{\"1\":{\"1431\":1}}],[\"来看下源码\",{\"1\":{\"1370\":1,\"1385\":1}}],[\"来看下怎么实现的\",{\"1\":{\"1150\":1}}],[\"来看下\",{\"1\":{\"1149\":1,\"1175\":1,\"1393\":1}}],[\"来创建一个更新器\",{\"1\":{\"1388\":1}}],[\"来总结下常用的方法\",{\"1\":{\"1386\":1}}],[\"来处理\",{\"1\":{\"1361\":1}}],[\"来感知其他线程对其自身的中断操作\",{\"1\":{\"1336\":1}}],[\"来新建线程\",{\"1\":{\"1330\":1}}],[\"来源于\",{\"1\":{\"1326\":2}}],[\"来指定排序规则\",{\"1\":{\"1326\":1}}],[\"来计算\",{\"1\":{\"1276\":1}}],[\"来确定\",{\"1\":{\"1276\":1}}],[\"来保证引用对象之间的原子性\",{\"1\":{\"1439\":1}}],[\"来保证可见性\",{\"1\":{\"1276\":1}}],[\"来保护数据的隐私和安全\",{\"1\":{\"574\":1}}],[\"来说之后的操作就会是错的\",{\"1\":{\"1485\":1}}],[\"来说是可见的\",{\"1\":{\"1455\":1}}],[\"来说明这些类的基本用法\",{\"1\":{\"1387\":1}}],[\"来说\",{\"1\":{\"1264\":1,\"1275\":1,\"1285\":1,\"1292\":1,\"1365\":1,\"1371\":1,\"1496\":1}}],[\"来说条件满足\",{\"1\":{\"1254\":1}}],[\"来执行上面的初始化操作\",{\"1\":{\"1182\":1}}],[\"来执行分页查询\",{\"1\":{\"40\":1}}],[\"来一份\",{\"1\":{\"1172\":1}}],[\"来获取\",{\"1\":{\"1164\":1}}],[\"来获取配置项的值\",{\"1\":{\"1157\":1}}],[\"来管理集群节点的生命周期\",{\"1\":{\"1162\":1}}],[\"来管理\",{\"1\":{\"1149\":1,\"1151\":1}}],[\"来加载配置文件\",{\"1\":{\"1149\":1}}],[\"来控制能够并发访问到数据库连接资源的线程个数最多只有\",{\"1\":{\"1398\":1}}],[\"来控制线程安全\",{\"1\":{\"1350\":1}}],[\"来控制优先级\",{\"1\":{\"1339\":1}}],[\"来控制\",{\"1\":{\"1131\":1}}],[\"来负责控制对象的生命周期和对象间的关系\",{\"1\":{\"1131\":1}}],[\"来统一管理维护的\",{\"1\":{\"1129\":1}}],[\"来关联属于一这方的主键\",{\"1\":{\"937\":1}}],[\"来避免这个问题\",{\"1\":{\"913\":1}}],[\"来连接\",{\"1\":{\"906\":1}}],[\"来优化空间\",{\"1\":{\"894\":1}}],[\"来降低误判率\",{\"1\":{\"613\":1}}],[\"来请求后端\",{\"1\":{\"585\":1}}],[\"来自动安装\",{\"1\":{\"538\":1}}],[\"来进行处理\",{\"1\":{\"1359\":1}}],[\"来进行判定\",{\"1\":{\"1326\":1}}],[\"来进行条件判断\",{\"1\":{\"1315\":1}}],[\"来进行统一资源加载\",{\"1\":{\"1136\":1}}],[\"来进行分片\",{\"1\":{\"61\":1}}],[\"来进一步提高查询速度\",{\"1\":{\"436\":1}}],[\"来解决或者通过\",{\"1\":{\"1417\":1}}],[\"来解决脏\",{\"1\":{\"1306\":1}}],[\"来解决\",{\"1\":{\"339\":1,\"613\":1,\"1439\":1}}],[\"来解决这个问题\",{\"1\":{\"180\":1}}],[\"来判断是否需要开始调度执行发送心跳\",{\"1\":{\"1158\":1}}],[\"来判断是否需要开始调度执行刷新注册表信息\",{\"1\":{\"1158\":1}}],[\"来判断\",{\"1\":{\"338\":1,\"899\":1}}],[\"来决定\",{\"1\":{\"338\":1}}],[\"来递加\",{\"1\":{\"261\":1}}],[\"来求出\",{\"1\":{\"261\":1}}],[\"来记录搜索过的元素\",{\"1\":{\"228\":1}}],[\"来存储已经注销的用户名\",{\"1\":{\"613\":1}}],[\"来存储每个元素的父节点\",{\"1\":{\"269\":1}}],[\"来存储每个元素的频率\",{\"1\":{\"178\":1}}],[\"来存储点击数据\",{\"1\":{\"151\":1}}],[\"来实现生产者\",{\"1\":{\"1411\":1}}],[\"来实现可阻塞的插入和删除数据\",{\"1\":{\"1350\":1}}],[\"来实现减小锁粒度\",{\"1\":{\"1276\":2}}],[\"来实现的\",{\"1\":{\"1132\":1,\"1306\":1,\"1385\":1}}],[\"来实现查询限制\",{\"1\":{\"471\":1}}],[\"来实现\",{\"1\":{\"151\":1}}],[\"来实现差异化评论排序的平衡\",{\"1\":{\"40\":1}}],[\"来缓冲和异步处理广告点击数据\",{\"1\":{\"151\":1}}],[\"来维护积分到玩家的映射\",{\"1\":{\"129\":1}}],[\"来维护玩家积分\",{\"1\":{\"129\":1}}],[\"来最大化这个子序列的长度\",{\"1\":{\"66\":1}}],[\"来做\",{\"1\":{\"437\":1}}],[\"来做加速完全足够\",{\"1\":{\"58\":1}}],[\"来做多条件组合检索\",{\"1\":{\"50\":1}}],[\"来完成的\",{\"1\":{\"50\":1}}],[\"来介绍该系统的功能\",{\"1\":{\"44\":1}}],[\"来承担这部分策略探索型业务\",{\"1\":{\"40\":1}}],[\"来支撑热评列表的读写\",{\"1\":{\"40\":1}}],[\"来验证相应的热点配置与代码实现是符合预期的\",{\"1\":{\"33\":1}}],[\"显而易见对线程\",{\"1\":{\"1485\":1}}],[\"显式内连接语法\",{\"1\":{\"944\":1}}],[\"显式内连接\",{\"1\":{\"944\":1}}],[\"显示转化\",{\"1\":{\"978\":1}}],[\"显示\",{\"1\":{\"463\":1,\"672\":1}}],[\"显示评论数\",{\"1\":{\"22\":1}}],[\"显然无解\",{\"1\":{\"383\":1}}],[\"显然题目把三种情况都告诉了\",{\"1\":{\"147\":1}}],[\"显然\",{\"1\":{\"40\":1,\"687\":1}}],[\"挑战与应对\",{\"0\":{\"40\":1}}],[\"→\",{\"1\":{\"39\":4,\"221\":1}}],[\"就数据结构而言\",{\"1\":{\"1501\":1}}],[\"就算写回到内存\",{\"1\":{\"1454\":1}}],[\"就算是可以分割成两个相同元素和子集了\",{\"1\":{\"772\":1}}],[\"就导致最终的计算结果不是正确的\",{\"1\":{\"1449\":1}}],[\"就可能会出现\",{\"1\":{\"1449\":1}}],[\"就可以判断是否已经超时了\",{\"1\":{\"1508\":1}}],[\"就可以说是\",{\"1\":{\"1453\":1}}],[\"就可以保证内存可见性\",{\"1\":{\"1449\":1}}],[\"就可以很好的完成生产者和消费者线程之间的协作\",{\"1\":{\"1411\":1}}],[\"就可以很方便的解决上述问题\",{\"1\":{\"937\":1}}],[\"就可以获取到许可\",{\"1\":{\"1398\":1}}],[\"就可以直接调用\",{\"1\":{\"1347\":1}}],[\"就可以直接用\",{\"1\":{\"1272\":1}}],[\"就可以执行\",{\"1\":{\"1283\":1}}],[\"就可以执行i\",{\"1\":{\"1274\":1}}],[\"就可以通过\",{\"1\":{\"1272\":1}}],[\"就可以通过该方法将相应的依赖对象设置到被注入对象中\",{\"1\":{\"1133\":1}}],[\"就可以进行拆分利用多线程的技术完成\",{\"1\":{\"1218\":1}}],[\"就可以达到\",{\"1\":{\"1218\":1}}],[\"就可以找到\",{\"1\":{\"958\":1}}],[\"就可以查询到当前所处的数据库\",{\"1\":{\"912\":1}}],[\"就可以起到不走回头路的作用\",{\"1\":{\"820\":1}}],[\"就可以了\",{\"1\":{\"772\":2}}],[\"就可以兼具\",{\"1\":{\"535\":1}}],[\"就可以把埃氏筛法运用在\",{\"1\":{\"372\":1}}],[\"就知道如何解决了\",{\"1\":{\"1449\":1}}],[\"就知道同步队列是一个带头结点的链式队列\",{\"1\":{\"1251\":1}}],[\"就具有使每个线程依次排队操作共享变量的功能\",{\"1\":{\"1429\":1}}],[\"就好像通过共享变量在进行隐式通信\",{\"1\":{\"1417\":1}}],[\"就从抽象层次定义了这种方式\",{\"1\":{\"1417\":1}}],[\"就以这个生活场景为例\",{\"1\":{\"1416\":1}}],[\"就以当前\",{\"1\":{\"1302\":1}}],[\"就模拟出\",{\"1\":{\"1406\":1}}],[\"就来模拟这个情景\",{\"1\":{\"1399\":1}}],[\"就变成了\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"就很容易了\",{\"1\":{\"1348\":1}}],[\"就和它的名字一样\",{\"1\":{\"1340\":1}}],[\"就两人携手并进\",{\"1\":{\"1337\":1}}],[\"就立即返回\",{\"1\":{\"1326\":1}}],[\"就跟加锁完要解锁一样\",{\"1\":{\"1320\":1}}],[\"就使用\",{\"1\":{\"1317\":1}}],[\"就更换到了\",{\"1\":{\"1317\":2}}],[\"就更新\",{\"1\":{\"1165\":1}}],[\"就整个扫描过程持续\",{\"1\":{\"1315\":1}}],[\"就存在了这样一条引用链\",{\"1\":{\"1313\":1}}],[\"就存在\",{\"1\":{\"1313\":1}}],[\"就相当于一个许可证\",{\"1\":{\"1398\":1}}],[\"就相当于\",{\"1\":{\"1313\":1}}],[\"就没有办法访问这些\",{\"1\":{\"1305\":1}}],[\"就新建\",{\"1\":{\"1301\":1}}],[\"就必须首先分析任务特性\",{\"1\":{\"1361\":1}}],[\"就必须了解它的几个核心方法\",{\"1\":{\"1300\":1}}],[\"就必须得到它\",{\"1\":{\"1131\":1}}],[\"就构造一个反序链表\",{\"1\":{\"1274\":1}}],[\"就在原\",{\"1\":{\"1274\":1}}],[\"就在任何场景下就一定适用么\",{\"1\":{\"1219\":1}}],[\"就向后遍历查找节点\",{\"1\":{\"1273\":1}}],[\"就覆盖旧值\",{\"1\":{\"1272\":1}}],[\"就直接使用\",{\"1\":{\"1309\":1}}],[\"就直接将待插入的键值对追加到链表的末尾即可\",{\"1\":{\"1272\":1}}],[\"就直接覆盖即可\",{\"1\":{\"1272\":1}}],[\"就直接抛出异常\",{\"1\":{\"1270\":1}}],[\"就说明当前\",{\"1\":{\"1272\":1}}],[\"就说明存在一条长度是n+1的最短路径\",{\"1\":{\"354\":1}}],[\"就像是一个仓库\",{\"1\":{\"1402\":1}}],[\"就像在使用数据库连接一样\",{\"1\":{\"1309\":1}}],[\"就像网购\",{\"1\":{\"1223\":1}}],[\"就像一个存储服务\",{\"1\":{\"674\":1}}],[\"就无法从\",{\"1\":{\"1191\":1}}],[\"就注册到\",{\"1\":{\"1184\":1}}],[\"就通过\",{\"1\":{\"1164\":2,\"1314\":1}}],[\"就调用副本的\",{\"1\":{\"1158\":1}}],[\"就调用对应的\",{\"1\":{\"1151\":1}}],[\"就会报错\",{\"1\":{\"1471\":1}}],[\"就会从内存中重读该变量数据\",{\"1\":{\"1454\":1}}],[\"就会从缓存里面这个默认值\",{\"1\":{\"1149\":1}}],[\"就会实现缓存一致性协议\",{\"1\":{\"1454\":1}}],[\"就会向处理器发送一条\",{\"1\":{\"1454\":1}}],[\"就会造成所有的生产者线程都处于等待状态\",{\"1\":{\"1408\":1}}],[\"就会造成数的高度比较高\",{\"1\":{\"958\":1}}],[\"就会出错\",{\"1\":{\"1407\":1}}],[\"就会存在wait条件变化造成程序错误的问题\",{\"1\":{\"1407\":2}}],[\"就会存在如下一种情况\",{\"1\":{\"1285\":1}}],[\"就会将当前处理器的缓存行设置成无效状态\",{\"1\":{\"1454\":1}}],[\"就会将任务提交给有界阻塞队列\",{\"1\":{\"1366\":1}}],[\"就会将这些空闲线程销毁\",{\"1\":{\"1359\":1}}],[\"就会创建新的线程来执行任务\",{\"1\":{\"1359\":1}}],[\"就会退出所以不会出现死循环的情况\",{\"1\":{\"1340\":1}}],[\"就会尝试在数组中寻找其他的单元\",{\"1\":{\"1306\":1}}],[\"就会一直存在一条强引用链\",{\"1\":{\"1305\":1}}],[\"就会转换为哨兵节点\",{\"1\":{\"1285\":1}}],[\"就会执行到代码的第\",{\"1\":{\"1284\":1}}],[\"就会调用被\",{\"1\":{\"1370\":1}}],[\"就会调用\",{\"1\":{\"1272\":1}}],[\"就应该有资源加载\",{\"1\":{\"1136\":1}}],[\"就被称为元注解\",{\"1\":{\"1053\":1}}],[\"就有可能读到的是普通变量\",{\"1\":{\"1475\":1}}],[\"就有可能获取不到正确的值\",{\"1\":{\"1380\":1}}],[\"就有了很大的变化\",{\"1\":{\"1264\":1}}],[\"就有\",{\"1\":{\"958\":1}}],[\"就满足这种要求\",{\"1\":{\"958\":1}}],[\"就进行事务的回滚\",{\"1\":{\"953\":1}}],[\"就占用多少个字符\",{\"1\":{\"920\":1}}],[\"就需要\",{\"1\":{\"1393\":1}}],[\"就需要向前环形搜索\",{\"1\":{\"1317\":1}}],[\"就需要扩容\",{\"1\":{\"1272\":2}}],[\"就需要自己自定义排序方式\",{\"1\":{\"1074\":1}}],[\"就需要自己按照下面这些文档整合这些工具\",{\"1\":{\"539\":1}}],[\"就需要通过该指令\",{\"1\":{\"914\":1}}],[\"就意味着有橘子永远不会腐烂\",{\"1\":{\"869\":1}}],[\"就要解决两个问题\",{\"1\":{\"1232\":1}}],[\"就要付出较高的公网带宽传输成本\",{\"1\":{\"1094\":1}}],[\"就要立即将这个功能应用到实践中\",{\"1\":{\"983\":1}}],[\"就要加入队列并标记为\",{\"1\":{\"821\":1}}],[\"就要获得倒数第\",{\"1\":{\"777\":1}}],[\"就用当前节点的下一个节点去试探\",{\"1\":{\"1284\":1}}],[\"就用\",{\"1\":{\"820\":1}}],[\"就得到了答案\",{\"1\":{\"893\":1}}],[\"就得到了\",{\"1\":{\"795\":1}}],[\"就得到了最短路径\",{\"1\":{\"355\":1}}],[\"就获得了倒数第\",{\"1\":{\"777\":1}}],[\"就返回相应的值value\",{\"1\":{\"1302\":1}}],[\"就返回right\",{\"1\":{\"755\":1}}],[\"就返回\",{\"1\":{\"755\":1,\"1326\":1}}],[\"就返回祖先\",{\"1\":{\"270\":1}}],[\"就将\",{\"1\":{\"1408\":1}}],[\"就将上一个节点的右指针更新为当前节点\",{\"1\":{\"725\":1}}],[\"就将这条边加入集合中\",{\"1\":{\"361\":1}}],[\"就能够读到\",{\"1\":{\"1475\":1}}],[\"就能够迅速感知\",{\"1\":{\"1455\":1}}],[\"就能够减少性能损耗\",{\"1\":{\"523\":1}}],[\"就能拥有我们自己的缓存策略\",{\"1\":{\"688\":1}}],[\"就表示停止\",{\"1\":{\"663\":1}}],[\"就表示以下标\",{\"1\":{\"120\":1}}],[\"就够了\",{\"1\":{\"525\":1}}],[\"就不能保证其原子性\",{\"1\":{\"1439\":1}}],[\"就不能再使用表名来指定对应的字段了\",{\"1\":{\"944\":1}}],[\"就不再去\",{\"1\":{\"1406\":1}}],[\"就不再需要关心生产者的行为\",{\"1\":{\"1402\":1}}],[\"就不会被其他线程所干扰\",{\"1\":{\"1482\":1}}],[\"就不会再恢复到轻量级锁状态\",{\"1\":{\"1447\":1}}],[\"就不会清除标志位\",{\"1\":{\"1336\":1}}],[\"就不会发现任何异常\",{\"1\":{\"664\":1}}],[\"就不用递归右子树了\",{\"1\":{\"901\":1}}],[\"就不用遍历了\",{\"1\":{\"876\":1}}],[\"就不用写到类里了\",{\"1\":{\"517\":1}}],[\"就不是公平组合游戏\",{\"1\":{\"395\":1}}],[\"就不是用最小质因子去更新了\",{\"1\":{\"373\":1}}],[\"就把这个链表转换成红黑树\",{\"1\":{\"1272\":1}}],[\"就把\",{\"1\":{\"869\":1}}],[\"就把节点\",{\"1\":{\"789\":1}}],[\"就把k改为l\",{\"1\":{\"404\":1}}],[\"就把它变成\",{\"1\":{\"161\":1}}],[\"就删去了所有的合数\",{\"1\":{\"371\":1}}],[\"就交换位置\",{\"1\":{\"417\":1}}],[\"就交换\",{\"1\":{\"317\":1}}],[\"就默认添加此选项\",{\"1\":{\"255\":1}}],[\"就执行这些操作\",{\"1\":{\"167\":1}}],[\"就是这\",{\"1\":{\"1393\":1}}],[\"就是这么简单\",{\"1\":{\"1129\":1}}],[\"就是新建了一个\",{\"1\":{\"1385\":1}}],[\"就是目前来说最新的值了\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"就是用来控制扫描趟数\",{\"1\":{\"1315\":1}}],[\"就是为每一个线程分配一个该对象\",{\"1\":{\"1313\":1}}],[\"就是两种情况\",{\"1\":{\"1272\":1}}],[\"就是线程安全的\",{\"1\":{\"1264\":1}}],[\"就是当前线程被中断或者调用\",{\"1\":{\"1251\":1}}],[\"就是通过\",{\"1\":{\"1291\":1}}],[\"就是通过尾插入的方式将当前线程封装的\",{\"1\":{\"1251\":1}}],[\"就是通过反射来实现注入的\",{\"1\":{\"1132\":1}}],[\"就是系统状态\",{\"1\":{\"1190\":1}}],[\"就是一个典型的案例\",{\"1\":{\"1309\":1}}],[\"就是一个支持\",{\"1\":{\"1184\":1}}],[\"就是一个质因数\",{\"1\":{\"371\":1}}],[\"就是要发送给\",{\"1\":{\"1184\":1}}],[\"就是将\",{\"1\":{\"1180\":1}}],[\"就是客户端\",{\"1\":{\"1175\":1}}],[\"就是获取配置管理类的一个单例\",{\"1\":{\"1145\":1}}],[\"就是由\",{\"1\":{\"1129\":1,\"1131\":1}}],[\"就是最后一层子节点\",{\"1\":{\"958\":1}}],[\"就是不再像红黑树一样每个节点只能保存一个数据\",{\"1\":{\"958\":1}}],[\"就是使用索引可以提高查询的效率\",{\"1\":{\"957\":1}}],[\"就是来保证数据库当中数据的正确性\",{\"1\":{\"919\":1}}],[\"就是装满背包之后的重量\",{\"1\":{\"772\":1}}],[\"就是动态路由参数\",{\"1\":{\"542\":1}}],[\"就是题目加入到题库的时间\",{\"1\":{\"513\":1}}],[\"就是判断\",{\"1\":{\"381\":1}}],[\"就是\",{\"1\":{\"362\":1,\"373\":1,\"1472\":1}}],[\"就是给定一个无向图\",{\"1\":{\"359\":1}}],[\"就是奇数\",{\"1\":{\"338\":1}}],[\"就是偶数\",{\"1\":{\"338\":1}}],[\"就是其爆炸范围\",{\"1\":{\"263\":1}}],[\"就是区间\",{\"1\":{\"261\":1}}],[\"就是上下左右全部被海水包围\",{\"1\":{\"229\":1}}],[\"就是根节点的左右子树的最大深度之和\",{\"1\":{\"760\":1}}],[\"就是根据各种要素排序的得分\",{\"1\":{\"58\":1}}],[\"就是根评论\",{\"1\":{\"56\":1}}],[\"就是回复的评论\",{\"1\":{\"56\":1}}],[\"就是评论\",{\"1\":{\"56\":1,\"58\":1}}],[\"就是读请求未命中缓存穿透到db\",{\"1\":{\"28\":1}}],[\"就代表热度高\",{\"1\":{\"39\":3}}],[\"咬文嚼字来说\",{\"1\":{\"39\":1}}],[\"介绍过线程间等待\",{\"1\":{\"1258\":1}}],[\"介绍\",{\"0\":{\"210\":1,\"445\":1,\"942\":1,\"947\":1,\"953\":1,\"957\":1,\"1415\":1},\"1\":{\"1242\":1}}],[\"介绍了什么样的评论更容易上热评前排\",{\"1\":{\"39\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}],[\"字节数\",{\"1\":{\"978\":1}}],[\"字节\",{\"1\":{\"958\":2}}],[\"字节二面\",{\"1\":{\"634\":1}}],[\"字节跳动基于\",{\"1\":{\"617\":1}}],[\"字节流光\",{\"1\":{\"587\":1}}],[\"字典树\",{\"2\":{\"805\":1}}],[\"字典树解法\",{\"1\":{\"203\":1}}],[\"字典序\",{\"1\":{\"422\":1}}],[\"字典序较小的排在前面\",{\"1\":{\"288\":1,\"289\":1}}],[\"字符可以参与运算\",{\"1\":{\"1004\":1}}],[\"字符可重复\",{\"1\":{\"82\":1}}],[\"字符与整数的联系\",{\"0\":{\"1004\":1}}],[\"字符数组的初始化\",{\"1\":{\"998\":1}}],[\"字符矩阵\",{\"1\":{\"280\":1}}],[\"字符串可以用单引号\",{\"1\":{\"1117\":1}}],[\"字符串比较必须能用equals\",{\"1\":{\"1069\":1}}],[\"字符串分为两类\",{\"1\":{\"1068\":1}}],[\"字符串或向量的排序\",{\"1\":{\"1045\":1}}],[\"字符串或者其他对象\",{\"1\":{\"1014\":1}}],[\"字符串是计算机与人类沟通的重要手段\",{\"1\":{\"1003\":1}}],[\"字符串等\",{\"1\":{\"972\":1}}],[\"字符串和日期型数据应该包含在引号中\",{\"1\":{\"925\":1}}],[\"字符串类型\",{\"1\":{\"920\":2}}],[\"字符串中的每个字符都有两种\",{\"1\":{\"839\":1}}],[\"字符串中只包含小写字母\",{\"1\":{\"305\":1}}],[\"字符串字段转换为前端更好理解的数据类型\",{\"1\":{\"517\":1}}],[\"字符串哈希\",{\"0\":{\"421\":1}}],[\"字符串以\",{\"1\":{\"412\":1}}],[\"字符串的第i个位置的字符\",{\"1\":{\"1005\":1}}],[\"字符串的权值为将字符串变成全\",{\"1\":{\"120\":1}}],[\"字符串的括号匹配问题\",{\"1\":{\"93\":1}}],[\"字符串不含空格\",{\"1\":{\"88\":1}}],[\"字符串只包含若干一位的正整数和若干计算符号\",{\"1\":{\"83\":2}}],[\"字符串\",{\"0\":{\"243\":1,\"1003\":1,\"1068\":1,\"1117\":1},\"1\":{\"71\":1,\"120\":1,\"422\":1,\"948\":1}}],[\"字数加权\",{\"1\":{\"39\":1}}],[\"字段的值已经变成了\",{\"1\":{\"1388\":1}}],[\"字段的类型\",{\"1\":{\"565\":1,\"921\":1}}],[\"字段原值为\",{\"1\":{\"1388\":1}}],[\"字段3\",{\"1\":{\"930\":1}}],[\"字段列表\",{\"1\":{\"929\":1,\"930\":1,\"931\":1,\"932\":1,\"933\":1,\"934\":1,\"935\":1,\"942\":2,\"944\":2,\"945\":2}}],[\"字段更新为\",{\"1\":{\"926\":1}}],[\"字段类型\",{\"1\":{\"922\":1}}],[\"字段类型为\",{\"1\":{\"922\":1}}],[\"字段名2\",{\"1\":{\"925\":2,\"926\":1}}],[\"字段名1\",{\"1\":{\"925\":2,\"926\":1}}],[\"字段名为\",{\"1\":{\"922\":1}}],[\"字段名\",{\"1\":{\"922\":3,\"937\":1,\"959\":1}}],[\"字段n注释\",{\"1\":{\"918\":1}}],[\"字段n类型\",{\"1\":{\"918\":1}}],[\"字段n\",{\"1\":{\"918\":1}}],[\"字段2注释\",{\"1\":{\"918\":1}}],[\"字段2类型\",{\"1\":{\"918\":1}}],[\"字段2\",{\"1\":{\"918\":1,\"930\":2,\"934\":1}}],[\"字段1注释\",{\"1\":{\"918\":1}}],[\"字段1类型\",{\"1\":{\"918\":1}}],[\"字段1\",{\"1\":{\"918\":1,\"930\":2,\"934\":1}}],[\"字段设置在\",{\"1\":{\"592\":1}}],[\"字段上加上\",{\"1\":{\"575\":1}}],[\"字段均为驼峰命名\",{\"1\":{\"567\":1}}],[\"字段增加索引\",{\"1\":{\"511\":1}}],[\"字段捞出\",{\"1\":{\"56\":1}}],[\"字段大部分都是增量更新\",{\"1\":{\"37\":1}}],[\"字段\",{\"1\":{\"30\":1,\"566\":2,\"909\":1,\"919\":1}}],[\"时能够将内存进行回收\",{\"1\":{\"1505\":1}}],[\"时进行入队操作\",{\"1\":{\"1504\":1}}],[\"时进行了补充\",{\"1\":{\"1259\":1}}],[\"时就会调用已经被\",{\"1\":{\"1495\":1}}],[\"时就会为\",{\"1\":{\"1485\":1}}],[\"时就为\",{\"1\":{\"1285\":1}}],[\"时需要考虑两个关键因素\",{\"1\":{\"1423\":1}}],[\"时需要加\",{\"1\":{\"322\":1}}],[\"时没有持有适当的锁\",{\"1\":{\"1404\":1}}],[\"时非阻塞同步\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"时检查发现旧值并没有变化依然为\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"时才会执行方法\",{\"1\":{\"1505\":1}}],[\"时才会继续\",{\"1\":{\"1336\":1}}],[\"时才能表示已经将所有点加入到集合中\",{\"1\":{\"361\":1}}],[\"时候\",{\"1\":{\"1336\":1,\"1393\":1}}],[\"时候不加锁\",{\"1\":{\"1276\":1}}],[\"时退出\",{\"1\":{\"1316\":1}}],[\"时创建线程的时候\",{\"1\":{\"1313\":1}}],[\"时创建出来的\",{\"1\":{\"1184\":1}}],[\"时的情况\",{\"1\":{\"1284\":1}}],[\"时的定义\",{\"1\":{\"1284\":1}}],[\"时的最大得分\",{\"1\":{\"178\":2}}],[\"时在多线程情况下扩容会出现\",{\"1\":{\"1264\":1}}],[\"时遗漏了这一点\",{\"1\":{\"1259\":1}}],[\"时都会调用\",{\"1\":{\"1258\":1}}],[\"时知道同步队列是一个双向队列\",{\"1\":{\"1250\":1}}],[\"时锁才算成功释放\",{\"1\":{\"1232\":1}}],[\"时序图如下\",{\"1\":{\"1185\":1}}],[\"时初始化出来的\",{\"1\":{\"1184\":1}}],[\"时为非公平锁\",{\"1\":{\"1233\":1}}],[\"时为公平锁\",{\"1\":{\"1233\":1}}],[\"时为偶数\",{\"1\":{\"381\":1}}],[\"时为奇数\",{\"1\":{\"381\":1}}],[\"时不需要加\",{\"1\":{\"321\":1}}],[\"时用来初始化\",{\"1\":{\"307\":1}}],[\"时到达\",{\"1\":{\"205\":1}}],[\"时会寻找真正的队头节点\",{\"1\":{\"1285\":1}}],[\"时会越界\",{\"1\":{\"182\":1}}],[\"时会爆炸\",{\"1\":{\"97\":1}}],[\"时剩余体力为\",{\"1\":{\"142\":1}}],[\"时如果你在商店里花费了\",{\"1\":{\"109\":1}}],[\"时\",{\"1\":{\"48\":1,\"83\":2,\"128\":1,\"178\":1,\"193\":1,\"243\":1,\"261\":1,\"274\":2,\"321\":1,\"322\":1,\"338\":1,\"373\":2,\"380\":1,\"383\":2,\"710\":1,\"797\":2,\"828\":1,\"833\":1,\"846\":4,\"881\":1,\"888\":1,\"1045\":2,\"1184\":1,\"1186\":1,\"1266\":1,\"1270\":1,\"1272\":2,\"1283\":4,\"1284\":1,\"1285\":2,\"1317\":3,\"1504\":1,\"1505\":1}}],[\"时间后\",{\"1\":{\"1392\":1}}],[\"时间单位\",{\"1\":{\"1359\":1}}],[\"时间换空间\",{\"1\":{\"1313\":2}}],[\"时间片当前线程依然会继续运行\",{\"1\":{\"1339\":1}}],[\"时间片才会继续执行\",{\"1\":{\"1338\":1}}],[\"时间片就会继续执行\",{\"1\":{\"1338\":1}}],[\"时间片\",{\"1\":{\"1271\":1,\"1339\":1}}],[\"时间片一般是几十毫秒\",{\"1\":{\"1220\":1}}],[\"时间片是\",{\"1\":{\"1220\":1}}],[\"时间戳\",{\"1\":{\"920\":1}}],[\"时间值或持续时间\",{\"1\":{\"920\":1}}],[\"时间充裕再做\",{\"1\":{\"506\":1}}],[\"时间购买商品\",{\"1\":{\"205\":1}}],[\"时间内查询区间最大值的数据结构\",{\"1\":{\"168\":1}}],[\"时间不够没\",{\"1\":{\"152\":1}}],[\"时间复杂度优化\",{\"1\":{\"852\":1}}],[\"时间复杂度o\",{\"1\":{\"358\":1}}],[\"时间复杂度是\",{\"1\":{\"352\":1,\"353\":1,\"361\":1,\"363\":1,\"422\":1}}],[\"时间复杂度一般为\",{\"1\":{\"351\":1}}],[\"时间复杂度为\",{\"1\":{\"324\":1,\"351\":3,\"360\":1,\"361\":2,\"367\":1,\"368\":1,\"371\":1,\"373\":1,\"381\":1,\"385\":1,\"852\":1}}],[\"时间复杂度\",{\"1\":{\"134\":1,\"346\":1,\"349\":1,\"354\":1,\"355\":1,\"356\":1,\"362\":1,\"422\":1,\"724\":1}}],[\"时间复杂度的基数可以认为都是o\",{\"1\":{\"40\":1}}],[\"时间衰退因子\",{\"1\":{\"39\":1}}],[\"时事热点容易造成发评论的瞬间峰值流量\",{\"1\":{\"28\":1}}],[\"突出展示的产品形态\",{\"1\":{\"39\":1}}],[\"妙评\",{\"1\":{\"39\":1}}],[\"后线程\",{\"1\":{\"1455\":1}}],[\"后的\",{\"1\":{\"1439\":1}}],[\"后的状态\",{\"1\":{\"1283\":1}}],[\"后才能继续往下执行\",{\"1\":{\"1431\":1}}],[\"后才会从\",{\"1\":{\"1251\":1}}],[\"后将状态变量\",{\"1\":{\"1406\":1}}],[\"后虚拟机才可以使用处理器提供的\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"后需要等待数据库返回结果\",{\"1\":{\"1361\":1}}],[\"后再进行操作\",{\"1\":{\"1454\":1}}],[\"后再去理解\",{\"1\":{\"1348\":1}}],[\"后再减\",{\"1\":{\"328\":1}}],[\"后清除标志位\",{\"1\":{\"1336\":1}}],[\"后向环形搜索到可覆盖的\",{\"1\":{\"1317\":1}}],[\"后向环形查找未查找到可覆盖的\",{\"1\":{\"1317\":1}}],[\"后向环形查找未找到可覆盖的\",{\"1\":{\"1317\":2}}],[\"后向环形查找过程结束\",{\"1\":{\"1317\":2}}],[\"后向环形查找找到可覆盖的\",{\"1\":{\"1317\":2}}],[\"后以便于存放新的\",{\"1\":{\"1316\":1}}],[\"后该\",{\"1\":{\"1316\":1}}],[\"后调用\",{\"1\":{\"1315\":1}}],[\"后也会通过\",{\"1\":{\"1306\":1}}],[\"后接下来通过\",{\"1\":{\"1284\":1}}],[\"后队列的状态图\",{\"1\":{\"1285\":1}}],[\"后队列的状态\",{\"1\":{\"1283\":1}}],[\"后插入\",{\"1\":{\"1283\":1}}],[\"后使得线程\",{\"1\":{\"1253\":1}}],[\"后结束\",{\"1\":{\"1251\":1}}],[\"后会使得当前线程从等待队列中移至到同步队列中去\",{\"1\":{\"1251\":1}}],[\"后继节点不为null时唤醒该线程\",{\"1\":{\"1506\":1}}],[\"后继节点的线程处于等待状态\",{\"1\":{\"1501\":1}}],[\"后继节点\",{\"1\":{\"1250\":1}}],[\"后依然有序\",{\"0\":{\"1214\":1}}],[\"后者是语言级别的\",{\"1\":{\"1248\":1}}],[\"后者就会把相应的被依赖对象注入到被注入的对象中\",{\"1\":{\"1129\":1}}],[\"后者则会在栈中创建一个对象引用变量\",{\"1\":{\"1069\":1}}],[\"后移元素\",{\"1\":{\"1072\":1}}],[\"后组成的新字符串\",{\"1\":{\"838\":1}}],[\"后序遍历先遍历左右子树\",{\"1\":{\"901\":1}}],[\"后序遍历\",{\"0\":{\"748\":1,\"901\":1}}],[\"后期再做修改\",{\"1\":{\"596\":1}}],[\"后台服务安装\",{\"0\":{\"1090\":1}}],[\"后台启动\",{\"1\":{\"1087\":1}}],[\"后台给前端返回的数据包含\",{\"1\":{\"935\":1}}],[\"后台也都需要借助于数据库的分页操作\",{\"1\":{\"935\":1}}],[\"后台管理页面\",{\"0\":{\"590\":1}}],[\"后台运营管理\",{\"1\":{\"22\":1,\"45\":1}}],[\"后并没有出现\",{\"1\":{\"576\":1}}],[\"后\",{\"1\":{\"465\":1,\"531\":1,\"533\":1,\"540\":1,\"588\":1,\"833\":1,\"986\":1,\"1129\":2,\"1272\":1,\"1283\":1,\"1302\":1,\"1308\":2,\"1316\":1,\"1366\":1,\"1392\":1,\"1404\":1,\"1458\":1}}],[\"后进后出\",{\"1\":{\"408\":1}}],[\"后面依然有效\",{\"1\":{\"1393\":1}}],[\"后面就以此时这个位置\",{\"1\":{\"1317\":1}}],[\"后面几行是关键语句\",{\"1\":{\"1149\":1}}],[\"后面再申请的时候就很快了\",{\"1\":{\"672\":1}}],[\"后面的配置自行设置即可\",{\"1\":{\"670\":1}}],[\"后面配合\",{\"1\":{\"670\":1}}],[\"后面用户状态优化会提到\",{\"1\":{\"575\":1}}],[\"后面一位\",{\"1\":{\"324\":1}}],[\"后面例二中将会给出解决方法\",{\"1\":{\"271\":1}}],[\"后缀部分\",{\"1\":{\"309\":1}}],[\"后把\",{\"1\":{\"200\":1}}],[\"后端需要响应什么数据给前端\",{\"1\":{\"935\":1}}],[\"后端优化\",{\"0\":{\"597\":1}}],[\"后端从\",{\"1\":{\"575\":1}}],[\"后端拿到前端传来的\",{\"1\":{\"575\":1}}],[\"后端初始化\",{\"0\":{\"560\":1}}],[\"后端核心业务开发\",{\"0\":{\"521\":1}}],[\"后端万用模板\",{\"1\":{\"514\":1}}],[\"后端基础开发\",{\"0\":{\"514\":1}}],[\"后端开发\",{\"0\":{\"505\":1},\"1\":{\"505\":1}}],[\"后端开发工程师\",{\"1\":{\"75\":1}}],[\"后端代码\",{\"1\":{\"477\":1}}],[\"后端\",{\"0\":{\"449\":1,\"454\":1,\"460\":1,\"500\":1},\"1\":{\"502\":1,\"557\":1}}],[\"后端处理逻辑则在\",{\"1\":{\"447\":1,\"458\":1}}],[\"后端通过\",{\"1\":{\"447\":1}}],[\"后端服务器将点击数据写入消息队列\",{\"1\":{\"151\":1}}],[\"后一个字符串为模式字符串\",{\"1\":{\"127\":1}}],[\"后续讲到\",{\"1\":{\"1175\":1}}],[\"后续也会针对这五个部分进行分析\",{\"1\":{\"1141\":1}}],[\"后续通过注入\",{\"1\":{\"1100\":1}}],[\"后续通过调用\",{\"1\":{\"1100\":1}}],[\"后续可以通过\",{\"1\":{\"670\":1}}],[\"后续连续的请求\",{\"1\":{\"60\":1}}],[\"后续失败仅仅存在一条\",{\"1\":{\"56\":1}}],[\"后来衍生了更为复杂的热评\",{\"1\":{\"39\":1}}],[\"早期通知带来的问题\",{\"1\":{\"1406\":1}}],[\"早期通知\",{\"0\":{\"1406\":1}}],[\"早期\",{\"1\":{\"48\":1}}],[\"早期的热评\",{\"1\":{\"39\":1}}],[\"早年间评论显示楼层号\",{\"1\":{\"28\":1}}],[\"7正在消费数据906921688\",{\"1\":{\"1411\":1}}],[\"7正在消费数据1520577501\",{\"1\":{\"1411\":1}}],[\"7和1\",{\"1\":{\"1276\":1}}],[\"722\",{\"1\":{\"1221\":2}}],[\"7<\",{\"1\":{\"1209\":1}}],[\"79300058\",{\"1\":{\"1171\":1}}],[\"7976931348623157\",{\"1\":{\"920\":3}}],[\"78\",{\"1\":{\"980\":1}}],[\"783469249310599\",{\"1\":{\"41\":1}}],[\"777\",{\"1\":{\"920\":2}}],[\"75=1\",{\"1\":{\"1274\":1}}],[\"75\",{\"1\":{\"1271\":5,\"1274\":3,\"1306\":1}}],[\"75f\",{\"1\":{\"688\":1}}],[\"75vw\",{\"1\":{\"587\":1}}],[\"7−1=6\",{\"1\":{\"152\":1}}],[\"70\",{\"1\":{\"129\":1,\"984\":1,\"1317\":1}}],[\"7108973163333025805\",{\"1\":{\"41\":1}}],[\"7\",{\"0\":{\"39\":1,\"40\":1,\"41\":1,\"222\":1,\"248\":1,\"313\":1,\"314\":1,\"340\":1,\"363\":1,\"385\":1,\"417\":1,\"469\":1,\"470\":1,\"471\":1,\"482\":1,\"502\":1,\"633\":1,\"643\":1,\"935\":1,\"952\":1,\"953\":1,\"954\":1,\"955\":1,\"1025\":1,\"1026\":1,\"1027\":1,\"1028\":1,\"1029\":1,\"1030\":1,\"1031\":1,\"1032\":1,\"1033\":1,\"1034\":1,\"1048\":1,\"1141\":1,\"1169\":1,\"1340\":1},\"1\":{\"39\":1,\"41\":1,\"99\":2,\"109\":3,\"122\":1,\"133\":2,\"135\":1,\"139\":1,\"146\":2,\"152\":3,\"157\":1,\"167\":1,\"179\":1,\"193\":2,\"196\":1,\"205\":1,\"221\":1,\"224\":9,\"261\":4,\"273\":3,\"274\":1,\"279\":9,\"280\":1,\"289\":1,\"301\":2,\"308\":2,\"376\":1,\"663\":1,\"850\":2,\"852\":3,\"986\":1,\"990\":1,\"1000\":1,\"1001\":1,\"1158\":1,\"1259\":2,\"1272\":2,\"1276\":2,\"1283\":3,\"1284\":6,\"1316\":1,\"1317\":1,\"1337\":1,\"1386\":2,\"1398\":4,\"1444\":1,\"1496\":1}}],[\"实线代表强引用\",{\"1\":{\"1313\":1}}],[\"实参数量过多\",{\"1\":{\"1012\":1}}],[\"实参数量不足\",{\"1\":{\"1012\":1}}],[\"实参类型不正确\",{\"1\":{\"1012\":1}}],[\"实参是形参的初始值\",{\"1\":{\"1012\":1}}],[\"实例变量\",{\"1\":{\"1465\":1}}],[\"实例通过\",{\"1\":{\"1385\":1}}],[\"实例方法\",{\"1\":{\"1338\":1}}],[\"实例就没有一条引用链路可达\",{\"1\":{\"1313\":1}}],[\"实例就没有任何一条链路能够引用到它\",{\"1\":{\"1305\":1}}],[\"实例引用的\",{\"1\":{\"1309\":1}}],[\"实例包装成一个\",{\"1\":{\"1305\":1}}],[\"实例获取到它所维护的\",{\"1\":{\"1302\":1}}],[\"实例作为\",{\"1\":{\"1301\":1}}],[\"实例对象\",{\"1\":{\"1301\":1}}],[\"实例为\",{\"1\":{\"1301\":2,\"1302\":1,\"1303\":1,\"1305\":2}}],[\"实例的目的\",{\"1\":{\"1318\":1}}],[\"实例的\",{\"1\":{\"1306\":1,\"1385\":1}}],[\"实例的方法\",{\"1\":{\"1282\":1}}],[\"实例的配置\",{\"1\":{\"1153\":1}}],[\"实例构造器方法\",{\"0\":{\"1270\":1}}],[\"实例上获取配置信息\",{\"1\":{\"1158\":1}}],[\"实例信息发送给\",{\"1\":{\"1185\":1}}],[\"实例信息传给其他服务\",{\"1\":{\"1158\":1}}],[\"实例信息\",{\"1\":{\"1158\":1,\"1179\":1}}],[\"实例信息管理器\",{\"1\":{\"1152\":1}}],[\"实例化\",{\"1\":{\"1073\":1,\"1074\":1,\"1076\":1,\"1077\":1}}],[\"实例\",{\"1\":{\"979\":1,\"1025\":1,\"1283\":1,\"1306\":1}}],[\"实例基于\",{\"1\":{\"448\":1}}],[\"实测这种方案最为安全和稳定\",{\"1\":{\"664\":1}}],[\"实战\",{\"1\":{\"648\":1}}],[\"实体对象\",{\"1\":{\"567\":1}}],[\"实体类的\",{\"1\":{\"575\":1}}],[\"实体类\",{\"1\":{\"517\":1,\"1100\":1}}],[\"实时数据链路的多维动态带宽管控|京东零售技术实践\",{\"1\":{\"633\":1}}],[\"实时处理\",{\"1\":{\"434\":1}}],[\"实时性\",{\"1\":{\"151\":1}}],[\"实时性放大存储压力\",{\"1\":{\"40\":1}}],[\"实验能力等\",{\"1\":{\"40\":1}}],[\"实际大小\",{\"1\":{\"1272\":2}}],[\"实际大小n\",{\"1\":{\"1271\":1}}],[\"实际的\",{\"1\":{\"1267\":1}}],[\"实际上通过头尾指针来管理同步队列\",{\"1\":{\"1501\":1}}],[\"实际上都是调用了其静态内存类\",{\"1\":{\"1493\":1}}],[\"实际上包含了三个操作\",{\"1\":{\"1482\":1}}],[\"实际上就像是给\",{\"1\":{\"1456\":1}}],[\"实际上就是以当前\",{\"1\":{\"1305\":1}}],[\"实际上就是一个以\",{\"1\":{\"1305\":1}}],[\"实际上主要是包含了两类线程\",{\"1\":{\"1402\":1}}],[\"实际上这对应着锁的获取和释放两个操作\",{\"1\":{\"1501\":1}}],[\"实际上这也是线程池工作流程中最重要的两个关键因素\",{\"1\":{\"1370\":1}}],[\"实际上这样的设计思想在需要框架中都会使用\",{\"1\":{\"1359\":1}}],[\"实际上为scheduledfuturetask\",{\"1\":{\"1369\":1}}],[\"实际上没有存储任何数据元素\",{\"1\":{\"1326\":1}}],[\"实际上会调用\",{\"1\":{\"1317\":1}}],[\"实际上保存的是hashmap中的元素个数\",{\"1\":{\"1275\":1}}],[\"实际上\",{\"1\":{\"1224\":1,\"1259\":1,\"1264\":2,\"1270\":1,\"1292\":1,\"1314\":1,\"1330\":1,\"1380\":1,\"1418\":1,\"1475\":1}}],[\"实际上是将提交的任务转换成的\",{\"1\":{\"1368\":1}}],[\"实际上是\",{\"1\":{\"1068\":1}}],[\"实际上全都是在请求国内的服务器\",{\"1\":{\"664\":1}}],[\"实际上超时了\",{\"1\":{\"162\":1}}],[\"实际情况下\",{\"1\":{\"535\":1}}],[\"实际要执行的任务类\",{\"1\":{\"479\":1}}],[\"实际就是按照评论点赞数降序\",{\"1\":{\"39\":1}}],[\"实际也会从计数上删除其回复\",{\"1\":{\"37\":1}}],[\"实现超时等待的效果\",{\"1\":{\"1508\":1}}],[\"实现同步组件时推荐定义继承\",{\"1\":{\"1496\":1}}],[\"实现中会有\",{\"1\":{\"1438\":1}}],[\"实现类有很多\",{\"1\":{\"1438\":1}}],[\"实现类是\",{\"1\":{\"1076\":1}}],[\"实现生产者和消费者代码如下\",{\"1\":{\"1409\":1}}],[\"实现生产者\",{\"0\":{\"1409\":1,\"1410\":1,\"1411\":1},\"1\":{\"1411\":1}}],[\"实现callable接口\",{\"1\":{\"1330\":1}}],[\"实现runable接口\",{\"1\":{\"1330\":2}}],[\"实现清理掉\",{\"1\":{\"1318\":1}}],[\"实现赋值为其他的初始值\",{\"1\":{\"1302\":1}}],[\"实现依然是采用\",{\"1\":{\"1264\":1}}],[\"实现原理为\",{\"1\":{\"1433\":1}}],[\"实现原理详解\",{\"0\":{\"1343\":1}}],[\"实现原理\",{\"0\":{\"1251\":1,\"1252\":1,\"1345\":1,\"1349\":1,\"1356\":1,\"1430\":1,\"1454\":1}}],[\"实现原理分析\",{\"0\":{\"1249\":1}}],[\"实现共享式同步组件的同步语义需要通过重写\",{\"1\":{\"1242\":1}}],[\"实现本地缓存\",{\"0\":{\"1202\":1,\"1205\":1,\"1208\":1}}],[\"实现本地缓存的几种方式\",{\"0\":{\"1199\":1}}],[\"实现思路其实很简单\",{\"1\":{\"1201\":1}}],[\"实现对\",{\"1\":{\"1082\":1}}],[\"实现对数据的访问控制\",{\"1\":{\"471\":1}}],[\"实现的是\",{\"1\":{\"1326\":1}}],[\"实现的代码量会更少\",{\"1\":{\"1286\":1}}],[\"实现的新一代缓存工具\",{\"1\":{\"1205\":1}}],[\"实现的\",{\"1\":{\"1072\":1}}],[\"实现多线程\",{\"0\":{\"1059\":1}}],[\"实现关系\",{\"1\":{\"939\":1}}],[\"实现trie\",{\"1\":{\"800\":1}}],[\"实现无差别存取\",{\"1\":{\"669\":1}}],[\"实现删除用户接口\",{\"1\":{\"579\":1}}],[\"实现查询用户接口\",{\"1\":{\"578\":1}}],[\"实现接口的调用\",{\"1\":{\"576\":1}}],[\"实现序列化接口\",{\"1\":{\"576\":1}}],[\"实现业务逻辑\",{\"1\":{\"555\":1}}],[\"实现基础功能的\",{\"1\":{\"513\":1}}],[\"实现job接口\",{\"1\":{\"477\":1}}],[\"实现动态管理任务\",{\"1\":{\"475\":1}}],[\"实现了\",{\"1\":{\"1151\":1,\"1178\":1,\"1326\":1,\"1365\":1,\"1367\":1,\"1375\":1}}],[\"实现了这些\",{\"1\":{\"1150\":1}}],[\"实现了快速的页面切换和复杂交互\",{\"1\":{\"532\":1}}],[\"实现了构建数据范围\",{\"1\":{\"471\":1}}],[\"实现了一套声明式规则语法\",{\"1\":{\"40\":1}}],[\"实现此功能的前端代码位于\",{\"1\":{\"458\":1}}],[\"实现增删改查操作\",{\"1\":{\"452\":1}}],[\"实现一些简洁的操作\",{\"1\":{\"257\":1}}],[\"实现简单的正则表达式匹配\",{\"0\":{\"127\":1}}],[\"实现起来太复杂而且很容易出错\",{\"1\":{\"60\":1}}],[\"实现上\",{\"1\":{\"46\":1}}],[\"实现并发提效\",{\"1\":{\"40\":1}}],[\"实现\",{\"0\":{\"485\":1,\"800\":1},\"1\":{\"28\":1,\"129\":4,\"200\":1,\"525\":1,\"599\":1,\"686\":1,\"742\":1,\"789\":1,\"1036\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1059\":1,\"1324\":2,\"1326\":1,\"1330\":2,\"1402\":1,\"1438\":1}}],[\"锁和同步器很好的隔离了使用者和实现者所需关注的领域\",{\"1\":{\"1494\":1}}],[\"锁是面向使用者\",{\"1\":{\"1494\":1}}],[\"锁是用来控制多个线程访问共享资源的方式\",{\"1\":{\"1492\":1}}],[\"锁定\",{\"1\":{\"1482\":1}}],[\"锁就会膨胀成重量级锁\",{\"1\":{\"1447\":1}}],[\"锁不仅不存在多线程竞争\",{\"1\":{\"1441\":1}}],[\"锁可以升级但不能降级\",{\"1\":{\"1440\":1}}],[\"锁一共有\",{\"1\":{\"1440\":1}}],[\"锁获取和锁释放的内存语义\",{\"0\":{\"1433\":1}}],[\"锁住的依然是该类的类对象\",{\"1\":{\"1431\":1}}],[\"锁住的是类对象\",{\"1\":{\"1431\":1}}],[\"锁住\",{\"1\":{\"1276\":1}}],[\"锁降级\",{\"0\":{\"1244\":1},\"1\":{\"1237\":1}}],[\"锁未被完全释放\",{\"1\":{\"1232\":1}}],[\"锁成功被释放\",{\"1\":{\"1232\":1}}],[\"锁加到了\",{\"1\":{\"1062\":1}}],[\"锁\",{\"0\":{\"1061\":1}}],[\"锁冲突\",{\"1\":{\"37\":1}}],[\"锁放大\",{\"1\":{\"37\":1}}],[\"越少越好\",{\"1\":{\"576\":1}}],[\"越界\",{\"1\":{\"229\":1}}],[\"越容易出现\",{\"1\":{\"37\":1}}],[\"越需要加锁的场景\",{\"1\":{\"37\":1}}],[\"即能成功获得同步状态\",{\"1\":{\"1510\":1}}],[\"即能看到\",{\"1\":{\"1476\":1}}],[\"即与队列断开\",{\"1\":{\"1505\":1}}],[\"即该同步组件没被任何线程获取\",{\"1\":{\"1496\":1}}],[\"即该旧值\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"即禁止\",{\"1\":{\"1476\":1}}],[\"即一直引用这个对象\",{\"1\":{\"1467\":1}}],[\"即一个类中的成员变量就是这几个共享变量\",{\"1\":{\"1439\":1}}],[\"即一个无符号整型类型\",{\"1\":{\"252\":1}}],[\"即满足数据的\",{\"1\":{\"1455\":1}}],[\"即不会出现数据脏读的现象\",{\"1\":{\"1453\":1}}],[\"即表现为互斥性\",{\"1\":{\"1434\":1}}],[\"即表现为当\",{\"1\":{\"1283\":2}}],[\"即监视器锁规则\",{\"1\":{\"1432\":1}}],[\"即同一时刻只有一个线程能够获取到\",{\"1\":{\"1431\":1}}],[\"即同一时刻该锁可以被多个读线程获取也就是一种共享式锁\",{\"1\":{\"1242\":1}}],[\"即线程阻塞时该线程被中断\",{\"1\":{\"1507\":1}}],[\"即线程之间保证同步关系\",{\"1\":{\"1430\":1}}],[\"即线段树\",{\"1\":{\"168\":1}}],[\"即执行结果不能被改变\",{\"1\":{\"1420\":1}}],[\"即执行一条\",{\"1\":{\"954\":1}}],[\"即唤醒的是同类线程\",{\"1\":{\"1408\":1}}],[\"即在同一锁程中\",{\"1\":{\"1431\":1}}],[\"即在调用前\",{\"1\":{\"1404\":1}}],[\"即在数组中选择一些元素\",{\"1\":{\"178\":1}}],[\"即只能在同步方法或同步块中调用\",{\"1\":{\"1404\":1}}],[\"即发生了数据交换\",{\"1\":{\"1399\":1}}],[\"即假设每一次执行临界区代码都会产生冲突\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"即获取到对象的锁\",{\"1\":{\"1440\":1}}],[\"即获取到lock\",{\"1\":{\"1251\":1}}],[\"即获取数组中的数据元素\",{\"1\":{\"1348\":1}}],[\"即完成出队操作\",{\"1\":{\"1348\":1}}],[\"即往数组中添加数据\",{\"1\":{\"1347\":1}}],[\"即等待获取锁的时候\",{\"1\":{\"1334\":1}}],[\"即等待队列中的头结点\",{\"1\":{\"1250\":1}}],[\"即遇到脏\",{\"1\":{\"1317\":1}}],[\"即内存占用问题和数据一致性问题\",{\"1\":{\"1295\":1}}],[\"即读线程对数据的更新是延时感知的\",{\"1\":{\"1295\":1}}],[\"即读线程任何时候都是获取到最新的数据\",{\"1\":{\"1291\":1}}],[\"即写时复制的思想\",{\"1\":{\"1291\":1}}],[\"即中间总是间隔了一个\",{\"1\":{\"1286\":1}}],[\"即对\",{\"1\":{\"1285\":1}}],[\"即那一时刻就可以称之为\",{\"1\":{\"1283\":1}}],[\"即那个正方形的边必须和\",{\"1\":{\"263\":1}}],[\"即插入\",{\"1\":{\"1272\":1}}],[\"即正在初始化的状态\",{\"1\":{\"1271\":1}}],[\"即32\",{\"1\":{\"1270\":1}}],[\"即数组长度为默认初始值\",{\"1\":{\"1266\":1}}],[\"即从\",{\"1\":{\"1252\":1}}],[\"即另外线程调用的\",{\"1\":{\"1251\":1}}],[\"即取同步状态的高\",{\"1\":{\"1239\":1}}],[\"即取同步状态的低\",{\"1\":{\"1239\":1}}],[\"即出现脏读\",{\"1\":{\"1237\":1}}],[\"即时将所有的像素遍历一边都需要很长的时间\",{\"1\":{\"1218\":1}}],[\"即依赖注入\",{\"1\":{\"1129\":1}}],[\"即丢失一半数量的硬盘的情况下仍能保证数据的安全性\",{\"1\":{\"1095\":1}}],[\"即输出到\",{\"1\":{\"1087\":1}}],[\"即索引\",{\"1\":{\"971\":1}}],[\"即这些操作要么同时成功\",{\"1\":{\"953\":1}}],[\"即这个迭代器是去重之后末尾元素的下一个位置\",{\"1\":{\"423\":1}}],[\"即自底向上计算子问题的过程\",{\"1\":{\"901\":1}}],[\"即自底向上递推计算\",{\"1\":{\"796\":1}}],[\"即路径节点\",{\"1\":{\"875\":1}}],[\"即最先等待的线程能够最先访问到\",{\"1\":{\"1326\":1}}],[\"即最外层\",{\"1\":{\"869\":1}}],[\"即最小值最大问题\",{\"1\":{\"162\":1}}],[\"即需要知道下标和值\",{\"1\":{\"851\":1}}],[\"即形如\",{\"1\":{\"846\":1}}],[\"即左子树最深节点和右子树最深节点的距离\",{\"1\":{\"760\":1}}],[\"即逐层地\",{\"1\":{\"741\":1}}],[\"即当前线程是第一次插入同步队列\",{\"1\":{\"1504\":1}}],[\"即当前线程获取该锁再次获取不会被阻塞\",{\"1\":{\"1231\":1}}],[\"即当前节点的父节点\",{\"1\":{\"731\":1}}],[\"即当前位置能填哪些数\",{\"1\":{\"288\":1}}],[\"即当\",{\"1\":{\"688\":1,\"1285\":1}}],[\"即存储在安装\",{\"1\":{\"670\":1}}],[\"即使在多个线程一起执行的时候\",{\"1\":{\"1482\":1}}],[\"即使corepoolsize=0\",{\"1\":{\"1370\":1}}],[\"即使当前核心线程池有空闲的线程\",{\"1\":{\"1359\":1}}],[\"即使负载因子和\",{\"1\":{\"1272\":1}}],[\"即使你退出了终端或关闭了会话\",{\"1\":{\"1087\":1}}],[\"即使两个形参的类型一样\",{\"1\":{\"1013\":1}}],[\"即使用变形后的后序遍历\",{\"1\":{\"725\":1}}],[\"即使客户端浏览器不支持\",{\"1\":{\"533\":1}}],[\"即使某个节点出现问题\",{\"1\":{\"484\":1}}],[\"即湖仓一体\",{\"1\":{\"438\":1}}],[\"即小根堆\",{\"1\":{\"417\":1}}],[\"即sg\",{\"1\":{\"398\":1}}],[\"即两人均无失误\",{\"1\":{\"394\":1}}],[\"即用二进制来表示\",{\"1\":{\"381\":1}}],[\"即组合成\",{\"1\":{\"381\":1}}],[\"即找到了\",{\"1\":{\"373\":1}}],[\"即源码取反加\",{\"1\":{\"339\":1}}],[\"即除以\",{\"1\":{\"338\":1}}],[\"即乘上\",{\"1\":{\"338\":1}}],[\"即得\",{\"1\":{\"338\":1}}],[\"即table数组还未初始化\",{\"1\":{\"1270\":1}}],[\"即t\",{\"1\":{\"328\":1}}],[\"即继续让j入队的话依然无解\",{\"1\":{\"223\":1}}],[\"即队列中存在比d\",{\"1\":{\"221\":1}}],[\"即选择元素\",{\"1\":{\"178\":1}}],[\"即为数组实际大小\",{\"1\":{\"1271\":1}}],[\"即为\",{\"1\":{\"388\":1,\"1239\":1}}],[\"即为最大总预计消费金额\",{\"1\":{\"162\":1}}],[\"即为所求的最少完全平方数的数量\",{\"1\":{\"115\":1}}],[\"即为所求\",{\"1\":{\"110\":1}}],[\"即每个线程都拥有该变量副本\",{\"1\":{\"1299\":1}}],[\"即每个桌子可容纳的最大人数\",{\"1\":{\"162\":1}}],[\"即每个窗口中\",{\"1\":{\"61\":1}}],[\"即要求\",{\"1\":{\"147\":1}}],[\"即要实现\",{\"1\":{\"40\":1}}],[\"即什么都不选\",{\"1\":{\"135\":1}}],[\"即将其\",{\"1\":{\"1316\":1}}],[\"即将\",{\"1\":{\"104\":1,\"237\":1}}],[\"即和它的序偶性相同\",{\"1\":{\"87\":1}}],[\"即便\",{\"1\":{\"56\":1}}],[\"即可以获得独占式锁\",{\"1\":{\"1504\":1}}],[\"即可以获取当前最新值\",{\"1\":{\"1454\":1}}],[\"即可用容量为\",{\"1\":{\"1306\":1}}],[\"即可启动\",{\"1\":{\"559\":1}}],[\"即可正常显示\",{\"1\":{\"540\":1}}],[\"即可得到最终的花费时间\",{\"1\":{\"869\":1}}],[\"即可得到\",{\"1\":{\"338\":3}}],[\"即可计算出该正方形内所有目标的价值之和\",{\"1\":{\"263\":1}}],[\"即可\",{\"1\":{\"56\":1,\"291\":1,\"323\":1,\"576\":1,\"672\":2,\"783\":1,\"846\":2,\"888\":1,\"927\":2,\"1087\":1,\"1100\":1,\"1251\":1,\"1301\":1,\"1383\":1,\"1437\":1,\"1496\":2}}],[\"即某个评论主题的数据都在一个分区里\",{\"1\":{\"49\":1}}],[\"即如果存储\",{\"1\":{\"49\":1}}],[\"即\",{\"1\":{\"48\":1,\"56\":1,\"71\":1,\"120\":1,\"135\":1,\"194\":1,\"215\":1,\"243\":1,\"252\":2,\"261\":2,\"338\":3,\"339\":2,\"394\":2,\"397\":1,\"398\":1,\"399\":1,\"438\":1,\"692\":1,\"795\":3,\"801\":1,\"840\":1,\"846\":1,\"851\":2,\"893\":3,\"899\":1,\"958\":1,\"1045\":1,\"1131\":1,\"1239\":2,\"1242\":1,\"1252\":1,\"1270\":1,\"1274\":1,\"1283\":3,\"1306\":1,\"1316\":1,\"1336\":1,\"1406\":1,\"1411\":1,\"1418\":2,\"1421\":1,\"1449\":1,\"1478\":1,\"1501\":1,\"1504\":1,\"1508\":1,\"1511\":1}}],[\"即先通过策略工程\",{\"1\":{\"40\":1}}],[\"即reddit\",{\"1\":{\"40\":1}}],[\"即+1\",{\"1\":{\"37\":1}}],[\"即是一个常量\",{\"1\":{\"1467\":1}}],[\"即是\",{\"1\":{\"28\":1}}],[\"甚至会使得系统崩溃\",{\"1\":{\"1361\":1}}],[\"甚至在极端情况下\",{\"1\":{\"1272\":1}}],[\"甚至在一些数据库开发规范中\",{\"1\":{\"937\":1}}],[\"甚至很臭\",{\"1\":{\"1250\":1}}],[\"甚至拥有多达\",{\"1\":{\"1218\":1}}],[\"甚至凤姐哪款的\",{\"1\":{\"1133\":1}}],[\"甚至无法访问\",{\"1\":{\"661\":1}}],[\"甚至\",{\"1\":{\"438\":1}}],[\"甚至可以直接被数仓使用\",{\"1\":{\"438\":1}}],[\"甚至可以整合端上\",{\"1\":{\"51\":1}}],[\"甚至更多\",{\"1\":{\"434\":1}}],[\"甚至直接忽略\",{\"1\":{\"37\":1}}],[\"甚至新功能上线\",{\"1\":{\"37\":1}}],[\"列子查询\",{\"0\":{\"949\":1},\"1\":{\"947\":1}}],[\"列col\",{\"1\":{\"385\":1}}],[\"列的状态是\",{\"1\":{\"311\":1}}],[\"列的像素都是海洋\",{\"1\":{\"280\":1}}],[\"列的格子中的数字为\",{\"1\":{\"196\":1}}],[\"列\",{\"1\":{\"228\":1,\"237\":1,\"280\":2,\"385\":1}}],[\"列表里面\",{\"1\":{\"1193\":1}}],[\"列表去批量查询评论内容了\",{\"1\":{\"58\":1}}],[\"列表\",{\"0\":{\"1072\":1},\"1\":{\"58\":1}}],[\"列表后\",{\"1\":{\"36\":1}}],[\"列出容量计算的数学公式\",{\"1\":{\"33\":1}}],[\"中需要重写的方法\",{\"1\":{\"1495\":1}}],[\"中需要一个\",{\"1\":{\"1132\":1}}],[\"中并没有多少代码\",{\"1\":{\"1493\":1}}],[\"中变量\",{\"1\":{\"1464\":1}}],[\"中偏向锁的标识是否设置成\",{\"1\":{\"1442\":1}}],[\"中提供的八个包装类和\",{\"1\":{\"1472\":1}}],[\"中提供了\",{\"1\":{\"1439\":1}}],[\"中提交任务后\",{\"1\":{\"1371\":1}}],[\"中在执行完同步代码块之后紧接着再会去执行一个静态同步方法\",{\"1\":{\"1431\":1}}],[\"中关键字\",{\"1\":{\"1429\":1}}],[\"中给出的定义如下\",{\"1\":{\"1415\":1}}],[\"中元素的代码\",{\"1\":{\"1407\":1}}],[\"中插入数据后\",{\"1\":{\"1407\":1}}],[\"中调用\",{\"1\":{\"1406\":1}}],[\"中则是使用\",{\"1\":{\"1380\":1}}],[\"中则是\",{\"1\":{\"1371\":1}}],[\"中实际上为\",{\"1\":{\"1371\":1}}],[\"中实现堆栈数据结构\",{\"1\":{\"1075\":1}}],[\"中为了实现可延时执行任务和周期性执行任务的特性\",{\"1\":{\"1371\":1}}],[\"中任务是指实现了\",{\"1\":{\"1371\":1}}],[\"中还有另外的一个重要的类就是\",{\"1\":{\"1369\":1}}],[\"中和短\",{\"1\":{\"1361\":1}}],[\"中和低\",{\"1\":{\"1361\":1}}],[\"中断操作可以看做线程间一种简便的交互方式\",{\"1\":{\"1336\":1}}],[\"中断好比其他线程对该线程打了一个招呼\",{\"1\":{\"1336\":1}}],[\"中断可以理解为线程的一个标志位\",{\"1\":{\"1336\":1}}],[\"中断或者到了某个时间\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"中断或者超时\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"中进行获取数据即可\",{\"1\":{\"1324\":1}}],[\"中讲到\",{\"1\":{\"1306\":1}}],[\"中使用的分离链表法\",{\"1\":{\"1306\":1}}],[\"中使用开放寻址法来处理散列冲突\",{\"1\":{\"1306\":1}}],[\"中使用当前类的成员函数和成员变量\",{\"1\":{\"255\":1}}],[\"中就会出现\",{\"1\":{\"1305\":1}}],[\"中存放\",{\"1\":{\"1305\":1}}],[\"中对\",{\"1\":{\"1282\":1}}],[\"中对应原积分的列表中删除该玩家\",{\"1\":{\"129\":2}}],[\"中对应积分的列表中删除该玩家\",{\"1\":{\"129\":2}}],[\"中定位到具体的桶\",{\"1\":{\"1276\":1}}],[\"中通过\",{\"1\":{\"1272\":1,\"1309\":1,\"1315\":1}}],[\"中待插入的索引\",{\"1\":{\"1272\":1}}],[\"中会调用方法\",{\"1\":{\"1511\":1}}],[\"中会将任务转换成\",{\"1\":{\"1371\":1}}],[\"中会持续监测\",{\"1\":{\"1336\":1}}],[\"中会大量使用\",{\"1\":{\"1268\":1}}],[\"中会使用一个标记数组\",{\"1\":{\"228\":1}}],[\"中有几个关键的属性和类\",{\"1\":{\"1265\":1}}],[\"中有两个成员变量\",{\"1\":{\"1250\":1}}],[\"中逻辑判断为\",{\"1\":{\"1251\":1}}],[\"中最核心的部分\",{\"1\":{\"1141\":1}}],[\"中最多只包含一个大于\",{\"1\":{\"368\":1}}],[\"中自己编写代码来获得一个\",{\"1\":{\"1132\":1}}],[\"中查询一个\",{\"1\":{\"1131\":1}}],[\"中查找小于等于\",{\"1\":{\"423\":1}}],[\"中查找大于等于\",{\"1\":{\"423\":1}}],[\"中常见的\",{\"1\":{\"1107\":1}}],[\"中配置\",{\"1\":{\"1100\":1}}],[\"中配置全局逻辑删除属性\",{\"1\":{\"575\":2}}],[\"中文文档地址\",{\"1\":{\"1095\":1}}],[\"中文官网\",{\"1\":{\"1093\":1}}],[\"中新增了一个\",{\"1\":{\"1082\":1}}],[\"中新积分对应的列表\",{\"1\":{\"129\":2}}],[\"中也可以使用\",{\"1\":{\"1077\":1}}],[\"中键如果是基本数据类型\",{\"1\":{\"1074\":1}}],[\"中标准的对象创建方式\",{\"1\":{\"1069\":1}}],[\"中注解占据了更重要的角色\",{\"1\":{\"1051\":1}}],[\"中所有偶数的和\",{\"1\":{\"993\":1}}],[\"中所有数的立方和\",{\"1\":{\"988\":1,\"990\":1}}],[\"中不同类型变量的输出格式\",{\"1\":{\"982\":1}}],[\"中间延时时间间隔为delay\",{\"1\":{\"1367\":1}}],[\"中间表至少包含两个外键\",{\"1\":{\"939\":1}}],[\"中间件流式消费\",{\"1\":{\"50\":1}}],[\"中间件解决了异构网络环境下软件互联和互操作等共性问题\",{\"1\":{\"14\":1}}],[\"中间件与操作系统和数据库共同构成基础软件三大支柱\",{\"1\":{\"14\":1}}],[\"中间件不仅仅实现互连\",{\"1\":{\"14\":1}}],[\"中间件是一类软件统称\",{\"1\":{\"14\":1}}],[\"中间件在客户服务器的操作系统\",{\"1\":{\"14\":1}}],[\"中间件\",{\"0\":{\"14\":1},\"1\":{\"14\":1},\"2\":{\"1091\":1,\"1096\":1,\"1104\":1}}],[\"中是\",{\"1\":{\"935\":1}}],[\"中是否包含和\",{\"1\":{\"186\":1}}],[\"中等长度文本数据\",{\"1\":{\"920\":1}}],[\"中数据库的常见操作\",{\"1\":{\"911\":1}}],[\"中序建树\",{\"1\":{\"766\":1}}],[\"中序遍历很好地利用了二叉搜索树的性质\",{\"1\":{\"900\":1}}],[\"中序遍历即层序遍历\",{\"1\":{\"900\":1}}],[\"中序遍历性质\",{\"1\":{\"766\":1}}],[\"中序遍历\",{\"0\":{\"900\":1},\"1\":{\"729\":1,\"766\":1}}],[\"中序\",{\"1\":{\"729\":1,\"767\":1}}],[\"中快速找某个\",{\"1\":{\"687\":1}}],[\"中下载已构建打包好的压缩包\",{\"1\":{\"670\":1}}],[\"中来自\",{\"1\":{\"664\":1}}],[\"中安装\",{\"1\":{\"664\":1}}],[\"中这\",{\"1\":{\"613\":1}}],[\"中上面的\",{\"1\":{\"592\":1}}],[\"中添加如下配置\",{\"1\":{\"672\":1}}],[\"中添加如下重定向配置\",{\"1\":{\"587\":1}}],[\"中添加路由规则\",{\"1\":{\"592\":1}}],[\"中添加调用的接口地址\",{\"1\":{\"589\":1}}],[\"中添加登录请求参数\",{\"1\":{\"589\":1}}],[\"中可以取出基于该\",{\"1\":{\"575\":1}}],[\"中心仓库寻找\",{\"1\":{\"560\":1}}],[\"中复制来的布局代码\",{\"1\":{\"548\":1}}],[\"中引用\",{\"1\":{\"526\":1}}],[\"中编写一个通用的分页获取题目列表的方法\",{\"1\":{\"525\":1}}],[\"中补充\",{\"1\":{\"525\":1}}],[\"中修改前端登录逻辑\",{\"1\":{\"589\":1}}],[\"中修改\",{\"1\":{\"523\":1}}],[\"中遍历动态路由菜单在页面显示\",{\"1\":{\"463\":1}}],[\"中加载\",{\"1\":{\"463\":1}}],[\"中能整除\",{\"1\":{\"392\":1}}],[\"中能被\",{\"1\":{\"392\":1}}],[\"中至少一个数整除的整数有多少个\",{\"1\":{\"392\":1}}],[\"中p的次数是\",{\"1\":{\"390\":1}}],[\"中国剩余定理\",{\"0\":{\"384\":1}}],[\"中计算过了\",{\"1\":{\"380\":1}}],[\"中与\",{\"1\":{\"379\":1}}],[\"中找到最长的序列\",{\"1\":{\"851\":1}}],[\"中找到\",{\"1\":{\"324\":2}}],[\"中含有空字符\",{\"1\":{\"243\":1}}],[\"中删除该\",{\"1\":{\"1303\":1}}],[\"中删除数据\",{\"1\":{\"1303\":1}}],[\"中删除\",{\"1\":{\"215\":1}}],[\"中选取优先级最高的节点\",{\"1\":{\"215\":1}}],[\"中选择一个数\",{\"1\":{\"156\":1}}],[\"中玩家的积分\",{\"1\":{\"129\":2}}],[\"中获取玩家积分\",{\"1\":{\"129\":2}}],[\"中获取玩家积分并删除玩家\",{\"1\":{\"129\":2}}],[\"中获取玩家原积分\",{\"1\":{\"129\":2}}],[\"中仅包含\",{\"1\":{\"77\":1}}],[\"中\",{\"0\":{\"563\":1,\"1410\":1},\"1\":{\"46\":1,\"49\":1,\"50\":2,\"129\":1,\"146\":1,\"215\":6,\"318\":1,\"320\":1,\"447\":1,\"458\":1,\"481\":1,\"482\":1,\"542\":1,\"563\":1,\"783\":1,\"839\":1,\"840\":2,\"852\":1,\"857\":1,\"868\":1,\"869\":1,\"1051\":1,\"1053\":1,\"1075\":1,\"1149\":1,\"1151\":1,\"1178\":1,\"1221\":1,\"1258\":1,\"1267\":1,\"1274\":1,\"1283\":1,\"1301\":1,\"1304\":1,\"1313\":1,\"1315\":1,\"1324\":1,\"1359\":1,\"1368\":1,\"1404\":1,\"1406\":1,\"1410\":2,\"1440\":1,\"1469\":1,\"1495\":1}}],[\"中的同步队列则是通过链式方式进行实现\",{\"1\":{\"1501\":1}}],[\"中的同步队列是一种什么样的数据结构\",{\"1\":{\"1500\":1}}],[\"中的模板方法\",{\"1\":{\"1495\":1}}],[\"中的两个示意图帮助理解\",{\"1\":{\"1457\":1}}],[\"中的任意操作\",{\"1\":{\"1421\":2}}],[\"中的散列值分散的十分均匀\",{\"1\":{\"1306\":1}}],[\"中的键值对\",{\"1\":{\"1302\":1}}],[\"中的位置\",{\"1\":{\"1272\":1}}],[\"中的方法\",{\"1\":{\"1493\":1}}],[\"中的方法不多\",{\"1\":{\"1259\":1}}],[\"中的方法实现同步组件的同步语义\",{\"1\":{\"1239\":1}}],[\"中的方法在\",{\"1\":{\"1077\":1}}],[\"中的值\",{\"1\":{\"1178\":1}}],[\"中的配置读取后\",{\"1\":{\"1178\":1}}],[\"中的语法\",{\"1\":{\"1107\":1}}],[\"中的语句\",{\"1\":{\"986\":1}}],[\"中的命令行可以看成是一个\",{\"1\":{\"1107\":1}}],[\"中的元素复制到\",{\"1\":{\"1274\":1}}],[\"中的元素和\",{\"1\":{\"1074\":1}}],[\"中的元素必须有时序\",{\"1\":{\"687\":1}}],[\"中的子串\",{\"1\":{\"1005\":1}}],[\"中的条件表达式作用一样\",{\"1\":{\"990\":1}}],[\"中的内容为可选参数\",{\"1\":{\"918\":1}}],[\"中的一个节点\",{\"1\":{\"820\":1}}],[\"中的单词完成分割\",{\"1\":{\"784\":1}}],[\"中的单词表示\",{\"1\":{\"783\":1}}],[\"中的某个\",{\"1\":{\"687\":1}}],[\"中的某个字符替换为另一个字符\",{\"1\":{\"306\":1}}],[\"中的某个字符删除\",{\"1\":{\"306\":1}}],[\"中的文件\",{\"1\":{\"674\":1}}],[\"中的盐值和密码混淆都是用来提高密码安全性的防护措施\",{\"1\":{\"568\":1}}],[\"中的样式\",{\"1\":{\"540\":1}}],[\"中的登录按钮\",{\"1\":{\"448\":1}}],[\"中的次数\",{\"1\":{\"390\":1}}],[\"中的所有质数\",{\"1\":{\"371\":1,\"994\":1}}],[\"中的每个单词\",{\"1\":{\"783\":1}}],[\"中的每个数加上c\",{\"1\":{\"334\":1}}],[\"中的每个字符\",{\"1\":{\"93\":1}}],[\"中的字符全部取反\",{\"1\":{\"120\":1}}],[\"中的数据最终是面向运营体系提供服务能力\",{\"1\":{\"50\":1}}],[\"中的数据被\",{\"1\":{\"50\":1}}],[\"中的\",{\"1\":{\"36\":1,\"322\":2,\"448\":4,\"453\":3,\"459\":3,\"592\":1,\"613\":1,\"688\":1,\"748\":1,\"1082\":1,\"1100\":1,\"1132\":1,\"1138\":1,\"1150\":1,\"1239\":1,\"1250\":1,\"1251\":1,\"1266\":1,\"1274\":1,\"1276\":1,\"1305\":1}}],[\"提出\",{\"1\":{\"1420\":1}}],[\"提出了较高要求\",{\"1\":{\"36\":1}}],[\"提取从0开始的5个字符\",{\"1\":{\"1117\":1}}],[\"提取子串\",{\"1\":{\"1117\":1}}],[\"提取bfs方法\",{\"1\":{\"870\":1}}],[\"提交一个任务后\",{\"1\":{\"1370\":1}}],[\"提交异步任务的基础功能\",{\"1\":{\"1365\":1}}],[\"提交任务后执行过程是怎样的\",{\"1\":{\"1359\":1}}],[\"提交给\",{\"1\":{\"1330\":2}}],[\"提交事务\",{\"1\":{\"954\":2}}],[\"提交的参与与定义的不同这里需要转化一下\",{\"1\":{\"592\":1}}],[\"提速10倍\",{\"1\":{\"628\":1}}],[\"提效\",{\"1\":{\"628\":1}}],[\"提升系统响应速度\",{\"1\":{\"1357\":1}}],[\"提升应用性能\",{\"1\":{\"1218\":1}}],[\"提升性能\",{\"1\":{\"543\":1}}],[\"提升了用户体验\",{\"1\":{\"533\":1}}],[\"提升了特征读取的稳定性与性能上限\",{\"1\":{\"40\":1}}],[\"提高线程的可管理性\",{\"1\":{\"1357\":1}}],[\"提高数据查询的效率\",{\"1\":{\"957\":1}}],[\"提高网站在搜索结果中的排名\",{\"1\":{\"533\":1}}],[\"提高了系统的性能和安全性\",{\"1\":{\"493\":1}}],[\"提示\",{\"1\":{\"58\":1,\"133\":1,\"147\":1,\"471\":1,\"525\":1,\"526\":1,\"672\":1,\"1089\":1}}],[\"提供出来的模板方法\",{\"1\":{\"1500\":1}}],[\"提供带参的构造器用于初始化类的成员变量\",{\"1\":{\"1472\":1}}],[\"提供强大的事件机制\",{\"1\":{\"1140\":1}}],[\"提供国际化的标准访问策略\",{\"1\":{\"1140\":1}}],[\"提供一个mm\",{\"1\":{\"1131\":1}}],[\"提供各种常用字符串\",{\"1\":{\"568\":1}}],[\"提供接口访问\",{\"1\":{\"557\":1}}],[\"提供了这样的构造方法\",{\"1\":{\"1393\":1}}],[\"提供了启动和取消异步任务\",{\"1\":{\"1375\":1}}],[\"提供了可阻塞的插入和移除的方法\",{\"1\":{\"1324\":1}}],[\"提供了线程安全的保障\",{\"1\":{\"1264\":1}}],[\"提供了一个关键字\",{\"1\":{\"919\":1}}],[\"提供了以下5种约束\",{\"1\":{\"919\":1}}],[\"提供了\",{\"1\":{\"668\":1}}],[\"提供了更快的加载速度和更好的搜索引擎优化\",{\"1\":{\"533\":1}}],[\"提供了全面的安全认证和授权的支持\",{\"1\":{\"445\":1}}],[\"提供更好的用户体验\",{\"1\":{\"532\":1}}],[\"提供的模板方法实现同步组件语义\",{\"1\":{\"1500\":1}}],[\"提供的模板方法实现自己的同步语义\",{\"1\":{\"1495\":1}}],[\"提供的模板方法\",{\"1\":{\"1496\":1}}],[\"提供的模板方法可以分为\",{\"1\":{\"1495\":1}}],[\"提供的模板方法如下图\",{\"1\":{\"1495\":1}}],[\"提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法\",{\"1\":{\"1424\":1}}],[\"提供的消息通知机制应该遵循以下条件\",{\"1\":{\"1408\":1}}],[\"提供的方法更多\",{\"1\":{\"1394\":1}}],[\"提供的方法\",{\"1\":{\"1250\":1}}],[\"提供的关键字\",{\"1\":{\"1237\":1}}],[\"提供的\",{\"1\":{\"486\":1,\"1253\":1,\"1385\":1,\"1495\":1}}],[\"提供统一的端上\",{\"1\":{\"51\":1}}],[\"提供统一化的数据检索能力\",{\"1\":{\"26\":1}}],[\"提供数据的读写接口\",{\"1\":{\"51\":1}}],[\"也至于在并发编程中很多程序员遇到线程安全的问题就会使用\",{\"1\":{\"1453\":1}}],[\"也省去了收银员跟你找零的时间了\",{\"1\":{\"1434\":1}}],[\"也无需担心内存可见性问题\",{\"1\":{\"1418\":1}}],[\"也无法封禁国内\",{\"1\":{\"664\":1}}],[\"也很能说明\",{\"1\":{\"1399\":1}}],[\"也很容易理解\",{\"1\":{\"1352\":1}}],[\"也提供了相关的类\",{\"1\":{\"1387\":1}}],[\"也提供了相应的方法进行这些操作\",{\"1\":{\"1385\":1}}],[\"也提供了同样的方法\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"也表示该类用于返回异步任务的结果\",{\"1\":{\"1365\":1}}],[\"也方便查找问题原因\",{\"1\":{\"1359\":1}}],[\"也由这两个\",{\"1\":{\"1350\":1}}],[\"也实现了\",{\"1\":{\"1330\":1}}],[\"也置为\",{\"1\":{\"1316\":1}}],[\"也几乎和大多数容器一样\",{\"1\":{\"1306\":1}}],[\"也正是能够均匀分布\",{\"1\":{\"1306\":1}}],[\"也没有加锁也没有\",{\"1\":{\"1293\":1}}],[\"也被广泛应用于很多业务场景之中\",{\"1\":{\"1290\":1}}],[\"也被称为元数据\",{\"1\":{\"1051\":1}}],[\"也指向它自己\",{\"1\":{\"1283\":1}}],[\"也为\",{\"1\":{\"1283\":1,\"1284\":1}}],[\"也做一个反序处理\",{\"1\":{\"1274\":1}}],[\"也免不了会出现拉链过长的情况\",{\"1\":{\"1272\":1}}],[\"也对\",{\"1\":{\"1251\":1}}],[\"也对系统的吞吐能力提出了更高要求\",{\"1\":{\"40\":1}}],[\"也会将当前线程插入同步队列等一系列的方法\",{\"1\":{\"1496\":1}}],[\"也会导致程序出现错误\",{\"1\":{\"1407\":1}}],[\"也会抛出\",{\"1\":{\"1404\":1}}],[\"也会调用\",{\"1\":{\"1317\":2}}],[\"也会根据\",{\"1\":{\"1158\":1}}],[\"也会被移除\",{\"1\":{\"1069\":1}}],[\"也会更新其根评论的计数\",{\"1\":{\"37\":1}}],[\"也必须把两个类型都写出来\",{\"1\":{\"1013\":1}}],[\"也称为散列表\",{\"1\":{\"971\":1}}],[\"也称静态链表\",{\"1\":{\"403\":1}}],[\"也有两个重要的内部类\",{\"1\":{\"1365\":1}}],[\"也有一个很著名的\",{\"1\":{\"1218\":1}}],[\"也有一个加载配置文件的方法\",{\"1\":{\"1157\":1}}],[\"也有降序排序\",{\"1\":{\"934\":1}}],[\"也有很不错的效果\",{\"1\":{\"668\":1}}],[\"也改为\",{\"1\":{\"899\":1}}],[\"也和\",{\"1\":{\"796\":1}}],[\"也能通过剩余的数据块和校验块恢复原始数据\",{\"1\":{\"1095\":1}}],[\"也能使用云存储服务提供的\",{\"1\":{\"1094\":1}}],[\"也能够满足许多场景下的需求\",{\"1\":{\"575\":1}}],[\"也能实现增删改查\",{\"1\":{\"557\":1}}],[\"也便于组合其他条件去过滤题目列表\",{\"1\":{\"525\":1}}],[\"也衍生出了很多大数据处理技术\",{\"1\":{\"434\":1}}],[\"也是同样的道理\",{\"1\":{\"1398\":1}}],[\"也是一种多线程并发控制的实用工具\",{\"1\":{\"1393\":1}}],[\"也是一名\",{\"1\":{\"1218\":1}}],[\"也是采用散列表进行实现的\",{\"1\":{\"1306\":1}}],[\"也是队列真正的对尾节点\",{\"1\":{\"1283\":1}}],[\"也是大费周章才计算出来的\",{\"1\":{\"1275\":1}}],[\"也是在实际编程中使用频率很高的一个锁\",{\"1\":{\"1231\":1}}],[\"也是通过接口方法里面的\",{\"1\":{\"1157\":1}}],[\"也是非常常见的一个功能\",{\"1\":{\"935\":1}}],[\"也是价值\",{\"1\":{\"772\":1}}],[\"也是\",{\"1\":{\"380\":1}}],[\"也是亲戚\",{\"1\":{\"273\":1}}],[\"也将其倍数从\",{\"1\":{\"372\":1}}],[\"也可能没有运行\",{\"1\":{\"1331\":1}}],[\"也可能是\",{\"1\":{\"789\":1}}],[\"也可能是长整数\",{\"1\":{\"252\":1}}],[\"也可为字符数组\",{\"1\":{\"1069\":1}}],[\"也可以支持共享式获取同步状态\",{\"1\":{\"1494\":1}}],[\"也可以插入其他指令\",{\"1\":{\"1482\":1}}],[\"也可以采用类似的思路进行实现\",{\"1\":{\"1385\":1}}],[\"也可以由调用的线程直接执行\",{\"1\":{\"1376\":1}}],[\"也可以利用上面第二种方式\",{\"1\":{\"1330\":1}}],[\"也可以让我们了解\",{\"1\":{\"1284\":1}}],[\"也可以理解成临界值\",{\"1\":{\"1266\":1}}],[\"也可以理解为是涉及到数据的采集\",{\"1\":{\"434\":1}}],[\"也可以直接定义数组中某个元素的值\",{\"1\":{\"1122\":1}}],[\"也可以用双引号\",{\"1\":{\"1117\":1}}],[\"也可以用来判断奇数和偶数\",{\"1\":{\"381\":1}}],[\"也可以将一套逻辑组织成一个文件\",{\"1\":{\"1107\":1}}],[\"也可以通过构造器参数来为其指定公平性\",{\"1\":{\"1326\":1}}],[\"也可以通过自定义类实现\",{\"1\":{\"1326\":1}}],[\"也可以通过\",{\"1\":{\"1078\":1}}],[\"也可以作为栈\",{\"1\":{\"1075\":1}}],[\"也可以不用引号\",{\"1\":{\"1117\":1}}],[\"也可以不加引号\",{\"1\":{\"1112\":1}}],[\"也可以不处理\",{\"1\":{\"1044\":1}}],[\"也可以不删除任何字符\",{\"1\":{\"838\":1}}],[\"也可以调用静态函数\",{\"1\":{\"1027\":1}}],[\"也可以调用函数本身\",{\"1\":{\"1023\":1}}],[\"也可以格式化输出\",{\"1\":{\"1006\":1}}],[\"也可以修改多个变量\",{\"1\":{\"990\":1}}],[\"也可以没有\",{\"1\":{\"926\":1,\"927\":1}}],[\"也可以替换成\",{\"1\":{\"915\":1}}],[\"也可以在递归完左子树之后立刻判断\",{\"1\":{\"901\":1}}],[\"也可以是任意同步组件\",{\"1\":{\"1494\":1}}],[\"也可以是在不同线程之间\",{\"1\":{\"1420\":1}}],[\"也可以是要注册的服务实例\",{\"1\":{\"1175\":1}}],[\"也可以是机器的绝对路径\",{\"1\":{\"670\":1}}],[\"也可以是列表\",{\"1\":{\"523\":1}}],[\"也可以存储在外部\",{\"1\":{\"669\":1}}],[\"也可以去找一些小众更便宜的云服务器提供商\",{\"1\":{\"662\":1}}],[\"也可以自己搭建一个代理服务\",{\"1\":{\"661\":1}}],[\"也可以根据此公式算出来存储这么多元素大概需要占用多少内存空间\",{\"1\":{\"613\":1}}],[\"也可以从业务角度上\",{\"1\":{\"613\":1}}],[\"也可以从湖中摄取数据\",{\"1\":{\"438\":1}}],[\"也可以省略\",{\"1\":{\"510\":1}}],[\"也可以轻松将大量冷门历史数据从数仓转移至成本更低廉的数据湖内\",{\"1\":{\"438\":1}}],[\"也可以流到湖里\",{\"1\":{\"438\":1}}],[\"也可以简写成这样\",{\"1\":{\"270\":1}}],[\"也可以换成更安全的\",{\"1\":{\"251\":1}}],[\"也可以看做它自身的一棵子树\",{\"1\":{\"186\":1}}],[\"也可以看到一些多元化的观点\",{\"1\":{\"41\":1}}],[\"也可以发一条友善的评论\",{\"1\":{\"41\":1}}],[\"也可以守护新人up主成长\",{\"1\":{\"41\":1}}],[\"也不需要进行额外的同步\",{\"1\":{\"1415\":1}}],[\"也不需要在叶子节点结束\",{\"1\":{\"880\":1}}],[\"也不需要复用\",{\"1\":{\"526\":1}}],[\"也不在\",{\"1\":{\"215\":1}}],[\"也不会出现非法的模式字符串\",{\"1\":{\"127\":1}}],[\"也不能通过api等对外暴露\",{\"1\":{\"36\":1}}],[\"也即数学中的取相反数\",{\"1\":{\"104\":1}}],[\"也支持动态的模型打分\",{\"1\":{\"40\":1}}],[\"也包括为了策略迭代而需要新开发的流式的窗口聚合数据\",{\"1\":{\"40\":1}}],[\"也包括各类热评排序算法\",{\"1\":{\"39\":1}}],[\"也就说前面对\",{\"1\":{\"1476\":1}}],[\"也就意味着\",{\"1\":{\"1319\":1}}],[\"也就意味着队列的\",{\"1\":{\"1285\":1}}],[\"也就找到了要删除的真正的队头节点\",{\"1\":{\"1284\":1}}],[\"也就导致算法越慢\",{\"1\":{\"216\":1}}],[\"也就造成了错误的增量更新\",{\"1\":{\"37\":1}}],[\"也就是彼此交换了数据\",{\"1\":{\"1399\":1}}],[\"也就是允许的最大并发执行的线程个数为\",{\"1\":{\"1398\":1}}],[\"也就是计数器的初始值\",{\"1\":{\"1393\":1}}],[\"也就是进一步了封装了\",{\"1\":{\"1371\":1}}],[\"也就是必须已经获得对象锁\",{\"1\":{\"1338\":1}}],[\"也就是调用这些方法后线程会进入\",{\"1\":{\"1334\":1}}],[\"也就是不断往后线性探测\",{\"1\":{\"1306\":1}}],[\"也就是队头删的速度要快于队尾添加节点的速度\",{\"1\":{\"1283\":1}}],[\"也就是为了保证内存可见性\",{\"1\":{\"1267\":1}}],[\"也就是每次调用\",{\"1\":{\"1252\":1}}],[\"也就是当前线程是同步队列中的头结点\",{\"1\":{\"1251\":1}}],[\"也就是一个阻塞队列\",{\"1\":{\"1365\":1}}],[\"也就是一个\",{\"1\":{\"1250\":1,\"1283\":1}}],[\"也就是在同一时刻只有一个线程能够获取锁\",{\"1\":{\"1237\":1}}],[\"也就是在查询第一页的时候会将后两页评论数据也一起加载进缓存\",{\"1\":{\"58\":1}}],[\"也就是理解了同步语义的第一条\",{\"1\":{\"1232\":1}}],[\"也就是形成了多核\",{\"1\":{\"1218\":1}}],[\"也就是即使你启动了\",{\"1\":{\"1087\":1}}],[\"也就是做\",{\"1\":{\"808\":1}}],[\"也就是答案\",{\"1\":{\"795\":1}}],[\"也就是将一张大表拆分成两张小表\",{\"1\":{\"938\":1}}],[\"也就是将\",{\"1\":{\"613\":1}}],[\"也就是直接穿过缓存打到数据库中\",{\"1\":{\"613\":1}}],[\"也就是最少需要多少辆缆车\",{\"1\":{\"290\":1}}],[\"也就是\",{\"1\":{\"152\":1,\"822\":1,\"1190\":1,\"1250\":1,\"1272\":1}}],[\"也就是从左往右对应山的高度严格单调递增\",{\"1\":{\"66\":1}}],[\"也就是它是回复哪条评论的\",{\"1\":{\"56\":1}}],[\"也就是用\",{\"1\":{\"37\":1}}],[\"也就是说该对象引用不能在构造函数中\",{\"1\":{\"1478\":1}}],[\"也就是说该方法\",{\"1\":{\"1316\":1}}],[\"也就是说当线程\",{\"1\":{\"1455\":1}}],[\"也就是说软件技术和硬件技术都为同一个目标而进行奋斗\",{\"1\":{\"1418\":1}}],[\"也就是说不会将线程挂起\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"也就是说理论上这是一个大小无界的线程池\",{\"1\":{\"1366\":1}}],[\"也就是说可以正常执行一次打印\",{\"1\":{\"1340\":1}}],[\"也就是说都有机会获得当前线程让出的时间片\",{\"1\":{\"1339\":1}}],[\"也就是说在调用\",{\"1\":{\"1336\":1}}],[\"也就是说每个不同的线程都拥有专属于自己的数据容器\",{\"1\":{\"1309\":1}}],[\"也就是说加载因子为\",{\"1\":{\"1306\":1}}],[\"也就是说如果使用读写锁依然会出现读线程阻塞等待的情况\",{\"1\":{\"1295\":1}}],[\"也就是说两类线程间并不会相互影响\",{\"1\":{\"1283\":1}}],[\"也就是说数组的可用大小为\",{\"1\":{\"1271\":1}}],[\"也就是说只能调用一次\",{\"1\":{\"1258\":1}}],[\"也就是说摩尔定律的有效性超过了半个世纪戛然而止\",{\"1\":{\"1218\":1}}],[\"也就是说线程\",{\"1\":{\"1145\":1}}],[\"也就是说控制对象生存周期的不再是引用它的对象\",{\"1\":{\"1131\":1}}],[\"也就是说你依赖的对象直接由你自己控制\",{\"1\":{\"1129\":1}}],[\"也就是说\",{\"1\":{\"14\":1,\"152\":1,\"687\":1,\"710\":1,\"958\":1,\"1270\":1,\"1283\":1,\"1284\":1,\"1290\":1,\"1301\":2,\"1365\":1,\"1393\":1,\"1410\":1,\"1420\":1,\"1422\":1,\"1473\":1,\"1477\":1,\"1482\":2,\"1485\":1,\"1501\":1}}],[\"状态变化\",{\"1\":{\"1440\":1}}],[\"状态变量\",{\"1\":{\"1406\":1}}],[\"状态的更新使用\",{\"1\":{\"1494\":1}}],[\"状态的线程\",{\"1\":{\"1408\":1}}],[\"状态的线程中挑选一个进行通知\",{\"1\":{\"1404\":1}}],[\"状态的\",{\"1\":{\"1407\":1}}],[\"状态的可能性\",{\"1\":{\"1353\":1}}],[\"状态迁移图\",{\"1\":{\"1375\":1}}],[\"状态转换可以说是线程的生命周期\",{\"1\":{\"1334\":1}}],[\"状态转移方程\",{\"1\":{\"194\":1,\"301\":1,\"302\":1,\"303\":1,\"306\":2,\"312\":1,\"314\":1,\"796\":1}}],[\"状态转移方程为\",{\"1\":{\"182\":1}}],[\"状态转移\",{\"1\":{\"115\":1,\"135\":1,\"178\":1,\"182\":1,\"279\":1}}],[\"状态时可以通过\",{\"1\":{\"1334\":1}}],[\"状态如下图所示\",{\"1\":{\"1281\":1,\"1317\":1}}],[\"状态更新等\",{\"1\":{\"1087\":1}}],[\"状态个数\",{\"1\":{\"851\":1}}],[\"状态\",{\"0\":{\"1408\":1},\"1\":{\"575\":1,\"592\":1,\"827\":1,\"839\":1,\"1193\":1,\"1259\":2,\"1276\":1,\"1334\":7,\"1360\":1,\"1404\":1,\"1407\":1,\"1431\":1,\"1496\":1}}],[\"状态管理\",{\"1\":{\"499\":1}}],[\"状态表示\",{\"1\":{\"311\":1}}],[\"状态压缩类dp\",{\"0\":{\"310\":1}}],[\"状态空间\",{\"1\":{\"221\":1}}],[\"状态一致性\",{\"1\":{\"36\":1}}],[\"状态类\",{\"1\":{\"30\":1}}],[\"6正在消费数据822954707\",{\"1\":{\"1411\":1}}],[\"6正在消费数据\",{\"1\":{\"1411\":1}}],[\"6正在全力冲刺\",{\"1\":{\"1392\":1}}],[\"6−10\",{\"1\":{\"1398\":1}}],[\"68\",{\"1\":{\"1317\":2}}],[\"6版本关键要素\",{\"1\":{\"1264\":1}}],[\"66\",{\"1\":{\"1004\":1}}],[\"652105379\",{\"1\":{\"1411\":1}}],[\"65\",{\"1\":{\"920\":2,\"1317\":3}}],[\"65535\",{\"1\":{\"920\":2}}],[\"67gb\",{\"1\":{\"613\":2}}],[\"64\",{\"1\":{\"384\":1,\"543\":2,\"1317\":3}}],[\"695\",{\"1\":{\"230\":1}}],[\"600080565\",{\"1\":{\"1410\":1}}],[\"6010\",{\"1\":{\"314\":4}}],[\"60\",{\"1\":{\"109\":1,\"162\":1,\"984\":1,\"1150\":1,\"1309\":1}}],[\"6\",{\"0\":{\"36\":1,\"37\":1,\"221\":1,\"247\":1,\"306\":1,\"310\":1,\"311\":1,\"312\":1,\"336\":1,\"337\":1,\"338\":1,\"339\":1,\"362\":1,\"384\":1,\"399\":1,\"413\":1,\"414\":1,\"415\":1,\"416\":1,\"441\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"468\":1,\"481\":1,\"501\":1,\"520\":1,\"547\":1,\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"634\":1,\"644\":1,\"934\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"947\":1,\"948\":1,\"949\":1,\"950\":1,\"951\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":1,\"1013\":1,\"1014\":1,\"1015\":2,\"1016\":1,\"1017\":1,\"1018\":1,\"1019\":1,\"1020\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1047\":1,\"1117\":1,\"1140\":1,\"1166\":1,\"1167\":1,\"1168\":1,\"1275\":1,\"1335\":1,\"1336\":1,\"1337\":1,\"1338\":1,\"1339\":1,\"1388\":1,\"1422\":1,\"1423\":1,\"1424\":1,\"1425\":1,\"1458\":1,\"1478\":1},\"1\":{\"40\":1,\"41\":1,\"70\":2,\"88\":2,\"92\":2,\"99\":1,\"120\":1,\"122\":1,\"135\":1,\"139\":2,\"152\":2,\"179\":1,\"182\":1,\"196\":1,\"224\":9,\"261\":1,\"273\":1,\"279\":9,\"289\":1,\"291\":1,\"301\":1,\"325\":1,\"327\":1,\"328\":1,\"338\":1,\"354\":1,\"385\":1,\"538\":3,\"568\":1,\"850\":2,\"852\":3,\"958\":1,\"980\":1,\"984\":1,\"986\":1,\"990\":1,\"1000\":1,\"1001\":1,\"1095\":3,\"1158\":1,\"1170\":1,\"1194\":1,\"1259\":1,\"1264\":1,\"1272\":2,\"1283\":3,\"1284\":1,\"1316\":3,\"1329\":1,\"1337\":1,\"1375\":1,\"1388\":2,\"1392\":11,\"1393\":15,\"1398\":4,\"1432\":1,\"1440\":1,\"1444\":1,\"1476\":1,\"1496\":1}}],[\"舆论安全问题更为泛化\",{\"1\":{\"37\":1}}],[\"舆论安全\",{\"0\":{\"37\":1},\"1\":{\"35\":1}}],[\"针对上面的实例程序\",{\"1\":{\"1476\":1}}],[\"针对引用数据类型\",{\"1\":{\"1476\":1}}],[\"针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱\",{\"1\":{\"1491\":1}}],[\"针对这两种类型的变量赋初值的时机是不同的\",{\"1\":{\"1465\":1}}],[\"针对这种情况\",{\"1\":{\"1417\":1}}],[\"针对这种情况可以进行异常捕获\",{\"1\":{\"526\":1}}],[\"针对这种现象\",{\"1\":{\"1406\":1}}],[\"针对这种境况\",{\"1\":{\"1264\":1}}],[\"针对这种读多写少的情况\",{\"1\":{\"1237\":1}}],[\"针对处理器重排序\",{\"1\":{\"1418\":1}}],[\"针对编译器重排序\",{\"1\":{\"1418\":1}}],[\"针对第一个问题\",{\"1\":{\"1232\":1}}],[\"针对于数据库设计\",{\"1\":{\"910\":1}}],[\"针对于最普通的也是最常见的迷宫问题\",{\"1\":{\"234\":1}}],[\"针对\",{\"1\":{\"540\":1,\"1248\":2,\"1314\":1,\"1317\":1,\"1410\":2}}],[\"针对双机房架构下特有的副机房数据延迟故障\",{\"1\":{\"34\":1}}],[\"针对不同依赖服务所提供的\",{\"1\":{\"25\":1}}],[\"冗余与降级\",{\"0\":{\"34\":1}}],[\"收集系统内部以及相应依赖方的一些的热点相关统计信息\",{\"1\":{\"33\":1}}],[\"感知到热点后即读取本地缓存\",{\"1\":{\"33\":1}}],[\"很明显已经超过了理论上的系统时间\",{\"1\":{\"1508\":1}}],[\"很自然而然的想法就是每一个线程依次去读写这个共享变量\",{\"1\":{\"1429\":1}}],[\"很重要的一条性质是它能够够保证可见性\",{\"1\":{\"1292\":1}}],[\"很容易理解\",{\"1\":{\"1270\":1,\"1272\":1}}],[\"很容易出现版本冲突的问题\",{\"1\":{\"539\":1}}],[\"很显然它是让当前线程按照指定的时间休眠\",{\"1\":{\"1338\":1}}],[\"很显然它连成为脏\",{\"1\":{\"1316\":1}}],[\"很显然在上述情况\",{\"1\":{\"1315\":1}}],[\"很显然在\",{\"1\":{\"1313\":1}}],[\"很显然内存使用率不高\",{\"1\":{\"1306\":1}}],[\"很显然该节点不是待删除的节点\",{\"1\":{\"1284\":1}}],[\"很显然当前\",{\"1\":{\"1284\":1}}],[\"很显然此时\",{\"1\":{\"1284\":1}}],[\"很显然此时第\",{\"1\":{\"1283\":1}}],[\"很显然线程\",{\"1\":{\"1283\":1}}],[\"很显然由于\",{\"1\":{\"1283\":1}}],[\"很显然这段源码最终是靠\",{\"1\":{\"1508\":1}}],[\"很显然这就是两种不同的思路\",{\"1\":{\"1313\":1}}],[\"很显然这种方式的时间效率并不是很好\",{\"1\":{\"1299\":1}}],[\"很显然这种方式效率并不是太高\",{\"1\":{\"1290\":1}}],[\"很显然这么写另有深意\",{\"1\":{\"1283\":1}}],[\"很显然这不是一种高效的方式\",{\"1\":{\"1280\":1}}],[\"很显然这将是出现性能瓶颈的地方\",{\"1\":{\"1237\":1}}],[\"很显然可以通过\",{\"1\":{\"1272\":1}}],[\"很显然\",{\"1\":{\"1251\":1,\"1429\":1,\"1496\":1}}],[\"很显然写锁是独占式锁\",{\"1\":{\"1239\":1}}],[\"很显然不是脏\",{\"1\":{\"1315\":1}}],[\"很显然不是\",{\"1\":{\"1219\":1}}],[\"很快就发现了\",{\"1\":{\"1186\":1}}],[\"很像\",{\"1\":{\"1153\":1}}],[\"很可能拿到\",{\"1\":{\"1147\":1}}],[\"很难找到\",{\"1\":{\"1184\":1}}],[\"很难找到一个完美的优化方案\",{\"1\":{\"40\":1}}],[\"很难确定是取到了null元素还是队列为空\",{\"1\":{\"1076\":1}}],[\"很少会出现冲突\",{\"1\":{\"1306\":1}}],[\"很少会使用物理外键\",{\"1\":{\"937\":1}}],[\"很少修改\",{\"1\":{\"30\":1}}],[\"很多时候\",{\"1\":{\"1337\":1}}],[\"很多大型网站为了做\",{\"1\":{\"534\":1}}],[\"很多依赖是体量相对小的业务单元\",{\"1\":{\"33\":1}}],[\"很有可能访问第二页\",{\"1\":{\"48\":1}}],[\"改变\",{\"1\":{\"1438\":1}}],[\"改变为\",{\"1\":{\"1283\":1,\"1406\":1}}],[\"改变对象的属性\",{\"1\":{\"1132\":1}}],[\"改了后\",{\"1\":{\"1145\":1}}],[\"改动会影响原数组\",{\"1\":{\"1072\":1}}],[\"改的效率\",{\"1\":{\"937\":1}}],[\"改操作\",{\"1\":{\"924\":1}}],[\"改\",{\"1\":{\"323\":1}}],[\"改为了\",{\"1\":{\"1458\":1}}],[\"改为自定义变量\",{\"1\":{\"1116\":1}}],[\"改为\",{\"1\":{\"237\":1,\"899\":1,\"1271\":1}}],[\"改造后\",{\"1\":{\"33\":1}}],[\"改成批量写入\",{\"1\":{\"33\":1}}],[\"先定义一个父类\",{\"1\":{\"1469\":1}}],[\"先执行了\",{\"1\":{\"1478\":1}}],[\"先执行\",{\"1\":{\"1455\":1,\"1456\":1}}],[\"先执行到第\",{\"1\":{\"1284\":1}}],[\"先天具有重入性\",{\"1\":{\"1431\":1}}],[\"先行于发生它的\",{\"1\":{\"1421\":1}}],[\"先调用\",{\"1\":{\"1406\":1}}],[\"先获取到笔\",{\"1\":{\"1398\":1}}],[\"先获取与当前线程相关联的\",{\"1\":{\"1303\":1}}],[\"先完成插入数据\",{\"1\":{\"1347\":1}}],[\"先简单的看下\",{\"1\":{\"1301\":1}}],[\"先来看两个核心之一\",{\"1\":{\"1455\":1}}],[\"先来看\",{\"1\":{\"1284\":1,\"1317\":1}}],[\"先来看第一步\",{\"1\":{\"1145\":1}}],[\"先从\",{\"1\":{\"1392\":1}}],[\"先从单线程执行的角度看起\",{\"1\":{\"1283\":1}}],[\"先从题库表里查询出题库信息\",{\"1\":{\"523\":1}}],[\"先\",{\"1\":{\"1283\":1}}],[\"先看源码\",{\"1\":{\"1506\":1}}],[\"先看同步状态是否获取成功\",{\"1\":{\"1503\":1}}],[\"先看看哪些是原子操作\",{\"1\":{\"1482\":1}}],[\"先看一段示例代码\",{\"1\":{\"1475\":1}}],[\"先看一个现象\",{\"1\":{\"1429\":1}}],[\"先看一张\",{\"1\":{\"56\":1}}],[\"先看这么一段代码\",{\"1\":{\"1283\":1}}],[\"先将节点状态设置成\",{\"1\":{\"1505\":1}}],[\"先将\",{\"1\":{\"1272\":1,\"1316\":1}}],[\"先通过\",{\"1\":{\"1253\":1,\"1308\":1}}],[\"先通过查询关联表得到题目\",{\"1\":{\"525\":1}}],[\"先检测当前线程是否已经获取lock\",{\"1\":{\"1252\":1}}],[\"先放一张时序图\",{\"1\":{\"1175\":1}}],[\"先上图\",{\"1\":{\"1134\":1}}],[\"先写\",{\"1\":{\"1026\":1}}],[\"先减1后取值\",{\"1\":{\"979\":1}}],[\"先取值后减1\",{\"1\":{\"979\":1}}],[\"先取值后加1\",{\"1\":{\"979\":1}}],[\"先加1后取值\",{\"1\":{\"979\":1}}],[\"先加上上次的进位\",{\"1\":{\"700\":1}}],[\"先开启\",{\"1\":{\"954\":1}}],[\"先找到左右叶子节点\",{\"1\":{\"901\":1}}],[\"先遍历左节点\",{\"1\":{\"900\":1}}],[\"先学习课程\",{\"1\":{\"874\":1}}],[\"先修课程对\",{\"1\":{\"874\":1}}],[\"先修课程按数组\",{\"1\":{\"874\":1}}],[\"先修改前端代码\",{\"1\":{\"583\":1}}],[\"先翻转左右子树\",{\"1\":{\"864\":1}}],[\"先要在链表头部接一个虚拟结点\",{\"1\":{\"777\":1}}],[\"先建立根节点\",{\"1\":{\"766\":1}}],[\"先递归右子树\",{\"1\":{\"736\":2}}],[\"先递归再合并\",{\"1\":{\"318\":1,\"833\":1}}],[\"先处理这个节点的左子树\",{\"1\":{\"730\":1}}],[\"先序遍历的访问顺序是\",{\"1\":{\"724\":1}}],[\"先序遍历\",{\"0\":{\"724\":1},\"1\":{\"723\":1}}],[\"先记录左子树中的结点数\",{\"1\":{\"712\":1}}],[\"先反转以\",{\"1\":{\"681\":1}}],[\"先说一下各个参数的含义\",{\"1\":{\"613\":1}}],[\"先暂时返回\",{\"1\":{\"596\":1}}],[\"先注册再登录\",{\"1\":{\"587\":1}}],[\"先新建一个文件夹\",{\"1\":{\"559\":1}}],[\"先去阿里云服务器配置\",{\"1\":{\"672\":1}}],[\"先去布隆过滤器中快速进行判断用户名是否已经被使用\",{\"1\":{\"613\":1}}],[\"先去\",{\"1\":{\"539\":1}}],[\"先进行管理员校验\",{\"1\":{\"578\":1}}],[\"先进先出\",{\"1\":{\"408\":1,\"1326\":1,\"1506\":1}}],[\"先进后出\",{\"1\":{\"405\":1}}],[\"先存值\",{\"1\":{\"403\":1}}],[\"先手走不到任何一个必败状态\",{\"1\":{\"394\":1}}],[\"先手\",{\"1\":{\"394\":1}}],[\"先手可以走到某一个必败状态\",{\"1\":{\"394\":1}}],[\"先手进行\",{\"1\":{\"394\":1}}],[\"先整除再乘\",{\"1\":{\"379\":1}}],[\"先累加\",{\"1\":{\"360\":1}}],[\"先把前两个元素翻转\",{\"1\":{\"694\":1}}],[\"先把所有距离初始化为正无穷\",{\"1\":{\"360\":1}}],[\"先把第\",{\"1\":{\"339\":1}}],[\"先枚举长度\",{\"1\":{\"307\":1}}],[\"先判断线程池中核心线程池所有的线程是否都在执行任务\",{\"1\":{\"1358\":1}}],[\"先判断范围和条件\",{\"1\":{\"820\":1}}],[\"先判断第一段是否符合\",{\"1\":{\"262\":1}}],[\"先判断如果\",{\"1\":{\"262\":1}}],[\"先预处理前缀和\",{\"1\":{\"262\":1}}],[\"先后与右\",{\"1\":{\"224\":1,\"279\":1}}],[\"先向右走两步\",{\"1\":{\"180\":1}}],[\"先对共享变量\",{\"1\":{\"1432\":1}}],[\"先对数列排序\",{\"1\":{\"324\":1}}],[\"先对工人的位置进行排序\",{\"1\":{\"173\":1}}],[\"先对所有桌子按容纳人数从小到大排序\",{\"1\":{\"162\":1}}],[\"先排序\",{\"1\":{\"156\":1}}],[\"先骗分\",{\"1\":{\"152\":1}}],[\"先计算每个单元格被覆盖的次数\",{\"1\":{\"141\":1}}],[\"先根据给定的公式计算出所有位置的伤害值\",{\"1\":{\"110\":1}}],[\"先购买第二个商品价格为21\",{\"1\":{\"109\":1}}],[\"先确定奇数和偶数的数量\",{\"1\":{\"87\":1}}],[\"先成功\",{\"1\":{\"56\":1}}],[\"先读取缓存\",{\"1\":{\"48\":1}}],[\"先读缓存\",{\"1\":{\"28\":1}}],[\"先理解业务背后的本质\",{\"1\":{\"45\":1}}],[\"先做内存合并再更新\",{\"1\":{\"33\":1}}],[\"痛定思痛\",{\"1\":{\"33\":1}}],[\"面对复杂业务模型\",{\"1\":{\"1218\":1}}],[\"面对如此复杂的计算量就需要充分利用多核的计算的能力\",{\"1\":{\"1218\":1}}],[\"面对如此大的流量出现了严重延迟\",{\"1\":{\"33\":1}}],[\"面试题\",{\"1\":{\"933\":1,\"955\":1}}],[\"面试如何吹一波牛\",{\"1\":{\"631\":1}}],[\"面试吧<\",{\"1\":{\"549\":1}}],[\"面试吧笔记第三期\",{\"1\":{\"529\":1}}],[\"面试吧笔记第二期\",{\"1\":{\"505\":1}}],[\"面试吧笔记第一期\",{\"1\":{\"492\":1}}],[\"面试吧\",{\"2\":{\"504\":1,\"528\":1,\"553\":1}}],[\"面试吧是一款基于\",{\"1\":{\"493\":1}}],[\"面向业务组合的服务\",{\"1\":{\"51\":1}}],[\"面向平台\",{\"1\":{\"51\":1}}],[\"面向线上联机事务处理的\",{\"1\":{\"50\":1}}],[\"面向服务端场景\",{\"1\":{\"25\":1}}],[\"面向移动端\",{\"1\":{\"25\":1,\"46\":1}}],[\"当成功释放同步状态之后\",{\"1\":{\"1511\":1}}],[\"当该节点的前驱节点是头结点且成功获取同步状态\",{\"1\":{\"1510\":1}}],[\"当返回值为大于等于\",{\"1\":{\"1510\":1}}],[\"当不满足条件时就会调用\",{\"1\":{\"1506\":1}}],[\"当不支持请求的操作时\",{\"1\":{\"1045\":1}}],[\"当后继节点的时候会调用\",{\"1\":{\"1506\":1}}],[\"当共享资源被某个线程占有\",{\"1\":{\"1501\":1}}],[\"当再次获取锁时才能从等待中返回\",{\"1\":{\"1493\":1}}],[\"当锁被占用后\",{\"1\":{\"1484\":1}}],[\"当锁处于这个状态下\",{\"1\":{\"1447\":1}}],[\"当子类继承该父类的时候\",{\"1\":{\"1471\":1}}],[\"当重写\",{\"1\":{\"1469\":1}}],[\"当父类的方法被\",{\"1\":{\"1469\":1}}],[\"当程序中其他地方使用该宏变量的地方\",{\"1\":{\"1467\":1}}],[\"当且仅有一次赋值\",{\"1\":{\"1466\":1}}],[\"当且仅当冲突发生的时候再去尝试\",{\"1\":{\"1266\":1}}],[\"当且仅当该局面对应节点的sg函数值等于0\",{\"1\":{\"399\":1}}],[\"当且仅当该局面对应节点的sg函数值大于0\",{\"1\":{\"399\":1}}],[\"当且仅当\",{\"1\":{\"394\":1,\"1506\":1}}],[\"当且仅当这两种方案经过的格子序列不同\",{\"1\":{\"196\":1}}],[\"当处理器发现本地缓存失效后\",{\"1\":{\"1454\":1}}],[\"当处理器发现自己缓存行对应的内存地址被修改\",{\"1\":{\"1454\":1}}],[\"当处理器对这个数据进行修改操作的时候\",{\"1\":{\"1454\":1}}],[\"当处理的节点是空节点时\",{\"1\":{\"730\":1}}],[\"当持有锁的线程释放锁之后会唤醒这些线程\",{\"1\":{\"1447\":1}}],[\"当对一个共享变量执行操作时\",{\"1\":{\"1439\":1}}],[\"当对第\",{\"1\":{\"1295\":1}}],[\"当这个对象由同步块或者这个对象的同步方法调用时\",{\"1\":{\"1431\":1}}],[\"当这些服务不稳定时\",{\"1\":{\"51\":1}}],[\"当两个线程都到达调用\",{\"1\":{\"1399\":1}}],[\"当指定的线程都到达了指定的临界点的时\",{\"1\":{\"1393\":1}}],[\"当指定大小为\",{\"1\":{\"1270\":1}}],[\"当多个线程访问同一个对象时\",{\"1\":{\"1415\":1}}],[\"当多个线程都达到了指定点后\",{\"1\":{\"1393\":1}}],[\"当多个线程凑齐了一波之后\",{\"1\":{\"1393\":1}}],[\"当多个线程使用\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"当多个线程试图执行同一个任务时\",{\"1\":{\"1376\":1}}],[\"当创建一个\",{\"1\":{\"1375\":1}}],[\"当执行到\",{\"1\":{\"1407\":1}}],[\"当执行到判断\",{\"1\":{\"1285\":1}}],[\"当执行完业务功能后\",{\"1\":{\"1398\":1}}],[\"当执行任务时\",{\"1\":{\"1370\":1}}],[\"当达到延时时间initialdelay后\",{\"1\":{\"1367\":1}}],[\"当达到了祖先位置\",{\"1\":{\"270\":1}}],[\"当核心线程池的线程个数达到\",{\"1\":{\"1366\":1}}],[\"当所有的线程都关闭成功\",{\"1\":{\"1360\":1}}],[\"当所有其他线程都释放了这个锁\",{\"1\":{\"1332\":1}}],[\"当提交一个任务时\",{\"1\":{\"1359\":1}}],[\"当构造对象时为指定队列大小时\",{\"1\":{\"1349\":1}}],[\"当插入数据的生产者线程被阻塞时\",{\"1\":{\"1346\":1}}],[\"当插入键值对时首先应该定位到要插入的桶\",{\"1\":{\"1272\":1}}],[\"当获取数据的消费者线程被阻塞时会将该线程放置到\",{\"1\":{\"1346\":1}}],[\"当一个类不希望被继承时就可以使用\",{\"1\":{\"1471\":1}}],[\"当一个类被\",{\"1\":{\"1471\":1}}],[\"当一个并发任务提交给线程池\",{\"1\":{\"1358\":1}}],[\"当一个\",{\"1\":{\"1340\":1}}],[\"当一个线程访问同步块并获取锁时\",{\"1\":{\"1442\":1}}],[\"当一个线程执行该方法的时候\",{\"1\":{\"1399\":1}}],[\"当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行\",{\"1\":{\"1376\":1}}],[\"当一个线程被重新激活\",{\"1\":{\"1334\":1}}],[\"当一个线程试图获取一个内部的对象锁\",{\"1\":{\"1332\":1}}],[\"当抛出\",{\"1\":{\"1336\":1}}],[\"当超时等待时间到达后\",{\"1\":{\"1334\":1}}],[\"当超时等待时当前线程不会阻塞\",{\"1\":{\"1221\":1}}],[\"当选择下一个线程时\",{\"1\":{\"1331\":1}}],[\"当时间片用完时\",{\"1\":{\"1331\":1}}],[\"当时评论发布的吞吐较低\",{\"1\":{\"33\":1}}],[\"当阻塞队列为空时\",{\"1\":{\"1325\":2}}],[\"当阻塞队列容量已经满时\",{\"1\":{\"1325\":1}}],[\"当往队列插入数据时\",{\"1\":{\"1325\":1}}],[\"当队列已满时\",{\"1\":{\"1347\":1,\"1411\":1}}],[\"当队列容量满时\",{\"1\":{\"1326\":1}}],[\"当队列容器为空时\",{\"1\":{\"1324\":1}}],[\"当队列容器已满\",{\"1\":{\"1324\":1}}],[\"当队列为空时\",{\"1\":{\"1325\":1,\"1411\":1}}],[\"当队列满时不会抛出异常\",{\"1\":{\"1325\":1}}],[\"当队列满时\",{\"1\":{\"1325\":1,\"1345\":1}}],[\"当遇到了\",{\"1\":{\"1317\":1}}],[\"当遇到了脏\",{\"1\":{\"1315\":1}}],[\"当在搜索过程中遇到了脏\",{\"1\":{\"1316\":1}}],[\"当在集群环境下\",{\"1\":{\"1158\":1}}],[\"当到哈希表末尾的时候再从\",{\"1\":{\"1306\":1}}],[\"当key为null时\",{\"1\":{\"1306\":1}}],[\"当关键字散列到的数组单元已经被另外一个关键字占用的时候\",{\"1\":{\"1306\":1}}],[\"当查询的时候\",{\"1\":{\"1306\":1}}],[\"当写锁被写线程获取后\",{\"1\":{\"1290\":1}}],[\"当写锁被其他线程获取后\",{\"1\":{\"1242\":1}}],[\"当线程获取独占式锁失败后就会将当前线程加入同步队列\",{\"1\":{\"1504\":1}}],[\"当线程获取该对象锁后\",{\"1\":{\"1431\":1}}],[\"当线程获取\",{\"1\":{\"1431\":1}}],[\"当线程获取锁时会从主内存中获取共享变量的最新值\",{\"1\":{\"1486\":1}}],[\"当线程获取锁时\",{\"1\":{\"1334\":1}}],[\"当线程调用\",{\"1\":{\"1392\":1}}],[\"当线程池的阻塞队列已满和指定的线程都已经开启\",{\"1\":{\"1359\":1}}],[\"当线程进入到\",{\"1\":{\"1334\":1}}],[\"当线程出现资源竞争时\",{\"1\":{\"1334\":1}}],[\"当线程等待另一个线程通知调度器出现某个条件时\",{\"1\":{\"1332\":1}}],[\"当线程处于阻塞或等待状态时\",{\"1\":{\"1332\":1}}],[\"当线程不满足操作条件时\",{\"1\":{\"1326\":1}}],[\"当线程退出时会执行\",{\"1\":{\"1319\":1}}],[\"当线程\",{\"1\":{\"1284\":1,\"1398\":1}}],[\"当线程第一次调用\",{\"1\":{\"1251\":1}}],[\"当要统计全局时\",{\"1\":{\"1276\":1}}],[\"当要获取配置项时\",{\"1\":{\"1151\":1}}],[\"当完成数据新节点插入之后\",{\"1\":{\"1272\":1}}],[\"当链表长度大于\",{\"1\":{\"1276\":1}}],[\"当链表长度太长\",{\"1\":{\"1272\":1}}],[\"当链表的长度大于\",{\"1\":{\"1272\":1}}],[\"当出现哈希冲突的时候\",{\"1\":{\"1272\":1}}],[\"当出现异常的运算条件时\",{\"1\":{\"1045\":1}}],[\"当第一次向\",{\"1\":{\"1270\":1}}],[\"当值为\",{\"1\":{\"1266\":1}}],[\"当值为正数时\",{\"1\":{\"1266\":1}}],[\"当值为负数时\",{\"1\":{\"1266\":1}}],[\"当其中的生产者线程获取到对象锁之后使用\",{\"1\":{\"1408\":1}}],[\"当其他线程释放\",{\"1\":{\"1253\":1}}],[\"当其登录系统时\",{\"1\":{\"458\":1}}],[\"当退出\",{\"1\":{\"1251\":1}}],[\"当读锁已经被读线程获取或者写锁已经被其他写线程获取\",{\"1\":{\"1239\":1}}],[\"当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话\",{\"1\":{\"1239\":1}}],[\"当货物到达后你收到通知去取就好\",{\"1\":{\"1223\":1}}],[\"当被调用的方法完成后会通知调用者\",{\"1\":{\"1223\":1}}],[\"当作一个\",{\"1\":{\"1175\":1}}],[\"当中\",{\"1\":{\"1132\":1}}],[\"当中有\",{\"1\":{\"371\":1}}],[\"当元素超过容量后会扩容\",{\"1\":{\"1078\":1}}],[\"当只剩下守护线程时\",{\"1\":{\"1060\":1}}],[\"当只有一条语句时\",{\"1\":{\"984\":1}}],[\"当试图使用\",{\"1\":{\"1045\":1}}],[\"当试图将对象强制转换为不是实例的子类时\",{\"1\":{\"1045\":1}}],[\"当调用构造器方法之后\",{\"1\":{\"1270\":1}}],[\"当调用\",{\"1\":{\"1045\":1,\"1151\":1,\"1251\":1,\"1334\":1,\"1368\":1,\"1392\":1,\"1495\":1}}],[\"当应用程序试图将字符串转换成一种数值类型\",{\"1\":{\"1045\":1}}],[\"当应用程序试图在需要对象的地方使用\",{\"1\":{\"1045\":1}}],[\"当局部变量与全局变量重名时\",{\"1\":{\"1015\":1}}],[\"当条件成立时\",{\"1\":{\"984\":1}}],[\"当冲突发生时\",{\"1\":{\"971\":1}}],[\"当根节点中可以存储\",{\"1\":{\"958\":1}}],[\"当数据量较大时\",{\"1\":{\"935\":1}}],[\"当进行删除全部数据操作时\",{\"1\":{\"927\":1}}],[\"当访问原节点\",{\"1\":{\"888\":1}}],[\"当存在循环依赖的时候\",{\"1\":{\"875\":1}}],[\"当定义为最小值的时候\",{\"1\":{\"852\":1}}],[\"当遍历到最后一间房子即\",{\"1\":{\"828\":1}}],[\"当快指针移动到末尾时\",{\"1\":{\"777\":1}}],[\"当left\",{\"1\":{\"767\":1}}],[\"当负数出现时则\",{\"1\":{\"705\":1}}],[\"当容量满了之后要删除最久未使用的那个元素腾位置\",{\"1\":{\"687\":1}}],[\"当服务器宕机后恢复也能够重启服务\",{\"1\":{\"671\":1}}],[\"当场就想给她\",{\"1\":{\"634\":1}}],[\"当页面内容更新时\",{\"1\":{\"534\":1}}],[\"当做一个过滤题目的查询条件\",{\"1\":{\"525\":1}}],[\"当模数\",{\"1\":{\"388\":1}}],[\"当有多个\",{\"1\":{\"1192\":1}}],[\"当有\",{\"1\":{\"373\":1}}],[\"当\",{\"1\":{\"243\":1,\"274\":2,\"320\":1,\"338\":1,\"371\":1,\"373\":1,\"383\":2,\"388\":2,\"465\":1,\"710\":1,\"797\":1,\"833\":1,\"846\":2,\"1160\":1,\"1260\":1,\"1272\":3,\"1274\":1,\"1276\":1,\"1283\":2,\"1286\":4,\"1301\":1,\"1305\":1,\"1317\":3,\"1337\":1,\"1375\":4,\"1383\":1,\"1384\":1,\"1393\":1,\"1406\":1,\"1431\":1,\"1437\":2,\"1456\":1,\"1465\":1,\"1505\":1,\"1506\":1,\"1511\":1}}],[\"当终点第一次出队时\",{\"1\":{\"221\":1}}],[\"当启发函数\",{\"1\":{\"216\":1}}],[\"当我们对\",{\"1\":{\"1467\":1}}],[\"当我们调用\",{\"1\":{\"1317\":2}}],[\"当我们调用无参构造器时\",{\"1\":{\"1281\":1}}],[\"当我们为\",{\"1\":{\"1305\":1}}],[\"当我们向二叉查找树保存数据时\",{\"1\":{\"958\":1}}],[\"当我们递归到节点\",{\"1\":{\"881\":1}}],[\"当我们查找一个完整字符串时\",{\"1\":{\"802\":1}}],[\"当我们找到时\",{\"1\":{\"802\":1}}],[\"当我们需要求出组合数的真实值\",{\"1\":{\"390\":1}}],[\"当我们将区间\",{\"1\":{\"321\":1,\"322\":1}}],[\"当我们选择下一个要遍历的节点时\",{\"1\":{\"215\":1}}],[\"当我们操作编辑的时候\",{\"1\":{\"50\":1}}],[\"当图形为网格图\",{\"1\":{\"213\":1}}],[\"当你走过了最后一间房子后\",{\"1\":{\"827\":1}}],[\"当你在一个格子时\",{\"1\":{\"196\":1}}],[\"当你每次移动到某个格子的时候\",{\"1\":{\"110\":1}}],[\"当牛牛在第\",{\"1\":{\"193\":2}}],[\"当体力耗尽的时候玩家无法移动\",{\"1\":{\"142\":1}}],[\"当玩家存在相分相同时\",{\"1\":{\"129\":1}}],[\"当栈不为空且栈顶元素对应的高度小于等于当前元素高度时\",{\"1\":{\"128\":1}}],[\"当前系统时间是\",{\"1\":{\"1508\":1}}],[\"当前同步队列的尾节点为\",{\"1\":{\"1504\":1}}],[\"当前同步队列尾节点为null\",{\"1\":{\"1504\":1}}],[\"当前同步状态需要加上\",{\"1\":{\"1242\":1}}],[\"当前尾节点是否为null\",{\"1\":{\"1504\":1}}],[\"当前处于不同的状态对应的结果也是大不相同\",{\"1\":{\"1375\":1}}],[\"当前队列的尾节点不为\",{\"1\":{\"1504\":1}}],[\"当前队列为空\",{\"1\":{\"1352\":1}}],[\"当前队列为空时\",{\"1\":{\"1345\":1}}],[\"当前队列中有数据可供消费\",{\"1\":{\"1347\":2}}],[\"当前时间片用完后就会发生线程调度\",{\"1\":{\"1339\":1}}],[\"当前向环形搜索直到遇到哈希桶\",{\"1\":{\"1317\":2}}],[\"当前向环形搜索遇到脏\",{\"1\":{\"1317\":2}}],[\"当前哈希桶\",{\"1\":{\"1316\":1}}],[\"当前哈希数组长度\",{\"1\":{\"1306\":1}}],[\"当前entitiy不为null的话\",{\"1\":{\"1302\":1}}],[\"当前先把它理解为一个普通的\",{\"1\":{\"1301\":1}}],[\"当前假设第\",{\"1\":{\"1284\":1}}],[\"当前数组中第i个元素为null\",{\"1\":{\"1274\":1}}],[\"当前是否正在扩容\",{\"1\":{\"1272\":1}}],[\"当前是单节点的\",{\"1\":{\"1192\":1}}],[\"当前为红黑树\",{\"1\":{\"1272\":1}}],[\"当前为链表\",{\"1\":{\"1272\":1}}],[\"当前正在扩容\",{\"1\":{\"1272\":1}}],[\"当前条件不满足等待\",{\"1\":{\"1254\":1}}],[\"当前调用\",{\"1\":{\"1252\":1,\"1392\":1}}],[\"当前写状态是否为0\",{\"1\":{\"1240\":1}}],[\"当前线程在超时时间内被中断\",{\"1\":{\"1508\":1}}],[\"当前线程成功获取了锁\",{\"1\":{\"1508\":1}}],[\"当前线程能够获得锁该方法执行结束退出\",{\"1\":{\"1505\":1}}],[\"当前线程可以获取同时将状态更改为\",{\"1\":{\"1496\":1}}],[\"当前线程可获取写锁\",{\"1\":{\"1239\":1}}],[\"当前线程必须获得了锁才能进行等待\",{\"1\":{\"1493\":1}}],[\"当前线程便尝试使用自旋来获取锁\",{\"1\":{\"1446\":1}}],[\"当前线程获得锁出队列\",{\"1\":{\"1508\":1}}],[\"当前线程获得锁\",{\"1\":{\"1446\":1}}],[\"当前线程获取读锁\",{\"1\":{\"1242\":1}}],[\"当前线程获取读锁失败返回\",{\"1\":{\"1242\":1}}],[\"当前线程获取写锁\",{\"1\":{\"1239\":1}}],[\"当前线程获取写锁失败\",{\"1\":{\"1239\":1}}],[\"当前线程才会释放锁\",{\"1\":{\"1404\":1}}],[\"当前线程才能从\",{\"1\":{\"1404\":2}}],[\"当前线程会释放锁\",{\"1\":{\"1404\":1}}],[\"当前线程并不会阻塞\",{\"1\":{\"1394\":1}}],[\"当前线程不会马上释放该对象锁\",{\"1\":{\"1404\":1}}],[\"当前线程不会被阻塞\",{\"1\":{\"1392\":1}}],[\"当前线程不是唯一的或不是第一个发起扩容的线程\",{\"1\":{\"1275\":1}}],[\"当前线程\",{\"1\":{\"1337\":1}}],[\"当前线程是唯一的或是第一个发起扩容的线程\",{\"1\":{\"1275\":1}}],[\"当前线程进入到等待状态\",{\"1\":{\"1251\":2}}],[\"当前线程进入等待状态直到被通知\",{\"1\":{\"1248\":2,\"1410\":2}}],[\"当前线程进入等待状态\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"当前线程请求资源失败\",{\"1\":{\"1233\":1}}],[\"当前已经使用内存的百分比\",{\"1\":{\"1194\":1}}],[\"当前服务的访问路径\",{\"1\":{\"1177\":1}}],[\"当前\",{\"1\":{\"1160\":1,\"1194\":1,\"1316\":1}}],[\"当前对象只需要为其所依赖的对象提供相对应的\",{\"1\":{\"1133\":1}}],[\"当前路径下执行\",{\"1\":{\"1107\":1}}],[\"当前页数据列表\",{\"1\":{\"935\":1}}],[\"当前页码\",{\"1\":{\"935\":1}}],[\"当前分钟的烂橘子都使其相邻位置的橘子也腐烂\",{\"1\":{\"869\":1}}],[\"当前操作\",{\"1\":{\"851\":1}}],[\"当前要查找的字符为\",{\"1\":{\"802\":1}}],[\"当前要加入的字符为\",{\"1\":{\"802\":1}}],[\"当前用户有admin角色权限\",{\"1\":{\"467\":1}}],[\"当前用户有编辑用户权限\",{\"1\":{\"467\":1}}],[\"当前位置部分\",{\"1\":{\"309\":1}}],[\"当前的\",{\"1\":{\"1317\":1}}],[\"当前的系统时间\",{\"1\":{\"1190\":1}}],[\"当前的值\",{\"1\":{\"291\":1}}],[\"当前的数据库设计不能满足该需求\",{\"1\":{\"30\":1}}],[\"当前加入的数字是几\",{\"1\":{\"291\":1}}],[\"当前前缀和\",{\"1\":{\"261\":1}}],[\"当前节点所指向的线程能够获取锁\",{\"1\":{\"1504\":1}}],[\"当前节点能否获取独占式锁\",{\"1\":{\"1504\":1}}],[\"当前节点进入等待队列中\",{\"1\":{\"1501\":1}}],[\"当前节点hash小于0说明为树节点\",{\"1\":{\"1273\":1}}],[\"当前节点的前驱节点是头结点并且成功获得同步状态时\",{\"1\":{\"1506\":1}}],[\"当前节点的数\",{\"1\":{\"898\":2}}],[\"当前节点的右子树已经访问过了\",{\"1\":{\"725\":1}}],[\"当前节点相当于左节点\",{\"1\":{\"731\":1}}],[\"当前节点选\",{\"1\":{\"314\":1}}],[\"当前节点不选\",{\"1\":{\"314\":1}}],[\"当前节点\",{\"1\":{\"223\":1,\"1501\":2}}],[\"当前距离\",{\"1\":{\"223\":1}}],[\"当前距离+估计到终点的距离\",{\"1\":{\"223\":1}}],[\"当前所在格子上面的数字为\",{\"1\":{\"196\":1}}],[\"当前可以种的边界应该是\",{\"1\":{\"173\":1}}],[\"当前种树区间为\",{\"1\":{\"173\":1}}],[\"当前字符匹配\",{\"1\":{\"127\":1}}],[\"当字符变化时更新计数器结果\",{\"1\":{\"82\":1}}],[\"当缓存抖动时候\",{\"1\":{\"48\":1}}],[\"当然在\",{\"1\":{\"1439\":1}}],[\"当然在设计层面可以考虑目录结构进行拆分\",{\"1\":{\"47\":1}}],[\"当然也可以选择挂起线程\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"当然也包含表1和表2交集部分的数据\",{\"1\":{\"945\":2}}],[\"当然我们可以用\",{\"1\":{\"1290\":1}}],[\"当然是根据\",{\"1\":{\"1272\":1}}],[\"当然是在使用依赖对象之前\",{\"1\":{\"1133\":1}}],[\"当然是\",{\"1\":{\"1129\":1}}],[\"当然不建议这么做\",{\"1\":{\"670\":1}}],[\"当然还会有很多相关的岛屿变型题\",{\"1\":{\"231\":1}}],[\"当然\",{\"1\":{\"40\":1,\"104\":2,\"238\":1,\"290\":1,\"423\":1,\"661\":1,\"664\":1,\"1094\":1,\"1305\":1,\"1313\":1,\"1392\":1}}],[\"那如果想阻止重排序要怎么办了\",{\"1\":{\"1457\":1}}],[\"那如果是新添加的定时任务该如何处理呢\",{\"1\":{\"481\":1}}],[\"那线程\",{\"1\":{\"1456\":1}}],[\"那为什么要使用弱引用呢\",{\"1\":{\"1318\":1}}],[\"那为什么不能按照评论维度进行拆分\",{\"1\":{\"37\":1}}],[\"那我们试着在多线程的情况下进行分析\",{\"1\":{\"1283\":1}}],[\"那我们就来研究下底层的源码\",{\"1\":{\"1175\":1}}],[\"那边了\",{\"1\":{\"1184\":1}}],[\"那\",{\"1\":{\"1178\":1}}],[\"那配置项都配置在哪呢\",{\"1\":{\"1150\":1}}],[\"那直接循环判断即可\",{\"1\":{\"777\":1}}],[\"那怎么办呢\",{\"1\":{\"668\":1}}],[\"那这个对象就是线程安全的\",{\"1\":{\"1415\":1}}],[\"那这个评论就是根评论\",{\"1\":{\"56\":1}}],[\"那这又是为什么呢\",{\"1\":{\"1186\":1}}],[\"那这里就填\",{\"1\":{\"665\":1}}],[\"那它就是一个质数\",{\"1\":{\"371\":1}}],[\"那等于说走过一次就不能走了\",{\"1\":{\"235\":1}}],[\"那就会继续执行\",{\"1\":{\"1508\":1}}],[\"那就只剩下为链表的形式的一种可能性了\",{\"1\":{\"1273\":1}}],[\"那就要求\",{\"1\":{\"846\":1}}],[\"那就是无法连接上端口\",{\"1\":{\"663\":1}}],[\"那就是定时任务\",{\"1\":{\"475\":1}}],[\"那就匹配并标记\",{\"1\":{\"363\":1}}],[\"那就一定有解\",{\"1\":{\"224\":1}}],[\"那就可以直接通过这些\",{\"1\":{\"56\":1}}],[\"那么当获取锁失败的时候会调用\",{\"1\":{\"1505\":1}}],[\"那么当前位置的最长有效括号长度还需要加上这一段\",{\"1\":{\"846\":1}}],[\"那么紧接着会有下一个问题\",{\"1\":{\"1504\":1}}],[\"那么带头节点的队列初始化时机是什么\",{\"1\":{\"1504\":1}}],[\"那么是不是真的就像我们分析的一样了\",{\"1\":{\"1504\":1}}],[\"那么如何理解这些指令了\",{\"1\":{\"1482\":1}}],[\"那么如何定义\",{\"1\":{\"33\":1}}],[\"那么程序默认会进入轻量级锁状态\",{\"1\":{\"1444\":1}}],[\"那么程序员的负担就太重了\",{\"1\":{\"1419\":1}}],[\"那么我们能不能让每次通过的速度变快一点了\",{\"1\":{\"1434\":1}}],[\"那么我们继续来看\",{\"1\":{\"1283\":1}}],[\"那么共享数据的线程安全问题怎样处理\",{\"1\":{\"1429\":1}}],[\"那么编译器可以把这个\",{\"1\":{\"1423\":1}}],[\"那么线程\",{\"1\":{\"1421\":1,\"1475\":1,\"1482\":1}}],[\"那么线程数应该设置越大\",{\"1\":{\"1361\":1}}],[\"那么什么情况下\",{\"1\":{\"1418\":1}}],[\"那么什么情况下会使得\",{\"1\":{\"1284\":1}}],[\"那么优先级低的任务可能永远不能执行\",{\"1\":{\"1361\":1}}],[\"那么分解后执行的吞吐率要高于串行执行的吞吐率\",{\"1\":{\"1361\":1}}],[\"那么实践中我们应该怎么做\",{\"1\":{\"1320\":1}}],[\"那么根据\",{\"1\":{\"1508\":1}}],[\"那么根据在向前搜索中是否还有脏\",{\"1\":{\"1317\":1}}],[\"那么根据每个元素的地址值又会找到下面的子节点\",{\"1\":{\"958\":1}}],[\"那么它会同步等待另一个线程也执行\",{\"1\":{\"1399\":1}}],[\"那么它的\",{\"1\":{\"1306\":1}}],[\"那么它就是一个完美匹配\",{\"1\":{\"363\":1}}],[\"那么系统\",{\"1\":{\"1305\":1}}],[\"那么再写入\",{\"1\":{\"1295\":1}}],[\"那么再从头开始查找\",{\"1\":{\"420\":1}}],[\"那么此时线程\",{\"1\":{\"1284\":1}}],[\"那么此时的判断就非常清晰\",{\"1\":{\"174\":1}}],[\"那么应该做的就是寻找\",{\"1\":{\"1284\":1}}],[\"那么还剩下第\",{\"1\":{\"1283\":1}}],[\"那么这种重排序并不非法\",{\"1\":{\"1420\":1}}],[\"那么这张纸条就是这两个线程间通信的共享变量\",{\"1\":{\"1416\":1}}],[\"那么这样设计的意图是什么呢\",{\"1\":{\"1286\":1}}],[\"那么这么写就不会有任何作用\",{\"1\":{\"1283\":1}}],[\"那么这个标志就是存放在\",{\"1\":{\"1440\":1}}],[\"那么这个正在执行的线程还需要获取该锁吗\",{\"1\":{\"1431\":1}}],[\"那么这个锁可以被消除\",{\"1\":{\"1423\":1}}],[\"那么这个时候很有可能造成频繁的\",{\"1\":{\"1295\":1}}],[\"那么这个时候线程\",{\"1\":{\"1283\":1}}],[\"那么这个类就应该被设计为单例类\",{\"1\":{\"963\":1}}],[\"那么这个前缀和就能和前面每一个组成一个组合\",{\"1\":{\"261\":1}}],[\"那么这个区间内任意三根木桩都能构成三角形\",{\"1\":{\"78\":1}}],[\"那么为了能够理解\",{\"1\":{\"1283\":1}}],[\"那么使用\",{\"1\":{\"1272\":1}}],[\"那么接下来在\",{\"1\":{\"1317\":2}}],[\"那么接下来\",{\"1\":{\"1272\":1}}],[\"那么怎样确定当前的这个\",{\"1\":{\"1272\":1}}],[\"那么怎样根据\",{\"1\":{\"1272\":1}}],[\"那么增加了一个\",{\"1\":{\"1259\":1}}],[\"那么要想退出这个\",{\"1\":{\"1251\":1}}],[\"那么要执行多表查询\",{\"1\":{\"942\":1}}],[\"那么关于这个实现过程\",{\"1\":{\"1251\":1}}],[\"那么低\",{\"1\":{\"1239\":1}}],[\"那么锁的获取顺序就应该符合请求上的绝对时间顺序\",{\"1\":{\"1233\":1}}],[\"那么释放的时候处理思路是怎样的了\",{\"1\":{\"1232\":1}}],[\"那么只有锁在被释放同样的\",{\"1\":{\"1232\":1}}],[\"那么只要找到集合里能够出现\",{\"1\":{\"772\":1}}],[\"那么其他线程必须等待\",{\"1\":{\"1226\":1}}],[\"那么其他线程需要这个资源就必须进行等待该资源的释放\",{\"1\":{\"1225\":1}}],[\"那么真实系统环境下不能并行\",{\"1\":{\"1224\":1}}],[\"那么之前产生的子list将会失效\",{\"1\":{\"1072\":1}}],[\"那么每个同学就是\",{\"1\":{\"1025\":1}}],[\"那么第一个操作的执行结果将对第二个操作可见\",{\"1\":{\"1420\":1}}],[\"那么第一件事就是要定位准备删除的队头节点\",{\"1\":{\"1284\":1}}],[\"那么第\",{\"1\":{\"1283\":1}}],[\"那么第三层总元素大小就是\",{\"1\":{\"958\":1}}],[\"那么第二层即第二次\",{\"1\":{\"958\":1}}],[\"那么结合第二层每个元素通过指针域找到第三层的节点\",{\"1\":{\"958\":1}}],[\"那么可以计算出一个节点可以存储的元素个数\",{\"1\":{\"958\":1}}],[\"那么会找到第三层\",{\"1\":{\"958\":1}}],[\"那么会造成效率极其低下\",{\"1\":{\"958\":1}}],[\"那么会导致最大的变最小的\",{\"1\":{\"705\":1}}],[\"那么一个用户有可能需要\",{\"1\":{\"958\":1}}],[\"那么查询\",{\"1\":{\"958\":1}}],[\"那么数据库的所有变化将会被回滚\",{\"1\":{\"955\":1}}],[\"那么数据库的所有变化将生效\",{\"1\":{\"955\":1}}],[\"那么计算结果为0\",{\"1\":{\"932\":1}}],[\"那么在效率上会有一定的提升\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"那么在第\",{\"1\":{\"1283\":2}}],[\"那么在下一次循环中第\",{\"1\":{\"1283\":1}}],[\"那么在插入节点的时候\",{\"1\":{\"1283\":1}}],[\"那么在\",{\"1\":{\"1282\":1}}],[\"那么在数据库层面怎么去体现上述两者之间是一对一的关系呢\",{\"1\":{\"938\":1}}],[\"那么在复制链表中对应的两个节点\",{\"1\":{\"886\":1}}],[\"那么在用户注册时\",{\"1\":{\"613\":1}}],[\"那么答案就是\",{\"1\":{\"881\":1}}],[\"那么答案为\",{\"1\":{\"795\":1}}],[\"那么需要枚举\",{\"1\":{\"851\":1}}],[\"那么有没有线程安全问题呢\",{\"1\":{\"1100\":1}}],[\"那么有\",{\"1\":{\"846\":2}}],[\"那么物品遍历放在外层\",{\"1\":{\"772\":1}}],[\"那么非\",{\"1\":{\"772\":2}}],[\"那么请将最后剩余的节点保持原有顺序\",{\"1\":{\"680\":1}}],[\"那么该用户名是无法从布隆过滤器中删除的\",{\"1\":{\"613\":1}}],[\"那么缓存穿透的话\",{\"1\":{\"613\":1}}],[\"那么人人都可以调用\",{\"1\":{\"578\":1}}],[\"那么校验写在哪里\",{\"1\":{\"576\":1}}],[\"那么考虑使用\",{\"1\":{\"525\":1}}],[\"那么相乘会大于\",{\"1\":{\"368\":1}}],[\"那么相同的\",{\"1\":{\"60\":1}}],[\"那么加上自己之后一共有n+1个点\",{\"1\":{\"356\":1}}],[\"那么最短路可能为负无穷\",{\"1\":{\"354\":1}}],[\"那么最少需要扩大一个才可以选择\",{\"1\":{\"174\":1}}],[\"那么子节点随意\",{\"1\":{\"314\":1}}],[\"那么称这一段数是两个数列的公共上升子序列\",{\"1\":{\"304\":1}}],[\"那么题目就是要我们求\",{\"1\":{\"261\":1}}],[\"那么对象的锁怎么理解\",{\"1\":{\"1440\":1}}],[\"那么对于任意的整数\",{\"1\":{\"248\":1,\"383\":1}}],[\"那么对应的方向数组也需要做出改变\",{\"1\":{\"228\":1}}],[\"那么就存在两种方式\",{\"1\":{\"1416\":1}}],[\"那么就需要采用一种策略来处理这种情况\",{\"1\":{\"1359\":1}}],[\"那么就需要搜索八个方向\",{\"1\":{\"228\":1}}],[\"那么就以当前位置作为cleansomeslots的起点\",{\"1\":{\"1317\":1}}],[\"那么就新建一个并把它设置到当前线程中\",{\"1\":{\"1309\":1}}],[\"那么就无法\",{\"1\":{\"1306\":1}}],[\"那么就按照数值大小以及字典序排序即可\",{\"1\":{\"1074\":1}}],[\"那么就得增加树的宽度\",{\"1\":{\"958\":1}}],[\"那么就找到了\",{\"1\":{\"881\":1}}],[\"那么就不满足条件\",{\"1\":{\"875\":1}}],[\"那么就是对每个节点计算左右子树的最大高度\",{\"1\":{\"760\":1}}],[\"那么就没必要让j继续入队了\",{\"1\":{\"223\":1}}],[\"那么就把它变成\",{\"1\":{\"161\":1}}],[\"那么\",{\"1\":{\"213\":1,\"261\":2,\"273\":1,\"324\":1,\"371\":1,\"407\":2,\"613\":1,\"795\":1,\"852\":1,\"958\":1,\"963\":1,\"1131\":1,\"1132\":1,\"1140\":1,\"1175\":1,\"1184\":1,\"1221\":1,\"1231\":1,\"1272\":1,\"1283\":1,\"1299\":1,\"1316\":1,\"1345\":1,\"1382\":1,\"1416\":1,\"1420\":1,\"1421\":2,\"1429\":2,\"1436\":1,\"1454\":1,\"1467\":1,\"1473\":1,\"1501\":1}}],[\"那么游戏中的角色在平地和山脉中移动的速度通常是不相等的\",{\"1\":{\"213\":1}}],[\"那么必然是平局\",{\"1\":{\"174\":1}}],[\"那么美观度为\",{\"1\":{\"147\":1}}],[\"那么通过\",{\"1\":{\"56\":1}}],[\"那么异步处理后用户体验是如何保证的呢\",{\"1\":{\"28\":1}}],[\"那大量写操作后读操作缓存命中率低的问题如何解决呢\",{\"1\":{\"31\":1}}],[\"刷题过程中常用\",{\"1\":{\"1066\":1}}],[\"刷缓存\",{\"1\":{\"31\":1}}],[\"刷新\",{\"1\":{\"31\":1}}],[\"程序逻辑同独占锁可响应中断式获取基本一致\",{\"1\":{\"1508\":1}}],[\"程序逻辑如图所示\",{\"1\":{\"1508\":1}}],[\"程序逻辑通过注释已经标出\",{\"1\":{\"1504\":1}}],[\"程序的逻辑主要分为两个部分\",{\"1\":{\"1504\":1}}],[\"程序的执行结果不能被改变\",{\"1\":{\"1418\":1}}],[\"程序主要是靠\",{\"1\":{\"1492\":1}}],[\"程序主动写缓存和\",{\"1\":{\"31\":1}}],[\"程序天然的有序性可以总结为\",{\"1\":{\"1485\":1}}],[\"程序天生就是一个多线程程序\",{\"1\":{\"1330\":1}}],[\"程序顺序规则\",{\"1\":{\"1421\":1}}],[\"程序员为了理解\",{\"1\":{\"1424\":1}}],[\"程序员来说\",{\"1\":{\"1424\":1}}],[\"程序员希望基于一个强内存模型来编写代码\",{\"1\":{\"1423\":1}}],[\"程序员希望内存模型易于理解\",{\"1\":{\"1423\":1}}],[\"程序员对内存模型的使用\",{\"1\":{\"1423\":1}}],[\"程序员对于这两个操作是否真的被重排序并不关心\",{\"1\":{\"1420\":1}}],[\"程序员关心的是程序执行时的语义不能被改变\",{\"1\":{\"1420\":1}}],[\"程序员们自动转换变量名\",{\"1\":{\"98\":1}}],[\"程序从\",{\"1\":{\"1330\":1}}],[\"程序自动退出\",{\"1\":{\"1060\":1}}],[\"程序就不能编译通过\",{\"1\":{\"1044\":1}}],[\"程序应该从逻辑角度尽可能避免这类异常的发生\",{\"1\":{\"1044\":1}}],[\"程序中断规则\",{\"1\":{\"1421\":1}}],[\"程序中\",{\"1\":{\"1339\":1}}],[\"程序中可以选择捕获处理\",{\"1\":{\"1044\":1}}],[\"程序中应当尽可能去处理这些异常\",{\"1\":{\"1042\":1}}],[\"程序如下所示\",{\"1\":{\"1010\":1}}],[\"程序\",{\"1\":{\"995\":1,\"1293\":1}}],[\"程序代替人工\",{\"1\":{\"564\":1}}],[\"程序人生\",{\"0\":{\"19\":1}}],[\"操作重排序\",{\"1\":{\"1485\":1}}],[\"操作从工作内存中得到的变量的值放入主内存的变量中\",{\"1\":{\"1482\":1}}],[\"操作从主内存中得到的变量值放入工作内存中的变量副本\",{\"1\":{\"1482\":1}}],[\"操作将\",{\"1\":{\"1447\":1}}],[\"操作将对\",{\"1\":{\"1420\":1}}],[\"操作来加锁和解锁\",{\"1\":{\"1442\":1}}],[\"操作来确保\",{\"1\":{\"1276\":1}}],[\"操作就可以保证其原子性\",{\"1\":{\"1439\":1}}],[\"操作彼此不存在数据依赖性\",{\"1\":{\"1421\":1}}],[\"操作之前\",{\"1\":{\"1421\":1}}],[\"操作可见\",{\"1\":{\"1420\":1}}],[\"操作可以调用\",{\"1\":{\"688\":1}}],[\"操作在不同的线程中执行\",{\"1\":{\"1420\":1}}],[\"操作比较简单\",{\"1\":{\"1394\":1}}],[\"操作一个变量时\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"操作具体实现\",{\"1\":{\"1380\":1}}],[\"操作具有超时特性\",{\"1\":{\"1326\":1}}],[\"操作和\",{\"1\":{\"1420\":1}}],[\"操作和一次\",{\"1\":{\"1340\":1}}],[\"操作和上面的类似\",{\"1\":{\"1274\":1}}],[\"操作等等\",{\"1\":{\"1293\":1}}],[\"操作了\",{\"1\":{\"1283\":1}}],[\"操作成功返回\",{\"1\":{\"1421\":1}}],[\"操作成功走到第\",{\"1\":{\"1283\":1}}],[\"操作成功会直接\",{\"1\":{\"1283\":1}}],[\"操作失败的重试\",{\"1\":{\"1506\":1}}],[\"操作失败的话就在\",{\"1\":{\"1283\":1}}],[\"操作失败会在\",{\"1\":{\"1504\":1}}],[\"操作失败会继续自旋\",{\"1\":{\"1504\":1}}],[\"操作失败后会进行一定的尝试\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"操作失败\",{\"1\":{\"1283\":1,\"1511\":1}}],[\"操作有这样几个\",{\"1\":{\"1282\":1}}],[\"操作直接放入\",{\"1\":{\"1272\":1}}],[\"操作直接继承父类的\",{\"1\":{\"688\":1}}],[\"操作设置尾节点\",{\"1\":{\"1504\":1}}],[\"操作设置\",{\"1\":{\"1268\":1}}],[\"操作依赖于现代处理器指令集\",{\"1\":{\"1266\":1}}],[\"操作的执行顺序在\",{\"1\":{\"1421\":1}}],[\"操作的结果将对\",{\"1\":{\"1420\":1}}],[\"操作的方法来进行实现\",{\"1\":{\"1385\":1}}],[\"操作的线程安全性\",{\"1\":{\"1264\":1}}],[\"操作的注意事项\",{\"1\":{\"925\":1}}],[\"操作符\",{\"1\":{\"949\":1}}],[\"操作时\",{\"1\":{\"808\":1}}],[\"操作数据库的对象\",{\"1\":{\"567\":1}}],[\"操作数据库的框架\",{\"1\":{\"557\":1}}],[\"操作数据库\",{\"1\":{\"564\":1}}],[\"操作数每右移一位\",{\"1\":{\"338\":1}}],[\"操作\",{\"0\":{\"954\":1,\"1102\":1,\"1103\":1,\"1282\":2,\"1381\":1,\"1435\":1},\"1\":{\"50\":2,\"129\":4,\"243\":1,\"417\":1,\"436\":1,\"526\":1,\"532\":1,\"592\":1,\"1274\":1,\"1282\":1,\"1284\":1,\"1285\":1,\"1340\":1,\"1361\":1,\"1380\":1,\"1381\":1,\"1382\":1,\"1385\":2,\"1421\":1,\"1436\":1,\"1482\":2,\"1504\":1}}],[\"操作不会顺序错乱\",{\"1\":{\"31\":1}}],[\"操作系统会分出一个个时间片\",{\"1\":{\"1339\":1}}],[\"操作系统会考虑线程的优先级\",{\"1\":{\"1331\":1}}],[\"操作系统会剥夺该线程的运行权\",{\"1\":{\"1331\":1}}],[\"操作系统\",{\"0\":{\"12\":1},\"1\":{\"7\":1}}],[\"zero\",{\"1\":{\"1496\":2}}],[\"zeus\",{\"1\":{\"1033\":2,\"1034\":1}}],[\"zsh\",{\"1\":{\"1107\":1}}],[\"zxvf\",{\"1\":{\"670\":1}}],[\"zipdateformat>\",{\"1\":{\"1090\":1}}],[\"zip\",{\"1\":{\"665\":2}}],[\"zi​=2\",{\"1\":{\"274\":2}}],[\"zi​=1\",{\"1\":{\"274\":1}}],[\"zi​\",{\"1\":{\"274\":1}}],[\"zone=public\",{\"1\":{\"663\":2}}],[\"z\",{\"1\":{\"88\":1,\"250\":1,\"274\":4,\"981\":1,\"1004\":2}}],[\"za\",{\"1\":{\"88\":1}}],[\"zadd\",{\"1\":{\"31\":1}}],[\"zdd\",{\"1\":{\"58\":1}}],[\"zhang\",{\"1\":{\"568\":1}}],[\"zhangsan\",{\"1\":{\"568\":5}}],[\"zhihu\",{\"1\":{\"41\":1}}],[\"zhuanlan\",{\"1\":{\"41\":1}}],[\"zh\",{\"1\":{\"41\":1,\"548\":1}}],[\"zrem\",{\"1\":{\"31\":1}}],[\"和处理器共同为编写单线程程序的程序员创建了一个幻觉\",{\"1\":{\"1418\":1}}],[\"和处理器都必须遵守\",{\"1\":{\"1418\":1}}],[\"和查找的\",{\"1\":{\"1307\":1}}],[\"和大多数容器一样内部维护了一个数组\",{\"1\":{\"1305\":1}}],[\"和读写锁都是通过读写分离的思想实现的\",{\"1\":{\"1295\":1}}],[\"和队尾节点的距离为\",{\"1\":{\"1286\":1}}],[\"和线程\",{\"1\":{\"1283\":1,\"1284\":1,\"1285\":1,\"1417\":2,\"1456\":1,\"1475\":1,\"1476\":1}}],[\"和线程b\",{\"1\":{\"1253\":1}}],[\"和公平的锁获取方式\",{\"1\":{\"1237\":1}}],[\"和之前初始化\",{\"1\":{\"1157\":1}}],[\"和之前讲过的\",{\"1\":{\"1153\":1}}],[\"和定义常量来获取配置项的方式不同\",{\"1\":{\"1147\":1}}],[\"和定义逻辑自恰\",{\"1\":{\"864\":1}}],[\"和校验和\",{\"1\":{\"1095\":1}}],[\"和传统对象存储相比\",{\"1\":{\"1095\":1}}],[\"和可变字符串\",{\"1\":{\"1068\":1}}],[\"和a\",{\"1\":{\"1020\":1}}],[\"和字段值的长度无关\",{\"1\":{\"920\":1}}],[\"和d\",{\"1\":{\"920\":2}}],[\"和其配对的位置为\",{\"1\":{\"846\":1}}],[\"和一个字符串列表\",{\"1\":{\"782\":1}}],[\"和一个整数\",{\"1\":{\"709\":1,\"880\":1}}],[\"和数据库服务器\",{\"1\":{\"671\":1}}],[\"和数据库实体类\",{\"1\":{\"515\":1}}],[\"和端口\",{\"1\":{\"665\":1}}],[\"和标题等其他条件来搜索题目\",{\"1\":{\"525\":1}}],[\"和题目\",{\"1\":{\"526\":1}}],[\"和题目id\",{\"1\":{\"513\":1}}],[\"和题目答案可能很长\",{\"1\":{\"512\":1}}],[\"和题目创建人\",{\"1\":{\"512\":1}}],[\"和用户表关联\",{\"1\":{\"511\":1}}],[\"和个人信息\",{\"1\":{\"510\":1}}],[\"和上面类似\",{\"1\":{\"422\":1}}],[\"和条件\",{\"1\":{\"395\":1}}],[\"和前面每一个都组合一下\",{\"1\":{\"261\":1}}],[\"和第\",{\"1\":{\"223\":1}}],[\"和购买目标商品\",{\"1\":{\"168\":1}}],[\"和m\",{\"1\":{\"147\":1}}],[\"和模式串\",{\"1\":{\"127\":1}}],[\"和为奇数时\",{\"1\":{\"772\":1}}],[\"和为0的方案数为1\",{\"1\":{\"126\":1}}],[\"和为\",{\"1\":{\"126\":1}}],[\"和尽可能高的写吞吐\",{\"1\":{\"40\":1}}],[\"和\",{\"0\":{\"1247\":1,\"1343\":1},\"1\":{\"31\":1,\"40\":2,\"47\":1,\"66\":3,\"71\":2,\"72\":2,\"92\":2,\"93\":1,\"103\":1,\"104\":2,\"109\":2,\"115\":2,\"126\":1,\"127\":1,\"140\":1,\"157\":1,\"161\":1,\"166\":1,\"167\":2,\"168\":3,\"178\":2,\"180\":1,\"181\":3,\"186\":1,\"205\":1,\"215\":2,\"223\":3,\"243\":2,\"261\":3,\"263\":1,\"273\":4,\"278\":1,\"280\":1,\"290\":1,\"291\":1,\"303\":2,\"304\":2,\"305\":1,\"306\":1,\"309\":2,\"317\":1,\"318\":1,\"321\":1,\"322\":1,\"323\":1,\"329\":1,\"330\":1,\"351\":1,\"362\":1,\"372\":2,\"383\":1,\"384\":2,\"392\":1,\"422\":1,\"434\":2,\"438\":2,\"471\":1,\"484\":1,\"489\":1,\"510\":1,\"515\":2,\"526\":1,\"531\":1,\"539\":2,\"559\":1,\"661\":1,\"662\":1,\"665\":1,\"668\":1,\"671\":1,\"672\":1,\"686\":1,\"687\":2,\"755\":1,\"765\":1,\"777\":1,\"794\":2,\"819\":1,\"822\":2,\"827\":1,\"833\":3,\"838\":1,\"839\":1,\"840\":5,\"844\":1,\"846\":2,\"886\":2,\"887\":2,\"888\":1,\"920\":2,\"945\":1,\"990\":1,\"1075\":1,\"1082\":1,\"1090\":1,\"1095\":2,\"1132\":1,\"1133\":1,\"1137\":1,\"1141\":1,\"1147\":1,\"1155\":1,\"1158\":1,\"1160\":1,\"1178\":1,\"1180\":1,\"1191\":1,\"1237\":1,\"1248\":2,\"1250\":1,\"1253\":2,\"1254\":1,\"1258\":1,\"1272\":2,\"1274\":2,\"1281\":2,\"1283\":3,\"1284\":5,\"1285\":2,\"1286\":3,\"1292\":1,\"1295\":1,\"1304\":2,\"1306\":3,\"1314\":1,\"1317\":1,\"1326\":1,\"1334\":1,\"1336\":1,\"1339\":1,\"1344\":1,\"1346\":2,\"1348\":1,\"1350\":2,\"1353\":2,\"1359\":1,\"1360\":2,\"1365\":2,\"1368\":1,\"1369\":1,\"1370\":1,\"1371\":1,\"1383\":2,\"1393\":1,\"1407\":1,\"1410\":1,\"1418\":2,\"1437\":2,\"1444\":1,\"1456\":1,\"1472\":2,\"1476\":2,\"1478\":2,\"1482\":7,\"1485\":2,\"1496\":4,\"1504\":1,\"1506\":1}}],[\"消耗\",{\"1\":{\"957\":1}}],[\"消耗性能\",{\"1\":{\"937\":1}}],[\"消耗换行符\",{\"1\":{\"129\":1}}],[\"消费数据\",{\"1\":{\"1409\":9,\"1410\":9}}],[\"消费者实现的三种方式\",{\"1\":{\"1411\":1}}],[\"消费者很简洁\",{\"1\":{\"1411\":1}}],[\"消费者pool\",{\"1\":{\"1409\":11,\"1410\":13,\"1411\":17}}],[\"消费者模式是一个十分经典的多线程并发协作的模式\",{\"1\":{\"1402\":1}}],[\"消费者问题时\",{\"1\":{\"1402\":1}}],[\"消费者问题能够让我们对并发编程的理解加深\",{\"1\":{\"1402\":1}}],[\"消费者问题\",{\"0\":{\"1402\":1},\"1\":{\"1402\":1,\"1410\":1,\"1411\":1}}],[\"消费者线程会被阻塞\",{\"1\":{\"1324\":1}}],[\"消费者\",{\"0\":{\"1409\":1,\"1410\":1,\"1411\":1},\"1\":{\"1324\":2,\"1326\":2,\"1344\":1,\"1409\":3,\"1410\":3,\"1411\":1}}],[\"消费者对点击数据进行去重处理\",{\"1\":{\"151\":1}}],[\"消费者从消息队列中读取点击数据\",{\"1\":{\"151\":1}}],[\"消费者顺序执行\",{\"1\":{\"31\":1}}],[\"消费能力就下降\",{\"1\":{\"49\":1}}],[\"消息通知的原理解析可以看这篇文章\",{\"1\":{\"1410\":1}}],[\"消息通知潜在的一些问题\",{\"0\":{\"1405\":1}}],[\"消息队列\",{\"1\":{\"151\":1}}],[\"消息队列的最大用途是\",{\"1\":{\"46\":1}}],[\"消息直接\",{\"1\":{\"60\":1}}],[\"消息\",{\"1\":{\"60\":1}}],[\"消息中间件\",{\"1\":{\"14\":1}}],[\"选\",{\"1\":{\"795\":1,\"893\":1}}],[\"选或不选\",{\"1\":{\"795\":1,\"851\":1}}],[\"选的次数没有限制\",{\"1\":{\"795\":1}}],[\"选出右端点最大的\",{\"1\":{\"430\":1}}],[\"选中奇数个集合\",{\"1\":{\"392\":1}}],[\"选中一个集合\",{\"1\":{\"392\":1}}],[\"选中的集合数量\",{\"1\":{\"392\":1}}],[\"选中集合对应质数的乘积\",{\"1\":{\"392\":1}}],[\"选了某个节点就不能选父节点和子节点\",{\"1\":{\"314\":1}}],[\"选取下一个邻近节点\",{\"1\":{\"215\":1}}],[\"选择运行该新线程\",{\"1\":{\"1334\":1}}],[\"选择服务器类型为\",{\"1\":{\"672\":1}}],[\"选择使用开放寻址法来解决\",{\"1\":{\"1306\":1}}],[\"选择使用\",{\"1\":{\"668\":1}}],[\"选择使得总伤害最小的那个\",{\"1\":{\"110\":1}}],[\"选择\",{\"1\":{\"576\":1,\"592\":1,\"670\":1,\"827\":1,\"839\":1}}],[\"选择合适的渲染模式\",{\"1\":{\"532\":1,\"533\":1}}],[\"选择一个估计距离最小的点\",{\"1\":{\"221\":1}}],[\"选择元素\",{\"1\":{\"178\":1}}],[\"选择较小的节点作为合并后的链表的头节点\",{\"1\":{\"134\":1}}],[\"选择当前数\",{\"1\":{\"126\":1}}],[\"选择相邻的两个数\",{\"1\":{\"104\":1}}],[\"选择的是评论区\",{\"1\":{\"31\":1}}],[\"选用\",{\"1\":{\"31\":1}}],[\"避免一个线程在锁内部占有多个资源\",{\"1\":{\"1221\":1}}],[\"避免一个线程同时获得多个锁\",{\"1\":{\"1221\":1}}],[\"避免创建不需要的线程\",{\"1\":{\"1220\":1}}],[\"避免下标越界\",{\"1\":{\"828\":1}}],[\"避免单个节点过载\",{\"1\":{\"484\":1}}],[\"避免和头文件next冲突\",{\"1\":{\"411\":1}}],[\"避免发生边界问题导致死循环\",{\"1\":{\"317\":1}}],[\"避免维护\",{\"1\":{\"228\":1,\"820\":1}}],[\"避免重复合并操作\",{\"1\":{\"822\":1}}],[\"避免重复计算\",{\"1\":{\"784\":1,\"827\":1}}],[\"避免重复计费\",{\"1\":{\"151\":1}}],[\"避免重复筛选\",{\"1\":{\"373\":1}}],[\"避免重复回传数据\",{\"1\":{\"151\":1}}],[\"避免使用评论\",{\"1\":{\"57\":1}}],[\"避免每次都重新统计\",{\"1\":{\"57\":1}}],[\"避免依赖\",{\"1\":{\"50\":1}}],[\"避免频繁\",{\"1\":{\"48\":1}}],[\"避免风险数据外泄\",{\"1\":{\"36\":1}}],[\"避免高优先级操作被低优先级操作覆盖\",{\"1\":{\"36\":1}}],[\"避免并发写操作时\",{\"1\":{\"31\":1}}],[\"避免此类极端情况导致的数据缺失\",{\"1\":{\"31\":1}}],[\"避免了并行处理导致的一些数据错乱风险\",{\"1\":{\"28\":1}}],[\"earlynotify\",{\"1\":{\"1406\":2}}],[\"each\",{\"1\":{\"1074\":2}}],[\"eh\",{\"1\":{\"1273\":3}}],[\"ehcache<\",{\"1\":{\"1209\":1}}],[\"ehcache\",{\"0\":{\"1209\":1},\"1\":{\"1209\":1}}],[\"ek\",{\"1\":{\"1272\":8,\"1273\":7}}],[\"either\",{\"1\":{\"1239\":1,\"1242\":1,\"1315\":1,\"1317\":1}}],[\"eof\",{\"1\":{\"1110\":2}}],[\"echo\",{\"1\":{\"1107\":1,\"1109\":1,\"1113\":3,\"1115\":1,\"1117\":4,\"1119\":5,\"1123\":4,\"1124\":2,\"1125\":2}}],[\"effect\",{\"1\":{\"1102\":1,\"1243\":1}}],[\"efefef\",{\"1\":{\"549\":1}}],[\"e2\",{\"1\":{\"1078\":4}}],[\"e2e\",{\"1\":{\"559\":2}}],[\"e1\",{\"1\":{\"1078\":4}}],[\"e+308\",{\"1\":{\"920\":3}}],[\"e+38\",{\"1\":{\"920\":3}}],[\"etc\",{\"1\":{\"672\":2,\"1350\":2,\"1351\":1}}],[\"equalsignorecase\",{\"1\":{\"1069\":1}}],[\"equals\",{\"1\":{\"568\":1,\"1005\":1,\"1067\":1,\"1069\":1,\"1082\":1,\"1272\":3,\"1273\":2,\"1472\":2}}],[\"eq\",{\"1\":{\"525\":1,\"526\":2,\"568\":1,\"575\":2}}],[\"emergency\",{\"1\":{\"1191\":1}}],[\"emp\",{\"1\":{\"922\":3,\"926\":2,\"942\":3}}],[\"empty\",{\"1\":{\"93\":2,\"110\":2,\"122\":1,\"133\":1,\"174\":2,\"279\":1,\"406\":2,\"409\":2,\"422\":7,\"429\":1,\"1037\":1,\"1272\":1,\"1410\":3}}],[\"email\",{\"1\":{\"471\":2,\"566\":2,\"589\":1,\"592\":1}}],[\"eurekamonitors\",{\"1\":{\"1168\":1}}],[\"eurekaservercontext\",{\"1\":{\"1164\":2}}],[\"eurekaservercontextholder\",{\"1\":{\"1164\":4}}],[\"eurekaserverconfig\",{\"1\":{\"1147\":4,\"1150\":3,\"1151\":1,\"1153\":1,\"1160\":1,\"1162\":1,\"1163\":1}}],[\"eurekatransport\",{\"1\":{\"1158\":2,\"1182\":1,\"1184\":2}}],[\"eurekaclientconfig\",{\"1\":{\"1157\":3}}],[\"eurekaclient\",{\"0\":{\"1158\":1,\"1181\":1},\"1\":{\"1157\":2,\"1158\":1,\"1160\":2,\"1162\":1,\"1175\":2,\"1182\":4}}],[\"eurekaconfigbasedinstanceinfoprovider\",{\"1\":{\"1153\":1,\"1154\":1,\"1179\":1}}],[\"eurekainstanceconfig\",{\"1\":{\"1154\":1,\"1178\":5}}],[\"eurekapropsfile\",{\"1\":{\"1149\":3}}],[\"eurekabootstrap\",{\"1\":{\"1145\":2,\"1146\":1}}],[\"eureka\",{\"0\":{\"1144\":1,\"1147\":1,\"1148\":1,\"1156\":1,\"1157\":1,\"1168\":1,\"1175\":1,\"1183\":1,\"1189\":1},\"1\":{\"1144\":1,\"1145\":4,\"1149\":10,\"1150\":1,\"1151\":1,\"1153\":3,\"1157\":7,\"1158\":8,\"1160\":3,\"1165\":1,\"1171\":1,\"1172\":2,\"1175\":8,\"1177\":4,\"1178\":2,\"1182\":3,\"1184\":8,\"1185\":4,\"1186\":5,\"1189\":3,\"1190\":3,\"1191\":6,\"1192\":1,\"1193\":1,\"1194\":4,\"1195\":2}}],[\"eulers\",{\"1\":{\"380\":1}}],[\"euler\",{\"1\":{\"380\":7}}],[\"euclideandistance\",{\"1\":{\"216\":1}}],[\"edges为先修课程关系\",{\"1\":{\"876\":1}}],[\"edges\",{\"1\":{\"354\":4,\"361\":6,\"875\":2,\"876\":2}}],[\"edge\",{\"1\":{\"345\":1,\"354\":1,\"361\":2,\"875\":3,\"876\":3}}],[\"editable=\",{\"1\":{\"592\":1}}],[\"editable\",{\"1\":{\"592\":1}}],[\"editor\",{\"1\":{\"576\":1}}],[\"edittime\",{\"1\":{\"510\":3,\"511\":1,\"512\":1}}],[\"edit\",{\"1\":{\"305\":2,\"457\":1,\"467\":3,\"481\":2}}],[\"erasure\",{\"1\":{\"1095\":1}}],[\"erase\",{\"1\":{\"341\":1,\"422\":3}}],[\"errorcode\",{\"1\":{\"523\":3,\"525\":1,\"526\":7}}],[\"error\",{\"0\":{\"1042\":1},\"1\":{\"243\":1,\"481\":7,\"523\":3,\"525\":1,\"526\":7,\"587\":6,\"589\":3,\"591\":1,\"592\":2,\"672\":2,\"1042\":1,\"1232\":1,\"1233\":1,\"1239\":1,\"1266\":1}}],[\"eps\",{\"1\":{\"325\":3,\"385\":4}}],[\"eligible\",{\"1\":{\"1239\":1,\"1242\":2}}],[\"elif\",{\"1\":{\"167\":1}}],[\"eldest\",{\"1\":{\"688\":1}}],[\"ellipsis\",{\"1\":{\"592\":2}}],[\"elasticsearch\",{\"1\":{\"493\":1,\"500\":1}}],[\"el\",{\"1\":{\"457\":4}}],[\"elementdequeued\",{\"1\":{\"1348\":1}}],[\"elements\",{\"1\":{\"1081\":2,\"1294\":3,\"1295\":3,\"1315\":1,\"1346\":1,\"1350\":1}}],[\"element\",{\"0\":{\"256\":2},\"1\":{\"174\":1,\"256\":12,\"1076\":1,\"1283\":1,\"1315\":1,\"1325\":1,\"1407\":4,\"1409\":2,\"1410\":2,\"1411\":2}}],[\"else连写\",{\"1\":{\"984\":1}}],[\"else\",{\"1\":{\"70\":3,\"71\":2,\"76\":1,\"77\":5,\"82\":1,\"83\":3,\"88\":3,\"92\":2,\"93\":1,\"97\":1,\"98\":2,\"103\":2,\"120\":2,\"127\":2,\"134\":1,\"139\":2,\"147\":2,\"161\":1,\"162\":1,\"167\":2,\"173\":2,\"174\":3,\"206\":2,\"224\":1,\"235\":1,\"236\":1,\"237\":1,\"270\":1,\"273\":2,\"274\":4,\"302\":2,\"305\":1,\"306\":2,\"311\":1,\"318\":1,\"321\":1,\"322\":1,\"323\":1,\"325\":1,\"328\":2,\"341\":1,\"342\":1,\"358\":1,\"360\":1,\"361\":1,\"362\":1,\"387\":1,\"392\":1,\"394\":1,\"406\":1,\"409\":1,\"414\":1,\"428\":1,\"429\":1,\"431\":1,\"481\":5,\"587\":2,\"713\":2,\"767\":2,\"796\":1,\"834\":1,\"845\":2,\"846\":3,\"852\":3,\"870\":2,\"893\":1,\"894\":1,\"984\":17,\"985\":3,\"992\":1,\"1048\":1,\"1063\":1,\"1102\":1,\"1232\":1,\"1233\":1,\"1242\":3,\"1243\":2,\"1251\":2,\"1271\":1,\"1272\":4,\"1273\":1,\"1274\":11,\"1275\":1,\"1283\":3,\"1284\":4,\"1301\":1,\"1302\":1,\"1306\":1,\"1307\":2,\"1309\":2,\"1316\":1,\"1317\":1,\"1359\":2,\"1368\":2,\"1370\":3,\"1504\":1,\"1505\":1,\"1511\":1}}],[\"ensureprestart\",{\"1\":{\"1370\":3}}],[\"ensure\",{\"1\":{\"1274\":1,\"1511\":2}}],[\"enqueuing\",{\"1\":{\"1359\":1}}],[\"enqueue\",{\"1\":{\"1347\":5,\"1351\":1}}],[\"enq方法请看\",{\"1\":{\"1252\":1}}],[\"enq\",{\"1\":{\"1252\":2,\"1504\":8,\"1506\":2}}],[\"encounter\",{\"1\":{\"1316\":1}}],[\"encountered\",{\"1\":{\"1316\":1,\"1317\":2}}],[\"encachetest\",{\"1\":{\"1211\":1}}],[\"encache\",{\"0\":{\"1208\":1}}],[\"encryptpassword\",{\"1\":{\"568\":2,\"575\":2}}],[\"enabled\",{\"1\":{\"1190\":1}}],[\"enableeurekaclient\",{\"1\":{\"1175\":1}}],[\"enable\",{\"1\":{\"671\":1,\"1191\":1}}],[\"enableglobalmethodsecurity\",{\"1\":{\"446\":2,\"465\":1}}],[\"en\",{\"1\":{\"539\":1,\"540\":1}}],[\"entries\",{\"1\":{\"1306\":1,\"1314\":1,\"1315\":1,\"1316\":3,\"1317\":2}}],[\"entry给清除掉\",{\"1\":{\"1316\":1}}],[\"entry对象的一个集视图\",{\"1\":{\"1074\":1}}],[\"entry<k\",{\"1\":{\"1040\":1,\"1074\":1,\"1267\":1}}],[\"entry<integer\",{\"1\":{\"129\":1,\"179\":1,\"688\":1}}],[\"entryset\",{\"1\":{\"129\":1,\"179\":1,\"1040\":1,\"1074\":1,\"1201\":1}}],[\"entry\",{\"0\":{\"1305\":1},\"1\":{\"129\":2,\"179\":3,\"1201\":3,\"1267\":1,\"1302\":5,\"1305\":17,\"1306\":22,\"1307\":10,\"1308\":5,\"1313\":5,\"1314\":11,\"1315\":13,\"1316\":33,\"1317\":73,\"1318\":4,\"1359\":1}}],[\"entity\",{\"1\":{\"515\":1,\"1184\":1}}],[\"envprops\",{\"1\":{\"1149\":1}}],[\"envconfigfilename\",{\"1\":{\"1149\":1}}],[\"environment\",{\"1\":{\"1149\":4,\"1190\":1,\"1194\":1}}],[\"env\",{\"1\":{\"448\":1,\"1149\":2}}],[\"endsignal\",{\"1\":{\"1392\":7}}],[\"endswith\",{\"1\":{\"1005\":1}}],[\"endpoint\",{\"1\":{\"1100\":3}}],[\"endpos\",{\"1\":{\"72\":8}}],[\"endindex\",{\"1\":{\"1005\":2}}],[\"endtime\",{\"1\":{\"592\":1}}],[\"end\",{\"1\":{\"70\":5,\"140\":1,\"141\":1,\"157\":12,\"173\":7,\"174\":4,\"200\":1,\"203\":4,\"224\":7,\"250\":1,\"254\":1,\"256\":4,\"302\":1,\"324\":4,\"330\":1,\"341\":3,\"342\":1,\"375\":1,\"422\":5,\"423\":5,\"431\":1,\"1067\":4,\"1069\":2,\"1072\":1,\"1081\":1}}],[\"endl\",{\"1\":{\"65\":1,\"66\":1,\"76\":2,\"77\":2,\"110\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"172\":1,\"173\":1,\"174\":7,\"194\":1,\"197\":1,\"203\":1,\"206\":1,\"223\":1,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":2,\"236\":2,\"237\":2,\"251\":2,\"261\":1,\"262\":2,\"263\":1,\"274\":2,\"278\":1,\"279\":1,\"287\":1,\"290\":1,\"291\":1,\"296\":2,\"297\":2,\"298\":4,\"299\":2,\"301\":2,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":2,\"311\":1,\"312\":1,\"324\":1,\"330\":2,\"352\":1,\"368\":3,\"376\":1,\"389\":1,\"392\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1}}],[\"ex\",{\"1\":{\"1274\":1}}],[\"exchange\",{\"1\":{\"1399\":8}}],[\"exchanger<string>\",{\"1\":{\"1399\":1}}],[\"exchangerdemo\",{\"1\":{\"1399\":1}}],[\"exchanger\",{\"0\":{\"1397\":1,\"1399\":1},\"1\":{\"1399\":8}}],[\"exclusive\",{\"1\":{\"1239\":4,\"1495\":1,\"1503\":1,\"1507\":1,\"1508\":1}}],[\"exclusivecount\",{\"1\":{\"1239\":6,\"1240\":1,\"1242\":1}}],[\"exceeded\",{\"1\":{\"1232\":1,\"1233\":1,\"1239\":1}}],[\"excel\",{\"1\":{\"564\":1}}],[\"exceptional\",{\"1\":{\"1375\":1}}],[\"exception类的继承关系\",{\"0\":{\"1043\":1}}],[\"exceptionhandling\",{\"1\":{\"446\":1}}],[\"exception\",{\"0\":{\"1042\":1},\"1\":{\"446\":4,\"981\":2,\"982\":2,\"1042\":1,\"1043\":1,\"1044\":2,\"1102\":4,\"1103\":7,\"1165\":1,\"1170\":1,\"1266\":1,\"1330\":1,\"1340\":1,\"1407\":1}}],[\"exampleeurekaclient\",{\"1\":{\"1175\":3}}],[\"example\",{\"1\":{\"1074\":3,\"1496\":1}}],[\"exact\",{\"1\":{\"539\":1}}],[\"extists\",{\"1\":{\"913\":1}}],[\"extends\",{\"1\":{\"446\":1,\"523\":1,\"525\":1,\"539\":1,\"568\":1,\"688\":1,\"1028\":1,\"1032\":1,\"1059\":1,\"1061\":1,\"1062\":1,\"1063\":1,\"1210\":2,\"1267\":3,\"1270\":2,\"1305\":1,\"1337\":1,\"1406\":4,\"1407\":4,\"1496\":1}}],[\"exe<\",{\"1\":{\"1090\":1}}],[\"executor\",{\"1\":{\"1376\":1}}],[\"executorsservice\",{\"1\":{\"1330\":1}}],[\"executorservice\",{\"1\":{\"1201\":2,\"1309\":3,\"1330\":2,\"1376\":1,\"1392\":4,\"1393\":1,\"1398\":1,\"1399\":1,\"1409\":1,\"1410\":1,\"1411\":1}}],[\"executors\",{\"1\":{\"1158\":1,\"1201\":1,\"1309\":1,\"1313\":1,\"1330\":2,\"1375\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":1,\"1409\":1,\"1410\":1,\"1411\":1,\"1491\":1}}],[\"executionexception\",{\"1\":{\"1204\":1,\"1330\":1}}],[\"executable>\",{\"1\":{\"1090\":1}}],[\"execute执行过程示意图\",{\"1\":{\"1359\":1}}],[\"execute\",{\"1\":{\"927\":1,\"1359\":5,\"1365\":1,\"1371\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":2}}],[\"execstart=\",{\"1\":{\"671\":1}}],[\"exe\",{\"1\":{\"665\":1,\"1089\":3,\"1090\":6}}],[\"expect\",{\"1\":{\"1385\":2,\"1386\":1}}],[\"expunging\",{\"1\":{\"1316\":1}}],[\"expungestleentry\",{\"1\":{\"1317\":1}}],[\"expungestaleentry\",{\"0\":{\"1316\":1},\"1\":{\"1307\":2,\"1308\":2,\"1315\":1,\"1316\":4,\"1317\":7}}],[\"expunges\",{\"1\":{\"1316\":1}}],[\"expunge\",{\"1\":{\"1316\":2,\"1317\":2}}],[\"explanation\",{\"1\":{\"1275\":1}}],[\"expiration\",{\"1\":{\"1190\":1}}],[\"expirypolicy\",{\"1\":{\"1211\":2}}],[\"expirypolicy<k\",{\"1\":{\"1210\":1}}],[\"expiry\",{\"1\":{\"1103\":1,\"1191\":2}}],[\"expireafterwrite\",{\"1\":{\"1204\":1,\"1207\":1}}],[\"expiretime\",{\"1\":{\"1201\":3}}],[\"expired\",{\"1\":{\"1191\":1}}],[\"expire\",{\"1\":{\"31\":1,\"1201\":4}}],[\"export\",{\"1\":{\"540\":1,\"542\":1,\"548\":1,\"549\":1,\"589\":1,\"591\":1,\"592\":3,\"596\":1,\"1116\":2}}],[\"expression\",{\"1\":{\"990\":3,\"1019\":1}}],[\"expressionintercepturlregistry\",{\"1\":{\"446\":1}}],[\"expressionurlauthorizationconfigurer<httpsecurity>\",{\"1\":{\"446\":1}}],[\"expressionurlauthorizationconfigurer\",{\"1\":{\"446\":1}}],[\"exgcd\",{\"1\":{\"383\":2,\"384\":3}}],[\"existing\",{\"1\":{\"1306\":1,\"1314\":1,\"1359\":1}}],[\"exists\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"913\":2,\"915\":3,\"923\":2,\"1317\":1}}],[\"existed\",{\"1\":{\"88\":3}}],[\"exit\",{\"0\":{\"1319\":1},\"1\":{\"246\":1,\"1319\":2}}],[\"e\",{\"1\":{\"70\":8,\"223\":4,\"345\":2,\"347\":1,\"348\":1,\"349\":1,\"353\":3,\"355\":3,\"356\":2,\"362\":2,\"363\":2,\"403\":4,\"404\":3,\"419\":3,\"920\":2,\"1047\":4,\"1048\":4,\"1049\":2,\"1059\":6,\"1063\":2,\"1072\":7,\"1073\":6,\"1075\":2,\"1076\":4,\"1077\":4,\"1078\":4,\"1082\":2,\"1103\":2,\"1149\":1,\"1221\":2,\"1250\":2,\"1254\":2,\"1260\":2,\"1266\":2,\"1272\":16,\"1273\":11,\"1274\":7,\"1281\":1,\"1282\":2,\"1283\":6,\"1284\":2,\"1293\":3,\"1294\":3,\"1295\":1,\"1302\":3,\"1306\":10,\"1307\":10,\"1308\":5,\"1309\":2,\"1314\":5,\"1315\":3,\"1316\":5,\"1317\":20,\"1325\":8,\"1326\":6,\"1330\":4,\"1336\":2,\"1337\":2,\"1340\":4,\"1347\":8,\"1348\":5,\"1350\":2,\"1351\":4,\"1352\":2,\"1385\":2,\"1392\":2,\"1393\":4,\"1398\":2,\"1399\":4,\"1406\":8,\"1407\":4,\"1408\":1,\"1409\":4,\"1410\":4,\"1411\":4,\"1429\":2,\"1449\":2,\"1458\":2,\"1482\":2,\"1496\":2,\"1506\":1}}],[\"ever\",{\"1\":{\"1351\":1}}],[\"even\",{\"1\":{\"1351\":1,\"1511\":1}}],[\"event\",{\"1\":{\"1145\":1}}],[\"events\",{\"1\":{\"37\":1}}],[\"evenchoices\",{\"1\":{\"87\":2}}],[\"evencount\",{\"1\":{\"87\":2}}],[\"evanmiller\",{\"1\":{\"41\":1}}],[\"evan\",{\"1\":{\"41\":1}}],[\"eslintrc\",{\"1\":{\"539\":2}}],[\"eslint\",{\"1\":{\"499\":1,\"538\":1,\"539\":8}}],[\"estimate\",{\"1\":{\"221\":2,\"1275\":1}}],[\"es\",{\"1\":{\"26\":2,\"46\":2,\"50\":7}}],[\"存入\",{\"1\":{\"1302\":1}}],[\"存入a和b两点之间的距离\",{\"1\":{\"352\":1}}],[\"存放到\",{\"1\":{\"1301\":1}}],[\"存放的是\",{\"1\":{\"1267\":1}}],[\"存放字符串池\",{\"1\":{\"1069\":1}}],[\"存得久\",{\"1\":{\"437\":1}}],[\"存得下\",{\"1\":{\"437\":1}}],[\"存的是当前加入的边数\",{\"1\":{\"361\":1}}],[\"存的是最小生成树的所有边的权值\",{\"1\":{\"361\":1}}],[\"存边\",{\"1\":{\"345\":1}}],[\"存在三个\",{\"1\":{\"1421\":1}}],[\"存在内存泄漏的问题似乎是因为\",{\"1\":{\"1318\":1}}],[\"存在的内存泄漏的问题\",{\"1\":{\"1317\":1}}],[\"存在于缓存中\",{\"1\":{\"686\":1}}],[\"存在互相引用\",{\"1\":{\"526\":1}}],[\"存在乘法逆元的充要条件是\",{\"1\":{\"388\":1}}],[\"存在负权边\",{\"0\":{\"354\":1,\"355\":1},\"1\":{\"351\":1}}],[\"存在\",{\"1\":{\"58\":1,\"72\":1}}],[\"存在读放大\",{\"1\":{\"33\":1}}],[\"存在才能增量追加\",{\"1\":{\"31\":1}}],[\"存储结构\",{\"1\":{\"1440\":1}}],[\"存储桶\",{\"1\":{\"1094\":1}}],[\"存储和检索数据\",{\"1\":{\"1094\":1}}],[\"存储到了相同地址\",{\"1\":{\"1005\":1}}],[\"存储到\",{\"1\":{\"935\":1}}],[\"存储中序遍历的节点与索引的映射关系\",{\"1\":{\"766\":1}}],[\"存储路径和文件名都可以使用\",{\"1\":{\"670\":1}}],[\"存储目录为\",{\"1\":{\"670\":1}}],[\"存储目前为止前缀和相同的个数\",{\"1\":{\"261\":1}}],[\"存储无关的方式\",{\"1\":{\"669\":1}}],[\"存储实时数仓这样建\",{\"1\":{\"645\":1}}],[\"存储的元数据主要包括对象的描述信息\",{\"1\":{\"1094\":1}}],[\"存储的的是\",{\"1\":{\"958\":1}}],[\"存储的变量\",{\"1\":{\"575\":1}}],[\"存储的是图片的\",{\"1\":{\"511\":1}}],[\"存储数据的目录路径\",{\"1\":{\"1089\":1}}],[\"存储数据\",{\"1\":{\"564\":1}}],[\"存储日历信息\",{\"1\":{\"484\":1}}],[\"存储已触发的触发器的详细信息\",{\"1\":{\"484\":1}}],[\"存储被暂停的触发器组的信息\",{\"1\":{\"484\":1}}],[\"存储锁信息\",{\"1\":{\"484\":1}}],[\"存储调度器的状态信息\",{\"1\":{\"484\":1}}],[\"存储作业详细信息\",{\"1\":{\"484\":1}}],[\"存储具有单一触发器属性的触发器的详细信息\",{\"1\":{\"484\":1}}],[\"存储blob类型触发器的额外信息\",{\"1\":{\"484\":1}}],[\"存储简单触发器的额外信息\",{\"1\":{\"484\":1}}],[\"存储cron触发器的额外信息\",{\"1\":{\"484\":1}}],[\"存储触发器的基本信息\",{\"1\":{\"484\":1}}],[\"存储字符串前k个字母的哈希值\",{\"1\":{\"421\":1}}],[\"存储堆中下标是k的点是第几个插入的\",{\"1\":{\"417\":1}}],[\"存储堆中的值\",{\"1\":{\"417\":1}}],[\"存储第k个插入的点在堆中的位置\",{\"1\":{\"417\":1}}],[\"存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\",{\"1\":{\"363\":1}}],[\"存储x到p\",{\"1\":{\"416\":1}}],[\"存储x是否被筛掉\",{\"1\":{\"371\":1,\"373\":1,\"380\":1}}],[\"存储当前用到的下标\",{\"1\":{\"412\":1}}],[\"存储以每个节点结尾的单词数量\",{\"1\":{\"412\":1}}],[\"存储树中每个节点的子节点\",{\"1\":{\"412\":1}}],[\"存储形式如下\",{\"1\":{\"412\":1}}],[\"存储节点的next指针\",{\"1\":{\"403\":1}}],[\"存储节点的值\",{\"1\":{\"403\":1}}],[\"存储图和树\",{\"1\":{\"403\":1}}],[\"存储其他点到当前最小生成树的距离\",{\"1\":{\"360\":1}}],[\"存储1到x的最短路中经过的点数\",{\"1\":{\"356\":1}}],[\"存储1到x的最短路距离\",{\"1\":{\"354\":1}}],[\"存储1号点到x的最短距离\",{\"1\":{\"356\":1}}],[\"存储1号点到每个点的最短距离\",{\"1\":{\"352\":1}}],[\"存储所有质数\",{\"1\":{\"390\":1}}],[\"存储所有素数\",{\"1\":{\"371\":1,\"373\":1,\"380\":1}}],[\"存储所有边\",{\"1\":{\"360\":1}}],[\"存储所有点到1号点的距离\",{\"1\":{\"353\":1}}],[\"存储所有待离散化的值\",{\"1\":{\"341\":1}}],[\"存储每个数是否已被筛掉\",{\"1\":{\"390\":1}}],[\"存储每个数的欧拉函数\",{\"1\":{\"380\":1}}],[\"存储每个质数的次数\",{\"1\":{\"390\":1}}],[\"存储每个点的祖宗节点\",{\"1\":{\"414\":1,\"415\":1,\"416\":1}}],[\"存储每个点的最短距离是否已确定\",{\"1\":{\"353\":1}}],[\"存储每个点的最短路是否已经确定\",{\"1\":{\"352\":1}}],[\"存储每个点是否已经在生成树中\",{\"1\":{\"360\":1}}],[\"存储每个点是否在队列中\",{\"1\":{\"355\":1,\"356\":1}}],[\"存储每个点到1号点的最短距离\",{\"1\":{\"355\":1}}],[\"存储每条边\",{\"1\":{\"352\":1}}],[\"存储点i的入度\",{\"1\":{\"349\":1}}],[\"存储这个单链表的头结点\",{\"1\":{\"345\":1}}],[\"存储k所有可以走到的点\",{\"1\":{\"345\":1}}],[\"存储边\",{\"1\":{\"345\":1}}],[\"存储变换后的字符串\",{\"1\":{\"279\":1}}],[\"存储备份该状态\",{\"1\":{\"224\":1}}],[\"存储该状态\",{\"1\":{\"224\":1}}],[\"存储距离和起点\",{\"1\":{\"223\":1}}],[\"存储积分到玩家列表的映射\",{\"1\":{\"129\":1}}],[\"存储玩家名称到积分的映射\",{\"1\":{\"129\":1}}],[\"存储\",{\"1\":{\"44\":1,\"56\":1,\"327\":1,\"328\":1,\"417\":1,\"421\":2,\"434\":3,\"676\":1,\"1095\":1,\"1482\":1}}],[\"存储内容包括同一个评论\",{\"1\":{\"31\":1}}],[\"存储设计\",{\"0\":{\"29\":1,\"55\":1}}],[\"表明获取同步状态失败即所引用的线程获取锁失败\",{\"1\":{\"1510\":1}}],[\"表明该类是不能被子类继承的\",{\"1\":{\"1471\":1}}],[\"表明该值已经被其他线程改过了则该旧值\",{\"1\":{\"1437\":1}}],[\"表明该值已经被其他线程改过了\",{\"1\":{\"1383\":1}}],[\"表来说\",{\"1\":{\"1272\":1}}],[\"表面\",{\"1\":{\"1175\":1}}],[\"表面上拼接字符串时\",{\"1\":{\"1068\":1}}],[\"表面看它就是一个平平无奇的服务器而已\",{\"1\":{\"664\":1}}],[\"表子查询\",{\"0\":{\"951\":1},\"1\":{\"947\":1}}],[\"表2\",{\"1\":{\"942\":1,\"944\":2,\"945\":2}}],[\"表1\",{\"1\":{\"942\":1,\"944\":2,\"945\":2}}],[\"表添加字段\",{\"1\":{\"922\":1}}],[\"表注释\",{\"1\":{\"918\":1}}],[\"表操作\",{\"0\":{\"916\":1}}],[\"表与表之间的关联\",{\"1\":{\"565\":1}}],[\"表格列名\",{\"1\":{\"592\":1}}],[\"表格\",{\"1\":{\"564\":1}}],[\"表格组件\",{\"1\":{\"540\":1}}],[\"表名列表\",{\"1\":{\"929\":1}}],[\"表名不存在\",{\"1\":{\"923\":1}}],[\"表名\",{\"1\":{\"484\":1,\"918\":1,\"921\":2,\"922\":5,\"923\":1,\"925\":4,\"926\":1,\"927\":1,\"930\":4,\"931\":1,\"932\":1,\"933\":1,\"934\":1,\"935\":1,\"937\":2,\"942\":1,\"959\":3}}],[\"表\",{\"1\":{\"476\":2,\"909\":1,\"911\":1}}],[\"表结构说明\",{\"0\":{\"476\":1}}],[\"表达式转换成题目\",{\"1\":{\"525\":1}}],[\"表达式工具类\",{\"1\":{\"477\":1}}],[\"表达式等\",{\"1\":{\"476\":1}}],[\"表达式\",{\"0\":{\"980\":1},\"1\":{\"255\":1,\"990\":1}}],[\"表达式拥有和当前类成员函数同样的访问权限\",{\"1\":{\"255\":1}}],[\"表达式的语法形式可简单归纳如下\",{\"1\":{\"255\":1}}],[\"表达式定义了一个匿名函数\",{\"1\":{\"255\":1}}],[\"表中元素数量与槽位数的比值\",{\"1\":{\"973\":1}}],[\"表中\",{\"1\":{\"926\":1}}],[\"表中有哪些字段\",{\"1\":{\"565\":1}}],[\"表中选择\",{\"1\":{\"181\":2}}],[\"表中的顾客名称\",{\"1\":{\"181\":1}}],[\"表中的产品名称\",{\"1\":{\"181\":1}}],[\"表代表顾客信息\",{\"1\":{\"181\":1}}],[\"表含有字段\",{\"1\":{\"181\":1}}],[\"表示下一次共享式同步状态获取将会无条件传播下去\",{\"1\":{\"1501\":1}}],[\"表示禁止重排序\",{\"1\":{\"1457\":1}}],[\"表示其他线程竞争锁\",{\"1\":{\"1446\":1}}],[\"表示50个学生\",{\"1\":{\"1398\":1}}],[\"表示老师只有10支笔\",{\"1\":{\"1398\":1}}],[\"表示线程已经获得了锁\",{\"1\":{\"1442\":1}}],[\"表示线程池能创建线程的最大个数\",{\"1\":{\"1359\":1}}],[\"表示线程的\",{\"1\":{\"1299\":1}}],[\"表示核心线程池的大小\",{\"1\":{\"1359\":1}}],[\"表示在\",{\"1\":{\"1336\":1}}],[\"表示在第\",{\"1\":{\"146\":1}}],[\"表示为需要新建数组的长度\",{\"1\":{\"1266\":1}}],[\"表示正在初始化\",{\"1\":{\"1266\":1}}],[\"表示能够对共享资源能够重复加锁\",{\"1\":{\"1231\":1}}],[\"表示存储桶是否存在\",{\"1\":{\"1102\":1}}],[\"表示键值对\",{\"1\":{\"1082\":1}}],[\"表示两个元素需要更换位置\",{\"1\":{\"1078\":1}}],[\"表示两个非负的整数\",{\"1\":{\"698\":1}}],[\"表示泛型\",{\"1\":{\"1072\":1}}],[\"表示出现了环\",{\"1\":{\"876\":1}}],[\"表示出口\",{\"1\":{\"235\":1}}],[\"表示回到了起点\",{\"1\":{\"875\":1}}],[\"表示如果要学习课程\",{\"1\":{\"874\":1}}],[\"表示长度为\",{\"1\":{\"852\":1}}],[\"表示长度和权值都是奇数的非空子串数量\",{\"1\":{\"120\":1}}],[\"表示末尾元素为\",{\"1\":{\"852\":1}}],[\"表示选了当前的数\",{\"1\":{\"851\":1}}],[\"表示选择元素\",{\"1\":{\"178\":1}}],[\"表示该节点是否为字符串的结尾\",{\"1\":{\"802\":1}}],[\"表示该数据已回传\",{\"1\":{\"151\":1}}],[\"表示没有计算过\",{\"1\":{\"795\":1}}],[\"表示已经处理过该节点\",{\"1\":{\"1274\":1}}],[\"表示已经使用\",{\"1\":{\"784\":1}}],[\"表示已售出\",{\"1\":{\"168\":1}}],[\"表示背包总容量是\",{\"1\":{\"772\":1}}],[\"表示全局底部栏\",{\"1\":{\"549\":1}}],[\"表示全局公用组件\",{\"1\":{\"549\":1}}],[\"表示不同面额的硬币\",{\"1\":{\"892\":1}}],[\"表示不合法的状态\",{\"1\":{\"795\":1}}],[\"表示不查询\",{\"1\":{\"523\":1}}],[\"表示不可通过的墙壁\",{\"1\":{\"278\":1}}],[\"表示添加题目到题库的用户\",{\"1\":{\"513\":1}}],[\"表示这条用户记录任何字段发生修改的时间\",{\"1\":{\"510\":1}}],[\"表示这个前缀和的值\",{\"1\":{\"261\":1}}],[\"表示这个房子的主人不想回答问题\",{\"1\":{\"108\":1}}],[\"表示用户编辑个人信息的时间\",{\"1\":{\"510\":1}}],[\"表示大小\",{\"1\":{\"417\":1}}],[\"表示堆\",{\"1\":{\"417\":1}}],[\"表示祖宗节点所在集合中的点的数量\",{\"1\":{\"415\":1}}],[\"表示队头\",{\"1\":{\"409\":1}}],[\"表示节点的右指针\",{\"1\":{\"404\":1}}],[\"表示节点的左指针\",{\"1\":{\"404\":1}}],[\"表示节点的值\",{\"1\":{\"404\":1}}],[\"表示a到b的距离\",{\"1\":{\"358\":1}}],[\"表示1号点已经被遍历过\",{\"1\":{\"348\":1}}],[\"表示边数\",{\"1\":{\"346\":1,\"349\":1,\"352\":1,\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"360\":1,\"361\":1,\"362\":1,\"363\":1}}],[\"表示补码\",{\"1\":{\"339\":1}}],[\"表示整个数列\",{\"1\":{\"339\":1}}],[\"表示精度\",{\"1\":{\"325\":1}}],[\"表示所有点都走过了\",{\"1\":{\"312\":1}}],[\"表示所有位置都可能是网吧\",{\"1\":{\"108\":1}}],[\"表示前\",{\"1\":{\"308\":1}}],[\"表示给定的字符串\",{\"1\":{\"305\":1}}],[\"表示总金额\",{\"1\":{\"892\":1}}],[\"表示总体积是i的情况下\",{\"1\":{\"296\":1,\"297\":1}}],[\"表示总共有\",{\"1\":{\"129\":1}}],[\"表示海洋\",{\"1\":{\"280\":2}}],[\"表示海⽔\",{\"1\":{\"229\":1}}],[\"表示变换到某个字符串时需要的交换次数\",{\"1\":{\"279\":1}}],[\"表示完整的二维数组迷宫\",{\"1\":{\"278\":1}}],[\"表示可以再次获取成功\",{\"1\":{\"1232\":1}}],[\"表示可以走的路\",{\"1\":{\"278\":1}}],[\"表示可走的路\",{\"1\":{\"235\":1}}],[\"表示共有\",{\"1\":{\"274\":1}}],[\"表示目标在地图上的位置\",{\"1\":{\"263\":1}}],[\"表示截断方法数量\",{\"1\":{\"262\":1}}],[\"表示捕获当前类中的\",{\"1\":{\"255\":1}}],[\"表示捕获外部作用域中所有变量\",{\"1\":{\"255\":2}}],[\"表示按值捕获外部作用域中所有变量\",{\"1\":{\"255\":1}}],[\"表示size\",{\"1\":{\"252\":1}}],[\"表示墙\",{\"1\":{\"235\":1}}],[\"表示起点\",{\"1\":{\"235\":1}}],[\"表示起点有一条路径\",{\"1\":{\"142\":1}}],[\"表示陆地\",{\"1\":{\"229\":1,\"280\":2}}],[\"表示得到正确排列的完整行动记录\",{\"1\":{\"224\":1}}],[\"表示点j已经被遍历过\",{\"1\":{\"348\":1}}],[\"表示点u已经被遍历过\",{\"1\":{\"347\":1}}],[\"表示点数\",{\"1\":{\"346\":1,\"349\":1,\"352\":1,\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"360\":1,\"361\":1,\"362\":1,\"363\":1}}],[\"表示点\",{\"1\":{\"223\":1}}],[\"表示答案\",{\"1\":{\"193\":1,\"199\":1}}],[\"表示询问\",{\"1\":{\"174\":1,\"273\":1}}],[\"表示每个点的颜色\",{\"1\":{\"362\":1}}],[\"表示每名工人的位置\",{\"1\":{\"173\":1}}],[\"表示每天骑行次数\",{\"1\":{\"65\":1}}],[\"表示瓶子的数量\",{\"1\":{\"166\":1}}],[\"表示小美初始位置和瓶子需要放置的位置\",{\"1\":{\"166\":1}}],[\"表示小乐乐改后得到的数字\",{\"1\":{\"161\":1}}],[\"表示小c从游戏开始到第\",{\"1\":{\"146\":1}}],[\"表示操作后这四个正整数的乘积\",{\"1\":{\"156\":1}}],[\"表示测试数据组数\",{\"1\":{\"156\":1}}],[\"表示格子数量和收藏品数量\",{\"1\":{\"147\":1}}],[\"表示理论的最佳速通时间\",{\"1\":{\"146\":1}}],[\"表示有\",{\"1\":{\"146\":1}}],[\"表示各种花卉花朵的数量\",{\"1\":{\"141\":1}}],[\"表示花卉品种的数量\",{\"1\":{\"141\":1}}],[\"表示当前线程阻塞\",{\"1\":{\"1505\":1}}],[\"表示当前锁存在竞争\",{\"1\":{\"1447\":1}}],[\"表示当前是偏向锁\",{\"1\":{\"1442\":1}}],[\"表示当前数据容器\",{\"1\":{\"1266\":1}}],[\"表示当前遍历到的节点为\",{\"1\":{\"881\":1}}],[\"表示当前脚手架的最新版本\",{\"1\":{\"538\":1}}],[\"表示当前摆到第\",{\"1\":{\"311\":1}}],[\"表示当前的组合方式数量等于不使用当前数字时的组合方式数量加上使用当前数字时的组合方式数量\",{\"1\":{\"135\":1}}],[\"表示当前和\",{\"1\":{\"126\":1}}],[\"表示将原数组中所有的\",{\"1\":{\"199\":1}}],[\"表示将\",{\"1\":{\"129\":3}}],[\"表示将编号为\",{\"1\":{\"103\":1}}],[\"表示赋值\",{\"1\":{\"128\":1}}],[\"表示空字符串匹配空模式\",{\"1\":{\"127\":1}}],[\"表示字符串\",{\"1\":{\"127\":1,\"1006\":1}}],[\"表示考虑前\",{\"1\":{\"126\":1}}],[\"表示以下标为\",{\"1\":{\"846\":1}}],[\"表示以下标\",{\"1\":{\"120\":1}}],[\"表示和为\",{\"1\":{\"115\":1,\"135\":1}}],[\"表示你采取最优策略的情况下获得的最少的优惠券个数\",{\"1\":{\"109\":1}}],[\"表示你采取最优策略的情况下获得的最多的优惠券个数\",{\"1\":{\"109\":1}}],[\"表示\",{\"1\":{\"104\":2,\"146\":1,\"152\":1,\"196\":2,\"273\":1,\"329\":1,\"330\":1,\"362\":1,\"388\":1,\"783\":1,\"874\":1,\"886\":1,\"982\":1,\"1025\":1,\"1315\":1}}],[\"表示经过任意次操作后数组的最大和\",{\"1\":{\"104\":1}}],[\"表示数列\",{\"1\":{\"304\":3}}],[\"表示数组的元素\",{\"1\":{\"179\":1}}],[\"表示数组的长度\",{\"1\":{\"104\":1,\"178\":1,\"179\":1}}],[\"表示数组\",{\"1\":{\"174\":1}}],[\"表示数组长度和询问次数\",{\"1\":{\"174\":1}}],[\"表示数字和操作次数\",{\"1\":{\"167\":1}}],[\"表示数据组数\",{\"1\":{\"66\":1,\"147\":1}}],[\"表示调整后\",{\"1\":{\"103\":1}}],[\"表示宝石数量和操作次数\",{\"1\":{\"103\":1}}],[\"表示最长公共上升子序列的长度\",{\"1\":{\"304\":1}}],[\"表示最长的满足条件的区间的两个端点\",{\"1\":{\"78\":1}}],[\"表示最少需要多少美元\",{\"1\":{\"290\":1}}],[\"表示最少需要多少代价\",{\"1\":{\"166\":1}}],[\"表示最少交换次数\",{\"1\":{\"279\":1}}],[\"表示最大的总预计消费金额\",{\"1\":{\"162\":1}}],[\"表示最大的美观度\",{\"1\":{\"147\":1}}],[\"表示最小花费\",{\"1\":{\"65\":1}}],[\"表示木桩数量\",{\"1\":{\"78\":1}}],[\"表示白色单元格\",{\"1\":{\"77\":1}}],[\"表示黑色单元格\",{\"1\":{\"77\":1}}],[\"表示到达第\",{\"1\":{\"194\":1}}],[\"表示到达位置\",{\"1\":{\"142\":1}}],[\"表示到达位置i时的最小总伤害\",{\"1\":{\"110\":1}}],[\"表示到达\",{\"1\":{\"72\":1}}],[\"表示一个完整的字符串\",{\"1\":{\"803\":1}}],[\"表示一个数都不选\",{\"1\":{\"126\":1}}],[\"表示一次询问中满足条件的字符串个数\",{\"1\":{\"305\":1}}],[\"表示一次询问\",{\"1\":{\"305\":1}}],[\"表示一开始在起点的方法数为\",{\"1\":{\"72\":1}}],[\"表示一共有\",{\"1\":{\"66\":1}}],[\"表示从前\",{\"1\":{\"795\":1,\"893\":1}}],[\"表示从a个苹果中选b个的方案数\",{\"1\":{\"387\":1}}],[\"表示从\",{\"1\":{\"312\":1}}],[\"表示从左上角移动至右下角的最少移动次数\",{\"1\":{\"278\":1}}],[\"表示从左到右以第\",{\"1\":{\"66\":1}}],[\"表示从起点移动\",{\"1\":{\"72\":1}}],[\"表示从右到左以第\",{\"1\":{\"66\":1}}],[\"表示盘古能够选择的最长的区间对应的长度\",{\"1\":{\"66\":1}}],[\"表示第二个集合中的每个点是否已经被遍历过\",{\"1\":{\"363\":1}}],[\"表示第\",{\"1\":{\"65\":1,\"78\":1,\"108\":1,\"152\":1,\"166\":1,\"182\":1,\"223\":1,\"261\":1}}],[\"表示四种卡的价格\",{\"1\":{\"65\":1}}],[\"表里有一些统计字段\",{\"1\":{\"57\":1}}],[\"表里捞出来一堆\",{\"1\":{\"56\":1}}],[\"表找到根评论列表\",{\"1\":{\"56\":1}}],[\"表还有自己的自增主键的话\",{\"1\":{\"56\":1}}],[\"表了\",{\"1\":{\"56\":1}}],[\"表都有主键\",{\"1\":{\"56\":1}}],[\"表的长度\",{\"1\":{\"1315\":1}}],[\"表的每个散列桶能够均匀的分布\",{\"1\":{\"1306\":1}}],[\"表的性能\",{\"1\":{\"1272\":1}}],[\"表的\",{\"1\":{\"56\":1,\"1306\":1,\"1316\":1}}],[\"表的两部分字段\",{\"1\":{\"31\":1}}],[\"表和\",{\"1\":{\"31\":1}}],[\"缓存性能接近理论最优\",{\"1\":{\"1205\":1}}],[\"缓存数据\",{\"1\":{\"1201\":1}}],[\"缓存数据map\",{\"1\":{\"1201\":1}}],[\"缓存值\",{\"1\":{\"1201\":1}}],[\"缓存键\",{\"1\":{\"1201\":3}}],[\"缓存刷新\",{\"1\":{\"1182\":1}}],[\"缓存加速\",{\"1\":{\"534\":1}}],[\"缓存要求使用\",{\"1\":{\"502\":1}}],[\"缓存\",{\"0\":{\"685\":1},\"1\":{\"493\":1,\"613\":2,\"686\":2}}],[\"缓存穿透\",{\"0\":{\"60\":1},\"1\":{\"613\":2}}],[\"缓存使用增量加载\",{\"1\":{\"58\":1}}],[\"缓存更多的\",{\"1\":{\"56\":1}}],[\"缓存的一致性依赖\",{\"1\":{\"31\":1}}],[\"缓存的重建\",{\"1\":{\"28\":1}}],[\"缓存设计\",{\"0\":{\"31\":1,\"58\":1}}],[\"原因分析\",{\"1\":{\"1408\":1}}],[\"原因是存在脏\",{\"1\":{\"1316\":1}}],[\"原因是它支持多线程进行扩容操作\",{\"1\":{\"1274\":1}}],[\"原因是\",{\"1\":{\"354\":1,\"1293\":1,\"1295\":1}}],[\"原子操作\",{\"1\":{\"1482\":1}}],[\"原子操作类介绍\",{\"0\":{\"1380\":1}}],[\"原子更新字段类都是抽象类\",{\"1\":{\"1388\":1}}],[\"原子更新字段类型\",{\"0\":{\"1388\":1}}],[\"原子更新长整型字段类\",{\"1\":{\"1388\":1}}],[\"原子更新长整型数组中的元素\",{\"1\":{\"1386\":1}}],[\"原子更新整型字段类\",{\"1\":{\"1388\":1}}],[\"原子更新整型数组中的元素\",{\"1\":{\"1386\":1}}],[\"原子更新带有标记位的引用类型\",{\"1\":{\"1387\":1}}],[\"原子更新引用类型里的字段\",{\"1\":{\"1387\":1}}],[\"原子更新引用类型\",{\"0\":{\"1387\":1},\"1\":{\"1387\":1,\"1388\":1}}],[\"原子更新引用类型数组中的元素\",{\"1\":{\"1386\":1}}],[\"原子更新数组类型\",{\"0\":{\"1386\":1}}],[\"原子更新\",{\"1\":{\"1385\":1}}],[\"原子更新基本类型\",{\"0\":{\"1385\":1}}],[\"原子性是指一个操作是不可中断的\",{\"1\":{\"1482\":1}}],[\"原子性是指事务包装的一组\",{\"1\":{\"955\":1}}],[\"原子性\",{\"0\":{\"1481\":1,\"1482\":1},\"1\":{\"955\":2,\"1455\":1}}],[\"原节点\",{\"1\":{\"887\":1,\"888\":2}}],[\"原本的右子树就丢失了\",{\"1\":{\"725\":1}}],[\"原\",{\"1\":{\"672\":1,\"887\":1}}],[\"原始部署\",{\"0\":{\"606\":1}}],[\"原始用户信息\",{\"1\":{\"575\":1}}],[\"原来的变化路径\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"原来的mysql分表架构很快到达存储瓶颈\",{\"1\":{\"30\":1}}],[\"原来是需要什么东西自己去拿\",{\"1\":{\"1129\":1}}],[\"原来请求是\",{\"1\":{\"586\":1}}],[\"原理同使用\",{\"1\":{\"1410\":1}}],[\"原理和使用介绍\",{\"1\":{\"641\":1}}],[\"原理\",{\"1\":{\"356\":1}}],[\"原文链接\",{\"1\":{\"20\":1,\"44\":1,\"54\":1,\"1144\":1,\"1175\":1,\"1189\":1}}],[\"有问题的语句是这条\",{\"1\":{\"1485\":1}}],[\"有着\",{\"1\":{\"1482\":1}}],[\"有着一排\",{\"1\":{\"147\":1}}],[\"有的时候付款的时候在包里拿出钱包再去拿出钱\",{\"1\":{\"1434\":1}}],[\"有的补0\",{\"1\":{\"337\":1}}],[\"有的补符号位\",{\"1\":{\"337\":1}}],[\"有什么解决方案\",{\"1\":{\"1429\":1}}],[\"有时候需要等待其他多个线程完成任务之后\",{\"1\":{\"1392\":1}}],[\"有如下代码\",{\"1\":{\"1418\":1}}],[\"有如下几个构造方法\",{\"1\":{\"1366\":1}}],[\"有如下优点\",{\"1\":{\"958\":1}}],[\"有许多重载的构造方法\",{\"1\":{\"1359\":1}}],[\"有界数据缓冲区\",{\"1\":{\"1326\":1}}],[\"有助于value能够被回收\",{\"1\":{\"1306\":1}}],[\"有助于工程人员能够迅速发现问题解决问题\",{\"1\":{\"1259\":1}}],[\"有个简单的认识就好\",{\"1\":{\"1301\":1}}],[\"有很多业务往往是读多写少的\",{\"1\":{\"1290\":1}}],[\"有很多种解法\",{\"1\":{\"238\":1}}],[\"有这样一部分\",{\"1\":{\"1284\":1}}],[\"有这样一种情况\",{\"1\":{\"1283\":1}}],[\"有这样几个问题\",{\"1\":{\"1251\":1}}],[\"有意思的是\",{\"1\":{\"1259\":1,\"1477\":1}}],[\"有兴趣的可以去看看\",{\"1\":{\"1264\":1}}],[\"有兴趣的可以去查阅资料\",{\"1\":{\"1259\":1}}],[\"有兴趣的可以直接去看源码\",{\"1\":{\"1258\":1}}],[\"有兴趣可以看看\",{\"1\":{\"1242\":1}}],[\"有可能就是一个未正确初始化的对象\",{\"1\":{\"1475\":1}}],[\"有可能存在\",{\"1\":{\"1326\":1}}],[\"有可能存在内存泄漏\",{\"1\":{\"1306\":1,\"1309\":1}}],[\"有可能存在一个情况是多个线程同时走到这个方法中\",{\"1\":{\"1271\":1}}],[\"有可能的执行时序\",{\"1\":{\"1283\":1}}],[\"有可能刚释放锁的线程能再次获取到锁\",{\"1\":{\"1233\":1}}],[\"有可能被\",{\"1\":{\"576\":1}}],[\"有三个直接子类\",{\"1\":{\"1137\":1}}],[\"有点像通过婚介找女朋友\",{\"1\":{\"1131\":1}}],[\"有了资源\",{\"1\":{\"1136\":1}}],[\"有了\",{\"1\":{\"1129\":1,\"1132\":1}}],[\"有十分完善的官方文档\",{\"1\":{\"1095\":1}}],[\"有返回值的函数\",{\"0\":{\"1021\":1}}],[\"有些内存可见性保证其实并不一定真实存在\",{\"1\":{\"1423\":1}}],[\"有些操作系统甚至会忽略线程优先级的设定\",{\"1\":{\"1339\":1}}],[\"有些业务操作要多次访问数据库\",{\"1\":{\"953\":1}}],[\"有些题则在判断的同时需要计算出最短路径\",{\"1\":{\"237\":1}}],[\"有些题只需要判断能不能逃出迷宫\",{\"1\":{\"237\":1}}],[\"有升序排序\",{\"1\":{\"934\":1}}],[\"有符号\",{\"1\":{\"920\":1}}],[\"有符号数\",{\"1\":{\"337\":1}}],[\"有关\",{\"1\":{\"894\":1}}],[\"有效性和完整性\",{\"1\":{\"919\":1}}],[\"有效\",{\"1\":{\"898\":1}}],[\"有效括号长度新增长度\",{\"1\":{\"846\":2}}],[\"有效字符串需满足\",{\"1\":{\"93\":1}}],[\"有效字符串\",{\"0\":{\"93\":1}}],[\"有需要的话也可以配置\",{\"1\":{\"670\":1}}],[\"有必要在用户登录后记录用户状态\",{\"1\":{\"580\":1}}],[\"有哪些表\",{\"1\":{\"565\":1}}],[\"有空就做\",{\"1\":{\"506\":1}}],[\"有唯一解\",{\"1\":{\"385\":1}}],[\"有无穷多组解\",{\"1\":{\"385\":1}}],[\"有向图游戏的某个局面必败\",{\"1\":{\"399\":1}}],[\"有向图游戏的某个局面必胜\",{\"1\":{\"399\":1}}],[\"有向图游戏的和的sg函数值等于它包含的各个子游戏sg函数值的异或和\",{\"1\":{\"399\":1}}],[\"有向图游戏的和\",{\"0\":{\"399\":1}}],[\"有向图游戏\",{\"0\":{\"396\":1}}],[\"有向图\",{\"1\":{\"352\":1}}],[\"有向无环图被称为拓扑图\",{\"1\":{\"349\":1}}],[\"有以下这些启发函数可以使用\",{\"1\":{\"216\":1}}],[\"有以下几种vip卡\",{\"1\":{\"65\":1}}],[\"有多少个是大于\",{\"1\":{\"121\":1}}],[\"有多少个长度为奇数并且权值为奇数的子字符串\",{\"1\":{\"120\":1}}],[\"有一些更方便的特性\",{\"1\":{\"1507\":1}}],[\"有一种的可能执行时序为下图\",{\"1\":{\"1475\":1}}],[\"有一天\",{\"1\":{\"1398\":1}}],[\"有一定的熟练度\",{\"1\":{\"662\":1}}],[\"有一个静态内部类\",{\"1\":{\"1501\":1}}],[\"有一个直观的印象\",{\"1\":{\"1482\":1}}],[\"有一个解决方案是利用对象整合多个共享变量\",{\"1\":{\"1439\":1}}],[\"有一个很简单的例子就是多线程执行\",{\"1\":{\"1380\":1}}],[\"有一个经验值公式\",{\"1\":{\"1361\":1}}],[\"有一个大小为\",{\"1\":{\"856\":1}}],[\"有一个逻辑删除\",{\"1\":{\"575\":1}}],[\"有一个1\",{\"1\":{\"392\":1}}],[\"有一个人位于左上角\",{\"1\":{\"278\":1}}],[\"有一个长度为\",{\"1\":{\"179\":1}}],[\"有一个线程去\",{\"1\":{\"60\":1}}],[\"有一条街\",{\"1\":{\"108\":1}}],[\"有两种思路\",{\"1\":{\"851\":1}}],[\"有两种选择\",{\"1\":{\"178\":1}}],[\"有两种解法\",{\"1\":{\"104\":1}}],[\"有两个知识点需要先关注\",{\"1\":{\"1434\":1}}],[\"有两个指针\",{\"1\":{\"404\":1}}],[\"有两个参数\",{\"1\":{\"254\":1}}],[\"有两个关键点\",{\"1\":{\"235\":1}}],[\"有两个不同的用户群体\",{\"1\":{\"70\":1}}],[\"有两个基本且重要的特征\",{\"1\":{\"30\":1}}],[\"有\",{\"1\":{\"78\":1,\"87\":2,\"157\":1,\"162\":1,\"205\":1,\"221\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":1,\"299\":1,\"389\":1,\"525\":1,\"537\":1,\"772\":1,\"893\":2,\"958\":1}}],[\"有温度\",{\"1\":{\"41\":1}}],[\"有知识\",{\"1\":{\"41\":1}}],[\"有趣的交流环境\",{\"1\":{\"41\":1}}],[\"有害评论被删除后\",{\"1\":{\"36\":1}}],[\"有序性和可见性\",{\"1\":{\"1487\":1}}],[\"有序性\",{\"0\":{\"1481\":1,\"1483\":1},\"1\":{\"1221\":1,\"1425\":1,\"1455\":1}}],[\"有序\",{\"1\":{\"28\":1,\"1081\":1}}],[\"再需要读取从主内存中去读取该变量的最新值\",{\"1\":{\"1456\":1}}],[\"再如\",{\"1\":{\"1423\":1}}],[\"再执行计算操作就会有问题\",{\"1\":{\"1454\":1}}],[\"再执行\",{\"1\":{\"1407\":1}}],[\"再执行删除\",{\"1\":{\"915\":1}}],[\"再然后\",{\"1\":{\"1407\":1}}],[\"再开始\",{\"1\":{\"1406\":1}}],[\"再携手共进\",{\"1\":{\"1394\":1}}],[\"再扫描\",{\"1\":{\"1315\":1}}],[\"再通过这个key获取threadlocalmap中对应的entry\",{\"1\":{\"1306\":1}}],[\"再通过业务主键更新业务数据层\",{\"1\":{\"46\":1}}],[\"再从头开始搜索\",{\"1\":{\"1306\":1}}],[\"再从地图右下角枚举边长为\",{\"1\":{\"263\":1}}],[\"再来看下如何进行添加数据的\",{\"1\":{\"1294\":1}}],[\"再来看下第二行代码\",{\"1\":{\"1158\":1}}],[\"再将该值刷新到主内存\",{\"1\":{\"1433\":1}}],[\"再将原容器的引用指向新的容器\",{\"1\":{\"1291\":1}}],[\"再将注册成功的用户名也放入的布隆过滤器中\",{\"1\":{\"613\":1}}],[\"再让\",{\"1\":{\"1284\":1}}],[\"再让他们研究了最长公共子序列\",{\"1\":{\"304\":1}}],[\"再回过头来看\",{\"1\":{\"1283\":1}}],[\"再插入节点的时候我们会问自己这样一个问题\",{\"1\":{\"1283\":1}}],[\"再看代码出现第\",{\"1\":{\"1251\":1}}],[\"再看个位是几\",{\"1\":{\"339\":1}}],[\"再才有做后面的逻辑判断的必要性\",{\"1\":{\"1233\":1}}],[\"再也不怕被问\",{\"1\":{\"1145\":1}}],[\"再也不用心惊胆战地使用\",{\"1\":{\"635\":1}}],[\"再写\",{\"1\":{\"1026\":1}}],[\"再输入\",{\"1\":{\"999\":1}}],[\"再提交\",{\"1\":{\"954\":1}}],[\"再一层层向上递归判断\",{\"1\":{\"901\":1}}],[\"再遍历根节点\",{\"1\":{\"900\":1}}],[\"再例如\",{\"1\":{\"845\":1}}],[\"再递归返回结果\",{\"1\":{\"796\":1}}],[\"再递归左子树\",{\"1\":{\"736\":1}}],[\"再划分左右子树\",{\"1\":{\"766\":1}}],[\"再深p和q中的一个就没了\",{\"1\":{\"755\":1}}],[\"再处理这个节点\",{\"1\":{\"730\":1}}],[\"再填入账号和生成的密码\",{\"1\":{\"676\":1}}],[\"再填写\",{\"1\":{\"672\":1}}],[\"再前往前台\",{\"1\":{\"675\":1}}],[\"再去\",{\"1\":{\"672\":1}}],[\"再加上文件放在云存储上\",{\"1\":{\"668\":1}}],[\"再准备一台国内的服务器\",{\"1\":{\"664\":1}}],[\"再在\",{\"1\":{\"592\":1}}],[\"再到\",{\"1\":{\"589\":1}}],[\"再修改项目文件\",{\"1\":{\"539\":1}}],[\"再根据\",{\"1\":{\"525\":1}}],[\"再封装返回值即可\",{\"1\":{\"523\":1}}],[\"再复用\",{\"1\":{\"523\":1}}],[\"再添加\",{\"1\":{\"488\":1}}],[\"再围绕数据湖建立专用\",{\"1\":{\"438\":1}}],[\"再次扩大搜索范围为\",{\"1\":{\"1316\":1}}],[\"再次执行\",{\"1\":{\"1283\":1}}],[\"再次获取\",{\"1\":{\"1232\":1}}],[\"再次访问即可\",{\"1\":{\"592\":1}}],[\"再次继续匹配\",{\"1\":{\"411\":1}}],[\"再次遍历哈希表\",{\"1\":{\"179\":1}}],[\"再更新\",{\"1\":{\"360\":1}}],[\"再把\",{\"1\":{\"360\":1,\"525\":1}}],[\"再建立一个数组\",{\"1\":{\"355\":1}}],[\"再建立一个数组记录起始点到所有点的最短路径\",{\"1\":{\"355\":1}}],[\"再按\",{\"1\":{\"338\":1}}],[\"再枚举左端点\",{\"1\":{\"307\":1}}],[\"再接下来\",{\"1\":{\"305\":1}}],[\"再进行重试\",{\"1\":{\"1266\":1}}],[\"再进行更新生成树\",{\"1\":{\"360\":1}}],[\"再进行比较得出最短路径\",{\"1\":{\"236\":1}}],[\"再进一步\",{\"1\":{\"60\":1}}],[\"再返回处理上一层找到的节点\",{\"1\":{\"731\":1}}],[\"再返回\",{\"1\":{\"235\":1}}],[\"再向下走两步\",{\"1\":{\"180\":1}}],[\"再对所有客人按消费金额从大到小排序\",{\"1\":{\"162\":1}}],[\"再重新排序进行下一次操作即可\",{\"1\":{\"156\":1}}],[\"再计算奇数和偶数的可选数量\",{\"1\":{\"87\":1}}],[\"再读取存储\",{\"1\":{\"48\":1}}],[\"再读db\",{\"1\":{\"28\":1}}],[\"再往大做可以是一个评论中台\",{\"1\":{\"45\":1}}],[\"再者\",{\"1\":{\"30\":1}}],[\"若检测出被中断直接抛出被中断异常\",{\"1\":{\"1508\":1}}],[\"若失败则先调用\",{\"1\":{\"1503\":1}}],[\"若失败的话就抛出异常\",{\"1\":{\"1251\":1}}],[\"若是周期性任务\",{\"1\":{\"1368\":1}}],[\"若是则直接返回\",{\"1\":{\"1273\":1}}],[\"若队列满足插入数据的条件\",{\"1\":{\"1351\":1}}],[\"若队列不为空则获取数据\",{\"1\":{\"1348\":1}}],[\"若队空返回true\",{\"1\":{\"1076\":1}}],[\"若超过当前给定的超时时间\",{\"1\":{\"1325\":1}}],[\"若超出地图边界\",{\"1\":{\"228\":1}}],[\"若阻塞队列已经满时\",{\"1\":{\"1325\":1}}],[\"若遇到了脏\",{\"1\":{\"1317\":2}}],[\"若没有查找到了可覆盖的\",{\"1\":{\"1317\":2}}],[\"若没有找到就返回\",{\"1\":{\"1273\":1}}],[\"若查找到了可覆盖的\",{\"1\":{\"1317\":2}}],[\"若再次遇到脏\",{\"1\":{\"1316\":1}}],[\"若将\",{\"1\":{\"1309\":1}}],[\"若能当前定位的\",{\"1\":{\"1307\":1}}],[\"若找到则通过\",{\"1\":{\"1284\":1}}],[\"若找到则返回节点的\",{\"1\":{\"1273\":1}}],[\"若第\",{\"1\":{\"1284\":1}}],[\"若当前已经有一个线程正在初始化即\",{\"1\":{\"1271\":1}}],[\"若当前变量实际值\",{\"1\":{\"1266\":2}}],[\"若被占有\",{\"1\":{\"1232\":1}}],[\"若成功入堆返回值true\",{\"1\":{\"1078\":1}}],[\"若成功添加则返回true\",{\"1\":{\"1073\":1}}],[\"若栈空返回true\",{\"1\":{\"1075\":1}}],[\"若map为null或者entry为null的话通过该方法初始化\",{\"1\":{\"1302\":1}}],[\"若map为空返回true\",{\"1\":{\"1074\":1}}],[\"若map中没有该key\",{\"1\":{\"1074\":2}}],[\"若集合为空返回true\",{\"1\":{\"1073\":1}}],[\"若集合中没有元素e\",{\"1\":{\"1073\":1}}],[\"若集合中有元素e则返回false\",{\"1\":{\"1073\":1}}],[\"若存在元素e\",{\"1\":{\"1073\":1}}],[\"若删除成功返回true\",{\"1\":{\"1073\":1}}],[\"若它的右子树不空\",{\"1\":{\"899\":1}}],[\"若头节点\",{\"1\":{\"887\":1}}],[\"若已经初始化了\",{\"1\":{\"1266\":1}}],[\"若已经是海水了\",{\"1\":{\"228\":1}}],[\"若已滑出窗口\",{\"1\":{\"857\":1}}],[\"若剩下字符串也能够完成分割\",{\"1\":{\"784\":1}}],[\"若剩下可选的数字不能填满剩下的空位则回退\",{\"1\":{\"289\":1}}],[\"若前面有使用\",{\"1\":{\"559\":1}}],[\"若依数据权限底层使用了\",{\"1\":{\"471\":1}}],[\"若依框架中的权限控制代码\",{\"1\":{\"465\":1}}],[\"若两区间部分存在交集\",{\"1\":{\"431\":1}}],[\"若右儿子小于它\",{\"1\":{\"417\":1}}],[\"若左二子小于它\",{\"1\":{\"417\":1}}],[\"若左移时舍弃的高位不包含\",{\"1\":{\"338\":1}}],[\"若从1开始\",{\"1\":{\"411\":1}}],[\"若一个游戏满足\",{\"1\":{\"395\":1}}],[\"若一级评论被删除\",{\"1\":{\"30\":1}}],[\"若在整个过程未遇到脏\",{\"1\":{\"1317\":2}}],[\"若在整个搜索过程没有脏\",{\"1\":{\"1316\":1}}],[\"若在搜索过程中发现了脏\",{\"1\":{\"1317\":1}}],[\"若在搜索过程再次遇到脏\",{\"1\":{\"1316\":1}}],[\"若在查找过程中遇到脏\",{\"1\":{\"1314\":1}}],[\"若在某一局面下存在某种行动\",{\"1\":{\"394\":1}}],[\"若在某一局面下无论采取何种行动\",{\"1\":{\"394\":1}}],[\"若在算数基本定理中\",{\"1\":{\"379\":1}}],[\"若p是质数\",{\"1\":{\"389\":1}}],[\"若整数\",{\"1\":{\"388\":1}}],[\"若为\",{\"1\":{\"381\":1}}],[\"若为0\",{\"1\":{\"235\":1}}],[\"若不是\",{\"1\":{\"1273\":1}}],[\"若不进行备份会因此发生串联效应\",{\"1\":{\"354\":1}}],[\"若不超过最大载重\",{\"1\":{\"290\":1}}],[\"若t\",{\"1\":{\"328\":1}}],[\"若a大于b\",{\"1\":{\"328\":1}}],[\"若ans为1\",{\"1\":{\"235\":1}}],[\"若满足则答案+1\",{\"1\":{\"291\":1}}],[\"若满足则答案\",{\"1\":{\"291\":1}}],[\"若满足条件\",{\"1\":{\"261\":1,\"410\":1}}],[\"若要提问\",{\"1\":{\"249\":1}}],[\"若\",{\"1\":{\"248\":1,\"273\":1,\"383\":2,\"783\":1,\"784\":1,\"846\":2,\"1301\":2,\"1302\":1,\"1383\":1}}],[\"若可走且未访问\",{\"1\":{\"236\":1,\"237\":1}}],[\"若无法逃出\",{\"1\":{\"236\":1,\"237\":1}}],[\"若平局则输出\",{\"1\":{\"174\":1}}],[\"若小美以获胜输出\",{\"1\":{\"174\":1}}],[\"若相同则平局\",{\"1\":{\"174\":1}}],[\"若某些位置被多次染色\",{\"1\":{\"157\":1}}],[\"若注册成功\",{\"1\":{\"88\":1}}],[\"若该账号合法但已经被注册过\",{\"1\":{\"88\":1}}],[\"若账号长度合法但出现了英文字母以外的字符\",{\"1\":{\"88\":1}}],[\"若账号长度不合法\",{\"1\":{\"88\":1}}],[\"若直接删除\",{\"1\":{\"30\":1}}],[\"若回复数也要无限套娃\",{\"1\":{\"30\":1}}],[\"若用户重新刷新页面\",{\"1\":{\"28\":1}}],[\"更改为\",{\"1\":{\"1455\":1}}],[\"更改node中的指针域next\",{\"1\":{\"1282\":2}}],[\"更改node中的数据域item\",{\"1\":{\"1282\":1}}],[\"更严重的是可能导致业务逻辑出现问题\",{\"1\":{\"1320\":1}}],[\"更多细节可以看这篇文章\",{\"1\":{\"1411\":1}}],[\"更多的细节可以看\",{\"1\":{\"1313\":1}}],[\"更多关于\",{\"1\":{\"1276\":1}}],[\"更多嵌套层次\",{\"1\":{\"30\":1}}],[\"更容易辨识\",{\"1\":{\"1147\":1}}],[\"更偏向于左外连接\",{\"1\":{\"945\":1}}],[\"更简单的说\",{\"1\":{\"1423\":1}}],[\"更简单的办法\",{\"1\":{\"663\":1}}],[\"更简洁的写法\",{\"1\":{\"870\":1}}],[\"更加好写\",{\"1\":{\"851\":1}}],[\"更加不容易出现评论区维度的热点\",{\"1\":{\"37\":1}}],[\"更早的状态\",{\"1\":{\"797\":1}}],[\"更换为程序所在目录\",{\"1\":{\"671\":1}}],[\"更优\",{\"1\":{\"617\":1}}],[\"更稳\",{\"1\":{\"617\":1}}],[\"更快\",{\"1\":{\"617\":1}}],[\"更快的首屏加载速度\",{\"1\":{\"533\":1}}],[\"更快的页面切换速度\",{\"1\":{\"532\":1}}],[\"更灵活\",{\"1\":{\"599\":1}}],[\"更好的可访问性\",{\"1\":{\"533\":1}}],[\"更好的搜索引擎优化\",{\"1\":{\"533\":1}}],[\"更有一种\",{\"1\":{\"437\":1}}],[\"更平衡一些\",{\"1\":{\"274\":1}}],[\"更省事\",{\"1\":{\"228\":1}}],[\"更形式化地说\",{\"1\":{\"128\":1}}],[\"更新后数据并没有及时写回到主存\",{\"1\":{\"1417\":1}}],[\"更新类的属性必须使用\",{\"1\":{\"1388\":1}}],[\"更新等操作\",{\"1\":{\"1385\":1}}],[\"更新的方式\",{\"1\":{\"1385\":1}}],[\"更新的新值\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"更新的操作\",{\"1\":{\"1286\":1}}],[\"更新为\",{\"1\":{\"1317\":1}}],[\"更新当前\",{\"1\":{\"1317\":1}}],[\"更新当前根节点的右指针为\",{\"1\":{\"725\":1}}],[\"更新触发时机\",{\"1\":{\"1286\":2}}],[\"更新状态为0\",{\"1\":{\"1252\":1}}],[\"更新lastwaiter\",{\"1\":{\"1251\":1}}],[\"更新同步状态\",{\"1\":{\"1242\":1}}],[\"更新第一个大于\",{\"1\":{\"852\":1}}],[\"更新第一个点到起点的最短距离\",{\"1\":{\"352\":1}}],[\"更新对应位置的\",{\"1\":{\"783\":1}}],[\"更新最长路径\",{\"1\":{\"761\":1}}],[\"更新最短距离\",{\"1\":{\"312\":1}}],[\"更新配置\",{\"1\":{\"671\":1}}],[\"更新配置并设置开机启动\",{\"1\":{\"671\":1}}],[\"更新时间\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"566\":2}}],[\"更新区间\",{\"1\":{\"431\":1}}],[\"更新端点和遍历的区间\",{\"1\":{\"430\":1}}],[\"更新右端点\",{\"1\":{\"427\":1}}],[\"更新t\",{\"1\":{\"360\":1}}],[\"更新其他点到集合的距离\",{\"1\":{\"360\":1}}],[\"更新两点之间的最短距离\",{\"1\":{\"354\":1}}],[\"更新完一个子节点\",{\"1\":{\"314\":1}}],[\"更新前缀计数器\",{\"1\":{\"309\":1}}],[\"更新c\",{\"1\":{\"291\":1}}],[\"更新操作\",{\"1\":{\"200\":1}}],[\"更新数据库中的标记字段\",{\"1\":{\"151\":1}}],[\"更新至少\",{\"1\":{\"129\":1}}],[\"更新积分和查询排名等操作\",{\"1\":{\"129\":1}}],[\"更新积分\",{\"1\":{\"129\":1}}],[\"更新\",{\"1\":{\"99\":1,\"109\":1,\"115\":1,\"129\":2,\"135\":1,\"355\":1,\"1251\":1,\"1275\":1,\"1286\":3}}],[\"更新频率\",{\"1\":{\"40\":1}}],[\"更进一步的\",{\"1\":{\"60\":1}}],[\"更可以来一个段子\",{\"1\":{\"41\":1}}],[\"更易扩展的工程化能力\",{\"1\":{\"40\":1}}],[\"更像是饭后甜点\",{\"1\":{\"21\":1}}],[\"cycliclatch\",{\"1\":{\"1394\":1}}],[\"cyclic\",{\"1\":{\"1393\":1}}],[\"cyclicbarrierdemo\",{\"1\":{\"1393\":1}}],[\"cyclicbarrier\",{\"0\":{\"1391\":1,\"1393\":1,\"1394\":1},\"1\":{\"1393\":12,\"1394\":6}}],[\"ctl\",{\"1\":{\"1359\":3,\"1370\":1}}],[\"ctrl\",{\"1\":{\"539\":1}}],[\"cbrt\",{\"1\":{\"1080\":1}}],[\"cba​=\",{\"1\":{\"389\":1}}],[\"cpus\",{\"1\":{\"1194\":1}}],[\"cpu\",{\"1\":{\"957\":1,\"1194\":1,\"1218\":8,\"1220\":2,\"1224\":2,\"1264\":1,\"1271\":1,\"1338\":2,\"1339\":4,\"1361\":8,\"1417\":2,\"1447\":1,\"1454\":1}}],[\"cmin\",{\"1\":{\"1083\":1}}],[\"cmax\",{\"1\":{\"1083\":1}}],[\"cmd\",{\"1\":{\"559\":1,\"663\":4,\"1089\":1,\"1090\":1}}],[\"cmpxchg\",{\"1\":{\"1266\":1,\"1282\":1,\"1383\":1,\"1437\":1}}],[\"cmp\",{\"1\":{\"328\":2,\"423\":2,\"1282\":4}}],[\"ceil\",{\"1\":{\"1080\":1}}],[\"ceilingentry\",{\"1\":{\"1040\":1}}],[\"ceiling\",{\"1\":{\"1039\":1}}],[\"certificate\",{\"1\":{\"672\":2}}],[\"centos\",{\"1\":{\"663\":1}}],[\"centered\",{\"1\":{\"587\":1}}],[\"center\",{\"0\":{\"1524\":1},\"1\":{\"549\":1,\"559\":3,\"1190\":1}}],[\"cellvalue\",{\"1\":{\"1275\":1}}],[\"cellsbusy\",{\"1\":{\"1275\":1}}],[\"cells\",{\"1\":{\"141\":7,\"1275\":1,\"1315\":2}}],[\"cell\",{\"1\":{\"141\":3,\"1275\":1}}],[\"cdn\",{\"1\":{\"534\":2,\"668\":2,\"670\":1}}],[\"csh\",{\"1\":{\"1107\":1}}],[\"cs\",{\"1\":{\"1069\":2,\"1218\":1}}],[\"csdn\",{\"1\":{\"576\":1,\"1140\":1,\"1171\":1}}],[\"csr\",{\"1\":{\"531\":1,\"532\":5,\"535\":1}}],[\"csrf\",{\"1\":{\"446\":2}}],[\"css\",{\"1\":{\"446\":1,\"531\":1,\"540\":1,\"544\":2,\"548\":1,\"549\":2}}],[\"crazy\",{\"1\":{\"1171\":1}}],[\"creating\",{\"1\":{\"1275\":1}}],[\"creationdate\",{\"1\":{\"1102\":1}}],[\"createthreaddemo\",{\"1\":{\"1330\":1}}],[\"createtime\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":2,\"517\":1,\"525\":1,\"566\":2,\"592\":1}}],[\"createmap\",{\"1\":{\"1301\":3,\"1302\":1}}],[\"created\",{\"1\":{\"592\":1}}],[\"create\",{\"1\":{\"471\":4,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"538\":4,\"559\":1,\"566\":1,\"913\":2,\"915\":1,\"918\":1,\"921\":1,\"937\":1,\"959\":1,\"1175\":1,\"1306\":1,\"1314\":1}}],[\"credentials\",{\"1\":{\"1100\":1}}],[\"cron表达式不正确\",{\"1\":{\"481\":1}}],[\"cronutils\",{\"1\":{\"481\":1}}],[\"crontrigger\",{\"1\":{\"479\":1}}],[\"cron\",{\"1\":{\"476\":1,\"477\":1,\"484\":1}}],[\"crypto\",{\"1\":{\"446\":1}}],[\"crud\",{\"1\":{\"50\":2}}],[\"ck\",{\"1\":{\"376\":1}}],[\"c2\",{\"1\":{\"376\":1,\"1191\":5}}],[\"c2​\",{\"1\":{\"290\":1}}],[\"c1\",{\"1\":{\"376\":1,\"1191\":2}}],[\"c1​\",{\"1\":{\"290\":1}}],[\"c表示当前点的颜色\",{\"1\":{\"362\":1}}],[\"c中的\",{\"1\":{\"249\":1}}],[\"customexpirypolicy\",{\"1\":{\"1211\":4}}],[\"customexpirypolicy<>\",{\"1\":{\"1211\":1}}],[\"customexpirypolicy<object\",{\"1\":{\"1211\":1}}],[\"customexpirypolicy<k\",{\"1\":{\"1210\":1}}],[\"customers\",{\"1\":{\"181\":4}}],[\"cust\",{\"1\":{\"181\":7}}],[\"curthread\",{\"1\":{\"1337\":3}}],[\"currentthread\",{\"1\":{\"1232\":2,\"1233\":1,\"1239\":1,\"1242\":1,\"1243\":1,\"1251\":1,\"1254\":2,\"1260\":1,\"1284\":1,\"1301\":1,\"1302\":2,\"1303\":1,\"1313\":1,\"1337\":1,\"1392\":3,\"1393\":2,\"1398\":4,\"1406\":12,\"1407\":12,\"1409\":6,\"1410\":6,\"1411\":2,\"1496\":1,\"1504\":1}}],[\"currenttimemillis\",{\"1\":{\"1201\":2}}],[\"currently\",{\"1\":{\"1193\":1}}],[\"currentuser>\",{\"1\":{\"589\":1,\"592\":2}}],[\"currentuser\",{\"1\":{\"587\":1,\"589\":8,\"591\":5}}],[\"currentyear\",{\"1\":{\"549\":2}}],[\"current\",{\"1\":{\"510\":4,\"511\":4,\"512\":4,\"513\":3,\"525\":2,\"566\":3,\"589\":3,\"1190\":1,\"1194\":1,\"1232\":3,\"1233\":3,\"1239\":3,\"1242\":6,\"1243\":3,\"1317\":1,\"1350\":1}}],[\"currentsum\",{\"1\":{\"140\":4}}],[\"cur\",{\"1\":{\"103\":4,\"121\":5,\"122\":6,\"133\":3,\"146\":3,\"180\":5,\"682\":7,\"887\":20,\"888\":6}}],[\"circularqueue<pair<long\",{\"1\":{\"1160\":2}}],[\"ciphers\",{\"1\":{\"672\":2}}],[\"ci\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1}}],[\"ci​\",{\"1\":{\"162\":2,\"290\":1}}],[\"cin>>n\",{\"1\":{\"312\":1}}],[\"cin\",{\"1\":{\"65\":3,\"66\":3,\"76\":1,\"77\":2,\"110\":1,\"119\":1,\"120\":2,\"121\":1,\"122\":2,\"139\":1,\"140\":2,\"141\":2,\"142\":1,\"146\":2,\"147\":2,\"172\":1,\"173\":2,\"174\":3,\"194\":3,\"197\":5,\"200\":4,\"203\":4,\"206\":2,\"223\":3,\"224\":1,\"228\":2,\"229\":2,\"230\":2,\"235\":2,\"236\":2,\"237\":2,\"261\":2,\"262\":2,\"263\":2,\"273\":3,\"274\":2,\"278\":2,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":2,\"291\":1,\"296\":2,\"297\":2,\"298\":6,\"299\":6,\"301\":2,\"302\":6,\"303\":1,\"304\":3,\"305\":3,\"306\":2,\"307\":2,\"308\":1,\"309\":1,\"311\":1,\"312\":1,\"314\":1,\"324\":2,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"339\":2,\"345\":1,\"352\":2,\"360\":2,\"376\":2,\"389\":2,\"392\":2,\"394\":2,\"411\":2,\"427\":2,\"428\":2,\"429\":2,\"430\":3,\"431\":2}}],[\"c++代码模板\",{\"1\":{\"321\":1,\"322\":1}}],[\"c++\",{\"0\":{\"422\":1},\"1\":{\"98\":1,\"128\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"254\":1,\"894\":2,\"1082\":1}}],[\"ch\",{\"1\":{\"802\":4}}],[\"chmod\",{\"1\":{\"670\":1,\"1087\":1,\"1107\":1,\"1119\":1}}],[\"children\",{\"1\":{\"540\":2,\"548\":3,\"802\":1,\"803\":6}}],[\"chain\",{\"1\":{\"1242\":1}}],[\"chaining\",{\"1\":{\"971\":1,\"1306\":1}}],[\"changes\",{\"1\":{\"1351\":1}}],[\"changestatus\",{\"1\":{\"482\":4}}],[\"changed\",{\"1\":{\"1244\":1,\"1315\":1,\"1506\":1,\"1511\":1}}],[\"change\",{\"1\":{\"922\":2,\"1252\":1}}],[\"char>>\",{\"1\":{\"224\":1}}],[\"character\",{\"1\":{\"83\":3,\"88\":3,\"98\":1,\"1074\":1,\"1083\":2,\"1472\":1}}],[\"charat\",{\"1\":{\"71\":1,\"82\":4,\"83\":4,\"127\":12,\"803\":2,\"840\":2,\"845\":1,\"846\":4,\"1005\":2,\"1007\":1,\"1069\":1,\"1070\":1}}],[\"char\",{\"1\":{\"71\":1,\"77\":1,\"83\":3,\"93\":2,\"98\":1,\"161\":1,\"180\":3,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"243\":2,\"246\":1,\"251\":2,\"279\":1,\"303\":1,\"305\":4,\"306\":1,\"411\":1,\"412\":2,\"820\":2,\"821\":2,\"822\":1,\"920\":5,\"978\":1,\"982\":1,\"997\":2,\"998\":1,\"1004\":3,\"1005\":5,\"1007\":1,\"1069\":5,\"1385\":1,\"1472\":1}}],[\"checking\",{\"1\":{\"1359\":1}}],[\"checkinterruptwhilewaiting\",{\"1\":{\"1251\":2}}],[\"checks\",{\"1\":{\"1359\":1}}],[\"checksum\",{\"1\":{\"1095\":1}}],[\"checked\",{\"1\":{\"1316\":1,\"1485\":1}}],[\"checknotnull\",{\"1\":{\"1283\":1,\"1347\":1}}],[\"checkpassword\",{\"1\":{\"568\":16,\"576\":4,\"587\":3}}],[\"check\",{\"1\":{\"83\":3,\"173\":2,\"291\":3,\"309\":1,\"322\":2,\"323\":1,\"325\":2,\"340\":1,\"362\":1,\"407\":1,\"410\":2,\"1242\":2,\"1275\":3,\"1283\":1,\"1317\":1,\"1359\":1}}],[\"cxy\",{\"1\":{\"77\":1}}],[\"cleansomeslot\",{\"1\":{\"1316\":3}}],[\"cleansomeslots\",{\"0\":{\"1315\":1},\"1\":{\"1306\":3,\"1314\":2,\"1315\":2,\"1316\":3,\"1317\":8}}],[\"clean\",{\"1\":{\"1251\":2,\"1317\":1}}],[\"clearcache\",{\"1\":{\"1201\":2}}],[\"clear\",{\"1\":{\"157\":1,\"174\":1,\"311\":1,\"422\":4,\"1036\":1,\"1037\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1308\":2,\"1317\":1,\"1506\":1}}],[\"claiming\",{\"1\":{\"1191\":1}}],[\"clash\",{\"1\":{\"661\":1}}],[\"classic\",{\"1\":{\"1346\":1}}],[\"classpathresource\",{\"1\":{\"1135\":1}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"1134\":1}}],[\"class<\",{\"1\":{\"1055\":1}}],[\"classnotfoundexception\",{\"1\":{\"1045\":1,\"1055\":1,\"1496\":1}}],[\"classname=\",{\"1\":{\"549\":1,\"587\":1}}],[\"classname\",{\"1\":{\"545\":1}}],[\"classcastexception\",{\"1\":{\"1045\":1}}],[\"class\",{\"1\":{\"70\":1,\"71\":1,\"72\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":2,\"104\":1,\"108\":1,\"109\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"133\":1,\"134\":1,\"135\":1,\"152\":1,\"157\":2,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":1,\"187\":1,\"446\":4,\"515\":1,\"517\":1,\"523\":2,\"525\":2,\"526\":3,\"568\":1,\"576\":3,\"682\":1,\"687\":1,\"688\":1,\"694\":1,\"700\":1,\"705\":1,\"710\":1,\"713\":1,\"724\":1,\"725\":1,\"736\":1,\"737\":1,\"743\":1,\"748\":1,\"749\":1,\"755\":1,\"761\":1,\"767\":2,\"772\":1,\"778\":1,\"783\":1,\"784\":1,\"789\":1,\"795\":1,\"796\":1,\"797\":1,\"803\":1,\"809\":1,\"815\":1,\"820\":1,\"821\":1,\"822\":1,\"827\":1,\"828\":2,\"834\":1,\"840\":1,\"845\":1,\"846\":1,\"851\":1,\"852\":2,\"857\":1,\"864\":1,\"870\":2,\"876\":1,\"882\":1,\"887\":1,\"888\":1,\"893\":1,\"894\":2,\"899\":1,\"900\":1,\"901\":1,\"935\":1,\"978\":1,\"980\":3,\"981\":2,\"982\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":4,\"989\":1,\"990\":4,\"992\":1,\"993\":1,\"994\":2,\"997\":1,\"998\":1,\"999\":4,\"1000\":2,\"1001\":1,\"1004\":2,\"1006\":1,\"1011\":1,\"1014\":1,\"1015\":1,\"1017\":1,\"1018\":1,\"1020\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1027\":1,\"1028\":1,\"1029\":1,\"1030\":1,\"1033\":1,\"1034\":2,\"1045\":1,\"1047\":1,\"1048\":1,\"1049\":1,\"1055\":7,\"1059\":5,\"1061\":2,\"1062\":5,\"1063\":2,\"1100\":2,\"1133\":1,\"1145\":1,\"1150\":1,\"1201\":3,\"1210\":1,\"1211\":5,\"1221\":1,\"1254\":3,\"1260\":1,\"1267\":4,\"1275\":1,\"1281\":1,\"1293\":1,\"1301\":1,\"1305\":1,\"1309\":2,\"1330\":1,\"1336\":1,\"1337\":2,\"1340\":1,\"1350\":1,\"1385\":1,\"1386\":1,\"1387\":2,\"1388\":3,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":1,\"1406\":6,\"1407\":6,\"1409\":3,\"1410\":3,\"1411\":3,\"1429\":1,\"1431\":5,\"1432\":1,\"1449\":2,\"1455\":1,\"1458\":1,\"1467\":2,\"1469\":1,\"1470\":1,\"1471\":1,\"1475\":1,\"1476\":1,\"1478\":1,\"1482\":1,\"1485\":2,\"1493\":1,\"1496\":4}}],[\"cls\",{\"1\":{\"1055\":5}}],[\"cloneable\",{\"1\":{\"1045\":1}}],[\"clone\",{\"1\":{\"1045\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"1045\":1}}],[\"cloudreve\",{\"0\":{\"669\":1,\"675\":1},\"1\":{\"668\":1,\"669\":2,\"670\":12,\"671\":16,\"672\":1,\"674\":1,\"675\":2,\"676\":1}}],[\"cloud\",{\"0\":{\"1543\":1},\"1\":{\"668\":1,\"672\":4}}],[\"close\",{\"1\":{\"129\":1,\"215\":4}}],[\"cli\",{\"1\":{\"559\":1,\"1095\":1}}],[\"clientconfig\",{\"1\":{\"1158\":2,\"1160\":2,\"1182\":1}}],[\"client\",{\"0\":{\"1156\":1,\"1157\":1,\"1183\":1},\"1\":{\"531\":1,\"545\":1,\"549\":1,\"672\":1,\"1095\":1,\"1153\":1,\"1157\":3,\"1158\":2,\"1160\":1,\"1175\":7,\"1178\":2,\"1182\":1,\"1184\":5,\"1185\":2,\"1186\":1}}],[\"cluster\",{\"1\":{\"56\":1}}],[\"c\",{\"1\":{\"65\":3,\"71\":2,\"77\":1,\"83\":5,\"93\":12,\"98\":8,\"156\":4,\"161\":2,\"166\":8,\"167\":19,\"203\":4,\"206\":4,\"223\":6,\"224\":5,\"243\":2,\"245\":2,\"251\":2,\"257\":1,\"273\":5,\"279\":3,\"290\":8,\"291\":16,\"324\":8,\"327\":9,\"328\":14,\"329\":11,\"330\":12,\"334\":2,\"335\":4,\"345\":4,\"352\":5,\"353\":2,\"355\":2,\"360\":3,\"361\":1,\"362\":4,\"371\":1,\"385\":13,\"387\":5,\"389\":6,\"390\":5,\"391\":1,\"422\":1,\"676\":1,\"894\":13,\"978\":1,\"980\":2,\"982\":1,\"984\":6,\"985\":4,\"988\":2,\"990\":2,\"997\":1,\"998\":1,\"1004\":4,\"1005\":5,\"1069\":4,\"1081\":3,\"1107\":1,\"1232\":6,\"1233\":3,\"1239\":13,\"1242\":5,\"1243\":3,\"1268\":2,\"1270\":2,\"1313\":1,\"1351\":4,\"1352\":4,\"1359\":4,\"1380\":1,\"1418\":1,\"1421\":4,\"1423\":1,\"1438\":1,\"1476\":4}}],[\"cas操作失败自旋尝试\",{\"1\":{\"1504\":1}}],[\"cas操作\",{\"1\":{\"1434\":1}}],[\"cas的操作过程\",{\"0\":{\"1383\":1}}],[\"cashead\",{\"1\":{\"1284\":2}}],[\"castail\",{\"1\":{\"1283\":7,\"1286\":1}}],[\"castabat\",{\"1\":{\"1268\":2,\"1272\":2,\"1274\":1}}],[\"casnext\",{\"1\":{\"1282\":1,\"1283\":5}}],[\"casitem\",{\"1\":{\"1282\":1,\"1284\":4}}],[\"casing\",{\"1\":{\"1242\":1}}],[\"cas\",{\"0\":{\"1268\":1,\"1282\":1,\"1381\":1,\"1382\":1,\"1384\":1,\"1435\":1,\"1436\":1,\"1437\":1,\"1438\":1,\"1439\":1},\"1\":{\"1242\":3,\"1264\":1,\"1266\":4,\"1268\":3,\"1272\":2,\"1275\":1,\"1276\":1,\"1282\":3,\"1283\":7,\"1284\":2,\"1286\":3,\"1293\":1,\"1380\":1,\"1381\":1,\"1382\":2,\"1383\":4,\"1384\":6,\"1385\":3,\"1436\":2,\"1437\":7,\"1438\":3,\"1439\":6,\"1442\":3,\"1446\":1,\"1447\":1,\"1491\":1,\"1504\":5,\"1505\":1,\"1506\":1,\"1511\":4}}],[\"cas算法\",{\"1\":{\"1220\":2}}],[\"cases\",{\"1\":{\"1511\":1}}],[\"case\",{\"1\":{\"129\":4,\"567\":1,\"827\":1,\"986\":9,\"1191\":2,\"1242\":1,\"1252\":1,\"1283\":1,\"1306\":1,\"1314\":1,\"1315\":1,\"1511\":1}}],[\"carry\",{\"1\":{\"700\":4}}],[\"cardbordered\",{\"1\":{\"592\":1}}],[\"carol\",{\"1\":{\"129\":1}}],[\"cancelacquire\",{\"1\":{\"1504\":1,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"cancel\",{\"1\":{\"1368\":1,\"1370\":1,\"1375\":9,\"1376\":1}}],[\"cancelled\",{\"1\":{\"1196\":1,\"1251\":3,\"1252\":2,\"1375\":1,\"1501\":1,\"1505\":1,\"1506\":2}}],[\"canrunincurrentrunstate\",{\"1\":{\"1368\":1,\"1370\":1}}],[\"can\",{\"1\":{\"1239\":1,\"1252\":1,\"1275\":1,\"1317\":1,\"1351\":1,\"1359\":1,\"1505\":1}}],[\"canfinish\",{\"1\":{\"876\":1}}],[\"canpartition\",{\"1\":{\"772\":1}}],[\"canadmin\",{\"1\":{\"592\":1}}],[\"canal\",{\"1\":{\"46\":1,\"50\":1}}],[\"cannot\",{\"1\":{\"575\":1,\"1149\":1,\"1252\":1,\"1359\":1,\"1505\":1}}],[\"camel\",{\"1\":{\"567\":1}}],[\"caffeine<\",{\"1\":{\"1206\":1}}],[\"caffeine\",{\"0\":{\"1205\":1},\"1\":{\"500\":1,\"502\":1,\"1205\":2,\"1206\":1,\"1207\":1}}],[\"calling\",{\"1\":{\"1408\":1}}],[\"caller\",{\"1\":{\"1505\":1}}],[\"callerrunspolicy\",{\"1\":{\"1359\":1}}],[\"called\",{\"1\":{\"1315\":1}}],[\"call\",{\"1\":{\"1330\":1,\"1359\":1}}],[\"callable<v>\",{\"1\":{\"1367\":1}}],[\"callable\",{\"1\":{\"1330\":11,\"1367\":1,\"1371\":1}}],[\"calendars\",{\"1\":{\"484\":1}}],[\"calculator\",{\"1\":{\"1055\":6}}],[\"calcite\",{\"1\":{\"640\":2}}],[\"calc\",{\"1\":{\"109\":1}}],[\"catch\",{\"1\":{\"587\":1,\"589\":1,\"591\":1,\"1047\":2,\"1048\":2,\"1049\":2,\"1059\":3,\"1063\":1,\"1103\":1,\"1149\":1,\"1221\":1,\"1250\":1,\"1254\":1,\"1260\":1,\"1266\":1,\"1274\":1,\"1309\":1,\"1330\":2,\"1336\":1,\"1337\":1,\"1340\":2,\"1392\":1,\"1393\":2,\"1398\":1,\"1399\":2,\"1406\":4,\"1407\":2,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1,\"1496\":1}}],[\"cat\",{\"1\":{\"391\":1}}],[\"cab​\",{\"1\":{\"390\":1}}],[\"cab​≡ca\",{\"1\":{\"389\":1}}],[\"cab​=b\",{\"1\":{\"388\":1}}],[\"cab​=ca−1b−1​+ca−1b​\",{\"1\":{\"387\":1}}],[\"cab​modp\",{\"1\":{\"389\":1}}],[\"cab​mod\",{\"1\":{\"387\":1}}],[\"cap\",{\"1\":{\"687\":3,\"1270\":3}}],[\"captchaimage\",{\"1\":{\"446\":1}}],[\"capture\",{\"1\":{\"255\":2}}],[\"capacity\",{\"1\":{\"243\":1,\"686\":3,\"687\":2,\"688\":6,\"1270\":5,\"1271\":2,\"1275\":1,\"1306\":6,\"1346\":3,\"1351\":3,\"1352\":1,\"1369\":2}}],[\"cachevalid\",{\"1\":{\"1244\":3}}],[\"cachedholdcounter\",{\"1\":{\"1242\":2,\"1243\":1}}],[\"cachemanagerbuilder\",{\"1\":{\"1211\":1}}],[\"cachemanager\",{\"1\":{\"1211\":3}}],[\"cacheconfigurationbuilder\",{\"1\":{\"1211\":2}}],[\"cachecontrol\",{\"1\":{\"446\":1}}],[\"cachebuilder\",{\"1\":{\"1204\":1}}],[\"cache<string\",{\"1\":{\"1204\":1,\"1207\":1,\"1211\":1}}],[\"cacheutil\",{\"1\":{\"1201\":5}}],[\"cacherefresh\",{\"1\":{\"1182\":1}}],[\"cacherefreshthread\",{\"1\":{\"1158\":1}}],[\"cacherefreshexecutor\",{\"1\":{\"1158\":2}}],[\"cache\",{\"0\":{\"1202\":1},\"1\":{\"28\":1,\"48\":5,\"58\":4,\"60\":5,\"61\":5,\"672\":1,\"687\":17,\"1201\":7,\"1202\":1,\"1204\":4,\"1205\":1,\"1207\":4,\"1211\":5}}],[\"cv15278397\",{\"1\":{\"41\":1}}],[\"cn=ca+b\",{\"1\":{\"291\":1}}],[\"cn​\",{\"1\":{\"290\":1}}],[\"cnt记录素数个数\",{\"1\":{\"371\":1}}],[\"cnt++\",{\"1\":{\"82\":1,\"224\":1,\"228\":1,\"229\":1,\"262\":1,\"298\":2,\"311\":1,\"361\":1,\"371\":1,\"373\":1}}],[\"cnt\",{\"1\":{\"82\":4,\"173\":4,\"174\":2,\"178\":7,\"197\":1,\"200\":6,\"223\":4,\"224\":2,\"228\":3,\"229\":3,\"255\":5,\"261\":9,\"262\":2,\"298\":6,\"309\":3,\"311\":4,\"356\":5,\"361\":3,\"371\":1,\"373\":1,\"380\":2,\"390\":4,\"412\":4,\"881\":2,\"882\":5,\"1061\":3,\"1062\":6}}],[\"cnm​\",{\"1\":{\"72\":1}}],[\"cn\",{\"1\":{\"41\":1,\"540\":1,\"567\":1,\"668\":1,\"672\":4,\"1086\":1,\"1087\":1,\"1093\":1,\"1095\":1}}],[\"cow\",{\"0\":{\"1291\":1},\"1\":{\"1291\":2,\"1295\":6}}],[\"cope\",{\"1\":{\"1274\":1}}],[\"copyonwritearrayset\",{\"1\":{\"1293\":1}}],[\"copyonwritearraylist\",{\"0\":{\"1289\":1,\"1290\":1,\"1292\":1},\"1\":{\"1290\":2,\"1291\":1,\"1292\":2,\"1324\":1}}],[\"copyonwrite\",{\"1\":{\"1291\":2,\"1295\":4}}],[\"copyofrange\",{\"1\":{\"1067\":1}}],[\"copyof\",{\"1\":{\"1067\":1,\"1294\":1,\"1295\":1}}],[\"copyrandomlist\",{\"1\":{\"887\":1,\"888\":1}}],[\"copy\",{\"1\":{\"592\":1,\"1049\":1,\"1291\":2}}],[\"copyable\",{\"1\":{\"592\":6}}],[\"copyproperties\",{\"1\":{\"526\":1}}],[\"cos\",{\"1\":{\"1094\":1}}],[\"coinchange\",{\"1\":{\"893\":1,\"894\":2}}],[\"coins\",{\"1\":{\"892\":1,\"893\":6,\"894\":7}}],[\"cookie\",{\"1\":{\"574\":1,\"575\":5}}],[\"corsfilter\",{\"1\":{\"446\":5}}],[\"corepoolsize\",{\"1\":{\"1359\":10,\"1366\":10,\"1370\":1}}],[\"core\",{\"1\":{\"446\":1,\"539\":1,\"665\":1,\"1135\":1,\"1136\":1,\"1145\":1}}],[\"codegenerator\",{\"1\":{\"516\":1}}],[\"code\",{\"1\":{\"246\":1,\"598\":1,\"1095\":1,\"1120\":1,\"1151\":1,\"1306\":1,\"1315\":2}}],[\"column1\",{\"1\":{\"947\":2}}],[\"columnsstate=\",{\"1\":{\"592\":1}}],[\"columns=\",{\"1\":{\"592\":1}}],[\"columns\",{\"1\":{\"592\":4}}],[\"colliding\",{\"1\":{\"1316\":1}}],[\"collector\",{\"1\":{\"1317\":2}}],[\"collectors\",{\"1\":{\"525\":1,\"578\":1}}],[\"collection\",{\"1\":{\"1324\":1}}],[\"collection<thread>\",{\"1\":{\"1398\":1}}],[\"collection<e>\",{\"1\":{\"1081\":5}}],[\"collection<v>\",{\"1\":{\"1074\":1}}],[\"collections\",{\"0\":{\"1081\":1},\"1\":{\"129\":1,\"1038\":1,\"1067\":1,\"1078\":1,\"1264\":1,\"1280\":1,\"1290\":2,\"1324\":1}}],[\"collect\",{\"1\":{\"525\":1,\"578\":1}}],[\"collutil\",{\"1\":{\"525\":1}}],[\"collate\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1}}],[\"colorpoint\",{\"1\":{\"1028\":2,\"1029\":3}}],[\"colors\",{\"1\":{\"157\":8}}],[\"color\",{\"1\":{\"157\":6,\"362\":7,\"1028\":8}}],[\"coverage\",{\"1\":{\"141\":3}}],[\"could\",{\"1\":{\"1315\":1,\"1316\":1}}],[\"coupons\",{\"1\":{\"109\":2}}],[\"cout\",{\"1\":{\"65\":1,\"66\":1,\"76\":2,\"77\":2,\"110\":1,\"119\":2,\"120\":1,\"121\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":3,\"172\":1,\"173\":1,\"174\":7,\"194\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":2,\"236\":2,\"237\":2,\"243\":1,\"249\":1,\"251\":3,\"261\":1,\"262\":2,\"263\":1,\"274\":2,\"278\":1,\"279\":1,\"287\":2,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":2,\"297\":2,\"298\":4,\"299\":2,\"301\":2,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":2,\"311\":1,\"312\":1,\"324\":1,\"330\":2,\"339\":2,\"352\":1,\"368\":3,\"376\":1,\"389\":1,\"392\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1}}],[\"countdown\",{\"1\":{\"1392\":8,\"1394\":1}}],[\"countdownlatchdemo\",{\"1\":{\"1392\":1}}],[\"countdownlatch\",{\"0\":{\"1391\":1,\"1392\":1,\"1394\":1},\"1\":{\"1392\":19,\"1393\":3,\"1394\":5,\"1495\":1}}],[\"counter++\",{\"1\":{\"1482\":2}}],[\"counter\",{\"1\":{\"1275\":1,\"1482\":6}}],[\"countercells\",{\"1\":{\"1275\":4}}],[\"countercell\",{\"1\":{\"1275\":7}}],[\"counts\",{\"1\":{\"1275\":1}}],[\"countnodes\",{\"1\":{\"713\":4}}],[\"count++\",{\"1\":{\"172\":1,\"1242\":1,\"1306\":1,\"1347\":1,\"1429\":1,\"1449\":1}}],[\"countways\",{\"1\":{\"135\":1}}],[\"count\",{\"1\":{\"30\":1,\"31\":1,\"37\":3,\"40\":2,\"56\":1,\"141\":3,\"172\":2,\"174\":1,\"203\":2,\"224\":1,\"279\":1,\"422\":2,\"568\":2,\"932\":2,\"1062\":15,\"1232\":1,\"1233\":1,\"1239\":7,\"1242\":5,\"1243\":5,\"1275\":1,\"1306\":2,\"1346\":1,\"1347\":2,\"1348\":2,\"1350\":1,\"1351\":8,\"1352\":4,\"1392\":1,\"1429\":2,\"1449\":2}}],[\"convention\",{\"1\":{\"1351\":1}}],[\"conventions\",{\"1\":{\"543\":1}}],[\"conditon\",{\"1\":{\"1410\":1}}],[\"conditionchange\",{\"1\":{\"1407\":2}}],[\"conditionobject\",{\"1\":{\"1250\":6,\"1496\":1}}],[\"condition\",{\"0\":{\"1247\":1,\"1248\":1,\"1249\":1,\"1410\":1},\"1\":{\"990\":2,\"1248\":9,\"1250\":14,\"1251\":13,\"1252\":6,\"1253\":4,\"1254\":6,\"1258\":1,\"1259\":2,\"1345\":2,\"1346\":6,\"1348\":1,\"1350\":3,\"1353\":1,\"1402\":1,\"1408\":2,\"1410\":7,\"1493\":1,\"1496\":3,\"1501\":1}}],[\"condiiton\",{\"1\":{\"1250\":1}}],[\"connection\",{\"1\":{\"1131\":1,\"1132\":6}}],[\"concurrency\",{\"1\":{\"1346\":1,\"1438\":1}}],[\"concurrencylevel\",{\"1\":{\"1270\":1}}],[\"concurrenhashmap\",{\"1\":{\"1272\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"1290\":1}}],[\"concurrentlinkedqueue<>\",{\"1\":{\"1283\":1}}],[\"concurrentlinkedqueue<integer>\",{\"1\":{\"1283\":1}}],[\"concurrentlinkedqueue\",{\"0\":{\"1279\":1,\"1280\":1},\"1\":{\"1280\":1,\"1281\":6,\"1282\":1,\"1283\":4,\"1284\":1,\"1324\":1}}],[\"concurrenthashmap扩容示意图\",{\"1\":{\"1274\":1}}],[\"concurrenthashmap散列桶数组结构示意图\",{\"1\":{\"1272\":1}}],[\"concurrenthashmapde\",{\"1\":{\"1266\":1}}],[\"concurrenthashmap\",{\"0\":{\"1263\":1,\"1264\":1,\"1265\":1},\"1\":{\"1201\":1,\"1210\":1,\"1220\":1,\"1264\":4,\"1265\":1,\"1266\":2,\"1267\":1,\"1268\":2,\"1270\":14,\"1272\":9,\"1274\":1,\"1275\":5,\"1276\":2,\"1295\":1,\"1306\":4,\"1324\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"1201\":1}}],[\"concurrent\",{\"0\":{\"1491\":1},\"1\":{\"1061\":1,\"1237\":1,\"1258\":1,\"1259\":2,\"1274\":1,\"1275\":1,\"1299\":1,\"1334\":1,\"1491\":4}}],[\"concerns\",{\"1\":{\"47\":1}}],[\"conf\",{\"1\":{\"613\":1,\"672\":2}}],[\"configinstance\",{\"1\":{\"1150\":3}}],[\"configname\",{\"1\":{\"1149\":2}}],[\"configure\",{\"1\":{\"446\":2}}],[\"configurers\",{\"1\":{\"446\":1}}],[\"configurationbuilder\",{\"1\":{\"1211\":2}}],[\"configurationmanager\",{\"1\":{\"1145\":2,\"1149\":5,\"1150\":1,\"1151\":2}}],[\"configurationproperties\",{\"1\":{\"1100\":1}}],[\"configuration\",{\"1\":{\"446\":2,\"539\":1,\"567\":1,\"1100\":1,\"1149\":1}}],[\"config\",{\"1\":{\"446\":8,\"538\":1,\"539\":3,\"559\":6,\"575\":2,\"592\":1,\"1100\":1,\"1102\":1,\"1138\":1,\"1147\":1,\"1149\":1,\"1157\":3,\"1158\":4,\"1160\":2,\"1178\":1}}],[\"consumer2能够获取对象锁\",{\"1\":{\"1407\":1}}],[\"consumer2\",{\"1\":{\"1407\":9}}],[\"consumer1\",{\"1\":{\"1407\":9}}],[\"consumer\",{\"1\":{\"1407\":12,\"1409\":3,\"1410\":3,\"1411\":3}}],[\"consistency\",{\"1\":{\"955\":2}}],[\"console\",{\"1\":{\"182\":1,\"589\":2,\"592\":3,\"1087\":3,\"1088\":1,\"1089\":1}}],[\"constant\",{\"1\":{\"580\":1}}],[\"constants\",{\"1\":{\"481\":6,\"1147\":1}}],[\"constraint\",{\"1\":{\"566\":1,\"937\":2}}],[\"constructor<\",{\"1\":{\"1055\":1}}],[\"constructor\",{\"1\":{\"549\":1,\"1055\":4}}],[\"const\",{\"1\":{\"110\":1,\"135\":1,\"140\":2,\"141\":2,\"194\":1,\"197\":2,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"235\":1,\"236\":1,\"237\":1,\"243\":3,\"251\":1,\"252\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"311\":1,\"312\":1,\"324\":1,\"325\":1,\"327\":1,\"339\":1,\"352\":1,\"360\":1,\"361\":3,\"376\":1,\"385\":1,\"392\":1,\"411\":1,\"423\":2,\"427\":3,\"428\":3,\"429\":3,\"430\":3,\"431\":1,\"540\":1,\"549\":1,\"587\":10,\"589\":5,\"591\":4,\"592\":5}}],[\"continual\",{\"1\":{\"1317\":1}}],[\"continues\",{\"1\":{\"1511\":1}}],[\"continue\",{\"0\":{\"993\":1},\"1\":{\"83\":2,\"121\":1,\"180\":1,\"200\":1,\"223\":1,\"307\":1,\"353\":1,\"371\":1,\"385\":1,\"821\":1,\"845\":1,\"993\":1,\"1284\":2,\"1511\":3}}],[\"control\",{\"1\":{\"909\":1,\"1129\":1,\"1131\":1,\"1315\":2,\"1346\":1}}],[\"controller\",{\"1\":{\"450\":1,\"455\":1,\"461\":1,\"468\":1,\"516\":2,\"518\":1,\"526\":2,\"576\":4,\"596\":1}}],[\"contain\",{\"1\":{\"1275\":1}}],[\"container\",{\"1\":{\"587\":1}}],[\"containsvalue\",{\"1\":{\"1074\":1}}],[\"containskey\",{\"1\":{\"687\":2,\"784\":1,\"1040\":1,\"1074\":1,\"1201\":1}}],[\"containsanyignorecase\",{\"1\":{\"481\":3}}],[\"containsignorecase\",{\"1\":{\"481\":1}}],[\"contains\",{\"1\":{\"88\":1,\"784\":1,\"1039\":1,\"1069\":1,\"1073\":1}}],[\"contended\",{\"1\":{\"1275\":1}}],[\"contentstyle=\",{\"1\":{\"587\":1}}],[\"content\",{\"1\":{\"30\":2,\"31\":2,\"56\":11,\"58\":1,\"512\":1,\"517\":1,\"525\":1}}],[\"contextloads\",{\"1\":{\"1201\":1}}],[\"contextinitialized\",{\"1\":{\"1145\":1,\"1146\":1}}],[\"context\",{\"1\":{\"446\":1,\"576\":1,\"1140\":3,\"1141\":1}}],[\"command这条命令的stdout\",{\"1\":{\"1120\":1}}],[\"command\",{\"1\":{\"1120\":3,\"1359\":9,\"1367\":3,\"1368\":4,\"1370\":4}}],[\"committing\",{\"1\":{\"1274\":1}}],[\"commit\",{\"1\":{\"954\":1,\"1274\":1}}],[\"commonconstants\",{\"1\":{\"1157\":1,\"1178\":1}}],[\"commons<\",{\"1\":{\"568\":1}}],[\"commons\",{\"1\":{\"568\":4}}],[\"common\",{\"1\":{\"471\":1,\"1306\":1,\"1314\":1}}],[\"comment\",{\"0\":{\"47\":1,\"50\":1,\"51\":1},\"1\":{\"46\":5,\"47\":3,\"48\":2,\"49\":1,\"50\":1,\"51\":2,\"56\":20,\"58\":3,\"60\":1,\"510\":14,\"511\":10,\"512\":11,\"513\":7,\"566\":16,\"918\":4,\"922\":4}}],[\"compareandswaplong\",{\"1\":{\"1275\":2,\"1385\":1}}],[\"compareandswapint\",{\"1\":{\"1271\":2,\"1274\":2,\"1275\":2,\"1385\":3}}],[\"compareandswapobject\",{\"1\":{\"1268\":1,\"1282\":2}}],[\"compareandswapxxxx\",{\"1\":{\"1266\":1}}],[\"compareandsethead\",{\"1\":{\"1504\":2}}],[\"compareandsettail\",{\"1\":{\"1504\":6}}],[\"compareandset\",{\"1\":{\"1385\":3,\"1386\":1}}],[\"compareandsetwaitstatus\",{\"1\":{\"1252\":2,\"1505\":4,\"1506\":1,\"1511\":2}}],[\"compareandsetstate\",{\"1\":{\"1232\":1,\"1233\":1,\"1239\":1,\"1242\":1,\"1243\":1,\"1494\":1,\"1495\":1,\"1496\":2}}],[\"compare\",{\"1\":{\"1078\":1,\"1382\":1,\"1436\":1}}],[\"compareto\",{\"1\":{\"1005\":1,\"1326\":1}}],[\"comparator<e>\",{\"1\":{\"1078\":1}}],[\"comparator\",{\"1\":{\"1074\":2,\"1078\":1,\"1326\":1}}],[\"comparable\",{\"1\":{\"1074\":2,\"1078\":2}}],[\"completing\",{\"1\":{\"1375\":1}}],[\"completablefuture\",{\"1\":{\"643\":1}}],[\"complete\",{\"1\":{\"88\":3}}],[\"component\",{\"1\":{\"592\":1,\"1100\":1}}],[\"components\",{\"1\":{\"463\":1,\"540\":1,\"544\":2,\"549\":1,\"592\":2,\"596\":1}}],[\"compile\",{\"1\":{\"568\":1,\"575\":1}}],[\"computeifabsent\",{\"1\":{\"129\":2}}],[\"com\",{\"1\":{\"41\":4,\"446\":5,\"450\":1,\"451\":1,\"455\":1,\"456\":1,\"461\":1,\"462\":1,\"465\":1,\"471\":2,\"517\":1,\"537\":1,\"538\":1,\"539\":2,\"540\":1,\"543\":1,\"549\":1,\"560\":1,\"567\":1,\"568\":1,\"575\":1,\"661\":1,\"665\":4,\"1086\":2,\"1090\":1,\"1095\":3,\"1145\":1}}],[\"fwd\",{\"1\":{\"1274\":4}}],[\"fh\",{\"1\":{\"1272\":8,\"1274\":6}}],[\"fmin\",{\"1\":{\"1083\":1}}],[\"fmax\",{\"1\":{\"1083\":1}}],[\"f2\",{\"1\":{\"1015\":2,\"1018\":2}}],[\"f4\",{\"1\":{\"1013\":1}}],[\"f3\",{\"1\":{\"1013\":1,\"1015\":2}}],[\"f输出\",{\"1\":{\"982\":1}}],[\"f1\",{\"1\":{\"828\":5,\"1013\":1,\"1015\":2,\"1018\":2}}],[\"f0\",{\"1\":{\"828\":3}}],[\"fewer\",{\"1\":{\"1359\":1}}],[\"featuretask\",{\"1\":{\"1330\":2}}],[\"fetch\",{\"1\":{\"1158\":2}}],[\"fetchuserinfo\",{\"1\":{\"589\":1,\"591\":5}}],[\"feed\",{\"1\":{\"40\":4}}],[\"fc\",{\"1\":{\"587\":1}}],[\"freeing\",{\"1\":{\"1317\":1}}],[\"free\",{\"1\":{\"1232\":3,\"1240\":3,\"1243\":1}}],[\"fresh++\",{\"1\":{\"870\":2}}],[\"fresh\",{\"1\":{\"869\":3,\"870\":6}}],[\"friday\",{\"1\":{\"986\":1}}],[\"frameoptions\",{\"1\":{\"446\":1}}],[\"framework\",{\"1\":{\"446\":5,\"451\":2,\"456\":2,\"465\":2,\"471\":1}}],[\"front\",{\"1\":{\"110\":3,\"122\":3,\"133\":1,\"278\":1,\"279\":1,\"348\":1,\"355\":2,\"356\":1,\"422\":5}}],[\"from=search\",{\"1\":{\"41\":1}}],[\"from=333\",{\"1\":{\"41\":2}}],[\"from\",{\"1\":{\"30\":5,\"37\":2,\"56\":2,\"181\":2,\"471\":4,\"525\":1,\"540\":2,\"549\":1,\"592\":5,\"875\":3,\"876\":2,\"927\":1,\"929\":1,\"930\":4,\"931\":1,\"932\":1,\"933\":1,\"934\":1,\"935\":1,\"942\":4,\"944\":2,\"945\":2,\"947\":3,\"959\":1,\"1275\":1,\"1283\":1,\"1284\":1,\"1293\":1,\"1315\":2,\"1351\":1,\"1506\":1}}],[\"found\",{\"1\":{\"523\":1,\"526\":2,\"1171\":1,\"1221\":1,\"1315\":1,\"1317\":1,\"1346\":1,\"1515\":1}}],[\"fond\",{\"1\":{\"270\":1}}],[\"footerrender=\",{\"1\":{\"549\":1}}],[\"footer\",{\"1\":{\"549\":2}}],[\"foo\",{\"1\":{\"255\":2,\"1047\":2,\"1048\":2}}],[\"for循环退出\",{\"1\":{\"1274\":1}}],[\"forward\",{\"1\":{\"1496\":1}}],[\"forwardnode\",{\"1\":{\"1274\":1}}],[\"forwarding\",{\"1\":{\"1272\":1}}],[\"forwardingnode<k\",{\"1\":{\"1267\":1,\"1274\":2}}],[\"forwardingnode\",{\"1\":{\"1267\":3,\"1272\":3}}],[\"forwarded\",{\"1\":{\"672\":2}}],[\"forname\",{\"1\":{\"1055\":1}}],[\"formatted\",{\"1\":{\"1069\":2}}],[\"format\",{\"1\":{\"1005\":1,\"1027\":1,\"1028\":1,\"1069\":2}}],[\"form=\",{\"1\":{\"592\":1}}],[\"foreign\",{\"1\":{\"919\":1,\"937\":5}}],[\"foreach\",{\"1\":{\"446\":1,\"1102\":1,\"1103\":1}}],[\"ford算法擅长解决有边数限制的最短路问题\",{\"1\":{\"354\":1}}],[\"ford算法\",{\"0\":{\"354\":1}}],[\"ford算法的优化\",{\"1\":{\"351\":1}}],[\"ford\",{\"1\":{\"351\":1,\"354\":1}}],[\"for\",{\"0\":{\"990\":1,\"1517\":1},\"1\":{\"65\":4,\"66\":5,\"71\":2,\"72\":2,\"77\":4,\"82\":1,\"88\":1,\"93\":1,\"97\":1,\"98\":1,\"103\":4,\"104\":2,\"108\":3,\"109\":4,\"110\":3,\"114\":2,\"115\":3,\"119\":3,\"120\":1,\"121\":5,\"122\":2,\"126\":3,\"127\":4,\"128\":3,\"129\":2,\"133\":1,\"135\":2,\"140\":2,\"141\":12,\"142\":4,\"146\":5,\"152\":1,\"157\":2,\"161\":1,\"162\":3,\"172\":1,\"173\":2,\"174\":8,\"178\":3,\"179\":3,\"180\":2,\"182\":1,\"194\":5,\"197\":5,\"200\":4,\"203\":4,\"206\":2,\"221\":1,\"223\":3,\"224\":5,\"228\":5,\"229\":7,\"230\":4,\"235\":5,\"236\":3,\"237\":3,\"244\":1,\"245\":2,\"250\":1,\"252\":1,\"255\":1,\"261\":1,\"262\":2,\"263\":5,\"269\":1,\"273\":3,\"274\":2,\"278\":3,\"279\":2,\"281\":2,\"287\":1,\"288\":2,\"289\":2,\"290\":2,\"291\":3,\"296\":5,\"297\":5,\"298\":14,\"299\":9,\"301\":9,\"302\":8,\"303\":2,\"304\":5,\"305\":6,\"306\":4,\"307\":7,\"308\":5,\"309\":16,\"311\":7,\"312\":5,\"314\":3,\"318\":1,\"324\":2,\"327\":4,\"328\":6,\"329\":3,\"330\":3,\"339\":1,\"340\":1,\"342\":1,\"345\":5,\"347\":1,\"348\":1,\"349\":2,\"352\":3,\"353\":1,\"354\":5,\"355\":1,\"356\":2,\"358\":5,\"360\":5,\"361\":2,\"362\":2,\"363\":2,\"367\":1,\"368\":1,\"369\":3,\"371\":2,\"372\":5,\"373\":2,\"375\":1,\"376\":2,\"379\":1,\"380\":2,\"384\":1,\"385\":9,\"387\":2,\"388\":1,\"389\":1,\"390\":6,\"392\":3,\"407\":1,\"410\":1,\"411\":2,\"412\":2,\"414\":1,\"415\":1,\"416\":1,\"417\":1,\"419\":1,\"421\":1,\"427\":2,\"428\":2,\"429\":2,\"430\":2,\"431\":2,\"672\":2,\"682\":1,\"705\":1,\"749\":1,\"767\":3,\"772\":3,\"783\":2,\"784\":1,\"789\":1,\"795\":1,\"796\":2,\"797\":2,\"803\":2,\"820\":2,\"821\":3,\"822\":4,\"828\":2,\"840\":2,\"845\":2,\"846\":1,\"851\":2,\"852\":2,\"857\":2,\"870\":7,\"875\":3,\"876\":4,\"887\":1,\"888\":3,\"893\":2,\"894\":4,\"990\":5,\"992\":1,\"993\":1,\"994\":4,\"999\":7,\"1000\":3,\"1001\":2,\"1005\":2,\"1007\":1,\"1010\":1,\"1011\":1,\"1018\":1,\"1034\":1,\"1047\":2,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":1,\"1074\":5,\"1221\":1,\"1239\":1,\"1242\":2,\"1243\":1,\"1250\":1,\"1259\":2,\"1267\":4,\"1270\":1,\"1272\":5,\"1274\":4,\"1275\":3,\"1283\":6,\"1284\":3,\"1306\":3,\"1308\":2,\"1309\":1,\"1314\":1,\"1316\":2,\"1317\":12,\"1337\":1,\"1346\":4,\"1350\":2,\"1351\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1408\":1,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":2,\"1449\":2,\"1472\":1,\"1482\":2,\"1496\":1,\"1504\":4,\"1505\":1,\"1506\":1,\"1507\":1,\"1508\":1,\"1510\":1,\"1511\":1},\"2\":{\"67\":1,\"73\":1,\"79\":1,\"84\":1,\"89\":1,\"94\":1,\"100\":1,\"105\":1,\"111\":1,\"116\":1,\"123\":1,\"130\":1,\"136\":1,\"143\":1,\"148\":1,\"153\":1,\"158\":1,\"163\":1,\"169\":1,\"175\":1,\"183\":1}}],[\"fflush\",{\"1\":{\"249\":1}}],[\"f\",{\"1\":{\"194\":11,\"215\":2,\"221\":5,\"223\":1,\"224\":3,\"257\":4,\"296\":12,\"297\":11,\"298\":19,\"299\":10,\"301\":11,\"302\":9,\"303\":14,\"304\":7,\"305\":13,\"306\":22,\"307\":7,\"308\":25,\"309\":7,\"311\":8,\"312\":12,\"314\":12,\"430\":3,\"796\":16,\"797\":17,\"828\":7,\"839\":2,\"840\":12,\"852\":1,\"893\":15,\"894\":18,\"982\":2,\"988\":4,\"990\":4,\"997\":1,\"999\":7,\"1017\":2,\"1272\":18,\"1274\":10}}],[\"fallen\",{\"1\":{\"1283\":1}}],[\"false\",{\"1\":{\"77\":3,\"93\":5,\"98\":2,\"108\":2,\"127\":1,\"129\":1,\"186\":1,\"187\":2,\"281\":1,\"288\":1,\"291\":5,\"309\":1,\"311\":2,\"355\":1,\"356\":2,\"362\":3,\"363\":2,\"367\":2,\"369\":1,\"372\":1,\"381\":2,\"419\":1,\"430\":1,\"523\":1,\"567\":1,\"578\":1,\"579\":2,\"772\":1,\"784\":2,\"801\":2,\"803\":1,\"808\":2,\"874\":1,\"875\":1,\"876\":2,\"900\":1,\"978\":1,\"992\":1,\"994\":1,\"1063\":1,\"1145\":1,\"1158\":3,\"1190\":1,\"1191\":1,\"1232\":3,\"1233\":2,\"1239\":2,\"1251\":4,\"1252\":1,\"1254\":1,\"1274\":4,\"1283\":3,\"1284\":5,\"1315\":1,\"1325\":2,\"1326\":3,\"1336\":3,\"1337\":1,\"1359\":4,\"1360\":1,\"1368\":1,\"1370\":2,\"1375\":2,\"1406\":2,\"1444\":1,\"1455\":1,\"1458\":1,\"1496\":7,\"1500\":1,\"1504\":3,\"1505\":3,\"1506\":1,\"1507\":1,\"1508\":5,\"1510\":2,\"1511\":1}}],[\"failure\",{\"1\":{\"1283\":1,\"1351\":1,\"1504\":1}}],[\"fails\",{\"1\":{\"1242\":2,\"1252\":1,\"1359\":1,\"1506\":1,\"1511\":1}}],[\"fail\",{\"1\":{\"1239\":2,\"1242\":1,\"1290\":1,\"1306\":1,\"1314\":1}}],[\"failed\",{\"1\":{\"575\":1,\"663\":1,\"1251\":3,\"1504\":3,\"1505\":1,\"1507\":3,\"1508\":3,\"1510\":3,\"1511\":1}}],[\"fairsync\",{\"1\":{\"1233\":1}}],[\"fair\",{\"1\":{\"1233\":2,\"1346\":2}}],[\"favicon\",{\"1\":{\"543\":1}}],[\"fact\",{\"1\":{\"388\":3,\"1010\":3,\"1011\":2,\"1012\":4}}],[\"factory\",{\"0\":{\"966\":1},\"1\":{\"446\":1,\"1137\":1,\"1138\":1,\"1139\":1}}],[\"factor\",{\"1\":{\"369\":1,\"1306\":1}}],[\"fabs\",{\"1\":{\"385\":2}}],[\"father\",{\"1\":{\"345\":2}}],[\"fa\",{\"1\":{\"269\":3,\"270\":6,\"271\":1,\"273\":7,\"274\":10}}],[\"fastjson\",{\"1\":{\"635\":1}}],[\"fast\",{\"1\":{\"134\":5,\"833\":1,\"834\":5,\"1290\":1,\"1306\":2,\"1314\":2,\"1315\":1,\"1504\":1}}],[\"futuretask\",{\"0\":{\"1374\":1,\"1375\":1,\"1376\":1},\"1\":{\"1330\":1,\"1365\":1,\"1371\":3,\"1375\":31,\"1376\":8}}],[\"future\",{\"1\":{\"1330\":2,\"1371\":1,\"1375\":2,\"1376\":1}}],[\"future<string>\",{\"1\":{\"1330\":1}}],[\"fulladdcount\",{\"1\":{\"1275\":1}}],[\"fullyrelease\",{\"1\":{\"1251\":5}}],[\"fullyauthenticated\",{\"1\":{\"446\":1}}],[\"fulltryacquireshared\",{\"1\":{\"1242\":2}}],[\"fulltext\",{\"1\":{\"46\":1}}],[\"full\",{\"1\":{\"958\":1,\"1242\":2,\"1410\":3,\"1504\":1}}],[\"function\",{\"1\":{\"218\":1,\"219\":1,\"220\":1,\"542\":1,\"548\":1,\"549\":1,\"589\":1,\"591\":1,\"596\":1}}],[\"fun\",{\"1\":{\"83\":3}}],[\"fifo\",{\"1\":{\"1233\":1,\"1252\":1,\"1283\":1,\"1326\":2,\"1494\":1,\"1506\":1}}],[\"fibonacci\",{\"1\":{\"1306\":1}}],[\"fib\",{\"1\":{\"1023\":4}}],[\"fields\",{\"1\":{\"1319\":1}}],[\"fieldprops=\",{\"1\":{\"587\":3}}],[\"field\",{\"1\":{\"575\":1,\"1055\":6}}],[\"firewall\",{\"1\":{\"663\":4}}],[\"firewalld\",{\"1\":{\"663\":2}}],[\"fired\",{\"1\":{\"484\":1}}],[\"firstkey\",{\"1\":{\"1306\":3}}],[\"firstvalue\",{\"1\":{\"1301\":2,\"1306\":2}}],[\"firstwaiter\",{\"1\":{\"1250\":2,\"1251\":3,\"1252\":4}}],[\"firstreaderholdcount++\",{\"1\":{\"1242\":1}}],[\"firstreaderholdcount\",{\"1\":{\"1242\":1,\"1243\":3}}],[\"firstreader\",{\"1\":{\"1242\":2,\"1243\":2}}],[\"first存储距离\",{\"1\":{\"353\":1}}],[\"first\",{\"1\":{\"122\":1,\"200\":2,\"206\":1,\"223\":1,\"224\":1,\"254\":2,\"278\":2,\"342\":2,\"353\":1,\"376\":1,\"422\":2,\"431\":2,\"694\":3,\"789\":2,\"857\":2,\"1073\":1,\"1082\":1,\"1250\":1,\"1252\":14,\"1267\":1,\"1274\":1,\"1317\":4,\"1359\":1}}],[\"firstlist\",{\"1\":{\"70\":6}}],[\"filesystemresource\",{\"1\":{\"1135\":1}}],[\"fileoutputstream\",{\"1\":{\"1103\":1}}],[\"filename\",{\"1\":{\"1103\":1}}],[\"fileinputstream\",{\"1\":{\"1103\":1}}],[\"filewriter\",{\"1\":{\"1049\":1}}],[\"filereader\",{\"1\":{\"1049\":1}}],[\"fileld\",{\"1\":{\"576\":1}}],[\"file\",{\"1\":{\"543\":1,\"1103\":5,\"1149\":5,\"1157\":1,\"1178\":1}}],[\"fillinstacktrace\",{\"1\":{\"1046\":1}}],[\"fill\",{\"1\":{\"128\":1,\"772\":1,\"795\":1,\"796\":1,\"797\":1,\"827\":1,\"845\":1,\"893\":1,\"894\":2,\"1002\":1,\"1081\":1}}],[\"filter\",{\"1\":{\"40\":1,\"46\":2,\"446\":5,\"592\":2}}],[\"finnaly\",{\"1\":{\"1340\":2}}],[\"finishing\",{\"1\":{\"1274\":4}}],[\"find\",{\"1\":{\"252\":1,\"267\":1,\"270\":3,\"271\":2,\"273\":6,\"274\":9,\"279\":1,\"323\":1,\"341\":1,\"361\":6,\"363\":3,\"414\":4,\"415\":6,\"416\":5,\"419\":1,\"420\":1,\"422\":2,\"568\":1,\"575\":1,\"822\":6,\"1149\":1,\"1273\":1,\"1317\":3,\"1506\":1}}],[\"findnexthigherground\",{\"1\":{\"128\":2}}],[\"findlostorderid\",{\"1\":{\"114\":1}}],[\"findpossiblecafe\",{\"1\":{\"108\":1}}],[\"findfreetimeintersections\",{\"1\":{\"70\":1}}],[\"finalreferenceescapedemo\",{\"1\":{\"1478\":4}}],[\"finalreferencedemo\",{\"1\":{\"1476\":8}}],[\"final域\",{\"1\":{\"1475\":1}}],[\"finaldemo\",{\"1\":{\"1475\":14}}],[\"finalexampleparent\",{\"1\":{\"1469\":1,\"1470\":1,\"1471\":1}}],[\"finalexample\",{\"1\":{\"1467\":1,\"1469\":1}}],[\"finalize\",{\"1\":{\"1330\":1,\"1421\":2}}],[\"finally\",{\"1\":{\"1047\":1,\"1061\":1,\"1244\":2,\"1250\":1,\"1251\":1,\"1254\":2,\"1271\":1,\"1294\":1,\"1340\":6,\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1410\":2,\"1492\":2,\"1496\":1,\"1504\":1,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"final\",{\"0\":{\"1461\":1,\"1462\":1,\"1463\":1,\"1465\":1,\"1466\":1,\"1467\":2,\"1472\":1,\"1473\":1,\"1474\":1,\"1475\":1,\"1476\":1,\"1477\":1,\"1478\":1},\"1\":{\"72\":1,\"87\":1,\"517\":1,\"523\":1,\"526\":2,\"568\":1,\"576\":2,\"978\":1,\"1033\":1,\"1034\":1,\"1061\":1,\"1062\":1,\"1063\":2,\"1149\":1,\"1201\":2,\"1210\":1,\"1232\":3,\"1233\":2,\"1239\":2,\"1240\":1,\"1242\":1,\"1243\":1,\"1251\":3,\"1252\":2,\"1267\":9,\"1268\":3,\"1270\":1,\"1271\":1,\"1272\":3,\"1274\":1,\"1275\":3,\"1283\":1,\"1284\":1,\"1293\":1,\"1294\":1,\"1306\":3,\"1336\":1,\"1337\":3,\"1346\":4,\"1347\":2,\"1348\":2,\"1350\":5,\"1351\":2,\"1352\":2,\"1369\":2,\"1375\":7,\"1385\":3,\"1462\":2,\"1465\":1,\"1466\":5,\"1467\":9,\"1469\":6,\"1470\":5,\"1471\":5,\"1472\":6,\"1473\":1,\"1475\":22,\"1476\":18,\"1477\":6,\"1478\":5,\"1495\":2,\"1496\":1,\"1503\":1,\"1504\":4,\"1505\":1,\"1506\":1,\"1507\":3,\"1508\":4,\"1510\":3,\"1511\":1}}],[\"flatten\",{\"1\":{\"724\":1,\"725\":3}}],[\"flag\",{\"1\":{\"60\":2,\"362\":3,\"471\":4,\"1254\":3,\"1455\":4,\"1456\":1}}],[\"flex\",{\"1\":{\"587\":1}}],[\"flink\",{\"1\":{\"434\":1}}],[\"flip\",{\"1\":{\"422\":2}}],[\"flush\",{\"1\":{\"249\":4,\"982\":1,\"1049\":1}}],[\"floyd算法\",{\"0\":{\"358\":1}}],[\"float与double都用\",{\"1\":{\"982\":1}}],[\"float>\",{\"1\":{\"257\":2}}],[\"float\",{\"1\":{\"257\":4,\"588\":2,\"920\":1,\"978\":1,\"981\":1,\"982\":1,\"997\":2,\"1083\":2,\"1270\":2,\"1385\":1}}],[\"floodfill\",{\"1\":{\"212\":1}}],[\"floorentry\",{\"1\":{\"1040\":1}}],[\"floor\",{\"1\":{\"31\":1,\"56\":3,\"1039\":1,\"1080\":1}}],[\"floor=\",{\"1\":{\"30\":1}}],[\"flower\",{\"1\":{\"181\":2}}],[\"flowers\",{\"1\":{\"141\":5}}],[\"rs\",{\"1\":{\"1275\":5}}],[\"rsp\",{\"1\":{\"246\":1}}],[\"rwl\",{\"1\":{\"1244\":6}}],[\"rlresource\",{\"1\":{\"1135\":1}}],[\"rfloor​\",{\"1\":{\"795\":1}}],[\"rules=\",{\"1\":{\"587\":3}}],[\"runworker\",{\"1\":{\"1370\":2,\"1371\":1}}],[\"runandreset\",{\"1\":{\"1368\":1,\"1375\":1}}],[\"runable\",{\"1\":{\"1329\":1,\"1330\":4,\"1334\":3}}],[\"running\",{\"1\":{\"1359\":1}}],[\"runnablescheduledfuture<\",{\"1\":{\"1368\":1,\"1369\":2,\"1370\":2}}],[\"runnable\",{\"1\":{\"1059\":3,\"1062\":1,\"1221\":2,\"1254\":2,\"1309\":1,\"1330\":4,\"1340\":1,\"1359\":1,\"1367\":3,\"1368\":2,\"1370\":2,\"1371\":1,\"1376\":1,\"1393\":1,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1}}],[\"runstate\",{\"1\":{\"1359\":1}}],[\"runs\",{\"1\":{\"1317\":2}}],[\"runbit\",{\"1\":{\"1274\":4}}],[\"runtime\",{\"1\":{\"1361\":1,\"1418\":2}}],[\"runtimeexception\",{\"1\":{\"1044\":2,\"1059\":3,\"1063\":1,\"1103\":1,\"1404\":1}}],[\"runtimelayoutconfig\",{\"1\":{\"587\":1}}],[\"run\",{\"1\":{\"538\":1,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":1,\"1088\":1,\"1221\":6,\"1254\":2,\"1309\":1,\"1317\":5,\"1330\":7,\"1333\":2,\"1336\":3,\"1337\":1,\"1340\":2,\"1368\":7,\"1370\":1,\"1371\":2,\"1375\":5,\"1376\":1,\"1392\":2,\"1406\":4,\"1407\":4,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1}}],[\"ruoyi\",{\"0\":{\"1522\":1},\"1\":{\"446\":1,\"450\":2,\"451\":2,\"455\":2,\"456\":2,\"461\":2,\"462\":2,\"465\":2,\"470\":1,\"471\":2,\"486\":1},\"2\":{\"473\":1,\"491\":1}}],[\"rmi\",{\"1\":{\"481\":2}}],[\"rmq\",{\"1\":{\"174\":2}}],[\"rbac\",{\"0\":{\"444\":1},\"1\":{\"445\":1}}],[\"rbegin\",{\"1\":{\"141\":1}}],[\"rp\",{\"0\":{\"440\":1}}],[\"rpid\",{\"1\":{\"30\":2}}],[\"rds\",{\"1\":{\"438\":1}}],[\"r代表区间右端点\",{\"1\":{\"431\":1}}],[\"r表示上一连续区间的最右端的点\",{\"1\":{\"427\":1}}],[\"r时\",{\"1\":{\"320\":1}}],[\"r​\",{\"1\":{\"263\":1}}],[\"r×r\",{\"1\":{\"263\":1}}],[\"rh\",{\"1\":{\"223\":5,\"1242\":7,\"1243\":6}}],[\"race\",{\"1\":{\"1271\":1,\"1283\":1}}],[\"rayshinehub\",{\"1\":{\"658\":1}}],[\"ray\",{\"1\":{\"617\":1}}],[\"range\",{\"1\":{\"429\":8,\"430\":9,\"1274\":1}}],[\"random\",{\"1\":{\"423\":1,\"886\":6,\"887\":4,\"888\":8,\"1080\":1,\"1409\":4,\"1410\":4,\"1411\":4}}],[\"rank\",{\"1\":{\"129\":3,\"361\":7,\"414\":8}}],[\"rankmap\",{\"1\":{\"129\":20}}],[\"rating\",{\"1\":{\"41\":2}}],[\"rxy\",{\"1\":{\"77\":1}}],[\"ring\",{\"1\":{\"181\":2}}],[\"rice\",{\"1\":{\"181\":2}}],[\"right时返回\",{\"1\":{\"767\":1}}],[\"right不为空\",{\"1\":{\"755\":1}}],[\"right都不为空\",{\"1\":{\"755\":1}}],[\"rightnodes\",{\"1\":{\"713\":2}}],[\"rightcontent\",{\"1\":{\"596\":1}}],[\"rightsideview\",{\"1\":{\"736\":1,\"737\":1}}],[\"rights\",{\"1\":{\"174\":4}}],[\"right\",{\"1\":{\"134\":2,\"140\":4,\"174\":10,\"187\":3,\"588\":1,\"710\":1,\"713\":2,\"723\":1,\"724\":6,\"725\":2,\"736\":1,\"737\":2,\"743\":2,\"748\":1,\"749\":2,\"755\":4,\"761\":1,\"766\":1,\"767\":10,\"777\":5,\"778\":6,\"809\":3,\"815\":1,\"833\":1,\"834\":7,\"852\":6,\"864\":2,\"882\":1,\"899\":5,\"900\":1,\"901\":4,\"945\":1,\"1267\":1}}],[\"rightb\",{\"1\":{\"71\":2}}],[\"rides\",{\"1\":{\"65\":3}}],[\"ri​\",{\"1\":{\"65\":1,\"168\":3}}],[\"r\",{\"1\":{\"65\":1,\"66\":9,\"77\":1,\"97\":5,\"157\":5,\"162\":4,\"173\":5,\"174\":26,\"206\":8,\"224\":1,\"246\":1,\"261\":8,\"263\":15,\"302\":6,\"317\":8,\"318\":8,\"320\":1,\"321\":7,\"322\":7,\"323\":6,\"325\":4,\"330\":1,\"332\":2,\"334\":2,\"341\":5,\"342\":7,\"385\":12,\"404\":10,\"421\":4,\"427\":8,\"428\":10,\"429\":4,\"430\":12,\"431\":10,\"748\":2,\"761\":3,\"815\":4,\"852\":10,\"864\":2,\"899\":4,\"1069\":1,\"1081\":2,\"1114\":1,\"1242\":3,\"1316\":1,\"1418\":3,\"1510\":3}}],[\"roll\",{\"1\":{\"1090\":1,\"1359\":1}}],[\"rollback\",{\"1\":{\"954\":1}}],[\"role2\",{\"1\":{\"457\":1}}],[\"role1\",{\"1\":{\"457\":1}}],[\"role以\",{\"1\":{\"129\":1}}],[\"role\",{\"1\":{\"129\":20,\"471\":5,\"525\":1,\"526\":1,\"578\":1,\"580\":2,\"1031\":1,\"1032\":1}}],[\"rob\",{\"1\":{\"827\":1,\"828\":2}}],[\"robots\",{\"1\":{\"543\":1}}],[\"routes\",{\"1\":{\"559\":1,\"592\":2}}],[\"routervo\",{\"1\":{\"462\":1}}],[\"router\",{\"1\":{\"453\":1,\"459\":1,\"463\":1,\"537\":1,\"540\":1}}],[\"routing\",{\"1\":{\"542\":1}}],[\"round++\",{\"1\":{\"99\":1}}],[\"round\",{\"1\":{\"99\":2,\"1080\":1}}],[\"rocks\",{\"1\":{\"56\":1}}],[\"rows\",{\"1\":{\"935\":1}}],[\"rowkey=\",{\"1\":{\"592\":1}}],[\"row\",{\"1\":{\"56\":1,\"795\":2,\"1001\":2}}],[\"rootinindex\",{\"1\":{\"767\":6}}],[\"rootindex\",{\"1\":{\"767\":4}}],[\"rootpreindex\",{\"1\":{\"767\":7}}],[\"rootlayout\",{\"1\":{\"540\":2,\"548\":1}}],[\"root\",{\"1\":{\"56\":3,\"133\":3,\"186\":2,\"187\":5,\"314\":5,\"672\":1,\"709\":1,\"710\":7,\"713\":9,\"717\":1,\"723\":1,\"724\":10,\"725\":7,\"729\":1,\"736\":7,\"737\":3,\"741\":1,\"743\":3,\"747\":1,\"748\":4,\"749\":3,\"755\":8,\"759\":1,\"761\":6,\"766\":3,\"767\":11,\"802\":2,\"807\":1,\"809\":3,\"815\":4,\"862\":1,\"864\":10,\"880\":1,\"881\":1,\"882\":7,\"898\":1,\"899\":3,\"900\":6,\"901\":2,\"1087\":4,\"1267\":1}}],[\"root=\",{\"1\":{\"30\":1}}],[\"root=0\",{\"1\":{\"30\":1}}],[\"reject\",{\"1\":{\"1359\":3,\"1370\":1}}],[\"rejectedexecutionexception\",{\"1\":{\"1359\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"1359\":2,\"1366\":2}}],[\"rehashing\",{\"1\":{\"1316\":1,\"1317\":1}}],[\"rehash\",{\"1\":{\"1306\":1,\"1314\":1,\"1316\":1,\"1317\":1}}],[\"reports\",{\"1\":{\"1496\":1}}],[\"reportinterruptafterwait\",{\"1\":{\"1251\":2}}],[\"represented\",{\"1\":{\"1275\":1}}],[\"replicas\",{\"1\":{\"1192\":2,\"1194\":3}}],[\"replicator\",{\"1\":{\"1184\":1}}],[\"replacesateleentry\",{\"1\":{\"1315\":1}}],[\"replacestaleentry\",{\"0\":{\"1317\":1},\"1\":{\"1306\":3,\"1314\":2,\"1315\":1,\"1317\":4}}],[\"replaceall\",{\"1\":{\"1081\":1}}],[\"replace\",{\"1\":{\"1005\":2,\"1069\":1,\"1306\":1,\"1314\":1}}],[\"reply\",{\"0\":{\"25\":1,\"26\":1,\"27\":1,\"28\":1},\"1\":{\"25\":1,\"27\":1,\"28\":5,\"30\":6,\"31\":5,\"37\":1}}],[\"reinterrupt\",{\"1\":{\"1251\":1}}],[\"re\",{\"1\":{\"1191\":1,\"1283\":1}}],[\"rechecking\",{\"1\":{\"1511\":1}}],[\"recheck\",{\"1\":{\"1244\":1,\"1274\":1,\"1359\":4,\"1511\":1}}],[\"recentregisteredqueue\",{\"1\":{\"1160\":1}}],[\"recentcanceledqueue\",{\"1\":{\"1160\":1}}],[\"record\",{\"1\":{\"592\":5}}],[\"recommended\",{\"1\":{\"539\":1}}],[\"reexecuteperiodic\",{\"1\":{\"1368\":2}}],[\"reentreadwritelocks\",{\"1\":{\"1258\":1}}],[\"reentrantwritereadlock源码中\",{\"1\":{\"1244\":1}}],[\"reentrant\",{\"1\":{\"1239\":2,\"1242\":2}}],[\"reentrantreadwritelock\",{\"0\":{\"1236\":1},\"1\":{\"1237\":1,\"1290\":2}}],[\"reentrantlock\",{\"0\":{\"1230\":1},\"1\":{\"643\":1,\"1061\":3,\"1231\":4,\"1232\":2,\"1233\":5,\"1237\":1,\"1240\":1,\"1254\":2,\"1258\":1,\"1264\":3,\"1276\":1,\"1294\":2,\"1346\":3,\"1347\":1,\"1348\":1,\"1350\":4,\"1351\":1,\"1352\":1,\"1369\":2,\"1410\":2,\"1492\":1,\"1493\":4,\"1495\":1}}],[\"reed\",{\"1\":{\"1095\":1}}],[\"renewals\",{\"1\":{\"1191\":2}}],[\"renews\",{\"1\":{\"1190\":2}}],[\"rename\",{\"1\":{\"922\":1}}],[\"render\",{\"1\":{\"592\":2}}],[\"rendering\",{\"1\":{\"531\":2}}],[\"rend\",{\"1\":{\"141\":1}}],[\"releasing\",{\"1\":{\"1243\":1,\"1244\":1}}],[\"release\",{\"0\":{\"1506\":1},\"1\":{\"670\":1,\"1087\":1,\"1089\":1,\"1244\":1,\"1251\":2,\"1319\":1,\"1398\":4,\"1496\":1,\"1500\":1,\"1505\":1,\"1506\":1,\"1511\":2}}],[\"releaseshared\",{\"0\":{\"1511\":1},\"1\":{\"1500\":1,\"1511\":2}}],[\"releases\",{\"1\":{\"665\":3,\"1090\":1,\"1232\":2,\"1240\":3,\"1408\":1,\"1496\":3,\"1511\":1}}],[\"reload\",{\"1\":{\"592\":1,\"663\":1,\"671\":1}}],[\"rel=\",{\"1\":{\"588\":1,\"592\":1}}],[\"required\",{\"1\":{\"587\":3}}],[\"request<record<string\",{\"1\":{\"596\":1}}],[\"request<api\",{\"1\":{\"589\":1}}],[\"request=\",{\"1\":{\"592\":1}}],[\"requestconfig\",{\"1\":{\"585\":1}}],[\"requestmapping\",{\"1\":{\"576\":2}}],[\"requestbody\",{\"1\":{\"481\":1,\"482\":1,\"525\":1,\"526\":2,\"576\":2,\"579\":1}}],[\"request\",{\"1\":{\"448\":1,\"523\":3,\"526\":3,\"557\":1,\"575\":3,\"576\":4,\"578\":5,\"579\":3,\"585\":2,\"589\":3,\"596\":7,\"1170\":1}}],[\"refs\",{\"1\":{\"1317\":1}}],[\"ref\",{\"1\":{\"1305\":1}}],[\"reflection\",{\"1\":{\"1132\":1}}],[\"reflect\",{\"1\":{\"1055\":7}}],[\"referencedemo\",{\"1\":{\"1478\":5}}],[\"references\",{\"1\":{\"937\":2}}],[\"reference\",{\"1\":{\"543\":1,\"1319\":1,\"1330\":1,\"1387\":4}}],[\"refid=\",{\"1\":{\"471\":1}}],[\"red\",{\"1\":{\"1029\":1,\"1267\":2}}],[\"redirect\",{\"1\":{\"587\":1,\"589\":1,\"672\":1}}],[\"redisbloom\",{\"1\":{\"613\":1}}],[\"redission\",{\"1\":{\"500\":1}}],[\"redis\",{\"1\":{\"31\":4,\"40\":3,\"46\":1,\"58\":3,\"493\":1,\"500\":1,\"613\":6,\"634\":1}}],[\"redux\",{\"1\":{\"499\":1}}],[\"remark\",{\"1\":{\"471\":2,\"566\":2,\"589\":1}}],[\"rememberme\",{\"1\":{\"446\":1}}],[\"removals\",{\"1\":{\"1275\":1}}],[\"removed\",{\"1\":{\"1284\":1,\"1315\":4}}],[\"removeexpire\",{\"1\":{\"1210\":1}}],[\"removeeldestentry\",{\"1\":{\"688\":2}}],[\"removeif\",{\"1\":{\"1201\":1}}],[\"removeobjectargs\",{\"1\":{\"1103\":1}}],[\"removeobject\",{\"1\":{\"1103\":2}}],[\"removebucketargs\",{\"1\":{\"1102\":1}}],[\"removebucket\",{\"1\":{\"1102\":2}}],[\"removebyid\",{\"1\":{\"579\":1}}],[\"removenthfromend\",{\"1\":{\"778\":1}}],[\"removeattribute\",{\"1\":{\"596\":1}}],[\"removequestionbankquestion\",{\"1\":{\"526\":1}}],[\"remove\",{\"0\":{\"1303\":1,\"1308\":1},\"1\":{\"129\":5,\"403\":2,\"404\":1,\"526\":2,\"559\":1,\"687\":2,\"1038\":1,\"1039\":1,\"1040\":1,\"1072\":2,\"1073\":1,\"1076\":1,\"1201\":2,\"1210\":1,\"1243\":1,\"1303\":2,\"1304\":2,\"1308\":2,\"1309\":1,\"1317\":5,\"1318\":1,\"1320\":1,\"1325\":1,\"1346\":1,\"1359\":1,\"1370\":1,\"1407\":3,\"1409\":1,\"1410\":1}}],[\"remote\",{\"1\":{\"61\":1}}],[\"reversekgroup\",{\"1\":{\"681\":2,\"682\":2}}],[\"reverse\",{\"1\":{\"224\":1,\"330\":1,\"423\":4,\"682\":2,\"1005\":1}}],[\"reverseorder\",{\"1\":{\"129\":1,\"1038\":1,\"1067\":1,\"1078\":1}}],[\"reacquires\",{\"1\":{\"1408\":1}}],[\"reachable\",{\"1\":{\"1283\":1}}],[\"reactnode\",{\"1\":{\"548\":1}}],[\"react\",{\"1\":{\"499\":1,\"538\":1,\"540\":5,\"545\":1,\"548\":1,\"549\":2,\"557\":1,\"587\":1,\"592\":1}}],[\"real\",{\"1\":{\"221\":1,\"1350\":1}}],[\"readobject\",{\"1\":{\"1496\":1}}],[\"readonly\",{\"1\":{\"1114\":2}}],[\"readonly<\",{\"1\":{\"548\":1}}],[\"reader\",{\"1\":{\"1267\":1,\"1432\":1,\"1455\":2,\"1456\":1,\"1475\":2,\"1476\":2,\"1478\":2}}],[\"readers\",{\"1\":{\"1243\":1}}],[\"readershouldblock\",{\"1\":{\"1242\":1}}],[\"readholds\",{\"1\":{\"1242\":2,\"1243\":2}}],[\"readlock\",{\"1\":{\"1237\":4,\"1244\":4}}],[\"readline\",{\"1\":{\"128\":2,\"157\":2,\"182\":1,\"981\":1,\"1049\":1}}],[\"read\",{\"1\":{\"41\":1,\"48\":1,\"1239\":1,\"1243\":2,\"1244\":3,\"1267\":1,\"1283\":1,\"1475\":1,\"1482\":7}}],[\"regex\",{\"1\":{\"1005\":1,\"1069\":1}}],[\"regexmatcher\",{\"1\":{\"127\":1}}],[\"regeneration\",{\"1\":{\"534\":1}}],[\"registered\",{\"1\":{\"1193\":1,\"1194\":1,\"1196\":1}}],[\"registeredaccounts\",{\"1\":{\"88\":3}}],[\"registerallstats\",{\"1\":{\"1168\":1}}],[\"registermessage\",{\"1\":{\"587\":4}}],[\"registerparams\",{\"1\":{\"587\":1}}],[\"register\",{\"1\":{\"446\":1,\"576\":1,\"587\":4,\"588\":1,\"591\":1,\"1158\":2,\"1184\":4}}],[\"registrycount\",{\"1\":{\"1167\":1}}],[\"registry\",{\"1\":{\"446\":2,\"538\":2,\"540\":2,\"1158\":2,\"1160\":1,\"1162\":1,\"1163\":1,\"1165\":2,\"1167\":1}}],[\"registrationclient\",{\"1\":{\"1184\":3}}],[\"registration\",{\"1\":{\"88\":3}}],[\"retry\",{\"1\":{\"1242\":1,\"1505\":2}}],[\"retrun\",{\"1\":{\"76\":1}}],[\"retention\",{\"1\":{\"1053\":1}}],[\"ret\",{\"1\":{\"206\":4,\"255\":2}}],[\"returning\",{\"1\":{\"1359\":1}}],[\"returned\",{\"1\":{\"1275\":1}}],[\"returns\",{\"1\":{\"1270\":1,\"1275\":1,\"1306\":1}}],[\"return\",{\"0\":{\"1019\":1},\"1\":{\"65\":1,\"66\":1,\"70\":1,\"71\":1,\"72\":1,\"77\":1,\"82\":1,\"83\":7,\"87\":1,\"92\":1,\"93\":3,\"99\":1,\"108\":1,\"109\":1,\"110\":1,\"114\":1,\"115\":1,\"121\":2,\"127\":1,\"128\":1,\"129\":2,\"133\":2,\"134\":3,\"135\":1,\"139\":4,\"140\":2,\"141\":2,\"142\":2,\"146\":1,\"147\":1,\"152\":1,\"157\":3,\"162\":1,\"167\":3,\"172\":1,\"173\":2,\"174\":2,\"179\":1,\"180\":2,\"182\":1,\"187\":5,\"194\":1,\"197\":3,\"200\":1,\"203\":5,\"206\":3,\"218\":1,\"219\":1,\"220\":1,\"223\":3,\"224\":3,\"228\":3,\"229\":2,\"230\":3,\"235\":2,\"236\":3,\"237\":3,\"245\":1,\"246\":1,\"247\":1,\"250\":1,\"255\":1,\"261\":1,\"262\":2,\"263\":1,\"270\":3,\"273\":3,\"274\":6,\"278\":2,\"279\":3,\"281\":2,\"287\":2,\"288\":2,\"289\":3,\"290\":3,\"291\":7,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":2,\"306\":1,\"307\":1,\"309\":6,\"311\":1,\"312\":1,\"314\":2,\"317\":1,\"318\":1,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"327\":2,\"328\":5,\"329\":2,\"330\":2,\"339\":3,\"341\":1,\"345\":1,\"349\":1,\"352\":3,\"353\":2,\"354\":2,\"355\":2,\"356\":2,\"360\":2,\"361\":5,\"362\":5,\"363\":2,\"367\":3,\"369\":4,\"375\":1,\"376\":1,\"377\":2,\"379\":1,\"381\":1,\"383\":2,\"384\":5,\"385\":3,\"388\":1,\"389\":6,\"390\":2,\"392\":1,\"394\":1,\"411\":1,\"412\":2,\"414\":1,\"415\":1,\"416\":1,\"419\":2,\"420\":1,\"421\":1,\"423\":2,\"427\":2,\"428\":2,\"429\":2,\"430\":2,\"431\":1,\"446\":3,\"465\":1,\"468\":1,\"471\":2,\"481\":7,\"482\":1,\"523\":2,\"525\":3,\"526\":4,\"542\":1,\"548\":1,\"549\":2,\"568\":9,\"575\":10,\"576\":8,\"578\":5,\"579\":4,\"587\":6,\"589\":5,\"591\":4,\"592\":5,\"596\":6,\"682\":4,\"687\":3,\"688\":2,\"694\":2,\"700\":1,\"705\":1,\"710\":3,\"713\":5,\"725\":1,\"736\":2,\"737\":2,\"743\":2,\"748\":2,\"749\":2,\"755\":4,\"761\":3,\"767\":7,\"772\":2,\"778\":1,\"783\":1,\"784\":4,\"789\":2,\"795\":5,\"796\":1,\"797\":1,\"803\":4,\"809\":3,\"815\":3,\"820\":3,\"821\":1,\"822\":3,\"827\":4,\"828\":2,\"834\":2,\"840\":1,\"845\":1,\"846\":2,\"851\":1,\"852\":4,\"857\":1,\"864\":2,\"870\":2,\"875\":1,\"876\":2,\"882\":3,\"887\":2,\"888\":1,\"893\":1,\"894\":2,\"899\":3,\"900\":3,\"901\":4,\"1010\":2,\"1011\":1,\"1014\":2,\"1019\":4,\"1020\":6,\"1021\":5,\"1022\":4,\"1023\":2,\"1027\":3,\"1028\":1,\"1033\":1,\"1034\":1,\"1055\":1,\"1078\":1,\"1100\":1,\"1145\":1,\"1150\":1,\"1164\":2,\"1201\":4,\"1207\":2,\"1210\":6,\"1232\":4,\"1233\":3,\"1239\":6,\"1240\":1,\"1242\":3,\"1243\":1,\"1251\":2,\"1252\":2,\"1264\":1,\"1268\":2,\"1270\":1,\"1271\":1,\"1272\":4,\"1273\":4,\"1274\":3,\"1275\":6,\"1282\":2,\"1283\":3,\"1284\":3,\"1293\":3,\"1294\":1,\"1301\":1,\"1302\":4,\"1306\":3,\"1307\":4,\"1308\":1,\"1314\":2,\"1315\":2,\"1316\":2,\"1317\":4,\"1330\":1,\"1348\":2,\"1352\":1,\"1359\":1,\"1368\":1,\"1370\":1,\"1385\":2,\"1387\":1,\"1388\":1,\"1467\":1,\"1475\":1,\"1485\":1,\"1495\":1,\"1496\":10,\"1504\":5,\"1505\":4,\"1506\":2,\"1507\":1,\"1508\":4,\"1510\":1,\"1511\":2}}],[\"resizing\",{\"1\":{\"1275\":1}}],[\"resized\",{\"1\":{\"1305\":1}}],[\"resizers\",{\"1\":{\"1275\":1}}],[\"resizestamp\",{\"1\":{\"1274\":1,\"1275\":1}}],[\"resize\",{\"1\":{\"174\":3,\"243\":2,\"1274\":1,\"1275\":2,\"1276\":2,\"1306\":4,\"1307\":1}}],[\"resync\",{\"1\":{\"1252\":1}}],[\"response\",{\"1\":{\"1184\":1}}],[\"resolve\",{\"1\":{\"592\":2}}],[\"resourcepoolsbuilder\",{\"1\":{\"1211\":1}}],[\"resourcebuilder\",{\"1\":{\"1184\":1}}],[\"resourceloader\",{\"0\":{\"1136\":1},\"1\":{\"1136\":2,\"1140\":1}}],[\"resource\",{\"0\":{\"1135\":1},\"1\":{\"526\":2,\"568\":1,\"576\":1,\"1049\":1,\"1100\":1,\"1102\":1,\"1135\":2,\"1140\":1,\"1221\":13}}],[\"resources\",{\"0\":{\"1049\":1},\"1\":{\"446\":1,\"1319\":1}}],[\"restartfromhead\",{\"1\":{\"1284\":4}}],[\"restart\",{\"1\":{\"671\":1}}],[\"restartsec=5s\",{\"1\":{\"671\":1}}],[\"restart=on\",{\"1\":{\"671\":1}}],[\"restcontroller\",{\"1\":{\"576\":2}}],[\"restful\",{\"1\":{\"576\":2,\"1184\":1}}],[\"restful接口等能力\",{\"1\":{\"557\":1}}],[\"reset\",{\"1\":{\"422\":1,\"1393\":1,\"1496\":1,\"1511\":1}}],[\"res++\",{\"1\":{\"305\":1,\"339\":1,\"363\":1,\"428\":1,\"430\":1,\"749\":1,\"820\":1,\"821\":1,\"822\":1}}],[\"resultutils\",{\"1\":{\"523\":1,\"525\":1,\"526\":2}}],[\"resultmap=\",{\"1\":{\"471\":1}}],[\"result\",{\"1\":{\"70\":1,\"128\":8,\"139\":4,\"142\":2,\"167\":2,\"471\":1,\"526\":4,\"567\":2,\"568\":16,\"1302\":2,\"1330\":3,\"1386\":2,\"1429\":1,\"1449\":1}}],[\"res\",{\"1\":{\"70\":2,\"71\":2,\"77\":14,\"82\":6,\"83\":2,\"87\":6,\"92\":8,\"98\":4,\"103\":3,\"104\":2,\"108\":3,\"133\":4,\"161\":4,\"162\":3,\"194\":4,\"224\":8,\"230\":4,\"244\":2,\"245\":7,\"261\":5,\"262\":3,\"263\":4,\"290\":4,\"304\":4,\"305\":2,\"339\":2,\"340\":2,\"342\":4,\"360\":3,\"361\":3,\"363\":1,\"369\":7,\"375\":6,\"376\":4,\"379\":6,\"381\":4,\"388\":4,\"389\":4,\"390\":7,\"392\":4,\"394\":3,\"428\":2,\"430\":4,\"737\":3,\"749\":2,\"784\":7,\"820\":2,\"821\":2,\"822\":4,\"827\":3,\"893\":4,\"1010\":4,\"1011\":5,\"1055\":2}}],[\"rebuild\",{\"1\":{\"48\":2,\"60\":2}}],[\"our\",{\"1\":{\"1496\":1}}],[\"outofmemoryerror\",{\"1\":{\"1042\":1}}],[\"outertask\",{\"1\":{\"1368\":2}}],[\"outer\",{\"1\":{\"945\":2}}],[\"outlogin\",{\"1\":{\"596\":2}}],[\"outputstreamwriter\",{\"1\":{\"982\":2}}],[\"output\",{\"1\":{\"249\":1,\"1049\":1}}],[\"out\",{\"1\":{\"82\":2,\"83\":1,\"87\":1,\"88\":4,\"97\":2,\"98\":1,\"99\":2,\"103\":1,\"104\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"157\":1,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":2,\"249\":1,\"410\":1,\"467\":2,\"567\":1,\"980\":9,\"981\":1,\"982\":7,\"984\":30,\"985\":5,\"986\":1,\"988\":4,\"989\":2,\"990\":4,\"992\":2,\"993\":1,\"994\":3,\"999\":5,\"1000\":2,\"1001\":2,\"1004\":5,\"1005\":2,\"1006\":2,\"1007\":2,\"1011\":1,\"1014\":2,\"1015\":3,\"1017\":1,\"1018\":2,\"1020\":1,\"1021\":1,\"1022\":4,\"1023\":1,\"1029\":2,\"1033\":3,\"1034\":3,\"1047\":3,\"1048\":2,\"1049\":2,\"1055\":3,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":1,\"1069\":2,\"1102\":3,\"1103\":6,\"1201\":2,\"1204\":2,\"1207\":2,\"1211\":2,\"1221\":4,\"1251\":1,\"1254\":2,\"1260\":1,\"1284\":2,\"1309\":1,\"1317\":1,\"1319\":1,\"1330\":3,\"1336\":2,\"1337\":1,\"1340\":2,\"1351\":1,\"1385\":2,\"1386\":2,\"1387\":2,\"1388\":2,\"1392\":5,\"1393\":4,\"1398\":4,\"1399\":3,\"1406\":12,\"1407\":10,\"1409\":6,\"1410\":6,\"1411\":2,\"1429\":1,\"1449\":1,\"1467\":1,\"1482\":1}}],[\"occurs\",{\"1\":{\"1317\":1}}],[\"occurred\",{\"1\":{\"1170\":1}}],[\"ok\",{\"1\":{\"1283\":1,\"1506\":1}}],[\"okay\",{\"1\":{\"1149\":1}}],[\"os\",{\"1\":{\"1259\":2}}],[\"oss\",{\"1\":{\"1094\":3}}],[\"otherwise\",{\"1\":{\"1239\":1,\"1242\":1,\"1496\":2}}],[\"other\",{\"1\":{\"1149\":1,\"1191\":2,\"1316\":1,\"1317\":3,\"1351\":4,\"1511\":2}}],[\"others\",{\"1\":{\"694\":2}}],[\"over\",{\"1\":{\"1505\":1}}],[\"overflow\",{\"1\":{\"1232\":1}}],[\"overload\",{\"1\":{\"1052\":1}}],[\"override\",{\"1\":{\"446\":3,\"526\":1,\"568\":1,\"575\":2,\"596\":1,\"688\":1,\"1052\":1,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":1,\"1078\":1,\"1145\":1,\"1150\":1,\"1210\":3,\"1221\":2,\"1254\":2,\"1309\":1,\"1330\":3,\"1336\":2,\"1337\":1,\"1340\":1,\"1387\":1,\"1388\":1,\"1406\":4,\"1407\":4,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1467\":1,\"1482\":1}}],[\"oauth\",{\"1\":{\"646\":2}}],[\"oauth2\",{\"1\":{\"445\":1}}],[\"one\",{\"1\":{\"1350\":1}}],[\"ones\",{\"1\":{\"1306\":1,\"1314\":1,\"1359\":1}}],[\"oneapi\",{\"1\":{\"559\":2}}],[\"onto\",{\"1\":{\"1252\":1}}],[\"onlyifabsent\",{\"1\":{\"1272\":5}}],[\"only\",{\"1\":{\"1239\":1,\"1292\":1,\"1351\":1}}],[\"ondemandupdate\",{\"1\":{\"1158\":1}}],[\"onpath\",{\"1\":{\"875\":2,\"876\":5}}],[\"onpagechange\",{\"1\":{\"587\":1}}],[\"onselect=\",{\"1\":{\"592\":1}}],[\"onchange\",{\"1\":{\"592\":2}}],[\"onchange=\",{\"1\":{\"587\":1}}],[\"onclick=\",{\"1\":{\"592\":1}}],[\"onfinish=\",{\"1\":{\"587\":1}}],[\"on\",{\"1\":{\"471\":2,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"525\":1,\"664\":1,\"672\":1,\"944\":1,\"945\":2,\"959\":2,\"1243\":1,\"1259\":2,\"1291\":1,\"1317\":1,\"1408\":1,\"1504\":1,\"1511\":1}}],[\"o→o→o→o→o→o→o\",{\"1\":{\"221\":1}}],[\"o→o→o\",{\"1\":{\"221\":1}}],[\"oldlen\",{\"1\":{\"1306\":3}}],[\"oldtab\",{\"1\":{\"1306\":3}}],[\"oldval\",{\"1\":{\"1272\":9}}],[\"oldvalue\",{\"1\":{\"1081\":1,\"1210\":1,\"1388\":2}}],[\"oldregex\",{\"1\":{\"1005\":1}}],[\"oldchar\",{\"1\":{\"1005\":1,\"1069\":1}}],[\"oldestkey\",{\"1\":{\"687\":2}}],[\"oldscore\",{\"1\":{\"129\":5}}],[\"olap\",{\"0\":{\"439\":1},\"1\":{\"439\":1,\"644\":1}}],[\"oltp\",{\"0\":{\"439\":1},\"1\":{\"50\":1,\"439\":1}}],[\"oddchoices\",{\"1\":{\"87\":2}}],[\"oddcount\",{\"1\":{\"87\":2}}],[\"optional\",{\"1\":{\"1210\":2}}],[\"option\",{\"1\":{\"592\":2}}],[\"options=\",{\"1\":{\"592\":1}}],[\"options\",{\"1\":{\"589\":2,\"596\":2}}],[\"optimizing\",{\"1\":{\"543\":1}}],[\"opt\",{\"1\":{\"255\":2,\"1087\":4}}],[\"operating\",{\"0\":{\"1539\":1}}],[\"operation\",{\"1\":{\"129\":8,\"338\":1,\"526\":1}}],[\"operate\",{\"1\":{\"1074\":2}}],[\"operator\",{\"1\":{\"423\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1}}],[\"operator<\",{\"1\":{\"361\":1}}],[\"openapi\",{\"1\":{\"499\":1}}],[\"open\",{\"1\":{\"215\":9,\"971\":1,\"1306\":1}}],[\"opi∈0\",{\"1\":{\"103\":1}}],[\"opi​=0时放到其前\",{\"1\":{\"103\":1}}],[\"opq​\",{\"1\":{\"103\":1}}],[\"op2​\",{\"1\":{\"103\":1}}],[\"op1​\",{\"1\":{\"103\":1}}],[\"op\",{\"1\":{\"77\":7,\"83\":15,\"103\":2,\"224\":2}}],[\"owner\",{\"1\":{\"60\":1,\"1239\":2}}],[\"o\",{\"1\":{\"58\":2,\"129\":3,\"134\":4,\"168\":1,\"324\":1,\"346\":1,\"349\":1,\"351\":5,\"352\":1,\"353\":1,\"354\":1,\"355\":2,\"356\":1,\"360\":1,\"361\":3,\"362\":1,\"363\":1,\"367\":1,\"368\":2,\"369\":3,\"371\":1,\"373\":1,\"377\":1,\"381\":1,\"385\":1,\"417\":1,\"422\":4,\"686\":1,\"687\":1,\"723\":1,\"724\":2,\"833\":2,\"850\":1,\"851\":2,\"852\":3,\"972\":1,\"1055\":6,\"1067\":1,\"1069\":14,\"1070\":4,\"1072\":6,\"1073\":4,\"1074\":9,\"1075\":6,\"1076\":5,\"1077\":6,\"1078\":3,\"1081\":1,\"1266\":3,\"1272\":1,\"1325\":1,\"1369\":1,\"1383\":6,\"1437\":6}}],[\"oome\",{\"1\":{\"1274\":1}}],[\"oom\",{\"1\":{\"48\":1}}],[\"often\",{\"1\":{\"1306\":1,\"1314\":1}}],[\"ofnanos\",{\"1\":{\"1210\":1}}],[\"ofnullable\",{\"1\":{\"1210\":2}}],[\"ofseconds\",{\"1\":{\"1201\":1,\"1211\":1}}],[\"of\",{\"1\":{\"47\":1,\"737\":1,\"743\":1,\"1129\":1,\"1131\":1,\"1191\":2,\"1194\":1,\"1242\":1,\"1250\":2,\"1252\":1,\"1270\":1,\"1275\":5,\"1283\":1,\"1305\":1,\"1306\":2,\"1315\":2,\"1316\":2,\"1317\":3,\"1319\":2,\"1346\":1,\"1350\":4,\"1351\":1,\"1504\":1,\"1506\":1,\"1511\":3}}],[\"off\",{\"1\":{\"672\":1,\"1191\":2,\"1272\":1,\"1283\":2,\"1291\":1}}],[\"offset\",{\"1\":{\"40\":2,\"72\":3}}],[\"offerlast\",{\"1\":{\"1077\":1}}],[\"offerfirst\",{\"1\":{\"1077\":1}}],[\"offer\",{\"0\":{\"5\":1,\"1283\":1,\"1285\":2,\"1517\":1},\"1\":{\"180\":2,\"634\":1,\"655\":1,\"737\":3,\"743\":3,\"821\":2,\"870\":2,\"1076\":1,\"1078\":1,\"1283\":38,\"1284\":6,\"1285\":7,\"1286\":1,\"1325\":2,\"1346\":1,\"1350\":1,\"1359\":1},\"2\":{\"67\":1,\"73\":1,\"79\":1,\"84\":1,\"89\":1,\"94\":1,\"100\":1,\"105\":1,\"111\":1,\"116\":1,\"123\":1,\"130\":1,\"136\":1,\"143\":1,\"148\":1,\"153\":1,\"158\":1,\"163\":1,\"169\":1,\"175\":1,\"183\":1}}],[\"orelse\",{\"1\":{\"1210\":2}}],[\"or\",{\"1\":{\"931\":1,\"1149\":1,\"1239\":2,\"1242\":2,\"1252\":1,\"1275\":2,\"1315\":1,\"1317\":3,\"1346\":2,\"1351\":1,\"1359\":3,\"1408\":1,\"1505\":1,\"1506\":2}}],[\"orangesrotting\",{\"1\":{\"870\":2}}],[\"originuser\",{\"1\":{\"575\":14}}],[\"originallist\",{\"1\":{\"114\":2}}],[\"org\",{\"1\":{\"41\":2,\"446\":15,\"526\":1,\"537\":1,\"538\":1,\"539\":1,\"542\":1,\"543\":2,\"568\":1,\"671\":1,\"1055\":3,\"1063\":1,\"1086\":1,\"1087\":1,\"1093\":1,\"1095\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":1,\"1139\":1,\"1140\":3}}],[\"orderservice\",{\"1\":{\"465\":1}}],[\"orderid\",{\"1\":{\"114\":5}}],[\"order\",{\"1\":{\"30\":2,\"31\":1,\"40\":2,\"56\":2,\"181\":1,\"465\":6,\"929\":2,\"934\":1,\"1317\":1}}],[\"objectinputstream\",{\"1\":{\"1496\":1}}],[\"object>\",{\"1\":{\"1211\":1}}],[\"objectname\",{\"1\":{\"1103\":1}}],[\"objectwriteresponse2\",{\"1\":{\"1103\":1}}],[\"objectwriteresponse\",{\"1\":{\"1103\":5}}],[\"object\",{\"0\":{\"1103\":1},\"1\":{\"1045\":1,\"1055\":2,\"1063\":14,\"1094\":1,\"1100\":3,\"1103\":6,\"1201\":5,\"1221\":2,\"1248\":9,\"1250\":2,\"1259\":10,\"1273\":1,\"1292\":1,\"1293\":2,\"1294\":2,\"1295\":2,\"1305\":3,\"1306\":2,\"1314\":1,\"1317\":1,\"1325\":1,\"1334\":2,\"1338\":4,\"1346\":2,\"1347\":1,\"1348\":1,\"1402\":1,\"1404\":1,\"1408\":1,\"1410\":1,\"1431\":3,\"1469\":1,\"1472\":1,\"1496\":1}}],[\"obj\",{\"1\":{\"30\":6,\"56\":6}}],[\"wc\",{\"1\":{\"1370\":3}}],[\"ws\",{\"1\":{\"1252\":3,\"1505\":5,\"1506\":3,\"1511\":3}}],[\"would\",{\"1\":{\"1239\":1,\"1306\":1,\"1314\":1,\"1359\":1}}],[\"worst\",{\"1\":{\"1306\":1}}],[\"workqueue\",{\"1\":{\"1359\":6}}],[\"works\",{\"1\":{\"1351\":1}}],[\"work\",{\"0\":{\"1544\":1},\"1\":{\"1062\":2,\"1315\":1,\"1371\":1,\"1496\":1}}],[\"worker类\",{\"1\":{\"1371\":1}}],[\"workercountof\",{\"1\":{\"1359\":2,\"1370\":1}}],[\"workercount\",{\"1\":{\"1359\":1}}],[\"worker2\",{\"1\":{\"1059\":5,\"1061\":3,\"1062\":6}}],[\"worker1\",{\"1\":{\"1059\":5,\"1061\":3,\"1062\":6}}],[\"worker\",{\"1\":{\"1059\":5,\"1061\":6,\"1062\":13,\"1063\":12,\"1370\":2,\"1371\":2}}],[\"workingdirectory=\",{\"1\":{\"671\":1}}],[\"word\",{\"1\":{\"783\":4,\"801\":5,\"803\":8,\"1440\":5,\"1442\":2,\"1443\":1,\"1446\":3,\"1447\":1}}],[\"wordbreak\",{\"1\":{\"783\":1,\"784\":1}}],[\"worddict\",{\"1\":{\"782\":1,\"783\":5,\"784\":6}}],[\"world\",{\"1\":{\"98\":2,\"982\":2,\"1005\":4,\"1007\":1,\"1014\":1,\"1018\":1,\"1107\":5,\"1109\":1,\"1275\":1}}],[\"wget\",{\"1\":{\"1087\":1}}],[\"well\",{\"1\":{\"1315\":1}}],[\"weighting\",{\"1\":{\"1315\":1}}],[\"weakreferenece\",{\"1\":{\"1305\":1}}],[\"weakreference\",{\"1\":{\"1305\":1}}],[\"weakreference<threadlocal<\",{\"1\":{\"1305\":1}}],[\"we\",{\"1\":{\"1074\":2,\"1244\":1,\"1283\":2,\"1306\":1,\"1314\":1,\"1316\":2,\"1317\":4,\"1351\":1,\"1359\":7,\"1496\":1,\"1505\":1,\"1511\":3}}],[\"wednesday\",{\"1\":{\"986\":1}}],[\"webdav\",{\"0\":{\"673\":1,\"674\":1,\"675\":1,\"676\":1},\"1\":{\"669\":1,\"670\":1,\"674\":3,\"675\":7,\"676\":1}}],[\"webstorm\",{\"1\":{\"538\":1,\"539\":1,\"559\":1}}],[\"websecurityconfigureradapter\",{\"1\":{\"446\":2}}],[\"webjars\",{\"1\":{\"446\":1}}],[\"web\",{\"1\":{\"446\":7,\"450\":1,\"451\":1,\"455\":1,\"456\":1,\"461\":1,\"462\":1,\"465\":1,\"475\":2,\"529\":1,\"539\":1,\"557\":1,\"671\":1,\"1089\":1,\"1140\":1}}],[\"web场景来设计\",{\"1\":{\"46\":1}}],[\"web场景\",{\"1\":{\"25\":1}}],[\"web中间件\",{\"1\":{\"14\":1}}],[\"was\",{\"1\":{\"1505\":1}}],[\"wakeup\",{\"1\":{\"1408\":1}}],[\"wake\",{\"1\":{\"1252\":1}}],[\"walkthrough\",{\"1\":{\"1239\":1,\"1242\":1}}],[\"warn\",{\"1\":{\"1149\":1}}],[\"wait方法结束\",{\"1\":{\"1407\":3}}],[\"waitthread\",{\"1\":{\"1406\":19}}],[\"waitting\",{\"1\":{\"1404\":2,\"1407\":1,\"1408\":1}}],[\"waittimeinmswhensyncempty\",{\"1\":{\"1150\":1}}],[\"waittime\",{\"1\":{\"592\":1}}],[\"waittimepromise\",{\"1\":{\"592\":2}}],[\"waiter\",{\"1\":{\"1254\":8,\"1267\":2}}],[\"waitstatus\",{\"1\":{\"1251\":2,\"1252\":5,\"1501\":1,\"1505\":3,\"1506\":4,\"1511\":1}}],[\"waiting\",{\"1\":{\"1221\":4,\"1243\":1,\"1252\":1,\"1259\":5,\"1267\":1,\"1329\":2,\"1334\":6,\"1346\":2,\"1350\":2,\"1351\":1,\"1353\":1,\"1407\":1,\"1506\":1}}],[\"wait\",{\"0\":{\"1063\":1,\"1403\":1,\"1405\":1,\"1407\":1,\"1409\":1},\"1\":{\"1063\":1,\"1248\":6,\"1259\":2,\"1334\":2,\"1337\":1,\"1338\":6,\"1350\":2,\"1351\":2,\"1402\":1,\"1404\":13,\"1406\":14,\"1407\":13,\"1408\":4,\"1409\":3,\"1410\":4,\"1496\":1}}],[\"want\",{\"1\":{\"1074\":2}}],[\"wantedby=multi\",{\"1\":{\"671\":1}}],[\"wants=network\",{\"1\":{\"671\":1}}],[\"way\",{\"1\":{\"289\":4,\"1511\":1}}],[\"wrong\",{\"1\":{\"1252\":1}}],[\"wrt\",{\"1\":{\"1242\":1}}],[\"wrappers\",{\"1\":{\"525\":1,\"526\":1}}],[\"write操作\",{\"1\":{\"1482\":1}}],[\"write操作使用\",{\"1\":{\"1482\":1}}],[\"writertwo\",{\"1\":{\"1476\":2}}],[\"writerone\",{\"1\":{\"1476\":1}}],[\"writer\",{\"1\":{\"1267\":1,\"1432\":1,\"1455\":2,\"1456\":1,\"1475\":3,\"1478\":2,\"1482\":1}}],[\"writers\",{\"1\":{\"1243\":1}}],[\"writershouldblock\",{\"1\":{\"1239\":1}}],[\"writelock\",{\"1\":{\"1237\":3,\"1244\":2}}],[\"write\",{\"1\":{\"37\":1,\"982\":1,\"1049\":1,\"1239\":1,\"1242\":1,\"1243\":1,\"1244\":4,\"1267\":2,\"1291\":1,\"1482\":2}}],[\"w表示边的权重\",{\"1\":{\"354\":1}}],[\"w表示的是无权图\",{\"1\":{\"312\":1}}],[\"wirterone\",{\"1\":{\"1476\":1}}],[\"wirtelock\",{\"1\":{\"1237\":1}}],[\"will\",{\"1\":{\"1283\":1,\"1316\":1,\"1505\":1}}],[\"width=\",{\"1\":{\"543\":1,\"592\":1}}],[\"width\",{\"1\":{\"540\":1,\"549\":1,\"592\":1}}],[\"withcache\",{\"1\":{\"1211\":1}}],[\"withexpiry\",{\"1\":{\"1211\":1}}],[\"with\",{\"0\":{\"1049\":1},\"1\":{\"539\":1,\"540\":1,\"665\":1,\"1049\":1,\"1074\":2,\"1149\":1,\"1158\":2,\"1171\":1,\"1193\":1,\"1242\":1,\"1274\":1,\"1305\":1,\"1306\":1,\"1314\":1,\"1317\":2,\"1359\":1}}],[\"wi​\",{\"1\":{\"193\":2,\"263\":2}}],[\"winsw\",{\"1\":{\"1090\":4}}],[\"windows\",{\"0\":{\"676\":1,\"1089\":1,\"1090\":1},\"1\":{\"665\":2,\"676\":1,\"1089\":2,\"1090\":3}}],[\"window\",{\"1\":{\"546\":1,\"589\":1}}],[\"win\",{\"1\":{\"174\":2}}],[\"wiki\",{\"1\":{\"41\":1}}],[\"wikipedia\",{\"1\":{\"41\":1}}],[\"w\",{\"1\":{\"141\":8,\"194\":5,\"223\":7,\"250\":4,\"263\":3,\"290\":3,\"296\":4,\"297\":4,\"298\":14,\"299\":6,\"307\":1,\"312\":4,\"345\":2,\"353\":4,\"354\":8,\"355\":4,\"356\":3,\"361\":8,\"427\":2,\"428\":2,\"429\":2,\"430\":2,\"772\":3,\"1205\":1,\"1239\":4}}],[\"whole\",{\"1\":{\"1317\":1}}],[\"whether\",{\"1\":{\"1359\":1,\"1496\":1}}],[\"whenever\",{\"1\":{\"1317\":1}}],[\"when\",{\"1\":{\"1191\":1,\"1267\":1,\"1272\":1,\"1275\":2,\"1315\":2,\"1359\":1}}],[\"where\",{\"1\":{\"30\":5,\"56\":2,\"471\":4,\"525\":1,\"926\":2,\"927\":1,\"929\":2,\"931\":1,\"933\":6,\"934\":1,\"942\":1,\"944\":1,\"947\":2}}],[\"whichever\",{\"1\":{\"1317\":1}}],[\"which\",{\"1\":{\"1221\":2,\"1242\":1,\"1252\":1,\"1283\":2,\"1306\":1,\"1314\":1,\"1315\":1,\"1506\":1}}],[\"white\",{\"1\":{\"591\":2}}],[\"whitelist\",{\"1\":{\"481\":1}}],[\"while中transferforsignal方法对头结点做真正的处理\",{\"1\":{\"1252\":1}}],[\"while语句与\",{\"1\":{\"989\":1}}],[\"while\",{\"0\":{\"988\":1,\"989\":1},\"1\":{\"66\":1,\"70\":1,\"77\":1,\"83\":4,\"87\":1,\"92\":3,\"99\":1,\"110\":1,\"122\":2,\"128\":1,\"133\":1,\"134\":2,\"139\":1,\"140\":1,\"147\":1,\"162\":1,\"173\":1,\"174\":3,\"180\":1,\"197\":1,\"200\":1,\"203\":1,\"221\":1,\"223\":2,\"224\":3,\"278\":1,\"279\":1,\"291\":1,\"298\":1,\"302\":1,\"305\":1,\"309\":3,\"311\":1,\"317\":3,\"318\":3,\"321\":1,\"322\":1,\"323\":1,\"325\":1,\"328\":1,\"329\":1,\"330\":1,\"339\":2,\"340\":1,\"341\":1,\"348\":1,\"349\":1,\"352\":1,\"353\":1,\"355\":2,\"356\":1,\"368\":1,\"369\":1,\"376\":3,\"379\":1,\"381\":1,\"388\":1,\"389\":2,\"390\":2,\"394\":1,\"407\":1,\"410\":1,\"411\":2,\"417\":1,\"420\":1,\"430\":1,\"682\":2,\"700\":1,\"724\":2,\"737\":2,\"743\":2,\"749\":1,\"778\":2,\"789\":1,\"821\":1,\"834\":2,\"845\":1,\"852\":2,\"857\":1,\"870\":3,\"887\":2,\"988\":5,\"989\":5,\"990\":1,\"1049\":1,\"1251\":10,\"1252\":2,\"1254\":1,\"1267\":1,\"1271\":1,\"1273\":1,\"1274\":1,\"1275\":1,\"1306\":1,\"1307\":1,\"1315\":2,\"1316\":1,\"1317\":3,\"1336\":3,\"1337\":2,\"1340\":2,\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1406\":4,\"1407\":6,\"1408\":2,\"1409\":4,\"1410\":4,\"1411\":2,\"1458\":1,\"1505\":1,\"1511\":1}}],[\"www\",{\"1\":{\"41\":2,\"672\":1,\"1086\":1,\"1095\":1}}],[\"以实现内存可见性\",{\"1\":{\"1486\":1}}],[\"以更高层次的指令\",{\"1\":{\"1482\":1}}],[\"以后该线程在进入和退出同步块时不需要进行\",{\"1\":{\"1442\":1}}],[\"以原子更新的方式将数组中索引为\",{\"1\":{\"1386\":2}}],[\"以原子更新的方式更新\",{\"1\":{\"1385\":3}}],[\"以原子的方式将实例中的原值加\",{\"1\":{\"1385\":1}}],[\"以原子的方式将实例中的原值进行加\",{\"1\":{\"1385\":1}}],[\"以原子方式将输入的数值与实例中原本的值相加\",{\"1\":{\"1385\":1}}],[\"以这种方式\",{\"1\":{\"1367\":1}}],[\"以一个例子更清晰的来说一下\",{\"1\":{\"1316\":1}}],[\"以保证多个线程能够合理的使用特定资源\",{\"1\":{\"1398\":1}}],[\"以保证内存可见性\",{\"1\":{\"1281\":1}}],[\"以保持操作的效率\",{\"1\":{\"973\":1}}],[\"以减小\",{\"1\":{\"1272\":1}}],[\"以非公平锁为例\",{\"1\":{\"1232\":1}}],[\"以前我们总是要在\",{\"1\":{\"1132\":1}}],[\"以前是它控制其他对象\",{\"1\":{\"1131\":1}}],[\"以m为底取n的对数\",{\"1\":{\"1080\":1}}],[\"以10为底取对数\",{\"1\":{\"1080\":1}}],[\"以e为底取对数\",{\"1\":{\"1080\":1}}],[\"以外的异常\",{\"1\":{\"1044\":1}}],[\"以外的数据类型的对象\",{\"1\":{\"1018\":1}}],[\"以适应数据的增减\",{\"1\":{\"972\":1}}],[\"以分号结尾\",{\"1\":{\"908\":1}}],[\"以升序数组的中间元素作为根节点\",{\"1\":{\"815\":1}}],[\"以区分最近使用的和久未使用的数据\",{\"1\":{\"687\":1}}],[\"以跨平台\",{\"1\":{\"669\":1}}],[\"以阿里云服务器为例\",{\"1\":{\"663\":1}}],[\"以避免敏感数据泄露和数据窃取的风险\",{\"1\":{\"574\":1}}],[\"以避免重复回传\",{\"1\":{\"151\":1}}],[\"以验证密码是否正确\",{\"1\":{\"568\":1}}],[\"以上一个任务开始的时间计时\",{\"1\":{\"1367\":1}}],[\"以上三种新建线程的方式需要注意的是\",{\"1\":{\"1330\":1}}],[\"以上的分析是从单线程执行的角度去看\",{\"1\":{\"1284\":1}}],[\"以上已经明确了\",{\"1\":{\"827\":1}}],[\"以上\",{\"1\":{\"559\":1}}],[\"以上只是\",{\"1\":{\"542\":1}}],[\"以上就是本文的内容\",{\"1\":{\"231\":1}}],[\"以创建题目请求包装类\",{\"1\":{\"517\":1}}],[\"以做出战略决策\",{\"1\":{\"470\":1}}],[\"以确保只有满足指定条件的用户才能调用该方法\",{\"1\":{\"465\":1}}],[\"以确保\",{\"1\":{\"446\":1}}],[\"以数据湖为中心\",{\"1\":{\"438\":1}}],[\"以second为第二关键字\",{\"1\":{\"422\":1}}],[\"以first为第一关键字\",{\"1\":{\"422\":1}}],[\"以内的素数表的话\",{\"1\":{\"372\":1}}],[\"以内的合数的最小质因数一定不超过\",{\"1\":{\"372\":1}}],[\"以k为终点的最短距离\",{\"1\":{\"312\":1}}],[\"以最快的速度给出答案\",{\"1\":{\"273\":1}}],[\"以最小化总移动距离\",{\"1\":{\"166\":1}}],[\"以下面的例子来说\",{\"1\":{\"1478\":1}}],[\"以下方案需要准备两台服务器\",{\"1\":{\"662\":1}}],[\"以下\",{\"1\":{\"261\":1,\"273\":1,\"280\":1}}],[\"以防止早期通知\",{\"1\":{\"1406\":1}}],[\"以防止外部广告平台的计费重复\",{\"1\":{\"151\":1}}],[\"以防爆栈风险\",{\"1\":{\"246\":1}}],[\"以边权都为1为例\",{\"1\":{\"221\":1}}],[\"以给定的\",{\"1\":{\"197\":1}}],[\"以空格分隔\",{\"1\":{\"162\":1}}],[\"以应对高并发场景\",{\"1\":{\"151\":1}}],[\"以此来提高数据的操作效率\",{\"1\":{\"938\":1}}],[\"以此最大化美观度\",{\"1\":{\"141\":1}}],[\"以此类推\",{\"1\":{\"120\":1,\"167\":1,\"1119\":1}}],[\"以便后面的\",{\"1\":{\"1482\":1}}],[\"以便其他线程能够获得许可证继续执行\",{\"1\":{\"1398\":1}}],[\"以便线程能够获取到任务进行执行\",{\"1\":{\"1371\":1}}],[\"以便于最先进行执行\",{\"1\":{\"1369\":1}}],[\"以便于软件各部件之间的沟通\",{\"1\":{\"14\":1}}],[\"以便垃圾回收时能够清理\",{\"1\":{\"1308\":1}}],[\"以便能够被垃圾回收器回收\",{\"1\":{\"1306\":1}}],[\"以便能够进行恢复先前状态\",{\"1\":{\"1220\":1}}],[\"以便可以通过http访问\",{\"1\":{\"1103\":1}}],[\"以便给其他节点搜索\",{\"1\":{\"875\":1}}],[\"以便从登录页跳转至用户注册页\",{\"1\":{\"588\":1}}],[\"以便跨部门或跨公司地进行管理和决策\",{\"1\":{\"470\":1}}],[\"以便在下一轮处理\",{\"1\":{\"133\":1}}],[\"以\",{\"1\":{\"127\":2,\"228\":1,\"229\":1,\"230\":1,\"236\":1,\"237\":1,\"262\":1,\"333\":1,\"542\":1,\"548\":1,\"686\":1,\"851\":2,\"864\":1,\"1368\":1,\"1370\":1,\"1385\":1,\"1386\":1,\"1387\":1,\"1388\":1,\"1457\":1,\"1477\":1}}],[\"以统一的接口形式提供平台化的能力\",{\"1\":{\"51\":1}}],[\"以及对阻塞线程进行排队\",{\"1\":{\"1500\":1}}],[\"以及对数据安全的保障服务\",{\"1\":{\"1094\":1}}],[\"以及实例变量\",{\"1\":{\"1465\":1}}],[\"以及重排序导致的问题\",{\"1\":{\"1429\":1}}],[\"以及操作系统上\",{\"1\":{\"1339\":1}}],[\"以及在\",{\"1\":{\"1258\":1,\"1317\":1}}],[\"以及存储桶索引\",{\"1\":{\"1094\":1}}],[\"以及下载限速\",{\"1\":{\"670\":1}}],[\"以及再加上两个权限常量\",{\"1\":{\"580\":1}}],[\"以及校验码\",{\"1\":{\"568\":1}}],[\"以及嵌套布局\",{\"1\":{\"547\":1}}],[\"以及站点地图的地址\",{\"1\":{\"543\":1}}],[\"以及一个整数\",{\"1\":{\"892\":1}}],[\"以及一个线段区间\",{\"1\":{\"430\":1}}],[\"以及一个数字\",{\"1\":{\"193\":1}}],[\"以及所有阶乘取模的逆元infact\",{\"1\":{\"388\":1}}],[\"以及\",{\"1\":{\"199\":1,\"535\":1,\"1264\":1,\"1272\":1,\"1306\":2,\"1407\":1,\"1455\":1,\"1491\":2,\"1494\":1}}],[\"以及小美要求的最少数量\",{\"1\":{\"173\":1}}],[\"以及大量透穿导致的密集写\",{\"1\":{\"60\":1}}],[\"以及该评论的一些相关信息\",{\"1\":{\"56\":1}}],[\"以及通过缓存来保护下游\",{\"1\":{\"40\":1}}],[\"以及热评的热评\",{\"1\":{\"33\":1}}],[\"以评论列表的访问为例\",{\"1\":{\"30\":1}}],[\"等方法\",{\"1\":{\"1496\":1}}],[\"等方法获取数据元素会返回\",{\"1\":{\"1326\":1}}],[\"等线程处于\",{\"1\":{\"1496\":1}}],[\"等同步组件主要专注于实现同步语义\",{\"1\":{\"1495\":1}}],[\"等大家都完成\",{\"1\":{\"1394\":1}}],[\"等到所有的线程都到达指定的临界点\",{\"1\":{\"1393\":1}}],[\"等到待插入的节点插入之后\",{\"1\":{\"1285\":1}}],[\"等一系列提供\",{\"1\":{\"1385\":1}}],[\"等重要属性在构造方法中进行创建\",{\"1\":{\"1346\":1}}],[\"等基友赶上来后\",{\"1\":{\"1337\":1}}],[\"等容器的方式一样\",{\"1\":{\"1306\":1}}],[\"等容器一样\",{\"1\":{\"1306\":1}}],[\"等问题\",{\"1\":{\"1295\":1}}],[\"等待通知等等一些底层的实现处理\",{\"1\":{\"1500\":1}}],[\"等待通知机制\",{\"0\":{\"1247\":1}}],[\"等待和唤醒这些底层操作\",{\"1\":{\"1495\":1}}],[\"等待和唤醒等底层操作\",{\"1\":{\"1494\":1}}],[\"等待下一次能够有机会获取到对象监视器锁\",{\"1\":{\"1404\":1}}],[\"等待下一次获取资源\",{\"1\":{\"1338\":1}}],[\"等待有机会再一次获取到锁\",{\"1\":{\"1404\":1}}],[\"等待若干个其他线程执行完任务之后\",{\"1\":{\"1394\":1}}],[\"等待\",{\"0\":{\"1407\":1},\"1\":{\"1329\":1,\"1406\":1,\"1407\":1,\"1408\":1}}],[\"等待方\",{\"1\":{\"1253\":1}}],[\"等待队列中的下一个节点\",{\"1\":{\"1501\":1}}],[\"等待队列中的线程\",{\"1\":{\"1348\":1}}],[\"等待队列中\",{\"1\":{\"1346\":2,\"1347\":1}}],[\"等待队列为空队列\",{\"1\":{\"1251\":1}}],[\"等待队列是一个单向队列\",{\"1\":{\"1250\":2}}],[\"等待队列\",{\"0\":{\"1250\":1}}],[\"等待线程执行结束\",{\"1\":{\"1060\":1}}],[\"等各种复杂工作负载以及成为\",{\"1\":{\"1095\":1}}],[\"等以及用户自定义的\",{\"1\":{\"1044\":1}}],[\"等采用引用传递\",{\"1\":{\"1018\":1}}],[\"等于\",{\"1\":{\"748\":1,\"931\":1,\"984\":1,\"1283\":1,\"1316\":1}}],[\"等靠近国内的延迟会比较低\",{\"1\":{\"662\":1}}],[\"等国内厂商没有问题\",{\"1\":{\"662\":1}}],[\"等浏览器环境才支持的对象\",{\"1\":{\"546\":1}}],[\"等现代认证方式\",{\"1\":{\"445\":1}}],[\"等分析工具进行处理\",{\"1\":{\"436\":1}}],[\"等等\",{\"1\":{\"436\":1}}],[\"等效替代\",{\"1\":{\"384\":1}}],[\"等级和价格\",{\"1\":{\"140\":1}}],[\"等级和价格都是非负整数\",{\"1\":{\"140\":1}}],[\"等级\",{\"1\":{\"140\":1}}],[\"等价于~\",{\"1\":{\"422\":1}}],[\"等价于\",{\"1\":{\"135\":1,\"261\":1}}],[\"等数据结构来解决问题\",{\"1\":{\"234\":1}}],[\"等数据\",{\"1\":{\"50\":1}}],[\"等\",{\"1\":{\"30\":1,\"31\":1,\"39\":1,\"46\":1,\"56\":1,\"83\":1,\"267\":1,\"542\":1,\"671\":1,\"1010\":1,\"1042\":1,\"1044\":1,\"1094\":2,\"1131\":1,\"1135\":1,\"1280\":1,\"1495\":1}}],[\"mb\",{\"1\":{\"1194\":2}}],[\"m为原串长度\",{\"1\":{\"1069\":2}}],[\"mm\",{\"1\":{\"920\":6,\"1309\":2}}],[\"mnt\",{\"1\":{\"1087\":3,\"1088\":1}}],[\"mn\",{\"1\":{\"705\":8}}],[\"mn​\",{\"1\":{\"384\":1}}],[\"mq消息乱序问题解析与实战解决方案\",{\"1\":{\"639\":1}}],[\"m=\",{\"1\":{\"613\":1}}],[\"m==0\",{\"1\":{\"388\":1}}],[\"msg\",{\"1\":{\"598\":1}}],[\"md5digestashex\",{\"1\":{\"568\":1,\"575\":1}}],[\"mvnrepository\",{\"1\":{\"560\":1,\"568\":1}}],[\"mutextdemo\",{\"1\":{\"1496\":1}}],[\"mutexdemo\",{\"1\":{\"1496\":2}}],[\"mutex\",{\"1\":{\"1264\":1,\"1496\":9}}],[\"must\",{\"1\":{\"1244\":1,\"1305\":1,\"1306\":1,\"1316\":1,\"1504\":1,\"1505\":1,\"1511\":1}}],[\"mustrole\",{\"1\":{\"525\":1,\"526\":1}}],[\"multiple\",{\"1\":{\"592\":1,\"1316\":1}}],[\"multimap\",{\"1\":{\"422\":3}}],[\"multiset\",{\"1\":{\"422\":3}}],[\"mul\",{\"1\":{\"329\":2,\"390\":2}}],[\"mycache>\",{\"1\":{\"1201\":1}}],[\"mycache\",{\"1\":{\"1201\":8}}],[\"myserviceurl\",{\"1\":{\"1177\":1}}],[\"mysql中有两种方式进行事务的操作\",{\"1\":{\"954\":1}}],[\"mysql中的数据类型主要分为三类\",{\"1\":{\"920\":1}}],[\"mysql数据库为解决id问题\",{\"1\":{\"919\":1}}],[\"mysql特有\",{\"1\":{\"908\":1}}],[\"mysql服务器启动完毕后\",{\"1\":{\"906\":1}}],[\"mysqld\",{\"1\":{\"671\":1}}],[\"mysql\",{\"0\":{\"904\":1,\"1530\":1},\"1\":{\"40\":1,\"46\":2,\"49\":2,\"50\":3,\"56\":1,\"58\":1,\"60\":8,\"493\":1,\"500\":1,\"557\":1,\"906\":3,\"908\":1,\"935\":1,\"954\":1,\"958\":3},\"2\":{\"960\":1}}],[\"myhostname\",{\"1\":{\"1177\":2}}],[\"mydatacenterinstanceconfig\",{\"1\":{\"1175\":1,\"1178\":4}}],[\"myfile2\",{\"1\":{\"1102\":2}}],[\"myfile目录是否存在\",{\"1\":{\"1102\":1}}],[\"myfile\",{\"1\":{\"1102\":1,\"1103\":7}}],[\"my\",{\"1\":{\"913\":1,\"1005\":3,\"1055\":1}}],[\"myapp\",{\"1\":{\"559\":1}}],[\"myatisx\",{\"1\":{\"515\":1}}],[\"mybatisx\",{\"1\":{\"567\":1}}],[\"mybatis\",{\"1\":{\"471\":1,\"500\":2,\"557\":3,\"560\":1,\"567\":2,\"575\":2,\"619\":1,\"634\":1}}],[\"m匹配串长度\",{\"1\":{\"411\":1}}],[\"m个1\",{\"1\":{\"392\":1}}],[\"m2\",{\"1\":{\"384\":4}}],[\"m2​\",{\"1\":{\"384\":1}}],[\"m1\",{\"1\":{\"384\":7}}],[\"m1​\",{\"1\":{\"384\":1}}],[\"m1≤n\",{\"1\":{\"87\":1}}],[\"m是边数\",{\"1\":{\"361\":1}}],[\"mlogm\",{\"1\":{\"361\":1}}],[\"mlogn\",{\"1\":{\"351\":1,\"353\":1}}],[\"m表示边数\",{\"1\":{\"354\":1,\"360\":1,\"362\":1}}],[\"m代表边数\",{\"1\":{\"345\":1}}],[\"m⩽100\",{\"1\":{\"278\":1}}],[\"m行\",{\"1\":{\"273\":1}}],[\"mpopenld\",{\"1\":{\"510\":2}}],[\"mpopenid\",{\"1\":{\"510\":1}}],[\"mp\",{\"1\":{\"228\":5,\"229\":5,\"230\":5,\"235\":6,\"236\":6,\"237\":7,\"767\":3}}],[\"more\",{\"1\":{\"1242\":1,\"1275\":1,\"1306\":1,\"1314\":1,\"1315\":1}}],[\"moved\",{\"1\":{\"1267\":1,\"1272\":6,\"1274\":1,\"1276\":1}}],[\"move\",{\"1\":{\"1031\":1,\"1033\":2,\"1034\":2}}],[\"movq\",{\"1\":{\"246\":1}}],[\"monday\",{\"1\":{\"986\":1}}],[\"mondles\",{\"1\":{\"448\":1,\"453\":1,\"459\":1}}],[\"monitordemo\",{\"1\":{\"1432\":1}}],[\"monitorexit\",{\"1\":{\"1431\":2,\"1482\":1}}],[\"monitorenter\",{\"1\":{\"1431\":2,\"1482\":1}}],[\"monitor\",{\"0\":{\"1431\":1},\"1\":{\"481\":1,\"482\":1,\"1221\":2,\"1431\":3,\"1434\":1,\"1440\":1}}],[\"money\",{\"1\":{\"162\":2,\"1005\":3}}],[\"modcount\",{\"1\":{\"1276\":1}}],[\"mode\",{\"0\":{\"1533\":1},\"1\":{\"1191\":2,\"1504\":2}}],[\"mode=\",{\"1\":{\"1090\":1}}],[\"model\",{\"1\":{\"515\":1,\"516\":2,\"517\":1,\"576\":1}}],[\"modify\",{\"1\":{\"922\":1}}],[\"modm\",{\"1\":{\"388\":1}}],[\"modp\",{\"1\":{\"388\":1,\"389\":1}}],[\"modai​\",{\"1\":{\"384\":1}}],[\"mod\",{\"1\":{\"72\":3,\"87\":4,\"110\":2,\"135\":2,\"167\":4,\"182\":2,\"197\":2,\"247\":5,\"261\":2,\"308\":4,\"376\":3,\"381\":1,\"384\":2,\"387\":1,\"388\":5,\"389\":1,\"421\":1}}],[\"m​\",{\"1\":{\"146\":2,\"305\":1}}],[\"m∗n\",{\"1\":{\"142\":1}}],[\"m≤1000\",{\"1\":{\"196\":1}}],[\"m≤1000000000\",{\"1\":{\"147\":1}}],[\"m≤105\",{\"1\":{\"168\":2,\"205\":1}}],[\"m≤106\",{\"1\":{\"87\":1}}],[\"m≤2∗105\",{\"1\":{\"141\":1}}],[\"m+1\",{\"1\":{\"127\":1,\"157\":1}}],[\"m<1001≤k≤1041≤xi​≤n1≤yi​≤msi​\",{\"1\":{\"77\":1}}],[\"major\",{\"1\":{\"1295\":1}}],[\"may\",{\"1\":{\"1149\":1,\"1191\":3,\"1243\":1,\"1275\":2}}],[\"macos\",{\"1\":{\"665\":1}}],[\"mark\",{\"1\":{\"845\":7,\"1440\":5,\"1442\":2,\"1443\":1,\"1446\":3,\"1447\":1}}],[\"markdown\",{\"1\":{\"658\":1}}],[\"margin\",{\"1\":{\"540\":1}}],[\"maven\",{\"1\":{\"500\":1,\"560\":1}}],[\"manes\",{\"1\":{\"1206\":1}}],[\"manipulation\",{\"1\":{\"909\":1,\"924\":1}}],[\"manage\",{\"1\":{\"465\":3,\"592\":2}}],[\"manhattandistance\",{\"1\":{\"216\":1}}],[\"malloc\",{\"1\":{\"246\":1}}],[\"makebucketargs\",{\"1\":{\"1102\":1}}],[\"makebucket\",{\"1\":{\"1102\":2}}],[\"makerecently\",{\"1\":{\"687\":3}}],[\"make\",{\"1\":{\"206\":1,\"257\":1,\"1505\":1}}],[\"map为null\",{\"1\":{\"1301\":1}}],[\"mappings\",{\"1\":{\"1275\":3}}],[\"mappingcount\",{\"1\":{\"1275\":4}}],[\"mapper\",{\"1\":{\"471\":2,\"515\":2,\"567\":3}}],[\"map中的对象类型\",{\"1\":{\"1040\":1}}],[\"map存节点和对应的下标\",{\"1\":{\"767\":1}}],[\"mapreduce\",{\"1\":{\"434\":1}}],[\"map<\",{\"1\":{\"1270\":1}}],[\"map<character\",{\"1\":{\"1074\":3}}],[\"map<characters\",{\"1\":{\"1074\":1}}],[\"map<k\",{\"1\":{\"1040\":1,\"1210\":1,\"1264\":2}}],[\"map<node\",{\"1\":{\"887\":1}}],[\"map<long\",{\"1\":{\"882\":1}}],[\"map<string\",{\"1\":{\"224\":2,\"279\":1,\"784\":2,\"1201\":1}}],[\"map<int\",{\"1\":{\"200\":1,\"369\":2,\"376\":1}}],[\"map<integer\",{\"1\":{\"179\":1,\"767\":2}}],[\"map>\",{\"1\":{\"200\":1,\"224\":1,\"279\":1,\"376\":1}}],[\"map\",{\"0\":{\"1040\":1,\"1074\":1,\"1214\":1},\"1\":{\"129\":1,\"167\":1,\"179\":5,\"422\":3,\"525\":1,\"567\":1,\"578\":1,\"688\":2,\"766\":1,\"887\":11,\"1040\":1,\"1074\":10,\"1137\":1,\"1141\":1,\"1149\":1,\"1151\":1,\"1201\":7,\"1264\":2,\"1267\":2,\"1301\":6,\"1302\":8,\"1303\":2,\"1324\":2}}],[\"masking\",{\"1\":{\"574\":1}}],[\"mask\",{\"1\":{\"121\":6,\"1239\":4}}],[\"matcher\",{\"1\":{\"568\":4,\"575\":4}}],[\"matches\",{\"1\":{\"88\":1}}],[\"match\",{\"0\":{\"1525\":1},\"1\":{\"363\":4,\"575\":1}}],[\"math\",{\"0\":{\"1080\":1},\"1\":{\"70\":2,\"71\":1,\"72\":2,\"97\":1,\"104\":3,\"115\":1,\"152\":1,\"178\":1,\"705\":3,\"748\":1,\"761\":2,\"772\":1,\"795\":2,\"796\":2,\"797\":1,\"827\":1,\"828\":2,\"840\":2,\"845\":1,\"846\":1,\"851\":2,\"870\":2,\"893\":1,\"894\":2,\"901\":2,\"1080\":14}}],[\"maxlength\",{\"1\":{\"1409\":5,\"1410\":5}}],[\"maxheap\",{\"1\":{\"1078\":1}}],[\"maxdepth\",{\"1\":{\"748\":3,\"749\":1}}],[\"maxdiff\",{\"1\":{\"152\":4}}],[\"maxproduct\",{\"1\":{\"705\":1}}],[\"maxpos\",{\"1\":{\"72\":4,\"256\":2}}],[\"maxwidth\",{\"1\":{\"587\":1}}],[\"maxvalue\",{\"1\":{\"256\":2}}],[\"maximumpoolsize\",{\"1\":{\"1359\":5}}],[\"maximumsize\",{\"1\":{\"1204\":1,\"1207\":1}}],[\"maximum\",{\"1\":{\"252\":1,\"1232\":1,\"1233\":1,\"1239\":1,\"1270\":4,\"1275\":1}}],[\"maxtotalmoney\",{\"1\":{\"162\":3}}],[\"maxflavor\",{\"1\":{\"152\":1}}],[\"maxslidingwindow\",{\"1\":{\"857\":1}}],[\"maxsum\",{\"1\":{\"140\":4}}],[\"maxscore\",{\"1\":{\"71\":1}}],[\"max\",{\"0\":{\"256\":1},\"1\":{\"66\":2,\"70\":1,\"71\":1,\"72\":1,\"104\":3,\"109\":10,\"110\":2,\"140\":1,\"146\":1,\"152\":1,\"167\":2,\"174\":18,\"178\":1,\"194\":2,\"206\":2,\"230\":1,\"243\":2,\"244\":1,\"256\":6,\"263\":1,\"296\":2,\"297\":2,\"298\":4,\"299\":2,\"301\":3,\"302\":4,\"303\":4,\"304\":3,\"314\":2,\"340\":1,\"342\":1,\"372\":1,\"377\":1,\"423\":1,\"430\":1,\"431\":1,\"540\":2,\"672\":1,\"705\":7,\"748\":1,\"761\":2,\"772\":3,\"795\":1,\"796\":1,\"797\":1,\"827\":1,\"828\":2,\"840\":2,\"845\":1,\"846\":1,\"851\":2,\"869\":1,\"870\":2,\"893\":2,\"894\":4,\"899\":3,\"901\":4,\"932\":2,\"1021\":2,\"1022\":6,\"1080\":1,\"1081\":1,\"1083\":8,\"1210\":1,\"1239\":1,\"1242\":1,\"1274\":1,\"1275\":3,\"1326\":2,\"1349\":2,\"1366\":5}}],[\"maintain\",{\"1\":{\"1306\":1,\"1317\":1}}],[\"maintained\",{\"1\":{\"1301\":1}}],[\"main\",{\"1\":{\"65\":1,\"66\":1,\"76\":1,\"77\":1,\"82\":2,\"83\":2,\"87\":2,\"88\":2,\"97\":2,\"98\":2,\"99\":2,\"103\":2,\"104\":2,\"110\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"126\":2,\"127\":1,\"128\":2,\"129\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"157\":2,\"161\":2,\"162\":2,\"172\":1,\"173\":1,\"174\":1,\"178\":2,\"179\":2,\"180\":2,\"182\":2,\"194\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"246\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"311\":1,\"312\":1,\"314\":1,\"324\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"339\":2,\"345\":1,\"352\":1,\"360\":1,\"376\":1,\"384\":1,\"389\":1,\"392\":1,\"394\":1,\"411\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1,\"463\":1,\"978\":2,\"980\":6,\"981\":4,\"982\":4,\"984\":18,\"985\":4,\"986\":2,\"988\":8,\"989\":2,\"990\":8,\"992\":2,\"993\":2,\"994\":4,\"997\":2,\"998\":2,\"999\":8,\"1000\":4,\"1001\":2,\"1004\":4,\"1006\":2,\"1011\":2,\"1014\":2,\"1015\":2,\"1017\":2,\"1018\":2,\"1020\":2,\"1021\":2,\"1022\":2,\"1023\":2,\"1029\":2,\"1034\":2,\"1047\":2,\"1048\":2,\"1049\":2,\"1055\":2,\"1059\":4,\"1061\":2,\"1062\":4,\"1063\":2,\"1145\":1,\"1175\":4,\"1211\":1,\"1221\":1,\"1250\":1,\"1254\":1,\"1259\":4,\"1260\":2,\"1284\":1,\"1309\":1,\"1330\":3,\"1336\":3,\"1337\":2,\"1340\":6,\"1346\":1,\"1385\":1,\"1386\":1,\"1387\":1,\"1388\":1,\"1392\":5,\"1393\":1,\"1398\":1,\"1399\":1,\"1406\":2,\"1407\":2,\"1409\":1,\"1410\":1,\"1411\":1,\"1429\":1,\"1431\":1,\"1449\":1,\"1458\":2,\"1467\":1,\"1482\":1,\"1496\":1}}],[\"mx\",{\"1\":{\"66\":6,\"174\":8,\"178\":5,\"250\":3,\"304\":4,\"705\":10}}],[\"m\",{\"1\":{\"58\":1,\"77\":5,\"87\":6,\"110\":4,\"121\":6,\"127\":6,\"141\":10,\"142\":11,\"146\":10,\"147\":6,\"157\":9,\"162\":7,\"168\":3,\"180\":11,\"196\":3,\"197\":5,\"205\":2,\"206\":4,\"215\":6,\"223\":9,\"228\":5,\"229\":7,\"230\":5,\"235\":6,\"236\":4,\"237\":6,\"273\":4,\"274\":6,\"278\":9,\"289\":7,\"290\":3,\"296\":7,\"297\":7,\"298\":17,\"299\":9,\"303\":5,\"305\":8,\"306\":5,\"311\":9,\"312\":2,\"345\":1,\"346\":2,\"349\":1,\"351\":4,\"352\":5,\"353\":1,\"354\":4,\"355\":6,\"356\":1,\"360\":6,\"361\":5,\"362\":5,\"363\":3,\"388\":8,\"389\":4,\"392\":6,\"411\":8,\"423\":2,\"613\":2,\"820\":4,\"821\":4,\"822\":10,\"840\":6,\"868\":1,\"870\":7,\"893\":2,\"1069\":4,\"1080\":1,\"1264\":2,\"1270\":1,\"1275\":3,\"1303\":3}}],[\"misc\",{\"1\":{\"1259\":3,\"1266\":3,\"1275\":1,\"1282\":1,\"1385\":1}}],[\"miss\",{\"1\":{\"48\":3,\"58\":1,\"60\":1}}],[\"might\",{\"1\":{\"1244\":1}}],[\"millis\",{\"1\":{\"1337\":2,\"1338\":1}}],[\"milliseconds\",{\"1\":{\"1201\":1}}],[\"miller\",{\"1\":{\"41\":1}}],[\"mirrors\",{\"1\":{\"1086\":1}}],[\"mianshiba\",{\"0\":{\"1523\":1},\"1\":{\"517\":1,\"543\":1,\"549\":1}}],[\"mi​\",{\"1\":{\"384\":1}}],[\"mid\",{\"1\":{\"134\":2,\"157\":6,\"162\":5,\"173\":4,\"206\":7,\"302\":4,\"318\":7,\"321\":9,\"322\":13,\"323\":5,\"325\":4,\"341\":4,\"815\":4,\"852\":12}}],[\"middleware\",{\"0\":{\"1537\":1},\"1\":{\"14\":1}}],[\"minor\",{\"1\":{\"1295\":1}}],[\"minutes\",{\"1\":{\"1103\":1}}],[\"minheap\",{\"1\":{\"1078\":1}}],[\"minioinfo\",{\"1\":{\"1100\":6}}],[\"minio密码\",{\"1\":{\"1100\":1}}],[\"minio用户名\",{\"1\":{\"1100\":1}}],[\"minioclient\",{\"0\":{\"1101\":1},\"1\":{\"1100\":8,\"1102\":6,\"1103\":9}}],[\"minio<\",{\"1\":{\"1099\":1}}],[\"minio官网\",{\"1\":{\"1093\":1}}],[\"minioadmin\",{\"1\":{\"1087\":1,\"1089\":1,\"1100\":2}}],[\"minio\",{\"0\":{\"1086\":1,\"1093\":1,\"1098\":1},\"1\":{\"668\":2,\"1086\":3,\"1087\":24,\"1088\":8,\"1089\":10,\"1090\":8,\"1093\":2,\"1094\":4,\"1095\":22,\"1100\":10,\"1103\":3},\"2\":{\"1092\":1,\"1097\":1,\"1105\":1}}],[\"minwidth\",{\"1\":{\"587\":1}}],[\"minvalue\",{\"1\":{\"256\":2}}],[\"minx\",{\"1\":{\"236\":7,\"237\":6}}],[\"minpos\",{\"1\":{\"72\":7,\"256\":2}}],[\"min\",{\"0\":{\"256\":1,\"1536\":1},\"1\":{\"65\":2,\"70\":1,\"72\":1,\"109\":10,\"110\":1,\"115\":2,\"122\":1,\"141\":1,\"146\":1,\"174\":4,\"219\":1,\"221\":1,\"256\":5,\"263\":1,\"305\":3,\"306\":6,\"307\":2,\"312\":2,\"352\":4,\"354\":1,\"358\":1,\"360\":2,\"397\":1,\"428\":1,\"587\":2,\"705\":3,\"795\":3,\"796\":2,\"797\":1,\"893\":1,\"894\":2,\"899\":2,\"900\":1,\"901\":3,\"932\":2,\"1080\":1,\"1081\":1,\"1083\":8,\"1089\":1,\"1093\":1,\"1190\":1,\"1274\":2}}],[\"meaning\",{\"1\":{\"1350\":2}}],[\"mediatype\",{\"1\":{\"1184\":1}}],[\"mediumtext\",{\"1\":{\"920\":1}}],[\"mediumblob\",{\"1\":{\"920\":1}}],[\"mediumint\",{\"1\":{\"920\":1}}],[\"mechanism\",{\"1\":{\"1149\":1}}],[\"messagesource\",{\"1\":{\"1140\":1}}],[\"message\",{\"1\":{\"587\":9,\"589\":2}}],[\"menus=\",{\"1\":{\"592\":1}}],[\"menu\",{\"1\":{\"459\":1}}],[\"me登录的用户访问\",{\"1\":{\"446\":1}}],[\"me下自动登录\",{\"1\":{\"446\":1}}],[\"method\",{\"0\":{\"966\":1},\"1\":{\"446\":1,\"589\":1,\"596\":1,\"1055\":5,\"1103\":2,\"1259\":2,\"1275\":1,\"1359\":1,\"1408\":1,\"1431\":2}}],[\"metadata\",{\"1\":{\"543\":1,\"1051\":1}}],[\"meta\",{\"1\":{\"30\":1}}],[\"mex运算\",{\"0\":{\"397\":1}}],[\"mex\",{\"1\":{\"250\":2,\"397\":1,\"398\":1}}],[\"mex函数\",{\"0\":{\"250\":1}}],[\"memory\",{\"1\":{\"1194\":2}}],[\"memo\",{\"1\":{\"784\":7,\"795\":6,\"827\":6}}],[\"memcpy\",{\"1\":{\"291\":1}}],[\"memset\",{\"1\":{\"223\":3,\"278\":1,\"311\":1,\"312\":1,\"345\":1,\"352\":2,\"353\":1,\"354\":1,\"355\":1,\"360\":2,\"362\":1,\"363\":1}}],[\"member\",{\"1\":{\"31\":2,\"58\":1}}],[\"mergeklists\",{\"1\":{\"789\":1}}],[\"merge\",{\"1\":{\"92\":1,\"134\":2,\"318\":3,\"342\":1,\"431\":2,\"882\":2}}],[\"可响应中断式锁可调用方法\",{\"1\":{\"1507\":1}}],[\"可中断\",{\"0\":{\"1512\":1}}],[\"可中断式获取锁\",{\"0\":{\"1507\":1}}],[\"可中断的获取锁以及超时获取锁等多种\",{\"1\":{\"1492\":1}}],[\"可实际上\",{\"1\":{\"1482\":1}}],[\"可实现各类定制化排序\",{\"1\":{\"40\":1}}],[\"可使用锁或者\",{\"1\":{\"1476\":1}}],[\"可使用在代码块和方法中\",{\"1\":{\"1430\":1}}],[\"可使物品总体积不超过背包容量\",{\"1\":{\"299\":1}}],[\"可无论运行多少次\",{\"1\":{\"1429\":1}}],[\"可周期性执行的任务\",{\"0\":{\"1368\":1}}],[\"可运行线程\",{\"0\":{\"1331\":1}}],[\"可运行\",{\"1\":{\"1329\":1}}],[\"可采用如下代码\",{\"1\":{\"1326\":1}}],[\"可采用这样的思维方式\",{\"1\":{\"1283\":1}}],[\"可作为\",{\"1\":{\"1326\":1}}],[\"可达从而不会被回收掉\",{\"1\":{\"1313\":1}}],[\"可见即线程\",{\"1\":{\"1432\":1}}],[\"可见性是指当一个线程修改了共享变量后\",{\"1\":{\"1486\":1}}],[\"可见性\",{\"0\":{\"1481\":1,\"1486\":1},\"1\":{\"1453\":1,\"1455\":2}}],[\"可见性三个方面进行考虑\",{\"1\":{\"1425\":1}}],[\"可见性带来的问题\",{\"1\":{\"1221\":1}}],[\"可见\",{\"1\":{\"1420\":1,\"1421\":1,\"1432\":1,\"1455\":1,\"1476\":1}}],[\"可见注释\",{\"1\":{\"1351\":1}}],[\"可见为了尽可能解决这个问题几乎无时无刻都在做出努力\",{\"1\":{\"1307\":1}}],[\"可是\",{\"1\":{\"1313\":1}}],[\"可是只能读到\",{\"1\":{\"1295\":1}}],[\"可是在这种情况下\",{\"1\":{\"869\":1}}],[\"可想而知\",{\"1\":{\"1264\":1}}],[\"可传入一个\",{\"1\":{\"1233\":1}}],[\"可嵌套\",{\"1\":{\"1120\":1}}],[\"可选\",{\"1\":{\"1100\":1}}],[\"可选字段\",{\"1\":{\"566\":1}}],[\"可视化管理界面\",{\"1\":{\"1095\":1}}],[\"可视化辅助工具\",{\"1\":{\"559\":1}}],[\"可拓展\",{\"1\":{\"1095\":1}}],[\"可拓展性的特点\",{\"1\":{\"1094\":1}}],[\"可修改\",{\"1\":{\"1087\":1}}],[\"可为string\",{\"1\":{\"1069\":1}}],[\"可确定\",{\"1\":{\"766\":1}}],[\"可将\",{\"1\":{\"766\":2}}],[\"可得出以下推论\",{\"1\":{\"766\":1}}],[\"可写可不写\",{\"1\":{\"688\":1}}],[\"可助你即刻构建出兼备自用或公用的网盘服务\",{\"1\":{\"669\":1}}],[\"可靠\",{\"1\":{\"575\":1}}],[\"可把该页面删除\",{\"1\":{\"559\":1}}],[\"可把一堆取光\",{\"1\":{\"394\":1}}],[\"可展示站点小图标\",{\"1\":{\"543\":1}}],[\"可做可不做\",{\"1\":{\"506\":1}}],[\"可匿名访问\",{\"1\":{\"446\":1}}],[\"可计算出去重后的元素个数\",{\"1\":{\"423\":1}}],[\"可理解为\",{\"1\":{\"360\":1,\"361\":1}}],[\"可进行的操作有\",{\"1\":{\"306\":1}}],[\"可走且未访问\",{\"1\":{\"235\":1}}],[\"可定义方向数组来进行遍历\",{\"1\":{\"228\":1}}],[\"可惜的是\",{\"1\":{\"216\":1}}],[\"可能有以下的执行顺序\",{\"1\":{\"1485\":1}}],[\"可能出在数据\",{\"1\":{\"1425\":1}}],[\"可能发生了网络分区\",{\"1\":{\"1191\":1}}],[\"可能需要额外的逻辑或使用其他数据结构\",{\"1\":{\"973\":1}}],[\"可能需要更换\",{\"1\":{\"538\":1}}],[\"可能过几天就会被\",{\"1\":{\"664\":1}}],[\"可能还存在外部防火墙没关或者端口放行方向不正确等问题\",{\"1\":{\"663\":1}}],[\"可能存在的执行时序\",{\"1\":{\"1285\":1}}],[\"可能存在\",{\"1\":{\"613\":1}}],[\"可能将不在集合中的元素判断为在集合中\",{\"1\":{\"613\":1}}],[\"可能\",{\"1\":{\"613\":1}}],[\"可能包含参数校验\",{\"1\":{\"576\":1}}],[\"可能包含长度为偶数的环\",{\"1\":{\"362\":1}}],[\"可能为负数\",{\"1\":{\"384\":1}}],[\"可能的执行时序如图所示\",{\"1\":{\"1478\":1}}],[\"可能的报错\",{\"1\":{\"567\":1}}],[\"可能的\",{\"1\":{\"323\":1}}],[\"可能会被重排序到构造函数之外\",{\"1\":{\"1475\":1}}],[\"可能会奇怪明明讨论的是并发编程为什么会扯到了硬件的发展\",{\"1\":{\"1218\":1}}],[\"可能会存在大\",{\"1\":{\"613\":1}}],[\"可能会有一定的延迟\",{\"1\":{\"533\":1}}],[\"可能会变为瓶颈\",{\"1\":{\"61\":1}}],[\"可能会引起存储过载的情况\",{\"1\":{\"60\":1}}],[\"可能更好\",{\"1\":{\"56\":1}}],[\"可能是最小节点\",{\"1\":{\"789\":1}}],[\"可能是某个链表的头节点\",{\"1\":{\"789\":1}}],[\"可能是整数\",{\"1\":{\"252\":1}}],[\"可能是\",{\"1\":{\"46\":1}}],[\"可能在b事务中被修改\",{\"1\":{\"37\":1}}],[\"可用容量\",{\"1\":{\"1266\":1}}],[\"可用的相邻集群复制节点\",{\"1\":{\"1194\":1}}],[\"可用性上\",{\"1\":{\"46\":1}}],[\"可用性\",{\"1\":{\"40\":1,\"500\":1}}],[\"可用性设计等\",{\"1\":{\"44\":1}}],[\"可用性设计\",{\"0\":{\"32\":1,\"59\":1}}],[\"可用于告诉搜索引擎爬虫能否访问特定的页面\",{\"1\":{\"543\":1}}],[\"可用于对路由进行分组管理\",{\"1\":{\"542\":1}}],[\"可用于存储一些关键的附属信息\",{\"1\":{\"30\":1}}],[\"可用于描述评论\",{\"1\":{\"30\":1}}],[\"可以清楚地知道两点\",{\"1\":{\"1501\":1}}],[\"可以清理掉\",{\"1\":{\"540\":1}}],[\"可以归纳总结为这么几点\",{\"1\":{\"1495\":1}}],[\"可以大致认为基本数据类型的访问读写具备原子性\",{\"1\":{\"1482\":1}}],[\"可以大大减少开发时的工作量\",{\"1\":{\"526\":1}}],[\"可以大大加快路径的搜索速度\",{\"1\":{\"214\":1}}],[\"可以作为扩展知识面掌握下\",{\"1\":{\"1482\":1}}],[\"可以确保线程\",{\"1\":{\"1476\":1}}],[\"可以修饰变量\",{\"1\":{\"1462\":1}}],[\"可以这样理解二者的关系\",{\"1\":{\"1494\":1}}],[\"可以这样理解\",{\"1\":{\"1420\":1}}],[\"可以重排序\",{\"1\":{\"1478\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"1418\":1}}],[\"可以重复选\",{\"1\":{\"795\":3,\"796\":1,\"893\":3}}],[\"可以引申到线程间通信机制\",{\"1\":{\"1416\":1}}],[\"可以引入另外一种数据结构\",{\"1\":{\"958\":1}}],[\"可以利用\",{\"1\":{\"1411\":1}}],[\"可以采用三种方式\",{\"1\":{\"1402\":1}}],[\"可以采用增量静态生成技术\",{\"1\":{\"534\":1}}],[\"可以优先考虑\",{\"1\":{\"1398\":1}}],[\"可以继续当做计数器使用\",{\"1\":{\"1393\":1}}],[\"可以继续凑齐下一波\",{\"1\":{\"1393\":1}}],[\"可以想象每当一个运动员到达终点的时候\",{\"1\":{\"1392\":1}}],[\"可以想到每次贪心的对窗口中的最后一个数进行操作\",{\"1\":{\"122\":1}}],[\"可以十分方便的完成所说的这种业务场景\",{\"1\":{\"1392\":1}}],[\"可以查看\",{\"1\":{\"1385\":1}}],[\"可以查看指定表的字段\",{\"1\":{\"921\":1}}],[\"可以交给\",{\"1\":{\"1376\":1}}],[\"可以从以下几个角度来进行分析\",{\"1\":{\"1361\":1}}],[\"可以从多种设备和应用上访问等等\",{\"1\":{\"669\":1}}],[\"可以通俗的理解成接力\",{\"1\":{\"1337\":1}}],[\"可以通过同步机制\",{\"1\":{\"1417\":1}}],[\"可以通过配合调用\",{\"1\":{\"1404\":1}}],[\"可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字\",{\"1\":{\"1359\":1}}],[\"可以通过查看\",{\"1\":{\"672\":1}}],[\"可以通过\",{\"1\":{\"542\":2,\"1284\":1,\"1330\":1,\"1360\":1,\"1420\":1,\"1444\":1}}],[\"可以通过二次点击支持\",{\"1\":{\"56\":1}}],[\"可以被访问时\",{\"1\":{\"1326\":1}}],[\"可以被多个线程使用\",{\"1\":{\"1226\":1}}],[\"可以进行赋值\",{\"1\":{\"1466\":1}}],[\"可以进行比较\",{\"1\":{\"1295\":1}}],[\"可以进行修改\",{\"1\":{\"670\":1}}],[\"可以总结出\",{\"1\":{\"1284\":1}}],[\"可以理解成占位符\",{\"1\":{\"1274\":1}}],[\"可以理解为信号量\",{\"1\":{\"1398\":1}}],[\"可以理解为传输的配置\",{\"1\":{\"1157\":1}}],[\"可以理解为一个\",{\"1\":{\"1153\":1}}],[\"可以理解为背包问题\",{\"1\":{\"194\":1}}],[\"可以理解为\",{\"1\":{\"14\":1,\"291\":1,\"1266\":1,\"1270\":1}}],[\"可以依次向上升级锁状态\",{\"1\":{\"1264\":1}}],[\"可以指定线程对象唤醒指定的线程\",{\"1\":{\"1260\":1}}],[\"可以指定用户使用的存储策略和可用的最大容量\",{\"1\":{\"670\":1}}],[\"可以持有多个等待队列\",{\"1\":{\"1250\":1}}],[\"可以有效的减少一部分不必要的锁竞争带来的上下文切换\",{\"1\":{\"1220\":1}}],[\"可以有两种形式\",{\"1\":{\"906\":1}}],[\"可以减少上下文切换的时间\",{\"1\":{\"1220\":1}}],[\"可以减少热点场景下的sql执行条数\",{\"1\":{\"33\":1}}],[\"可以参考这篇\",{\"1\":{\"1276\":1}}],[\"可以参考之前我写的文章\",{\"1\":{\"1145\":1}}],[\"可以参照\",{\"1\":{\"1220\":1}}],[\"可以感知集群实例注册表的实现类\",{\"1\":{\"1160\":1}}],[\"可以得出结论\",{\"1\":{\"1150\":1,\"1368\":1}}],[\"可以得到思路\",{\"1\":{\"852\":1}}],[\"可以得到递归的解法\",{\"1\":{\"851\":1}}],[\"可以灵活访问不同的资源\",{\"1\":{\"1140\":1}}],[\"可以看\",{\"1\":{\"1344\":1}}],[\"可以看出要想理解\",{\"1\":{\"1493\":1}}],[\"可以看出被\",{\"1\":{\"1470\":1}}],[\"可以看出该方法逻辑很简单\",{\"1\":{\"1370\":1}}],[\"可以看出该方法的重要逻辑会是在\",{\"1\":{\"1370\":1}}],[\"可以看出由于\",{\"1\":{\"1366\":1}}],[\"可以看出与\",{\"1\":{\"1350\":1}}],[\"可以看出\",{\"1\":{\"1336\":1,\"1348\":1,\"1360\":1,\"1365\":1,\"1366\":1,\"1368\":1,\"1369\":1,\"1385\":3,\"1386\":1,\"1388\":1,\"1398\":1,\"1407\":1,\"1411\":1,\"1472\":1}}],[\"可以看出为每一个线程分配一个\",{\"1\":{\"1309\":1}}],[\"可以看出来当前等待对象\",{\"1\":{\"1337\":1}}],[\"可以看出来\",{\"1\":{\"1293\":1}}],[\"可以看出这些方法实际上是通过调用\",{\"1\":{\"1282\":1}}],[\"可以看出在处理器指令集能够支持\",{\"1\":{\"1282\":1}}],[\"可以看这篇文章\",{\"1\":{\"1281\":1,\"1496\":1}}],[\"可以看作是\",{\"1\":{\"1205\":1}}],[\"可以看下这里乘以\",{\"1\":{\"1271\":1}}],[\"可以看下\",{\"1\":{\"1133\":1}}],[\"可以看到改了后的值\",{\"1\":{\"1145\":1}}],[\"可以看到\",{\"1\":{\"537\":1,\"1504\":1}}],[\"可以向脚本传递参数\",{\"1\":{\"1119\":1}}],[\"可以取变量\",{\"1\":{\"1117\":1}}],[\"可以换成其它任意字符串\",{\"1\":{\"1110\":1}}],[\"可以多个线程共同使用一个\",{\"1\":{\"1100\":1}}],[\"可以丢失任意\",{\"1\":{\"1095\":1}}],[\"可以自定义修改\",{\"1\":{\"1087\":1}}],[\"可以删除变量\",{\"1\":{\"1115\":1}}],[\"可以删除元素\",{\"1\":{\"1074\":1}}],[\"可以删掉\",{\"1\":{\"407\":1}}],[\"可以动态创建和使用对象\",{\"1\":{\"1056\":1}}],[\"可以提前从循环中退出\",{\"1\":{\"992\":1}}],[\"可以提升性能\",{\"1\":{\"525\":1}}],[\"可以定义多个变量\",{\"1\":{\"990\":1}}],[\"可以定义关于该任务的详情\",{\"1\":{\"479\":1}}],[\"可以简单理解为循环版的\",{\"1\":{\"988\":1}}],[\"可以简写为\",{\"1\":{\"979\":5}}],[\"可以控制在小于等于\",{\"1\":{\"958\":1}}],[\"可以存储多个\",{\"1\":{\"958\":1}}],[\"可以是\",{\"1\":{\"1175\":1}}],[\"可以是声明语句\",{\"1\":{\"990\":1}}],[\"可以是多列\",{\"1\":{\"950\":1}}],[\"可以是多行\",{\"1\":{\"949\":1}}],[\"可以是一个区间\",{\"1\":{\"256\":2}}],[\"可以\",{\"1\":{\"933\":1}}],[\"可以加上参数\",{\"1\":{\"915\":1}}],[\"可以逆过来进行\",{\"1\":{\"725\":1}}],[\"可以画出这样一个流程图\",{\"1\":{\"687\":1}}],[\"可以形成一种新的数据结构\",{\"1\":{\"687\":1}}],[\"可以像操作本地磁盘一样操作网盘了\",{\"1\":{\"676\":1}}],[\"可以借此实现跨平台的文件共享与同步\",{\"1\":{\"674\":1}}],[\"可以说是支撑起整个\",{\"1\":{\"1438\":1}}],[\"可以说是一个写多读少的场景\",{\"1\":{\"40\":1}}],[\"可以说\",{\"1\":{\"669\":1}}],[\"可以创建外链分享文件以及目录\",{\"1\":{\"669\":1}}],[\"可以分为成员变量以及方法局部变量\",{\"1\":{\"1464\":1}}],[\"可以分布式部署\",{\"1\":{\"669\":1}}],[\"可以分解为六个1相加或者一个1和一个5\",{\"1\":{\"135\":1}}],[\"可以给第三方调用\",{\"1\":{\"668\":1}}],[\"可以搜索在线布隆过滤器容量计算\",{\"1\":{\"613\":1}}],[\"可以设置\",{\"1\":{\"613\":1}}],[\"可以考虑交换状态与状态值\",{\"1\":{\"852\":1}}],[\"可以考虑分片存储来解决\",{\"1\":{\"613\":1}}],[\"可以考虑再添加一层\",{\"1\":{\"613\":1}}],[\"可以解决跨域问题\",{\"1\":{\"586\":1}}],[\"可以去\",{\"1\":{\"560\":1}}],[\"可以只对部分页面生效\",{\"1\":{\"547\":1}}],[\"可以匹配\",{\"1\":{\"542\":1}}],[\"可以匹配零个或多个前面的字符\",{\"1\":{\"127\":1}}],[\"可以轻松索引并提升\",{\"1\":{\"534\":1}}],[\"可以更好地理解和索引网页内容\",{\"1\":{\"533\":1}}],[\"可以实现复杂的交互和动态内容\",{\"1\":{\"532\":1}}],[\"可以实现更丰富的交互和动态内容\",{\"1\":{\"531\":1}}],[\"可以同时支持按照题库\",{\"1\":{\"525\":1}}],[\"可以直接插入\",{\"1\":{\"1314\":1}}],[\"可以直接通过浏览器登录系统\",{\"1\":{\"1095\":1}}],[\"可以直接输出\",{\"1\":{\"1006\":1}}],[\"可以直接跳到当前循环体的结尾\",{\"1\":{\"993\":1}}],[\"可以直接把\",{\"1\":{\"852\":1}}],[\"可以直接把命令中的\",{\"1\":{\"538\":1}}],[\"可以直接将实现写在\",{\"1\":{\"526\":1}}],[\"可以直接获取全部题目\",{\"1\":{\"525\":1}}],[\"可以直接引用因子机预定义的因子\",{\"1\":{\"40\":1}}],[\"可以发现\",{\"1\":{\"482\":1,\"894\":1,\"1250\":1}}],[\"可以达到动态控制定时任务启动\",{\"1\":{\"475\":1}}],[\"可以访问自己部门及下属部门的数据\",{\"1\":{\"470\":1}}],[\"可以将其转换为线程安全的容器\",{\"1\":{\"1324\":1}}],[\"可以将变量变为只读\",{\"1\":{\"1114\":1}}],[\"可以将\",{\"1\":{\"1025\":1}}],[\"可以将这张大表拆分成两张小表\",{\"1\":{\"938\":1}}],[\"可以将文件存储在第三方\",{\"1\":{\"670\":1}}],[\"可以将数据湖中最近几个月的\",{\"1\":{\"438\":1}}],[\"可以将模板\",{\"1\":{\"322\":1}}],[\"可以执行的合法行动与轮到哪名玩家无关\",{\"1\":{\"395\":1}}],[\"可以用在方法上也可以使用在代码块中\",{\"1\":{\"1430\":1}}],[\"可以用于做流量控制\",{\"1\":{\"1398\":1}}],[\"可以用于解决\",{\"1\":{\"613\":1}}],[\"可以用来在给定延时后执行异步任务或者周期性执行任务\",{\"1\":{\"1365\":1}}],[\"可以用来加载多种\",{\"1\":{\"1140\":1}}],[\"可以用函数的方式声明页面和组件\",{\"1\":{\"545\":1}}],[\"可以用\",{\"1\":{\"543\":1}}],[\"可以用费马小定理求逆元\",{\"1\":{\"388\":1}}],[\"可以用结构体存储点和边\",{\"1\":{\"354\":1}}],[\"可以缩小问题规模而保持最大公约数不变\",{\"1\":{\"377\":1}}],[\"可以对其进行优化\",{\"1\":{\"368\":1}}],[\"可以生成最小生成树\",{\"1\":{\"361\":1}}],[\"可以生小母牛\",{\"1\":{\"182\":1}}],[\"可以不加大括号\",{\"1\":{\"990\":1}}],[\"可以不指定排序方式asc\",{\"1\":{\"934\":1}}],[\"可以不需要考虑重边\",{\"1\":{\"353\":1}}],[\"可以不对回复做更新操作\",{\"1\":{\"30\":1}}],[\"可以任选\",{\"1\":{\"317\":1}}],[\"可以表示为\",{\"1\":{\"338\":1}}],[\"可以表示为带分数的形式\",{\"1\":{\"291\":1}}],[\"可以表示成若干个正整数之和\",{\"1\":{\"308\":1}}],[\"可以摧毁一个包含\",{\"1\":{\"263\":1}}],[\"可以返回\",{\"1\":{\"243\":1}}],[\"可以把题库\",{\"1\":{\"525\":1}}],[\"可以把\",{\"1\":{\"224\":1,\"279\":1}}],[\"可以称之为父节点\",{\"1\":{\"212\":1}}],[\"可以证明没有更优方案\",{\"1\":{\"147\":1}}],[\"可以选择平衡二叉树或者是红黑树来解决上述问题\",{\"1\":{\"958\":1}}],[\"可以选择若干个数字\",{\"1\":{\"135\":1}}],[\"可以选择任意一座山\",{\"1\":{\"66\":1}}],[\"可以使得答案最优\",{\"1\":{\"122\":1}}],[\"可以使用各种公有云提供的\",{\"1\":{\"1094\":1}}],[\"可以使用各种类型的键\",{\"1\":{\"972\":1}}],[\"可以使用stringbuilder和stringbuffer\",{\"1\":{\"1007\":1}}],[\"可以使用\",{\"1\":{\"58\":1,\"180\":1,\"243\":1,\"613\":1,\"913\":1,\"927\":1,\"1020\":1,\"1095\":1,\"1220\":1,\"1359\":1}}],[\"可以为空\",{\"1\":{\"990\":2}}],[\"可以为此账号指定相对根目录\",{\"1\":{\"675\":1}}],[\"可以为\",{\"1\":{\"104\":1}}],[\"可以跟踪\",{\"1\":{\"99\":1}}],[\"可以在网上随便搜搜即可\",{\"1\":{\"1272\":1}}],[\"可以在网页端上传和下载文件\",{\"1\":{\"668\":1}}],[\"可以在类的所有成员函数中调用\",{\"1\":{\"1015\":1}}],[\"可以在创建表\",{\"1\":{\"919\":1}}],[\"可以在里面自己写\",{\"1\":{\"567\":1}}],[\"可以在里面存放图片等静态资源文件\",{\"1\":{\"543\":1}}],[\"可以在既能享受静态网站高性能\",{\"1\":{\"534\":1}}],[\"可以在页面进行任务状态的开关控制\",{\"1\":{\"482\":1}}],[\"可以在第三个参数传入定义大小比较的函数\",{\"1\":{\"423\":1}}],[\"可以在区间\",{\"1\":{\"324\":2}}],[\"可以在进程内吞掉大量的读请求\",{\"1\":{\"61\":1}}],[\"可以在\",{\"1\":{\"60\":1,\"538\":1,\"1107\":1}}],[\"可以做到\",{\"1\":{\"58\":1}}],[\"可以先写入\",{\"1\":{\"56\":1}}],[\"可以按照\",{\"1\":{\"49\":1}}],[\"可以认为是物理上的一个小队列\",{\"1\":{\"49\":1}}],[\"可以接入各种业务形态\",{\"1\":{\"45\":1}}],[\"可以倾诉自己的故事\",{\"1\":{\"41\":1}}],[\"可以炫一下自己的装扮\",{\"1\":{\"41\":1}}],[\"可以保留一套通用的底层排序算法\",{\"1\":{\"40\":1}}],[\"可以视具体场景要求降级至下一级缓存\",{\"1\":{\"34\":1}}],[\"审核\",{\"1\":{\"30\":1}}],[\"审核等\",{\"1\":{\"22\":1,\"45\":1}}],[\"计时等待\",{\"1\":{\"1329\":1}}],[\"计划偷窃沿街的房屋\",{\"1\":{\"826\":1}}],[\"计蒜客\",{\"1\":{\"235\":1,\"236\":1,\"237\":1}}],[\"计数器就会加一\",{\"1\":{\"1431\":1}}],[\"计数器维护\",{\"1\":{\"40\":1}}],[\"计数加一\",{\"1\":{\"1232\":1}}],[\"计数冗余同步至其他系统\",{\"1\":{\"37\":1}}],[\"计数不一致的根源\",{\"1\":{\"37\":1}}],[\"计数类dp\",{\"0\":{\"308\":1}}],[\"计数类\",{\"1\":{\"30\":1}}],[\"计算key的hash值\",{\"1\":{\"1272\":1}}],[\"计算数组中可用的大小\",{\"1\":{\"1271\":1}}],[\"计算公式\",{\"1\":{\"935\":1}}],[\"计算公式如下\",{\"1\":{\"392\":1}}],[\"计算指定列的平均值\",{\"1\":{\"932\":1}}],[\"计算指定列的最小值\",{\"1\":{\"932\":1}}],[\"计算指定列的最大值\",{\"1\":{\"932\":1}}],[\"计算指定列的数值和\",{\"1\":{\"932\":1}}],[\"计算你\",{\"1\":{\"826\":1}}],[\"计算子串\",{\"1\":{\"421\":1}}],[\"计算起始点经过队头到其他点的距离是否变短\",{\"1\":{\"355\":1}}],[\"计算它们的差\",{\"1\":{\"328\":1}}],[\"计算它们的和\",{\"1\":{\"327\":1}}],[\"计算结果可能为负数\",{\"1\":{\"328\":1}}],[\"计算结果时就要加上这一个\",{\"1\":{\"261\":1}}],[\"计算结果范围为\",{\"1\":{\"83\":2}}],[\"计算两个数的和\",{\"1\":{\"255\":1}}],[\"计算两个数组的元素总和\",{\"1\":{\"114\":1}}],[\"计算各个点与目标状态的曼哈顿距离之和\",{\"1\":{\"224\":1}}],[\"计算对角距离的函数如下\",{\"1\":{\"219\":1}}],[\"计算曼哈顿距离的函数如下\",{\"1\":{\"218\":1}}],[\"计算节点\",{\"1\":{\"215\":1}}],[\"计算并返回可以凑成总金额所需的\",{\"1\":{\"892\":1}}],[\"计算并返回排名\",{\"1\":{\"129\":1}}],[\"计算并输出结果\",{\"1\":{\"167\":1}}],[\"计算最终结果并取模\",{\"1\":{\"167\":1}}],[\"计算最终的\",{\"1\":{\"167\":1}}],[\"计算将\",{\"1\":{\"167\":1}}],[\"计算剩余瓶子到位置\",{\"1\":{\"166\":1}}],[\"计算每个瓶子到位置\",{\"1\":{\"166\":1}}],[\"计算当前游戏节点与前一个游戏节点之间的时间差\",{\"1\":{\"146\":1}}],[\"计算分别购买这两部分能获得的优惠券总数\",{\"1\":{\"109\":1}}],[\"计算出来就是一个负数\",{\"1\":{\"1508\":1}}],[\"计算出刚好达到超时时间时的系统时间就是\",{\"1\":{\"1508\":1}}],[\"计算出所有可能的子集购买方案\",{\"1\":{\"109\":1}}],[\"计算出探测数据项的单机qps热点阈值\",{\"1\":{\"33\":1}}],[\"计算可能的网吧距离\",{\"1\":{\"108\":1}}],[\"计算魔法水晶箭从发射到落地的时间\",{\"1\":{\"97\":1}}],[\"计算符号只有\",{\"1\":{\"83\":2}}],[\"计算相同字符的个数\",{\"1\":{\"82\":1}}],[\"计算相应的热点条件阈值呢\",{\"1\":{\"33\":1}}],[\"计算\",{\"1\":{\"72\":1,\"139\":1,\"321\":1,\"322\":1,\"797\":1,\"1272\":1}}],[\"计算通过修改第\",{\"1\":{\"66\":1}}],[\"计算修改一次后的最长递增子序列\",{\"1\":{\"66\":1}}],[\"计算从左到右和从右到左的最长递增子序列的长度\",{\"1\":{\"66\":1}}],[\"计算机网络\",{\"0\":{\"10\":1},\"1\":{\"7\":1}}],[\"计算机\",{\"0\":{\"7\":1},\"1\":{\"676\":1}}],[\"其返回值是一个int类型\",{\"1\":{\"1510\":1}}],[\"其示意图如下\",{\"1\":{\"1501\":1}}],[\"其示意图如下图所示\",{\"1\":{\"1239\":1}}],[\"其关键就是必须要对对象的监视器\",{\"1\":{\"1431\":1}}],[\"其核心在于理解\",{\"1\":{\"1415\":1}}],[\"其源码如下\",{\"1\":{\"1385\":1}}],[\"其源码为\",{\"1\":{\"1281\":1}}],[\"其功能更加强大\",{\"1\":{\"1365\":1}}],[\"其休眠时间的精度取决于处理器的计时器和调度器\",{\"1\":{\"1338\":1}}],[\"其含义是\",{\"1\":{\"1337\":1}}],[\"其默认大小为\",{\"1\":{\"1326\":1}}],[\"其方法执行示意图如下\",{\"1\":{\"1316\":1}}],[\"其值为\",{\"1\":{\"1306\":1}}],[\"其值等于一个整数自乘的积\",{\"1\":{\"794\":1}}],[\"其值等于另一个整数的平方\",{\"1\":{\"794\":1}}],[\"其节点状态和相关属性可以去看\",{\"1\":{\"1250\":1}}],[\"其原因是\",{\"1\":{\"1324\":1}}],[\"其原因正是我们刚才所说的\",{\"1\":{\"1240\":1}}],[\"其原理也很简单\",{\"1\":{\"214\":1}}],[\"其主要逻辑为\",{\"1\":{\"1239\":1}}],[\"其主要区别有\",{\"1\":{\"1140\":1}}],[\"其它参数相关变量\",{\"0\":{\"1120\":1}}],[\"其全部oldchar都替换成newchar\",{\"1\":{\"1069\":1}}],[\"其创建的对象将直接放置到堆中\",{\"1\":{\"1069\":1}}],[\"其长度为end或end\",{\"1\":{\"1067\":1}}],[\"其工作原理主要包括以下几个步骤\",{\"1\":{\"971\":1}}],[\"其所有的节点是否都在\",{\"1\":{\"899\":1}}],[\"其\",{\"1\":{\"894\":1,\"1267\":1,\"1478\":1}}],[\"其之前2个位置的最长括号长度加上当前位置新增的\",{\"1\":{\"846\":1}}],[\"其要求一定是能稳定运行\",{\"1\":{\"671\":1}}],[\"其实是因为\",{\"1\":{\"1493\":1}}],[\"其实是在遵循一个基本原则\",{\"1\":{\"1420\":1,\"1423\":1}}],[\"其实是将当前\",{\"1\":{\"1175\":1}}],[\"其实线程间的这种协作方式也符合现实生活\",{\"1\":{\"1337\":1}}],[\"其实在多线程环境下这行代码很有意思的\",{\"1\":{\"1283\":1}}],[\"其实要面临的问题还是有很多的\",{\"1\":{\"1141\":1}}],[\"其实一对一我们可以看成一种特殊的一对多\",{\"1\":{\"938\":1}}],[\"其实就是创建了\",{\"1\":{\"1178\":1}}],[\"其实就是加载这个文件\",{\"1\":{\"1149\":1}}],[\"其实就是把二叉树上的每个节点的左右子节点都交换一下\",{\"1\":{\"863\":1}}],[\"其实就是找每一层最右边的节点\",{\"1\":{\"736\":1}}],[\"其实隐式地维护了一个栈结构\",{\"1\":{\"731\":1}}],[\"其实\",{\"1\":{\"671\":1,\"1141\":1,\"1392\":1}}],[\"其实到这一步\",{\"1\":{\"670\":1}}],[\"其实解决方法也有\",{\"1\":{\"668\":1}}],[\"其实关键在于\",{\"1\":{\"274\":1}}],[\"其自身并不能提供一个外部链接\",{\"1\":{\"668\":1}}],[\"其作用就是相当于在一个\",{\"1\":{\"471\":1}}],[\"其表达式为\",{\"1\":{\"339\":1}}],[\"其更新操作是\",{\"1\":{\"321\":1,\"322\":1}}],[\"其位数和棋盘的行数一致\",{\"1\":{\"311\":1}}],[\"其时间复杂度就是树的高度\",{\"1\":{\"274\":1}}],[\"其函数表示如下\",{\"1\":{\"220\":1}}],[\"其幂次运算的个位数都会呈现周期性变化\",{\"1\":{\"139\":1}}],[\"其余会失败\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"其余为o\",{\"1\":{\"1072\":1}}],[\"其余所有的数字依次跟着变化\",{\"1\":{\"385\":1}}],[\"其余位为\",{\"1\":{\"338\":3}}],[\"其余\",{\"1\":{\"115\":1}}],[\"其次安全性和稳定性也不能一直保证\",{\"1\":{\"668\":1}}],[\"其次\",{\"1\":{\"288\":1,\"289\":1}}],[\"其次在全量打分排序阶段\",{\"1\":{\"40\":1}}],[\"其次是评论区表\",{\"1\":{\"30\":1}}],[\"其中包含了两个子包\",{\"1\":{\"1491\":1}}],[\"其中六条可以满足基本数据类型的访问读写具备原子性\",{\"1\":{\"1482\":1}}],[\"其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象\",{\"1\":{\"1430\":1}}],[\"其中另有玄机\",{\"1\":{\"1292\":1}}],[\"其中会用到红黑树的插入\",{\"1\":{\"1272\":1}}],[\"其中利用了锁分段的思想提高了并发度\",{\"1\":{\"1264\":1}}],[\"其中每个形参都是含有一个声明符的声明\",{\"1\":{\"1013\":1}}],[\"其中每个新节点的值都设为其对应的原节点的值\",{\"1\":{\"886\":1}}],[\"其中每个完全平方数是一个物品\",{\"1\":{\"115\":1}}],[\"其中调用了\",{\"1\":{\"596\":1}}],[\"其中元素已经按\",{\"1\":{\"813\":1}}],[\"其中元素\",{\"1\":{\"417\":1}}],[\"其中任意两条边都不依附于同一个顶点\",{\"1\":{\"363\":1}}],[\"其中的属性有\",{\"1\":{\"1501\":1}}],[\"其中的\",{\"1\":{\"465\":1}}],[\"其中的第\",{\"1\":{\"339\":1}}],[\"其中的数据实时性\",{\"1\":{\"40\":1}}],[\"其中一个作为分界点\",{\"1\":{\"317\":1}}],[\"其中i为数字个数\",{\"1\":{\"309\":2}}],[\"其中第\",{\"1\":{\"196\":1,\"290\":1}}],[\"其中选择的数字只能为1\",{\"1\":{\"135\":1}}],[\"其中输入输出部分已经实现\",{\"1\":{\"129\":1}}],[\"其中如果\",{\"1\":{\"128\":1}}],[\"其中为了考虑均衡\",{\"1\":{\"104\":1}}],[\"其中\",{\"1\":{\"56\":1,\"66\":1,\"70\":1,\"72\":2,\"77\":1,\"110\":1,\"115\":1,\"126\":1,\"127\":2,\"128\":1,\"135\":1,\"142\":2,\"146\":1,\"152\":1,\"168\":2,\"215\":1,\"228\":1,\"229\":1,\"235\":1,\"255\":1,\"278\":1,\"280\":1,\"311\":1,\"339\":1,\"389\":1,\"471\":1,\"510\":1,\"511\":1,\"517\":1,\"538\":1,\"723\":1,\"724\":1,\"765\":1,\"851\":1,\"874\":1,\"886\":1,\"1089\":1,\"1110\":1,\"1137\":1,\"1221\":1,\"1239\":1,\"1361\":1}}],[\"其中最核心的是发布类接口以及列表类接口\",{\"1\":{\"25\":1}}],[\"其回复也等价于全部删除\",{\"1\":{\"30\":1}}],[\"其他请求该资源的线程将会阻塞\",{\"1\":{\"1501\":1}}],[\"其他请求包装类同理\",{\"1\":{\"517\":1}}],[\"其他方法主要是实现了排队和阻塞机制\",{\"1\":{\"1494\":1}}],[\"其他线程能够立即得知这个修改\",{\"1\":{\"1486\":1}}],[\"其他线程只能等待\",{\"1\":{\"1484\":1}}],[\"其他线程对这个值已经做了自增操作后\",{\"1\":{\"1482\":1}}],[\"其他线程试图获取锁时\",{\"1\":{\"1447\":1}}],[\"其他线程获取锁时会强制从主内存中获取最新的值\",{\"1\":{\"1433\":1}}],[\"其他线程才能往下执行\",{\"1\":{\"1392\":1}}],[\"其他线程才能插入数据\",{\"1\":{\"1326\":1}}],[\"其他线程需要等待这个任务执行完后才能继续执行\",{\"1\":{\"1376\":1}}],[\"其他线程可以调用该线程的\",{\"1\":{\"1336\":1}}],[\"其他大部分时刻其他模块之后对系统信息只需要进行读取\",{\"1\":{\"1290\":1}}],[\"其他地方想获取\",{\"1\":{\"1164\":1}}],[\"其他地方想要获取上下文\",{\"1\":{\"1164\":1}}],[\"其他地方也要调用用户状态\",{\"1\":{\"580\":1}}],[\"其他值表示错误\",{\"1\":{\"1120\":1}}],[\"其他保持默认即可\",{\"1\":{\"663\":1}}],[\"其他注意事项\",{\"0\":{\"546\":1}}],[\"其他规则详见\",{\"1\":{\"542\":1}}],[\"其他渲染方式\",{\"0\":{\"534\":1}}],[\"其他节点仍然可以正常运行\",{\"1\":{\"484\":1}}],[\"其他人员只有部分权限\",{\"1\":{\"452\":1}}],[\"其他点的移动距离都是\",{\"1\":{\"166\":1}}],[\"其他组合类似\",{\"1\":{\"152\":1}}],[\"其他的都是一些统计信息等等\",{\"1\":{\"56\":1}}],[\"其他\",{\"0\":{\"1166\":1},\"1\":{\"30\":1}}],[\"i=2\",{\"1\":{\"1317\":1}}],[\"i=4\",{\"1\":{\"1317\":1}}],[\"i=7\",{\"1\":{\"1316\":2,\"1317\":1}}],[\"i=3\",{\"1\":{\"1316\":1,\"1317\":1}}],[\"i=1\",{\"1\":{\"1316\":1}}],[\"i==nums\",{\"1\":{\"309\":1}}],[\"ie\",{\"1\":{\"1251\":1}}],[\"i7\",{\"1\":{\"1218\":1}}],[\"iq号\",{\"1\":{\"1131\":1}}],[\"iii\",{\"0\":{\"879\":1},\"1\":{\"879\":1}}],[\"i≤\",{\"1\":{\"795\":1}}],[\"i^2\",{\"1\":{\"795\":1}}],[\"i2≤n\",{\"1\":{\"795\":1}}],[\"i2\",{\"1\":{\"795\":1}}],[\"i<\",{\"1\":{\"705\":1}}],[\"i<4\",{\"1\":{\"182\":2}}],[\"iceberg\",{\"1\":{\"621\":1}}],[\"ico\",{\"1\":{\"543\":1}}],[\"ignore\",{\"1\":{\"591\":2,\"1275\":1}}],[\"i18n\",{\"1\":{\"559\":1}}],[\"imeunit\",{\"1\":{\"1326\":1}}],[\"imin\",{\"1\":{\"1083\":1}}],[\"imax\",{\"1\":{\"1083\":1}}],[\"image\",{\"1\":{\"477\":1,\"543\":1,\"592\":1}}],[\"implementation\",{\"1\":{\"1272\":1}}],[\"implements\",{\"1\":{\"515\":1,\"517\":1,\"523\":2,\"525\":1,\"526\":2,\"568\":1,\"576\":3,\"1033\":1,\"1034\":1,\"1059\":2,\"1062\":1,\"1150\":1,\"1210\":1,\"1254\":2,\"1267\":1,\"1309\":1,\"1409\":2,\"1410\":2,\"1411\":2,\"1429\":1,\"1449\":1,\"1493\":1,\"1496\":1}}],[\"impossible\",{\"1\":{\"360\":1}}],[\"import\",{\"1\":{\"70\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"126\":1,\"127\":1,\"128\":2,\"129\":1,\"152\":1,\"157\":2,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"446\":19,\"517\":3,\"540\":2,\"549\":2,\"592\":5,\"981\":3,\"982\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":1,\"990\":1,\"992\":1,\"999\":3,\"1001\":1,\"1004\":2,\"1006\":1,\"1014\":1,\"1018\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1026\":1,\"1047\":1,\"1048\":2,\"1049\":1,\"1055\":4,\"1061\":1}}],[\"ipaddr\",{\"1\":{\"1195\":1}}],[\"ip号\",{\"1\":{\"1131\":1}}],[\"ip为\",{\"1\":{\"664\":1}}],[\"ip\",{\"1\":{\"471\":2,\"493\":1,\"497\":1,\"508\":1,\"662\":1,\"663\":2,\"664\":7,\"665\":1,\"672\":1,\"1195\":1}}],[\"i的最小质因子\",{\"1\":{\"373\":1}}],[\"i的根节点指向j的根节点\",{\"1\":{\"271\":1}}],[\"i是素数\",{\"1\":{\"372\":1}}],[\"i表示所有的情况\",{\"1\":{\"312\":1}}],[\"i表示从哪个数开始\",{\"1\":{\"289\":1}}],[\"i+n\",{\"1\":{\"1274\":2}}],[\"i+1\",{\"1\":{\"290\":1,\"384\":1,\"852\":1}}],[\"i++\",{\"1\":{\"70\":2,\"71\":1,\"72\":1,\"77\":1,\"82\":1,\"83\":3,\"88\":1,\"92\":3,\"97\":1,\"103\":4,\"104\":2,\"108\":2,\"109\":2,\"115\":2,\"119\":2,\"120\":1,\"121\":2,\"122\":2,\"126\":2,\"127\":2,\"128\":2,\"129\":1,\"133\":1,\"141\":5,\"152\":1,\"157\":2,\"162\":3,\"172\":1,\"173\":1,\"178\":2,\"179\":1,\"180\":1,\"182\":1,\"194\":4,\"197\":3,\"200\":2,\"203\":2,\"206\":2,\"223\":1,\"224\":4,\"228\":3,\"229\":4,\"230\":2,\"235\":3,\"236\":2,\"237\":2,\"244\":1,\"245\":1,\"261\":1,\"262\":2,\"263\":3,\"269\":1,\"273\":3,\"274\":2,\"278\":2,\"279\":2,\"281\":2,\"287\":1,\"288\":2,\"289\":2,\"290\":2,\"291\":3,\"296\":3,\"297\":3,\"298\":6,\"299\":3,\"301\":4,\"302\":7,\"303\":1,\"304\":4,\"305\":4,\"306\":2,\"307\":3,\"309\":8,\"312\":2,\"314\":3,\"317\":1,\"318\":3,\"324\":2,\"327\":1,\"328\":1,\"329\":1,\"340\":1,\"345\":1,\"349\":1,\"358\":2,\"360\":3,\"361\":2,\"367\":1,\"368\":1,\"369\":3,\"371\":1,\"372\":3,\"373\":1,\"375\":1,\"379\":1,\"384\":1,\"387\":1,\"392\":2,\"407\":1,\"410\":1,\"411\":2,\"414\":1,\"427\":2,\"428\":2,\"429\":2,\"430\":1,\"431\":1,\"682\":1,\"705\":1,\"767\":3,\"772\":1,\"783\":1,\"784\":1,\"796\":1,\"797\":1,\"803\":2,\"820\":1,\"821\":1,\"822\":2,\"828\":1,\"840\":1,\"845\":2,\"846\":1,\"851\":1,\"857\":2,\"870\":2,\"875\":1,\"876\":2,\"893\":1,\"894\":1,\"1250\":1,\"1309\":1,\"1337\":1,\"1380\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1409\":2,\"1410\":2,\"1411\":2,\"1425\":1,\"1429\":2,\"1449\":2,\"1482\":2,\"1496\":1}}],[\"its\",{\"1\":{\"1359\":1}}],[\"itrs\",{\"1\":{\"1348\":2}}],[\"itcast数据库存在时删除\",{\"1\":{\"915\":1}}],[\"itcast\",{\"1\":{\"915\":2}}],[\"items\",{\"1\":{\"1346\":6,\"1347\":8,\"1348\":7}}],[\"items=\",{\"1\":{\"587\":1}}],[\"itemoffset\",{\"1\":{\"1282\":1}}],[\"item\",{\"1\":{\"1103\":3,\"1281\":4,\"1283\":1,\"1284\":13,\"1285\":2,\"1286\":2,\"1350\":3}}],[\"itemresult\",{\"1\":{\"1103\":2}}],[\"iterable<result<item>>\",{\"1\":{\"1103\":1}}],[\"iterator\",{\"1\":{\"200\":6,\"687\":1}}],[\"it\",{\"1\":{\"200\":2,\"1239\":2,\"1242\":1,\"1243\":1,\"1283\":1,\"1306\":2,\"1314\":2,\"1315\":1,\"1317\":3,\"1351\":2,\"1359\":2,\"1496\":1,\"1505\":3,\"1506\":1,\"1511\":2}}],[\"i个人的喜好区间\",{\"1\":{\"168\":1}}],[\"i个房间的主人回答的数字\",{\"1\":{\"108\":1}}],[\"i∈\",{\"1\":{\"128\":1}}],[\"i−3\",{\"1\":{\"182\":1}}],[\"i−x\",{\"1\":{\"110\":2}}],[\"i−1个\",{\"1\":{\"380\":1}}],[\"i−1均与\",{\"1\":{\"380\":1}}],[\"i−1\",{\"1\":{\"65\":1,\"110\":2,\"182\":1,\"308\":1,\"795\":4,\"796\":2,\"797\":1,\"893\":2}}],[\"illegalaccessexception\",{\"1\":{\"1045\":1,\"1055\":1}}],[\"illegalargumentexception\",{\"1\":{\"1045\":1,\"1270\":1,\"1346\":1}}],[\"illegalthreadstateexception\",{\"1\":{\"1045\":1,\"1340\":1}}],[\"illegalstateexception\",{\"1\":{\"1045\":1,\"1325\":1}}],[\"illegalmonitorstateexception\",{\"1\":{\"1045\":1,\"1232\":1,\"1240\":1,\"1251\":1,\"1252\":1,\"1404\":2,\"1496\":1}}],[\"illegal\",{\"1\":{\"88\":6}}],[\"islocked\",{\"1\":{\"1496\":1}}],[\"iswait\",{\"1\":{\"1406\":6}}],[\"isperiodic\",{\"1\":{\"1368\":1,\"1370\":1}}],[\"isprime\",{\"1\":{\"992\":3,\"994\":3}}],[\"isterminated\",{\"1\":{\"1360\":1}}],[\"isinterrupted\",{\"1\":{\"1336\":11}}],[\"isover\",{\"1\":{\"1458\":6}}],[\"isonsyncqueue\",{\"1\":{\"1251\":3}}],[\"isolation\",{\"1\":{\"955\":2}}],[\"isheldexclusively\",{\"1\":{\"1240\":1,\"1252\":1,\"1496\":2}}],[\"isbroken\",{\"1\":{\"1393\":1,\"1394\":1}}],[\"isbucketexists\",{\"1\":{\"1102\":4}}],[\"isblank\",{\"1\":{\"1069\":1}}],[\"isend\",{\"1\":{\"802\":3,\"803\":4}}],[\"isempty\",{\"1\":{\"83\":2,\"128\":2,\"129\":2,\"180\":1,\"737\":1,\"743\":1,\"749\":1,\"784\":1,\"789\":1,\"821\":1,\"845\":2,\"870\":2,\"1036\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1069\":1,\"1073\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1284\":2,\"1407\":3,\"1409\":1,\"1410\":1}}],[\"isalive\",{\"1\":{\"1337\":2}}],[\"isadmin\",{\"1\":{\"578\":2,\"579\":1}}],[\"isanyblank\",{\"1\":{\"568\":1,\"575\":1,\"576\":2}}],[\"isrunning\",{\"1\":{\"1359\":2}}],[\"isr\",{\"1\":{\"534\":1}}],[\"isnotblank\",{\"1\":{\"578\":1}}],[\"isnotempty\",{\"1\":{\"525\":1}}],[\"isneedqueryquestionlist\",{\"1\":{\"523\":1}}],[\"isdelete\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"515\":1,\"566\":2,\"575\":2}}],[\"isdigit\",{\"1\":{\"83\":3}}],[\"isysmenuservice\",{\"0\":{\"462\":1},\"1\":{\"462\":1}}],[\"is\",{\"1\":{\"311\":4,\"367\":1,\"369\":1,\"372\":8,\"852\":1,\"931\":1,\"984\":5,\"1005\":3,\"1011\":1,\"1069\":2,\"1149\":1,\"1191\":2,\"1221\":2,\"1239\":4,\"1242\":2,\"1251\":1,\"1252\":1,\"1275\":2,\"1283\":5,\"1284\":1,\"1301\":1,\"1306\":2,\"1314\":2,\"1315\":4,\"1317\":1,\"1350\":3,\"1351\":3,\"1472\":1,\"1496\":1,\"1506\":5,\"1511\":2}}],[\"isshutdown\",{\"1\":{\"1360\":1,\"1370\":2}}],[\"issymmetric\",{\"1\":{\"809\":1}}],[\"issubtree\",{\"1\":{\"187\":3}}],[\"issametree\",{\"1\":{\"187\":4,\"809\":4}}],[\"isupper\",{\"1\":{\"172\":1}}],[\"ismatch\",{\"1\":{\"127\":2}}],[\"isvalidbst\",{\"1\":{\"899\":6,\"900\":3,\"901\":1}}],[\"isvalid\",{\"1\":{\"93\":1,\"481\":1}}],[\"if\",{\"0\":{\"984\":1},\"1\":{\"65\":1,\"66\":3,\"70\":3,\"71\":2,\"72\":2,\"76\":1,\"77\":10,\"82\":2,\"83\":7,\"87\":1,\"88\":3,\"92\":2,\"93\":3,\"97\":1,\"98\":2,\"99\":2,\"103\":4,\"104\":1,\"108\":3,\"109\":1,\"110\":1,\"120\":4,\"121\":6,\"122\":1,\"126\":1,\"127\":6,\"128\":1,\"129\":5,\"133\":3,\"134\":4,\"139\":5,\"142\":2,\"147\":3,\"157\":8,\"161\":1,\"162\":2,\"167\":4,\"172\":1,\"173\":2,\"174\":6,\"179\":1,\"180\":5,\"182\":1,\"187\":3,\"194\":2,\"197\":2,\"200\":1,\"203\":3,\"206\":4,\"223\":5,\"224\":8,\"228\":3,\"229\":2,\"230\":2,\"235\":4,\"236\":7,\"237\":5,\"244\":2,\"250\":1,\"255\":2,\"262\":3,\"270\":1,\"273\":2,\"274\":8,\"278\":1,\"279\":3,\"281\":2,\"287\":2,\"288\":2,\"289\":2,\"290\":3,\"291\":9,\"296\":1,\"297\":1,\"298\":2,\"299\":2,\"302\":4,\"303\":2,\"304\":2,\"305\":2,\"306\":2,\"307\":1,\"308\":1,\"309\":4,\"311\":4,\"312\":2,\"314\":3,\"317\":2,\"318\":2,\"321\":1,\"322\":1,\"323\":1,\"325\":1,\"327\":3,\"328\":5,\"329\":1,\"338\":3,\"341\":1,\"342\":3,\"345\":3,\"347\":1,\"348\":1,\"349\":2,\"352\":2,\"353\":3,\"354\":4,\"355\":3,\"356\":3,\"358\":1,\"360\":4,\"361\":6,\"362\":5,\"363\":3,\"367\":2,\"368\":2,\"369\":4,\"371\":1,\"372\":1,\"373\":2,\"375\":2,\"376\":1,\"379\":2,\"380\":2,\"381\":1,\"383\":1,\"384\":2,\"385\":5,\"387\":1,\"388\":1,\"389\":3,\"390\":2,\"392\":4,\"394\":1,\"406\":1,\"409\":1,\"410\":2,\"411\":3,\"412\":2,\"414\":2,\"415\":1,\"416\":1,\"417\":3,\"419\":1,\"420\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":3,\"431\":3,\"467\":2,\"481\":6,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"523\":1,\"525\":2,\"526\":2,\"568\":7,\"575\":6,\"576\":4,\"578\":3,\"579\":2,\"587\":6,\"589\":2,\"591\":1,\"592\":1,\"596\":1,\"682\":2,\"687\":3,\"694\":1,\"700\":2,\"705\":1,\"710\":3,\"713\":3,\"724\":1,\"725\":1,\"736\":2,\"737\":4,\"743\":3,\"748\":1,\"749\":3,\"755\":3,\"761\":1,\"767\":5,\"772\":1,\"783\":1,\"784\":3,\"789\":3,\"795\":3,\"796\":1,\"803\":2,\"809\":1,\"815\":1,\"820\":3,\"821\":2,\"822\":5,\"827\":2,\"834\":2,\"840\":1,\"845\":3,\"846\":6,\"851\":1,\"852\":4,\"864\":1,\"870\":6,\"876\":2,\"882\":1,\"887\":1,\"888\":1,\"893\":2,\"894\":1,\"899\":1,\"900\":2,\"901\":2,\"913\":3,\"915\":3,\"923\":2,\"984\":24,\"985\":4,\"988\":2,\"992\":3,\"993\":2,\"994\":2,\"999\":1,\"1020\":1,\"1021\":1,\"1022\":2,\"1023\":1,\"1048\":1,\"1063\":1,\"1074\":1,\"1102\":1,\"1145\":2,\"1149\":1,\"1158\":2,\"1201\":3,\"1232\":6,\"1233\":4,\"1239\":10,\"1240\":2,\"1242\":10,\"1243\":7,\"1244\":2,\"1251\":14,\"1252\":7,\"1270\":1,\"1271\":5,\"1272\":27,\"1273\":5,\"1274\":20,\"1275\":11,\"1283\":12,\"1284\":15,\"1285\":4,\"1301\":1,\"1302\":3,\"1303\":1,\"1306\":5,\"1307\":3,\"1308\":1,\"1309\":2,\"1314\":3,\"1315\":2,\"1316\":2,\"1317\":15,\"1319\":1,\"1346\":1,\"1347\":1,\"1348\":2,\"1351\":4,\"1352\":2,\"1359\":14,\"1368\":5,\"1370\":5,\"1407\":2,\"1408\":1,\"1418\":6,\"1420\":5,\"1455\":1,\"1476\":1,\"1478\":1,\"1485\":3,\"1495\":1,\"1496\":3,\"1503\":1,\"1504\":10,\"1505\":2,\"1506\":11,\"1507\":5,\"1508\":9,\"1510\":6,\"1511\":12}}],[\"i\",{\"0\":{\"253\":1},\"1\":{\"65\":23,\"66\":40,\"70\":16,\"71\":3,\"72\":16,\"77\":9,\"78\":3,\"82\":5,\"83\":7,\"88\":2,\"92\":5,\"97\":2,\"103\":13,\"104\":30,\"108\":15,\"109\":17,\"110\":18,\"115\":18,\"119\":7,\"120\":40,\"121\":10,\"122\":10,\"126\":24,\"127\":29,\"128\":15,\"129\":2,\"133\":2,\"135\":11,\"140\":4,\"141\":21,\"142\":9,\"146\":10,\"147\":1,\"152\":6,\"157\":13,\"162\":12,\"166\":1,\"168\":4,\"172\":5,\"173\":8,\"174\":28,\"178\":21,\"179\":3,\"180\":3,\"182\":13,\"193\":2,\"194\":27,\"196\":1,\"197\":10,\"200\":10,\"203\":5,\"205\":2,\"206\":11,\"221\":1,\"223\":15,\"224\":20,\"228\":11,\"229\":16,\"230\":9,\"235\":11,\"236\":12,\"237\":9,\"244\":4,\"245\":6,\"253\":1,\"261\":17,\"262\":13,\"263\":18,\"269\":4,\"271\":3,\"273\":10,\"274\":11,\"278\":7,\"279\":6,\"281\":9,\"287\":4,\"288\":9,\"289\":7,\"290\":9,\"291\":15,\"296\":20,\"297\":19,\"298\":30,\"299\":14,\"301\":25,\"302\":32,\"303\":16,\"304\":18,\"305\":22,\"306\":27,\"307\":26,\"308\":44,\"309\":44,\"311\":19,\"312\":15,\"314\":17,\"317\":11,\"318\":9,\"324\":7,\"327\":19,\"328\":29,\"329\":12,\"330\":12,\"332\":2,\"333\":1,\"339\":2,\"340\":5,\"345\":15,\"347\":5,\"348\":5,\"349\":10,\"352\":3,\"353\":7,\"354\":3,\"355\":7,\"356\":12,\"358\":10,\"360\":9,\"361\":10,\"362\":10,\"363\":9,\"367\":4,\"368\":7,\"369\":18,\"371\":6,\"372\":17,\"373\":15,\"375\":8,\"376\":7,\"379\":8,\"380\":26,\"384\":2,\"385\":30,\"387\":7,\"388\":9,\"389\":3,\"390\":22,\"392\":6,\"407\":4,\"410\":4,\"411\":16,\"412\":9,\"414\":5,\"415\":6,\"416\":6,\"417\":4,\"419\":5,\"421\":8,\"423\":1,\"427\":8,\"428\":9,\"429\":7,\"430\":8,\"431\":2,\"540\":1,\"559\":1,\"682\":2,\"705\":10,\"766\":4,\"767\":16,\"772\":12,\"783\":12,\"784\":6,\"795\":26,\"796\":17,\"797\":9,\"803\":6,\"820\":13,\"821\":7,\"822\":21,\"828\":6,\"839\":4,\"840\":14,\"845\":8,\"846\":70,\"851\":18,\"852\":7,\"857\":9,\"870\":16,\"874\":1,\"875\":3,\"876\":6,\"893\":23,\"894\":13,\"988\":13,\"990\":17,\"992\":4,\"993\":5,\"994\":9,\"999\":29,\"1000\":8,\"1005\":5,\"1007\":5,\"1010\":4,\"1011\":4,\"1018\":5,\"1036\":2,\"1047\":9,\"1059\":9,\"1061\":3,\"1062\":6,\"1063\":4,\"1250\":2,\"1268\":9,\"1272\":17,\"1273\":2,\"1274\":22,\"1275\":3,\"1306\":13,\"1307\":8,\"1308\":6,\"1309\":3,\"1314\":9,\"1315\":12,\"1316\":20,\"1317\":43,\"1337\":2,\"1340\":5,\"1386\":7,\"1392\":2,\"1393\":2,\"1398\":2,\"1409\":7,\"1410\":7,\"1411\":7,\"1429\":4,\"1432\":1,\"1449\":4,\"1455\":1,\"1482\":4,\"1496\":2,\"1506\":1}}],[\"ioc\",{\"0\":{\"1128\":1,\"1129\":1,\"1130\":1,\"1131\":1,\"1540\":1},\"1\":{\"1129\":18,\"1131\":3,\"1132\":2,\"1133\":1,\"1134\":1,\"1137\":1,\"1139\":1,\"1141\":3}}],[\"iops\",{\"1\":{\"436\":1}}],[\"ioexception\",{\"1\":{\"128\":1,\"157\":1,\"1044\":1,\"1048\":5,\"1049\":2,\"1149\":1,\"1496\":1}}],[\"io\",{\"0\":{\"1536\":1},\"1\":{\"56\":1,\"128\":1,\"157\":1,\"517\":1,\"539\":1,\"560\":1,\"658\":1,\"766\":1,\"957\":1,\"958\":3,\"981\":2,\"982\":2,\"1048\":1,\"1049\":1,\"1089\":1,\"1093\":1,\"1135\":1,\"1136\":1,\"1361\":5,\"1493\":1,\"1496\":1}}],[\"inheritablethreadlocals\",{\"1\":{\"1319\":1}}],[\"inheritedaccesscontrolcontext\",{\"1\":{\"1319\":1}}],[\"inherited\",{\"1\":{\"1053\":1}}],[\"inetaddress\",{\"1\":{\"1177\":1}}],[\"injecteurekaconfiguration\",{\"1\":{\"1175\":1,\"1177\":2}}],[\"injection\",{\"1\":{\"1129\":1,\"1132\":1,\"1133\":1}}],[\"invariant\",{\"1\":{\"1350\":2}}],[\"inversion\",{\"1\":{\"1129\":1,\"1131\":1}}],[\"inverttree\",{\"1\":{\"864\":3}}],[\"invoke\",{\"1\":{\"1055\":1}}],[\"invocationtargetexception\",{\"1\":{\"1055\":2}}],[\"innodb\",{\"1\":{\"958\":1}}],[\"inner\",{\"1\":{\"944\":1}}],[\"ingeger\",{\"1\":{\"899\":1}}],[\"inmap\",{\"1\":{\"767\":3}}],[\"inorder\",{\"1\":{\"765\":2,\"767\":12}}],[\"instead\",{\"1\":{\"1275\":1,\"1315\":1}}],[\"instancce\",{\"1\":{\"1454\":1}}],[\"instance是volatile变量\",{\"1\":{\"1454\":1}}],[\"instanceof\",{\"1\":{\"1272\":3,\"1274\":1}}],[\"instances\",{\"1\":{\"1191\":2,\"1193\":1}}],[\"instanceinforeplicator\",{\"1\":{\"1182\":1,\"1184\":3,\"1185\":1}}],[\"instanceinfo\",{\"0\":{\"1154\":1},\"1\":{\"1154\":4,\"1155\":2,\"1158\":2,\"1179\":3,\"1180\":2,\"1184\":3,\"1185\":1}}],[\"instanceconfig\",{\"0\":{\"1153\":1},\"1\":{\"1153\":4,\"1155\":2,\"1178\":1,\"1179\":1,\"1180\":2}}],[\"instance\",{\"1\":{\"1145\":6,\"1157\":1,\"1158\":1,\"1191\":2,\"1454\":1,\"1485\":9}}],[\"instantiationexception\",{\"1\":{\"1045\":1,\"1055\":1}}],[\"installed\",{\"1\":{\"1149\":1}}],[\"install\",{\"1\":{\"539\":3,\"540\":2,\"671\":1,\"1090\":1}}],[\"installation\",{\"1\":{\"537\":1,\"538\":2,\"539\":1}}],[\"inspections\",{\"1\":{\"576\":1}}],[\"insertions\",{\"1\":{\"1275\":1,\"1315\":1}}],[\"insert\",{\"0\":{\"925\":1},\"1\":{\"403\":1,\"404\":1,\"412\":1,\"419\":1,\"422\":2,\"568\":1,\"801\":1,\"803\":1,\"924\":1,\"925\":6,\"947\":1,\"957\":1}}],[\"inline\",{\"1\":{\"384\":1}}],[\"indicate\",{\"1\":{\"1252\":1,\"1351\":1,\"1505\":2}}],[\"ind\",{\"1\":{\"314\":5}}],[\"indexoutofboundsexception\",{\"1\":{\"1044\":1,\"1045\":1,\"1407\":1}}],[\"indexofsublist\",{\"1\":{\"1081\":1}}],[\"indexof\",{\"1\":{\"1005\":2,\"1069\":2}}],[\"indexborder\",{\"1\":{\"592\":1}}],[\"index指向下一个指针\",{\"1\":{\"403\":1}}],[\"indexs\",{\"1\":{\"174\":11}}],[\"index\",{\"1\":{\"30\":4,\"31\":3,\"37\":1,\"56\":9,\"58\":1,\"162\":4,\"174\":8,\"463\":3,\"510\":1,\"511\":1,\"512\":2,\"544\":3,\"548\":2,\"549\":4,\"589\":1,\"886\":2,\"957\":1,\"959\":3,\"1069\":4,\"1070\":1,\"1072\":4,\"1094\":1,\"1123\":1,\"1293\":4,\"1316\":2,\"1317\":1,\"1346\":2,\"1407\":1}}],[\"information\",{\"1\":{\"1221\":1}}],[\"info\",{\"1\":{\"575\":1,\"1165\":2,\"1184\":1}}],[\"infact\",{\"1\":{\"388\":4}}],[\"inf\",{\"1\":{\"301\":3,\"354\":3,\"358\":1,\"360\":3,\"361\":1}}],[\"initiating\",{\"1\":{\"1274\":1}}],[\"initialdelay\",{\"1\":{\"1367\":2}}],[\"initialvalue\",{\"1\":{\"1302\":3}}],[\"initialization\",{\"1\":{\"1271\":1}}],[\"initializing\",{\"1\":{\"1165\":1}}],[\"initializeeurekaclient\",{\"1\":{\"1175\":1}}],[\"initializeapplicationinfomanager\",{\"1\":{\"1175\":1}}],[\"initialized\",{\"1\":{\"1165\":1}}],[\"initialize\",{\"1\":{\"1164\":3,\"1165\":2,\"1504\":1}}],[\"initialcapacity\",{\"1\":{\"1072\":1,\"1204\":1,\"1207\":1,\"1270\":8}}],[\"initial\",{\"1\":{\"588\":1,\"1306\":5,\"1369\":2,\"1501\":1,\"1505\":1}}],[\"initialstate\",{\"1\":{\"587\":1}}],[\"inittable\",{\"0\":{\"1271\":1},\"1\":{\"1271\":1,\"1272\":2}}],[\"initscheduledtasks\",{\"1\":{\"1158\":1}}],[\"initconfig\",{\"1\":{\"1157\":1,\"1178\":1}}],[\"initwithconfigurationsource\",{\"1\":{\"1150\":1}}],[\"initeurekaservercontext\",{\"1\":{\"1145\":1,\"1146\":2,\"1147\":1}}],[\"initeurekaenvironment\",{\"1\":{\"1145\":2}}],[\"init\",{\"1\":{\"174\":2,\"267\":1,\"269\":1,\"273\":2,\"274\":2,\"309\":2,\"361\":2,\"403\":1,\"404\":1,\"414\":1,\"990\":3,\"1148\":2,\"1149\":1,\"1151\":2,\"1165\":2}}],[\"incorrectly\",{\"1\":{\"1191\":1}}],[\"incrementandget\",{\"1\":{\"1385\":1}}],[\"incremental\",{\"1\":{\"534\":1,\"1317\":1}}],[\"increment\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"566\":1,\"919\":3,\"1267\":1,\"1306\":2}}],[\"increase\",{\"1\":{\"167\":7}}],[\"includes\",{\"1\":{\"591\":1}}],[\"include<algorithm>\",{\"1\":{\"312\":1}}],[\"include<cstring>\",{\"1\":{\"312\":1}}],[\"include<deque>\",{\"1\":{\"122\":1}}],[\"include<string>\",{\"1\":{\"120\":1}}],[\"include<vector>\",{\"1\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1}}],[\"include<iostream>\",{\"1\":{\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"312\":1,\"392\":1}}],[\"include\",{\"1\":{\"65\":3,\"66\":3,\"76\":1,\"77\":2,\"110\":4,\"139\":1,\"140\":3,\"141\":3,\"142\":2,\"146\":4,\"147\":1,\"172\":2,\"173\":3,\"174\":6,\"194\":2,\"197\":3,\"200\":3,\"203\":2,\"206\":3,\"223\":4,\"224\":5,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"261\":3,\"262\":3,\"263\":3,\"273\":3,\"274\":2,\"278\":4,\"279\":5,\"281\":3,\"287\":3,\"288\":3,\"289\":3,\"290\":3,\"291\":3,\"296\":3,\"297\":3,\"298\":10,\"299\":6,\"301\":2,\"302\":9,\"303\":3,\"304\":3,\"305\":3,\"306\":3,\"307\":3,\"308\":1,\"309\":1,\"311\":4,\"314\":1,\"324\":2,\"327\":2,\"328\":2,\"329\":2,\"330\":3,\"339\":2,\"352\":3,\"360\":1,\"361\":1,\"376\":4,\"384\":2,\"394\":2,\"411\":1,\"427\":2,\"428\":2,\"429\":3,\"430\":2,\"431\":4}}],[\"input\",{\"1\":{\"128\":2,\"167\":1,\"1049\":1}}],[\"inputstreamreader\",{\"1\":{\"128\":1,\"157\":1,\"981\":2}}],[\"intanceinfo\",{\"1\":{\"1179\":1}}],[\"int会被隐式转化成字符串\",{\"1\":{\"1005\":1}}],[\"into\",{\"1\":{\"925\":4,\"1359\":1,\"1408\":1}}],[\"intel\",{\"1\":{\"1218\":3}}],[\"internal\",{\"1\":{\"1275\":1,\"1496\":1}}],[\"interrupting\",{\"1\":{\"1375\":1}}],[\"interruptdemo\",{\"1\":{\"1336\":1}}],[\"interruptmode\",{\"1\":{\"1251\":7}}],[\"interrupted\",{\"0\":{\"1336\":1},\"1\":{\"1251\":5,\"1336\":1,\"1375\":1,\"1421\":1,\"1504\":3,\"1505\":2,\"1507\":1,\"1508\":2,\"1510\":3}}],[\"interruptedexception\",{\"1\":{\"1045\":1,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":2,\"1201\":1,\"1204\":1,\"1207\":1,\"1211\":1,\"1221\":1,\"1248\":3,\"1250\":1,\"1251\":2,\"1254\":1,\"1260\":1,\"1330\":1,\"1336\":4,\"1337\":2,\"1340\":2,\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1392\":3,\"1393\":3,\"1398\":4,\"1399\":4,\"1406\":4,\"1407\":2,\"1409\":2,\"1410\":5,\"1411\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1,\"1493\":2,\"1496\":3,\"1507\":4,\"1508\":4}}],[\"interrupt\",{\"1\":{\"1060\":1,\"1336\":3}}],[\"interface\",{\"0\":{\"25\":1},\"1\":{\"25\":1,\"28\":2,\"580\":1,\"1030\":1,\"1031\":1,\"1032\":1,\"1133\":1}}],[\"integerarray\",{\"1\":{\"1386\":3}}],[\"integer>>\",{\"1\":{\"821\":1,\"870\":1}}],[\"integer>\",{\"1\":{\"129\":1,\"179\":2,\"687\":1,\"688\":2,\"767\":3,\"821\":1,\"870\":1,\"882\":1,\"1074\":4}}],[\"integer\",{\"1\":{\"127\":1,\"128\":2,\"129\":5,\"157\":3,\"161\":1,\"515\":1,\"596\":2,\"705\":1,\"795\":1,\"796\":1,\"797\":1,\"882\":2,\"893\":2,\"894\":4,\"899\":2,\"920\":1,\"1074\":1,\"1083\":2,\"1274\":1,\"1275\":2,\"1284\":1,\"1326\":2,\"1349\":2,\"1366\":5,\"1385\":1,\"1409\":1,\"1410\":1,\"1411\":2}}],[\"int>\",{\"1\":{\"122\":1,\"223\":1,\"224\":1,\"278\":1,\"279\":1,\"353\":1,\"369\":2,\"376\":1,\"422\":1,\"431\":1}}],[\"int>>\",{\"1\":{\"122\":1,\"857\":1}}],[\"int\",{\"0\":{\"251\":1},\"1\":{\"65\":7,\"66\":9,\"70\":8,\"71\":7,\"72\":11,\"76\":2,\"77\":8,\"82\":3,\"83\":3,\"87\":5,\"88\":2,\"92\":1,\"97\":7,\"99\":1,\"103\":13,\"104\":8,\"108\":5,\"109\":9,\"110\":5,\"114\":8,\"115\":7,\"119\":5,\"120\":3,\"121\":10,\"122\":5,\"126\":7,\"127\":7,\"128\":12,\"129\":7,\"133\":2,\"135\":6,\"139\":10,\"140\":5,\"141\":16,\"142\":9,\"146\":11,\"147\":3,\"152\":6,\"157\":24,\"161\":2,\"162\":19,\"167\":1,\"172\":4,\"173\":12,\"174\":30,\"178\":11,\"179\":5,\"180\":17,\"182\":3,\"194\":11,\"197\":20,\"200\":8,\"203\":14,\"206\":16,\"223\":18,\"224\":15,\"228\":15,\"229\":13,\"230\":10,\"235\":13,\"236\":15,\"237\":14,\"244\":1,\"245\":5,\"246\":2,\"247\":3,\"250\":3,\"251\":5,\"255\":6,\"256\":9,\"257\":4,\"261\":4,\"262\":5,\"263\":11,\"269\":3,\"270\":4,\"271\":4,\"273\":14,\"274\":16,\"278\":11,\"279\":10,\"281\":7,\"287\":6,\"288\":7,\"289\":8,\"290\":10,\"291\":16,\"296\":10,\"297\":10,\"298\":32,\"299\":19,\"301\":15,\"302\":25,\"303\":6,\"304\":12,\"305\":14,\"306\":8,\"307\":14,\"308\":9,\"309\":25,\"311\":10,\"312\":9,\"314\":12,\"317\":4,\"318\":6,\"321\":4,\"322\":4,\"323\":5,\"324\":5,\"327\":7,\"328\":8,\"329\":7,\"330\":8,\"338\":2,\"339\":10,\"340\":1,\"341\":4,\"342\":1,\"345\":19,\"347\":4,\"348\":3,\"349\":5,\"352\":11,\"353\":10,\"354\":7,\"355\":10,\"356\":7,\"358\":5,\"360\":15,\"361\":17,\"362\":8,\"363\":8,\"367\":2,\"368\":3,\"369\":6,\"371\":4,\"372\":4,\"373\":5,\"375\":2,\"376\":5,\"377\":6,\"379\":4,\"380\":6,\"381\":5,\"383\":6,\"384\":1,\"385\":13,\"387\":2,\"388\":6,\"389\":14,\"390\":16,\"392\":9,\"394\":4,\"403\":5,\"404\":4,\"406\":2,\"407\":2,\"409\":1,\"410\":2,\"411\":6,\"412\":10,\"414\":9,\"415\":4,\"416\":5,\"417\":7,\"419\":6,\"420\":4,\"421\":3,\"423\":10,\"427\":8,\"428\":7,\"429\":6,\"430\":9,\"431\":6,\"566\":4,\"568\":1,\"580\":2,\"682\":2,\"686\":5,\"687\":9,\"688\":6,\"700\":2,\"705\":5,\"710\":4,\"713\":6,\"736\":1,\"737\":1,\"743\":1,\"748\":3,\"749\":2,\"761\":5,\"767\":19,\"772\":9,\"778\":1,\"783\":2,\"784\":2,\"795\":9,\"796\":7,\"797\":6,\"803\":6,\"815\":5,\"820\":8,\"821\":13,\"822\":15,\"827\":8,\"828\":12,\"840\":6,\"845\":7,\"846\":6,\"851\":8,\"852\":19,\"857\":4,\"870\":30,\"875\":5,\"876\":9,\"882\":5,\"893\":9,\"894\":17,\"899\":2,\"920\":1,\"978\":6,\"980\":5,\"981\":1,\"982\":1,\"984\":9,\"985\":2,\"986\":1,\"988\":6,\"989\":2,\"990\":9,\"992\":2,\"993\":2,\"994\":4,\"997\":2,\"998\":3,\"999\":18,\"1000\":8,\"1001\":3,\"1002\":2,\"1004\":4,\"1005\":3,\"1007\":1,\"1010\":4,\"1011\":5,\"1013\":5,\"1014\":2,\"1015\":2,\"1017\":2,\"1018\":4,\"1020\":3,\"1021\":4,\"1022\":4,\"1023\":3,\"1027\":8,\"1028\":2,\"1031\":1,\"1033\":1,\"1034\":1,\"1047\":6,\"1048\":1,\"1055\":7,\"1059\":3,\"1061\":2,\"1062\":4,\"1063\":1,\"1069\":6,\"1070\":1,\"1072\":7,\"1078\":1,\"1150\":1,\"1167\":1,\"1232\":5,\"1233\":3,\"1239\":10,\"1240\":3,\"1242\":4,\"1243\":4,\"1248\":1,\"1250\":1,\"1251\":5,\"1252\":1,\"1266\":1,\"1267\":5,\"1268\":3,\"1270\":9,\"1271\":2,\"1272\":6,\"1273\":2,\"1274\":11,\"1275\":9,\"1293\":2,\"1294\":1,\"1295\":1,\"1306\":15,\"1307\":3,\"1308\":2,\"1309\":1,\"1314\":3,\"1315\":3,\"1316\":5,\"1317\":11,\"1337\":2,\"1339\":1,\"1346\":4,\"1351\":1,\"1352\":1,\"1359\":4,\"1366\":4,\"1369\":2,\"1370\":1,\"1375\":7,\"1385\":8,\"1386\":9,\"1387\":2,\"1388\":3,\"1392\":2,\"1393\":3,\"1398\":7,\"1409\":5,\"1410\":5,\"1411\":3,\"1429\":3,\"1432\":2,\"1449\":3,\"1455\":2,\"1467\":4,\"1475\":4,\"1476\":3,\"1478\":2,\"1482\":5,\"1494\":1,\"1495\":3,\"1496\":3,\"1500\":8,\"1501\":6,\"1503\":1,\"1504\":1,\"1505\":1,\"1506\":2,\"1507\":2,\"1508\":2,\"1510\":3,\"1511\":2}}],[\"in\",{\"1\":{\"30\":2,\"56\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"157\":1,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"221\":1,\"471\":2,\"525\":2,\"931\":1,\"949\":2,\"950\":2,\"981\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":1,\"990\":1,\"992\":1,\"999\":3,\"1006\":1,\"1021\":1,\"1023\":1,\"1047\":1,\"1048\":1,\"1049\":1,\"1074\":2,\"1191\":2,\"1242\":1,\"1252\":1,\"1267\":1,\"1283\":1,\"1306\":1,\"1314\":1,\"1315\":1,\"1317\":6,\"1340\":1,\"1346\":2,\"1351\":3,\"1359\":1,\"1407\":1,\"1408\":1,\"1496\":1,\"1506\":2,\"1511\":3}}],[\"idiom\",{\"1\":{\"1408\":1}}],[\"id>\",{\"1\":{\"1090\":1}}],[\"idea\",{\"1\":{\"560\":1}}],[\"idtype\",{\"1\":{\"515\":1}}],[\"id++\",{\"1\":{\"203\":1}}],[\"idx表示当前用到了哪个节点\",{\"1\":{\"403\":1,\"404\":1}}],[\"idx++\",{\"1\":{\"223\":1,\"353\":1,\"355\":1,\"403\":1,\"404\":1}}],[\"idx\",{\"1\":{\"174\":12,\"200\":2,\"203\":10,\"223\":4,\"345\":5,\"353\":4,\"355\":4,\"356\":1,\"362\":1,\"363\":1,\"403\":8,\"404\":6,\"412\":2,\"419\":4,\"510\":1,\"511\":1,\"512\":2,\"803\":6,\"822\":6}}],[\"id=1\",{\"1\":{\"926\":1}}],[\"id=\",{\"1\":{\"30\":3,\"471\":1}}],[\"id\",{\"1\":{\"30\":7,\"31\":2,\"36\":1,\"41\":2,\"56\":23,\"57\":2,\"58\":4,\"203\":17,\"345\":3,\"423\":1,\"451\":2,\"462\":1,\"471\":14,\"510\":2,\"511\":3,\"512\":3,\"513\":7,\"515\":4,\"521\":3,\"523\":7,\"525\":17,\"526\":7,\"545\":1,\"566\":1,\"576\":1,\"587\":4,\"592\":3,\"598\":1,\"665\":1,\"919\":1,\"926\":1,\"942\":2,\"1170\":2,\"1171\":1,\"1442\":1}}],[\"主内存和工作内存\",{\"1\":{\"1455\":1}}],[\"主线程才能继续往下执行\",{\"1\":{\"1392\":1}}],[\"主线程才能继续往下执行业务功能\",{\"1\":{\"1392\":1}}],[\"主调函数的执行被暂时中断\",{\"1\":{\"1011\":1}}],[\"主表列名\",{\"1\":{\"937\":2}}],[\"主表\",{\"1\":{\"937\":2}}],[\"主函数\",{\"1\":{\"827\":1}}],[\"主体\",{\"1\":{\"510\":1,\"688\":1}}],[\"主题\",{\"1\":{\"58\":1}}],[\"主题一张表\",{\"1\":{\"57\":1}}],[\"主评论下面有子评论\",{\"1\":{\"56\":1}}],[\"主键字段\",{\"1\":{\"959\":1}}],[\"主键自增\",{\"1\":{\"919\":1}}],[\"主键是一行数据的唯一标识\",{\"1\":{\"919\":1}}],[\"主键是评论区\",{\"1\":{\"30\":1}}],[\"主键是评论\",{\"1\":{\"30\":1}}],[\"主键约束\",{\"1\":{\"919\":1}}],[\"主键\",{\"1\":{\"56\":1,\"566\":1,\"919\":1}}],[\"主键也是评论\",{\"1\":{\"30\":1}}],[\"主要集中在主内存和线程的工作内存而导致的内存可见性问题\",{\"1\":{\"1429\":1}}],[\"主要方法也很简单\",{\"1\":{\"1399\":1}}],[\"主要的区别是\",{\"1\":{\"1350\":1}}],[\"主要的不同点在于\",{\"1\":{\"1326\":1}}],[\"主要看看可阻塞式的\",{\"1\":{\"1346\":1}}],[\"主要做了这么几件事情\",{\"1\":{\"1316\":1}}],[\"主要做了些什么事情\",{\"1\":{\"1302\":1}}],[\"主要采用下面两种方式\",{\"1\":{\"1306\":1}}],[\"主要设计上的变化有以下几点\",{\"1\":{\"1276\":1}}],[\"主要使用\",{\"1\":{\"1276\":1}}],[\"主要存放\",{\"1\":{\"1267\":1}}],[\"主要存的是评论实际内容\",{\"1\":{\"56\":1}}],[\"主要存的是评论的\",{\"1\":{\"56\":1}}],[\"主要逻辑请看注释\",{\"1\":{\"1243\":1}}],[\"主要也就是\",{\"1\":{\"1231\":1}}],[\"主要用于扫描控制\",{\"1\":{\"1315\":1}}],[\"主要用于实现系统的高性能\",{\"1\":{\"1200\":1}}],[\"主要用来定义类中所需包含的函数\",{\"1\":{\"1030\":1}}],[\"主要用来优化某些问题\",{\"1\":{\"404\":1}}],[\"主要就是构造出\",{\"1\":{\"1179\":1}}],[\"主要就是防止信息泄露\",{\"1\":{\"574\":1}}],[\"主要由\",{\"1\":{\"1141\":1}}],[\"主要为了帮助解释器识别变量边界\",{\"1\":{\"1113\":1}}],[\"主要对集合进行操作\",{\"1\":{\"1081\":1}}],[\"主要包含数学内的应用方法\",{\"1\":{\"1080\":1}}],[\"主要包括三个阶段\",{\"1\":{\"910\":1}}],[\"主要包括各接口qps的关系\",{\"1\":{\"33\":1}}],[\"主要是遍历复制的过程\",{\"1\":{\"1274\":1}}],[\"主要是为了省事\",{\"1\":{\"820\":1}}],[\"主要是账号服务\",{\"1\":{\"46\":1}}],[\"主要目的\",{\"1\":{\"586\":1}}],[\"主要区别\",{\"1\":{\"586\":1}}],[\"主要应用\",{\"1\":{\"403\":1}}],[\"主要步骤\",{\"1\":{\"317\":1,\"318\":1}}],[\"主要职责是维护策略所需的全部\",{\"1\":{\"40\":1}}],[\"主要有两种\",{\"1\":{\"1416\":1}}],[\"主要有两个职责\",{\"1\":{\"28\":1}}],[\"主要有这两个方面的影响\",{\"1\":{\"1454\":1}}],[\"主要有这些\",{\"1\":{\"1385\":1}}],[\"主要有这样几点需要注意\",{\"1\":{\"1306\":1}}],[\"主要有几个关键细节\",{\"1\":{\"31\":1}}],[\"主要有3项缓存\",{\"1\":{\"31\":1}}],[\"主要服务于两种调用者\",{\"1\":{\"25\":1}}],[\"且这两个操作有一个为写操作\",{\"1\":{\"1418\":1}}],[\"且消耗最少的资源\",{\"1\":{\"1332\":1}}],[\"且在该节点\",{\"1\":{\"1283\":1}}],[\"且在一个评论区范围内不能出现重复\",{\"1\":{\"28\":1}}],[\"且该节点为特殊节点\",{\"1\":{\"1272\":1}}],[\"且要得到的数等于\",{\"1\":{\"795\":1}}],[\"且内层循环必须倒序遍历\",{\"1\":{\"772\":1}}],[\"且不一定经过根节点\",{\"1\":{\"717\":1}}],[\"且不随文件位置的改变而变化\",{\"1\":{\"670\":1}}],[\"且运行不稳定\",{\"1\":{\"671\":1}}],[\"且只能管理员使用\",{\"1\":{\"577\":1}}],[\"且x不属于s\",{\"1\":{\"397\":1}}],[\"且原来匹配的点能找到另一个点\",{\"1\":{\"363\":1}}],[\"且到树的距离最短\",{\"1\":{\"360\":1}}],[\"且使权值最小的一种结构\",{\"1\":{\"359\":1}}],[\"且终点是n\",{\"1\":{\"312\":1}}],[\"且保证右端点不会超范围\",{\"1\":{\"307\":1}}],[\"且长度均不超过\",{\"1\":{\"305\":1}}],[\"且数值是严格递增的\",{\"1\":{\"304\":1}}],[\"且数据更新实时性不高\",{\"1\":{\"26\":1}}],[\"且总价值最大\",{\"1\":{\"299\":1}}],[\"且一定至少存在一条通路\",{\"1\":{\"278\":1}}],[\"且它们的执行效果相同\",{\"1\":{\"243\":1}}],[\"且astar\",{\"1\":{\"223\":1}}],[\"且边长为\",{\"1\":{\"223\":1}}],[\"且怪物的数量不超过\",{\"1\":{\"180\":1}}],[\"且上面有一个战斗力为该数字的怪物\",{\"1\":{\"180\":1}}],[\"且由大小写字母和空格混合构成的字符串\",{\"1\":{\"172\":1}}],[\"且每条\",{\"1\":{\"1021\":1}}],[\"且每座岛屿只能由上下左右四个方向相连的陆地组成\",{\"1\":{\"228\":1,\"229\":1}}],[\"且每位工人的种树区间长度相同\",{\"1\":{\"173\":1}}],[\"且每次只能移动\",{\"1\":{\"142\":1}}],[\"且每种花卉只能种在一个单元格里\",{\"1\":{\"141\":1}}],[\"且每个订单号在数组或列表中是唯一的\",{\"1\":{\"114\":1}}],[\"且每个元素都在区间\",{\"1\":{\"87\":1}}],[\"且空间复杂度为\",{\"1\":{\"134\":1}}],[\"且对时间复杂度有严格要求\",{\"1\":{\"129\":1}}],[\"且高度最小的地块\",{\"1\":{\"128\":1}}],[\"且必须全部由英文字母\",{\"1\":{\"88\":1}}],[\"且恰好移动\",{\"1\":{\"72\":1}}],[\"且\",{\"1\":{\"71\":5,\"248\":1,\"317\":1,\"383\":1,\"846\":1,\"851\":2,\"1420\":1,\"1421\":1}}],[\"且基本维持相同的热评排序逻辑\",{\"1\":{\"40\":1}}],[\"且热评排序算法应用场景也不仅局限于评论主列表的热度序\",{\"1\":{\"39\":1}}],[\"且多是批量查询\",{\"1\":{\"33\":1}}],[\"且评论计数也只有两级\",{\"1\":{\"30\":1}}],[\"且相对独立\",{\"1\":{\"30\":1}}],[\"楼中楼\",{\"1\":{\"45\":1}}],[\"楼中楼等\",{\"1\":{\"22\":1}}],[\"楼层号实际是计数器\",{\"1\":{\"28\":1}}],[\"不保证线程\",{\"1\":{\"1476\":1}}],[\"不提供\",{\"1\":{\"1472\":1}}],[\"不加以注意的也容易出现线程安全的问题\",{\"1\":{\"1425\":1}}],[\"不再赘述\",{\"1\":{\"1385\":1}}],[\"不处理直接丢弃掉任务\",{\"1\":{\"1359\":1}}],[\"不执行任何代码\",{\"1\":{\"1332\":1}}],[\"不直接往当前容器添加\",{\"1\":{\"1291\":1}}],[\"不一定指向对象真正的尾节点\",{\"1\":{\"1283\":1}}],[\"不一定是\",{\"1\":{\"362\":1}}],[\"不采用\",{\"1\":{\"1276\":1}}],[\"不相同\",{\"1\":{\"1266\":1,\"1437\":1}}],[\"不响应中断的支持\",{\"1\":{\"1251\":1}}],[\"不成功释放同步状态抛出异常\",{\"1\":{\"1251\":1}}],[\"不难理解与\",{\"1\":{\"1240\":1}}],[\"不久以后会拥有超强的计算能力\",{\"1\":{\"1218\":1}}],[\"不含当前\",{\"1\":{\"1190\":1}}],[\"不含前导0\",{\"1\":{\"327\":1,\"328\":1,\"329\":1,\"330\":1}}],[\"不建议把null添加到队列中\",{\"1\":{\"1076\":1}}],[\"不推荐\",{\"1\":{\"1069\":1}}],[\"不可再分的\",{\"1\":{\"1482\":1}}],[\"不可变类的意思是创建该类的实例后\",{\"1\":{\"1472\":1}}],[\"不可变类\",{\"1\":{\"1472\":1}}],[\"不可变字符串\",{\"1\":{\"1068\":1}}],[\"不可用的集群复制节点\",{\"1\":{\"1194\":1}}],[\"不可嵌套\",{\"1\":{\"1120\":1}}],[\"不可能划分成两个和相等的集合\",{\"1\":{\"772\":1}}],[\"不添加修饰符\",{\"1\":{\"1027\":1}}],[\"不在指定的集合范围之内\",{\"1\":{\"949\":1}}],[\"不适用与分布式\",{\"1\":{\"937\":1}}],[\"不参与分组\",{\"1\":{\"933\":1}}],[\"不等于\",{\"1\":{\"931\":1,\"984\":1}}],[\"不带任何的查询条件\",{\"1\":{\"930\":1}}],[\"不带任何条件\",{\"1\":{\"929\":1}}],[\"不超过255个字符的二进制数据\",{\"1\":{\"920\":1}}],[\"不触动警报装置的情况下\",{\"1\":{\"826\":1}}],[\"不得不通过遍历子树的方式来获知\",{\"1\":{\"712\":1}}],[\"不足\",{\"1\":{\"682\":1}}],[\"不禁有点害怕\",{\"1\":{\"668\":1}}],[\"不受影响\",{\"1\":{\"1295\":1}}],[\"不受\",{\"1\":{\"664\":1}}],[\"不受权限约束\",{\"1\":{\"467\":1}}],[\"不然要被请去喝茶了\",{\"1\":{\"661\":1}}],[\"不然大概率会超时\",{\"1\":{\"270\":1}}],[\"不错的短链接产品\",{\"1\":{\"634\":1}}],[\"不暴露服务器内部状态\",{\"1\":{\"599\":1}}],[\"不利于后续维护和拓展\",{\"1\":{\"580\":1}}],[\"不利于搜索引擎优化\",{\"1\":{\"532\":1}}],[\"不涉及业务逻辑本身\",{\"1\":{\"576\":1}}],[\"不涉及利用\",{\"1\":{\"234\":1}}],[\"不小于\",{\"1\":{\"568\":2}}],[\"不影响后续开发\",{\"1\":{\"559\":1}}],[\"不报错则代表配置工程化成功\",{\"1\":{\"539\":1}}],[\"不要调用\",{\"1\":{\"1330\":1}}],[\"不要死记硬背\",{\"1\":{\"1107\":1}}],[\"不要求字典中出现的单词全部都使用\",{\"1\":{\"782\":1}}],[\"不要\",{\"1\":{\"525\":1}}],[\"不要做需求的翻译机\",{\"1\":{\"45\":1}}],[\"不属于\",{\"1\":{\"467\":1}}],[\"不符合\",{\"1\":{\"467\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"1357\":1}}],[\"不仅是内存泄漏的问题\",{\"1\":{\"1320\":1}}],[\"不仅支持重入性\",{\"1\":{\"1231\":1}}],[\"不仅支持传统的用户名和密码认证\",{\"1\":{\"445\":1}}],[\"不仅有队列\",{\"1\":{\"1075\":1}}],[\"不仅能够保护数据安全\",{\"1\":{\"470\":1}}],[\"不仅如此\",{\"1\":{\"438\":1}}],[\"不新鲜\",{\"1\":{\"438\":1}}],[\"不擅长分析性工作\",{\"1\":{\"436\":1}}],[\"不支持锁升级\",{\"1\":{\"1244\":1}}],[\"不支持\",{\"1\":{\"422\":1,\"676\":1,\"1248\":1}}],[\"不满足\",{\"1\":{\"933\":1,\"1407\":1}}],[\"不满足条件\",{\"1\":{\"395\":1}}],[\"不满足就吃不了\",{\"1\":{\"194\":1}}],[\"不存在则返回null\",{\"1\":{\"1039\":2,\"1040\":2}}],[\"不存在时会返回默认值\",{\"1\":{\"688\":1}}],[\"不存在\",{\"1\":{\"384\":1,\"852\":3}}],[\"不包括自己\",{\"1\":{\"356\":1}}],[\"不包含前导零\",{\"1\":{\"309\":1}}],[\"不包含\",{\"1\":{\"77\":4,\"291\":1}}],[\"不需要知道\",{\"1\":{\"1132\":1}}],[\"不需要加锁\",{\"1\":{\"1291\":1}}],[\"不需要加\",{\"1\":{\"1112\":1}}],[\"不需要创建\",{\"1\":{\"1102\":1}}],[\"不需要从根节点开始\",{\"1\":{\"880\":1}}],[\"不需要再搜了\",{\"1\":{\"822\":1}}],[\"不需要再跟别的前缀和组合\",{\"1\":{\"261\":1}}],[\"不需要反转\",{\"1\":{\"682\":1}}],[\"不需要\",{\"1\":{\"565\":1}}],[\"不需要进行页面渲染和数据处理\",{\"1\":{\"532\":1}}],[\"不需要包含业务逻辑\",{\"1\":{\"518\":1}}],[\"不需要初始化dist数组\",{\"1\":{\"356\":1}}],[\"不需要借位\",{\"1\":{\"328\":1}}],[\"不用深究\",{\"1\":{\"1184\":1}}],[\"不用引号\",{\"1\":{\"1117\":1}}],[\"不用真实地打开浏览器就能测试\",{\"1\":{\"559\":1}}],[\"不用自己整合各种框架\",{\"1\":{\"557\":1}}],[\"不用自己管理\",{\"1\":{\"557\":1}}],[\"不用写\",{\"1\":{\"557\":1}}],[\"不用担心重复添加脏数据\",{\"1\":{\"526\":1}}],[\"不用再作为查询条件\",{\"1\":{\"525\":1}}],[\"不用全部遍历\",{\"1\":{\"327\":1,\"328\":1}}],[\"不用判重\",{\"1\":{\"221\":1}}],[\"不重复的\",{\"1\":{\"919\":1}}],[\"不重复不遗漏地组成带分数表示的全部种数\",{\"1\":{\"291\":1}}],[\"不重不漏地经过每个点恰好一次\",{\"1\":{\"312\":1}}],[\"不连续\",{\"0\":{\"303\":1}}],[\"不妨称为\",{\"1\":{\"274\":1}}],[\"不断通过切换线程\",{\"1\":{\"1220\":1}}],[\"不断二分递归建立左子树和右子树\",{\"1\":{\"814\":1}}],[\"不断更新\",{\"1\":{\"705\":1}}],[\"不断向上寻找最初的根节点\",{\"1\":{\"273\":1}}],[\"不断往上查找祖先\",{\"1\":{\"270\":1}}],[\"不过都被注释了\",{\"1\":{\"1149\":1}}],[\"不过存储空间是映射的本地\",{\"1\":{\"676\":1}}],[\"不过如果注销用户名多了\",{\"1\":{\"613\":1}}],[\"不过要先进行管理员校验\",{\"1\":{\"578\":1}}],[\"不过有可能点击\",{\"1\":{\"576\":1}}],[\"不过缺点就是架构更复杂\",{\"1\":{\"534\":1}}],[\"不过\",{\"1\":{\"304\":1}}],[\"不过具体问题还得具体分析\",{\"1\":{\"234\":1}}],[\"不过此时会很快\",{\"1\":{\"216\":1}}],[\"不够则增加\",{\"1\":{\"173\":1}}],[\"不理解\",{\"1\":{\"162\":1}}],[\"不知道哪错了\",{\"1\":{\"157\":1}}],[\"不允许直接使用\",{\"1\":{\"129\":1}}],[\"不想手动修改排行榜\",{\"1\":{\"129\":1}}],[\"不选\",{\"1\":{\"795\":1,\"893\":1}}],[\"不选择元素\",{\"1\":{\"178\":1}}],[\"不选当前数\",{\"1\":{\"126\":1}}],[\"不选任何数\",{\"1\":{\"126\":1}}],[\"不能让这个被构造的对象被其他线程可见\",{\"1\":{\"1478\":1}}],[\"不能对基本数据类型变量重新赋值\",{\"1\":{\"1467\":1}}],[\"不能对聚合函数进行判断\",{\"1\":{\"933\":1}}],[\"不能带来巨大的价值\",{\"1\":{\"1429\":1}}],[\"不能进行重排序\",{\"1\":{\"1418\":1}}],[\"不能多继承可以实现多个接口\",{\"1\":{\"1330\":1}}],[\"不能保证数据的实时一致性\",{\"1\":{\"1295\":1}}],[\"不能简单的将\",{\"1\":{\"1191\":1}}],[\"不能中断任何线程\",{\"1\":{\"1060\":1}}],[\"不能写入\",{\"1\":{\"1005\":1}}],[\"不能修改\",{\"1\":{\"1005\":1}}],[\"不能被重排序\",{\"1\":{\"1476\":1}}],[\"不能被100整除时\",{\"1\":{\"984\":1}}],[\"不能被其他普通运营人员\",{\"1\":{\"36\":1}}],[\"不能重排序\",{\"1\":{\"1476\":1}}],[\"不能重名\",{\"1\":{\"978\":1}}],[\"不能重复加入\",{\"1\":{\"526\":1}}],[\"不能创建两个名称相同的数据库\",{\"1\":{\"913\":1}}],[\"不能实现外部的访问\",{\"1\":{\"668\":1}}],[\"不能超过\",{\"1\":{\"502\":1}}],[\"不能行动的玩家判负\",{\"1\":{\"395\":1}}],[\"不能开到\",{\"1\":{\"263\":1}}],[\"不能小于当前所在格子的数字与权值之和\",{\"1\":{\"196\":1}}],[\"不能为负数\",{\"1\":{\"122\":1}}],[\"不是顺序执行的\",{\"1\":{\"1418\":1}}],[\"不是最新版本的值了\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"不是和所要找的\",{\"1\":{\"1317\":1}}],[\"不是脏\",{\"1\":{\"1316\":2}}],[\"不是用来解决共享对象的多线程访问问题的\",{\"1\":{\"1309\":1}}],[\"不是线程安全的\",{\"1\":{\"1280\":1}}],[\"不是直接调用注册的方法\",{\"1\":{\"1184\":1}}],[\"不是有序的\",{\"1\":{\"973\":1}}],[\"不是树结构最下面的节点\",{\"1\":{\"958\":1}}],[\"不是起点\",{\"1\":{\"360\":1}}],[\"不是一定\",{\"1\":{\"354\":1}}],[\"不是c语言的内置数据类型\",{\"1\":{\"243\":1}}],[\"不是终点\",{\"1\":{\"215\":1}}],[\"不是\",{\"1\":{\"115\":1,\"373\":1,\"380\":1,\"388\":1,\"794\":1,\"838\":1,\"931\":1}}],[\"不到\",{\"1\":{\"109\":1}}],[\"不会对写\",{\"1\":{\"1477\":1}}],[\"不会改变程序执行结果的重排序\",{\"1\":{\"1423\":1}}],[\"不会出现两个关键字散列值相同\",{\"1\":{\"1306\":1}}],[\"不会取变量\",{\"1\":{\"1117\":1}}],[\"不会执行\",{\"1\":{\"1117\":1}}],[\"不会用到比\",{\"1\":{\"797\":1}}],[\"不会被阻塞在\",{\"1\":{\"1406\":1}}],[\"不会被转化为路径\",{\"1\":{\"542\":1}}],[\"不会被删除则输出\",{\"1\":{\"99\":1}}],[\"不会影响用户体验\",{\"1\":{\"28\":1}}],[\"不为0则更新同步状态\",{\"1\":{\"1240\":1}}],[\"不为空就加入堆中\",{\"1\":{\"789\":1}}],[\"不为空\",{\"1\":{\"128\":1,\"215\":1,\"355\":1}}],[\"不为\",{\"1\":{\"56\":1,\"1272\":1,\"1283\":1,\"1284\":2,\"1301\":1,\"1302\":1,\"1316\":1}}],[\"不管运行多少次都是小于\",{\"1\":{\"1482\":1}}],[\"不管怎么重排序\",{\"1\":{\"1418\":1}}],[\"不管\",{\"1\":{\"1392\":1}}],[\"不管其是存放的数据块还是奇偶校验块\",{\"1\":{\"1095\":1}}],[\"不管条件的值如何\",{\"1\":{\"989\":1}}],[\"不管是氛围还是商业\",{\"1\":{\"41\":1}}],[\"不管热评的算法如何变化\",{\"1\":{\"40\":1}}],[\"不容易出错\",{\"1\":{\"37\":1}}],[\"不值得用户重试\",{\"1\":{\"37\":1}}],[\"不对用户暴露用户无法处理和不值得处理的错误\",{\"1\":{\"37\":1}}],[\"不同点\",{\"1\":{\"1295\":1,\"1353\":1}}],[\"不同的情况做不同的处理\",{\"1\":{\"1496\":1}}],[\"不同的请求线程\",{\"1\":{\"1309\":1}}],[\"不同的线程处理不同段的数据\",{\"1\":{\"1220\":1}}],[\"不同的是\",{\"1\":{\"1205\":1}}],[\"不同的是它是⽤\",{\"1\":{\"229\":1}}],[\"不同的键可能会产生相同的哈希值\",{\"1\":{\"971\":1}}],[\"不同的数据库有不同的实现\",{\"1\":{\"935\":1}}],[\"不同颜色\",{\"1\":{\"362\":1}}],[\"不同为\",{\"1\":{\"338\":1}}],[\"不同为1\",{\"1\":{\"337\":1}}],[\"不同位置的数字一样的数对算不同的数对\",{\"1\":{\"324\":1}}],[\"不同方案\",{\"1\":{\"287\":1}}],[\"不同目标可能在同一位置\",{\"1\":{\"263\":1}}],[\"不同规则的决策叠加作用\",{\"1\":{\"40\":1}}],[\"不同\",{\"1\":{\"25\":1,\"72\":1,\"1095\":1,\"1383\":1}}],[\"因子\",{\"1\":{\"40\":1}}],[\"因子机的重难点是需要管理各种数据获取的拓扑关系\",{\"1\":{\"40\":1}}],[\"因子机\",{\"1\":{\"40\":2}}],[\"因为同步队列是\",{\"1\":{\"1500\":1}}],[\"因为构造函数中操作\",{\"1\":{\"1478\":1}}],[\"因为普通方法无法修改\",{\"1\":{\"1472\":1}}],[\"因为自旋会消耗\",{\"1\":{\"1447\":1}}],[\"因为自己就包含了注册表信息\",{\"1\":{\"1158\":1}}],[\"因为每个线程所操作的都是当前最新的版本数据\",{\"1\":{\"1429\":1}}],[\"因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化\",{\"1\":{\"363\":1}}],[\"因为线程提交\",{\"1\":{\"1361\":1}}],[\"因为只有线程在删除数据时\",{\"1\":{\"1326\":1}}],[\"因为哈希表大小总是为\",{\"1\":{\"1306\":1}}],[\"因为尽管多个读线程从同一个数据容器中读取数据\",{\"1\":{\"1290\":1}}],[\"因为时间非常短\",{\"1\":{\"1220\":1}}],[\"因为缓存是存储在内存中的\",{\"1\":{\"1200\":1}}],[\"因为如果剔除了\",{\"1\":{\"1191\":1}}],[\"因为常量的定义都是大写\",{\"1\":{\"1147\":1}}],[\"因为它需要被依赖的对象实现不必要的接口\",{\"1\":{\"1133\":1}}],[\"因为它们是本来就有的\",{\"1\":{\"869\":1}}],[\"因为此时name只读\",{\"1\":{\"1114\":1}}],[\"因为左子树的所有节点都要小于根节点的值\",{\"1\":{\"899\":1}}],[\"因为烂橘子不止一个\",{\"1\":{\"869\":1}}],[\"因为遍历图是需要\",{\"1\":{\"820\":1}}],[\"因为本题要求高度平衡\",{\"1\":{\"814\":1}}],[\"因为本质是一样的\",{\"1\":{\"411\":1}}],[\"因为字符串中只存在小写字母\",{\"1\":{\"802\":1}}],[\"因为没有数可以选了\",{\"1\":{\"795\":1}}],[\"因为链表已按升序排列\",{\"1\":{\"789\":1}}],[\"因为要删除该结点\",{\"1\":{\"777\":1}}],[\"因为要求最小值\",{\"1\":{\"312\":1}}],[\"因为不可能在调用\",{\"1\":{\"1275\":1}}],[\"因为不可能组成有效的括号\",{\"1\":{\"846\":1}}],[\"因为不管是二叉搜索数还是红黑数\",{\"1\":{\"958\":1}}],[\"因为不能比这个更深了\",{\"1\":{\"755\":1}}],[\"因为不使用session\",{\"1\":{\"446\":1}}],[\"因为更新当前的右指针的时候\",{\"1\":{\"725\":1}}],[\"因为我自己有加速器\",{\"1\":{\"665\":1}}],[\"因为我们可以重复选第\",{\"1\":{\"893\":1}}],[\"因为我们可以继续选第\",{\"1\":{\"795\":1}}],[\"因为我们的\",{\"1\":{\"671\":1}}],[\"因为我们之前已经选择的是\",{\"1\":{\"559\":1}}],[\"因为我们是从小到大遍历的\",{\"1\":{\"373\":1}}],[\"因为业务层处理多表分页比较麻烦\",{\"1\":{\"525\":1}}],[\"因为关联逻辑并不复杂\",{\"1\":{\"525\":1}}],[\"因为数据库中的查询大多是基于\",{\"1\":{\"513\":1}}],[\"因为数据范围是从0开始的\",{\"1\":{\"263\":1}}],[\"因为分析型业务需要大量的\",{\"1\":{\"436\":1}}],[\"因为存的都是英文字母\",{\"1\":{\"412\":1}}],[\"因为围棋交战双方分别只能落黑子和白子\",{\"1\":{\"395\":1}}],[\"因为从\",{\"1\":{\"389\":1}}],[\"因为你要去问的都是男孩子\",{\"1\":{\"363\":1}}],[\"因为再给边排序的时候是按照边的权重进行排序的\",{\"1\":{\"361\":1}}],[\"因为是从\",{\"1\":{\"822\":1}}],[\"因为是倒序数组\",{\"1\":{\"328\":1}}],[\"因为是严格递增\",{\"1\":{\"66\":1}}],[\"因为剩下的这部分一定是大于前面的\",{\"1\":{\"318\":1}}],[\"因为零是起点\",{\"1\":{\"312\":1}}],[\"因为r最大可取到10^9\",{\"1\":{\"263\":1}}],[\"因为题目没有特殊要求\",{\"1\":{\"688\":1}}],[\"因为题目的内存限制\",{\"1\":{\"263\":1}}],[\"因为题目保证有解\",{\"1\":{\"179\":1}}],[\"因为当前容器不会添加任何元素\",{\"1\":{\"1291\":1}}],[\"因为当\",{\"1\":{\"261\":1}}],[\"因为在\",{\"1\":{\"1283\":1}}],[\"因为在集群环境中\",{\"1\":{\"1157\":1}}],[\"因为在这类函数的最后一句后面会隐式地执行\",{\"1\":{\"1020\":1}}],[\"因为在一些情况\",{\"1\":{\"216\":1}}],[\"因为在没有达到终点之前\",{\"1\":{\"216\":1}}],[\"因为这是一种互斥同步\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"因为这些牛在第\",{\"1\":{\"182\":1}}],[\"因为这决定了是否能到达终点以及路径是否最短\",{\"1\":{\"142\":1}}],[\"因为牛不会死\",{\"1\":{\"182\":1}}],[\"因为第一年只有一头成熟的母牛\",{\"1\":{\"182\":1}}],[\"因为和为\",{\"1\":{\"135\":1}}],[\"因为起点不受伤害\",{\"1\":{\"110\":1}}],[\"因为所有房主都没有回答\",{\"1\":{\"108\":1}}],[\"因为底层的\",{\"1\":{\"61\":1}}],[\"因为\",{\"1\":{\"58\":1,\"338\":1,\"372\":1,\"383\":1,\"502\":1,\"546\":1,\"664\":1,\"795\":1,\"822\":1,\"840\":1,\"894\":1,\"899\":1,\"1075\":1,\"1264\":1,\"1295\":1,\"1305\":1,\"1334\":1,\"1384\":1,\"1385\":1,\"1407\":1,\"1439\":1,\"1496\":3}}],[\"因为产品形态上只存在\",{\"1\":{\"56\":1}}],[\"因为上文提到\",{\"1\":{\"37\":1}}],[\"因为发评的异步处理端到端延迟基本在2s以内\",{\"1\":{\"28\":1}}],[\"因此到这里就应该清楚了\",{\"1\":{\"1505\":1}}],[\"因此同步队列选择了带头结点的链式存储结构\",{\"1\":{\"1504\":1}}],[\"因此基本数据类型变量不能被改变\",{\"1\":{\"1467\":1}}],[\"因此线程\",{\"1\":{\"1456\":1}}],[\"因此两个线程就都达到了同步点\",{\"1\":{\"1399\":1}}],[\"因此也叫做非阻塞同步\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"因此执行\",{\"1\":{\"1375\":1}}],[\"因此整体上提升了系统的响应速度\",{\"1\":{\"1357\":1}}],[\"因此系统就没有对象需要守护的了\",{\"1\":{\"1340\":1}}],[\"因此系统设计层面需要提供更多元\",{\"1\":{\"40\":1}}],[\"因此前向搜索脏\",{\"1\":{\"1317\":1}}],[\"因此前导0在数组前面\",{\"1\":{\"330\":1}}],[\"因此扩大搜索范围\",{\"1\":{\"1316\":1}}],[\"因此方法执行完的结果为\",{\"1\":{\"1316\":1}}],[\"因此读线程不会存在等待的情况\",{\"1\":{\"1295\":1}}],[\"因此将旧的数组引用指向新的数组\",{\"1\":{\"1294\":1}}],[\"因此会通过引用\",{\"1\":{\"1285\":1}}],[\"因此会导致其他用户也无法注册这个用户名\",{\"1\":{\"613\":1}}],[\"因此代码走到了第\",{\"1\":{\"1284\":1}}],[\"因此可能在统计的时候有其他线程正在执行插入或删除操作\",{\"1\":{\"1275\":1}}],[\"因此可以执行顺序可以是\",{\"1\":{\"1418\":1}}],[\"因此可以通过\",{\"1\":{\"1283\":1}}],[\"因此可以说明\",{\"1\":{\"1283\":1}}],[\"因此可以安全的将新值\",{\"1\":{\"1266\":1}}],[\"因此可以将原来的二维数组压缩至一维数组\",{\"1\":{\"894\":1}}],[\"因此可以将问题转化为在一个数组中选择不相邻的元素\",{\"1\":{\"178\":1}}],[\"因此可以去掉第一个维度\",{\"1\":{\"797\":1}}],[\"因此可以递推的每次乘\",{\"1\":{\"389\":1}}],[\"因此可以用\",{\"1\":{\"338\":1}}],[\"因此通过scheduledfuture\",{\"1\":{\"1367\":1}}],[\"因此通过\",{\"1\":{\"1272\":1}}],[\"因此我们对每个节点引入一个标志\",{\"1\":{\"802\":1}}],[\"因此我们针对数据源的特点做了多级缓存\",{\"1\":{\"40\":1}}],[\"因此每个\",{\"1\":{\"1250\":1}}],[\"因此每个节点最多有\",{\"1\":{\"802\":1}}],[\"因此每一个组件都是一个独立的包\",{\"1\":{\"540\":1}}],[\"因此利用迭代的思想\",{\"1\":{\"731\":1}}],[\"因此还需要维护当前最小值\",{\"1\":{\"705\":1}}],[\"因此这个布隆过滤器大约占用\",{\"1\":{\"613\":1}}],[\"因此要考虑\",{\"1\":{\"613\":1}}],[\"因此要贪心的考虑\",{\"1\":{\"119\":1}}],[\"因此数据也不会在缓存中\",{\"1\":{\"613\":1}}],[\"因此布隆过滤器会出现\",{\"1\":{\"613\":1}}],[\"因此页面加载速度相对较快\",{\"1\":{\"531\":1}}],[\"因此最终结果\",{\"1\":{\"380\":1}}],[\"因此不仅需要将基数\",{\"1\":{\"380\":1}}],[\"因此其计算方法也是我们比较熟悉的\",{\"1\":{\"220\":1}}],[\"因此只能说这个数量是个估计值\",{\"1\":{\"1275\":1}}],[\"因此只有某个点染色失败才能立刻\",{\"1\":{\"362\":1}}],[\"因此只有当小红当前血量大于怪物的战斗力时才可经过该点\",{\"1\":{\"180\":1}}],[\"因此只需要迭代查询两次即可\",{\"1\":{\"56\":1}}],[\"因此你需要输出答案对\",{\"1\":{\"167\":1}}],[\"因此需要配合使用一个\",{\"1\":{\"1407\":1}}],[\"因此需要对\",{\"1\":{\"354\":1}}],[\"因此需要具备高并发处理能力\",{\"1\":{\"151\":1}}],[\"因此需要放到消息队列中处理\",{\"1\":{\"28\":1}}],[\"因此直接模拟即可\",{\"1\":{\"119\":1}}],[\"因此贪心选个绝对值最小的数字当最后那个负数即可\",{\"1\":{\"104\":1}}],[\"因此做\",{\"1\":{\"61\":1}}],[\"因此必须判定\",{\"1\":{\"58\":1}}],[\"因此在线程\",{\"1\":{\"1285\":1}}],[\"因此在第\",{\"1\":{\"1284\":1}}],[\"因此在右子树中寻找第\",{\"1\":{\"712\":1}}],[\"因此在左子树中寻找第\",{\"1\":{\"712\":1}}],[\"因此在\",{\"1\":{\"40\":1,\"1318\":1}}],[\"因此按照评论维度进行拆分仍然存在并发事务问题\",{\"1\":{\"37\":1}}],[\"因此该操作是最先感知到读热点存在的\",{\"1\":{\"33\":1}}],[\"因此选用\",{\"1\":{\"31\":1}}],[\"因此结合查询逻辑\",{\"1\":{\"30\":1}}],[\"因此独立设计第3张表\",{\"1\":{\"30\":1}}],[\"因此\",{\"1\":{\"25\":1,\"26\":1,\"27\":1,\"28\":2,\"33\":1,\"41\":1,\"182\":1,\"308\":1,\"373\":1,\"380\":1,\"789\":1,\"1078\":1,\"1218\":2,\"1221\":1,\"1233\":1,\"1239\":1,\"1264\":1,\"1268\":1,\"1284\":1,\"1286\":1,\"1295\":1,\"1309\":1,\"1313\":2,\"1325\":1,\"1326\":3,\"1330\":1,\"1336\":1,\"1340\":1,\"1350\":1,\"1357\":2,\"1367\":1,\"1368\":1,\"1371\":1,\"1376\":1,\"1382\":1,\"1385\":1,\"1392\":1,\"1398\":1,\"1406\":2,\"1407\":1,\"1417\":1,\"1418\":1,\"1419\":1,\"1420\":2,\"1436\":1,\"1454\":1,\"1471\":1,\"1475\":2,\"1476\":2,\"1482\":1,\"1484\":1,\"1486\":1,\"1504\":2,\"1506\":1}}],[\"因此一般会作为一个独立系统拆分设计\",{\"1\":{\"23\":1}}],[\"将新值赋值给变量\",{\"1\":{\"1482\":1}}],[\"将新的键值对插入到红黑树中\",{\"1\":{\"1272\":1}}],[\"将新的区间放入ans数组中\",{\"1\":{\"431\":1}}],[\"将工作内存同步到主内存中就需要执行\",{\"1\":{\"1482\":1}}],[\"将计算后的值再赋值给变量a\",{\"1\":{\"1482\":1}}],[\"将对象头中的\",{\"1\":{\"1446\":1}}],[\"将对象头的偏向锁指向当前线程\",{\"1\":{\"1442\":1}}],[\"将阻塞当前线程\",{\"1\":{\"1404\":1}}],[\"将抛出brokenbarrierexception\",{\"1\":{\"1393\":1}}],[\"将屏障重置为初始状态\",{\"1\":{\"1393\":1}}],[\"将值\",{\"1\":{\"1392\":1}}],[\"将它们一个个列举出来\",{\"1\":{\"1392\":1}}],[\"将它们的子节点加入队列\",{\"1\":{\"133\":1}}],[\"将不会对正在执行任务的线程有任何影响\",{\"1\":{\"1375\":1}}],[\"将提交的任务转换成scheduledfuturetask\",{\"1\":{\"1370\":1}}],[\"将待执行时间越近的任务放在在队列的队头位置\",{\"1\":{\"1369\":1}}],[\"将消费者线程移入等待队列中\",{\"1\":{\"1348\":1}}],[\"将线程移入到\",{\"1\":{\"1347\":1}}],[\"将线程移入到notfull等待队列中\",{\"1\":{\"1347\":1}}],[\"将线程设置为守护线程\",{\"1\":{\"1060\":1}}],[\"将entry的key置为null\",{\"1\":{\"1308\":1}}],[\"将散列值相同的元素都保存到一个链表中\",{\"1\":{\"1306\":1}}],[\"将关键字映射到数组的不同位置\",{\"1\":{\"1306\":1}}],[\"将关联映射中的值改为新值\",{\"1\":{\"1074\":1}}],[\"将旧数组引用指向新的数组\",{\"1\":{\"1294\":1}}],[\"将队列的\",{\"1\":{\"1284\":1}}],[\"将插入的新\",{\"1\":{\"1317\":2}}],[\"将插入的\",{\"1\":{\"1283\":1}}],[\"将多线程执行变成串行化\",{\"1\":{\"1280\":1}}],[\"将多维数组转化为字符串\",{\"1\":{\"1002\":1}}],[\"将头结点的状态更改为\",{\"1\":{\"1252\":1}}],[\"将头结点从等待队列中移除\",{\"1\":{\"1252\":1}}],[\"将头结点删除\",{\"1\":{\"403\":1}}],[\"将同步状态减去读状态即可\",{\"1\":{\"1243\":1}}],[\"将服务实例配置\",{\"1\":{\"1182\":1}}],[\"将配置文件\",{\"1\":{\"1178\":1}}],[\"将配置文件中的配置项放到\",{\"1\":{\"1150\":1}}],[\"将集群中的\",{\"1\":{\"1165\":1}}],[\"将集群节点的\",{\"1\":{\"1165\":1}}],[\"将集合的所有元素设置为\",{\"1\":{\"1081\":1}}],[\"将业务数据存储在云上\",{\"1\":{\"1094\":1}}],[\"将元素添加到队尾\",{\"1\":{\"1077\":1}}],[\"将元素添加到队首\",{\"1\":{\"1077\":1}}],[\"将元素e放在index位置\",{\"1\":{\"1072\":1}}],[\"将char\",{\"1\":{\"1069\":1}}],[\"将任意基本类型或引用类型转换为字符串\",{\"1\":{\"1069\":1}}],[\"将任务放入阻塞队列中\",{\"1\":{\"1370\":1}}],[\"将任务分散到不同的节点执行\",{\"1\":{\"484\":1}}],[\"将任务信息存储到数据库中\",{\"1\":{\"484\":1}}],[\"将此\",{\"1\":{\"1046\":1}}],[\"将实例中的值更新为新值\",{\"1\":{\"1385\":1}}],[\"将实例的生成交给子类\",{\"0\":{\"966\":1}}],[\"将实参的引用\",{\"1\":{\"1018\":1}}],[\"将实参的初始值拷贝给形参\",{\"1\":{\"1017\":1}}],[\"将得到\",{\"1\":{\"979\":5}}],[\"将大表中的一些基础字段放在一张表当中\",{\"1\":{\"938\":1}}],[\"将一列数据作为一个整体\",{\"1\":{\"932\":1}}],[\"将一个对象拆分成\",{\"1\":{\"1095\":1}}],[\"将一个容器中重复的元素删除\",{\"1\":{\"422\":1}}],[\"将一个新的节点x插入下标是k的后面\",{\"1\":{\"403\":1}}],[\"将一个数的各二进制位全部右移若干位\",{\"1\":{\"338\":1}}],[\"将一个数拆为完全平方数之和\",{\"1\":{\"115\":1}}],[\"将一个运算对象的各二进制位全部左移若干位\",{\"1\":{\"338\":1}}],[\"将一个\",{\"1\":{\"245\":1}}],[\"将一个整数的每一位数字进行转换\",{\"1\":{\"161\":1}}],[\"将该实例不被多线程共享即可\",{\"1\":{\"1309\":1}}],[\"将该entry的value也置为null\",{\"1\":{\"1308\":1}}],[\"将该节点尾插入到同步队列中\",{\"1\":{\"1252\":1}}],[\"将该节点移入到同步队列中去\",{\"1\":{\"1252\":1}}],[\"将该线程从等待队列中转移到同步队列中\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"将该字符串对应的系统变量转换为integer\",{\"1\":{\"1069\":1}}],[\"将该字段值置为\",{\"1\":{\"927\":1}}],[\"将该行的第一个数变成\",{\"1\":{\"385\":1}}],[\"将会立即返回\",{\"1\":{\"1258\":1}}],[\"将会报错\",{\"1\":{\"915\":1}}],[\"将会有很多种排列方法\",{\"1\":{\"281\":1}}],[\"将两链表拆分开\",{\"1\":{\"888\":1}}],[\"将两个链表看成是相同长度的进行遍历\",{\"1\":{\"699\":1}}],[\"将两个有序的子链表合并成一个有序的链表\",{\"1\":{\"134\":1}}],[\"将初始的烂橘子入队\",{\"1\":{\"870\":1}}],[\"将bfs过程提取为单独的一个方法\",{\"1\":{\"870\":1}}],[\"将以\",{\"1\":{\"864\":1}}],[\"将链表断开\",{\"1\":{\"834\":1}}],[\"将链表分割\",{\"1\":{\"833\":1}}],[\"将小的结点接入临时链表后面\",{\"1\":{\"833\":1}}],[\"将小的放入一个临时序列\",{\"1\":{\"318\":1}}],[\"将整个序列分为两部分\",{\"1\":{\"833\":1}}],[\"将整个序列均分为两部分\",{\"1\":{\"318\":1}}],[\"将遍历过的陆地淹没\",{\"1\":{\"820\":1}}],[\"将有序数组转换为二叉搜索树\",{\"0\":{\"812\":1},\"1\":{\"812\":1}}],[\"将每层的扩散情况都加入队列\",{\"1\":{\"869\":1}}],[\"将每层最后一个加入到结果中\",{\"1\":{\"737\":1}}],[\"将每次移动的最大值保存在\",{\"1\":{\"857\":1}}],[\"将每一层的节点依次加入队列\",{\"1\":{\"133\":1}}],[\"将最后访问到的节点加入到右视图中\",{\"1\":{\"737\":1}}],[\"将左子树的最右节点指向原来的右子树\",{\"1\":{\"724\":1}}],[\"将左子树插入到右子树的地方\",{\"1\":{\"724\":1}}],[\"将剩下的链表节点两两翻转\",{\"1\":{\"694\":1}}],[\"将上述两个过程的结果连接起来\",{\"1\":{\"681\":1}}],[\"将上次的余数×10再加上当前位的数字\",{\"1\":{\"330\":1}}],[\"将第i个元素设置为val\",{\"1\":{\"1036\":1}}],[\"将第一行全部变成0\",{\"1\":{\"1000\":1}}],[\"将第\",{\"1\":{\"681\":1}}],[\"将第k位变成v\",{\"1\":{\"422\":1}}],[\"将已知编码的byte\",{\"1\":{\"1069\":1}}],[\"将已经注销的用户名放在这个\",{\"1\":{\"613\":1}}],[\"将已访问状态重置为未访问\",{\"1\":{\"235\":1}}],[\"将已访问标记为\",{\"1\":{\"235\":1}}],[\"将文件名修改为注册页面\",{\"1\":{\"587\":1}}],[\"将框架预生成的样式改成自己想要的样式\",{\"1\":{\"583\":1}}],[\"将用户数据插入到数据库\",{\"1\":{\"568\":1}}],[\"将密码进行混淆\",{\"1\":{\"568\":1}}],[\"将生成的代码拖到对应的包路径下之后\",{\"1\":{\"567\":1}}],[\"将题目题目关联表中已有的记录删除\",{\"1\":{\"526\":1}}],[\"将前端的状态设置到任务配置对象中\",{\"1\":{\"482\":1}}],[\"将前导0置于尾部\",{\"1\":{\"330\":1}}],[\"将返回结果存入\",{\"1\":{\"448\":1,\"453\":1,\"459\":1}}],[\"将指定线段区间完全覆盖\",{\"1\":{\"430\":1}}],[\"将下面代码粘贴到配置文件中\",{\"1\":{\"671\":1}}],[\"将下面所有行的当且列的值变成\",{\"1\":{\"385\":1}}],[\"将下标是k的点后面的点删掉\",{\"1\":{\"403\":1}}],[\"将当前处理器缓存行的数据写回系统内存\",{\"1\":{\"1454\":1}}],[\"将当前节点通过\",{\"1\":{\"1505\":1}}],[\"将当前节点尾插入的方式插入同步队列中\",{\"1\":{\"1504\":1}}],[\"将当前节点\",{\"1\":{\"1283\":1}}],[\"将当前节点插入到等待对列之后\",{\"1\":{\"1251\":1}}],[\"将当前节点包装成\",{\"1\":{\"1251\":1}}],[\"将当前节点指向左子树\",{\"1\":{\"724\":1}}],[\"将当前线程构建成node类型\",{\"1\":{\"1504\":1}}],[\"将当前线程添加到等待队列中\",{\"1\":{\"1251\":1}}],[\"将当前线程包装成node\",{\"1\":{\"1251\":2}}],[\"将当前字符添加到当前节点对应的子节点位置\",{\"1\":{\"803\":1}}],[\"将当前行的首位变成1\",{\"1\":{\"385\":1}}],[\"将当前元素加入到队尾\",{\"1\":{\"410\":1}}],[\"将当前元素加入队尾\",{\"1\":{\"410\":1}}],[\"将当前元素入栈\",{\"1\":{\"128\":1}}],[\"将当前元素的下标入栈\",{\"1\":{\"128\":1}}],[\"将绝对值最大的行换到最顶端\",{\"1\":{\"385\":1}}],[\"将这个变量所在缓存行的数据写回到系统内存\",{\"1\":{\"1454\":1}}],[\"将这\",{\"1\":{\"384\":1,\"999\":2}}],[\"将这一位相减后的结果压入c中\",{\"1\":{\"328\":1}}],[\"将连通块逐渐扩大\",{\"1\":{\"360\":1}}],[\"将所有的值添加到给定的集合中\",{\"1\":{\"1081\":1}}],[\"将所有元素的初值为0\",{\"1\":{\"1000\":1}}],[\"将所有无法匹配的括号的位置全部置\",{\"1\":{\"845\":1}}],[\"将所有点分成\",{\"1\":{\"362\":1}}],[\"将所有存在交集的区间合并\",{\"1\":{\"342\":1}}],[\"将所有值排序\",{\"1\":{\"341\":1}}],[\"将问题转变成统计数列中\",{\"1\":{\"324\":1}}],[\"将问题转化为一个选择问题\",{\"1\":{\"178\":1}}],[\"将模板\",{\"1\":{\"322\":1}}],[\"将临时序列放入原序列中\",{\"1\":{\"318\":1}}],[\"将数组中索引为\",{\"1\":{\"1386\":1}}],[\"将数组列表的存储容量削减到其当前大小\",{\"1\":{\"1072\":1}}],[\"将数组转化为字符串\",{\"1\":{\"1002\":1}}],[\"将数据交换给另一个线程\",{\"1\":{\"1399\":1}}],[\"将数据库查询出来的数据放入缓存服务中\",{\"1\":{\"1200\":1}}],[\"将数据填充到模板中\",{\"1\":{\"533\":1}}],[\"将数据填充到页面中的相应位置\",{\"1\":{\"532\":1}}],[\"将数据异步回传给外部广告平台\",{\"1\":{\"151\":1}}],[\"将数字\",{\"1\":{\"281\":1}}],[\"将a串变为b串\",{\"1\":{\"279\":1}}],[\"将标记数组重置为\",{\"1\":{\"235\":1}}],[\"将与之相邻的陆地都变成海水\",{\"1\":{\"229\":1}}],[\"将搜索过的mp\",{\"1\":{\"228\":1}}],[\"将走过的元素标记为\",{\"1\":{\"228\":1}}],[\"将邻边入队\",{\"1\":{\"221\":1}}],[\"将节点插入到同步队列中\",{\"1\":{\"1507\":1}}],[\"将节点状态由\",{\"1\":{\"1505\":1}}],[\"将节点加入到右视图中\",{\"1\":{\"736\":1}}],[\"将节点\",{\"1\":{\"215\":2}}],[\"将起点加入\",{\"1\":{\"215\":1}}],[\"将原数组中的元素复制到新数组中去\",{\"1\":{\"1274\":1}}],[\"将原来的右子树接到左子树的最右边节点\",{\"1\":{\"724\":1}}],[\"将原本的\",{\"1\":{\"664\":1}}],[\"将原\",{\"1\":{\"200\":1}}],[\"将三个数字排序\",{\"1\":{\"167\":1}}],[\"将去重后的点击数据存储到分布式数据库中\",{\"1\":{\"151\":1}}],[\"将花卉依次放置到对应的单元格中\",{\"1\":{\"141\":1}}],[\"将花卉按数量从大到小排序\",{\"1\":{\"141\":1}}],[\"将子网格按被覆盖的次数从大到小排序\",{\"1\":{\"141\":1}}],[\"将玩家加入\",{\"1\":{\"129\":4}}],[\"将玩家和积分加入\",{\"1\":{\"129\":2}}],[\"将\",{\"1\":{\"108\":1,\"120\":1,\"167\":2,\"181\":1,\"224\":1,\"230\":1,\"274\":1,\"279\":1,\"291\":2,\"306\":1,\"338\":2,\"381\":1,\"486\":1,\"513\":2,\"543\":2,\"613\":2,\"664\":2,\"676\":1,\"789\":1,\"926\":1,\"994\":1,\"1062\":2,\"1090\":1,\"1100\":1,\"1155\":1,\"1158\":1,\"1185\":1,\"1264\":1,\"1272\":1,\"1284\":2,\"1317\":1,\"1330\":2,\"1375\":1,\"1408\":1,\"1455\":1,\"1458\":1,\"1482\":1}}],[\"将某个宝石调到其整条项链的前面或者后面去\",{\"1\":{\"103\":1}}],[\"将自然数\",{\"1\":{\"99\":1}}],[\"将另一个数组中剩余的元素直接添加到结果数组中\",{\"1\":{\"92\":1}}],[\"将较小的元素放入结果数组中\",{\"1\":{\"92\":1}}],[\"将相同的字符进行压缩\",{\"1\":{\"82\":1}}],[\"将单元格涂黑\",{\"1\":{\"77\":1}}],[\"将单个评论区内的发评串行处理\",{\"1\":{\"28\":1}}],[\"将坐标转换为0\",{\"1\":{\"77\":1}}],[\"将位置为\",{\"1\":{\"77\":1}}],[\"将字符串转换为char\",{\"1\":{\"1069\":1}}],[\"将字符串转换为boolean类型\",{\"1\":{\"1069\":1}}],[\"将字符串转换为int类型\",{\"1\":{\"1069\":1}}],[\"将字符串转化成字符数组\",{\"1\":{\"1005\":1}}],[\"将字符串看成\",{\"1\":{\"421\":1}}],[\"将字符串\",{\"1\":{\"71\":1,\"306\":2}}],[\"将其移入到等待队列中\",{\"1\":{\"1352\":1}}],[\"将其移入等待队列\",{\"1\":{\"1351\":1}}],[\"将其他的字段放在另外一张表当中\",{\"1\":{\"938\":1}}],[\"将其修改为当前操作时间\",{\"1\":{\"926\":1}}],[\"将其存到服务器上\",{\"1\":{\"574\":1}}],[\"将其等价转换\",{\"1\":{\"384\":1}}],[\"将其赋值为海水\",{\"1\":{\"228\":1}}],[\"将其高度赋值给\",{\"1\":{\"128\":1}}],[\"将其高度修改为任意非负整数值\",{\"1\":{\"66\":1}}],[\"将其拆分为两个子状态\",{\"1\":{\"109\":1}}],[\"将其找出来以便系统可以安排共同的活动\",{\"1\":{\"70\":1}}],[\"将其转换\",{\"1\":{\"25\":1}}],[\"将评论区的所有操作\",{\"1\":{\"37\":1}}],[\"特有方法\",{\"0\":{\"1367\":1}}],[\"特点\",{\"0\":{\"1095\":1}}],[\"特判最中间的数\",{\"1\":{\"375\":1}}],[\"特殊情况\",{\"1\":{\"1326\":2}}],[\"特殊的\",{\"1\":{\"1119\":1}}],[\"特殊\",{\"1\":{\"308\":1}}],[\"特别适合通过\",{\"1\":{\"534\":1}}],[\"特别强调每秒能干多少事儿\",{\"1\":{\"436\":1}}],[\"特别说明\",{\"1\":{\"129\":1}}],[\"特别地\",{\"1\":{\"126\":1,\"248\":1,\"383\":1,\"398\":1}}],[\"特别容易引起集群\",{\"1\":{\"48\":1}}],[\"特别是公共资源有限的应用场景\",{\"1\":{\"1398\":1}}],[\"特别是在面对不理想的数据分布时\",{\"1\":{\"973\":1}}],[\"特别是在冲突解决策略不够高效时\",{\"1\":{\"973\":1}}],[\"特别是数据量大的时候\",{\"1\":{\"534\":1}}],[\"特别是tidb\",{\"1\":{\"40\":1}}],[\"特别是存在\",{\"1\":{\"37\":1}}],[\"特别是诸如\",{\"1\":{\"31\":1}}],[\"特别是一些依赖的变更\",{\"1\":{\"25\":1}}],[\"特别是应用软件对于系统软件的集中的逻辑\",{\"1\":{\"14\":1}}],[\"特征\",{\"1\":{\"40\":1}}],[\"特性是先进先出\",{\"1\":{\"1076\":1}}],[\"特性\",{\"1\":{\"28\":1,\"1283\":1}}],[\"发号施令\",{\"1\":{\"1392\":1}}],[\"发生了改变\",{\"1\":{\"1285\":1}}],[\"发生的相对顺序又可从两个角度去思考\",{\"1\":{\"1283\":1}}],[\"发生缓存\",{\"1\":{\"48\":1}}],[\"发音类似\",{\"1\":{\"801\":1}}],[\"发现一个最优布置来最小化插入屏障的总数几乎是不可能的\",{\"1\":{\"1457\":1}}],[\"发现里面有几个\",{\"1\":{\"1149\":1}}],[\"发现\",{\"1\":{\"725\":1}}],[\"发现会被强制路由至登录页面\",{\"1\":{\"587\":1}}],[\"发布上线\",{\"1\":{\"555\":1}}],[\"发布评论\",{\"1\":{\"22\":1,\"45\":1}}],[\"发起异步请求\",{\"1\":{\"532\":1}}],[\"发射了一个速度为\",{\"1\":{\"97\":1}}],[\"发送了一个消息告诉线程\",{\"1\":{\"1456\":1}}],[\"发送心跳续约\",{\"1\":{\"1191\":1}}],[\"发送过来的注册信息保存起来的\",{\"1\":{\"1186\":1}}],[\"发送注册请求的类是\",{\"1\":{\"1184\":1}}],[\"发送\",{\"1\":{\"60\":1,\"448\":1,\"1184\":1,\"1185\":1}}],[\"发通知等\",{\"1\":{\"28\":1}}],[\"写的内存屏障都会被省略\",{\"1\":{\"1477\":1}}],[\"写的核心逻辑\",{\"0\":{\"49\":1}}],[\"写过程没有重排序\",{\"1\":{\"1475\":1}}],[\"写final域\",{\"1\":{\"1475\":1}}],[\"写普通域\",{\"1\":{\"1475\":1}}],[\"写一个例子来加深理解\",{\"1\":{\"1469\":1}}],[\"写与下面可能有的\",{\"1\":{\"1457\":1}}],[\"写重排序\",{\"1\":{\"1457\":2,\"1477\":1}}],[\"写是在前面和后面分别插入内存屏障\",{\"1\":{\"1457\":1}}],[\"写操作的后面插入一个\",{\"1\":{\"1457\":1}}],[\"写操作的前面插入一个\",{\"1\":{\"1457\":1}}],[\"写后的状态图\",{\"1\":{\"1456\":1}}],[\"写后读\",{\"1\":{\"1418\":1}}],[\"写后读的可靠性与实时性要求高等特征\",{\"1\":{\"26\":1}}],[\"写后写\",{\"1\":{\"1418\":1}}],[\"写缓冲区\",{\"1\":{\"1418\":1}}],[\"写共享变量来完成隐式通信\",{\"1\":{\"1416\":1}}],[\"写线程会等待\",{\"1\":{\"1295\":1}}],[\"写线程对数组引用的修改对读线程是可见的\",{\"1\":{\"1294\":1}}],[\"写状态由同步状态的低\",{\"1\":{\"1240\":1}}],[\"写锁释放通过重写\",{\"1\":{\"1240\":1}}],[\"写锁未被任何线程获取\",{\"1\":{\"1239\":1}}],[\"写锁的释放\",{\"0\":{\"1240\":1}}],[\"写锁的实现依然也是采用这种方式\",{\"1\":{\"1239\":1}}],[\"写锁的获取\",{\"0\":{\"1239\":1}}],[\"写锁详解\",{\"0\":{\"1238\":1}}],[\"写锁是怎样获取和释放的\",{\"1\":{\"1237\":1}}],[\"写锁能够降级成为读锁\",{\"1\":{\"1237\":1,\"1244\":1}}],[\"写锁获取之后能够再次获取写锁\",{\"1\":{\"1237\":1}}],[\"写速度最高可以高达\",{\"1\":{\"1095\":1}}],[\"写法2\",{\"1\":{\"1059\":1,\"1062\":1}}],[\"写法1\",{\"1\":{\"1059\":1,\"1062\":1}}],[\"写法示例\",{\"1\":{\"255\":1}}],[\"写上\",{\"1\":{\"663\":1}}],[\"写代码\",{\"1\":{\"555\":1}}],[\"写\",{\"1\":{\"555\":1,\"1475\":3,\"1477\":1}}],[\"写入缓存数据\",{\"1\":{\"1201\":1,\"1204\":1,\"1207\":1,\"1211\":1}}],[\"写入数据库\",{\"1\":{\"526\":1}}],[\"写入时可以先写评论内容表\",{\"1\":{\"57\":1}}],[\"写不出来了\",{\"1\":{\"182\":1}}],[\"写成一排\",{\"1\":{\"99\":1}}],[\"写数据很少\",{\"1\":{\"1237\":1}}],[\"写数据\",{\"1\":{\"56\":1}}],[\"写可以认为是\",{\"1\":{\"49\":1}}],[\"写倾斜\",{\"1\":{\"37\":1}}],[\"写热点与读热点\",{\"0\":{\"33\":1}}],[\"写db\",{\"1\":{\"28\":1}}],[\"会做什么事情了来保证自己能够有机会获得独占式锁了\",{\"1\":{\"1504\":1}}],[\"会认为当前线程获取同步组件成功直接返回\",{\"1\":{\"1496\":1}}],[\"会重写该方法为\",{\"1\":{\"1495\":1}}],[\"会重新从系统内存中把数据读到处理器缓存里\",{\"1\":{\"1454\":1}}],[\"会禁止这两个操作的重排序\",{\"1\":{\"1475\":1}}],[\"会禁止\",{\"1\":{\"1475\":1}}],[\"会带来一定的安全隐患\",{\"1\":{\"1471\":1}}],[\"会出现报错\",{\"1\":{\"1465\":1}}],[\"会出错\",{\"1\":{\"899\":1}}],[\"会针对\",{\"1\":{\"1496\":1}}],[\"会针对编译器制定\",{\"1\":{\"1457\":1}}],[\"会针对该组件进行特定的图像优化\",{\"1\":{\"543\":1}}],[\"会限制特定类型的编译器和处理器重排序\",{\"1\":{\"1457\":1}}],[\"会允许编译器和处理器对指令序列进行重排序\",{\"1\":{\"1457\":1}}],[\"会默认存放\",{\"1\":{\"1440\":1}}],[\"会首先先从主内存中读取共享变量\",{\"1\":{\"1433\":1}}],[\"会改变程序执行结果的重排序\",{\"1\":{\"1423\":1}}],[\"会让人感觉代码是一行一行顺序执行上\",{\"1\":{\"1418\":1}}],[\"会遵守数据依赖性\",{\"1\":{\"1418\":1}}],[\"会自旋\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"会自动创建主键索引\",{\"1\":{\"959\":1}}],[\"会自动进行驼峰命令转换\",{\"1\":{\"567\":1}}],[\"会检查旧值有没有变化\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"会先在当前线程的栈桢中创建用于存储锁记录的空间\",{\"1\":{\"1446\":1}}],[\"会先启动\",{\"1\":{\"1406\":1}}],[\"会先将实现\",{\"1\":{\"1370\":1}}],[\"会先对当前认证的用户进行权限检查\",{\"1\":{\"465\":1}}],[\"会想到任何线程执行任务\",{\"1\":{\"1368\":1}}],[\"会直接中断正在执行的任务\",{\"1\":{\"1360\":1}}],[\"会直接抛出异常\",{\"1\":{\"1252\":1}}],[\"会阻塞当前线程\",{\"1\":{\"1394\":1}}],[\"会阻塞等待在调用\",{\"1\":{\"1393\":1}}],[\"会阻塞插入数据的线程\",{\"1\":{\"1345\":1}}],[\"会阻塞消费数据的线程\",{\"1\":{\"1345\":1}}],[\"会一直在\",{\"1\":{\"1406\":1}}],[\"会一直打印\",{\"1\":{\"1340\":1}}],[\"会一直阻塞\",{\"1\":{\"1337\":1}}],[\"会等待另一个线程也执行该方法\",{\"1\":{\"1399\":1}}],[\"会等待\",{\"1\":{\"1337\":1}}],[\"会返回\",{\"1\":{\"1336\":1}}],[\"会清除中断标志位\",{\"1\":{\"1336\":1}}],[\"会调用\",{\"1\":{\"1334\":1,\"1495\":1}}],[\"会指定其大小\",{\"1\":{\"1326\":1}}],[\"会指向另外一个节点\",{\"1\":{\"1283\":1}}],[\"会经常使用到\",{\"1\":{\"1324\":1}}],[\"会令\",{\"1\":{\"1319\":1}}],[\"会抛出\",{\"1\":{\"1290\":1}}],[\"会执行\",{\"1\":{\"1510\":1}}],[\"会执行定位队列真正的队头节点的操作\",{\"1\":{\"1286\":1}}],[\"会执行定位队列真正的队尾节点的操作\",{\"1\":{\"1286\":1}}],[\"会执行回调方法\",{\"1\":{\"1207\":2}}],[\"会继续往下执行\",{\"1\":{\"1394\":1}}],[\"会继续通过\",{\"1\":{\"1317\":1}}],[\"会继续执行到\",{\"1\":{\"1504\":1}}],[\"会继续执行\",{\"1\":{\"1285\":1,\"1511\":1}}],[\"会继续检查占有线程是否为当前线程\",{\"1\":{\"1232\":1}}],[\"会更新为当前脏\",{\"1\":{\"1317\":2}}],[\"会更新\",{\"1\":{\"1285\":1}}],[\"会通过在指令中添加\",{\"1\":{\"1486\":1}}],[\"会通过第\",{\"1\":{\"1317\":1}}],[\"会通过\",{\"1\":{\"1283\":1,\"1306\":1}}],[\"会通过消息队列送至\",{\"1\":{\"28\":1}}],[\"会被减\",{\"1\":{\"1392\":1}}],[\"会被赋值为\",{\"1\":{\"1283\":1}}],[\"会被强制路由到登录页面\",{\"1\":{\"587\":1}}],[\"会帮助\",{\"1\":{\"1276\":1}}],[\"会进行怎样的重排序\",{\"1\":{\"1473\":1}}],[\"会进一步对当前链表大小进行调整\",{\"1\":{\"1272\":1}}],[\"会进入到这个\",{\"1\":{\"1251\":1}}],[\"会对\",{\"1\":{\"1272\":1,\"1496\":1}}],[\"会对应这个数列的连续一段\",{\"1\":{\"324\":1}}],[\"会判断当前\",{\"1\":{\"1272\":1}}],[\"会使用原子的\",{\"1\":{\"1447\":1}}],[\"会使用阻塞队列\",{\"1\":{\"1344\":1}}],[\"会使用线程池去维护线程的创建和复用\",{\"1\":{\"1305\":1}}],[\"会使当前线程释放\",{\"1\":{\"1251\":1}}],[\"会使得当前线程释放\",{\"1\":{\"1251\":1}}],[\"会使得这些查询更加高效\",{\"1\":{\"513\":1}}],[\"会展示集群\",{\"1\":{\"1192\":1}}],[\"会有不同的操作\",{\"1\":{\"1496\":1}}],[\"会有跑步这一项运动\",{\"1\":{\"1393\":1}}],[\"会有扩容机制\",{\"1\":{\"1306\":1}}],[\"会有如下提示\",{\"1\":{\"1191\":1}}],[\"会有非常重的前置调用逻辑\",{\"1\":{\"28\":1}}],[\"会根据是否设置了抓取注册表信息和是否注册将\",{\"1\":{\"1182\":1}}],[\"会根据业务需求及业务模块之间的关系\",{\"1\":{\"936\":1}}],[\"会报异常\",{\"1\":{\"1407\":1}}],[\"会报警\",{\"1\":{\"1160\":1}}],[\"会报错\",{\"1\":{\"1114\":1}}],[\"会创建出一个默认的\",{\"1\":{\"1148\":1}}],[\"会创建初始管理员账号\",{\"1\":{\"670\":1}}],[\"会话也不会被阻塞\",{\"1\":{\"1087\":1}}],[\"会话管理\",{\"1\":{\"446\":1}}],[\"会优先使用局部变量\",{\"1\":{\"1015\":1}}],[\"会构造一个新的字符串\",{\"1\":{\"1005\":1}}],[\"会顺次执行后面每个\",{\"1\":{\"986\":1}}],[\"会影响检索速度\",{\"1\":{\"958\":1}}],[\"会明确指出禁止使用物理外键\",{\"1\":{\"937\":1}}],[\"会提示询问是否确认删除所有数据\",{\"1\":{\"927\":1}}],[\"会存在重复计算的问题\",{\"1\":{\"851\":1}}],[\"会产生一定的费用\",{\"1\":{\"664\":1}}],[\"会发现\",{\"1\":{\"592\":1,\"1493\":1}}],[\"会发现无权访问\",{\"1\":{\"592\":1}}],[\"会将传入的\",{\"1\":{\"1368\":1}}],[\"会将该线程放置到\",{\"1\":{\"1346\":1}}],[\"会将\",{\"1\":{\"1267\":1}}],[\"会将主内存中的值刷回到自己的线程内存中\",{\"1\":{\"1145\":1}}],[\"会将变量的值刷到主内存中\",{\"1\":{\"1145\":1}}],[\"会将逻辑删除的用户也查找出来\",{\"1\":{\"575\":1}}],[\"会将用户密码和一个随机生成的字符串\",{\"1\":{\"568\":1}}],[\"会将页面的初始\",{\"1\":{\"531\":1}}],[\"会因为数据库的唯一性约束导致\",{\"1\":{\"526\":1}}],[\"会随着其他数值而受到影响\",{\"1\":{\"354\":1}}],[\"会覆盖掉\",{\"1\":{\"254\":1}}],[\"会爆掉\",{\"1\":{\"243\":1}}],[\"会过滤掉空字符\",{\"1\":{\"243\":1}}],[\"会在入队和出队的操作中获得更大的便捷性\",{\"1\":{\"1504\":1}}],[\"会在指令序列中插入内存屏障来禁止特定类型的处理器重排序\",{\"1\":{\"1457\":1}}],[\"会在对象头和栈帧中的锁记录里存储锁偏向的线程\",{\"1\":{\"1442\":1}}],[\"会在自己的栈空间运行\",{\"1\":{\"1429\":1}}],[\"会在超时之后继续执行\",{\"1\":{\"1337\":1}}],[\"会在适当的时候制造一个\",{\"1\":{\"1132\":1}}],[\"会在系统运行到适当的时候\",{\"1\":{\"1131\":1}}],[\"会在下一章解释\",{\"1\":{\"1010\":1}}],[\"会在跳转到新路由之前\",{\"1\":{\"458\":1}}],[\"会在\",{\"1\":{\"200\":1,\"1306\":1}}],[\"会在评论列表以外\",{\"1\":{\"37\":1}}],[\"会看见下一块高大且离得远的集合中\",{\"1\":{\"128\":1}}],[\"会收到伤害为\",{\"1\":{\"110\":1}}],[\"会导致线程安全的问题吗\",{\"1\":{\"1473\":1}}],[\"会导致等待的线程挂起\",{\"1\":{\"1225\":1}}],[\"会导致边界问题\",{\"1\":{\"899\":1}}],[\"会导致如果用户注销帐号了\",{\"1\":{\"613\":1}}],[\"会导致找不到属性对应的字段\",{\"1\":{\"567\":1}}],[\"会导致循环依赖问题\",{\"1\":{\"526\":1}}],[\"会导致\",{\"1\":{\"338\":1}}],[\"会导致大量的同进程\",{\"1\":{\"60\":1}}],[\"会导致更大的\",{\"1\":{\"56\":1}}],[\"会减少之后大量的返工\",{\"1\":{\"45\":1}}],[\"会向下游传递预先声明的召回决策\",{\"1\":{\"40\":1}}],[\"在共享式锁的释放过程中\",{\"1\":{\"1511\":1}}],[\"在释放同步状态时\",{\"1\":{\"1506\":1}}],[\"在释放的过程中会唤醒同步队列中的下一个节点\",{\"1\":{\"1251\":1}}],[\"在自旋过程中主要完成了两件事情\",{\"1\":{\"1505\":1}}],[\"在当前线程是第一个加入同步队列时\",{\"1\":{\"1504\":1}}],[\"在重写\",{\"1\":{\"1495\":1}}],[\"在重写的\",{\"1\":{\"1368\":1}}],[\"在弄懂这点后会lock的实现理解有很大的提升\",{\"1\":{\"1495\":1}}],[\"在锁的实现中聚合同步器\",{\"1\":{\"1494\":1}}],[\"在超时时间内\",{\"1\":{\"1508\":1}}],[\"在超时时间内没有获得同步状态返回\",{\"1\":{\"1500\":1}}],[\"在超时内或者未中断的情况下能够获取锁\",{\"1\":{\"1493\":1}}],[\"在超时购物\",{\"1\":{\"1223\":1}}],[\"在针对并发编程中\",{\"1\":{\"1491\":1}}],[\"在引用对象对所有线程可见时\",{\"1\":{\"1478\":1}}],[\"在定义该\",{\"1\":{\"1467\":1}}],[\"在声明final实例成员变量时进行赋值\",{\"1\":{\"1467\":1}}],[\"在非静态初始化块中以及构造器中赋初值\",{\"1\":{\"1465\":1}}],[\"在非法或不适当的时间调用方法时产生的信号\",{\"1\":{\"1045\":1}}],[\"在六条\",{\"1\":{\"1455\":1}}],[\"在生成汇编代码时会在\",{\"1\":{\"1454\":1}}],[\"在生成实体类时用\",{\"1\":{\"567\":1}}],[\"在聊到锁的优化也就是锁的几种状态前\",{\"1\":{\"1434\":1}}],[\"在java程序中所有实例域\",{\"1\":{\"1416\":1}}],[\"在现实生活中\",{\"1\":{\"1416\":1}}],[\"在现在的企业开发中\",{\"1\":{\"937\":1}}],[\"在调用\",{\"1\":{\"1404\":1}}],[\"在调用方法前后进行额外的处理\",{\"1\":{\"599\":1}}],[\"在实现实现\",{\"1\":{\"1496\":1}}],[\"在实现同步组件时\",{\"1\":{\"1495\":1}}],[\"在实现生产者\",{\"1\":{\"1402\":1}}],[\"在实际使用中\",{\"1\":{\"1357\":1}}],[\"在实际使用中我们都是会用线程池去维护我们的线程\",{\"1\":{\"1313\":1}}],[\"在实际编程中\",{\"1\":{\"1324\":1}}],[\"在实际开发中\",{\"1\":{\"1305\":1}}],[\"在实际的业务开发中\",{\"1\":{\"953\":1}}],[\"在实际项目开发中\",{\"1\":{\"475\":1}}],[\"在青春洋溢的中学时代\",{\"1\":{\"1399\":1}}],[\"在semaphore的构造方法中还支持指定是够具有公平性\",{\"1\":{\"1398\":1}}],[\"在sql语句当中构造条件的运算符分为两类\",{\"1\":{\"931\":1}}],[\"在限制资源使用的应用场景下\",{\"1\":{\"1398\":1}}],[\"在比赛开始时\",{\"1\":{\"1393\":1}}],[\"在比如\",{\"1\":{\"939\":1}}],[\"在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"在存储用户密码时\",{\"1\":{\"568\":1}}],[\"在设计\",{\"1\":{\"1423\":1}}],[\"在设计时的三个关键要素是\",{\"1\":{\"1371\":1}}],[\"在设计层面主要有两方面实践\",{\"1\":{\"36\":1}}],[\"在下面进行详细介绍\",{\"1\":{\"1366\":1}}],[\"在下一篇文章\",{\"1\":{\"1326\":1}}],[\"在下一次循环中进行重试\",{\"1\":{\"1511\":1}}],[\"在下一次\",{\"1\":{\"1316\":1}}],[\"在大多数并发框架中都会使用线程池来管理线程\",{\"1\":{\"1357\":1}}],[\"在插入数据和删除数据时分别是由两个不同的\",{\"1\":{\"1350\":1}}],[\"在后台默默地守护一些系统服务\",{\"1\":{\"1340\":1}}],[\"在后续篇幅会讲述\",{\"1\":{\"1221\":1}}],[\"在等待的时间内还没有结束的话\",{\"1\":{\"1337\":1}}],[\"在软件开发的过程中\",{\"1\":{\"1337\":1}}],[\"在创建线程的时候尽量多考虑采用实现接口的形式\",{\"1\":{\"1330\":1}}],[\"在业务代码中执行\",{\"1\":{\"1318\":1}}],[\"在业务层逻辑中\",{\"1\":{\"937\":1}}],[\"在接下来的\",{\"1\":{\"1317\":4}}],[\"在扫描过程中\",{\"1\":{\"1315\":1}}],[\"在该方法中会首先调用\",{\"1\":{\"1510\":1}}],[\"在该方法中如果当前同步状态为\",{\"1\":{\"1496\":1}}],[\"在该方法中针对脏\",{\"1\":{\"1314\":1}}],[\"在该示例中\",{\"1\":{\"1406\":1}}],[\"在该目录下创建\",{\"1\":{\"549\":1}}],[\"在该目录下新建一个布局文件夹\",{\"1\":{\"548\":1}}],[\"在扩容的过程中针对脏\",{\"1\":{\"1306\":1}}],[\"在扩容时才会出现的特殊节点\",{\"1\":{\"1267\":1}}],[\"在源码中针对这种\",{\"1\":{\"1306\":1}}],[\"在了解这些相关知识后我们再回过头来看一下\",{\"1\":{\"1306\":1}}],[\"在了解\",{\"1\":{\"1306\":1}}],[\"在垃圾回收的时候都会被系统进行回收\",{\"1\":{\"1305\":1}}],[\"在复制的时候只是复制容器里的引用\",{\"1\":{\"1295\":1}}],[\"在写\",{\"1\":{\"1456\":1}}],[\"在写锁被获取后\",{\"1\":{\"1295\":1}}],[\"在写锁被获取之后\",{\"1\":{\"1291\":1}}],[\"在写入要尽可能的顺序自增\",{\"1\":{\"56\":1}}],[\"在读一个对象的\",{\"1\":{\"1475\":1}}],[\"在读线程在读取\",{\"1\":{\"1290\":1}}],[\"在读取评论区基础信息阶段探测热点\",{\"1\":{\"33\":1}}],[\"在判断队列是否为空队列的时候是不能通过线程在\",{\"1\":{\"1284\":1}}],[\"在判断\",{\"1\":{\"1284\":1}}],[\"在经过第一次循环后\",{\"1\":{\"1284\":1}}],[\"在循环体\",{\"1\":{\"1283\":1}}],[\"在看多线程的代码时\",{\"1\":{\"1283\":1}}],[\"在多处理器下\",{\"1\":{\"1454\":1}}],[\"在多线程情况下\",{\"1\":{\"1473\":1}}],[\"在多线程开发时需要从原子性\",{\"1\":{\"1425\":1}}],[\"在多线程下原子操作例如\",{\"1\":{\"1425\":1}}],[\"在多线程条件下\",{\"1\":{\"1415\":1}}],[\"在多线程协作完成业务功能时\",{\"1\":{\"1392\":1}}],[\"在多线程编程过程中\",{\"1\":{\"1344\":1}}],[\"在多线程编程中通常解决线程安全的问题我们会利用\",{\"1\":{\"1299\":1}}],[\"在多线程就很容易出现线程安全的问题\",{\"1\":{\"1282\":1}}],[\"在多表查询时\",{\"1\":{\"942\":1}}],[\"在队列进行出队入队的时候免不了对节点需要进行操作\",{\"1\":{\"1282\":1}}],[\"在队尾添加元素\",{\"1\":{\"1038\":1}}],[\"在面试中也经常会有一些考点\",{\"1\":{\"1280\":1}}],[\"在面对具体题目时\",{\"1\":{\"227\":1}}],[\"在原容量大小的基础上右移一位\",{\"1\":{\"1274\":1}}],[\"在table的i位置上插入forwardnode节点\",{\"1\":{\"1274\":1}}],[\"在treeset类中\",{\"1\":{\"1073\":1}}],[\"在nexttable的i+n的位置上插入另一个链表\",{\"1\":{\"1274\":1}}],[\"在nexttable的i位置上插入一个链表\",{\"1\":{\"1274\":1}}],[\"在之后的逻辑一直没有使用该对象\",{\"1\":{\"1306\":1}}],[\"在之后会用到\",{\"1\":{\"1274\":1}}],[\"在之前了解过\",{\"1\":{\"1272\":1}}],[\"在之前介绍\",{\"1\":{\"1258\":1}}],[\"在之前的搜索中已经加入到集合了\",{\"1\":{\"822\":1}}],[\"在红黑树中查找即可\",{\"1\":{\"1273\":1}}],[\"在红黑树中插入新值\",{\"1\":{\"1272\":1}}],[\"在性能开销上也能兼顾\",{\"1\":{\"1272\":1}}],[\"在性能上有明显的优越性\",{\"1\":{\"1205\":1}}],[\"在链表中如果找到了与待插入的键值对的\",{\"1\":{\"1272\":1}}],[\"在链表中插入新值\",{\"1\":{\"1272\":1}}],[\"在链表中插入新的键值对\",{\"1\":{\"1272\":1}}],[\"在链表头插入一个数a\",{\"1\":{\"403\":1}}],[\"在对象引用为任意线程可见之前\",{\"1\":{\"1475\":1}}],[\"在对线程\",{\"1\":{\"1285\":1}}],[\"在对poll方法的讨论中\",{\"1\":{\"1285\":1}}],[\"在对指定值做进一步处理\",{\"1\":{\"1270\":1}}],[\"在对应类型的线段树上查询指定区间\",{\"1\":{\"168\":1}}],[\"在熟悉上面的这核心信息之后\",{\"1\":{\"1269\":1}}],[\"在理想状态下\",{\"1\":{\"1306\":1}}],[\"在理想情况下\",{\"1\":{\"972\":1}}],[\"在理解\",{\"1\":{\"1268\":1,\"1348\":1}}],[\"在高并发的情况下\",{\"1\":{\"1264\":1}}],[\"在使用线程的等待\",{\"1\":{\"1406\":1,\"1407\":1}}],[\"在使用线程池的情况下\",{\"1\":{\"1320\":1}}],[\"在使用一次后\",{\"1\":{\"1393\":1}}],[\"在使用完之后\",{\"1\":{\"1309\":1}}],[\"在使用\",{\"1\":{\"1264\":1,\"1270\":1}}],[\"在功能特性上还是有很多的不同\",{\"1\":{\"1248\":1}}],[\"在功能层面\",{\"1\":{\"34\":1}}],[\"在分析\",{\"1\":{\"1237\":1,\"1285\":1,\"1306\":1}}],[\"在并发编程中主要需要解决两个问题\",{\"1\":{\"1416\":1}}],[\"在并发编程中很容易出现并发安全的问题\",{\"1\":{\"1380\":1}}],[\"在并发场景中用于解决线程安全的问题\",{\"1\":{\"1237\":1}}],[\"在并查集中进行合并\",{\"1\":{\"822\":1}}],[\"在单例模式的实现上有一种双重检验锁定的方式\",{\"1\":{\"1485\":1}}],[\"在单线程中\",{\"1\":{\"1418\":1}}],[\"在单线程编程中我们会经常用到一些集合类\",{\"1\":{\"1280\":1}}],[\"在单线程里实现多任务的调度\",{\"1\":{\"1220\":1}}],[\"在单机模式下\",{\"1\":{\"484\":1}}],[\"在特殊的业务场景下先天的就适合于并发编程\",{\"1\":{\"1218\":1}}],[\"在我的理解中\",{\"1\":{\"1423\":1}}],[\"在我看来\",{\"1\":{\"1218\":1}}],[\"在我和女朋友之间引入了一个第三者\",{\"1\":{\"1131\":1}}],[\"在配置上\",{\"1\":{\"1191\":1}}],[\"在初始化过程中\",{\"1\":{\"1266\":1}}],[\"在初始化\",{\"1\":{\"1184\":2}}],[\"在初始化调度任务的方法\",{\"1\":{\"1182\":1}}],[\"在系统运行时\",{\"1\":{\"1132\":1}}],[\"在系统设计上也提出了不同层面的要求\",{\"1\":{\"40\":1}}],[\"在传统的开发模式下\",{\"1\":{\"1129\":1}}],[\"在没有引入\",{\"1\":{\"1129\":1}}],[\"在回答这四个问题之前\",{\"1\":{\"1129\":1}}],[\"在很早的时候就采用了\",{\"1\":{\"1095\":1}}],[\"在标准硬件上\",{\"1\":{\"1095\":1}}],[\"在同步队列中的节点\",{\"1\":{\"1504\":1}}],[\"在同步队列中得线程就会有机会重新获取该监视器\",{\"1\":{\"1431\":1}}],[\"在同步组件的实现中\",{\"1\":{\"1500\":1}}],[\"在同步组件的实现上主要是利用了\",{\"1\":{\"1496\":1}}],[\"在同步组件实现中\",{\"1\":{\"1495\":1}}],[\"在同步的时候是获取对象的\",{\"1\":{\"1440\":1}}],[\"在同目录下创建\",{\"1\":{\"1090\":1}}],[\"在同一时刻写锁是不能被多个线程所获取\",{\"1\":{\"1239\":1}}],[\"在同一个时刻只允许一个线程占有锁\",{\"1\":{\"1496\":1}}],[\"在同一个包中可以访问\",{\"1\":{\"1027\":1}}],[\"在同一个类中存在多个函数\",{\"1\":{\"1022\":1}}],[\"在同一个数据库服务器中\",{\"1\":{\"913\":1}}],[\"在同一个公众号的\",{\"1\":{\"510\":1}}],[\"在同一行用空格隔开\",{\"1\":{\"289\":1}}],[\"在浏览器输入\",{\"1\":{\"1089\":1}}],[\"在堆中加入元素\",{\"1\":{\"1078\":1}}],[\"在map中若存在value\",{\"1\":{\"1074\":1}}],[\"在map中若存在key\",{\"1\":{\"1074\":1}}],[\"在map中加入键值对<key\",{\"1\":{\"1074\":1}}],[\"在mysql数据库当中\",{\"1\":{\"919\":1}}],[\"在index位置插一个元素e\",{\"1\":{\"1072\":1}}],[\"在in之后的列表中的值\",{\"1\":{\"931\":1}}],[\"在尾部添加一个元素e\",{\"1\":{\"1072\":1}}],[\"在函数定义时抛出一些可能的异常\",{\"1\":{\"1048\":1}}],[\"在函数内抛出一个异常\",{\"1\":{\"1048\":1}}],[\"在末尾添加一个元素\",{\"1\":{\"1036\":1}}],[\"在建表时\",{\"1\":{\"959\":1}}],[\"在指定的集合范围之内\",{\"1\":{\"949\":1}}],[\"在指定方向上遍历网格\",{\"1\":{\"77\":1}}],[\"在查询时给多表查询加上连接查询的条件\",{\"1\":{\"942\":1}}],[\"在数据库表中多的一方\",{\"1\":{\"937\":1}}],[\"在数据处理流程中引入去重机制\",{\"1\":{\"151\":1}}],[\"在进行数据库表结构设计时\",{\"1\":{\"936\":1}}],[\"在根据指定的列统计的时候\",{\"1\":{\"932\":1}}],[\"在某个范围之内\",{\"1\":{\"931\":1}}],[\"在基本查询的\",{\"1\":{\"930\":1}}],[\"在修改数据时\",{\"1\":{\"926\":1}}],[\"在命令行中输入密码\",{\"1\":{\"906\":1}}],[\"在搜索完当前所能走到的所有节点后\",{\"1\":{\"875\":1}}],[\"在学习课程\",{\"1\":{\"875\":1}}],[\"在选修某些课程之前需要一些先修课程\",{\"1\":{\"874\":1}}],[\"在全为烂橘子的情况下要返回\",{\"1\":{\"869\":1}}],[\"在全局\",{\"1\":{\"453\":1,\"459\":1}}],[\"在给定的\",{\"1\":{\"868\":1}}],[\"在每个\",{\"1\":{\"1457\":4}}],[\"在每层遍历的时候\",{\"1\":{\"869\":1}}],[\"在每间房子前都有两种选择\",{\"1\":{\"827\":1}}],[\"在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点\",{\"1\":{\"301\":1}}],[\"在每一轮中\",{\"1\":{\"99\":1}}],[\"在每一轮中的位置\",{\"1\":{\"99\":1}}],[\"在广度优先搜索的过程中\",{\"1\":{\"821\":1}}],[\"在递归调用左子树时\",{\"1\":{\"899\":1}}],[\"在递归判断过程中存在短路现象\",{\"1\":{\"808\":1}}],[\"在递归的方法中\",{\"1\":{\"731\":1}}],[\"在检索之前已经插入\",{\"1\":{\"801\":1}}],[\"在计算\",{\"1\":{\"797\":1}}],[\"在字典中且可以分割\",{\"1\":{\"784\":1}}],[\"在字符串\",{\"1\":{\"306\":1}}],[\"在字符串中的位置\",{\"1\":{\"279\":1}}],[\"在头部加入\",{\"1\":{\"777\":1}}],[\"在不改变最终结果的前提下\",{\"1\":{\"1421\":1}}],[\"在不改变程序执行结果的前提下\",{\"1\":{\"1418\":1}}],[\"在不知道链表长度的情况下\",{\"1\":{\"777\":1}}],[\"在不允许拼桌的情况下\",{\"1\":{\"162\":1}}],[\"在中序遍历中搜索根节点\",{\"1\":{\"766\":1}}],[\"在前面说过\",{\"1\":{\"1482\":1}}],[\"在前面的学习中\",{\"1\":{\"1457\":1}}],[\"在前面的方法中\",{\"1\":{\"712\":1}}],[\"在前缀树中\",{\"1\":{\"801\":1}}],[\"在前期花足够时间去反复思考设计\",{\"1\":{\"45\":1}}],[\"在上述五个接口中\",{\"1\":{\"1493\":1}}],[\"在上一篇文章中我们了解到\",{\"1\":{\"1453\":1}}],[\"在上一篇提到过\",{\"1\":{\"1433\":1}}],[\"在上一篇讨论过\",{\"1\":{\"1432\":1}}],[\"在上一篇中我们已经了解了\",{\"1\":{\"1429\":1}}],[\"在上一级缓存未命中或者出现网络错误后\",{\"1\":{\"34\":1}}],[\"在上面的源码中我们可以看出在第1步中会先创建头结点\",{\"1\":{\"1504\":1}}],[\"在上面的例子中一个创建了\",{\"1\":{\"1337\":1}}],[\"在上面的这个\",{\"1\":{\"1221\":1}}],[\"在上面我们说过\",{\"1\":{\"1309\":1}}],[\"在上面我们提及到在\",{\"1\":{\"1268\":1}}],[\"在上面非公平锁获取时\",{\"1\":{\"1233\":1}}],[\"在上方菜单中\",{\"1\":{\"676\":1}}],[\"在本地保存图片后\",{\"1\":{\"670\":1}}],[\"在本项目中只有管理员才能创建题库\",{\"1\":{\"511\":1}}],[\"在首次启动时\",{\"1\":{\"670\":1}}],[\"在服务安装后\",{\"1\":{\"1095\":1}}],[\"在服务器上搭建了一个对象存储服务\",{\"1\":{\"668\":1}}],[\"在服务端渲染模式下\",{\"1\":{\"531\":1}}],[\"在宝塔上配置\",{\"1\":{\"664\":1}}],[\"在其它设置不变的情况下\",{\"1\":{\"664\":1}}],[\"在其下新建\",{\"1\":{\"543\":1}}],[\"在集合中删除元素e\",{\"1\":{\"1073\":1}}],[\"在集合中添加元素e\",{\"1\":{\"1073\":1}}],[\"在集合中\",{\"1\":{\"613\":1}}],[\"在集合中选取数量大于\",{\"1\":{\"140\":1}}],[\"在用户程序中新建一个线程\",{\"1\":{\"1330\":1}}],[\"在用户组里面\",{\"1\":{\"670\":1}}],[\"在用户注册的时候\",{\"1\":{\"613\":1}}],[\"在用户管理页面下引入组件\",{\"1\":{\"592\":1}}],[\"在用户登录成功之后才会保存到\",{\"1\":{\"575\":1}}],[\"在添加完组件以及路由之后\",{\"1\":{\"587\":1}}],[\"在请求头中带上\",{\"1\":{\"575\":1}}],[\"在信息脱敏技术中\",{\"1\":{\"574\":1}}],[\"在验证用户登录时\",{\"1\":{\"568\":1}}],[\"在地址栏输入\",{\"1\":{\"559\":1}}],[\"在项目中慎用\",{\"1\":{\"546\":1}}],[\"在项目启动时\",{\"1\":{\"481\":1}}],[\"在页面中可以获取到\",{\"1\":{\"542\":1}}],[\"在任意一方加入外键\",{\"1\":{\"938\":1}}],[\"在任意一个\",{\"1\":{\"539\":1}}],[\"在任意\",{\"1\":{\"540\":1}}],[\"在终端执行\",{\"1\":{\"538\":1}}],[\"在构造函数\",{\"1\":{\"1478\":1}}],[\"在构造函数内对一个\",{\"1\":{\"1476\":1}}],[\"在构造或者拼接\",{\"1\":{\"243\":1}}],[\"在构建线程的时候可以通过\",{\"1\":{\"1339\":1}}],[\"在构建阶段或请求阶段\",{\"1\":{\"535\":1}}],[\"在构建阶段\",{\"1\":{\"534\":1}}],[\"在具体项目中\",{\"1\":{\"532\":1,\"533\":1}}],[\"在客户端加载并渲染\",{\"1\":{\"535\":1}}],[\"在客户端渲染模式下\",{\"1\":{\"531\":1}}],[\"在客户端不能展现\",{\"1\":{\"36\":1}}],[\"在此处将实体类和\",{\"1\":{\"526\":1}}],[\"在此情况下所花费的总时间\",{\"1\":{\"146\":1}}],[\"在题库题目关联表中添加一条记录\",{\"1\":{\"526\":1}}],[\"在题目查询请求类\",{\"1\":{\"525\":1}}],[\"在这样的设备中\",{\"1\":{\"1331\":1}}],[\"在这一行代码中\",{\"1\":{\"1178\":1}}],[\"在这种的业务场景下\",{\"1\":{\"1392\":1}}],[\"在这种时候就可能需要一些代理手段\",{\"1\":{\"661\":1}}],[\"在这种情况下\",{\"1\":{\"534\":1,\"1094\":1}}],[\"在这种模式下\",{\"1\":{\"531\":1}}],[\"在这里替换\",{\"1\":{\"525\":1}}],[\"在这个时间点上没有正在执行的字节码\",{\"1\":{\"1443\":1}}],[\"在这个例子中一共开启了\",{\"1\":{\"1407\":1}}],[\"在这个同步点两个线程能够交换数据\",{\"1\":{\"1399\":1}}],[\"在这个路径下\",{\"1\":{\"1145\":1}}],[\"在这个过程中\",{\"1\":{\"796\":1}}],[\"在这个游戏中\",{\"1\":{\"97\":1}}],[\"在这个系统中\",{\"1\":{\"70\":1}}],[\"在线程竞争激烈的情况下会升级为重量级锁\",{\"1\":{\"1453\":1}}],[\"在线程中调用\",{\"1\":{\"1404\":1}}],[\"在线程\",{\"1\":{\"1285\":1}}],[\"在线程间实现通信的往往会应用到\",{\"1\":{\"1248\":1}}],[\"在线程获取锁的时候\",{\"1\":{\"1232\":1}}],[\"在线刷题并查看刷题记录日历等\",{\"1\":{\"493\":1}}],[\"在线段树中\",{\"1\":{\"168\":1}}],[\"在需要数据权限控制方法上添加\",{\"1\":{\"471\":1}}],[\"在执行程序时\",{\"1\":{\"1418\":1}}],[\"在执行定时任务的时候\",{\"1\":{\"1369\":1}}],[\"在执行判断\",{\"1\":{\"1285\":1}}],[\"在执行\",{\"1\":{\"1119\":1,\"1284\":1,\"1475\":1}}],[\"在执行方法前执行\",{\"1\":{\"465\":1}}],[\"在执行算法的过程中\",{\"1\":{\"212\":1}}],[\"在若依框架中\",{\"1\":{\"465\":1}}],[\"在登录成功后\",{\"1\":{\"458\":1}}],[\"在仓库内转换和流动\",{\"1\":{\"436\":1}}],[\"在获取同步状态失败后就会调用\",{\"1\":{\"1507\":1}}],[\"在获取同步状态时\",{\"1\":{\"1506\":1}}],[\"在获取\",{\"1\":{\"434\":1}}],[\"在两个字符串上游走\",{\"1\":{\"839\":1}}],[\"在两个迭代器\",{\"1\":{\"423\":1}}],[\"在两行中给出两个正整数\",{\"1\":{\"99\":1}}],[\"在哈希表中查询某个数是否存在\",{\"1\":{\"419\":1}}],[\"在满足一下三个条件时\",{\"1\":{\"1467\":1}}],[\"在满足\",{\"1\":{\"411\":1}}],[\"在节点k的右边插入一个数x\",{\"1\":{\"404\":1}}],[\"在算法竞赛中一般不需要考虑删除的那个节点该如何处理\",{\"1\":{\"403\":1}}],[\"在算法运行的过程中\",{\"1\":{\"213\":1}}],[\"在有多个处理器的机器上\",{\"1\":{\"1331\":1}}],[\"在有多个数位的情况下不能开头\",{\"1\":{\"121\":1}}],[\"在有序\",{\"1\":{\"423\":2}}],[\"在有向图游戏中\",{\"1\":{\"398\":1}}],[\"在起点上放有一枚棋子\",{\"1\":{\"396\":1}}],[\"在游戏进程的任意时刻\",{\"1\":{\"395\":1}}],[\"在游戏过程中\",{\"1\":{\"224\":1,\"279\":1}}],[\"在图中每一个箭头连接的两个节点就代表之间的\",{\"1\":{\"1432\":1}}],[\"在图中选择若干条边把图中的所有节点连接起来\",{\"1\":{\"359\":1}}],[\"在图论中\",{\"1\":{\"359\":1,\"363\":1}}],[\"在保存最短路径的数组中\",{\"1\":{\"355\":1}}],[\"在还未确定最短路的点中\",{\"1\":{\"352\":1}}],[\"在所有子节点更新后再更新\",{\"1\":{\"314\":1}}],[\"在所有可能的情况下\",{\"1\":{\"141\":1}}],[\"在网格中的位置\",{\"1\":{\"279\":1}}],[\"在由\",{\"1\":{\"244\":1}}],[\"在另外一个极端情况下\",{\"1\":{\"216\":1}}],[\"在极端情况下\",{\"1\":{\"216\":1}}],[\"在程序中即\",{\"1\":{\"104\":1}}],[\"在第一趟搜索过程中通过\",{\"1\":{\"1316\":1}}],[\"在第一次为\",{\"1\":{\"1306\":1}}],[\"在第一次循环中指针\",{\"1\":{\"1283\":1}}],[\"在第\",{\"1\":{\"1251\":1,\"1271\":2,\"1283\":1,\"1284\":2,\"1317\":4,\"1508\":1}}],[\"在第二步增加了处理逻辑\",{\"1\":{\"1232\":1}}],[\"在第几轮被删除\",{\"1\":{\"99\":2}}],[\"在第三轮被删除\",{\"1\":{\"99\":1}}],[\"在一段时间内不会让其他应用获取注册信息\",{\"1\":{\"1160\":1}}],[\"在一次搜索中\",{\"1\":{\"875\":1}}],[\"在一次移动中\",{\"1\":{\"72\":1}}],[\"在一些情况下\",{\"1\":{\"213\":1,\"214\":1}}],[\"在一行上输出一个整数\",{\"1\":{\"172\":1,\"173\":1}}],[\"在一行上输入一个长度为\",{\"1\":{\"172\":1}}],[\"在一行中输出数字\",{\"1\":{\"99\":1}}],[\"在一个线程中\",{\"1\":{\"1475\":1}}],[\"在一个对象中\",{\"1\":{\"1131\":1}}],[\"在一个函数内部\",{\"1\":{\"1023\":1}}],[\"在一个数组中查找最长的相同连续子序列\",{\"0\":{\"244\":1}}],[\"在一个\",{\"1\":{\"142\":1,\"224\":1,\"279\":1}}],[\"在区间\",{\"1\":{\"87\":2}}],[\"在盘古开天辟地之前\",{\"1\":{\"66\":1}}],[\"在内存中使用\",{\"1\":{\"61\":1}}],[\"在\",{\"1\":{\"56\":1,\"129\":1,\"182\":1,\"213\":1,\"215\":2,\"235\":1,\"450\":1,\"451\":1,\"455\":1,\"456\":1,\"461\":1,\"462\":1,\"463\":2,\"465\":2,\"470\":1,\"471\":1,\"523\":1,\"525\":1,\"526\":1,\"533\":1,\"541\":1,\"548\":1,\"549\":1,\"575\":1,\"576\":1,\"578\":1,\"588\":1,\"589\":2,\"592\":2,\"596\":3,\"664\":1,\"670\":1,\"672\":1,\"852\":1,\"869\":1,\"1051\":2,\"1087\":1,\"1090\":1,\"1100\":1,\"1150\":1,\"1231\":1,\"1248\":1,\"1259\":2,\"1264\":1,\"1266\":1,\"1272\":3,\"1275\":1,\"1276\":1,\"1282\":1,\"1285\":1,\"1305\":1,\"1306\":2,\"1307\":1,\"1314\":1,\"1317\":1,\"1339\":1,\"1369\":1,\"1370\":1,\"1371\":3,\"1375\":3,\"1380\":2,\"1383\":1,\"1406\":3,\"1407\":1,\"1408\":1,\"1429\":1,\"1430\":1,\"1437\":1,\"1438\":3,\"1464\":1,\"1473\":1,\"1482\":1,\"1485\":1,\"1492\":1,\"1500\":3,\"1501\":1}}],[\"在入\",{\"1\":{\"50\":1}}],[\"在动手设计前\",{\"1\":{\"45\":1}}],[\"在工程上实现了架构的统一\",{\"1\":{\"40\":1}}],[\"在工程落地层面尽可能还原理想的排序算法设计\",{\"1\":{\"40\":1}}],[\"在楼中楼\",{\"1\":{\"40\":1}}],[\"在评论数过百万甚至千万的评论区\",{\"1\":{\"40\":1}}],[\"在架构上\",{\"1\":{\"40\":1}}],[\"在a事务中读取的评论状态\",{\"1\":{\"37\":1}}],[\"在吞吐方面具备更大的弹性\",{\"1\":{\"33\":1}}],[\"在处理完一些必要校验逻辑之后\",{\"1\":{\"28\":1}}],[\"在b站\",{\"1\":{\"21\":1}}],[\"这句话比较抽象\",{\"1\":{\"1496\":1}}],[\"这句话是比较拗口的\",{\"1\":{\"1476\":1}}],[\"这并不是一个原子操作\",{\"1\":{\"1482\":1}}],[\"这显然是错误的操作\",{\"1\":{\"1475\":1}}],[\"这么优秀的语言\",{\"1\":{\"1439\":1}}],[\"这么做的目的\",{\"1\":{\"1420\":1}}],[\"这么做的原因是\",{\"1\":{\"1420\":1}}],[\"这只是\",{\"1\":{\"1420\":1}}],[\"这使得加载和存储操作看上去可能是在乱序执行的\",{\"1\":{\"1418\":1}}],[\"这其中有一个问题\",{\"1\":{\"1417\":1}}],[\"这其中的关系应该是多核\",{\"1\":{\"1218\":1}}],[\"这正是利用了\",{\"1\":{\"1411\":1}}],[\"这三个方法\",{\"1\":{\"1494\":1,\"1496\":1}}],[\"这三个方法清理掉\",{\"1\":{\"1317\":1}}],[\"这三种操作都是存在数据依赖性的\",{\"1\":{\"1418\":1}}],[\"这三种基本类型的原子更新的方法\",{\"1\":{\"1385\":1}}],[\"这几个状态会随着竞争情况逐渐升级\",{\"1\":{\"1440\":1}}],[\"这几个类提供的方法基本一致\",{\"1\":{\"1388\":1}}],[\"这几个类的使用方法也是基本一样的\",{\"1\":{\"1387\":1}}],[\"这几个类的用法一致\",{\"1\":{\"1386\":1}}],[\"这几个类的用法基本一致\",{\"1\":{\"1385\":1}}],[\"这几次尝试中\",{\"1\":{\"1276\":1}}],[\"这会创建一个新线程来执行\",{\"1\":{\"1330\":1}}],[\"这中间所有的\",{\"1\":{\"1316\":1}}],[\"这篇文章就主要来看看\",{\"1\":{\"1344\":1}}],[\"这篇文章\",{\"1\":{\"1344\":1,\"1370\":1}}],[\"这篇文章的\",{\"1\":{\"1306\":2}}],[\"这篇的\",{\"1\":{\"1306\":1}}],[\"这行代码在单线程中\",{\"1\":{\"1283\":1}}],[\"这很符合\",{\"1\":{\"1283\":1}}],[\"这下也正好验证了我们在最上面介绍时说的\",{\"1\":{\"1272\":1}}],[\"这部分代码通过\",{\"1\":{\"1317\":1}}],[\"这部分代码为\",{\"1\":{\"1272\":1}}],[\"这部分代码很好理解\",{\"1\":{\"1272\":1}}],[\"这部分是将标准错误输出\",{\"1\":{\"1087\":1}}],[\"这部分是将标准输出\",{\"1\":{\"1087\":1}}],[\"这段源码的逻辑也很容易理解\",{\"1\":{\"1510\":1}}],[\"这段方法跟独占式锁释放过程有点点不同\",{\"1\":{\"1511\":1}}],[\"这段方法的逻辑和\",{\"1\":{\"1302\":1}}],[\"这段方法与上面的\",{\"1\":{\"1251\":1}}],[\"这段代码逻辑就比较容易理解了\",{\"1\":{\"1506\":1}}],[\"这段代码只是增加了一个\",{\"1\":{\"1406\":1}}],[\"这段代码永远不会将\",{\"1\":{\"1283\":1}}],[\"这段代码主要做了两件事情\",{\"1\":{\"1252\":1}}],[\"这段代码调用\",{\"1\":{\"1251\":1}}],[\"这段代码就很容易理解了\",{\"1\":{\"1251\":1}}],[\"这段代码就不展开说了\",{\"1\":{\"1242\":1}}],[\"这段代码没有任何实际意义\",{\"1\":{\"1250\":1}}],[\"这段代码的逻辑请看注释\",{\"1\":{\"1239\":1,\"1270\":1}}],[\"这段代码的逻辑与\",{\"1\":{\"1233\":1}}],[\"这段代码的逻辑也很简单\",{\"1\":{\"1232\":1}}],[\"这次我们来分析客户端是如何注册的\",{\"1\":{\"1175\":1}}],[\"这意味着\",{\"1\":{\"1087\":1}}],[\"这可能需要重新哈希和复制整个表\",{\"1\":{\"973\":1}}],[\"这可能导致空间的浪费\",{\"1\":{\"973\":1}}],[\"这可以用\",{\"1\":{\"789\":1}}],[\"这将是一段独立的有效括号序列\",{\"1\":{\"846\":1}}],[\"这将给服务器带来巨大的负载压力\",{\"1\":{\"484\":1}}],[\"这两段代码已经解决了前面的两个问题的答案了\",{\"1\":{\"1251\":1}}],[\"这两种情况取最小值\",{\"1\":{\"795\":1,\"893\":1}}],[\"这两个操作是不能被重排序的\",{\"1\":{\"1476\":1}}],[\"这两个关键类\",{\"1\":{\"1365\":1}}],[\"这两个方法\",{\"1\":{\"1360\":1}}],[\"这两个方法的实现原理\",{\"1\":{\"1251\":1}}],[\"这两个接口的主要区别如下图所示\",{\"1\":{\"1326\":1}}],[\"这两个功能在后续篇章中都会讲到\",{\"1\":{\"1182\":1}}],[\"这两个数都不会以\",{\"1\":{\"698\":1}}],[\"这两个函数会返回\",{\"1\":{\"243\":1}}],[\"这条语句实际上包含了三个操作\",{\"1\":{\"1485\":1}}],[\"这条禁止重排序规则就是针对这些处理器而设定的\",{\"1\":{\"1475\":1}}],[\"这条命令的stdout\",{\"1\":{\"1120\":1}}],[\"这条路径可能经过也可能不经过根节点\",{\"1\":{\"759\":1}}],[\"这条边不要\",{\"1\":{\"361\":1}}],[\"这时调用\",{\"1\":{\"1360\":1}}],[\"这时重新令搜索起点为索引位置\",{\"1\":{\"1316\":1}}],[\"这时让\",{\"1\":{\"1274\":1}}],[\"这时\",{\"1\":{\"664\":1,\"846\":1,\"1254\":1,\"1284\":1}}],[\"这时候就需要使用\",{\"1\":{\"1398\":1}}],[\"这时候就需要\",{\"1\":{\"437\":1}}],[\"这时候\",{\"1\":{\"61\":1,\"1191\":1}}],[\"这比物理删除更加安全\",{\"1\":{\"575\":1}}],[\"这不仅影响性能\",{\"1\":{\"484\":1}}],[\"这是理解下面知识的前提条件\",{\"1\":{\"1434\":1}}],[\"这是为什么\",{\"1\":{\"1429\":1}}],[\"这是与\",{\"1\":{\"1393\":1}}],[\"这是两者主要的区别\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"这是两者的一个区别\",{\"1\":{\"1251\":1}}],[\"这是当前线程退出\",{\"1\":{\"1251\":1}}],[\"这是什么意思呢\",{\"1\":{\"1131\":1}}],[\"这是\",{\"1\":{\"1131\":1,\"1306\":1}}],[\"这是正转\",{\"1\":{\"1129\":1}}],[\"这是一种乐观策略\",{\"1\":{\"1266\":1}}],[\"这是一种c语言中的转换方式\",{\"1\":{\"251\":1}}],[\"这是一行注释\",{\"1\":{\"1109\":1}}],[\"这是一个计算圆面积的代码\",{\"1\":{\"1418\":1}}],[\"这是一个静态方法\",{\"1\":{\"1339\":1}}],[\"这是一个很底层的类\",{\"1\":{\"1259\":1}}],[\"这是一个\",{\"1\":{\"1087\":1,\"1404\":1}}],[\"这是非常不安全的\",{\"1\":{\"578\":1}}],[\"这是核心的定时任务表\",{\"1\":{\"476\":1}}],[\"这套架构\",{\"1\":{\"438\":1}}],[\"这天\",{\"1\":{\"290\":1}}],[\"这也就意味着\",{\"1\":{\"261\":1}}],[\"这也就变成了最佳优先搜索\",{\"1\":{\"216\":1}}],[\"这也是添加\",{\"1\":{\"1431\":1}}],[\"这也是面试经常被问的地方\",{\"1\":{\"1338\":1}}],[\"这也是为什么\",{\"1\":{\"1295\":1}}],[\"这也是容易造成找不到注册代码的一个原因\",{\"1\":{\"1184\":1}}],[\"这也是注释\",{\"1\":{\"1109\":1}}],[\"这也是\",{\"1\":{\"216\":1}}],[\"这也是一种\",{\"1\":{\"56\":1}}],[\"这通常称之为\",{\"1\":{\"215\":1}}],[\"这道题要求实现一个游戏排行榜系统\",{\"1\":{\"129\":1}}],[\"这实际上是一个带重复元素的组合问题\",{\"1\":{\"126\":1}}],[\"这\",{\"1\":{\"121\":1,\"224\":1,\"279\":1,\"287\":1,\"288\":1,\"289\":1,\"381\":2,\"1392\":1,\"1398\":1}}],[\"这些就是\",{\"1\":{\"1491\":1}}],[\"这些代码在\",{\"1\":{\"1491\":1}}],[\"这些优化既不会改变程序的执行结果\",{\"1\":{\"1423\":1}}],[\"这些重排序会导致线程安全的问题\",{\"1\":{\"1418\":1}}],[\"这些方法获取当前多个线程的状态\",{\"1\":{\"1394\":1}}],[\"这些方法实际上是利用了\",{\"1\":{\"1266\":1}}],[\"这些情况都称之为\",{\"1\":{\"1375\":1}}],[\"这些核心方法\",{\"1\":{\"1317\":1}}],[\"这些地方都会对脏\",{\"1\":{\"1307\":1}}],[\"这些\",{\"1\":{\"1305\":1}}],[\"这些配置项如果在配置文件中有\",{\"1\":{\"1151\":1}}],[\"这些是检查型异常\",{\"1\":{\"1044\":1}}],[\"这些异常一般是由程序逻辑错误引起的\",{\"1\":{\"1044\":1}}],[\"这些异常是非检查型异常\",{\"1\":{\"1044\":1}}],[\"这些异常发生时\",{\"1\":{\"1042\":1}}],[\"这些数组的元素是含有30个整数的数组\",{\"1\":{\"1000\":1}}],[\"这些数字组成的\",{\"1\":{\"121\":1}}],[\"这些完全平方数视作物品体积\",{\"1\":{\"795\":1}}],[\"这些静态文件可以直接由内容分发网络\",{\"1\":{\"534\":1}}],[\"这些人的编号为\",{\"1\":{\"273\":1}}],[\"这些操作后\",{\"1\":{\"104\":1}}],[\"这些关系型数据是发布时已经确定的\",{\"1\":{\"30\":1}}],[\"这种锁升级却不能降级的策略\",{\"1\":{\"1440\":1}}],[\"这种优化方式同样可以引申到锁优化上\",{\"1\":{\"1434\":1}}],[\"这种形式不能改变的话\",{\"1\":{\"1434\":1}}],[\"这种形式拼接字符串\",{\"1\":{\"1068\":1}}],[\"这种线程间的通信机制正好吻合\",{\"1\":{\"1433\":1}}],[\"这种同步机制效率很低\",{\"1\":{\"1429\":1}}],[\"这种更新方式会带有版本号\",{\"1\":{\"1388\":1}}],[\"这种数据更新的方法也具有高效性\",{\"1\":{\"1385\":1}}],[\"这种操作是不安全的\",{\"1\":{\"1340\":1}}],[\"这种节点在队列中存在的价值不大\",{\"1\":{\"1283\":1}}],[\"这种节点称之为哨兵节点\",{\"1\":{\"1283\":1}}],[\"这种方案的性能也是令人不太满意的\",{\"1\":{\"1264\":1}}],[\"这种方式肯定效率低下\",{\"1\":{\"1434\":1}}],[\"这种方式就是通知机制来完成协作\",{\"1\":{\"1416\":1}}],[\"这种方式要优雅和安全\",{\"1\":{\"1336\":1}}],[\"这种方式代替了锁\",{\"1\":{\"1276\":1}}],[\"这种方式和上面的接口的方式相比\",{\"1\":{\"1147\":1}}],[\"这种方式不安全\",{\"1\":{\"906\":1}}],[\"这种方式不仅解决了单点故障问题\",{\"1\":{\"484\":1}}],[\"这种方式本质上也是客户端渲染\",{\"1\":{\"534\":1}}],[\"这种信息就类似于记录\",{\"1\":{\"1259\":1}}],[\"这种现象就是通知过早的现象\",{\"1\":{\"1406\":1}}],[\"这种现象\",{\"1\":{\"1218\":1}}],[\"这种现象称为冲突\",{\"1\":{\"971\":1}}],[\"这种模式旨在避免因网络分区故障导致服务不可用的问题\",{\"1\":{\"1191\":1}}],[\"这种模式下\",{\"1\":{\"531\":1}}],[\"这种接口之前专门讲过\",{\"1\":{\"1178\":1}}],[\"这种机制使得即使部分磁盘发生故障\",{\"1\":{\"1095\":1}}],[\"这种异常分两大类运行时异常和非运行时异常\",{\"1\":{\"1042\":1}}],[\"这种设计模式就称为单例模式\",{\"1\":{\"963\":1}}],[\"这种子查询称为表子查询\",{\"1\":{\"951\":1}}],[\"这种子查询称为行子查询\",{\"1\":{\"950\":1}}],[\"这种子查询称为列子查询\",{\"1\":{\"949\":1}}],[\"这种子查询称为标量子查询\",{\"1\":{\"948\":1}}],[\"这种做法可以降低空间复杂度\",{\"1\":{\"888\":1}}],[\"这种序列\",{\"1\":{\"846\":1}}],[\"这种情况很显然需要在\",{\"1\":{\"1283\":1}}],[\"这种情况站在相对速率的角度来看\",{\"1\":{\"1283\":1}}],[\"这种情况就是阻塞\",{\"1\":{\"1225\":1}}],[\"这种情况下\",{\"1\":{\"846\":1}}],[\"这种情况下最多能获得21个优惠券\",{\"1\":{\"109\":1}}],[\"这种情况是可以容忍的\",{\"1\":{\"613\":1}}],[\"这种技术适用于那些大多数内容不变\",{\"1\":{\"534\":1}}],[\"这种写法包含了两种情况\",{\"1\":{\"328\":1}}],[\"这种题对于已访问的元素\",{\"1\":{\"235\":1}}],[\"这种题的⼤体思路和之前完全⼀样\",{\"1\":{\"230\":1}}],[\"这种单纯的题型\",{\"1\":{\"228\":1}}],[\"这种算法称之为最佳优先\",{\"1\":{\"214\":1}}],[\"这种算法就像洪水\",{\"1\":{\"212\":1}}],[\"这种迭代查询的方式也可以直接用图数据库来实现\",{\"1\":{\"56\":1}}],[\"这种用户推荐\",{\"1\":{\"39\":1}}],[\"这里采用的\",{\"1\":{\"1511\":1}}],[\"这里不仅仅值锁\",{\"1\":{\"1495\":1}}],[\"这里为什么要加\",{\"1\":{\"1485\":1}}],[\"这里能够计算出正确的结果是因为在做累加操作时使用了同步代码块\",{\"1\":{\"1449\":1}}],[\"这里存在这样一个有意思的问题\",{\"1\":{\"1439\":1}}],[\"这里存在一个问题\",{\"1\":{\"1272\":1}}],[\"这里使用if的话\",{\"1\":{\"1407\":2}}],[\"这里使用库函数二分的写法\",{\"1\":{\"324\":1}}],[\"这里举一个通俗的例子\",{\"1\":{\"1393\":1}}],[\"这里以\",{\"1\":{\"1385\":1}}],[\"这里对\",{\"1\":{\"1375\":1}}],[\"这里传入的是实现callable接口的任务\",{\"1\":{\"1367\":1}}],[\"这里传入的是实现runnable接口的任务\",{\"1\":{\"1367\":1}}],[\"这里就存在三种情况\",{\"1\":{\"1418\":1}}],[\"这里就存在内存泄漏的可能性\",{\"1\":{\"1306\":1}}],[\"这里就会存在一个问题\",{\"1\":{\"1384\":1}}],[\"这里就是我们的突破口\",{\"1\":{\"1290\":1}}],[\"这里就是\",{\"1\":{\"1184\":1}}],[\"这里介绍一种最简单的\",{\"1\":{\"1306\":1}}],[\"这里还有这样一个问题\",{\"1\":{\"1295\":1}}],[\"这里实例变量\",{\"1\":{\"1283\":1}}],[\"这里是控制并发扩容的核心\",{\"1\":{\"1274\":1}}],[\"这里在\",{\"1\":{\"1271\":1}}],[\"这里才真正的初始化数组\",{\"1\":{\"1271\":1}}],[\"这里将这些方法做一个总结\",{\"1\":{\"1259\":1}}],[\"这里需要注意的是守护线程在退出的时候并不会执行\",{\"1\":{\"1340\":1}}],[\"这里需要注意的是\",{\"1\":{\"1240\":1}}],[\"这里有一个地方需要重点关注\",{\"1\":{\"1239\":1}}],[\"这里简单做个小结\",{\"1\":{\"1237\":1}}],[\"这里从\",{\"1\":{\"893\":1}}],[\"这里用一个简单的例子来看下它的具体使用\",{\"1\":{\"1399\":1}}],[\"这里用\",{\"1\":{\"795\":1}}],[\"这里我就只把结果说出来\",{\"1\":{\"1454\":1}}],[\"这里我就称之为\",{\"1\":{\"1314\":1}}],[\"这里我使用\",{\"1\":{\"671\":1}}],[\"这里我结合日常使用习惯和需要\",{\"1\":{\"668\":1}}],[\"这里我们不再打印根节点\",{\"1\":{\"725\":1}}],[\"这里我们在\",{\"1\":{\"576\":1}}],[\"这里我们计算下最短路径\",{\"1\":{\"237\":1}}],[\"这里我们仍然用\",{\"1\":{\"229\":1}}],[\"这里总结一下如何通过\",{\"1\":{\"613\":1}}],[\"这里后面再调整\",{\"1\":{\"589\":1}}],[\"这里设置为\",{\"1\":{\"576\":1}}],[\"这里选择使用\",{\"1\":{\"559\":1}}],[\"这里展示的只是我个人总结下来的一些使用\",{\"1\":{\"238\":1}}],[\"这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且\",{\"1\":{\"1510\":1}}],[\"这里的2\",{\"1\":{\"1455\":1}}],[\"这里的需要注意的是\",{\"1\":{\"1430\":1}}],[\"这里的第三个关系是利用传递性进行推论的\",{\"1\":{\"1421\":1}}],[\"这里的线程指的是并发执行的活动实体\",{\"1\":{\"1416\":1}}],[\"这里的\",{\"1\":{\"219\":1,\"1283\":1,\"1393\":1}}],[\"这里的d是指两个相邻节点之间的移动代价\",{\"1\":{\"218\":1}}],[\"这里可以使用滑动窗口统计\",{\"1\":{\"61\":1}}],[\"这里\",{\"1\":{\"46\":1,\"1271\":1,\"1295\":1,\"1306\":1}}],[\"这里也利用了消息队列的\",{\"1\":{\"28\":1}}],[\"这样针对\",{\"1\":{\"1454\":1}}],[\"这样它们就可以做尽可能多的优化来提高性能\",{\"1\":{\"1423\":1}}],[\"这样我们就可以根据规则去推论跨线程的内存可见性问题\",{\"1\":{\"1419\":1}}],[\"这样我们才能随时随地使用它\",{\"1\":{\"671\":1}}],[\"这样当\",{\"1\":{\"1407\":1}}],[\"这样当两个边进行比较的时候就会使用他们的权重进行比较了\",{\"1\":{\"361\":1}}],[\"这样便保证了程序的正确性\",{\"1\":{\"1406\":1}}],[\"这样也是为了保证吞吐量\",{\"1\":{\"1398\":1}}],[\"这样也说明了退出\",{\"1\":{\"1251\":1}}],[\"这样生产者线程和消费者线程就能够进行解耦\",{\"1\":{\"1324\":1}}],[\"这样每个同学都使用自己的\",{\"1\":{\"1313\":1}}],[\"这样每个线程使用自己的对象实例\",{\"1\":{\"1313\":1}}],[\"这样设计会多出在循环中定位队尾节点\",{\"1\":{\"1286\":1}}],[\"这样存的话我反过来这么取就好了\",{\"1\":{\"1273\":1}}],[\"这样不仅可以保证线程安全\",{\"1\":{\"1344\":1}}],[\"这样不仅能够使得\",{\"1\":{\"1272\":1}}],[\"这样不同的业务只需要设计自己的策略接入评论系统即可\",{\"1\":{\"45\":1}}],[\"这样会造成大量的线程都处于等待状态\",{\"1\":{\"1220\":1}}],[\"这样宽度就会增加从而降低树的高度\",{\"1\":{\"958\":1}}],[\"这样确实比之前的方式快了很多\",{\"1\":{\"958\":1}}],[\"这样初始的烂橘子时间为\",{\"1\":{\"869\":1}}],[\"这样最后如果发现\",{\"1\":{\"869\":1}}],[\"这样二维矩阵就被抽象成了一幅网状的\",{\"1\":{\"820\":1}}],[\"这样才能更好的利用\",{\"1\":{\"1361\":1}}],[\"这样才能保证前面的状态不会被后面覆盖\",{\"1\":{\"772\":1}}],[\"这样才能让\",{\"1\":{\"772\":1}}],[\"这样如果国内能访问就优先用国内线路\",{\"1\":{\"665\":1}}],[\"这样在多线程竞争的条件下\",{\"1\":{\"1220\":1}}],[\"这样在\",{\"1\":{\"613\":1,\"1458\":1}}],[\"这样一来\",{\"1\":{\"534\":1,\"535\":1,\"1305\":1}}],[\"这样直接用\",{\"1\":{\"421\":1}}],[\"这样可以尽可能降低系统资源消耗\",{\"1\":{\"1359\":1}}],[\"这样可以降低线程由于线程无法获取到\",{\"1\":{\"1353\":1}}],[\"这样可以防止攻击者使用相同的方式对一组用户的密码执行攻击\",{\"1\":{\"568\":1}}],[\"这样可以最大化三个数字的乘积\",{\"1\":{\"167\":1}}],[\"这样可以高效地处理相同积分的情况\",{\"1\":{\"129\":1}}],[\"这样可以大大减少查询\",{\"1\":{\"60\":1}}],[\"这样就可能出现错误\",{\"1\":{\"1475\":1}}],[\"这样就可以方便的实现不同类型的同步组件\",{\"1\":{\"1494\":1}}],[\"这样就可以对各个模块的业务功能进行解耦\",{\"1\":{\"1324\":1}}],[\"这样就可以通过\",{\"1\":{\"1306\":1}}],[\"这样就可以省去刚开始向下\",{\"1\":{\"796\":1}}],[\"这样就可以解决布隆过滤器无法删除元素的缺点了\",{\"1\":{\"613\":1}}],[\"这样就可以最大程度地利用桌子资源\",{\"1\":{\"162\":1}}],[\"这样就可以根据某个主题查询\",{\"1\":{\"58\":1}}],[\"这样就能保证每个线程所获得共享变量的值都是当前最新的值\",{\"1\":{\"1449\":1}}],[\"这样就能避免头重脚轻\",{\"1\":{\"274\":1}}],[\"这样就无法真正达到业务逻辑的目的\",{\"1\":{\"1318\":1}}],[\"这样就存在了内存泄漏\",{\"1\":{\"1313\":1}}],[\"这样就完成了对各个对象之间关系的控制\",{\"1\":{\"1132\":1}}],[\"这样就实现了无感知地调用\",{\"1\":{\"676\":1}}],[\"这样就实现了一个图床的效果\",{\"1\":{\"670\":1}}],[\"这样就不会有任何数据安全的问题\",{\"1\":{\"1429\":1}}],[\"这样就不会有丢失子树的问题了\",{\"1\":{\"725\":1}}],[\"这样就不会出现线程安全的问题\",{\"1\":{\"1299\":1}}],[\"这样就不用到设置里面配置代理了\",{\"1\":{\"665\":1}}],[\"这样就不用重复去\",{\"1\":{\"60\":1}}],[\"这样就不能再继续下去了\",{\"1\":{\"99\":1}}],[\"这样\",{\"1\":{\"60\":1,\"128\":1,\"484\":1,\"777\":1,\"1087\":1,\"1406\":1,\"1449\":1}}],[\"这样的工具类\",{\"1\":{\"1392\":1}}],[\"这样的缓存策略来处理任务\",{\"1\":{\"1359\":1}}],[\"这样的异常\",{\"1\":{\"1340\":1}}],[\"这样的并发性能的确不令人满意\",{\"1\":{\"1264\":1}}],[\"这样的设计\",{\"1\":{\"1095\":1}}],[\"这样的话\",{\"1\":{\"523\":1,\"1150\":1}}],[\"这样的局面被称为必胜\",{\"1\":{\"394\":1}}],[\"这样的路\",{\"1\":{\"237\":1}}],[\"这样的好处是\",{\"1\":{\"56\":1}}],[\"这样的数据结构\",{\"1\":{\"40\":1}}],[\"这样效率很低\",{\"1\":{\"56\":1}}],[\"这样做有一个缺点\",{\"1\":{\"1286\":1}}],[\"这样做之后\",{\"1\":{\"212\":1}}],[\"这样做是为了避免每次需要统计总数时都要做一次\",{\"1\":{\"56\":1}}],[\"这样做的好处是读取速度快\",{\"1\":{\"484\":1}}],[\"这样做的好处是\",{\"1\":{\"40\":1}}],[\"这样方便我们串行消费\",{\"1\":{\"49\":1}}],[\"这样运营端的查询压力就下方给了独立的\",{\"1\":{\"46\":1}}],[\"这样让上游可以灵活组织逻辑\",{\"1\":{\"46\":1}}],[\"这就像线程\",{\"1\":{\"1433\":1}}],[\"这就像两个好基友\",{\"1\":{\"1337\":1}}],[\"这就出现了\",{\"1\":{\"1417\":1}}],[\"这就有点像报数的感觉\",{\"1\":{\"1393\":1}}],[\"这就类似同步调用\",{\"1\":{\"1223\":1}}],[\"这就好比你可以先把自己想要的妹子想好了\",{\"1\":{\"1133\":1}}],[\"这就好比你出生你家里就给你指定了你媳妇\",{\"1\":{\"1133\":1}}],[\"这就意味着个人也可以基于\",{\"1\":{\"1094\":1}}],[\"这就是使用\",{\"1\":{\"1495\":1}}],[\"这就是锁的重入性\",{\"1\":{\"1431\":1}}],[\"这就是需要禁止重排序\",{\"1\":{\"1425\":1}}],[\"这就是数据可见性的问题\",{\"1\":{\"1425\":1}}],[\"这就是一种\",{\"1\":{\"1299\":1}}],[\"这就是\",{\"1\":{\"839\":1}}],[\"这就是缓存穿透\",{\"1\":{\"613\":1}}],[\"这就是所谓的单点故障问题\",{\"1\":{\"484\":1}}],[\"这就是做一个削峰的处理\",{\"1\":{\"49\":1}}],[\"这就要求缓存命中率要非常高\",{\"1\":{\"40\":1}}],[\"这就对数据一致性\",{\"1\":{\"36\":1}}],[\"这个例子也是来源于\",{\"1\":{\"1496\":1}}],[\"这个例子很简单\",{\"1\":{\"1399\":1}}],[\"这个规则仅仅是针对处理器\",{\"1\":{\"1475\":1}}],[\"这个规则的实现主要包含了两个方面\",{\"1\":{\"1475\":1}}],[\"这个屏障可以禁止处理器把\",{\"1\":{\"1475\":1}}],[\"这个引用的对象能够改变吗\",{\"1\":{\"1467\":1}}],[\"这个写回内存的操作会使得其他\",{\"1\":{\"1454\":1}}],[\"这个时机对普通变量是没有规定的\",{\"1\":{\"1453\":1}}],[\"这个时候引用对象\",{\"1\":{\"1478\":1}}],[\"这个时候就是最新的值\",{\"1\":{\"1433\":1}}],[\"这个时候就需要我们给接口放行\",{\"1\":{\"468\":1}}],[\"这个时候两个线程就都达到了同步点\",{\"1\":{\"1399\":1}}],[\"这个时候只打印了\",{\"1\":{\"1340\":1}}],[\"这个时候产品\",{\"1\":{\"1337\":1}}],[\"这个时候他就会在原处等一等这个基友\",{\"1\":{\"1337\":1}}],[\"这个时候\",{\"1\":{\"1283\":1,\"1284\":1,\"1407\":2}}],[\"这个时候其他线程在\",{\"1\":{\"1271\":1}}],[\"这个时候你需要采用如下做法来保护你的海外服务器以及\",{\"1\":{\"664\":1}}],[\"这个共享数据区域中应该具备这样的线程间并发协作的功能\",{\"1\":{\"1402\":1}}],[\"这个线程会进入等待状态\",{\"1\":{\"1332\":1}}],[\"这个线程安全的队列\",{\"1\":{\"1280\":1}}],[\"这个容器中\",{\"1\":{\"1301\":1}}],[\"这个操作并非一个原子操作\",{\"1\":{\"1283\":1}}],[\"这个操作是单线程完成的\",{\"1\":{\"1274\":1}}],[\"这个也是触发并发扩容的关键点\",{\"1\":{\"1274\":1}}],[\"这个方法的作用就是排队获取锁的过程\",{\"1\":{\"1504\":1}}],[\"这个方法的基本思想跟\",{\"1\":{\"1274\":1}}],[\"这个方法也是关键方法\",{\"1\":{\"1370\":1}}],[\"这个方法显然是\",{\"1\":{\"1338\":1}}],[\"这个方法同样很好理解\",{\"1\":{\"1307\":1}}],[\"这个方法是\",{\"1\":{\"1302\":1}}],[\"这个方法一共做了两件事\",{\"1\":{\"1275\":1}}],[\"这个方法在介绍\",{\"1\":{\"1251\":1}}],[\"这个列表里面会显示最后\",{\"1\":{\"1196\":1}}],[\"这个列表里面会显示最近\",{\"1\":{\"1196\":1}}],[\"这个类名可以顾名思义的进行理解\",{\"1\":{\"1299\":1}}],[\"这个类并不负责包装用户的\",{\"1\":{\"1267\":1}}],[\"这个类在工程\",{\"1\":{\"1184\":1}}],[\"这个类就是一个单例类\",{\"1\":{\"963\":1}}],[\"这个隐藏的有点深啊\",{\"1\":{\"1178\":1}}],[\"这个里面也有注册的逻辑\",{\"1\":{\"1182\":1}}],[\"这个里面的信息包含了第一步初始化变量中的配置信息\",{\"1\":{\"1179\":1}}],[\"这个里面会初始化注册表\",{\"1\":{\"1165\":1}}],[\"这个里面就是启动了一个定时任务\",{\"1\":{\"1165\":1}}],[\"这个里面就会根据\",{\"1\":{\"1158\":1}}],[\"这个集合不包含本地节点的\",{\"1\":{\"1165\":1}}],[\"这个集合指当前已经在连通块中的所有点\",{\"1\":{\"360\":1}}],[\"这个监听器监听到状态改变时\",{\"1\":{\"1158\":1}}],[\"这个发送心跳的操作由一个\",{\"1\":{\"1158\":1}}],[\"这个刷新的操作是由一个\",{\"1\":{\"1158\":1}}],[\"这个文件就是\",{\"1\":{\"1157\":1}}],[\"这个\",{\"1\":{\"1153\":1,\"1154\":1,\"1178\":1,\"1275\":1,\"1305\":2}}],[\"这个就是\",{\"1\":{\"1153\":1}}],[\"这个就是大名鼎鼎的\",{\"1\":{\"1140\":1}}],[\"这个单例又是\",{\"1\":{\"1150\":1}}],[\"这个过程是比较耗时的\",{\"1\":{\"1434\":1}}],[\"这个过程是复杂深奥的\",{\"1\":{\"1131\":1}}],[\"这个过程与广度优先搜索的过程一致\",{\"1\":{\"869\":1}}],[\"这个符号是在命令的末尾\",{\"1\":{\"1087\":1}}],[\"这个set中包含map中所有的key\",{\"1\":{\"1074\":1}}],[\"这个消息在throwable\",{\"1\":{\"1046\":1}}],[\"这个抽象的概念\",{\"1\":{\"1025\":1}}],[\"这个哈希值是一个整数\",{\"1\":{\"971\":1}}],[\"这个节点和周围的四个节点连通\",{\"1\":{\"820\":1}}],[\"这个状态已经被计算过\",{\"1\":{\"784\":1}}],[\"这个数是有特殊意义的\",{\"1\":{\"1306\":1}}],[\"这个数据结构必要的条件\",{\"1\":{\"687\":1}}],[\"这个数本身\",{\"1\":{\"309\":1}}],[\"这个网盘就已经搭建完成可以使用了\",{\"1\":{\"670\":1}}],[\"这个公式求出每个质因子的次数\",{\"1\":{\"390\":1}}],[\"这个步骤\",{\"1\":{\"377\":1}}],[\"这个点还未被匹配\",{\"1\":{\"363\":1}}],[\"这个前缀和本身就是\",{\"1\":{\"261\":1}}],[\"这个思路是没有问题的\",{\"1\":{\"162\":1}}],[\"这个项链还没有封口\",{\"1\":{\"103\":1}}],[\"这个楼层发号操作必须是在一个评论区范围内串行的\",{\"1\":{\"28\":1}}],[\"这个长耗时几乎是不可接受的\",{\"1\":{\"28\":1}}],[\"这一波就凑齐了\",{\"1\":{\"1393\":1}}],[\"这一部分就是处理多个线程\",{\"1\":{\"1284\":1}}],[\"这一点是通过\",{\"1\":{\"1132\":1}}],[\"这一数据结构有相当多的应用情景\",{\"1\":{\"801\":1}}],[\"这一步的意思是\",{\"1\":{\"664\":2}}],[\"这一步类似完全背包的推导\",{\"1\":{\"308\":1}}],[\"这一项\",{\"1\":{\"380\":1}}],[\"这一项在\",{\"1\":{\"380\":1}}],[\"这一对有发生反转的前\",{\"1\":{\"104\":1}}],[\"这一对没有发生反转的前\",{\"1\":{\"104\":1}}],[\"这一层抽象把评论的本身的内容列表处理\",{\"1\":{\"46\":1}}],[\"这一层的职责就是接收规则机返回的各种决策并执行\",{\"1\":{\"40\":1}}],[\"这一层是较少做业务逻辑变更的\",{\"1\":{\"27\":1}}],[\"这一阶段\",{\"1\":{\"40\":1}}],[\"这一套流程对外提供了一个原子化的数据读取功能\",{\"1\":{\"28\":1}}],[\"策略考量\",{\"1\":{\"28\":1}}],[\"基本数据类型的重排序规则在这里还是使用\",{\"1\":{\"1476\":1}}],[\"基本数据类型\",{\"0\":{\"1467\":1},\"1\":{\"1476\":1}}],[\"基本的使用范式如下\",{\"1\":{\"1408\":1}}],[\"基本功能一样\",{\"1\":{\"1326\":1}}],[\"基本操作总结\",{\"0\":{\"1374\":1}}],[\"基本操作总结如下\",{\"1\":{\"1325\":1}}],[\"基本操作如下图所示\",{\"1\":{\"1326\":1}}],[\"基本操作\",{\"0\":{\"1325\":1},\"1\":{\"1325\":1}}],[\"基本操作主要有\",{\"1\":{\"267\":1}}],[\"基本一致\",{\"1\":{\"1240\":1}}],[\"基本上所有方法的实现\",{\"1\":{\"1493\":1}}],[\"基本上和\",{\"1\":{\"1351\":1}}],[\"基本上与\",{\"1\":{\"1251\":1}}],[\"基本上一致\",{\"1\":{\"1233\":1}}],[\"基本上分为三种\",{\"1\":{\"936\":1}}],[\"基本介绍\",{\"0\":{\"1231\":1}}],[\"基本类型的最大值和最小值\",{\"0\":{\"1083\":1}}],[\"基本思想\",{\"1\":{\"990\":1}}],[\"基本思路\",{\"1\":{\"381\":1}}],[\"基本\",{\"1\":{\"984\":1}}],[\"基本信息\",{\"1\":{\"938\":1}}],[\"基本信息+身份信息\",{\"1\":{\"938\":1}}],[\"基本查询\",{\"0\":{\"930\":1},\"1\":{\"929\":1}}],[\"基本步骤\",{\"1\":{\"355\":1}}],[\"基本模板\",{\"0\":{\"268\":1}}],[\"基本不会修改\",{\"1\":{\"30\":1}}],[\"基于接口的方式\",{\"1\":{\"1147\":1}}],[\"基于前缀树结构\",{\"1\":{\"802\":1}}],[\"基于原始的\",{\"1\":{\"540\":1}}],[\"基于这些优缺点\",{\"1\":{\"534\":1}}],[\"基于这种冗余设计\",{\"1\":{\"37\":1}}],[\"基于token\",{\"1\":{\"446\":1}}],[\"基于大数据的发展\",{\"1\":{\"434\":1}}],[\"基于平衡二叉树\",{\"1\":{\"422\":1}}],[\"基于\",{\"0\":{\"1202\":1,\"1205\":1,\"1208\":1},\"1\":{\"56\":1,\"544\":1,\"1093\":1,\"1095\":1,\"1202\":1,\"1290\":1}}],[\"基于用户正负样本投票的\",{\"1\":{\"39\":1}}],[\"基于安全\",{\"1\":{\"28\":1}}],[\"基础上增加了超时等待的功能\",{\"1\":{\"1500\":1}}],[\"基础上增加了超时等待功能\",{\"1\":{\"1500\":1}}],[\"基础知识\",{\"0\":{\"904\":1,\"976\":1}}],[\"基础布局示例\",{\"1\":{\"548\":1}}],[\"基础布局结构\",{\"0\":{\"548\":1}}],[\"基础规则\",{\"1\":{\"542\":1}}],[\"基础功能\",{\"0\":{\"496\":1,\"507\":1}}],[\"基础功能模块\",{\"0\":{\"22\":1}}],[\"基础\",{\"0\":{\"905\":1},\"2\":{\"443\":1,\"961\":1,\"975\":1,\"1065\":1,\"1127\":1}}],[\"基础算法\",{\"0\":{\"316\":1},\"1\":{\"3\":1}}],[\"诸如评论发布等操作\",{\"1\":{\"28\":1}}],[\"削峰处理\",{\"1\":{\"28\":1,\"46\":1}}],[\"高\",{\"1\":{\"1361\":1}}],[\"高效的数据检索\",{\"1\":{\"972\":1}}],[\"高效保障技术实践\",{\"1\":{\"627\":1}}],[\"高效地开发和集成复杂的应用软件\",{\"1\":{\"14\":1}}],[\"高性能的工具类\",{\"1\":{\"1491\":1}}],[\"高性能\",{\"1\":{\"534\":1,\"1094\":1,\"1095\":1}}],[\"高级表格的属性\",{\"1\":{\"592\":1}}],[\"高级表格\",{\"1\":{\"592\":1}}],[\"高级功能\",{\"0\":{\"497\":1,\"508\":1}}],[\"高级数据结构来提升性能\",{\"1\":{\"493\":1}}],[\"高级解法\",{\"1\":{\"224\":1}}],[\"高可用性\",{\"1\":{\"484\":1}}],[\"高斯消元适用解法\",{\"1\":{\"385\":1}}],[\"高斯消元\",{\"0\":{\"385\":1}}],[\"高位补0\",{\"1\":{\"337\":1}}],[\"高位丢弃\",{\"1\":{\"337\":1}}],[\"高位在后面\",{\"1\":{\"328\":1}}],[\"高精\",{\"1\":{\"329\":1,\"330\":1}}],[\"高精度乘低精度模板\",{\"1\":{\"390\":1}}],[\"高精度整数除法\",{\"0\":{\"330\":1}}],[\"高精度整数乘法\",{\"0\":{\"329\":1}}],[\"高精度减法\",{\"0\":{\"328\":1}}],[\"高精度加法\",{\"0\":{\"327\":1}}],[\"高精度算法\",{\"0\":{\"326\":1}}],[\"高度小的接在高的下面\",{\"1\":{\"274\":1}}],[\"高度小一些的树接到大一些的树下面\",{\"1\":{\"274\":1}}],[\"高度数组\",{\"1\":{\"274\":1}}],[\"高度\",{\"1\":{\"274\":1}}],[\"高度是小于等于\",{\"1\":{\"128\":1}}],[\"高并发\",{\"1\":{\"1200\":1}}],[\"高并发处理\",{\"1\":{\"151\":1}}],[\"高并发的热点处理实践\",{\"1\":{\"33\":1,\"41\":1}}],[\"高吞吐的调用做异步化\",{\"1\":{\"28\":1}}],[\"的条件是前驱节点是头结点并且成功获得了同步状态\",{\"1\":{\"1506\":1}}],[\"的条件发生变化\",{\"0\":{\"1407\":1}}],[\"的使用\",{\"1\":{\"1496\":1}}],[\"的使用场景\",{\"0\":{\"1309\":1}}],[\"的静态内部类\",{\"1\":{\"1496\":1,\"1501\":1}}],[\"的静态内存类\",{\"1\":{\"1495\":1,\"1496\":1}}],[\"的静态方法\",{\"1\":{\"1336\":1,\"1338\":2}}],[\"的静态方法将\",{\"1\":{\"1290\":1}}],[\"的这个值自然而然就是一个过期的值\",{\"1\":{\"1482\":1}}],[\"的这种情况\",{\"1\":{\"1283\":1}}],[\"的这种用法有点类似于我们用\",{\"1\":{\"1020\":1}}],[\"的非原子性协定\",{\"1\":{\"1482\":1}}],[\"的普通域\",{\"1\":{\"1475\":1}}],[\"的例子\",{\"0\":{\"1472\":1}}],[\"的属性改成\",{\"1\":{\"1467\":1}}],[\"的变量进行写操作\",{\"1\":{\"1454\":1}}],[\"的变化如下图所示\",{\"1\":{\"1295\":1}}],[\"的作者经过研究发现\",{\"1\":{\"1441\":1}}],[\"的作用是读取\",{\"1\":{\"1139\":1}}],[\"的应用场景\",{\"0\":{\"1438\":1}}],[\"的监视器占有者释放后\",{\"1\":{\"1431\":1}}],[\"的监视器\",{\"1\":{\"1431\":1}}],[\"的现象\",{\"1\":{\"1425\":1}}],[\"的关键\",{\"1\":{\"1494\":1}}],[\"的关键字和\",{\"1\":{\"1423\":1}}],[\"的关系\",{\"0\":{\"1424\":1},\"1\":{\"1422\":1}}],[\"的关系的时候\",{\"1\":{\"1306\":1}}],[\"的概念来指定两个操作之间的执行顺序\",{\"1\":{\"1420\":1}}],[\"的概念最初由\",{\"1\":{\"1420\":1}}],[\"的概念后\",{\"1\":{\"1132\":1}}],[\"的编译器重排序规则会禁止一些特定类型的编译器重排序\",{\"1\":{\"1418\":1}}],[\"的编排\",{\"1\":{\"1095\":1}}],[\"的工作内存该变量值就会失效\",{\"1\":{\"1458\":1}}],[\"的工作内存中去\",{\"1\":{\"1433\":1}}],[\"的工作内存后并进行操作\",{\"1\":{\"1417\":1}}],[\"的工作就是按照执行时间的升序来排列\",{\"1\":{\"1369\":1}}],[\"的处理速度和主存的读写速度不是一个量级的\",{\"1\":{\"1417\":1}}],[\"的具体底层实现\",{\"1\":{\"1431\":1}}],[\"的具体使用场景\",{\"0\":{\"1463\":1}}],[\"的具体使用\",{\"1\":{\"1398\":1}}],[\"的具体用法\",{\"1\":{\"1392\":1}}],[\"的具体逻辑\",{\"1\":{\"687\":1}}],[\"的获取也可以通过\",{\"1\":{\"1376\":1}}],[\"的获取配置项的方法\",{\"1\":{\"1151\":1}}],[\"的已完成状态\",{\"1\":{\"1375\":1}}],[\"的通知机制来完成可阻塞式的插入数据和获取数据\",{\"1\":{\"1348\":1}}],[\"的通知机制呢\",{\"1\":{\"1345\":1}}],[\"的中断标志位清零\",{\"1\":{\"1336\":1}}],[\"的中序遍历是升序的\",{\"1\":{\"814\":1}}],[\"的基本使用\",{\"0\":{\"1376\":1},\"1\":{\"1399\":1}}],[\"的基本操作可以分为四种类型\",{\"1\":{\"1326\":1}}],[\"的基本操作\",{\"1\":{\"1326\":1}}],[\"的基本对象\",{\"1\":{\"1100\":1}}],[\"的顺序不是遵守严格的时间顺序\",{\"1\":{\"1326\":1}}],[\"的顺序保存的\",{\"1\":{\"958\":1}}],[\"的引用关系看起来\",{\"1\":{\"1318\":1}}],[\"的引用是作为\",{\"1\":{\"1301\":1}}],[\"的生命周期相同\",{\"1\":{\"1319\":1}}],[\"的生命周期\",{\"1\":{\"1318\":1}}],[\"的生命周期里\",{\"1\":{\"1317\":1}}],[\"的生日\",{\"1\":{\"129\":1}}],[\"的清理\",{\"1\":{\"1317\":1}}],[\"的相邻位置也有很大概率出现脏\",{\"1\":{\"1317\":1}}],[\"的相对速率快于\",{\"1\":{\"1283\":1}}],[\"的功能实际上别切分成各自的两部分\",{\"1\":{\"1496\":1}}],[\"的功能\",{\"1\":{\"1317\":1}}],[\"的脏\",{\"1\":{\"1316\":1,\"1317\":2,\"1318\":1}}],[\"的取值\",{\"1\":{\"1315\":1}}],[\"的初始值\",{\"1\":{\"1315\":1}}],[\"的初始网格描绘出来\",{\"1\":{\"224\":1,\"279\":1}}],[\"的得来是因为\",{\"1\":{\"1315\":1}}],[\"的用途\",{\"1\":{\"1315\":1}}],[\"的用法\",{\"1\":{\"1254\":1,\"1385\":1,\"1393\":1}}],[\"的用法和\",{\"1\":{\"423\":1}}],[\"的业务场景\",{\"1\":{\"1309\":1}}],[\"的加载因子都为\",{\"1\":{\"1306\":1}}],[\"的确定\",{\"1\":{\"1306\":1}}],[\"的拉链法\",{\"1\":{\"1306\":1}}],[\"的键值对\",{\"1\":{\"1305\":1}}],[\"的键值对即可\",{\"1\":{\"1303\":1}}],[\"的键值对存入\",{\"1\":{\"1301\":2}}],[\"的写入对线程\",{\"1\":{\"1476\":1}}],[\"的写时复制机制\",{\"1\":{\"1295\":1}}],[\"的写法\",{\"1\":{\"298\":1}}],[\"的缺点\",{\"1\":{\"1295\":1}}],[\"的缺点包括\",{\"1\":{\"532\":1,\"533\":1}}],[\"的语义\",{\"1\":{\"1295\":1}}],[\"的语法\",{\"1\":{\"545\":1}}],[\"的修饰的仅仅只是数组引用\",{\"1\":{\"1295\":1}}],[\"的能从数组中读取数据\",{\"1\":{\"1295\":1}}],[\"的读效率更高的话\",{\"1\":{\"1290\":1}}],[\"的更新也是利用了\",{\"1\":{\"1496\":1}}],[\"的更新也是同样的道理\",{\"1\":{\"1286\":1}}],[\"的更新\",{\"1\":{\"1286\":1}}],[\"的更新是\",{\"1\":{\"1286\":1}}],[\"的更新方式为\",{\"1\":{\"354\":1}}],[\"的执行结果\",{\"1\":{\"1433\":1}}],[\"的执行结果对线程\",{\"1\":{\"1432\":1}}],[\"的执行结果对\",{\"1\":{\"1432\":1,\"1433\":1,\"1455\":1}}],[\"的执行示意图如下\",{\"1\":{\"1393\":1}}],[\"的执行顺序先于\",{\"1\":{\"1432\":1,\"1455\":1}}],[\"的执行顺序排在\",{\"1\":{\"1420\":1}}],[\"的执行顺序\",{\"1\":{\"1284\":1,\"1455\":1}}],[\"的执行逻辑为\",{\"1\":{\"1283\":1}}],[\"的思维方式\",{\"1\":{\"1284\":1}}],[\"的思路\",{\"1\":{\"48\":1,\"61\":1}}],[\"的整型变量\",{\"1\":{\"1385\":1}}],[\"的整体思路\",{\"1\":{\"1284\":1}}],[\"的整数\",{\"1\":{\"886\":1}}],[\"的整数倍\",{\"1\":{\"76\":1,\"193\":1,\"680\":1}}],[\"的速度慢于\",{\"1\":{\"1283\":1}}],[\"的速度快于\",{\"1\":{\"1283\":1}}],[\"的速度沿\",{\"1\":{\"97\":1}}],[\"的两个内部类\",{\"1\":{\"1370\":1}}],[\"的两个节点\",{\"1\":{\"753\":1}}],[\"的两倍即\",{\"1\":{\"1274\":1}}],[\"的要求\",{\"1\":{\"1274\":1}}],[\"的性能\",{\"1\":{\"1272\":2}}],[\"的性能会持平甚至在某些情况更优\",{\"1\":{\"1264\":1}}],[\"的性能会更高些\",{\"1\":{\"920\":1}}],[\"的说明请看上面的说明\",{\"1\":{\"1270\":1}}],[\"的幂次方特性\",{\"1\":{\"1270\":1}}],[\"的幂次方数\",{\"1\":{\"1270\":1}}],[\"的幂次方\",{\"1\":{\"1266\":1,\"1270\":1,\"1272\":1,\"1305\":1,\"1306\":1}}],[\"的版本网上资料很多\",{\"1\":{\"1264\":1}}],[\"的版本要求必须\",{\"1\":{\"537\":1}}],[\"的信息\",{\"1\":{\"1259\":1}}],[\"的阻塞对象的重载方法\",{\"1\":{\"1259\":1}}],[\"的底层实现\",{\"1\":{\"1258\":1}}],[\"的底层实现时说过\",{\"1\":{\"1251\":1}}],[\"的结果\",{\"1\":{\"1482\":1}}],[\"的结合思考\",{\"0\":{\"1253\":1}}],[\"的结构就决定了它与\",{\"1\":{\"1140\":1}}],[\"的同级目录之后\",{\"1\":{\"1431\":1}}],[\"的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程\",{\"1\":{\"1251\":1}}],[\"的同学尽量使用\",{\"1\":{\"128\":2}}],[\"的内存模型正好是共享内存的并发模型结构\",{\"1\":{\"1433\":1}}],[\"的内存语义实现\",{\"0\":{\"1457\":1}}],[\"的内存语义\",{\"0\":{\"1456\":1},\"1\":{\"1433\":1,\"1456\":1,\"1457\":1}}],[\"的内存泄漏做了很详细的分析\",{\"1\":{\"1320\":1}}],[\"的内存泄漏问题\",{\"1\":{\"1305\":1}}],[\"的内部类\",{\"1\":{\"1250\":1}}],[\"的内容部分或全部元素删除\",{\"1\":{\"200\":1}}],[\"的源码中为其定义了这些状态\",{\"1\":{\"1375\":1}}],[\"的源码分析看\",{\"1\":{\"1370\":1}}],[\"的源码为\",{\"1\":{\"1251\":1,\"1252\":1,\"1283\":1}}],[\"的源码\",{\"1\":{\"1250\":1}}],[\"的原因正是我们在上面说的\",{\"1\":{\"1242\":1}}],[\"的原理可以看这篇文章\",{\"1\":{\"60\":1}}],[\"的互斥性时可以按照\",{\"1\":{\"1237\":1}}],[\"的逻辑判断\",{\"1\":{\"1233\":1}}],[\"的逻辑空间\",{\"1\":{\"1100\":1}}],[\"的几个方法\",{\"1\":{\"1248\":1}}],[\"的几个\",{\"0\":{\"1282\":1},\"1\":{\"1232\":1,\"1494\":1}}],[\"的几种常用路由规则\",{\"1\":{\"542\":1}}],[\"的系统中\",{\"1\":{\"1224\":1}}],[\"的背景下\",{\"1\":{\"1218\":1}}],[\"的背包\",{\"1\":{\"299\":1,\"772\":1}}],[\"的计算能力\",{\"1\":{\"1218\":1}}],[\"的计算方式如下\",{\"1\":{\"110\":1}}],[\"的计划\",{\"1\":{\"1218\":1}}],[\"的发展为并发编程提供的硬件基础\",{\"1\":{\"1218\":1}}],[\"的依赖\",{\"0\":{\"1203\":1}}],[\"的其他节点\",{\"1\":{\"1192\":1}}],[\"的连通性是良好的\",{\"1\":{\"1191\":1}}],[\"的连接地址\",{\"1\":{\"675\":1}}],[\"的自我保护模式\",{\"1\":{\"1191\":1}}],[\"的存在\",{\"1\":{\"1186\":1}}],[\"的存储机制使用纠删码\",{\"1\":{\"1095\":1}}],[\"的后台线程\",{\"1\":{\"1185\":1}}],[\"的当前实例信息\",{\"1\":{\"1184\":1}}],[\"的线程统统退出\",{\"1\":{\"1404\":1}}],[\"的线程执行完之后\",{\"1\":{\"1392\":1}}],[\"的线程都会与一个许可关联\",{\"1\":{\"1258\":1}}],[\"的线程进入到等待队列\",{\"1\":{\"1251\":1}}],[\"的线程\",{\"1\":{\"1184\":1,\"1330\":1}}],[\"的构造方法可以传入\",{\"1\":{\"1394\":1}}],[\"的构造方法传入的\",{\"1\":{\"1393\":1}}],[\"的构造方法看起\",{\"1\":{\"1392\":1}}],[\"的构造方法也就是传入一个基本类型数据即可\",{\"1\":{\"1385\":1}}],[\"的构造方法为\",{\"1\":{\"1359\":1}}],[\"的构造方法中\",{\"1\":{\"1305\":1}}],[\"的构造方法无参时是构造非公平锁\",{\"1\":{\"1233\":1}}],[\"的构造和注册过程\",{\"1\":{\"1175\":1}}],[\"的构建要求非常严格\",{\"1\":{\"546\":1}}],[\"的构建\",{\"1\":{\"58\":1}}],[\"的话才会执行\",{\"1\":{\"1506\":1}}],[\"的话会调用该方法去清理掉脏\",{\"1\":{\"1316\":1}}],[\"的话会令\",{\"1\":{\"1306\":1}}],[\"的话使用\",{\"1\":{\"1307\":1}}],[\"的话就\",{\"1\":{\"1496\":1}}],[\"的话就会令\",{\"1\":{\"1315\":1}}],[\"的话就直接返回\",{\"1\":{\"1307\":1}}],[\"的话就直接抛出空指针异常\",{\"1\":{\"1283\":1}}],[\"的话就可以直接将值插入即可\",{\"1\":{\"1272\":1}}],[\"的话说明当前节点\",{\"1\":{\"1272\":1}}],[\"的话表示\",{\"1\":{\"1266\":1}}],[\"的话\",{\"1\":{\"1164\":1,\"1231\":1,\"1251\":1,\"1272\":2,\"1283\":3,\"1284\":2,\"1301\":1,\"1302\":1,\"1306\":1,\"1313\":1,\"1315\":1,\"1317\":1,\"1359\":1,\"1393\":1,\"1408\":1}}],[\"的代码\",{\"1\":{\"1182\":1}}],[\"的代码如下所示\",{\"1\":{\"1154\":1}}],[\"的代理服务是否可用\",{\"1\":{\"662\":1}}],[\"的扩展升级版\",{\"1\":{\"1140\":1}}],[\"的创建和管理\",{\"1\":{\"1137\":1}}],[\"的描述进行\",{\"1\":{\"1137\":1}}],[\"的框架中堆积木而已\",{\"1\":{\"1132\":1}}],[\"的核心也包括了这些方面\",{\"1\":{\"1500\":1}}],[\"的核心线程池的线程个数为指定的\",{\"1\":{\"1366\":1}}],[\"的核心\",{\"1\":{\"1131\":1}}],[\"的签名url\",{\"1\":{\"1103\":1}}],[\"的状态变化的过程\",{\"1\":{\"1375\":1}}],[\"的状态如下图所示\",{\"1\":{\"1283\":1}}],[\"的状态\",{\"1\":{\"1103\":1,\"1334\":1}}],[\"的状态只与\",{\"1\":{\"894\":1}}],[\"的常用\",{\"0\":{\"1101\":1}}],[\"的产品\",{\"1\":{\"1095\":1}}],[\"的替代品\",{\"1\":{\"1095\":1}}],[\"的特性\",{\"1\":{\"1075\":1,\"1326\":1}}],[\"的简短描述\",{\"1\":{\"1046\":1}}],[\"的函数不要求非得有\",{\"1\":{\"1020\":1}}],[\"的函数中\",{\"1\":{\"1020\":1}}],[\"的ascii值为32\",{\"1\":{\"1012\":1}}],[\"的矩阵中\",{\"1\":{\"994\":1}}],[\"的运算\",{\"1\":{\"980\":1}}],[\"的运行进程\",{\"1\":{\"672\":1}}],[\"的高度\",{\"1\":{\"958\":1}}],[\"的高度只存在于平衡二叉树\",{\"1\":{\"274\":1}}],[\"的效率\",{\"1\":{\"957\":1}}],[\"的事务是自动提交\",{\"1\":{\"954\":1}}],[\"的任何一个\",{\"1\":{\"947\":1}}],[\"的行\",{\"1\":{\"932\":1}}],[\"的员工\",{\"1\":{\"926\":1}}],[\"的范围内\",{\"1\":{\"899\":1}}],[\"的随机指向节点为\",{\"1\":{\"888\":1}}],[\"的随机指向节点\",{\"1\":{\"888\":1}}],[\"的拼接链表\",{\"1\":{\"888\":1}}],[\"的路径元素和为\",{\"1\":{\"881\":1}}],[\"的路径数目\",{\"1\":{\"881\":1}}],[\"的路径数\",{\"1\":{\"142\":1}}],[\"的有向边\",{\"1\":{\"875\":1}}],[\"的烂橘子\",{\"1\":{\"869\":1}}],[\"的新的节点\",{\"1\":{\"1284\":1}}],[\"的新鲜橘子都会腐烂\",{\"1\":{\"868\":1}}],[\"的新位置为原位置减去被删除的数的数量\",{\"1\":{\"99\":1}}],[\"的滑动窗口从数组的最左侧移动到数组的最右侧\",{\"1\":{\"856\":1}}],[\"的下标\",{\"1\":{\"852\":1}}],[\"的下一个节点\",{\"1\":{\"789\":2,\"1284\":2}}],[\"的下一个更大的元素\",{\"1\":{\"174\":1}}],[\"的上升子序列\",{\"1\":{\"852\":1}}],[\"的倒数第二个元素\",{\"1\":{\"851\":1}}],[\"的倒序遍历\",{\"1\":{\"197\":1}}],[\"的末尾元素的最小值\",{\"1\":{\"852\":1}}],[\"的末尾元素\",{\"1\":{\"851\":1}}],[\"的含义是\",{\"1\":{\"839\":1}}],[\"的左子树与\",{\"1\":{\"808\":1}}],[\"的左子树是否对称\",{\"1\":{\"808\":1}}],[\"的左儿子为\",{\"1\":{\"417\":1}}],[\"的右子树是否对称\",{\"1\":{\"808\":1}}],[\"的右子树与\",{\"1\":{\"808\":1}}],[\"的右儿子为\",{\"1\":{\"417\":1}}],[\"的列表存储当前节点对应出现过的字符的子节点\",{\"1\":{\"802\":1}}],[\"的递推式简化为\",{\"1\":{\"797\":1}}],[\"的每个字符\",{\"1\":{\"783\":1}}],[\"的每一个集合状态\",{\"1\":{\"392\":1}}],[\"的定义中的一条\",{\"1\":{\"1432\":1}}],[\"的定义\",{\"1\":{\"1129\":1}}],[\"的定义和\",{\"1\":{\"796\":1}}],[\"的定义来看\",{\"1\":{\"772\":1}}],[\"的定义是一样的\",{\"1\":{\"796\":1}}],[\"的定义是\",{\"1\":{\"21\":1}}],[\"的子类所重写的方法\",{\"1\":{\"1496\":1}}],[\"的子类的方法时就会调用被重写的方法\",{\"1\":{\"1495\":1}}],[\"的子类进行重写实现\",{\"1\":{\"1495\":1}}],[\"的子类可重写该方法\",{\"1\":{\"1302\":1}}],[\"的子类\",{\"1\":{\"1182\":1}}],[\"的子节点列表中\",{\"1\":{\"802\":2}}],[\"的子集\",{\"1\":{\"772\":1}}],[\"的子集总和\",{\"1\":{\"772\":1}}],[\"的子序列的字符串长度最长是多少\",{\"1\":{\"303\":1}}],[\"的子序列又是\",{\"1\":{\"303\":1}}],[\"的子序列连接起来\",{\"1\":{\"66\":1}}],[\"的子序列\",{\"1\":{\"66\":1,\"838\":2,\"850\":1}}],[\"的深度尽可能大\",{\"1\":{\"753\":1}}],[\"的祖先且\",{\"1\":{\"753\":1}}],[\"的链表\",{\"1\":{\"698\":1,\"886\":1}}],[\"的大概原因是这个\",{\"1\":{\"1286\":1}}],[\"的大小总是\",{\"1\":{\"1272\":1}}],[\"的大小为\",{\"1\":{\"1270\":1}}],[\"的大小一定是\",{\"1\":{\"1270\":1}}],[\"的大小\",{\"1\":{\"1270\":1}}],[\"的大小应该就代表了\",{\"1\":{\"1270\":1}}],[\"的大小不超过给定的容量\",{\"1\":{\"688\":1}}],[\"的大规模多模态数据处理框架\",{\"1\":{\"617\":1}}],[\"的平均时间复杂度运行\",{\"1\":{\"686\":1}}],[\"的机器上\",{\"1\":{\"670\":1}}],[\"的机器访问\",{\"1\":{\"664\":1}}],[\"的访问\",{\"1\":{\"664\":1,\"1431\":1}}],[\"的访问频次\",{\"1\":{\"61\":1}}],[\"的安全组\",{\"1\":{\"664\":1}}],[\"的扫描不会发觉任何异常\",{\"1\":{\"664\":1}}],[\"的地方很相似\",{\"1\":{\"1157\":1}}],[\"的地址和端口换成\",{\"1\":{\"664\":1}}],[\"的地块\",{\"1\":{\"128\":1}}],[\"的设计是使用模板方法设计模式\",{\"1\":{\"1495\":1}}],[\"的设计\",{\"0\":{\"1286\":1,\"1423\":1},\"1\":{\"1429\":1}}],[\"的设计方案\",{\"1\":{\"1272\":1}}],[\"的设计思想\",{\"0\":{\"1291\":1},\"1\":{\"56\":1}}],[\"的设置界面\",{\"1\":{\"664\":1}}],[\"的四种方式\",{\"1\":{\"646\":1}}],[\"的流批一体的探索和实践\",{\"1\":{\"621\":1}}],[\"的架构和原理\",{\"1\":{\"618\":1}}],[\"的空间\",{\"1\":{\"613\":1}}],[\"的布隆过滤器模块\",{\"1\":{\"613\":1}}],[\"的布局组件\",{\"1\":{\"548\":1}}],[\"的异常类\",{\"1\":{\"599\":1}}],[\"的插件\",{\"1\":{\"585\":1}}],[\"的主要方法\",{\"1\":{\"1393\":1,\"1398\":1}}],[\"的主要属性有\",{\"1\":{\"1350\":1}}],[\"的主要属性如下\",{\"1\":{\"1346\":1}}],[\"的主要属性\",{\"0\":{\"1346\":1,\"1350\":1}}],[\"的主要工作\",{\"1\":{\"576\":1}}],[\"的主要功能就是从某个节点向上遍历到根节点\",{\"1\":{\"274\":1}}],[\"的包装类型\",{\"1\":{\"1074\":1}}],[\"的包\",{\"1\":{\"560\":1}}],[\"的文件夹下\",{\"1\":{\"559\":1}}],[\"的增强版\",{\"1\":{\"1205\":1}}],[\"的增强\",{\"1\":{\"557\":1}}],[\"的封装\",{\"1\":{\"557\":1}}],[\"的类继承体系结构\",{\"1\":{\"1134\":1}}],[\"的类型和编辑器的错误提示\",{\"1\":{\"546\":1}}],[\"的类或方法上加入\",{\"1\":{\"468\":1}}],[\"的约定式路由\",{\"1\":{\"544\":1}}],[\"的约数\",{\"1\":{\"371\":1}}],[\"的根目录下\",{\"1\":{\"543\":2}}],[\"的配置信息\",{\"1\":{\"1160\":1}}],[\"的配置文件的内容\",{\"1\":{\"1139\":1}}],[\"的配置文件\",{\"1\":{\"672\":1}}],[\"的配置\",{\"1\":{\"539\":1,\"665\":1}}],[\"的配置类是实现安全控制的核心部分\",{\"1\":{\"446\":1}}],[\"的官方文档中查看\",{\"1\":{\"539\":1}}],[\"的官方文档\",{\"1\":{\"539\":1,\"542\":1}}],[\"的优点包括\",{\"1\":{\"532\":1,\"533\":1}}],[\"的优先级\",{\"1\":{\"215\":1}}],[\"的响应\",{\"1\":{\"532\":1}}],[\"的过程结束\",{\"1\":{\"1317\":1}}],[\"的过程中通过\",{\"1\":{\"1306\":1}}],[\"的过程中\",{\"1\":{\"1276\":1}}],[\"的过程中维护小红的血量状态\",{\"1\":{\"180\":1}}],[\"的过程\",{\"1\":{\"796\":1,\"1283\":1,\"1317\":4,\"1506\":1}}],[\"的过程如下\",{\"1\":{\"532\":1}}],[\"的唯一性约束\",{\"1\":{\"526\":1}}],[\"的唯一质因子\",{\"1\":{\"368\":1}}],[\"的服务层接口\",{\"1\":{\"523\":1}}],[\"的面试刷题平台\",{\"1\":{\"493\":1}}],[\"的启动配置\",{\"1\":{\"488\":1}}],[\"的启动类的名称\",{\"1\":{\"488\":1}}],[\"的提供的权限注解\",{\"1\":{\"465\":1}}],[\"的感觉\",{\"1\":{\"437\":1,\"1482\":1}}],[\"的减法\",{\"1\":{\"423\":1}}],[\"的哈希值\",{\"1\":{\"421\":1}}],[\"的经验值是\",{\"1\":{\"421\":1}}],[\"的偏移量\",{\"1\":{\"416\":1}}],[\"的sg函数值构成的集合再执行mex\",{\"1\":{\"398\":1}}],[\"的集合中\",{\"1\":{\"789\":1}}],[\"的集合\",{\"1\":{\"392\":1}}],[\"的乘法逆元为\",{\"1\":{\"388\":1}}],[\"的乘法逆元\",{\"1\":{\"388\":1}}],[\"的模板方法可以很方便的给同步组件的实现者进行调用\",{\"1\":{\"1496\":1}}],[\"的模板方法设计模式\",{\"0\":{\"1495\":1}}],[\"的模板方法\",{\"1\":{\"1251\":1,\"1496\":1}}],[\"的模\",{\"1\":{\"388\":1}}],[\"的逆元不存在\",{\"1\":{\"388\":1}}],[\"的逆元\",{\"1\":{\"388\":1}}],[\"的解释在源码上也写的很清楚了\",{\"1\":{\"1272\":1}}],[\"的解析和执行可能存在差异\",{\"1\":{\"532\":1}}],[\"的解\",{\"1\":{\"383\":1}}],[\"的欧拉函数即为\",{\"1\":{\"380\":1}}],[\"的质因子\",{\"1\":{\"373\":1,\"380\":1}}],[\"的表中划去\",{\"1\":{\"372\":1}}],[\"的表中筛得素数的同时\",{\"1\":{\"372\":1}}],[\"的表格中\",{\"1\":{\"142\":1}}],[\"的素数表\",{\"1\":{\"372\":1}}],[\"的因子\",{\"1\":{\"368\":3}}],[\"的点\",{\"1\":{\"349\":1}}],[\"的点作为第一个点\",{\"1\":{\"166\":1}}],[\"的个数\",{\"1\":{\"339\":2,\"1194\":1,\"1316\":1}}],[\"的个位数\",{\"1\":{\"139\":1}}],[\"的个位数确定周期\",{\"1\":{\"139\":1}}],[\"的指定位\",{\"1\":{\"338\":1}}],[\"的指令\",{\"1\":{\"60\":1}}],[\"的低\",{\"1\":{\"338\":6,\"1272\":1}}],[\"的商和余数\",{\"1\":{\"330\":1}}],[\"的所有数据\",{\"1\":{\"945\":2}}],[\"的所有组合情况\",{\"1\":{\"942\":1}}],[\"的所有因数\",{\"1\":{\"368\":1}}],[\"的所有出边\",{\"1\":{\"355\":1}}],[\"的所有路径\",{\"1\":{\"312\":1}}],[\"的所有方案\",{\"1\":{\"311\":1}}],[\"的所有可能的和\",{\"1\":{\"135\":1}}],[\"的所有可能的前一个位置\",{\"1\":{\"110\":1}}],[\"的树里各个数字有多少个\",{\"1\":{\"309\":1}}],[\"的各位数字有多少个\",{\"1\":{\"309\":2}}],[\"的出现次数\",{\"1\":{\"309\":1}}],[\"的一些重要方法\",{\"1\":{\"1392\":1}}],[\"的一些操作的原子性\",{\"1\":{\"1276\":1}}],[\"的一些属性\",{\"1\":{\"1266\":1}}],[\"的一些变量\",{\"1\":{\"1177\":1}}],[\"的一个成员变量\",{\"1\":{\"1301\":2}}],[\"的一个内部类无可厚非\",{\"1\":{\"1250\":1}}],[\"的一个内部类\",{\"1\":{\"1250\":1}}],[\"的一个重点是在系统运行中\",{\"1\":{\"1132\":1}}],[\"的一个简单解释\",{\"1\":{\"646\":1}}],[\"的一维数组\",{\"1\":{\"797\":1}}],[\"的一种划分\",{\"1\":{\"308\":1}}],[\"的一棵子树包括\",{\"1\":{\"186\":1}}],[\"的某个位置插入某个字符\",{\"1\":{\"306\":1}}],[\"的某个节点和这个节点的所有后代节点\",{\"1\":{\"186\":1}}],[\"的形式如下\",{\"1\":{\"1492\":1}}],[\"的形式存储\",{\"1\":{\"353\":1}}],[\"的形式\",{\"1\":{\"291\":1}}],[\"的不可更改性\",{\"1\":{\"1472\":1}}],[\"的不同值来代表不同含义\",{\"1\":{\"1276\":1}}],[\"的不同\",{\"1\":{\"1140\":1}}],[\"的不同方法数\",{\"1\":{\"72\":1}}],[\"的不平衡状况\",{\"1\":{\"271\":1}}],[\"的组合有多少种\",{\"1\":{\"261\":1}}],[\"的组合方式只有一种\",{\"1\":{\"135\":1}}],[\"的组合方式的数量\",{\"1\":{\"135\":1}}],[\"的差值必然是\",{\"1\":{\"261\":1}}],[\"的余数相等\",{\"1\":{\"261\":1}}],[\"的和\",{\"1\":{\"261\":1}}],[\"的和是k的倍数\",{\"1\":{\"261\":1}}],[\"的和是\",{\"1\":{\"261\":1}}],[\"的目的是可以在\",{\"1\":{\"255\":1}}],[\"的正方形\",{\"1\":{\"263\":1}}],[\"的正余数\",{\"0\":{\"247\":1}}],[\"的正整数倍\",{\"1\":{\"76\":1}}],[\"的成员函数c\",{\"1\":{\"243\":1}}],[\"的真实长度\",{\"1\":{\"243\":1}}],[\"的二叉树\",{\"1\":{\"766\":1}}],[\"的二维整数数组\",{\"1\":{\"278\":1}}],[\"的二维字符数组作为迷宫\",{\"1\":{\"235\":1}}],[\"的二进制表示\",{\"1\":{\"339\":1}}],[\"的二进制表示中第\",{\"1\":{\"339\":1,\"381\":1}}],[\"的二进制表示下的每一位是不是\",{\"1\":{\"253\":1}}],[\"的二进制位右移\",{\"1\":{\"338\":1}}],[\"的二进制位\",{\"1\":{\"338\":1}}],[\"的二进制字符串\",{\"1\":{\"120\":1}}],[\"的坐标\",{\"1\":{\"224\":1}}],[\"的网格中\",{\"1\":{\"224\":2,\"279\":2}}],[\"的网格板\",{\"1\":{\"77\":1}}],[\"的第三个参数传入一个元素\",{\"1\":{\"423\":1}}],[\"的第一个元素\",{\"1\":{\"322\":1}}],[\"的第\",{\"1\":{\"223\":1}}],[\"的节点后\",{\"1\":{\"1284\":1}}],[\"的节点的话\",{\"1\":{\"1272\":1}}],[\"的节点作为下一个待遍历的节点\",{\"1\":{\"215\":1}}],[\"的节点作为下一个遍历的节点\",{\"1\":{\"214\":1}}],[\"的节点\",{\"1\":{\"215\":1,\"1281\":1,\"1284\":2}}],[\"的综合优先级\",{\"1\":{\"215\":1}}],[\"的棋盘可以摆放不同的\",{\"1\":{\"311\":1}}],[\"的棋盘\",{\"1\":{\"196\":1}}],[\"的情况为\",{\"1\":{\"1285\":1}}],[\"的情况\",{\"1\":{\"182\":1,\"613\":1,\"1264\":1,\"1272\":1,\"1284\":1,\"1306\":1,\"1313\":1,\"1408\":1,\"1485\":1}}],[\"的情况下也能正常返回\",{\"1\":{\"777\":1}}],[\"的情况下\",{\"1\":{\"173\":1,\"772\":1}}],[\"的迷宫\",{\"1\":{\"180\":1}}],[\"的元素变成了\",{\"1\":{\"1386\":1}}],[\"的元素加\",{\"1\":{\"1386\":1}}],[\"的元素自增加\",{\"1\":{\"1386\":1}}],[\"的元素与输入值相加\",{\"1\":{\"1386\":1}}],[\"的元素个数\",{\"1\":{\"958\":1,\"1275\":1}}],[\"的元素的位置的迭代器\",{\"1\":{\"423\":1}}],[\"的元素到\",{\"1\":{\"254\":1}}],[\"的元素赋值到当前的\",{\"1\":{\"254\":1}}],[\"的元素\",{\"1\":{\"179\":1,\"423\":1,\"682\":1,\"852\":1,\"1078\":1,\"1268\":2}}],[\"的元素会被移除\",{\"1\":{\"178\":1}}],[\"的元素会被全部移除\",{\"1\":{\"178\":1}}],[\"的元组\",{\"1\":{\"140\":1}}],[\"的仅包含正整数的数组\",{\"1\":{\"178\":1}}],[\"的区别之一\",{\"1\":{\"1393\":1}}],[\"的区别\",{\"0\":{\"1042\":1},\"1\":{\"1326\":1}}],[\"的区别是\",{\"1\":{\"510\":1}}],[\"的区间的最大值已经是整个数组的最大值\",{\"1\":{\"174\":1}}],[\"的区域造成范围伤害\",{\"1\":{\"97\":1}}],[\"的距离\",{\"1\":{\"166\":1,\"416\":1}}],[\"的距离之和\",{\"1\":{\"166\":1}}],[\"的位置的元素进行更新\",{\"1\":{\"1386\":1}}],[\"的位置的\",{\"1\":{\"1316\":2}}],[\"的位置变成了\",{\"1\":{\"1316\":1}}],[\"的位置上\",{\"1\":{\"1274\":2}}],[\"的位置会直接返回\",{\"1\":{\"820\":1}}],[\"的位置\",{\"1\":{\"802\":1,\"822\":1,\"1315\":1,\"1316\":1}}],[\"的位置恰好是倒数第\",{\"1\":{\"777\":1}}],[\"的位置加上\",{\"1\":{\"526\":1}}],[\"的位置染成\",{\"1\":{\"157\":1}}],[\"的位置是\",{\"1\":{\"99\":1}}],[\"的绝对值\",{\"1\":{\"147\":1}}],[\"的体力\",{\"1\":{\"142\":1}}],[\"的值然后将该变量拷贝到自己的本地内存\",{\"1\":{\"1433\":1}}],[\"的值为\",{\"1\":{\"338\":1,\"1284\":2,\"1432\":1}}],[\"的值比节点\",{\"1\":{\"216\":1}}],[\"的值越小\",{\"1\":{\"216\":1}}],[\"的值剪接到要操作的\",{\"1\":{\"200\":1}}],[\"的值\",{\"1\":{\"135\":1,\"329\":1,\"389\":1,\"390\":1,\"766\":1,\"920\":2,\"1010\":1,\"1275\":1,\"1284\":1,\"1433\":1,\"1482\":2}}],[\"的值表示使用前\",{\"1\":{\"126\":1}}],[\"的无序单链表\",{\"1\":{\"134\":1}}],[\"的复杂度\",{\"1\":{\"129\":1}}],[\"的排名\",{\"1\":{\"129\":1}}],[\"的排列\",{\"1\":{\"119\":1}}],[\"的积分更新为\",{\"1\":{\"129\":1}}],[\"的积分插入到排行榜中\",{\"1\":{\"129\":1}}],[\"的最小整数的下标\",{\"1\":{\"423\":1}}],[\"的最小质因子也就是\",{\"1\":{\"373\":1}}],[\"的最小质因子就是\",{\"1\":{\"373\":1}}],[\"的最小质因子\",{\"1\":{\"373\":2,\"380\":3}}],[\"的最后一位\",{\"1\":{\"339\":1}}],[\"的最后一个元素\",{\"1\":{\"322\":1}}],[\"的最低位为\",{\"1\":{\"338\":1}}],[\"的最短hamilton路径\",{\"1\":{\"312\":1}}],[\"的最大上升子序列\",{\"1\":{\"852\":1}}],[\"的最大整数\",{\"1\":{\"423\":1}}],[\"的最大值是多少\",{\"1\":{\"167\":1}}],[\"的最大值\",{\"1\":{\"156\":2,\"411\":1}}],[\"的最大连续区间\",{\"1\":{\"140\":1}}],[\"的最差时间复杂度\",{\"1\":{\"129\":2}}],[\"的最长上升子序列长度为\",{\"1\":{\"119\":1}}],[\"的长度要\",{\"1\":{\"828\":1}}],[\"的长度均不超过\",{\"1\":{\"304\":1}}],[\"的长度时会被截断\",{\"1\":{\"243\":1}}],[\"的长度并消耗\",{\"1\":{\"142\":1}}],[\"的长度\",{\"1\":{\"127\":1,\"243\":1,\"304\":1,\"844\":1,\"845\":1,\"852\":2}}],[\"的前提条件都不具备\",{\"1\":{\"1316\":1}}],[\"的前提条件是\",{\"1\":{\"1316\":1}}],[\"的前提条件是当前线程已经获取了\",{\"1\":{\"1252\":1}}],[\"的前提下\",{\"1\":{\"411\":1}}],[\"的前缀之一为\",{\"1\":{\"801\":1}}],[\"的前\",{\"1\":{\"127\":2,\"783\":2}}],[\"的是\",{\"1\":{\"121\":1}}],[\"的权值定义如下\",{\"1\":{\"120\":1}}],[\"的完全平方数来更新\",{\"1\":{\"115\":1}}],[\"的完全平方数的最少数量\",{\"1\":{\"115\":2,\"794\":1}}],[\"的格子为终点\",{\"1\":{\"110\":1}}],[\"的格子为起始点\",{\"1\":{\"110\":1}}],[\"的索引位置为\",{\"1\":{\"1316\":1}}],[\"的索引\",{\"1\":{\"108\":1,\"766\":1,\"1317\":2}}],[\"的符号翻转\",{\"1\":{\"104\":1}}],[\"的宝石旁边\",{\"1\":{\"103\":1}}],[\"的宝石取下\",{\"1\":{\"103\":1}}],[\"的倍数时\",{\"1\":{\"388\":1}}],[\"的倍数的个数\",{\"1\":{\"261\":1}}],[\"的倍数\",{\"1\":{\"99\":1,\"248\":1,\"261\":3,\"383\":1,\"388\":1}}],[\"的倍数上的数字\",{\"1\":{\"99\":1}}],[\"的时候方法结束说明获得成功获取锁\",{\"1\":{\"1510\":1}}],[\"的时候才会结束\",{\"1\":{\"1337\":1}}],[\"的时候就可以将\",{\"1\":{\"1319\":1}}],[\"的时候就会被回收掉\",{\"1\":{\"1316\":1}}],[\"的时候就会找到数据大概是\",{\"1\":{\"958\":1}}],[\"的时候进行可达性分析\",{\"1\":{\"1318\":1}}],[\"的时候遇到\",{\"1\":{\"1317\":1}}],[\"的时候遇到脏\",{\"1\":{\"1317\":1}}],[\"的时候此处\",{\"1\":{\"1316\":1}}],[\"的时候退出\",{\"1\":{\"1316\":1}}],[\"的时候势必会被回收\",{\"1\":{\"1313\":1}}],[\"的时候存在\",{\"1\":{\"1307\":1}}],[\"的时候会通过\",{\"1\":{\"1301\":1}}],[\"的时候会将链表转换成红黑树\",{\"1\":{\"1272\":1}}],[\"的时候如果有写线程在写数据\",{\"1\":{\"1290\":1}}],[\"的时候返回为\",{\"1\":{\"1284\":1}}],[\"的时候转变成了哨兵节点\",{\"1\":{\"1284\":1}}],[\"的时候的情况\",{\"1\":{\"1283\":1}}],[\"的时候采用红黑树的设计\",{\"1\":{\"1276\":1}}],[\"的时候摒弃了\",{\"1\":{\"1276\":1}}],[\"的时候需要锁住\",{\"1\":{\"1276\":1}}],[\"的时候我们都是在自己对象中主动去创建被依赖的对象\",{\"1\":{\"1129\":1}}],[\"的时候\",{\"1\":{\"99\":1,\"243\":1,\"772\":1,\"1129\":1,\"1272\":1,\"1286\":4,\"1305\":1,\"1306\":1,\"1317\":9,\"1392\":3,\"1406\":1}}],[\"的时间复杂度\",{\"1\":{\"58\":1}}],[\"的程序员\",{\"1\":{\"98\":1}}],[\"的魔法水晶箭\",{\"1\":{\"97\":1}}],[\"的起始位置\",{\"1\":{\"92\":1}}],[\"的字符结尾的最长有效括号的长度\",{\"1\":{\"846\":1}}],[\"的字符串以及\",{\"1\":{\"305\":1}}],[\"的字符串\",{\"1\":{\"88\":2,\"93\":1,\"180\":1,\"303\":1,\"844\":1}}],[\"的字段\",{\"1\":{\"31\":1}}],[\"的命令\",{\"1\":{\"77\":1}}],[\"的单元格向下寻找最先出现的白色单元格\",{\"1\":{\"77\":1}}],[\"的单元格向上寻找最先出现的白色单元格\",{\"1\":{\"77\":1}}],[\"的单元格向右寻找最先出现的白色单元格\",{\"1\":{\"77\":1}}],[\"的单元格向左寻找最先出现的白色单元格\",{\"1\":{\"77\":1}}],[\"的单元格涂成黑色lxy\",{\"1\":{\"77\":1}}],[\"的单元格组成\",{\"1\":{\"77\":1}}],[\"的方案\",{\"1\":{\"1299\":1}}],[\"的方案数为\",{\"1\":{\"126\":1}}],[\"的方案数\",{\"1\":{\"126\":2,\"308\":1}}],[\"的方法实现自己想要表达的同步语义\",{\"1\":{\"1496\":1}}],[\"的方法不是很多\",{\"1\":{\"1392\":1}}],[\"的方法中会多一个指定数组索引位\",{\"1\":{\"1386\":1}}],[\"的方法基本一致\",{\"1\":{\"1386\":1}}],[\"的方法将线程设置为守护线程\",{\"1\":{\"1340\":1}}],[\"的方法前我们需要了解下面几个常用的利用\",{\"1\":{\"1268\":1}}],[\"的方法去修改\",{\"1\":{\"1266\":1}}],[\"的方法\",{\"1\":{\"1150\":1,\"1334\":1,\"1508\":1}}],[\"的方法是同步的\",{\"1\":{\"1075\":1}}],[\"的方法数等于从\",{\"1\":{\"72\":1}}],[\"的方式入队\",{\"1\":{\"1504\":1}}],[\"的方式时\",{\"1\":{\"1495\":1}}],[\"的方式被推荐定义继承\",{\"1\":{\"1495\":1}}],[\"的方式来一行一行的看代码\",{\"1\":{\"1283\":1}}],[\"的方式进行加锁以实现线程安全性\",{\"1\":{\"1272\":1}}],[\"的方式进行分发\",{\"1\":{\"49\":1}}],[\"的方式\",{\"1\":{\"1272\":1,\"1495\":1}}],[\"的方式实际上是指在对象\",{\"1\":{\"1250\":1}}],[\"的方式存储的\",{\"1\":{\"698\":1}}],[\"的数字\",{\"1\":{\"1004\":1}}],[\"的数是否是质数\",{\"1\":{\"992\":1}}],[\"的数目\",{\"1\":{\"822\":1,\"880\":1}}],[\"的数整除\",{\"1\":{\"367\":1}}],[\"的数对的个数\",{\"1\":{\"324\":1}}],[\"的数列\",{\"1\":{\"261\":1,\"339\":1}}],[\"的数\",{\"1\":{\"139\":3}}],[\"的数组只针对数组的引用具有\",{\"1\":{\"1295\":1}}],[\"的数组\",{\"1\":{\"87\":1,\"104\":1,\"122\":1,\"146\":1,\"174\":1,\"178\":1,\"179\":1,\"199\":1,\"262\":1,\"1266\":1}}],[\"的数量\",{\"1\":{\"71\":1,\"121\":1}}],[\"的数量加上右子字符串中\",{\"1\":{\"71\":1}}],[\"的数据结构\",{\"1\":{\"1369\":1}}],[\"的数据域为\",{\"1\":{\"1284\":1}}],[\"的数据域\",{\"1\":{\"1284\":1}}],[\"的数据域设置为\",{\"1\":{\"1284\":1}}],[\"的数据域不为\",{\"1\":{\"1284\":1}}],[\"的数据容器\",{\"1\":{\"1266\":1,\"1270\":1}}],[\"的数据列是一个正数序列开始增长\",{\"1\":{\"919\":1}}],[\"的数据\",{\"1\":{\"61\":2,\"438\":1}}],[\"的升级\",{\"1\":{\"61\":1}}],[\"的查询压力\",{\"1\":{\"60\":1}}],[\"的消息通知原理来实现生产者\",{\"1\":{\"1410\":1}}],[\"的消息通知机制\",{\"0\":{\"1403\":1},\"1\":{\"1402\":2}}],[\"的消息\",{\"1\":{\"60\":1}}],[\"的消费者中处理\",{\"1\":{\"58\":1}}],[\"的消费者\",{\"1\":{\"28\":1}}],[\"的问题\",{\"0\":{\"1439\":1},\"1\":{\"60\":1,\"323\":1,\"613\":1,\"1306\":2,\"1384\":1}}],[\"的压力更小\",{\"1\":{\"60\":1}}],[\"的压力\",{\"1\":{\"60\":1}}],[\"的操作过程\",{\"0\":{\"1437\":1}}],[\"的操作归根结底是由该类提供就好\",{\"1\":{\"1282\":1}}],[\"的操作方式\",{\"1\":{\"306\":1}}],[\"的操作\",{\"1\":{\"60\":1,\"274\":1,\"1082\":1,\"1100\":1}}],[\"的实现依赖于同步器\",{\"1\":{\"1495\":1}}],[\"的实现需要硬件指令集的支撑\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"的实现是不是也会采用\",{\"1\":{\"1345\":1}}],[\"的实现原理和\",{\"1\":{\"1385\":1}}],[\"的实现原理\",{\"0\":{\"1292\":1,\"1300\":1,\"1477\":1},\"1\":{\"1300\":1,\"1326\":1,\"1344\":1,\"1385\":1}}],[\"的实现原理又依赖于\",{\"1\":{\"1250\":1}}],[\"的实现对比\",{\"1\":{\"1276\":1}}],[\"的实现中可以看到大量的\",{\"1\":{\"1266\":1}}],[\"的实现类有\",{\"1\":{\"1075\":1}}],[\"的实现\",{\"1\":{\"58\":1,\"1472\":1}}],[\"的评论内容\",{\"1\":{\"56\":1}}],[\"的好处是\",{\"1\":{\"50\":1}}],[\"的吞吐模型理解为\",{\"1\":{\"49\":1}}],[\"的瓶颈\",{\"1\":{\"40\":1}}],[\"的分析同理可得这两条语句不具备原子性\",{\"1\":{\"1482\":1}}],[\"的分布可能出现同一个值堆叠多个元素\",{\"1\":{\"40\":1}}],[\"的分页排序\",{\"1\":{\"40\":1}}],[\"的理解\",{\"1\":{\"39\":1,\"1493\":1}}],[\"的\",{\"0\":{\"1130\":1,\"1247\":1,\"1410\":1,\"1432\":1,\"1455\":1},\"1\":{\"31\":2,\"40\":1,\"46\":1,\"49\":1,\"56\":1,\"60\":2,\"61\":1,\"65\":1,\"72\":1,\"120\":1,\"121\":1,\"129\":2,\"139\":2,\"215\":1,\"243\":2,\"269\":1,\"291\":1,\"434\":1,\"510\":1,\"525\":2,\"526\":1,\"535\":1,\"543\":1,\"559\":1,\"575\":1,\"613\":2,\"664\":3,\"672\":1,\"771\":1,\"840\":2,\"845\":2,\"852\":3,\"880\":1,\"887\":1,\"906\":1,\"1082\":1,\"1151\":1,\"1158\":2,\"1164\":2,\"1165\":1,\"1184\":1,\"1240\":1,\"1242\":1,\"1248\":5,\"1251\":2,\"1252\":4,\"1259\":1,\"1264\":3,\"1268\":1,\"1270\":1,\"1272\":5,\"1274\":2,\"1275\":1,\"1282\":1,\"1283\":4,\"1284\":4,\"1285\":2,\"1294\":1,\"1295\":1,\"1302\":1,\"1304\":2,\"1305\":7,\"1306\":4,\"1307\":1,\"1313\":1,\"1314\":3,\"1315\":1,\"1316\":2,\"1317\":3,\"1318\":1,\"1326\":2,\"1340\":1,\"1345\":1,\"1351\":1,\"1359\":2,\"1370\":1,\"1371\":2,\"1375\":2,\"1392\":2,\"1394\":2,\"1402\":3,\"1410\":2,\"1423\":1,\"1432\":1,\"1433\":1,\"1455\":1,\"1469\":1,\"1472\":1,\"1475\":1,\"1482\":1,\"1495\":2,\"1496\":1,\"1503\":1,\"1507\":1}}],[\"还剩下\",{\"1\":{\"1482\":1}}],[\"还剩下第三个问题\",{\"1\":{\"1251\":1}}],[\"还未读到对象引用就在读取该对象的普通域变量\",{\"1\":{\"1475\":1}}],[\"还会涉及到编译器指令重排序和处理器指令重排序\",{\"1\":{\"1415\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"1357\":1}}],[\"还没开始\",{\"1\":{\"1406\":1}}],[\"还没有执行\",{\"1\":{\"1375\":1}}],[\"还实现了\",{\"1\":{\"1376\":1}}],[\"还依旧指向\",{\"1\":{\"1284\":1}}],[\"还在\",{\"1\":{\"1276\":1}}],[\"还额外支持了超时机制\",{\"1\":{\"1251\":1}}],[\"还提供了另外一个实现\",{\"1\":{\"1237\":1}}],[\"还提供可视化的操作管理界面\",{\"1\":{\"1095\":1}}],[\"还做了一些事情\",{\"1\":{\"1150\":1}}],[\"还能通过负载均衡提升效率\",{\"1\":{\"484\":1}}],[\"还有这样一种情况\",{\"1\":{\"1284\":1}}],[\"还有另外一种获取配置项的方式\",{\"1\":{\"1147\":1}}],[\"还有另一个自然数\",{\"1\":{\"99\":1}}],[\"还有一个比较有意思的就是\",{\"1\":{\"1418\":1}}],[\"还有一个跟部分预渲染相似的概念叫\",{\"1\":{\"535\":1}}],[\"还有一些方法\",{\"1\":{\"1385\":1}}],[\"还有一些由后端自动生成的字段\",{\"1\":{\"517\":1}}],[\"还有一点值得关注的是\",{\"1\":{\"1260\":1}}],[\"还有一点需要注意的是\",{\"1\":{\"1259\":1}}],[\"还有如果在一个高峰时段\",{\"1\":{\"484\":1}}],[\"还支持公平锁和非公平锁两种方式\",{\"1\":{\"1231\":1}}],[\"还支持\",{\"1\":{\"445\":1,\"1095\":1}}],[\"还要在\",{\"1\":{\"589\":1}}],[\"还要把湖\",{\"1\":{\"438\":1}}],[\"还要实现应用之间的互操作\",{\"1\":{\"14\":1}}],[\"还是以上面的代码为例\",{\"1\":{\"1456\":1}}],[\"还是不太完整的\",{\"1\":{\"1433\":1}}],[\"还是有不一样的地方\",{\"1\":{\"1360\":1}}],[\"还是线程\",{\"1\":{\"1284\":1}}],[\"还是指向\",{\"1\":{\"1283\":1}}],[\"还是应该知道它的实现原理\",{\"1\":{\"1250\":1}}],[\"还是在\",{\"1\":{\"1146\":1}}],[\"还是\",{\"1\":{\"323\":1,\"338\":1,\"368\":1,\"1371\":2}}],[\"还可能引发服务中断\",{\"1\":{\"484\":1}}],[\"还可能遇到\",{\"1\":{\"40\":1}}],[\"还可以简化各个线程操作\",{\"1\":{\"1344\":1}}],[\"还可以支持范围查询\",{\"1\":{\"958\":1}}],[\"还可以确保了数据的合理利用和流程的顺畅\",{\"1\":{\"470\":1}}],[\"还可以向湖中回注数据\",{\"1\":{\"438\":1}}],[\"还可以表示为\",{\"1\":{\"291\":1}}],[\"还原\",{\"1\":{\"279\":1}}],[\"还包括\",{\"1\":{\"1495\":1}}],[\"还包括中文的空格字符\",{\"1\":{\"1069\":1}}],[\"还包括楼中楼\",{\"1\":{\"39\":1}}],[\"还包含了许多用于操作的函数\",{\"1\":{\"243\":1}}],[\"还应先完成课程\",{\"1\":{\"875\":1}}],[\"还应该对状态异常的用户进行筛选\",{\"1\":{\"589\":1}}],[\"还应该想办法记录这个岛屿的⾯积\",{\"1\":{\"230\":1}}],[\"还应用了内部稀疏数据的\",{\"1\":{\"40\":1}}],[\"还需要安装\",{\"1\":{\"540\":1}}],[\"还需要补上\",{\"1\":{\"380\":1}}],[\"还需要一个优先队列结构\",{\"1\":{\"213\":1}}],[\"还需要校验对应评论的状态\",{\"1\":{\"36\":1}}],[\"还作为数据库\",{\"1\":{\"28\":1}}],[\"用的位置可以有这些使用场景\",{\"1\":{\"1430\":1}}],[\"用的数字个数+1\",{\"1\":{\"291\":1}}],[\"用完就清理\",{\"1\":{\"1320\":1}}],[\"用下图来理解下\",{\"1\":{\"1305\":1}}],[\"用cas设置成特殊节点forwardingnode\",{\"1\":{\"1274\":1}}],[\"用逆向思维去看就好\",{\"1\":{\"1273\":1}}],[\"用到的是\",{\"1\":{\"1184\":1}}],[\"用到了单例模式\",{\"1\":{\"1164\":1}}],[\"用到了设计模式中的\",{\"1\":{\"1154\":1}}],[\"用到了\",{\"1\":{\"585\":1}}],[\"用构造器模式初始化服务实例\",{\"1\":{\"1155\":1}}],[\"用解释器执行\",{\"1\":{\"1107\":1}}],[\"用作云原生应用程序的主要存储\",{\"1\":{\"1095\":1}}],[\"用作堆栈而不是\",{\"1\":{\"1075\":1}}],[\"用newvalue替换所有等于oldvalue的元素\",{\"1\":{\"1081\":1}}],[\"用指定的字符串连接字符串数组\",{\"1\":{\"1069\":1}}],[\"用当前插入的值替换掉这个key为null的\",{\"1\":{\"1306\":1}}],[\"用当前同步状态直接减去写状态\",{\"1\":{\"1240\":1}}],[\"用当前的调用栈层次填充throwable\",{\"1\":{\"1046\":1}}],[\"用当前行将下面所有的列消成0\",{\"1\":{\"385\":1}}],[\"用非法索引访问数组时抛出的异常\",{\"1\":{\"1045\":1}}],[\"用一条\",{\"1\":{\"985\":1}}],[\"用一个简单的\",{\"1\":{\"1431\":1}}],[\"用一个表格将上面六种状态进行一个总结归纳\",{\"1\":{\"1334\":1}}],[\"用一个很简单的例子说说这些方法怎么用\",{\"1\":{\"1260\":1}}],[\"用一个由\",{\"1\":{\"886\":1}}],[\"用一个小根堆来维护所有组的右端点\",{\"1\":{\"429\":1}}],[\"用一个一维数组存储树\",{\"1\":{\"417\":1}}],[\"用一个布尔变量记录下来\",{\"1\":{\"235\":1}}],[\"用一个二维布尔数组来表示网格\",{\"1\":{\"77\":1}}],[\"用法没懂\",{\"1\":{\"1194\":1}}],[\"用法同\",{\"1\":{\"1075\":1}}],[\"用法\",{\"1\":{\"912\":1}}],[\"用法与\",{\"1\":{\"423\":1}}],[\"用栈模拟一遍\",{\"1\":{\"845\":1}}],[\"用哨兵节点简化代码\",{\"1\":{\"778\":1}}],[\"用慢指针指针\",{\"1\":{\"777\":1}}],[\"用递归的思维\",{\"1\":{\"725\":1}}],[\"用后端\",{\"1\":{\"574\":1}}],[\"用单例工厂\",{\"1\":{\"1149\":1}}],[\"用单调队列来优化\",{\"1\":{\"410\":1}}],[\"用单线程解决分布式无状态服务的共性问题\",{\"1\":{\"28\":1}}],[\"用高精度乘法将所有质因子相乘\",{\"1\":{\"390\":2}}],[\"用高精度乘法把所有质因子乘上\",{\"1\":{\"390\":1}}],[\"用高精度相乘即可\",{\"1\":{\"390\":1}}],[\"用初等行变换\",{\"1\":{\"385\":3}}],[\"用扩展欧几里得算法找出一组解\",{\"1\":{\"384\":1}}],[\"用上面的公式定义求\",{\"1\":{\"379\":1}}],[\"用两个指针\",{\"1\":{\"839\":1}}],[\"用两个指针维护一段区间\",{\"1\":{\"340\":1}}],[\"用两数之积除以他们的最大公约数可得最小公倍数\",{\"1\":{\"377\":1}}],[\"用最小质因子去筛合数\",{\"1\":{\"373\":1}}],[\"用质数把其所有的倍数都筛掉\",{\"1\":{\"371\":1}}],[\"用队列来存储\",{\"1\":{\"355\":1}}],[\"用t更新其他点的距离\",{\"1\":{\"352\":1}}],[\"用途\",{\"0\":{\"338\":1},\"1\":{\"484\":1}}],[\"用了几个数\",{\"1\":{\"291\":2}}],[\"用过则不合法\",{\"1\":{\"291\":1}}],[\"用这种写法不过是略微优化了一下\",{\"1\":{\"274\":1}}],[\"用整数\",{\"1\":{\"263\":1}}],[\"用\",{\"1\":{\"261\":1,\"291\":1,\"329\":1,\"330\":1,\"339\":1,\"360\":1,\"362\":1,\"381\":1,\"388\":1,\"422\":1,\"668\":1,\"982\":1,\"1006\":1,\"1313\":1,\"1387\":1}}],[\"用define定义的话后面不用加分号\",{\"1\":{\"235\":1}}],[\"用来做特殊资源的并发访问控制是相当合适的\",{\"1\":{\"1398\":1}}],[\"用来记录导致线程阻塞的阻塞对象\",{\"1\":{\"1259\":3}}],[\"用来阻塞线程和唤醒线程\",{\"1\":{\"1258\":1}}],[\"用来注册的信息\",{\"1\":{\"1184\":1}}],[\"用来标记是否注册过了\",{\"1\":{\"1184\":1}}],[\"用来向\",{\"1\":{\"1182\":1}}],[\"用来持有上下文\",{\"1\":{\"1164\":1}}],[\"用来将自己本地的\",{\"1\":{\"1158\":1}}],[\"用来将之后多余的步数去掉\",{\"1\":{\"236\":1}}],[\"用来跟其他\",{\"1\":{\"1157\":1}}],[\"用来描述\",{\"1\":{\"1138\":1}}],[\"用来处理\",{\"1\":{\"1095\":1}}],[\"用来对数据库中表的数据记录进行增\",{\"1\":{\"924\":1}}],[\"用来对数据库表中的数据进行增删改\",{\"1\":{\"909\":1}}],[\"用来创建数据库用户\",{\"1\":{\"909\":1}}],[\"用来查询数据库中表的记录\",{\"1\":{\"909\":1}}],[\"用来查找小于等于\",{\"1\":{\"322\":1}}],[\"用来查找大于等于\",{\"1\":{\"322\":1}}],[\"用来定义数据库对象\",{\"1\":{\"909\":1,\"911\":1}}],[\"用来存储各种常量\",{\"1\":{\"580\":1}}],[\"用来触发并执行job实例的机制\",{\"1\":{\"479\":1}}],[\"用来表示裁判员需要维护的是6个运动员\",{\"1\":{\"1392\":1}}],[\"用来表示可获取结果的异步任务\",{\"1\":{\"1375\":1}}],[\"用来表示表的别名\",{\"1\":{\"471\":1}}],[\"用来表示哪一行的小方块是横着放的\",{\"1\":{\"311\":1}}],[\"用来表示一个迷宫\",{\"1\":{\"278\":1}}],[\"用来表示地图\",{\"1\":{\"180\":1}}],[\"用来判断\",{\"1\":{\"253\":1}}],[\"用来遍历上下左右四个方向\",{\"1\":{\"228\":1,\"229\":1}}],[\"用数组\",{\"1\":{\"152\":1,\"875\":2}}],[\"用于表示所修饰的内容一旦赋值之后就不会再被改变\",{\"1\":{\"1462\":1}}],[\"用于表示某个程序元素\",{\"1\":{\"1052\":1}}],[\"用于两个线程间能够交换\",{\"1\":{\"1399\":1}}],[\"用于查询阻塞等待的线程是否被中断\",{\"1\":{\"1393\":1}}],[\"用于让\",{\"1\":{\"1392\":1}}],[\"用于保存任务的\",{\"1\":{\"1359\":1}}],[\"用于指向下一个节点从而构成链式队列\",{\"1\":{\"1281\":1}}],[\"用于清除过期缓存\",{\"1\":{\"1201\":1}}],[\"用于删除指定存储桶中的对象\",{\"1\":{\"1103\":1}}],[\"用于删除一个已存在的存储桶\",{\"1\":{\"1102\":1}}],[\"用于列出指定存储桶中的所有对象\",{\"1\":{\"1103\":1}}],[\"用于列出用户有权访问的所有存储桶\",{\"1\":{\"1102\":1}}],[\"用于从指定的存储桶中下载文件\",{\"1\":{\"1103\":1}}],[\"用于生成一个对象\",{\"1\":{\"1103\":1}}],[\"用于检查指定的对象\",{\"1\":{\"1103\":1}}],[\"用于检查指定的存储桶是否存在\",{\"1\":{\"1102\":1}}],[\"用于上传文件到指定的存储桶\",{\"1\":{\"1103\":1}}],[\"用于创建一个新的存储桶\",{\"1\":{\"1102\":1}}],[\"用于创建触发器trigger实例的构建器\",{\"1\":{\"479\":1}}],[\"用于将命令放到后台执行\",{\"1\":{\"1087\":1}}],[\"用于运行另一个命令在后台\",{\"1\":{\"1087\":1}}],[\"用于修饰包\",{\"1\":{\"1051\":1}}],[\"用于处理关闭资源时可能引发的所有异常\",{\"1\":{\"1049\":1}}],[\"用于处理大规模数据集\",{\"1\":{\"434\":1}}],[\"用于索引数据\",{\"1\":{\"958\":1}}],[\"用于限制存储在表中的数据\",{\"1\":{\"919\":1}}],[\"用于高效地存储和检索字符串数据集中的键\",{\"1\":{\"801\":1}}],[\"用于配置分布式存储\",{\"1\":{\"670\":1}}],[\"用于声明和实例化资源\",{\"1\":{\"1049\":1}}],[\"用于声明这一列的类型\",{\"1\":{\"592\":1}}],[\"用于声明一个任务实例\",{\"1\":{\"479\":1}}],[\"用于记录用户的登录状态\",{\"1\":{\"575\":1}}],[\"用于记录定时任务的执行日志\",{\"1\":{\"476\":1}}],[\"用于存放项目中的各种布局\",{\"1\":{\"548\":1}}],[\"用于存储定时任务的配置信息\",{\"1\":{\"476\":1}}],[\"用于存储大规模数据集\",{\"1\":{\"434\":1}}],[\"用于存储每个游戏节点之间的最小时间差\",{\"1\":{\"146\":1}}],[\"用于存储积分到玩家列表的映射\",{\"1\":{\"129\":1}}],[\"用于存储玩家名称到积分的映射\",{\"1\":{\"129\":1}}],[\"用于存储元素的下标\",{\"1\":{\"128\":1}}],[\"用于控制资源能够被并发访问的线程数量\",{\"1\":{\"1398\":1}}],[\"用于控制让\",{\"1\":{\"1392\":1}}],[\"用于控制样式和快速定位\",{\"1\":{\"545\":1}}],[\"用于控制是否要关联查询题目列表\",{\"1\":{\"523\":1}}],[\"用于控制并发和防止资源冲突\",{\"1\":{\"484\":1}}],[\"用于调度时间约束\",{\"1\":{\"484\":1}}],[\"用于简单重复执行作业的触发器\",{\"1\":{\"479\":1}}],[\"用于实现基于注解的访问控制\",{\"1\":{\"465\":1}}],[\"用于实时数据流的处理\",{\"1\":{\"434\":1}}],[\"用于管理用户相关的状态和操作\",{\"1\":{\"448\":1,\"453\":1}}],[\"用于开启\",{\"1\":{\"446\":1}}],[\"用于求解方程\",{\"1\":{\"383\":1}}],[\"用于累加理论最佳速通时间\",{\"1\":{\"146\":1}}],[\"用快速幂方法计算\",{\"1\":{\"139\":1}}],[\"用空格隔开\",{\"1\":{\"119\":1,\"180\":1}}],[\"用户线程完全结束后就意味着整个系统的业务任务全部结束了\",{\"1\":{\"1340\":1}}],[\"用户线程就可以认为是系统的工作线程\",{\"1\":{\"1340\":1}}],[\"用户程序的入口\",{\"1\":{\"1330\":1}}],[\"用户的id\",{\"1\":{\"938\":1}}],[\"用户的登录信息\",{\"1\":{\"575\":1}}],[\"用户匹配系统\",{\"2\":{\"615\":1}}],[\"用户注销实现\",{\"1\":{\"596\":1}}],[\"用户注销\",{\"0\":{\"596\":1},\"1\":{\"596\":1}}],[\"用户注册的时候通过\",{\"1\":{\"613\":1}}],[\"用户注册时可以通过布隆过滤器快速判断用户名是否重复\",{\"1\":{\"613\":1}}],[\"用户注册用户名重复的话\",{\"1\":{\"613\":1}}],[\"用户注册场景\",{\"1\":{\"613\":1}}],[\"用户注册请求\",{\"1\":{\"576\":1}}],[\"用户注册请求体\",{\"1\":{\"576\":1}}],[\"用户注册实现\",{\"1\":{\"568\":1}}],[\"用户注册\",{\"1\":{\"496\":1,\"507\":1,\"576\":1}}],[\"用户常量\",{\"1\":{\"580\":1}}],[\"用户状态优化\",{\"0\":{\"580\":1}}],[\"用户列表\",{\"1\":{\"578\":1,\"592\":1}}],[\"用户控制器\",{\"1\":{\"576\":1}}],[\"用户脱敏\",{\"1\":{\"575\":1}}],[\"用户已经有了会话\",{\"1\":{\"575\":1}}],[\"用户信息脱敏\",{\"1\":{\"574\":1,\"575\":1}}],[\"用户信息\",{\"1\":{\"573\":1,\"575\":1,\"576\":1,\"589\":1}}],[\"用户信息和用户权限信息\",{\"1\":{\"451\":1}}],[\"用户密码\",{\"1\":{\"568\":1,\"575\":1,\"576\":2}}],[\"用户逻辑实现\",{\"1\":{\"568\":1}}],[\"用户编号不得大于15位\",{\"1\":{\"568\":1}}],[\"用户在前端输入账户和密码\",{\"1\":{\"568\":1}}],[\"用户在访问网站时可以快速看到页面的内容\",{\"1\":{\"533\":1}}],[\"用户id\",{\"1\":{\"566\":1,\"568\":1,\"576\":1,\"579\":1}}],[\"用户权限\",{\"1\":{\"566\":1}}],[\"用户中心笔记第六期\",{\"1\":{\"603\":1}}],[\"用户中心笔记第五期\",{\"1\":{\"595\":1}}],[\"用户中心笔记第四期\",{\"1\":{\"583\":1}}],[\"用户中心笔记第三期\",{\"1\":{\"571\":1}}],[\"用户中心笔记第二期\",{\"1\":{\"563\":1}}],[\"用户中心笔记第一期\",{\"1\":{\"554\":1}}],[\"用户中心\",{\"2\":{\"562\":1,\"570\":1,\"582\":1,\"594\":1,\"602\":1,\"612\":1}}],[\"用户校验\",{\"1\":{\"556\":1}}],[\"用户请求时\",{\"1\":{\"534\":1}}],[\"用户仍然可以正常访问和浏览网页内容\",{\"1\":{\"533\":1}}],[\"用户可能在加载过程中看到空白页面\",{\"1\":{\"532\":1}}],[\"用户可以注册登录\",{\"1\":{\"493\":1}}],[\"用户可以根据自己的需求设定访问特定数据的规则\",{\"1\":{\"470\":1}}],[\"用户可以任意访问\",{\"1\":{\"446\":1}}],[\"用户可以在这里看到自己喜欢的评论内容\",{\"1\":{\"41\":1}}],[\"用户\",{\"1\":{\"510\":1,\"1309\":1}}],[\"用户角色\",{\"1\":{\"510\":1,\"566\":1}}],[\"用户简介\",{\"1\":{\"510\":1}}],[\"用户头像\",{\"1\":{\"510\":1,\"566\":2}}],[\"用户昵称\",{\"1\":{\"510\":1,\"566\":2}}],[\"用户表设计\",{\"0\":{\"566\":1}}],[\"用户表\",{\"1\":{\"510\":1,\"566\":1,\"938\":1}}],[\"用户表的核心是用户登录凭证\",{\"1\":{\"510\":1}}],[\"用户表的别名\",{\"1\":{\"471\":1}}],[\"用户刷题记录日历图\",{\"1\":{\"497\":1,\"508\":1}}],[\"用户模块\",{\"1\":{\"496\":1,\"507\":1}}],[\"用户管理\",{\"0\":{\"577\":1},\"1\":{\"471\":2,\"556\":1,\"592\":1}}],[\"用户则通过他们的角色来继承这些权限\",{\"1\":{\"470\":1}}],[\"用户点击菜单后会根据路由的\",{\"1\":{\"463\":1}}],[\"用户点击广告后\",{\"1\":{\"151\":1}}],[\"用户授权流程\",{\"1\":{\"456\":1}}],[\"用户登录态键\",{\"1\":{\"580\":1}}],[\"用户登录请求\",{\"1\":{\"576\":1}}],[\"用户登录请求体\",{\"1\":{\"576\":1}}],[\"用户登录成功\",{\"1\":{\"575\":1}}],[\"用户登录成功后\",{\"1\":{\"463\":1}}],[\"用户登录实现\",{\"1\":{\"575\":1}}],[\"用户登录\",{\"1\":{\"496\":1,\"507\":1,\"521\":1,\"576\":1}}],[\"用户登录流程\",{\"0\":{\"447\":1},\"1\":{\"451\":1}}],[\"用户登录后可访问\",{\"1\":{\"446\":1}}],[\"用户完全认证可以访问\",{\"1\":{\"446\":1}}],[\"用户不能访问\",{\"1\":{\"446\":1}}],[\"用户不满意的评论被顶到热评前排等问题均可能引发舆情问题\",{\"1\":{\"37\":1}}],[\"用户就能从容地用对的工具从对的数据中\",{\"1\":{\"438\":1}}],[\"用户名和密码都可以省略\",{\"1\":{\"1087\":1}}],[\"用户名不能重复\",{\"1\":{\"568\":1}}],[\"用户名不包含特殊字符\",{\"1\":{\"568\":1,\"575\":1}}],[\"用户名长度不小于4位\",{\"1\":{\"568\":1,\"575\":1}}],[\"用户名\",{\"1\":{\"566\":2,\"568\":1,\"573\":1,\"575\":1,\"576\":2,\"578\":1,\"920\":1}}],[\"用户名必须没有被注册过\",{\"1\":{\"88\":1}}],[\"用户名为\",{\"1\":{\"88\":1}}],[\"用户访问了第一页\",{\"1\":{\"48\":1}}],[\"用户等级加权等等\",{\"1\":{\"39\":1}}],[\"用户删除\",{\"1\":{\"22\":1,\"45\":1}}],[\"重排序的总结\",{\"1\":{\"1476\":1}}],[\"重排序到构造函数之外\",{\"1\":{\"1475\":1}}],[\"重排序规则表\",{\"1\":{\"1457\":1}}],[\"重排序在多线程中不注意的话也容易存在一些问题\",{\"1\":{\"1425\":1}}],[\"重排序可以分为两类\",{\"1\":{\"1423\":1}}],[\"重排序以及\",{\"1\":{\"1423\":1}}],[\"重排序\",{\"0\":{\"1418\":1}}],[\"重要的一点差异是\",{\"1\":{\"1404\":1}}],[\"重要的关键数据可以存储在数据库\",{\"1\":{\"437\":1}}],[\"重设下一次执行的时间\",{\"1\":{\"1368\":1}}],[\"重写方法\",{\"1\":{\"1496\":1}}],[\"重写的\",{\"1\":{\"1495\":1}}],[\"重写的条件是\",{\"1\":{\"688\":1}}],[\"重写了\",{\"1\":{\"1368\":1}}],[\"重写\",{\"0\":{\"1469\":1},\"1\":{\"1330\":1}}],[\"重hash\",{\"1\":{\"1273\":1}}],[\"重哈希\",{\"1\":{\"1272\":1}}],[\"重点方法讲解\",{\"0\":{\"1269\":1}}],[\"重点关注后端部分\",{\"1\":{\"481\":1}}],[\"重量级锁\",{\"1\":{\"1264\":1}}],[\"重量为\",{\"1\":{\"772\":1}}],[\"重入性\",{\"1\":{\"1237\":1}}],[\"重入性的实现了\",{\"1\":{\"1232\":1}}],[\"重入性的实现原理\",{\"0\":{\"1232\":1},\"1\":{\"1231\":1}}],[\"重入锁的释放必须得等到同步状态为\",{\"1\":{\"1232\":1}}],[\"重入锁\",{\"1\":{\"1231\":1}}],[\"重命名为\",{\"1\":{\"1090\":1}}],[\"重新计算超时时间\",{\"1\":{\"1508\":1}}],[\"重新设计了任务类\",{\"1\":{\"1371\":1}}],[\"重新确定entry在新数组的位置\",{\"1\":{\"1306\":1}}],[\"重新从\",{\"1\":{\"1285\":1}}],[\"重新调整堆\",{\"1\":{\"1078\":1}}],[\"重新启动主程序以初始化新的管理员账户\",{\"1\":{\"670\":1}}],[\"重新赋给每个元素的值\",{\"1\":{\"254\":1}}],[\"重定向到标准输出\",{\"1\":{\"1087\":1}}],[\"重定向到\",{\"1\":{\"587\":1,\"1087\":1}}],[\"重启之后数据亦然存在\",{\"1\":{\"955\":1}}],[\"重启服务\",{\"1\":{\"671\":1}}],[\"重启防火墙\",{\"1\":{\"663\":1}}],[\"重启项目即可\",{\"1\":{\"489\":1}}],[\"重启\",{\"1\":{\"475\":1}}],[\"重载小于运算符\",{\"1\":{\"429\":1}}],[\"重载小于号\",{\"1\":{\"361\":1}}],[\"重载\",{\"0\":{\"1470\":1},\"1\":{\"423\":1}}],[\"重置为未访问\",{\"1\":{\"236\":1,\"237\":1}}],[\"重置标记数组即可\",{\"1\":{\"235\":1}}],[\"重复上述步骤\",{\"1\":{\"869\":1}}],[\"重复上述步骤即可\",{\"1\":{\"742\":1}}],[\"重复上述过程\",{\"1\":{\"168\":1}}],[\"重复执行直到队列为空\",{\"1\":{\"355\":1}}],[\"重复的注释就不再赘述了\",{\"1\":{\"229\":1}}],[\"重复此过程\",{\"1\":{\"99\":1}}],[\"重复这个过程\",{\"1\":{\"92\":1}}],[\"重建时会启用预加载\",{\"1\":{\"28\":1}}],[\"重在提升视频观看体验\",{\"1\":{\"21\":1}}],[\"但在同步队列中进行等待的时候可以检测中断\",{\"1\":{\"1500\":1}}],[\"但在实际应用中\",{\"1\":{\"971\":1}}],[\"但操作完不知道何时会写到内存\",{\"1\":{\"1454\":1}}],[\"但它同时不容易被正确理解\",{\"1\":{\"1453\":1}}],[\"但它并不用返回当前hashmap的元素个数\",{\"1\":{\"1275\":1}}],[\"但整个付款的时间大大缩短\",{\"1\":{\"1434\":1}}],[\"但他们仍然是属于同一个类依然会被锁住\",{\"1\":{\"1430\":1}}],[\"但总的来说\",{\"1\":{\"1425\":1}}],[\"但总体来说读的操作效率要远远高于写的性能\",{\"1\":{\"1286\":1}}],[\"但与此同时利用定义中的第二条\",{\"1\":{\"1421\":1}}],[\"但由于存在重排序的问题\",{\"1\":{\"1485\":1}}],[\"但由于\",{\"1\":{\"1380\":1}}],[\"但由于部分缓存数据项的重建代价较高\",{\"1\":{\"28\":1}}],[\"但如果线程数多于处理器的数目\",{\"1\":{\"1331\":1}}],[\"但如果是一维\",{\"1\":{\"772\":1}}],[\"但实际上做了两件事情\",{\"1\":{\"1475\":1}}],[\"但实际上\",{\"1\":{\"1330\":1}}],[\"但实际上后面的搜索中可能还是要走这条路的\",{\"1\":{\"235\":1}}],[\"但我更倾向于把它当作是一种并发容器\",{\"1\":{\"1299\":1}}],[\"但我们维护的是一个小根堆\",{\"1\":{\"221\":1}}],[\"但两者还是有些不同\",{\"1\":{\"1295\":1}}],[\"但此时\",{\"1\":{\"1283\":1}}],[\"但此时以每个节点到达终点的距离作为优先级\",{\"1\":{\"214\":1}}],[\"但这个对象属性是可以改变的\",{\"1\":{\"1467\":1}}],[\"但这种转换方式依然是通过\",{\"1\":{\"1280\":1}}],[\"但这次野猪骑士并没有上路\",{\"1\":{\"128\":1}}],[\"但关闭会话服务会停止\",{\"1\":{\"1087\":1}}],[\"但最好使用\",{\"1\":{\"1075\":1}}],[\"但从index开始从后往前找\",{\"1\":{\"1069\":1}}],[\"但从index开始找\",{\"1\":{\"1069\":1}}],[\"但其实\",{\"1\":{\"1068\":1}}],[\"但其有一个缺点\",{\"1\":{\"263\":1}}],[\"但注解可以被编译或运行\",{\"1\":{\"1051\":1}}],[\"但该对象的类无法实现\",{\"1\":{\"1045\":1}}],[\"但该字符串不能转换为适当格式时\",{\"1\":{\"1045\":1}}],[\"但可以是多列\",{\"1\":{\"947\":1}}],[\"但可以是多行\",{\"1\":{\"947\":1}}],[\"但可购买vip卡免去骑行费用\",{\"1\":{\"65\":1}}],[\"但要注意\",{\"1\":{\"869\":1}}],[\"但\",{\"1\":{\"838\":1,\"1420\":1,\"1429\":1,\"1482\":1}}],[\"但题目要求倒数第\",{\"1\":{\"777\":1}}],[\"但坏处是它会占用大量的系统资源\",{\"1\":{\"671\":1}}],[\"但很快发现\",{\"1\":{\"668\":1}}],[\"但依然推荐一些国外厂商的云主机\",{\"1\":{\"662\":1}}],[\"但不建议这么做\",{\"1\":{\"1077\":1}}],[\"但不要对其进行改动\",{\"1\":{\"1072\":1}}],[\"但不更改其余元素的顺序得到的数组\",{\"1\":{\"850\":1}}],[\"但不推荐\",{\"1\":{\"539\":1}}],[\"但不能降级\",{\"1\":{\"1264\":1}}],[\"但不能添加任何元素\",{\"1\":{\"1074\":1}}],[\"但不能不取\",{\"1\":{\"394\":1}}],[\"但不能跟小团选择同一个数\",{\"1\":{\"174\":1}}],[\"但值得一提的是\",{\"1\":{\"534\":1}}],[\"但某些部分需要动态更新的网站\",{\"1\":{\"534\":1}}],[\"但某些题目会描述为\",{\"1\":{\"228\":1}}],[\"但也面临服务器压力大和开发复杂度高的挑战\",{\"1\":{\"533\":1}}],[\"但也面临首屏加载速度较慢和搜索引擎优化不友好的问题\",{\"1\":{\"532\":1}}],[\"但也有一点根本性差异\",{\"1\":{\"40\":1}}],[\"但返回的还是对象\",{\"1\":{\"525\":1}}],[\"但缺点也很明显\",{\"1\":{\"484\":1}}],[\"但随着数据体量增大\",{\"1\":{\"438\":1}}],[\"但随着b站社区破圈起量\",{\"1\":{\"30\":1}}],[\"但城建的棋类游戏\",{\"1\":{\"395\":1}}],[\"但归并排序的核心在这一步骤\",{\"1\":{\"317\":1}}],[\"但地图没有这么大\",{\"1\":{\"263\":1}}],[\"但都是大同小异\",{\"1\":{\"231\":1}}],[\"但都能保障用户的基础体验\",{\"1\":{\"34\":1}}],[\"但对于数据传输的安全性和及时性有较高要求的业务来说\",{\"1\":{\"1094\":1}}],[\"但对于\",{\"1\":{\"228\":1}}],[\"但前面的选择题有一定难度\",{\"1\":{\"86\":1}}],[\"但只能过\",{\"1\":{\"72\":1}}],[\"但评论往往不会如此激进\",{\"1\":{\"40\":1}}],[\"但是却拥有了锁获取和释放的可操作性\",{\"1\":{\"1492\":1}}],[\"但是它在应用程序启动几秒钟之后才激活\",{\"1\":{\"1444\":1}}],[\"但是它基本上包含了\",{\"1\":{\"1134\":1}}],[\"但是之后等待的条件发生了变化\",{\"1\":{\"1407\":1}}],[\"但是老师只准备了\",{\"1\":{\"1398\":1}}],[\"但是相比于\",{\"1\":{\"1393\":1}}],[\"但是相较于\",{\"1\":{\"1371\":1}}],[\"但是实际上的确发生了变化\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"但是会阻塞当前线程直至异步任务执行结束\",{\"1\":{\"1375\":1}}],[\"但是因为\",{\"1\":{\"1318\":1}}],[\"但是全部搞定还需要掌握\",{\"1\":{\"1316\":1}}],[\"但是插入后会调用\",{\"1\":{\"1314\":1}}],[\"但是该线程还是会执行\",{\"1\":{\"1340\":1}}],[\"但是该方法并不会停下\",{\"1\":{\"1316\":1}}],[\"但是该\",{\"1\":{\"1313\":1,\"1316\":1}}],[\"但是对象只占有一份内存\",{\"1\":{\"1313\":1}}],[\"但是对于用户的身份信息查询频率很低\",{\"1\":{\"938\":1}}],[\"但是垃圾回收器无法回收这个部分的内存\",{\"1\":{\"1306\":1}}],[\"但是同时也存在两个问题\",{\"1\":{\"1295\":1}}],[\"但是读线程对数据容器的数据并不会发生发生修改\",{\"1\":{\"1290\":1}}],[\"但是位运算比取模运算的效率要高很多\",{\"1\":{\"1272\":1}}],[\"但是注意许可不可重入\",{\"1\":{\"1258\":1}}],[\"但是每个线程使用时\",{\"1\":{\"1226\":1}}],[\"但是创建了很多的线程\",{\"1\":{\"1220\":1}}],[\"但是电脑重启后\",{\"1\":{\"1200\":1}}],[\"但是一分钟内的续约数没有达到\",{\"1\":{\"1191\":1}}],[\"但是只看\",{\"1\":{\"1175\":1}}],[\"但是有一些处理器会重排序\",{\"1\":{\"1475\":1}}],[\"但是有了\",{\"1\":{\"1129\":2}}],[\"但是有可能出现\",{\"1\":{\"271\":1}}],[\"但是在实际使用中\",{\"1\":{\"1306\":1}}],[\"但是在写线程访问时\",{\"1\":{\"1237\":1}}],[\"但是在\",{\"1\":{\"958\":1,\"1318\":1}}],[\"但是如果是自定义的实体类对象\",{\"1\":{\"1074\":1}}],[\"但是如果高并发访问\",{\"1\":{\"958\":1}}],[\"但是如果数据给的\",{\"1\":{\"899\":1}}],[\"但是如果都不是\",{\"1\":{\"613\":1}}],[\"但是路径方向必须是向下的\",{\"1\":{\"880\":1}}],[\"但是由于通知过了\",{\"1\":{\"1406\":1}}],[\"但是由于不需要同步也就减少了线程可能存在的阻塞等待的情况从而提高的时间效率\",{\"1\":{\"1299\":1}}],[\"但是由于它是支持并发扩容的\",{\"1\":{\"1274\":1}}],[\"但是由于网络故障\",{\"1\":{\"1191\":1}}],[\"但是由于每个子问题都需要进行枚举\",{\"1\":{\"851\":1}}],[\"但是由于业务数据量较大\",{\"1\":{\"26\":1}}],[\"但是查找慢\",{\"1\":{\"687\":1}}],[\"但是数据不会丢失\",{\"1\":{\"1200\":1}}],[\"但是数据无固定顺序\",{\"1\":{\"687\":1}}],[\"但是数据库擅长事务性工作\",{\"1\":{\"436\":1}}],[\"但是这里其实是有一个前提条件的\",{\"1\":{\"1478\":1}}],[\"但是这两者还是各有不同侧重点的\",{\"1\":{\"1394\":1}}],[\"但是这种加锁的方式会让未获取到锁的线程进行阻塞等待\",{\"1\":{\"1299\":1}}],[\"但是这些容器类基本上不是线程安全的\",{\"1\":{\"1324\":1}}],[\"但是这些方式都是采用\",{\"1\":{\"1290\":1}}],[\"但是这些类都不是线程安全的类\",{\"1\":{\"1280\":1}}],[\"但是这时候\",{\"1\":{\"1191\":1}}],[\"但是这毕竟很麻烦\",{\"1\":{\"664\":1}}],[\"但是这个会\",{\"1\":{\"575\":1}}],[\"但是别开心的太早\",{\"1\":{\"664\":1}}],[\"但是布隆过滤器解决缓存穿透还存在另外一个缺点\",{\"1\":{\"613\":1}}],[\"但是可能右上角的头像和用户名一直加载不出来\",{\"1\":{\"591\":1}}],[\"但是区块一直无法显示\",{\"1\":{\"559\":1}}],[\"但是我们还需要手动整合代码自动格式化插件\",{\"1\":{\"539\":1}}],[\"但是企业中还存在大量的与业务没有直接关联的辅助型数据\",{\"1\":{\"437\":1}}],[\"但是疲倦的它们再也不想徒步走下山了\",{\"1\":{\"290\":1}}],[\"但是不能省略\",{\"1\":{\"1013\":1}}],[\"但是不需要由客户端再动态地向后端发送请求来获取数据\",{\"1\":{\"534\":1}}],[\"但是不一定\",{\"1\":{\"274\":1}}],[\"但是不小心加进去了一些无关的单词\",{\"1\":{\"172\":1}}],[\"但是当\",{\"1\":{\"216\":1,\"1340\":1}}],[\"但是算法也有缺点\",{\"1\":{\"214\":1}}],[\"但是那个格子上面的数字\",{\"1\":{\"196\":1}}],[\"但是牛牛有强迫症\",{\"1\":{\"193\":1}}],[\"但是热点\",{\"1\":{\"61\":1}}],[\"但是\",{\"1\":{\"50\":1,\"531\":2,\"1218\":1,\"1286\":1,\"1290\":2,\"1331\":1,\"1339\":1,\"1365\":1,\"1402\":1,\"1454\":1,\"1469\":1,\"1478\":1}}],[\"但是架构层次来说\",{\"1\":{\"47\":1}}],[\"但是评论区的计数更新操作\",{\"1\":{\"30\":1}}],[\"但是需要提供极高的可用性与性能吞吐\",{\"1\":{\"27\":1}}],[\"从方法名就可以很清楚\",{\"1\":{\"1504\":1}}],[\"从执行情况也可以看出来当前\",{\"1\":{\"1496\":1}}],[\"从横向来看\",{\"1\":{\"1433\":1}}],[\"从横向上看\",{\"1\":{\"1417\":1,\"1456\":1}}],[\"从程序员的角度来说\",{\"1\":{\"1420\":1}}],[\"从程序语法角度讲是必须进行处理的异常\",{\"1\":{\"1044\":1}}],[\"从主存中读取最新的共享变量\",{\"1\":{\"1417\":1}}],[\"从主内存中将共享变量读入线程\",{\"1\":{\"1417\":1}}],[\"从输出结果可以看出\",{\"1\":{\"1393\":1}}],[\"从示例中可以看出\",{\"1\":{\"1388\":1}}],[\"从结果可以看出\",{\"1\":{\"1387\":1}}],[\"从结果可以看出索引为\",{\"1\":{\"1386\":1}}],[\"从图可以看出\",{\"1\":{\"1358\":1}}],[\"从它的构造方法可以看出\",{\"1\":{\"1349\":1}}],[\"从客户那里获取需求后\",{\"1\":{\"1337\":1}}],[\"从文章开头通过\",{\"1\":{\"1318\":1}}],[\"从以上分析\",{\"1\":{\"1348\":1}}],[\"从以上的分析可以看出\",{\"1\":{\"1318\":1}}],[\"从以上\",{\"1\":{\"1317\":1}}],[\"从当前位置\",{\"1\":{\"1316\":1}}],[\"从当前脏\",{\"1\":{\"1316\":1}}],[\"从当前\",{\"1\":{\"1316\":1}}],[\"从当前点到终点的估计距离\",{\"1\":{\"221\":1}}],[\"从源码可以很明显的看出\",{\"1\":{\"1368\":1}}],[\"从源码可以看出当线程结束时\",{\"1\":{\"1319\":1}}],[\"从源码就可以看出\",{\"1\":{\"1368\":1}}],[\"从源码中可以看出\",{\"1\":{\"1346\":1}}],[\"从源码中我们可以清楚的看到\",{\"1\":{\"1306\":1}}],[\"从源码深入详解\",{\"0\":{\"1312\":1}}],[\"从map中删除以当前threadlocal实例为key的键值对\",{\"1\":{\"1303\":1}}],[\"从队列中删除数据\",{\"1\":{\"1325\":1}}],[\"从队列中出队后的状态\",{\"1\":{\"1284\":1}}],[\"从队头弹出一个数\",{\"1\":{\"409\":1}}],[\"从类名就可以看的出来实现队列的数据结构是链式\",{\"1\":{\"1280\":1}}],[\"从类图关系中可以看到\",{\"1\":{\"1178\":1}}],[\"从给出的注释来看\",{\"1\":{\"1275\":1}}],[\"从链表中查找\",{\"1\":{\"1273\":1}}],[\"从整体而言\",{\"1\":{\"1272\":1}}],[\"从整体上来看\",{\"1\":{\"1248\":1,\"1433\":1,\"1491\":1}}],[\"从该类的注释也可以看出\",{\"1\":{\"1267\":1}}],[\"从该状态到达目标状态的估价函数\",{\"1\":{\"224\":1}}],[\"从这个例子就可以很清楚的看出来\",{\"1\":{\"1496\":1}}],[\"从这个例子就可以看出\",{\"1\":{\"1398\":1}}],[\"从这个图我们可以很清楚的看到这样几点\",{\"1\":{\"1250\":1}}],[\"从这个角度上来说\",{\"1\":{\"899\":1}}],[\"从注册表中剔除\",{\"1\":{\"1191\":1}}],[\"从相邻节点拷贝注册信息\",{\"0\":{\"1167\":1}}],[\"从堆栈的顶部返回元素的位置\",{\"1\":{\"1075\":1}}],[\"从休眠中中断线程\",{\"1\":{\"1060\":1}}],[\"从业务概念方面来讲\",{\"1\":{\"963\":1}}],[\"从初始的\",{\"1\":{\"869\":1}}],[\"从根节点到当前节点的路径上的前缀和为\",{\"1\":{\"881\":1}}],[\"从根节点依次开始匹配每个字符\",{\"1\":{\"803\":1}}],[\"从根节点出发到任一个节点都是一个前缀\",{\"1\":{\"802\":1}}],[\"从根节点开始构造这个word对应的路径节点\",{\"1\":{\"803\":1}}],[\"从根节点开始\",{\"1\":{\"133\":1,\"729\":1}}],[\"从前序遍历数组的第一个元素开始\",{\"1\":{\"766\":1}}],[\"从前序与中序遍历序列构造二叉树\",{\"0\":{\"764\":1},\"1\":{\"764\":1}}],[\"从前面使用\",{\"1\":{\"671\":1}}],[\"从机存储\",{\"1\":{\"670\":1}}],[\"从effective\",{\"1\":{\"626\":1,\"632\":1}}],[\"从零开始了解推荐系统全貌\",{\"1\":{\"622\":1}}],[\"从服务器获取所需的数据\",{\"1\":{\"532\":1}}],[\"从关联表查到的虽然只有一个字段\",{\"1\":{\"525\":1}}],[\"从题目表查询到题目的完整信息\",{\"1\":{\"525\":1}}],[\"从数据结构中找到并移除最小节点\",{\"1\":{\"789\":1}}],[\"从数据库中查询任务配置列表\",{\"1\":{\"481\":1}}],[\"从数据获取到数据应用到完整流程上\",{\"1\":{\"438\":1}}],[\"从数据写入主线程中剥离\",{\"1\":{\"33\":1}}],[\"从多个数据源抽取有价值的数据\",{\"1\":{\"436\":1}}],[\"从大容量数据中挖掘价值的一种全新的技术架构\",{\"1\":{\"434\":1}}],[\"从大到小排序需要加入第三个参数\",{\"1\":{\"423\":1}}],[\"从大到小排序\",{\"1\":{\"423\":1}}],[\"从0开始\",{\"1\":{\"411\":1}}],[\"从00\",{\"1\":{\"309\":1}}],[\"从栈顶弹出一个数\",{\"1\":{\"406\":1}}],[\"从一个未匹配路出发\",{\"1\":{\"363\":1}}],[\"从一个未匹配点出发\",{\"1\":{\"363\":1}}],[\"从高位到低位运算\",{\"1\":{\"330\":1}}],[\"从小到大枚举n的所有约数对里面比较小的那一个\",{\"1\":{\"375\":1}}],[\"从小到大枚举所有的质数\",{\"1\":{\"371\":1}}],[\"从小到大判断\",{\"1\":{\"375\":1}}],[\"从小到大尝试\",{\"1\":{\"368\":1}}],[\"从小到大遍历\",{\"1\":{\"367\":1,\"373\":1}}],[\"从小到大依次枚举每组边\",{\"1\":{\"361\":1}}],[\"从小到大\",{\"1\":{\"327\":1,\"328\":1}}],[\"从头开始遍历比较\",{\"1\":{\"833\":1}}],[\"从头开始遍历\",{\"1\":{\"318\":1}}],[\"从1\",{\"1\":{\"309\":1}}],[\"从下往上遍历\",{\"1\":{\"301\":1}}],[\"从上图中就可以看出来\",{\"1\":{\"1431\":1}}],[\"从上图中可以看出\",{\"1\":{\"1423\":1}}],[\"从上图可以看出\",{\"1\":{\"1326\":1,\"1433\":1}}],[\"从上面内存抽象结构来说\",{\"1\":{\"1425\":1}}],[\"从上面更新时的状态图可以看出\",{\"1\":{\"1286\":1}}],[\"从上面的分析可以看出\",{\"1\":{\"1423\":1}}],[\"从上面的分析我们已经知道\",{\"1\":{\"1304\":1}}],[\"从上面的结构示意图就可以看出存在这样一种情况\",{\"1\":{\"1272\":1}}],[\"从上面的例子可以看出\",{\"1\":{\"152\":1}}],[\"从上往下遍历\",{\"1\":{\"301\":1}}],[\"从顶部出发\",{\"1\":{\"301\":1}}],[\"从start开始枚举剩下的可选数字\",{\"1\":{\"289\":1}}],[\"从各点到终点的最短路距离\",{\"1\":{\"223\":1}}],[\"从终点开始\",{\"1\":{\"223\":1}}],[\"从终点开始逐步追踪\",{\"1\":{\"215\":1}}],[\"从起点到该状态的真实距离+该状态到目标状态的估价距离\",{\"1\":{\"224\":1}}],[\"从起点到当前点的真实距离\",{\"1\":{\"221\":1}}],[\"从起点开始\",{\"1\":{\"110\":1,\"212\":1}}],[\"从任意一个格子出发\",{\"1\":{\"196\":1}}],[\"从第一个数中减去第二个数\",{\"1\":{\"979\":1}}],[\"从第1块草地走到第3块\",{\"1\":{\"193\":1}}],[\"从第二年开始\",{\"1\":{\"182\":1}}],[\"从游戏开始到第\",{\"1\":{\"146\":1}}],[\"从排行榜中删除\",{\"1\":{\"129\":1}}],[\"从右向左遍历\",{\"1\":{\"128\":1}}],[\"从右往左遍历数组\",{\"1\":{\"128\":2}}],[\"从左向右数\",{\"1\":{\"173\":1}}],[\"从左到右走过这一排房子\",{\"1\":{\"827\":1}}],[\"从左到右访问所有节点\",{\"1\":{\"741\":1}}],[\"从左到右分别编号为\",{\"1\":{\"147\":1}}],[\"从左到右\",{\"1\":{\"133\":1}}],[\"从左到右宝石的编号\",{\"1\":{\"103\":1}}],[\"从左往右第\",{\"1\":{\"66\":1}}],[\"从位置为\",{\"1\":{\"77\":4}}],[\"从\",{\"1\":{\"48\":1,\"72\":1,\"98\":1,\"110\":1,\"126\":2,\"128\":1,\"129\":10,\"181\":2,\"215\":1,\"229\":1,\"287\":1,\"289\":1,\"291\":1,\"371\":1,\"434\":1,\"709\":1,\"772\":1,\"796\":1,\"840\":1,\"919\":1,\"1248\":1,\"1299\":1,\"1306\":1,\"1309\":1,\"1365\":1,\"1407\":2,\"1410\":1,\"1421\":1}}],[\"从而进一步可以佐证获得锁的过程是一个\",{\"1\":{\"1506\":1}}],[\"从而进入同步队列\",{\"1\":{\"1501\":1}}],[\"从而进入到同步代码块或者同步方法之中\",{\"1\":{\"1434\":1}}],[\"从而进入到同步代块中\",{\"1\":{\"1407\":1}}],[\"从而实现自己的同步语义\",{\"1\":{\"1496\":1}}],[\"从而就可以避免这种情况\",{\"1\":{\"1475\":1}}],[\"从而就解决了对象在被共享访问带来线程安全问题\",{\"1\":{\"1313\":1}}],[\"从而\",{\"1\":{\"1475\":1,\"1486\":1}}],[\"从而能够顺利停止掉\",{\"1\":{\"1458\":1}}],[\"从而能够结束在\",{\"1\":{\"1458\":1}}],[\"从而需要再次从主内存中读取该值\",{\"1\":{\"1458\":1}}],[\"从而避免这种情况\",{\"1\":{\"1485\":1}}],[\"从而避免出现数据脏读的现象\",{\"1\":{\"1453\":1}}],[\"从而避免了\",{\"1\":{\"1406\":1}}],[\"从而对每个线程都是可见的\",{\"1\":{\"1417\":1}}],[\"从而使得调用\",{\"1\":{\"1404\":1}}],[\"从而使得线程\",{\"1\":{\"1253\":1}}],[\"从而提高了线程并发执行的效率\",{\"1\":{\"1353\":1}}],[\"从而提高系统的可靠性和容错能力\",{\"1\":{\"1095\":1}}],[\"从而做出响应\",{\"1\":{\"1336\":1}}],[\"从而通过\",{\"1\":{\"1315\":1}}],[\"从而解决\",{\"1\":{\"1295\":1}}],[\"从而保证该对象对所有线程可见时\",{\"1\":{\"1476\":1}}],[\"从而保证数据的\",{\"1\":{\"1453\":1}}],[\"从而保证读写是在两个不同的数据容器中进行操作\",{\"1\":{\"1294\":1}}],[\"从而保证上式中的\",{\"1\":{\"795\":1}}],[\"从而确定新值插入到数组的哪个位置\",{\"1\":{\"1272\":1}}],[\"从而大大减小哈希冲突的可能性\",{\"1\":{\"1272\":1}}],[\"从而影响到\",{\"1\":{\"1272\":1}}],[\"从而调用\",{\"1\":{\"1271\":1}}],[\"从而才有机会使得调用\",{\"1\":{\"1252\":1}}],[\"从而达到\",{\"1\":{\"1129\":1}}],[\"从而不断扩散直到没有新鲜橘子或者无法扩散\",{\"1\":{\"869\":1}}],[\"从而联想到归并排序\",{\"1\":{\"833\":1}}],[\"从而明确开发计划\",{\"1\":{\"506\":1}}],[\"从而便于删除前导0\",{\"1\":{\"330\":1}}],[\"从而把基础能力和业务能力剥离\",{\"1\":{\"46\":1}}],[\"从而具备了水平扩容能力\",{\"1\":{\"30\":1}}],[\"从而更好地满足各类用户的需求\",{\"1\":{\"21\":1}}],[\"从db读取到内容之后反写缓存\",{\"1\":{\"28\":1}}],[\"模糊匹配\",{\"1\":{\"931\":1}}],[\"模型\",{\"1\":{\"565\":1}}],[\"模型结合使用时\",{\"1\":{\"445\":1}}],[\"模拟堆栈\",{\"1\":{\"302\":1}}],[\"模拟\",{\"1\":{\"108\":1}}],[\"模块中的\",{\"1\":{\"465\":1}}],[\"模块中\",{\"1\":{\"450\":1,\"451\":1,\"455\":1,\"456\":1,\"461\":1,\"462\":1,\"487\":1}}],[\"模块的\",{\"1\":{\"447\":1,\"458\":1}}],[\"模块\",{\"1\":{\"46\":1}}],[\"模式的\",{\"1\":{\"540\":1}}],[\"模式下情景图如下\",{\"1\":{\"1250\":1}}],[\"模式下\",{\"1\":{\"533\":1}}],[\"模式字符串\",{\"1\":{\"127\":1}}],[\"模式\",{\"1\":{\"28\":1,\"48\":1}}],[\"模板方法又依赖于被\",{\"1\":{\"1496\":1}}],[\"模板渲染和路由处理等\",{\"1\":{\"533\":1}}],[\"模板渲染和内容填充\",{\"1\":{\"532\":1}}],[\"模板渲染\",{\"1\":{\"533\":1}}],[\"模板代码如下\",{\"1\":{\"307\":1}}],[\"模板代码\",{\"1\":{\"305\":1}}],[\"模板\",{\"0\":{\"3\":1,\"274\":1},\"1\":{\"227\":2},\"2\":{\"315\":1,\"343\":1,\"364\":1,\"400\":1,\"424\":1,\"432\":1}}],[\"after\",{\"1\":{\"1283\":1,\"1315\":1,\"1316\":1}}],[\"after=mysqld\",{\"1\":{\"671\":1}}],[\"after=network\",{\"1\":{\"671\":1}}],[\"aqs可重写的方法如下图\",{\"1\":{\"1495\":1}}],[\"aqs的角度\",{\"1\":{\"1496\":1}}],[\"aqs的底层实现\",{\"1\":{\"1252\":1}}],[\"aqs的底层实现分析可以看这篇文章\",{\"1\":{\"1239\":1}}],[\"aqs的实现原理\",{\"1\":{\"1250\":1}}],[\"aqs\",{\"0\":{\"1490\":1,\"1494\":1,\"1495\":1,\"1499\":1,\"1500\":1},\"1\":{\"1232\":1,\"1239\":3,\"1240\":1,\"1242\":2,\"1250\":9,\"1251\":5,\"1258\":1,\"1493\":1,\"1494\":1,\"1495\":18,\"1496\":22,\"1500\":7,\"1501\":5,\"1503\":1,\"1506\":1,\"1507\":1,\"1508\":1,\"1511\":1}}],[\"aq​\",{\"1\":{\"103\":1}}],[\"aggressively\",{\"1\":{\"1319\":1}}],[\"aggressive\",{\"1\":{\"1315\":1}}],[\"again\",{\"1\":{\"1107\":1}}],[\"age=2\",{\"1\":{\"1387\":2}}],[\"age=1\",{\"1\":{\"1387\":2}}],[\"age=\",{\"1\":{\"1387\":1,\"1388\":1,\"1467\":1}}],[\"age\",{\"1\":{\"1005\":2,\"1387\":5,\"1388\":8,\"1467\":6}}],[\"agent\",{\"1\":{\"543\":1}}],[\"azure\",{\"1\":{\"1095\":1}}],[\"a++\",{\"1\":{\"979\":1,\"1432\":1,\"1482\":2}}],[\"aec\",{\"1\":{\"838\":1}}],[\"aux\",{\"1\":{\"672\":1}}],[\"authcheck\",{\"1\":{\"525\":1,\"526\":1}}],[\"auth\",{\"1\":{\"446\":2}}],[\"authenticated\",{\"1\":{\"446\":2}}],[\"authenticationentrypoint\",{\"1\":{\"446\":1}}],[\"authenticationentrypointimpl\",{\"1\":{\"446\":2}}],[\"authenticationtokenfilter\",{\"1\":{\"446\":2}}],[\"authenticationmanagerbean\",{\"1\":{\"446\":2}}],[\"authenticationmanagerbuilder\",{\"1\":{\"446\":2}}],[\"authenticationmanager\",{\"1\":{\"446\":3}}],[\"authentication\",{\"1\":{\"445\":1,\"446\":4}}],[\"authorizerequests\",{\"1\":{\"446\":2}}],[\"authorization\",{\"1\":{\"445\":1}}],[\"author\",{\"1\":{\"446\":1,\"515\":1,\"517\":1,\"526\":2,\"568\":1,\"576\":3,\"580\":1}}],[\"autowirecapablebeanfactory\",{\"1\":{\"1137\":1}}],[\"autowired\",{\"1\":{\"446\":7}}],[\"autorollattime>\",{\"1\":{\"1090\":1}}],[\"autologin\",{\"1\":{\"588\":1,\"589\":1}}],[\"automatic\",{\"1\":{\"538\":1}}],[\"auto\",{\"1\":{\"121\":2,\"200\":2,\"203\":2,\"223\":2,\"224\":1,\"245\":1,\"250\":1,\"255\":4,\"278\":1,\"279\":1,\"298\":1,\"309\":5,\"311\":1,\"327\":1,\"328\":2,\"329\":1,\"330\":1,\"342\":1,\"345\":1,\"353\":1,\"355\":1,\"356\":1,\"376\":1,\"429\":1,\"431\":1,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"566\":1,\"592\":1,\"919\":3}}],[\"am\",{\"1\":{\"1340\":5}}],[\"amazon\",{\"1\":{\"1095\":2}}],[\"amount\",{\"1\":{\"892\":1,\"893\":5,\"894\":8}}],[\"amd64\",{\"1\":{\"670\":3,\"1087\":1,\"1089\":1}}],[\"am​\",{\"1\":{\"146\":1,\"168\":1}}],[\"attempt\",{\"1\":{\"1252\":1}}],[\"attack\",{\"1\":{\"1032\":1,\"1033\":2,\"1034\":2}}],[\"athena\",{\"1\":{\"1034\":3}}],[\"atomicstampedreference\",{\"1\":{\"1388\":1,\"1439\":1}}],[\"atomicmarkablereference\",{\"1\":{\"1387\":1}}],[\"atomicreference<>\",{\"1\":{\"1387\":1}}],[\"atomicreference<user>\",{\"1\":{\"1387\":1}}],[\"atomicreferencefieldupdater\",{\"1\":{\"1387\":1}}],[\"atomicreference\",{\"1\":{\"1387\":3,\"1439\":1}}],[\"atomicreferencearray\",{\"1\":{\"1386\":1}}],[\"atomicdemo\",{\"1\":{\"1385\":1,\"1386\":1,\"1387\":1,\"1388\":1}}],[\"atomiclongfieldupdater\",{\"1\":{\"1388\":1}}],[\"atomiclongarray\",{\"1\":{\"1386\":1}}],[\"atomiclong\",{\"1\":{\"1385\":2}}],[\"atomicboolean\",{\"1\":{\"1385\":2}}],[\"atomically\",{\"1\":{\"1359\":1}}],[\"atomicintegefieldupdater\",{\"1\":{\"1388\":1}}],[\"atomicintegerfieldupdater\",{\"1\":{\"1388\":4}}],[\"atomicintegerarray\",{\"1\":{\"1386\":6}}],[\"atomicinteger\",{\"1\":{\"1306\":3,\"1350\":2,\"1351\":1,\"1352\":1,\"1385\":14,\"1386\":4}}],[\"atomicity\",{\"1\":{\"955\":2}}],[\"atomic\",{\"0\":{\"1379\":1},\"1\":{\"1220\":1,\"1380\":2,\"1381\":1,\"1385\":3,\"1386\":1,\"1387\":1,\"1388\":1,\"1438\":1,\"1439\":2,\"1491\":1}}],[\"atoi\",{\"1\":{\"251\":3}}],[\"at\",{\"1\":{\"592\":1,\"1221\":4,\"1259\":6,\"1283\":1,\"1284\":1,\"1286\":1,\"1306\":2,\"1314\":1,\"1315\":1,\"1316\":1,\"1317\":2,\"1340\":2,\"1351\":1}}],[\"actual\",{\"1\":{\"1275\":1,\"1506\":1}}],[\"active\",{\"1\":{\"663\":1}}],[\"activekey=\",{\"1\":{\"587\":1}}],[\"actionref=\",{\"1\":{\"592\":1}}],[\"actionref\",{\"1\":{\"592\":2}}],[\"actiongroup\",{\"1\":{\"592\":1}}],[\"action\",{\"1\":{\"592\":3,\"1102\":1,\"1408\":1}}],[\"actiontype\",{\"1\":{\"592\":1}}],[\"acquiring\",{\"1\":{\"1244\":2}}],[\"acquireinterruptibly\",{\"0\":{\"1507\":1},\"1\":{\"1496\":1,\"1500\":2,\"1507\":2}}],[\"acquirequeued\",{\"1\":{\"1251\":3,\"1495\":1,\"1503\":3,\"1504\":3,\"1505\":2}}],[\"acquired\",{\"1\":{\"1244\":1}}],[\"acquire\",{\"0\":{\"1503\":1},\"1\":{\"1239\":2,\"1398\":4,\"1495\":3,\"1496\":1,\"1500\":2,\"1503\":3,\"1505\":2,\"1507\":1}}],[\"acquiresharedinterruptibly\",{\"0\":{\"1512\":1},\"1\":{\"1500\":2}}],[\"acquireshared\",{\"0\":{\"1510\":1},\"1\":{\"1500\":2,\"1510\":2}}],[\"acquires\",{\"1\":{\"1232\":3,\"1233\":3,\"1239\":4,\"1242\":1,\"1495\":2,\"1496\":3,\"1511\":1}}],[\"acwing\",{\"1\":{\"1113\":1}}],[\"acs\",{\"1\":{\"1107\":6,\"1116\":5,\"1119\":2}}],[\"ac\",{\"1\":{\"1107\":2}}],[\"acid\",{\"1\":{\"955\":1}}],[\"ace\",{\"1\":{\"838\":1}}],[\"acceptencoding\",{\"1\":{\"1184\":1}}],[\"accept\",{\"1\":{\"1184\":1}}],[\"accessible\",{\"1\":{\"1293\":1}}],[\"accessid\",{\"1\":{\"1147\":1}}],[\"accessed\",{\"1\":{\"1292\":1}}],[\"accesskey\",{\"1\":{\"1100\":2}}],[\"accessdeniedexception\",{\"1\":{\"465\":1}}],[\"access\",{\"1\":{\"446\":1,\"592\":3,\"1346\":1}}],[\"account\",{\"1\":{\"46\":2,\"88\":9,\"587\":3,\"1094\":1}}],[\"a>\",{\"1\":{\"549\":1,\"588\":1,\"592\":2}}],[\"a>b\",{\"1\":{\"309\":1}}],[\"aop\",{\"1\":{\"471\":1,\"599\":1}}],[\"aop切面\",{\"1\":{\"471\":1}}],[\"avoid\",{\"1\":{\"1242\":1,\"1317\":1}}],[\"availablepermits\",{\"1\":{\"1398\":1}}],[\"availableprocessors\",{\"1\":{\"1361\":1}}],[\"available\",{\"1\":{\"1194\":1}}],[\"avail\",{\"1\":{\"1194\":1}}],[\"avatardropdown\",{\"1\":{\"596\":1}}],[\"avatar\",{\"1\":{\"471\":2,\"566\":2,\"589\":1,\"592\":2}}],[\"avg\",{\"1\":{\"932\":2}}],[\"average\",{\"1\":{\"41\":2}}],[\"ajaxresult\",{\"1\":{\"481\":1,\"482\":1}}],[\"ajax\",{\"1\":{\"448\":1,\"585\":2}}],[\"aj​\",{\"1\":{\"261\":1}}],[\"awaitsignal\",{\"1\":{\"1254\":1}}],[\"awaitthread\",{\"1\":{\"1253\":5}}],[\"awaituninterruptibly\",{\"1\":{\"1251\":2}}],[\"awaituntil\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"awaitutil\",{\"1\":{\"1251\":1}}],[\"awaitnanos\",{\"1\":{\"1248\":1,\"1251\":1,\"1410\":1}}],[\"await\",{\"0\":{\"1247\":1,\"1251\":1,\"1253\":1,\"1410\":1},\"1\":{\"587\":2,\"589\":2,\"591\":2,\"592\":2,\"1248\":3,\"1250\":4,\"1251\":17,\"1252\":3,\"1253\":4,\"1254\":2,\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1392\":9,\"1393\":4,\"1394\":1,\"1402\":1,\"1410\":6}}],[\"aws\",{\"1\":{\"438\":1,\"1095\":2,\"1102\":2}}],[\"aw​\",{\"1\":{\"141\":1}}],[\"a−2\",{\"1\":{\"389\":2}}],[\"a−1\",{\"1\":{\"389\":2}}],[\"a−b+1\",{\"1\":{\"389\":2}}],[\"a−b−1\",{\"1\":{\"389\":1}}],[\"a−b\",{\"1\":{\"388\":2,\"389\":3}}],[\"a1\",{\"1\":{\"384\":6,\"394\":1}}],[\"a1​\",{\"1\":{\"103\":1,\"141\":1,\"146\":1,\"168\":1,\"173\":2,\"202\":1,\"261\":1,\"262\":2,\"384\":1}}],[\"ak\",{\"1\":{\"381\":1}}],[\"a2\",{\"1\":{\"384\":5,\"394\":1}}],[\"a2logk\",{\"1\":{\"381\":2}}],[\"a22\",{\"1\":{\"381\":2}}],[\"a21\",{\"1\":{\"381\":2}}],[\"a20\",{\"1\":{\"381\":2}}],[\"a2​\",{\"1\":{\"103\":1,\"141\":1,\"146\":1,\"168\":1,\"173\":2,\"202\":1,\"261\":1,\"262\":2,\"384\":1}}],[\"a表示出点\",{\"1\":{\"354\":1}}],[\"a的这一位数\",{\"1\":{\"328\":1}}],[\"a长度不等于b\",{\"1\":{\"328\":1}}],[\"a||b\",{\"1\":{\"309\":1}}],[\"a是几\",{\"1\":{\"291\":1}}],[\"a不变\",{\"1\":{\"291\":1}}],[\"a和\",{\"1\":{\"273\":1}}],[\"axios\",{\"1\":{\"448\":1,\"585\":1}}],[\"ax​\",{\"1\":{\"407\":1}}],[\"ax​≥ay​\",{\"1\":{\"407\":1}}],[\"ax\",{\"1\":{\"248\":2,\"383\":2}}],[\"ax+by=1\",{\"1\":{\"383\":1}}],[\"ax+by=a\",{\"1\":{\"383\":1}}],[\"ax+by=gcd\",{\"1\":{\"383\":2}}],[\"ax+by\",{\"1\":{\"248\":1,\"383\":1}}],[\"a∗\",{\"1\":{\"210\":1,\"215\":5,\"216\":5,\"389\":2}}],[\"a∗b∗c∗d\",{\"1\":{\"156\":2}}],[\"aabab\",{\"1\":{\"202\":1}}],[\"aaabbbcccddd\",{\"1\":{\"82\":3}}],[\"alarms\",{\"1\":{\"1359\":1}}],[\"always\",{\"1\":{\"1283\":1,\"1305\":1}}],[\"also\",{\"1\":{\"1283\":1,\"1293\":1,\"1316\":1,\"1511\":1}}],[\"already\",{\"1\":{\"1239\":1,\"1274\":1,\"1505\":1}}],[\"alive\",{\"1\":{\"1340\":5}}],[\"align\",{\"1\":{\"549\":1}}],[\"alice\",{\"1\":{\"129\":1,\"1069\":1}}],[\"alter\",{\"1\":{\"922\":6,\"937\":1}}],[\"alt+enter\",{\"1\":{\"576\":1}}],[\"alt=\",{\"1\":{\"543\":1,\"587\":1}}],[\"alt\",{\"1\":{\"539\":1,\"543\":1}}],[\"allargsconstructor\",{\"1\":{\"935\":1}}],[\"all\",{\"1\":{\"663\":1,\"1074\":2,\"1283\":1,\"1315\":1,\"1316\":1,\"1317\":1,\"1319\":1,\"1346\":1,\"1351\":3,\"1496\":1}}],[\"allows\",{\"1\":{\"1239\":1}}],[\"allow\",{\"1\":{\"543\":1,\"1102\":1,\"1243\":1}}],[\"allocator>\",{\"1\":{\"200\":3}}],[\"alls\",{\"1\":{\"341\":9}}],[\"algorithm\",{\"1\":{\"324\":1,\"1316\":1,\"1346\":1}}],[\"a3​≥a5​\",{\"1\":{\"407\":1}}],[\"a3​\",{\"1\":{\"202\":1,\"407\":1}}],[\"a3​=2\",{\"1\":{\"193\":1}}],[\"a3b3c3d3\",{\"1\":{\"82\":3}}],[\"ashift\",{\"1\":{\"1268\":3}}],[\"as\",{\"1\":{\"587\":1,\"930\":2,\"944\":2,\"1275\":10,\"1293\":1,\"1305\":1,\"1306\":3,\"1314\":3,\"1359\":1,\"1418\":6,\"1420\":5}}],[\"async\",{\"1\":{\"587\":2,\"589\":2,\"591\":2,\"592\":3,\"596\":1}}],[\"associated\",{\"1\":{\"1305\":1,\"1317\":1}}],[\"assert\",{\"1\":{\"1243\":1,\"1347\":2,\"1348\":2,\"1496\":2}}],[\"assertequals\",{\"1\":{\"568\":7}}],[\"assertions\",{\"1\":{\"567\":1,\"568\":7}}],[\"asserttrue\",{\"1\":{\"567\":2}}],[\"assets\",{\"1\":{\"543\":3}}],[\"assign\",{\"0\":{\"254\":1},\"1\":{\"254\":6,\"515\":2,\"1482\":2}}],[\"astro\",{\"1\":{\"534\":1}}],[\"astar\",{\"1\":{\"223\":2}}],[\"aspectj\",{\"1\":{\"471\":1}}],[\"asking\",{\"1\":{\"1505\":1}}],[\"ask\",{\"1\":{\"309\":3,\"1242\":1}}],[\"asm\",{\"1\":{\"246\":1}}],[\"ascii码\",{\"0\":{\"1004\":1}}],[\"asc\",{\"1\":{\"181\":1,\"934\":1}}],[\"aside\",{\"1\":{\"28\":1,\"48\":1}}],[\"a≤b≤c\",{\"1\":{\"167\":1}}],[\"a×b×c\",{\"1\":{\"167\":2}}],[\"ai+1​\",{\"1\":{\"261\":1}}],[\"ai\",{\"1\":{\"146\":4,\"196\":2,\"206\":4,\"1095\":1}}],[\"ai​+1\",{\"1\":{\"178\":2}}],[\"ai​−1\",{\"1\":{\"178\":2}}],[\"ai​≥0\",{\"1\":{\"147\":1}}],[\"ai​=ai​−1\",{\"1\":{\"122\":1}}],[\"ai​=bi​\",{\"1\":{\"103\":1}}],[\"ai​\",{\"1\":{\"78\":2,\"103\":1,\"122\":2,\"141\":1,\"146\":1,\"147\":1,\"162\":2,\"178\":3,\"193\":3,\"199\":1,\"202\":1,\"205\":3,\"261\":2,\"384\":1,\"874\":2}}],[\"a=\",{\"1\":{\"146\":1}}],[\"apk\",{\"1\":{\"665\":1}}],[\"apparently\",{\"1\":{\"1242\":1,\"1506\":1}}],[\"apps\",{\"1\":{\"1184\":1}}],[\"applying\",{\"1\":{\"1170\":1}}],[\"applicationinfomanager\",{\"1\":{\"1153\":3,\"1155\":1,\"1157\":1,\"1162\":1,\"1163\":1,\"1175\":3,\"1178\":1,\"1180\":2,\"1182\":1}}],[\"applicationeventpublisher\",{\"1\":{\"1140\":1}}],[\"applicationcontext\",{\"0\":{\"1140\":1},\"1\":{\"1140\":4}}],[\"application\",{\"1\":{\"542\":1,\"543\":1,\"575\":2,\"576\":1,\"1100\":1,\"1153\":1,\"1175\":1,\"1184\":1}}],[\"app\",{\"1\":{\"537\":2,\"538\":4,\"540\":3,\"542\":3,\"543\":5,\"548\":1,\"587\":1,\"591\":1}}],[\"append\",{\"1\":{\"82\":4,\"98\":2,\"128\":2,\"157\":2,\"161\":2,\"1007\":1,\"1018\":1,\"1068\":1,\"1070\":1}}],[\"apache\",{\"1\":{\"434\":2,\"568\":4,\"618\":1,\"640\":1,\"1093\":1}}],[\"ap−1≡1\",{\"1\":{\"388\":1}}],[\"api\",{\"0\":{\"479\":1,\"1101\":1,\"1493\":1},\"1\":{\"46\":3,\"446\":1,\"448\":1,\"453\":1,\"459\":1,\"479\":1,\"520\":1,\"543\":1,\"576\":3,\"586\":2,\"587\":2,\"589\":9,\"591\":1,\"592\":1,\"596\":2,\"634\":2,\"668\":1,\"1066\":1,\"1094\":2,\"1095\":2,\"1100\":1,\"1325\":1,\"1385\":1},\"2\":{\"1085\":1}}],[\"area\",{\"1\":{\"1418\":1}}],[\"are\",{\"1\":{\"1149\":1,\"1191\":4,\"1243\":1,\"1275\":1,\"1283\":1,\"1315\":2,\"1317\":1,\"1351\":2,\"1359\":3,\"1511\":2}}],[\"archaius1utils\",{\"1\":{\"1157\":1,\"1178\":1}}],[\"archaius\",{\"1\":{\"1149\":1}}],[\"arn\",{\"1\":{\"1102\":1}}],[\"arg\",{\"1\":{\"1495\":4,\"1500\":8,\"1503\":3,\"1504\":3,\"1506\":2,\"1507\":5,\"1508\":5,\"1510\":6,\"1511\":2}}],[\"arguments>\",{\"1\":{\"1090\":1}}],[\"args\",{\"1\":{\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":1,\"104\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"157\":1,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":1,\"978\":1,\"980\":3,\"981\":2,\"982\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":4,\"989\":1,\"990\":4,\"992\":1,\"993\":1,\"994\":2,\"997\":1,\"998\":1,\"999\":4,\"1000\":2,\"1001\":1,\"1004\":2,\"1006\":1,\"1011\":1,\"1014\":1,\"1015\":1,\"1017\":1,\"1018\":1,\"1020\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1029\":1,\"1034\":1,\"1047\":1,\"1048\":1,\"1049\":1,\"1055\":1,\"1059\":2,\"1061\":1,\"1062\":2,\"1063\":1,\"1175\":1,\"1211\":1,\"1221\":1,\"1250\":1,\"1254\":1,\"1260\":1,\"1284\":1,\"1309\":1,\"1330\":1,\"1336\":1,\"1337\":1,\"1340\":1,\"1385\":1,\"1386\":1,\"1387\":1,\"1388\":1,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":1,\"1406\":2,\"1407\":2,\"1409\":1,\"1410\":1,\"1411\":1,\"1429\":1,\"1431\":1,\"1449\":1,\"1458\":1,\"1467\":1,\"1482\":1,\"1496\":1}}],[\"arithmeticexception\",{\"1\":{\"1045\":1,\"1047\":1}}],[\"article\",{\"0\":{\"1526\":1},\"1\":{\"576\":1,\"1140\":1,\"1171\":1}}],[\"artifactid>\",{\"1\":{\"568\":1,\"1099\":1,\"1203\":1,\"1206\":1,\"1209\":1}}],[\"artifact\",{\"1\":{\"568\":1}}],[\"arr2\",{\"1\":{\"1067\":1}}],[\"arr1\",{\"1\":{\"1067\":1}}],[\"arr\",{\"1\":{\"174\":17,\"178\":1,\"179\":1,\"302\":7,\"427\":7,\"428\":9,\"1067\":5,\"1069\":2,\"1081\":1}}],[\"arrayblockingqueue<integer>\",{\"1\":{\"1326\":2}}],[\"arrayblockingqueue\",{\"0\":{\"1343\":1,\"1344\":1,\"1345\":1,\"1346\":1,\"1353\":1},\"1\":{\"1326\":13,\"1344\":1,\"1345\":1,\"1346\":3,\"1348\":1,\"1350\":1,\"1351\":1,\"1353\":3,\"1359\":1}}],[\"array=\",{\"1\":{\"1122\":1,\"1123\":1,\"1124\":1,\"1125\":1}}],[\"arraydeque是deque的一个实现类\",{\"1\":{\"1075\":1}}],[\"arraydeque\",{\"1\":{\"1075\":2}}],[\"arraydeque<>\",{\"1\":{\"845\":1,\"1075\":1}}],[\"arraylist<e>\",{\"1\":{\"1072\":1}}],[\"arraylist<>\",{\"1\":{\"70\":1,\"578\":1,\"736\":1,\"737\":2,\"743\":2,\"852\":1,\"870\":2,\"1036\":1,\"1072\":2,\"1073\":1}}],[\"arraylist\",{\"1\":{\"1072\":2,\"1280\":4,\"1290\":4,\"1407\":2}}],[\"array\",{\"1\":{\"1047\":4,\"1072\":2,\"1122\":4,\"1123\":5,\"1124\":4,\"1125\":4,\"1292\":2,\"1293\":2,\"1295\":1}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"1045\":1,\"1047\":1}}],[\"arraystoreexception\",{\"1\":{\"1045\":1}}],[\"arrays\",{\"1\":{\"128\":1,\"152\":1,\"162\":2,\"772\":1,\"795\":1,\"796\":1,\"797\":1,\"827\":1,\"845\":1,\"893\":1,\"894\":2,\"1002\":5,\"1004\":2,\"1014\":2,\"1018\":2,\"1294\":1,\"1295\":1,\"1476\":6}}],[\"another\",{\"1\":{\"1242\":1,\"1244\":1,\"1283\":1}}],[\"anonymous\",{\"1\":{\"446\":1,\"468\":2}}],[\"anticipation\",{\"1\":{\"1506\":1}}],[\"antdregistry>\",{\"1\":{\"540\":1,\"548\":1}}],[\"antdregistry\",{\"1\":{\"540\":1}}],[\"antd\",{\"1\":{\"540\":1,\"592\":1}}],[\"antgroup\",{\"1\":{\"540\":1}}],[\"ant\",{\"1\":{\"499\":1,\"540\":12,\"548\":1,\"557\":1,\"559\":3,\"585\":1,\"587\":1,\"592\":4}}],[\"antmatchers\",{\"1\":{\"446\":4}}],[\"annotation\",{\"1\":{\"446\":7,\"471\":1,\"1051\":1}}],[\"any>>\",{\"1\":{\"596\":1}}],[\"anyrequest\",{\"1\":{\"446\":2}}],[\"any\",{\"1\":{\"422\":1,\"589\":1,\"596\":1,\"1315\":1,\"1316\":2,\"1317\":2,\"1346\":1}}],[\"an\",{\"1\":{\"181\":2,\"394\":1,\"1170\":1,\"1275\":2,\"1283\":1}}],[\"an​\",{\"1\":{\"173\":2,\"199\":1,\"202\":1,\"261\":1,\"262\":2,\"384\":1}}],[\"answer\",{\"1\":{\"512\":1,\"517\":1,\"525\":1}}],[\"ans用来标记是否找到出口\",{\"1\":{\"235\":1}}],[\"ans++\",{\"1\":{\"121\":1,\"291\":1,\"427\":1}}],[\"ans\",{\"1\":{\"71\":4,\"120\":3,\"121\":5,\"122\":3,\"174\":6,\"235\":4,\"291\":2,\"301\":4,\"302\":4,\"309\":13,\"323\":3,\"427\":2,\"431\":4,\"710\":4,\"736\":8,\"743\":3,\"761\":4,\"845\":4,\"846\":4,\"851\":4,\"857\":4,\"882\":4,\"894\":6}}],[\"android\",{\"1\":{\"665\":1}}],[\"andy\",{\"1\":{\"181\":2}}],[\"and\",{\"1\":{\"30\":6,\"56\":3,\"446\":4,\"471\":3,\"931\":2,\"1191\":1,\"1239\":3,\"1242\":1,\"1243\":1,\"1244\":1,\"1252\":2,\"1272\":1,\"1275\":2,\"1283\":1,\"1315\":1,\"1316\":2,\"1351\":1,\"1359\":4,\"1382\":1,\"1408\":1,\"1436\":1,\"1505\":1}}],[\"abortpolicy\",{\"1\":{\"1359\":1}}],[\"above\",{\"1\":{\"1221\":1,\"1317\":1}}],[\"aba\",{\"1\":{\"1384\":1,\"1439\":2}}],[\"abase\",{\"1\":{\"1268\":3}}],[\"abaab\",{\"1\":{\"202\":1}}],[\"abnormal\",{\"1\":{\"671\":1}}],[\"ab=a2x1​×a2x2​×\",{\"1\":{\"381\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"1493\":2,\"1496\":1}}],[\"abstractquartzjob\",{\"1\":{\"477\":1}}],[\"abstractjersey2eurekahttpclient\",{\"1\":{\"1185\":1}}],[\"abstractjerseyeurekahttpclient\",{\"1\":{\"1184\":1}}],[\"abstractinstanceregistry\",{\"1\":{\"1160\":1}}],[\"abstractconfiguration\",{\"1\":{\"1145\":2}}],[\"absolute\",{\"1\":{\"549\":1}}],[\"abs\",{\"1\":{\"108\":1,\"218\":2,\"219\":2,\"220\":2,\"224\":2,\"384\":2,\"385\":3,\"1080\":1}}],[\"abcde\",{\"1\":{\"838\":2}}],[\"abcdef\",{\"1\":{\"88\":2}}],[\"abcd2f\",{\"1\":{\"88\":1}}],[\"abc\",{\"1\":{\"88\":1,\"1110\":1,\"1122\":1,\"1123\":1,\"1124\":1,\"1125\":1}}],[\"abbbb\",{\"1\":{\"202\":1}}],[\"abbba\",{\"1\":{\"71\":1}}],[\"abbbab\",{\"1\":{\"71\":1}}],[\"abbb\",{\"1\":{\"71\":1}}],[\"abb\",{\"1\":{\"71\":1,\"202\":1}}],[\"ab\",{\"1\":{\"71\":2,\"202\":1,\"381\":1}}],[\"adapted\",{\"1\":{\"1275\":1}}],[\"advance\",{\"1\":{\"1274\":10}}],[\"adj\",{\"1\":{\"255\":1}}],[\"addwaiter\",{\"1\":{\"1495\":1,\"1503\":3,\"1504\":3,\"1506\":1,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"addwork\",{\"1\":{\"1371\":1}}],[\"addworker\",{\"1\":{\"1359\":4,\"1370\":4}}],[\"addandget\",{\"1\":{\"1385\":1,\"1386\":1}}],[\"addall\",{\"1\":{\"1081\":1}}],[\"added\",{\"1\":{\"1359\":1,\"1511\":1}}],[\"addlast\",{\"1\":{\"1326\":1}}],[\"additionally\",{\"1\":{\"1511\":1}}],[\"additional\",{\"1\":{\"1315\":1}}],[\"adding\",{\"1\":{\"1272\":1}}],[\"addcount\",{\"1\":{\"1272\":1,\"1275\":3}}],[\"addconditionwaiter\",{\"1\":{\"1251\":4}}],[\"address\",{\"1\":{\"1087\":3,\"1088\":1,\"1089\":1}}],[\"addressing\",{\"1\":{\"971\":1,\"1306\":1}}],[\"addtwonumbers\",{\"1\":{\"700\":1}}],[\"addquestionbankquestion\",{\"1\":{\"526\":1}}],[\"addfilterbefore\",{\"1\":{\"446\":3}}],[\"add\",{\"0\":{\"1294\":1},\"1\":{\"70\":1,\"88\":1,\"121\":2,\"129\":7,\"157\":1,\"223\":3,\"327\":2,\"345\":3,\"353\":1,\"355\":1,\"403\":1,\"457\":2,\"467\":2,\"526\":3,\"559\":1,\"576\":1,\"663\":2,\"672\":1,\"736\":1,\"737\":1,\"743\":2,\"749\":3,\"789\":2,\"852\":1,\"870\":2,\"875\":1,\"876\":1,\"922\":2,\"937\":1,\"1036\":1,\"1038\":1,\"1039\":1,\"1055\":2,\"1072\":2,\"1073\":1,\"1076\":1,\"1292\":1,\"1294\":3,\"1295\":1,\"1325\":1,\"1326\":1,\"1346\":1,\"1359\":2,\"1370\":1,\"1407\":2,\"1409\":1,\"1410\":1}}],[\"admin\",{\"0\":{\"26\":1,\"50\":1},\"1\":{\"46\":2,\"50\":1,\"447\":1,\"450\":1,\"455\":1,\"457\":1,\"458\":1,\"461\":1,\"467\":3,\"510\":1,\"525\":1,\"526\":1,\"578\":1,\"580\":1,\"592\":5}}],[\"a\",{\"0\":{\"209\":1,\"215\":1,\"247\":1},\"1\":{\"65\":2,\"71\":6,\"83\":8,\"88\":1,\"92\":10,\"103\":2,\"104\":20,\"109\":1,\"119\":5,\"122\":6,\"128\":1,\"135\":2,\"140\":2,\"141\":2,\"146\":7,\"152\":1,\"156\":3,\"162\":2,\"166\":4,\"167\":26,\"173\":1,\"174\":4,\"178\":2,\"179\":2,\"194\":3,\"197\":4,\"200\":5,\"202\":1,\"203\":2,\"206\":3,\"210\":1,\"215\":1,\"221\":7,\"223\":9,\"224\":1,\"242\":1,\"245\":1,\"247\":2,\"248\":3,\"254\":2,\"256\":11,\"257\":1,\"273\":3,\"279\":6,\"291\":19,\"298\":4,\"301\":5,\"302\":10,\"303\":6,\"304\":8,\"305\":3,\"306\":10,\"307\":3,\"309\":8,\"314\":3,\"317\":7,\"318\":12,\"321\":1,\"322\":2,\"324\":13,\"327\":15,\"328\":27,\"329\":17,\"330\":15,\"332\":5,\"338\":17,\"345\":13,\"352\":9,\"353\":3,\"354\":9,\"355\":3,\"358\":1,\"360\":5,\"361\":8,\"372\":13,\"376\":2,\"377\":6,\"381\":5,\"383\":15,\"384\":6,\"385\":17,\"387\":2,\"388\":13,\"389\":22,\"390\":10,\"403\":2,\"412\":2,\"415\":2,\"416\":3,\"417\":4,\"423\":29,\"647\":1,\"682\":9,\"789\":2,\"803\":2,\"808\":2,\"876\":1,\"942\":1,\"943\":1,\"978\":4,\"979\":23,\"980\":8,\"984\":38,\"985\":5,\"988\":4,\"990\":4,\"997\":1,\"998\":2,\"999\":18,\"1000\":4,\"1001\":2,\"1002\":1,\"1004\":10,\"1005\":3,\"1014\":2,\"1018\":9,\"1020\":11,\"1021\":3,\"1022\":6,\"1055\":2,\"1069\":4,\"1072\":2,\"1080\":10,\"1081\":1,\"1132\":7,\"1145\":2,\"1149\":1,\"1196\":1,\"1221\":14,\"1239\":2,\"1253\":1,\"1259\":2,\"1270\":1,\"1275\":10,\"1283\":6,\"1284\":5,\"1285\":4,\"1286\":1,\"1293\":2,\"1305\":1,\"1306\":4,\"1313\":1,\"1314\":2,\"1315\":3,\"1316\":1,\"1317\":1,\"1337\":2,\"1359\":5,\"1384\":5,\"1387\":3,\"1388\":1,\"1394\":1,\"1417\":5,\"1418\":6,\"1420\":6,\"1421\":13,\"1423\":1,\"1432\":10,\"1433\":8,\"1439\":4,\"1449\":1,\"1455\":8,\"1456\":6,\"1475\":11,\"1476\":2,\"1478\":4,\"1482\":12,\"1496\":1,\"1505\":2,\"1511\":2}}],[\"ahead\",{\"1\":{\"48\":1}}],[\"最熟悉的\",{\"1\":{\"1493\":1}}],[\"最新值为\",{\"1\":{\"1458\":1}}],[\"最新的\",{\"1\":{\"1283\":1}}],[\"最主要的问题是\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"最主要的功能是根据当前任务是否具有周期性\",{\"1\":{\"1368\":1}}],[\"最常用的方法是通过\",{\"1\":{\"1380\":1}}],[\"最常用的\",{\"1\":{\"1324\":1}}],[\"最常用的也应该是\",{\"1\":{\"1272\":1}}],[\"最常见的是\",{\"1\":{\"947\":1}}],[\"最上面的是\",{\"1\":{\"1190\":1}}],[\"最重要的是理解代码的执行顺序\",{\"1\":{\"1008\":1}}],[\"最重要的是配置直链\",{\"1\":{\"670\":1}}],[\"最简单的\",{\"1\":{\"1087\":1}}],[\"最简单的形式\",{\"1\":{\"948\":1}}],[\"最简单的合并就是像下面这样\",{\"1\":{\"271\":1}}],[\"最近\",{\"0\":{\"1196\":1}}],[\"最近公共祖先表示为一个节点\",{\"1\":{\"753\":1}}],[\"最近最少使用\",{\"1\":{\"686\":1}}],[\"最久未使用的关键字\",{\"1\":{\"686\":1}}],[\"最好使用\",{\"1\":{\"1309\":1}}],[\"最好封装一个对象来记录所有的请求参数\",{\"1\":{\"576\":1}}],[\"最好按照官方文档的指引来操作\",{\"1\":{\"539\":1}}],[\"最好做\",{\"1\":{\"506\":1}}],[\"最多有26个\",{\"1\":{\"412\":1}}],[\"最多可以吃掉多少斤草\",{\"1\":{\"193\":1}}],[\"最多可以操作\",{\"1\":{\"167\":1}}],[\"最坏情况下的时间复杂度为\",{\"1\":{\"377\":1}}],[\"最坏情况下\",{\"1\":{\"355\":1}}],[\"最坏情况为\",{\"1\":{\"351\":1}}],[\"最低位一定为\",{\"1\":{\"338\":1}}],[\"最短路问题\",{\"0\":{\"350\":1}}],[\"最短路径\",{\"1\":{\"237\":1}}],[\"最短hamilton路径\",{\"0\":{\"312\":1}}],[\"最短编辑距离\",{\"0\":{\"306\":1}}],[\"最少要选的硬币个数\",{\"1\":{\"893\":3}}],[\"最少要选的数字个数\",{\"1\":{\"795\":3,\"796\":1}}],[\"最少的硬币个数\",{\"1\":{\"892\":1}}],[\"最少需要付多少美元才能把这\",{\"1\":{\"290\":1}}],[\"最少执行多少次操作可以满足\",{\"1\":{\"122\":1}}],[\"最值元素的值\",{\"1\":{\"256\":1}}],[\"最值元素的地址\",{\"1\":{\"256\":1}}],[\"最小\",{\"1\":{\"1078\":1}}],[\"最小堆\",{\"1\":{\"789\":2}}],[\"最小的变最大的\",{\"1\":{\"705\":1}}],[\"最小的最大\",{\"1\":{\"323\":1}}],[\"最小生成树所有边的长度之和\",{\"1\":{\"360\":1}}],[\"最小生成树就是将\",{\"1\":{\"359\":1}}],[\"最小生成树问题\",{\"0\":{\"359\":1}}],[\"最小值\",{\"1\":{\"256\":2,\"410\":1,\"932\":1}}],[\"最小值下标\",{\"1\":{\"256\":2}}],[\"最小可用原则对外提供数据\",{\"1\":{\"25\":1}}],[\"最朴素的迷宫问题\",{\"1\":{\"235\":1}}],[\"最优\",{\"1\":{\"221\":1}}],[\"最佳实践\",{\"0\":{\"1320\":1},\"1\":{\"541\":1}}],[\"最佳优先搜索\",{\"0\":{\"214\":1}}],[\"最佳速通时间\",{\"0\":{\"146\":1}}],[\"最有访问顺序\",{\"1\":{\"166\":1}}],[\"最大缓存数\",{\"1\":{\"1204\":1,\"1207\":1}}],[\"最大重量为\",{\"1\":{\"772\":1}}],[\"最大深度\",{\"1\":{\"747\":1}}],[\"最大路径和\",{\"1\":{\"717\":1}}],[\"最大不相交区间数量\",{\"0\":{\"428\":1}}],[\"最大公约数与最小公倍数\",{\"0\":{\"377\":1}}],[\"最大匹配\",{\"1\":{\"363\":1}}],[\"最大价值是多少\",{\"1\":{\"296\":1,\"297\":1}}],[\"最大值\",{\"1\":{\"256\":2,\"748\":1,\"931\":1,\"932\":1}}],[\"最大值下标\",{\"1\":{\"256\":2}}],[\"最大值的数量超过\",{\"1\":{\"174\":1}}],[\"最大乘积\",{\"0\":{\"167\":1}}],[\"最大\",{\"1\":{\"152\":1,\"1078\":1}}],[\"最大的特色是能够周期性执行异步任务\",{\"1\":{\"1368\":1}}],[\"最大的问题就是在数据量大的情况下\",{\"1\":{\"958\":1}}],[\"最大的最小\",{\"1\":{\"323\":1}}],[\"最大的总价值\",{\"1\":{\"296\":1}}],[\"最大的乘积\",{\"0\":{\"156\":1}}],[\"最大的那个\",{\"1\":{\"152\":1}}],[\"最大的美观度\",{\"1\":{\"141\":1}}],[\"最大得分为5\",{\"1\":{\"71\":1}}],[\"最长不超过\",{\"1\":{\"1259\":1}}],[\"最长不会超过50\",{\"1\":{\"920\":1}}],[\"最长递增子序列\",{\"0\":{\"849\":1},\"1\":{\"849\":1}}],[\"最长有效括号\",{\"0\":{\"843\":1},\"1\":{\"843\":1}}],[\"最长公共上升子序列\",{\"0\":{\"304\":1}}],[\"最长公共子序列\",{\"0\":{\"303\":1,\"837\":1},\"1\":{\"837\":1}}],[\"最长上升子序列\",{\"0\":{\"302\":1}}],[\"最长上升子序列是一个序列中最长的严格单调递增的子序列\",{\"1\":{\"119\":1}}],[\"最长的严格单调递增子序列的长度\",{\"1\":{\"66\":1}}],[\"最终正确的结果为\",{\"1\":{\"1449\":1}}],[\"最终都应能掌握\",{\"1\":{\"1317\":1}}],[\"最终一致性的分析\",{\"1\":{\"1295\":1}}],[\"最终岛屿的数量就是并查集中连通分量的数目\",{\"1\":{\"822\":1}}],[\"最终岛屿的数量就是进行广度优先搜索的次数\",{\"1\":{\"821\":1}}],[\"最终岛屿的数量就是每次发现新岛屿的次数\",{\"1\":{\"820\":1}}],[\"最终呈现给用户\",{\"1\":{\"531\":1,\"533\":2}}],[\"最终将这些转换后的数字重新组合成一个新的整数\",{\"1\":{\"161\":1}}],[\"最终返回全选状态下的最大和最小优惠券数\",{\"1\":{\"109\":1}}],[\"最终\",{\"1\":{\"93\":1}}],[\"最终结果为\",{\"1\":{\"72\":1,\"126\":1,\"178\":1,\"380\":1}}],[\"最初最小生成树的边数为\",{\"1\":{\"361\":1}}],[\"最初所有的单元格是白色的\",{\"1\":{\"77\":1}}],[\"最初\",{\"1\":{\"72\":1,\"278\":1}}],[\"最后唤醒暂停的线程\",{\"1\":{\"1443\":1}}],[\"最后只能在\",{\"1\":{\"1317\":1}}],[\"最后使用\",{\"1\":{\"1317\":3}}],[\"最后用一个示意图来进行总结\",{\"1\":{\"1274\":1}}],[\"最后定义类\",{\"1\":{\"1026\":1}}],[\"最后遍历根节点\",{\"1\":{\"901\":1}}],[\"最后遍历右子树\",{\"1\":{\"900\":1}}],[\"最后遍历左子节点的右子树\",{\"1\":{\"729\":1}}],[\"最后构建左右子树\",{\"1\":{\"766\":1}}],[\"最后返回\",{\"1\":{\"783\":1,\"784\":1}}],[\"最后返回即可\",{\"1\":{\"737\":1}}],[\"最后返回上一层\",{\"1\":{\"731\":1}}],[\"最后返回c数组\",{\"1\":{\"327\":1,\"328\":1}}],[\"最后找到的节点处理完后\",{\"1\":{\"731\":1}}],[\"最后处理这个节点的右子树\",{\"1\":{\"730\":1}}],[\"最后访问右子树\",{\"1\":{\"729\":1}}],[\"最后点击确定\",{\"1\":{\"665\":1}}],[\"最后再说一下布隆过滤器中容量的计算\",{\"1\":{\"613\":1}}],[\"最后写一下校验\",{\"1\":{\"576\":1}}],[\"最后登录时间\",{\"1\":{\"566\":1}}],[\"最后在第7行代码中返回\",{\"1\":{\"1284\":1}}],[\"最后在\",{\"1\":{\"539\":1,\"672\":1}}],[\"最后修改配置文件启动项目即可\",{\"1\":{\"514\":1}}],[\"最后剩下的式子就满足我们的答案\",{\"1\":{\"384\":1}}],[\"最后剩下的就是区间\",{\"1\":{\"372\":1}}],[\"最后根据分界点分别递归左右两部分\",{\"1\":{\"317\":1}}],[\"最后一分钟的续约数量\",{\"1\":{\"1190\":1}}],[\"最后一个元素\",{\"1\":{\"1073\":1}}],[\"最后一个元素代表方法调用堆栈的栈底\",{\"1\":{\"1046\":1}}],[\"最后一个字段后面没有逗号\",{\"1\":{\"918\":1}}],[\"最后一个节点的isend置为true\",{\"1\":{\"803\":1}}],[\"最后一个访问到的一定是根\",{\"1\":{\"314\":1}}],[\"最后一层节点从左向右排列\",{\"1\":{\"417\":1}}],[\"最后一次出现的位置的\",{\"1\":{\"324\":1}}],[\"最后一行包含三个整数\",{\"1\":{\"223\":1}}],[\"最后一行\",{\"1\":{\"193\":1}}],[\"最后判断\",{\"1\":{\"291\":1}}],[\"最后到达这个格子的方案有多少种\",{\"1\":{\"196\":1}}],[\"最后按\",{\"1\":{\"181\":1}}],[\"最后将\",{\"1\":{\"1270\":1}}],[\"最后将整个图连通起来\",{\"1\":{\"360\":1}}],[\"最后将所有瓶子移动到目标位置的总距离\",{\"1\":{\"166\":1}}],[\"最后将遍历后的\",{\"1\":{\"108\":1}}],[\"最后累加所有成功分配的客人的消费金额\",{\"1\":{\"162\":1}}],[\"最后输出岛屿的最大面积\",{\"1\":{\"230\":1}}],[\"最后输出岛屿的数目\",{\"1\":{\"229\":1}}],[\"最后输出岛屿的数量\",{\"1\":{\"228\":1}}],[\"最后输出最大的价格\",{\"1\":{\"140\":1}}],[\"最后输出结果就为\",{\"1\":{\"82\":1}}],[\"最后的\",{\"1\":{\"109\":1}}],[\"最后\",{\"1\":{\"92\":1,\"110\":1,\"1190\":1,\"1201\":1}}],[\"最后计算总的方案数\",{\"1\":{\"87\":1}}],[\"最后要加上中间修改的山\",{\"1\":{\"66\":1}}],[\"最后交由\",{\"1\":{\"50\":1}}],[\"最后通过热点压测\",{\"1\":{\"33\":1}}],[\"最典型的案例就是缓存的更新\",{\"1\":{\"28\":1}}],[\"做晚饭后准备叫小明回家吃饭\",{\"1\":{\"1416\":1}}],[\"做一下总结\",{\"1\":{\"1506\":1}}],[\"做一个横向比较的话\",{\"1\":{\"1313\":1}}],[\"做一番理解\",{\"1\":{\"1304\":1}}],[\"做进一步处理\",{\"1\":{\"1307\":1}}],[\"做进一步封装\",{\"1\":{\"1272\":1}}],[\"做到平衡的\",{\"1\":{\"1272\":1}}],[\"做了这样的处理\",{\"1\":{\"1314\":1}}],[\"做了哪些事情呢\",{\"1\":{\"1270\":1}}],[\"做了很多的优化\",{\"1\":{\"1264\":1}}],[\"做了以下几件事\",{\"1\":{\"1182\":1}}],[\"做了什么\",{\"1\":{\"1149\":1}}],[\"做了一层封装\",{\"1\":{\"26\":1}}],[\"做好异常处理即可\",{\"1\":{\"526\":1}}],[\"做该\",{\"1\":{\"60\":1}}],[\"做主键\",{\"1\":{\"56\":2}}],[\"做架构上的补充\",{\"1\":{\"28\":1}}],[\"协程\",{\"1\":{\"1220\":1}}],[\"协同\",{\"1\":{\"28\":2}}],[\"协议的\",{\"1\":{\"1094\":1}}],[\"协议的文件传输协议\",{\"1\":{\"674\":1}}],[\"协议访问\",{\"1\":{\"674\":1}}],[\"协议链接\",{\"1\":{\"662\":1}}],[\"协议\",{\"1\":{\"14\":1,\"669\":1}}],[\"与独占式的区别在于同一时刻有多个线程获取同步状态\",{\"1\":{\"1500\":1}}],[\"与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量\",{\"1\":{\"1476\":1}}],[\"与按\",{\"1\":{\"1420\":1}}],[\"与tryacquire方法一致\",{\"1\":{\"1398\":1}}],[\"与之对应的就是用户线程\",{\"1\":{\"1340\":1}}],[\"与其他阻塞队列相比主要有以下不同的方法\",{\"1\":{\"1326\":1}}],[\"与其上\",{\"1\":{\"224\":1,\"279\":1}}],[\"与哈希表大小相与\",{\"1\":{\"1306\":1}}],[\"与期望的旧值\",{\"1\":{\"1266\":2}}],[\"与第一种的区别在于能够唤醒所有等待在\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"与第二种迷宫差不多\",{\"1\":{\"237\":1}}],[\"与此同时\",{\"1\":{\"1231\":1}}],[\"与我们应用息息相关\",{\"1\":{\"1140\":1}}],[\"与客户端渲染结合的技术\",{\"1\":{\"535\":1}}],[\"与服务端渲染不同\",{\"1\":{\"534\":1}}],[\"与模数\",{\"1\":{\"388\":1}}],[\"与一个各位都为零的数值相与\",{\"1\":{\"338\":1}}],[\"与快排不同\",{\"1\":{\"318\":1}}],[\"与min\",{\"1\":{\"256\":1}}],[\"与上一个方法一致\",{\"1\":{\"1398\":1}}],[\"与上面的await方法功能基本一致\",{\"1\":{\"1393\":1}}],[\"与上面的\",{\"1\":{\"1392\":1}}],[\"与上题一样\",{\"1\":{\"236\":1}}],[\"与上题类似\",{\"1\":{\"229\":1}}],[\"与上下左右方向数字交换的行动记录为\",{\"1\":{\"224\":1}}],[\"与点\",{\"1\":{\"223\":1}}],[\"与已经遍历过的节点\",{\"1\":{\"215\":1}}],[\"与括式字符串前一个字符组成一组\",{\"1\":{\"127\":2}}],[\"与评论主题的对应关系\",{\"1\":{\"56\":1}}],[\"与评论区\",{\"1\":{\"30\":1}}],[\"与推荐排序不同\",{\"1\":{\"40\":1}}],[\"与\",{\"0\":{\"251\":1,\"256\":1,\"439\":1,\"1042\":1,\"1063\":1,\"1130\":1,\"1253\":1,\"1275\":1,\"1353\":1,\"1394\":1,\"1424\":1,\"1490\":1},\"1\":{\"28\":2,\"35\":1,\"214\":1,\"256\":1,\"274\":2,\"337\":1,\"338\":5,\"387\":1,\"388\":1,\"445\":1,\"466\":2,\"705\":1,\"748\":1,\"808\":1,\"920\":1,\"933\":1,\"985\":1,\"1030\":1,\"1237\":3,\"1239\":1,\"1248\":2,\"1252\":1,\"1275\":2,\"1306\":1,\"1325\":1,\"1326\":4,\"1386\":1,\"1394\":1,\"1420\":1,\"1422\":1,\"1475\":1,\"1500\":1,\"1507\":1}}],[\"jmm在不改变正确语义的前提下\",{\"1\":{\"1457\":1}}],[\"jmm的设计图为\",{\"1\":{\"1423\":1}}],[\"jmm\",{\"0\":{\"1415\":1,\"1417\":1,\"1423\":1,\"1424\":1},\"1\":{\"1415\":1,\"1417\":3,\"1418\":2,\"1419\":1,\"1420\":7,\"1422\":4,\"1423\":13,\"1424\":1,\"1429\":1,\"1433\":1,\"1455\":1,\"1457\":4,\"1475\":2,\"1476\":2}}],[\"jit\",{\"1\":{\"1340\":1}}],[\"jps\",{\"1\":{\"1221\":1}}],[\"jpg\",{\"1\":{\"567\":1,\"1103\":9}}],[\"jre<\",{\"1\":{\"1203\":1}}],[\"jersey\",{\"1\":{\"1184\":1}}],[\"jersey2\",{\"1\":{\"1184\":1}}],[\"jetty\",{\"1\":{\"1171\":1}}],[\"jest\",{\"1\":{\"559\":2}}],[\"jndi\",{\"1\":{\"1131\":1}}],[\"jbods\",{\"1\":{\"1095\":1}}],[\"jvm\",{\"1\":{\"1042\":1,\"1068\":1,\"1330\":1,\"1339\":1,\"1384\":1,\"1439\":1,\"1440\":1,\"1444\":2,\"1446\":1,\"1454\":1,\"1482\":2}}],[\"j<i\",{\"1\":{\"851\":1}}],[\"j<i2\",{\"1\":{\"797\":1}}],[\"j>0\",{\"1\":{\"795\":1}}],[\"j≥i2\",{\"1\":{\"795\":1,\"797\":1}}],[\"jump\",{\"1\":{\"1283\":1}}],[\"juc\",{\"0\":{\"1546\":1},\"1\":{\"1411\":1},\"2\":{\"1229\":1,\"1235\":1,\"1246\":1,\"1256\":1,\"1262\":1,\"1278\":1,\"1288\":1,\"1297\":1,\"1311\":1,\"1322\":1,\"1328\":1,\"1342\":1,\"1355\":1,\"1363\":1,\"1373\":1,\"1378\":1,\"1390\":1,\"1396\":1,\"1401\":1,\"1413\":1,\"1427\":1,\"1451\":1,\"1460\":1,\"1480\":1,\"1489\":1,\"1498\":1,\"1514\":1}}],[\"just\",{\"1\":{\"1191\":1,\"1271\":1,\"1315\":1,\"1496\":1,\"1506\":1}}],[\"junit\",{\"1\":{\"557\":1}}],[\"juejin\",{\"1\":{\"41\":1}}],[\"jdbc\",{\"1\":{\"557\":1}}],[\"jdk6\",{\"1\":{\"1276\":1}}],[\"jdk1\",{\"1\":{\"1264\":1,\"1272\":1,\"1383\":1,\"1437\":1}}],[\"jdk17\",{\"1\":{\"634\":1}}],[\"jdk7\",{\"1\":{\"1049\":1}}],[\"jdk\",{\"1\":{\"502\":1,\"1264\":2,\"1324\":1,\"1472\":1}}],[\"jds\",{\"1\":{\"75\":1}}],[\"jsr\",{\"1\":{\"1420\":1}}],[\"jstack\",{\"1\":{\"1221\":1}}],[\"jsx\",{\"1\":{\"542\":1}}],[\"json串\",{\"1\":{\"1102\":1}}],[\"json\",{\"1\":{\"512\":2,\"517\":2,\"539\":2,\"559\":4,\"573\":1,\"576\":2,\"935\":1,\"1082\":1,\"1184\":2}}],[\"js\",{\"0\":{\"536\":1,\"541\":1},\"1\":{\"446\":1,\"448\":3,\"453\":3,\"457\":2,\"458\":1,\"459\":3,\"463\":1,\"493\":1,\"499\":1,\"502\":1,\"537\":5,\"538\":2,\"539\":2,\"540\":2,\"541\":1,\"542\":4,\"543\":3,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"559\":2,\"586\":1}}],[\"jwtauthenticationtokenfilter\",{\"1\":{\"446\":3}}],[\"jwt\",{\"1\":{\"445\":1}}],[\"j表示第几个区间\",{\"1\":{\"430\":1}}],[\"j表示走到哪一个点\",{\"1\":{\"312\":1}}],[\"j走到哪了呀\",{\"1\":{\"411\":1}}],[\"j−coins\",{\"1\":{\"893\":1}}],[\"j−i2\",{\"1\":{\"795\":2,\"796\":1,\"797\":1}}],[\"j−i\",{\"1\":{\"308\":1}}],[\"j−1\",{\"1\":{\"72\":1}}],[\"j≤103\",{\"1\":{\"196\":1}}],[\"j≤105\",{\"1\":{\"196\":1}}],[\"j​​\",{\"1\":{\"196\":1}}],[\"j​≤10000000\",{\"1\":{\"146\":1}}],[\"j​\",{\"1\":{\"146\":1,\"196\":3}}],[\"j^2\",{\"1\":{\"115\":1}}],[\"j2<=i\",{\"1\":{\"115\":1}}],[\"j2\",{\"1\":{\"115\":1}}],[\"j+1\",{\"1\":{\"72\":2,\"411\":1}}],[\"j++\",{\"1\":{\"70\":2,\"72\":1,\"77\":1,\"92\":3,\"108\":1,\"109\":1,\"115\":1,\"121\":1,\"126\":1,\"127\":2,\"141\":3,\"194\":1,\"197\":2,\"224\":1,\"228\":2,\"229\":3,\"230\":2,\"235\":2,\"236\":1,\"237\":1,\"263\":2,\"278\":1,\"296\":1,\"297\":2,\"298\":1,\"299\":2,\"301\":3,\"302\":1,\"303\":1,\"304\":1,\"305\":2,\"306\":2,\"309\":3,\"312\":2,\"318\":3,\"340\":1,\"358\":2,\"360\":2,\"373\":1,\"387\":1,\"392\":1,\"411\":2,\"430\":1,\"796\":1,\"797\":1,\"820\":1,\"821\":1,\"822\":2,\"840\":1,\"851\":1,\"870\":2,\"893\":1}}],[\"j\",{\"1\":{\"65\":6,\"70\":14,\"72\":16,\"77\":9,\"92\":5,\"108\":4,\"109\":13,\"115\":5,\"121\":4,\"126\":17,\"127\":44,\"141\":12,\"142\":9,\"146\":13,\"174\":7,\"194\":5,\"196\":1,\"197\":6,\"221\":1,\"223\":13,\"224\":3,\"228\":7,\"229\":12,\"230\":9,\"235\":7,\"236\":8,\"237\":5,\"261\":1,\"263\":16,\"271\":3,\"273\":2,\"274\":4,\"278\":3,\"296\":14,\"297\":13,\"298\":25,\"299\":22,\"301\":19,\"302\":6,\"303\":16,\"304\":9,\"305\":16,\"306\":27,\"307\":16,\"308\":28,\"309\":12,\"311\":18,\"312\":14,\"317\":14,\"318\":8,\"333\":1,\"340\":4,\"347\":3,\"348\":4,\"349\":3,\"352\":12,\"353\":5,\"354\":6,\"355\":6,\"356\":8,\"358\":10,\"360\":10,\"362\":4,\"363\":6,\"371\":4,\"372\":9,\"373\":15,\"380\":20,\"385\":10,\"387\":7,\"389\":4,\"390\":8,\"392\":5,\"411\":20,\"430\":5,\"772\":16,\"795\":22,\"796\":15,\"797\":11,\"820\":13,\"821\":7,\"822\":16,\"839\":4,\"840\":14,\"851\":14,\"852\":11,\"870\":16,\"893\":15,\"990\":4,\"994\":7,\"999\":6,\"1000\":4,\"1018\":5,\"1306\":3,\"1380\":1,\"1423\":1,\"1438\":1}}],[\"joshblochanddouglea\",{\"1\":{\"1306\":1,\"1314\":1}}],[\"jointhread\",{\"1\":{\"1337\":3}}],[\"joindemo\",{\"1\":{\"1337\":1}}],[\"join方法源码关键是\",{\"1\":{\"1337\":1}}],[\"join\",{\"0\":{\"1337\":1},\"1\":{\"50\":1,\"471\":2,\"525\":3,\"944\":1,\"945\":2,\"1060\":1,\"1061\":2,\"1062\":4,\"1069\":2,\"1334\":2,\"1337\":9,\"1392\":2,\"1421\":3}}],[\"joiner\",{\"1\":{\"50\":1}}],[\"jobservice\",{\"1\":{\"481\":1,\"482\":2}}],[\"jobbuilder\",{\"1\":{\"479\":1}}],[\"jobdetail\",{\"1\":{\"479\":1,\"484\":1,\"489\":1}}],[\"jobinvokeutil\",{\"1\":{\"477\":1}}],[\"job\",{\"0\":{\"28\":1},\"1\":{\"28\":2,\"40\":2,\"46\":2,\"48\":1,\"60\":1,\"476\":2,\"479\":1,\"481\":17,\"482\":4,\"484\":1}}],[\"java对象头\",{\"1\":{\"1434\":1}}],[\"javap\",{\"1\":{\"1431\":1}}],[\"java并发工具类\",{\"0\":{\"1391\":1,\"1397\":1}}],[\"java并发编程的艺术\",{\"1\":{\"1220\":1,\"1334\":1,\"1375\":1,\"1457\":1,\"1495\":1}}],[\"java8\",{\"1\":{\"1205\":1}}],[\"javabean\",{\"1\":{\"1133\":1}}],[\"javafx\",{\"0\":{\"1082\":1}}],[\"javadoc\",{\"1\":{\"1053\":1}}],[\"javaee\",{\"1\":{\"1051\":2}}],[\"javase\",{\"1\":{\"1051\":1,\"1440\":1}}],[\"javascript\",{\"1\":{\"531\":4,\"532\":13,\"533\":3,\"535\":2}}],[\"java到团队案例\",{\"1\":{\"626\":1,\"632\":1}}],[\"java方法设计原则与实践\",{\"1\":{\"626\":1,\"632\":1}}],[\"java中的\",{\"1\":{\"249\":1}}],[\"java\",{\"0\":{\"560\":1,\"976\":1,\"1080\":1,\"1081\":1,\"1199\":1,\"1227\":1,\"1414\":1,\"1440\":1,\"1534\":1},\"1\":{\"1\":1,\"70\":1,\"82\":1,\"83\":1,\"87\":1,\"88\":1,\"97\":1,\"98\":3,\"99\":1,\"103\":1,\"104\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":3,\"129\":2,\"152\":1,\"157\":2,\"161\":1,\"162\":1,\"178\":1,\"179\":1,\"180\":1,\"445\":1,\"500\":1,\"512\":1,\"517\":2,\"557\":3,\"560\":1,\"564\":1,\"568\":2,\"599\":1,\"981\":3,\"982\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":1,\"990\":1,\"992\":1,\"999\":3,\"1001\":1,\"1002\":1,\"1004\":2,\"1006\":1,\"1014\":1,\"1018\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1036\":3,\"1037\":1,\"1038\":3,\"1039\":4,\"1040\":4,\"1042\":1,\"1045\":2,\"1047\":1,\"1048\":2,\"1049\":2,\"1055\":8,\"1061\":1,\"1066\":1,\"1069\":1,\"1075\":2,\"1082\":1,\"1095\":2,\"1132\":1,\"1145\":3,\"1146\":1,\"1184\":1,\"1221\":13,\"1231\":1,\"1237\":2,\"1248\":3,\"1258\":1,\"1259\":12,\"1264\":2,\"1266\":1,\"1282\":1,\"1290\":2,\"1299\":2,\"1325\":1,\"1326\":2,\"1330\":3,\"1334\":2,\"1339\":1,\"1340\":5,\"1380\":1,\"1392\":1,\"1404\":1,\"1407\":1,\"1408\":1,\"1415\":1,\"1416\":1,\"1420\":3,\"1424\":2,\"1429\":2,\"1430\":1,\"1433\":2,\"1434\":1,\"1439\":2,\"1440\":2,\"1444\":2,\"1453\":3,\"1454\":1,\"1457\":1,\"1464\":1,\"1473\":3,\"1482\":3,\"1485\":2,\"1491\":1,\"1492\":2,\"1493\":1,\"1496\":1},\"2\":{\"974\":1,\"1064\":1,\"1084\":1}}],[\"专家模式\",{\"1\":{\"670\":1}}],[\"专门把动态网站转为静态\",{\"1\":{\"534\":1}}],[\"专注于获取释放的逻辑来实现自己想要表达的同步语义\",{\"1\":{\"1496\":1}}],[\"专注于评论功能的原子化实现\",{\"1\":{\"27\":1}}],[\"专注在评论数据处理\",{\"1\":{\"47\":1}}],[\"专注在评论功能的\",{\"1\":{\"46\":1}}],[\"专栏等内容\",{\"1\":{\"21\":1}}],[\"sdf\",{\"1\":{\"1309\":5}}],[\"sdk\",{\"1\":{\"51\":1,\"668\":1,\"1095\":7}}],[\"sz\",{\"1\":{\"1306\":3,\"1314\":3}}],[\"s后执行\",{\"1\":{\"1184\":1}}],[\"snail\",{\"1\":{\"1171\":1}}],[\"snprintf\",{\"1\":{\"251\":1}}],[\"s3\",{\"1\":{\"1093\":1,\"1095\":5,\"1102\":2}}],[\"small\",{\"1\":{\"984\":2}}],[\"smallint\",{\"1\":{\"920\":1}}],[\"s2\",{\"1\":{\"838\":1,\"839\":1,\"840\":7,\"1069\":1}}],[\"s1\",{\"1\":{\"838\":1,\"839\":1,\"840\":7,\"1069\":1}}],[\"safely\",{\"1\":{\"1505\":1}}],[\"safe\",{\"1\":{\"1191\":1}}],[\"safetyuser\",{\"1\":{\"575\":16}}],[\"sampleclient\",{\"1\":{\"1175\":1}}],[\"samza\",{\"1\":{\"434\":1}}],[\"saturated\",{\"1\":{\"1242\":1,\"1359\":1}}],[\"saturate\",{\"1\":{\"1239\":1}}],[\"saturday\",{\"1\":{\"986\":1}}],[\"satrt\",{\"1\":{\"1072\":1}}],[\"saas\",{\"1\":{\"634\":2}}],[\"salt\",{\"1\":{\"568\":2,\"575\":1}}],[\"savedstate\",{\"1\":{\"1251\":8}}],[\"save\",{\"1\":{\"526\":1,\"539\":3,\"540\":3,\"567\":1}}],[\"sa\",{\"1\":{\"493\":1,\"500\":1}}],[\"src=\",{\"1\":{\"543\":1,\"587\":1,\"592\":1}}],[\"src\",{\"1\":{\"458\":1,\"544\":1,\"548\":1,\"549\":2,\"559\":3,\"587\":1,\"591\":1,\"592\":1,\"1145\":1}}],[\"ssl\",{\"1\":{\"664\":1,\"672\":11}}],[\"sso\",{\"1\":{\"648\":1}}],[\"ssg\",{\"1\":{\"534\":2}}],[\"ssr\",{\"1\":{\"531\":1,\"533\":5,\"535\":1}}],[\"ss\",{\"1\":{\"451\":1,\"465\":3,\"467\":6,\"468\":1,\"481\":1,\"482\":1,\"920\":3,\"1069\":1,\"1309\":1}}],[\"sscanf\",{\"1\":{\"251\":2}}],[\"sscnaf\",{\"1\":{\"251\":1}}],[\"shift\",{\"1\":{\"1239\":2,\"1242\":1,\"1274\":1,\"1275\":2}}],[\"shut\",{\"1\":{\"1351\":1,\"1359\":2}}],[\"shutdownnow\",{\"1\":{\"1360\":4}}],[\"shutdown\",{\"1\":{\"1175\":2,\"1360\":5,\"1392\":1,\"1398\":1}}],[\"shuffle\",{\"1\":{\"423\":1}}],[\"shell脚本在逐行执行\",{\"1\":{\"1107\":1}}],[\"shell\",{\"0\":{\"1106\":1},\"1\":{\"1087\":1,\"1107\":7,\"1119\":1}}],[\"shtml\",{\"1\":{\"1086\":1}}],[\"shmin\",{\"1\":{\"1083\":1}}],[\"shmax\",{\"1\":{\"1083\":1}}],[\"shouldparkafterfailedacquire\",{\"1\":{\"1504\":1,\"1505\":6,\"1507\":1,\"1508\":1,\"1510\":1}}],[\"shouldn\",{\"1\":{\"1359\":1}}],[\"should\",{\"1\":{\"1242\":1,\"1275\":1,\"1359\":1}}],[\"shouldregisterwitheureka\",{\"1\":{\"1158\":1}}],[\"shouldfetchregistry\",{\"1\":{\"1158\":1}}],[\"show\",{\"1\":{\"912\":1,\"915\":1,\"921\":2,\"958\":1,\"959\":1}}],[\"shorturl\",{\"1\":{\"634\":1}}],[\"shortlink\",{\"1\":{\"634\":1}}],[\"short\",{\"1\":{\"60\":1,\"978\":1,\"1083\":2}}],[\"sharedobject\",{\"1\":{\"1408\":2}}],[\"sharedcount\",{\"1\":{\"1239\":1,\"1242\":1}}],[\"shared\",{\"1\":{\"672\":1,\"1239\":3,\"1242\":3,\"1243\":1,\"1510\":1}}],[\"share\",{\"1\":{\"672\":1}}],[\"shardingsphere\",{\"1\":{\"618\":1}}],[\"sh\",{\"1\":{\"537\":1,\"1107\":8,\"1119\":4}}],[\"s+1\",{\"1\":{\"411\":1}}],[\"s++\",{\"1\":{\"368\":1,\"392\":1}}],[\"s为模式串\",{\"1\":{\"411\":1}}],[\"sg\",{\"1\":{\"398\":5,\"399\":4}}],[\"sg游戏\",{\"0\":{\"398\":1}}],[\"s表示次幂\",{\"1\":{\"368\":1}}],[\"syncnized\",{\"1\":{\"1449\":1}}],[\"sync\",{\"1\":{\"1233\":2,\"1493\":2,\"1496\":15}}],[\"syncup\",{\"1\":{\"1167\":1}}],[\"synchronize\",{\"1\":{\"1492\":1}}],[\"synchronized了\",{\"1\":{\"1434\":1}}],[\"synchronized优化\",{\"0\":{\"1434\":1}}],[\"synchronizeddemo\",{\"1\":{\"1429\":2,\"1431\":5,\"1449\":3}}],[\"synchronizedlist\",{\"1\":{\"1280\":1}}],[\"synchronizedmap\",{\"1\":{\"1264\":2}}],[\"synchronized\",{\"0\":{\"1062\":1,\"1384\":1,\"1428\":1,\"1429\":1,\"1430\":1,\"1432\":1,\"1484\":1},\"1\":{\"1062\":4,\"1063\":1,\"1145\":1,\"1164\":1,\"1221\":4,\"1231\":2,\"1237\":1,\"1264\":5,\"1272\":2,\"1274\":1,\"1276\":1,\"1280\":2,\"1334\":2,\"1337\":2,\"1380\":2,\"1384\":1,\"1406\":5,\"1407\":4,\"1408\":1,\"1409\":2,\"1429\":2,\"1430\":3,\"1431\":5,\"1432\":3,\"1433\":2,\"1437\":2,\"1449\":1,\"1453\":2,\"1482\":3,\"1484\":3,\"1485\":1,\"1486\":1,\"1487\":1,\"1492\":4,\"1507\":1}}],[\"synchronousqueue\",{\"1\":{\"1326\":5,\"1359\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"1158\":2}}],[\"synchronzied\",{\"1\":{\"1264\":2,\"1272\":1,\"1290\":1}}],[\"synchronzedmap\",{\"1\":{\"1264\":1}}],[\"synchronzed\",{\"1\":{\"1259\":2,\"1299\":1,\"1486\":1}}],[\"synctourl\",{\"1\":{\"592\":1}}],[\"syslogd\",{\"1\":{\"671\":1}}],[\"sysloginservice\",{\"0\":{\"451\":1},\"1\":{\"451\":1}}],[\"syslogincontroller\",{\"0\":{\"450\":1,\"455\":1,\"461\":1},\"1\":{\"447\":1,\"450\":1,\"455\":1,\"458\":1,\"461\":1}}],[\"sysjob\",{\"1\":{\"481\":1,\"482\":2}}],[\"sysjobcontroller\",{\"1\":{\"481\":1,\"482\":1}}],[\"sysxxxx\",{\"1\":{\"468\":1}}],[\"sys\",{\"1\":{\"467\":1,\"471\":7,\"476\":2}}],[\"syspermissionservice\",{\"0\":{\"456\":1},\"1\":{\"456\":1}}],[\"systemd\",{\"1\":{\"671\":4}}],[\"systemctl\",{\"1\":{\"663\":2,\"671\":8}}],[\"system\",{\"0\":{\"1516\":1,\"1539\":1},\"1\":{\"82\":3,\"83\":2,\"87\":2,\"88\":5,\"97\":3,\"98\":2,\"99\":3,\"103\":2,\"104\":2,\"126\":2,\"127\":2,\"128\":2,\"129\":2,\"157\":2,\"161\":2,\"162\":2,\"178\":2,\"179\":2,\"180\":2,\"182\":3,\"249\":1,\"450\":1,\"455\":1,\"457\":3,\"461\":1,\"462\":2,\"467\":10,\"567\":1,\"587\":1,\"671\":1,\"980\":9,\"981\":3,\"982\":7,\"984\":39,\"985\":7,\"986\":2,\"988\":5,\"989\":2,\"990\":5,\"992\":3,\"993\":1,\"994\":3,\"999\":8,\"1000\":2,\"1001\":2,\"1004\":5,\"1005\":2,\"1006\":3,\"1007\":2,\"1011\":1,\"1014\":2,\"1015\":3,\"1017\":1,\"1018\":2,\"1020\":1,\"1021\":2,\"1022\":4,\"1023\":2,\"1029\":2,\"1033\":3,\"1034\":3,\"1047\":4,\"1048\":3,\"1049\":2,\"1055\":3,\"1059\":3,\"1061\":1,\"1062\":2,\"1063\":1,\"1069\":2,\"1102\":3,\"1103\":6,\"1177\":2,\"1190\":2,\"1201\":4,\"1204\":2,\"1207\":2,\"1211\":2,\"1221\":4,\"1254\":2,\"1260\":1,\"1284\":2,\"1309\":1,\"1330\":3,\"1336\":2,\"1337\":1,\"1340\":2,\"1385\":2,\"1386\":2,\"1387\":2,\"1388\":2,\"1392\":5,\"1393\":4,\"1398\":4,\"1399\":3,\"1406\":12,\"1407\":10,\"1409\":6,\"1410\":6,\"1411\":2,\"1429\":1,\"1449\":1,\"1467\":1,\"1482\":1,\"1508\":5}}],[\"sy\",{\"1\":{\"236\":4,\"237\":4}}],[\"sx\",{\"1\":{\"236\":4,\"237\":4}}],[\"sweep\",{\"1\":{\"1274\":1}}],[\"swtich\",{\"1\":{\"986\":1}}],[\"swagger\",{\"0\":{\"520\":1},\"1\":{\"446\":2,\"520\":1,\"559\":2}}],[\"swappairs\",{\"1\":{\"694\":2}}],[\"swap\",{\"1\":{\"224\":2,\"279\":2,\"309\":1,\"317\":1,\"338\":1,\"385\":1,\"417\":6,\"1020\":2,\"1317\":1,\"1382\":1,\"1436\":1}}],[\"switch\",{\"0\":{\"986\":1},\"1\":{\"129\":1,\"986\":1}}],[\"s→s\",{\"1\":{\"223\":1}}],[\"sqlexception\",{\"1\":{\"1044\":1}}],[\"sql语句\",{\"1\":{\"954\":1}}],[\"sql优化\",{\"1\":{\"910\":1}}],[\"sql拼接\",{\"1\":{\"471\":1}}],[\"sql\",{\"0\":{\"907\":1,\"908\":1},\"1\":{\"181\":1,\"471\":2,\"486\":1,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"525\":2,\"557\":1,\"567\":1,\"907\":1,\"908\":3,\"909\":1,\"942\":1,\"945\":1,\"947\":1,\"953\":4,\"954\":2,\"955\":1,\"1361\":1}}],[\"sqrt\",{\"1\":{\"97\":1,\"220\":1,\"367\":2,\"368\":5,\"795\":2,\"796\":1,\"1080\":1}}],[\"sleepthread\",{\"1\":{\"1336\":14}}],[\"sleepthread睡眠1000ms\",{\"1\":{\"1336\":1}}],[\"sleep\",{\"0\":{\"1338\":1},\"1\":{\"1059\":3,\"1060\":1,\"1063\":1,\"1201\":1,\"1204\":1,\"1207\":1,\"1211\":1,\"1221\":1,\"1260\":1,\"1334\":1,\"1336\":1,\"1338\":8,\"1339\":2,\"1340\":2,\"1398\":1,\"1399\":1,\"1406\":2,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1,\"1496\":1}}],[\"slottoexpung\",{\"1\":{\"1317\":1}}],[\"slottoexpunge\",{\"1\":{\"1317\":30}}],[\"slot\",{\"1\":{\"971\":1,\"1316\":4,\"1317\":4}}],[\"slownext\",{\"1\":{\"834\":2}}],[\"slow\",{\"1\":{\"134\":5,\"833\":4,\"834\":5}}],[\"slf4j\",{\"1\":{\"568\":1}}],[\"sla\",{\"1\":{\"25\":1}}],[\"sb\",{\"1\":{\"128\":3,\"157\":3,\"1007\":7,\"1018\":5,\"1070\":1}}],[\"speed\",{\"1\":{\"1319\":1}}],[\"specific\",{\"1\":{\"1149\":1}}],[\"specified\",{\"1\":{\"1149\":1}}],[\"spread\",{\"1\":{\"1272\":6,\"1273\":1}}],[\"spring所倡导的开发方式就是如此\",{\"1\":{\"1131\":1}}],[\"springcloud\",{\"1\":{\"634\":1},\"2\":{\"1174\":1,\"1188\":1,\"1198\":1}}],[\"springmvc\",{\"1\":{\"557\":1}}],[\"springboottest\",{\"1\":{\"1201\":1}}],[\"springboot3\",{\"1\":{\"634\":1}}],[\"springboot\",{\"0\":{\"1098\":1},\"1\":{\"488\":2,\"557\":1,\"560\":1,\"574\":1,\"639\":1,\"1100\":1}}],[\"springel表达式结果为true时可以访问\",{\"1\":{\"446\":1}}],[\"springframework\",{\"1\":{\"446\":15,\"526\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":1,\"1139\":1,\"1140\":3}}],[\"spring\",{\"0\":{\"1541\":1,\"1543\":1},\"1\":{\"445\":3,\"446\":3,\"465\":5,\"493\":1,\"500\":1,\"557\":2,\"560\":1,\"577\":1,\"599\":1,\"634\":1,\"639\":1,\"1129\":1,\"1131\":9,\"1132\":6,\"1136\":1,\"1138\":1,\"1139\":1,\"1140\":1,\"1141\":3},\"2\":{\"1143\":1}}],[\"springsecurity\",{\"0\":{\"445\":1,\"446\":1},\"1\":{\"447\":1}}],[\"sprintf\",{\"1\":{\"251\":3}}],[\"spinfortimeoutthreshold\",{\"1\":{\"1508\":1}}],[\"spinlock\",{\"1\":{\"1275\":1}}],[\"spin\",{\"1\":{\"1271\":1}}],[\"spark\",{\"1\":{\"434\":1,\"1095\":1}}],[\"spfa求最短路\",{\"1\":{\"355\":1}}],[\"spfa算法判断图中是否存在负环\",{\"0\":{\"356\":1}}],[\"spfa算法\",{\"0\":{\"355\":1}}],[\"spfa\",{\"1\":{\"351\":1,\"355\":1,\"356\":1}}],[\"spj\",{\"1\":{\"287\":1}}],[\"splice\",{\"1\":{\"200\":6,\"1252\":1}}],[\"split\",{\"1\":{\"127\":1,\"128\":1,\"129\":1,\"157\":2,\"167\":1,\"1005\":2,\"1069\":2}}],[\"spm\",{\"1\":{\"41\":2}}],[\"s=10\",{\"1\":{\"109\":1}}],[\"similarly\",{\"1\":{\"1351\":1}}],[\"simprop\",{\"1\":{\"484\":1}}],[\"simpledateformat\",{\"1\":{\"1309\":5}}],[\"simple\",{\"1\":{\"484\":1,\"559\":1,\"1315\":1}}],[\"simpletrigger\",{\"1\":{\"479\":1}}],[\"signalling\",{\"1\":{\"1506\":1}}],[\"signalled\",{\"1\":{\"1351\":1}}],[\"signalnotfull\",{\"1\":{\"1352\":1}}],[\"signalnotempty\",{\"1\":{\"1351\":1}}],[\"signaler\",{\"1\":{\"1254\":7}}],[\"signalthread\",{\"1\":{\"1253\":1}}],[\"signalall\",{\"0\":{\"1252\":1,\"1253\":1,\"1410\":1},\"1\":{\"1248\":2,\"1251\":3,\"1252\":3,\"1253\":3,\"1254\":1,\"1408\":1,\"1410\":4}}],[\"signal\",{\"0\":{\"1247\":1,\"1252\":1,\"1253\":1},\"1\":{\"1248\":2,\"1251\":3,\"1252\":9,\"1253\":3,\"1347\":2,\"1348\":1,\"1351\":1,\"1352\":1,\"1402\":1,\"1408\":1,\"1410\":3,\"1501\":1,\"1505\":8,\"1506\":1,\"1511\":3}}],[\"signed\",{\"1\":{\"920\":1}}],[\"since\",{\"1\":{\"1275\":1,\"1359\":2}}],[\"sino\",{\"1\":{\"1171\":1}}],[\"singleton\",{\"0\":{\"962\":1},\"1\":{\"1485\":7}}],[\"singleflight\",{\"1\":{\"31\":1,\"60\":4}}],[\"singe\",{\"1\":{\"592\":1}}],[\"sizing\",{\"1\":{\"540\":1}}],[\"sizectl\",{\"1\":{\"1266\":3,\"1270\":4,\"1271\":5,\"1274\":6,\"1275\":3,\"1276\":1}}],[\"sizethreshold>\",{\"1\":{\"1090\":1}}],[\"sizeof\",{\"1\":{\"223\":3,\"278\":1,\"291\":1,\"311\":1,\"312\":1,\"345\":1,\"352\":2,\"353\":1,\"354\":1,\"355\":1,\"360\":2,\"362\":1,\"363\":1}}],[\"size\",{\"0\":{\"1275\":1},\"1\":{\"92\":4,\"108\":1,\"109\":1,\"121\":2,\"129\":1,\"133\":1,\"141\":1,\"157\":4,\"173\":1,\"174\":1,\"221\":1,\"223\":2,\"224\":5,\"243\":9,\"246\":2,\"252\":3,\"274\":15,\"278\":1,\"302\":1,\"309\":3,\"327\":7,\"328\":12,\"329\":5,\"330\":4,\"341\":1,\"348\":1,\"353\":1,\"355\":1,\"356\":1,\"390\":1,\"415\":5,\"417\":9,\"422\":7,\"423\":1,\"429\":1,\"431\":1,\"525\":2,\"587\":3,\"672\":1,\"687\":1,\"688\":1,\"736\":2,\"737\":1,\"743\":1,\"852\":3,\"857\":1,\"869\":1,\"870\":3,\"958\":1,\"1036\":1,\"1037\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1072\":2,\"1074\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1090\":1,\"1201\":1,\"1270\":1,\"1275\":7,\"1276\":2,\"1306\":3,\"1315\":1,\"1316\":4,\"1369\":1,\"1407\":1,\"1409\":1,\"1410\":1}}],[\"sitemap\",{\"1\":{\"543\":2}}],[\"site\",{\"1\":{\"534\":1}}],[\"sid\",{\"1\":{\"1102\":1}}],[\"side\",{\"1\":{\"531\":2}}],[\"sidebar\",{\"1\":{\"463\":1}}],[\"sidbar\",{\"1\":{\"463\":1}}],[\"si​≤109\",{\"1\":{\"205\":1}}],[\"si​\",{\"1\":{\"205\":2,\"392\":1}}],[\"schemas\",{\"1\":{\"915\":1}}],[\"schema\",{\"1\":{\"915\":2}}],[\"schedulefuturetask重写了\",{\"1\":{\"1371\":1}}],[\"schedulefuturetask\",{\"1\":{\"1371\":1}}],[\"schedulewithfixeddelay\",{\"1\":{\"1367\":1,\"1368\":1}}],[\"schedule\",{\"1\":{\"1367\":2,\"1368\":4,\"1370\":2,\"1371\":1}}],[\"scheduledfutuetask\",{\"1\":{\"1370\":1}}],[\"scheduledfuture<v>\",{\"1\":{\"1367\":1}}],[\"scheduledfuture<\",{\"1\":{\"1367\":3,\"1368\":1,\"1370\":1}}],[\"scheduledfuturetask<void>\",{\"1\":{\"1368\":1,\"1370\":1}}],[\"scheduledfuturetask\",{\"0\":{\"1368\":1},\"1\":{\"1365\":2,\"1368\":7,\"1370\":1,\"1371\":2}}],[\"scheduledthreadpoolexecutor\",{\"0\":{\"1364\":1,\"1365\":1,\"1370\":1},\"1\":{\"1365\":8,\"1366\":7,\"1367\":1,\"1368\":2,\"1369\":2,\"1370\":4,\"1371\":8}}],[\"scheduledexecutorservice\",{\"1\":{\"1201\":1,\"1365\":1,\"1367\":1}}],[\"scheduleatfixedrate\",{\"1\":{\"1201\":1,\"1367\":1,\"1368\":1}}],[\"scheduleserverendpointtask\",{\"1\":{\"1184\":1}}],[\"scheduleconfig\",{\"1\":{\"487\":1}}],[\"schedulerexception\",{\"1\":{\"481\":1,\"482\":1}}],[\"scheduler\",{\"1\":{\"479\":1,\"484\":1,\"1158\":1}}],[\"scheduleutils\",{\"1\":{\"477\":1,\"481\":1}}],[\"scripts\",{\"1\":{\"559\":2}}],[\"scanning\",{\"1\":{\"1317\":1}}],[\"scanned\",{\"1\":{\"1315\":2}}],[\"scanner\",{\"1\":{\"82\":2,\"83\":2,\"87\":2,\"88\":2,\"97\":8,\"98\":3,\"99\":3,\"103\":2,\"104\":2,\"126\":7,\"127\":6,\"129\":7,\"161\":3,\"162\":2,\"178\":2,\"179\":2,\"180\":2,\"981\":3,\"984\":27,\"985\":6,\"986\":3,\"988\":3,\"990\":3,\"992\":3,\"999\":9,\"1001\":1,\"1006\":3,\"1021\":3,\"1022\":1,\"1023\":3,\"1047\":3,\"1048\":3}}],[\"scan\",{\"1\":{\"1315\":3,\"1316\":1,\"1317\":1}}],[\"scanf\",{\"1\":{\"273\":1,\"314\":2,\"345\":2,\"384\":3}}],[\"sc\",{\"1\":{\"82\":2,\"83\":2,\"87\":3,\"88\":4,\"97\":2,\"98\":2,\"99\":3,\"103\":6,\"104\":3,\"161\":2,\"162\":6,\"178\":3,\"179\":3,\"180\":6,\"981\":6,\"984\":22,\"985\":6,\"986\":2,\"988\":2,\"990\":2,\"992\":2,\"999\":8,\"1005\":1,\"1006\":3,\"1021\":3,\"1023\":2,\"1047\":3,\"1048\":2,\"1271\":7,\"1274\":4,\"1275\":9}}],[\"scoremap\",{\"1\":{\"129\":18}}],[\"score+delta\",{\"1\":{\"129\":1}}],[\"score\",{\"1\":{\"31\":1,\"58\":1,\"129\":12,\"1069\":2}}],[\"sure\",{\"1\":{\"1505\":1}}],[\"sundry\",{\"0\":{\"1545\":1}}],[\"sunday\",{\"1\":{\"986\":1}}],[\"sun\",{\"1\":{\"1259\":3,\"1266\":3,\"1275\":1,\"1282\":1,\"1385\":1}}],[\"supplier<\",{\"1\":{\"1210\":2}}],[\"support\",{\"1\":{\"1139\":1}}],[\"suppresswarnings\",{\"1\":{\"1052\":1,\"1271\":1,\"1274\":1,\"1302\":1,\"1348\":1}}],[\"supervisor\",{\"1\":{\"671\":2}}],[\"super\",{\"1\":{\"446\":1,\"688\":3,\"1028\":3,\"1267\":1,\"1305\":2,\"1330\":1,\"1336\":1,\"1366\":4,\"1368\":2,\"1370\":1}}],[\"successor\",{\"1\":{\"1350\":3,\"1506\":2}}],[\"successfully\",{\"1\":{\"1359\":1}}],[\"successful\",{\"1\":{\"663\":1,\"1283\":1,\"1284\":1}}],[\"success\",{\"1\":{\"523\":1,\"525\":1,\"526\":2,\"587\":1,\"589\":1,\"592\":3}}],[\"submit\",{\"1\":{\"1309\":1,\"1330\":1,\"1365\":1,\"1371\":1,\"1376\":1,\"1409\":2,\"1410\":2,\"1411\":2}}],[\"submittext\",{\"1\":{\"587\":1}}],[\"submitter=\",{\"1\":{\"587\":1}}],[\"subdivide\",{\"1\":{\"1274\":1}}],[\"sublist\",{\"1\":{\"1072\":1}}],[\"subtitle=\",{\"1\":{\"587\":1}}],[\"subroot\",{\"1\":{\"186\":2,\"187\":8}}],[\"subgrid\",{\"1\":{\"141\":3}}],[\"sub\",{\"1\":{\"122\":4,\"328\":3}}],[\"substring\",{\"1\":{\"784\":2,\"1005\":1,\"1069\":2}}],[\"substr\",{\"1\":{\"76\":1,\"422\":1}}],[\"subject\",{\"1\":{\"30\":1,\"31\":1,\"37\":1,\"49\":1,\"56\":2,\"58\":1}}],[\"sumcount\",{\"1\":{\"1275\":5}}],[\"sum++\",{\"1\":{\"230\":1}}],[\"sum2\",{\"1\":{\"114\":3}}],[\"sum1\",{\"1\":{\"114\":3}}],[\"sum\",{\"1\":{\"109\":4,\"121\":4,\"122\":6,\"203\":3,\"255\":1,\"261\":1,\"390\":3,\"772\":7,\"882\":2,\"932\":2,\"988\":3,\"990\":6,\"993\":3,\"1275\":3}}],[\"sumb++\",{\"1\":{\"71\":1}}],[\"sumb\",{\"1\":{\"71\":2}}],[\"suma++\",{\"1\":{\"71\":1}}],[\"suma\",{\"1\":{\"71\":1}}],[\"s\",{\"1\":{\"70\":6,\"71\":3,\"76\":5,\"77\":1,\"82\":7,\"83\":6,\"93\":3,\"109\":3,\"120\":6,\"126\":10,\"127\":12,\"146\":5,\"172\":6,\"174\":4,\"203\":5,\"206\":3,\"221\":3,\"223\":10,\"235\":2,\"236\":1,\"243\":5,\"244\":2,\"245\":2,\"251\":4,\"261\":20,\"262\":14,\"263\":14,\"290\":6,\"298\":18,\"299\":8,\"305\":3,\"307\":5,\"332\":3,\"333\":5,\"335\":4,\"345\":4,\"368\":2,\"392\":2,\"397\":2,\"398\":2,\"411\":5,\"422\":4,\"481\":2,\"782\":2,\"783\":7,\"784\":13,\"845\":3,\"846\":24,\"881\":4,\"882\":7,\"982\":1,\"984\":4,\"1006\":2,\"1028\":1,\"1069\":8,\"1095\":2,\"1158\":2,\"1184\":1,\"1185\":1,\"1186\":1,\"1275\":5,\"1496\":2,\"1506\":7}}],[\"some\",{\"1\":{\"1319\":1,\"1351\":1}}],[\"so\",{\"1\":{\"1239\":1,\"1242\":1,\"1293\":1,\"1359\":3,\"1505\":1,\"1511\":1}}],[\"solomon\",{\"1\":{\"1095\":1}}],[\"solution\",{\"1\":{\"70\":1,\"71\":1,\"72\":1,\"108\":1,\"109\":1,\"133\":1,\"134\":1,\"135\":1,\"152\":1,\"187\":1,\"682\":1,\"694\":1,\"700\":1,\"705\":1,\"710\":1,\"713\":1,\"724\":1,\"725\":1,\"736\":1,\"737\":1,\"743\":1,\"748\":1,\"749\":1,\"755\":1,\"761\":1,\"767\":2,\"772\":1,\"778\":1,\"783\":1,\"784\":1,\"789\":1,\"795\":1,\"796\":1,\"797\":1,\"809\":1,\"815\":1,\"820\":1,\"821\":1,\"822\":1,\"827\":1,\"828\":2,\"834\":1,\"840\":1,\"845\":1,\"846\":1,\"851\":1,\"852\":2,\"857\":1,\"864\":1,\"870\":2,\"876\":1,\"882\":1,\"887\":1,\"888\":1,\"893\":1,\"894\":2,\"899\":1,\"900\":1,\"901\":1}}],[\"son\",{\"1\":{\"412\":7}}],[\"source\",{\"1\":{\"224\":2}}],[\"sortlist\",{\"1\":{\"834\":3}}],[\"sortinlist\",{\"1\":{\"134\":3}}],[\"sort\",{\"1\":{\"41\":2,\"129\":1,\"140\":1,\"141\":2,\"152\":1,\"162\":2,\"173\":1,\"206\":1,\"250\":1,\"290\":1,\"317\":3,\"318\":3,\"324\":1,\"341\":1,\"342\":1,\"361\":1,\"375\":1,\"423\":4,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1,\"592\":2,\"1002\":1,\"1067\":2}}],[\"sortedarraytobst\",{\"1\":{\"815\":1}}],[\"sortedset\",{\"1\":{\"58\":2}}],[\"sorted\",{\"1\":{\"31\":2,\"36\":1,\"40\":3,\"58\":1,\"167\":1}}],[\"skip\",{\"1\":{\"1505\":1}}],[\"skiperrorhandler\",{\"1\":{\"591\":1}}],[\"skiplist\",{\"1\":{\"58\":1}}],[\"sk\",{\"1\":{\"174\":12}}],[\"skew\",{\"1\":{\"37\":1}}],[\"still\",{\"1\":{\"1244\":1,\"1317\":1,\"1359\":1}}],[\"stter方法注入\",{\"1\":{\"1133\":1}}],[\"student\",{\"1\":{\"1025\":2}}],[\"stopped\",{\"1\":{\"1359\":1}}],[\"stop\",{\"1\":{\"671\":1,\"1275\":1,\"1360\":1}}],[\"storeload\",{\"1\":{\"1457\":2}}],[\"storestore屏障可以省略\",{\"1\":{\"1477\":1}}],[\"storestore\",{\"1\":{\"1457\":2,\"1475\":1,\"1477\":1}}],[\"store\",{\"1\":{\"448\":1,\"453\":1,\"459\":1,\"1482\":5}}],[\"storm\",{\"1\":{\"434\":1}}],[\"storage\",{\"1\":{\"56\":1,\"1094\":1,\"1472\":1}}],[\"style=\",{\"1\":{\"587\":1,\"588\":2}}],[\"styles\",{\"1\":{\"587\":2}}],[\"stl简介\",{\"0\":{\"422\":1}}],[\"stk\",{\"1\":{\"302\":7,\"406\":3,\"407\":2}}],[\"steps\",{\"1\":{\"1359\":1}}],[\"step\",{\"1\":{\"224\":3,\"236\":5,\"237\":4,\"1242\":2}}],[\"st表\",{\"1\":{\"174\":1}}],[\"st\",{\"1\":{\"93\":6,\"108\":3,\"157\":3,\"197\":7,\"223\":3,\"281\":4,\"287\":6,\"288\":4,\"291\":9,\"311\":3,\"342\":1,\"347\":3,\"348\":3,\"352\":3,\"353\":3,\"355\":5,\"356\":5,\"360\":3,\"363\":5,\"371\":4,\"373\":5,\"380\":4,\"390\":3,\"845\":7,\"875\":1,\"876\":4}}],[\"stalesolt\",{\"1\":{\"1317\":1}}],[\"staleslot\",{\"1\":{\"1316\":13,\"1317\":26}}],[\"stale\",{\"1\":{\"1306\":1,\"1314\":1,\"1315\":3,\"1316\":3,\"1317\":10}}],[\"stamp\",{\"1\":{\"1274\":1,\"1275\":2}}],[\"standard\",{\"1\":{\"1408\":1}}],[\"standardcharsets\",{\"1\":{\"1069\":2}}],[\"standarderror=syslog\",{\"1\":{\"671\":1}}],[\"standardoutput=null\",{\"1\":{\"671\":1}}],[\"star\",{\"1\":{\"210\":1}}],[\"startsignal\",{\"1\":{\"1392\":7}}],[\"starts\",{\"1\":{\"1315\":1}}],[\"startswith\",{\"1\":{\"783\":1,\"801\":1,\"803\":1,\"1005\":1}}],[\"starttime\",{\"1\":{\"592\":1}}],[\"starteditable\",{\"1\":{\"592\":1}}],[\"started\",{\"1\":{\"537\":1,\"538\":1,\"539\":1}}],[\"startpage\",{\"1\":{\"465\":1}}],[\"startpos\",{\"1\":{\"72\":8}}],[\"start\",{\"1\":{\"70\":5,\"157\":12,\"224\":5,\"289\":3,\"559\":1,\"560\":1,\"663\":1,\"671\":2,\"827\":9,\"954\":1,\"1059\":4,\"1060\":1,\"1061\":2,\"1062\":4,\"1063\":2,\"1081\":1,\"1165\":2,\"1184\":1,\"1221\":2,\"1250\":1,\"1254\":2,\"1260\":1,\"1284\":2,\"1317\":1,\"1330\":3,\"1331\":1,\"1334\":1,\"1336\":2,\"1337\":1,\"1340\":2,\"1359\":2,\"1406\":4,\"1407\":6,\"1421\":3,\"1429\":1,\"1449\":1,\"1458\":1,\"1482\":1,\"1496\":1}}],[\"stack类\",{\"1\":{\"1075\":1}}],[\"stacktraceelement\",{\"1\":{\"1046\":1}}],[\"stack\",{\"1\":{\"93\":1,\"128\":8,\"422\":1,\"1075\":6,\"1221\":1}}],[\"stack<e>\",{\"1\":{\"1075\":1}}],[\"stack<integer>\",{\"1\":{\"128\":1}}],[\"stack<char>\",{\"1\":{\"93\":1}}],[\"stack<character>\",{\"1\":{\"83\":1}}],[\"stack<>\",{\"1\":{\"83\":2,\"128\":1,\"1037\":1,\"1075\":1}}],[\"stack<long>\",{\"1\":{\"83\":1}}],[\"statobjectargs\",{\"1\":{\"1103\":1}}],[\"statobjectresponse\",{\"1\":{\"1103\":3}}],[\"statobject\",{\"1\":{\"1103\":2}}],[\"statuschangelistener\",{\"1\":{\"1158\":1,\"1182\":1}}],[\"status\",{\"1\":{\"471\":2,\"566\":2,\"589\":1,\"592\":8,\"663\":1,\"671\":1,\"958\":1,\"1190\":2,\"1195\":1,\"1505\":1,\"1506\":2,\"1511\":2}}],[\"statement\",{\"1\":{\"990\":4,\"1102\":1}}],[\"stateless\",{\"1\":{\"446\":1}}],[\"state到终点的真实距离=真实距离\",{\"1\":{\"221\":1}}],[\"state到终点的估计距离=估计距离\",{\"1\":{\"221\":1}}],[\"state\",{\"1\":{\"110\":8,\"221\":4,\"224\":21,\"311\":4,\"484\":1,\"575\":2,\"578\":1,\"580\":1,\"589\":1,\"596\":1,\"1239\":2,\"1242\":2,\"1244\":2,\"1259\":2,\"1359\":1,\"1438\":1,\"1496\":5}}],[\"state=0\",{\"1\":{\"30\":1}}],[\"static修饰的变量\",{\"1\":{\"1465\":1}}],[\"static\",{\"1\":{\"82\":1,\"83\":3,\"87\":3,\"88\":1,\"97\":1,\"98\":1,\"99\":1,\"103\":2,\"104\":1,\"126\":1,\"127\":2,\"128\":2,\"129\":1,\"157\":2,\"161\":1,\"162\":2,\"178\":1,\"179\":1,\"180\":2,\"182\":1,\"252\":1,\"517\":1,\"523\":1,\"526\":2,\"534\":2,\"543\":1,\"568\":1,\"576\":2,\"795\":2,\"978\":1,\"980\":3,\"981\":2,\"982\":2,\"984\":9,\"985\":2,\"986\":1,\"988\":4,\"989\":1,\"990\":4,\"992\":1,\"993\":1,\"994\":2,\"997\":1,\"998\":1,\"999\":4,\"1000\":2,\"1001\":1,\"1004\":2,\"1006\":1,\"1010\":2,\"1011\":2,\"1014\":3,\"1015\":5,\"1017\":2,\"1018\":3,\"1020\":2,\"1021\":2,\"1022\":3,\"1023\":2,\"1027\":2,\"1029\":1,\"1034\":1,\"1047\":2,\"1048\":2,\"1049\":1,\"1055\":1,\"1059\":2,\"1061\":3,\"1062\":3,\"1063\":1,\"1145\":2,\"1149\":1,\"1164\":3,\"1175\":1,\"1177\":1,\"1201\":7,\"1211\":1,\"1221\":4,\"1239\":3,\"1250\":1,\"1254\":6,\"1260\":1,\"1266\":1,\"1267\":7,\"1268\":3,\"1270\":1,\"1272\":2,\"1275\":1,\"1281\":1,\"1284\":1,\"1305\":1,\"1306\":4,\"1309\":3,\"1326\":1,\"1330\":1,\"1336\":1,\"1337\":2,\"1338\":1,\"1339\":1,\"1340\":1,\"1350\":1,\"1369\":1,\"1375\":7,\"1385\":3,\"1386\":4,\"1387\":3,\"1388\":3,\"1392\":3,\"1393\":2,\"1398\":2,\"1399\":2,\"1406\":9,\"1407\":8,\"1409\":3,\"1410\":6,\"1411\":4,\"1429\":2,\"1431\":2,\"1449\":2,\"1458\":2,\"1467\":3,\"1475\":3,\"1482\":2,\"1485\":1,\"1496\":3,\"1505\":1}}],[\"stderr\",{\"1\":{\"1087\":1}}],[\"stdlib\",{\"1\":{\"251\":1}}],[\"stdout\",{\"1\":{\"249\":2,\"1087\":2}}],[\"stdc++\",{\"1\":{\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"309\":1,\"314\":1,\"360\":1,\"361\":1}}],[\"std\",{\"1\":{\"65\":1,\"66\":1,\"76\":1,\"77\":1,\"110\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":1,\"172\":1,\"173\":1,\"174\":1,\"194\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"224\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"254\":1,\"257\":1,\"261\":1,\"262\":1,\"263\":1,\"273\":1,\"274\":1,\"278\":1,\"279\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"296\":1,\"297\":1,\"298\":3,\"299\":2,\"301\":1,\"302\":3,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"311\":1,\"312\":1,\"314\":1,\"324\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"339\":2,\"352\":1,\"360\":1,\"361\":1,\"376\":1,\"384\":1,\"392\":1,\"394\":1,\"411\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1}}],[\"straight\",{\"1\":{\"1315\":1}}],[\"strategy\",{\"1\":{\"40\":2}}],[\"stride\",{\"1\":{\"1274\":7}}],[\"striped64\",{\"1\":{\"1275\":1}}],[\"strip\",{\"1\":{\"1069\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"1045\":1}}],[\"string不能被修改\",{\"1\":{\"1007\":1}}],[\"stringbuffer线程安全\",{\"1\":{\"1007\":1}}],[\"stringbuffer\",{\"0\":{\"1007\":1}}],[\"stringbuilder线程不安全\",{\"1\":{\"1007\":1}}],[\"stringbuilder\",{\"0\":{\"1007\":1,\"1070\":1},\"1\":{\"82\":2,\"98\":2,\"128\":4,\"157\":2,\"161\":2,\"1007\":2,\"1018\":4,\"1068\":5,\"1070\":2}}],[\"string转double\",{\"1\":{\"1005\":1}}],[\"string可以通过加号拼接\",{\"1\":{\"1005\":1}}],[\"stringutils\",{\"1\":{\"481\":4,\"568\":1,\"575\":1,\"576\":2,\"578\":1}}],[\"string类型的参数需要转换一下\",{\"1\":{\"251\":1}}],[\"string>>\",{\"1\":{\"1160\":2}}],[\"string>\",{\"1\":{\"224\":1,\"1204\":1,\"1207\":1,\"1211\":1}}],[\"string\",{\"0\":{\"251\":1,\"252\":1,\"1005\":1,\"1069\":1},\"1\":{\"31\":1,\"71\":1,\"76\":2,\"82\":2,\"83\":2,\"87\":1,\"88\":2,\"93\":1,\"97\":1,\"98\":2,\"99\":1,\"103\":1,\"104\":1,\"120\":1,\"126\":1,\"127\":7,\"128\":2,\"129\":6,\"157\":3,\"161\":3,\"162\":1,\"172\":1,\"178\":1,\"179\":1,\"180\":1,\"182\":1,\"203\":4,\"224\":8,\"243\":17,\"245\":1,\"251\":7,\"252\":4,\"279\":3,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"422\":1,\"466\":6,\"471\":2,\"481\":2,\"517\":4,\"542\":1,\"568\":9,\"575\":4,\"576\":10,\"578\":1,\"580\":1,\"587\":2,\"589\":10,\"592\":1,\"596\":1,\"598\":1,\"783\":2,\"784\":3,\"801\":3,\"803\":4,\"840\":2,\"845\":1,\"846\":1,\"978\":1,\"980\":3,\"981\":5,\"982\":3,\"984\":9,\"985\":2,\"986\":2,\"988\":4,\"989\":1,\"990\":4,\"992\":1,\"993\":1,\"994\":2,\"997\":1,\"998\":1,\"999\":4,\"1000\":2,\"1001\":1,\"1004\":2,\"1005\":17,\"1006\":3,\"1011\":1,\"1014\":2,\"1015\":1,\"1017\":2,\"1018\":2,\"1020\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1027\":2,\"1028\":5,\"1029\":1,\"1033\":1,\"1034\":2,\"1045\":1,\"1046\":2,\"1047\":1,\"1048\":1,\"1049\":2,\"1055\":4,\"1059\":2,\"1061\":1,\"1062\":2,\"1063\":1,\"1068\":3,\"1069\":24,\"1070\":1,\"1100\":4,\"1102\":2,\"1103\":1,\"1145\":1,\"1147\":2,\"1149\":4,\"1175\":1,\"1177\":2,\"1201\":4,\"1204\":2,\"1207\":2,\"1211\":8,\"1221\":9,\"1250\":1,\"1254\":1,\"1259\":2,\"1260\":1,\"1284\":1,\"1309\":3,\"1330\":3,\"1336\":1,\"1337\":1,\"1340\":1,\"1385\":1,\"1386\":1,\"1387\":4,\"1388\":4,\"1392\":1,\"1393\":1,\"1398\":1,\"1399\":3,\"1406\":12,\"1407\":4,\"1409\":1,\"1410\":1,\"1411\":1,\"1429\":1,\"1431\":1,\"1449\":1,\"1458\":1,\"1462\":1,\"1467\":2,\"1470\":1,\"1472\":3,\"1482\":1,\"1496\":1}}],[\"str2\",{\"1\":{\"1006\":2,\"1068\":1}}],[\"str1\",{\"1\":{\"1006\":2,\"1068\":1}}],[\"strs\",{\"1\":{\"1005\":1}}],[\"stream\",{\"1\":{\"525\":1,\"578\":1,\"664\":1,\"1103\":1}}],[\"strlen\",{\"1\":{\"243\":3,\"305\":2}}],[\"struct\",{\"1\":{\"140\":1,\"141\":1,\"257\":1,\"298\":1,\"345\":1,\"354\":1,\"361\":1,\"423\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1}}],[\"str\",{\"1\":{\"71\":4,\"76\":2,\"98\":2,\"161\":2,\"243\":5,\"251\":9,\"305\":3,\"412\":6,\"421\":2,\"422\":1,\"481\":1,\"981\":3,\"1005\":10,\"1069\":10,\"1070\":1,\"1470\":1}}],[\"se5\",{\"1\":{\"1492\":1}}],[\"semaphoredemo\",{\"1\":{\"1398\":1}}],[\"semaphore\",{\"0\":{\"1397\":1,\"1398\":1},\"1\":{\"1398\":15}}],[\"seen\",{\"1\":{\"1317\":1}}],[\"seems\",{\"1\":{\"1315\":1}}],[\"see\",{\"1\":{\"1270\":1,\"1275\":1,\"1316\":1,\"1319\":1}}],[\"seed\",{\"1\":{\"110\":4}}],[\"separate\",{\"1\":{\"971\":1,\"1306\":1}}],[\"separation\",{\"1\":{\"47\":1}}],[\"sent\",{\"1\":{\"1317\":1}}],[\"sentinel\",{\"1\":{\"493\":1,\"500\":1}}],[\"sendmail\",{\"1\":{\"671\":1}}],[\"seo\",{\"1\":{\"534\":4,\"535\":1}}],[\"servletcontextevent\",{\"1\":{\"1145\":1}}],[\"servlet\",{\"1\":{\"576\":1}}],[\"server1\",{\"1\":{\"1194\":1}}],[\"servercontext\",{\"1\":{\"1163\":1,\"1164\":4,\"1165\":1}}],[\"serverconfig\",{\"1\":{\"1160\":2}}],[\"servercodecs\",{\"1\":{\"1160\":1,\"1162\":1,\"1163\":1}}],[\"server<\",{\"1\":{\"1090\":2}}],[\"server\",{\"0\":{\"1147\":1,\"1148\":1},\"1\":{\"531\":1,\"545\":1,\"576\":1,\"664\":2,\"672\":4,\"1087\":4,\"1088\":1,\"1089\":2,\"1090\":5,\"1148\":1,\"1149\":4,\"1150\":1,\"1151\":1,\"1157\":4,\"1158\":1,\"1160\":3,\"1165\":1,\"1171\":1,\"1175\":1,\"1182\":2,\"1184\":6,\"1185\":2,\"1186\":1,\"1190\":2,\"1191\":1,\"1192\":1,\"1194\":4}}],[\"servicea\",{\"1\":{\"1193\":2}}],[\"service>\",{\"1\":{\"1090\":1}}],[\"serviceimpl<usermapper\",{\"1\":{\"568\":1}}],[\"serviceimpl\",{\"1\":{\"567\":1}}],[\"services\",{\"1\":{\"559\":1,\"592\":1}}],[\"service\",{\"0\":{\"27\":1,\"47\":1},\"1\":{\"27\":1,\"28\":1,\"40\":2,\"46\":5,\"47\":2,\"448\":1,\"451\":1,\"456\":1,\"462\":1,\"465\":1,\"516\":2,\"519\":1,\"525\":1,\"526\":1,\"567\":2,\"568\":1,\"576\":3,\"596\":1,\"671\":3,\"1129\":4,\"1133\":1,\"1186\":2,\"1196\":1,\"1330\":2,\"1393\":2,\"1398\":3,\"1399\":3,\"1409\":3,\"1410\":3,\"1411\":3}}],[\"serial\",{\"1\":{\"1418\":6,\"1420\":5}}],[\"serialversionuld\",{\"1\":{\"576\":1}}],[\"serialversionuid\",{\"1\":{\"517\":1,\"523\":1,\"526\":2,\"576\":4}}],[\"serializable\",{\"1\":{\"515\":1,\"517\":2,\"523\":2,\"525\":1,\"526\":2,\"576\":3,\"1493\":1,\"1496\":1}}],[\"sex\",{\"1\":{\"471\":2}}],[\"sessionedeurekahttpclient\",{\"1\":{\"1184\":1}}],[\"session\",{\"1\":{\"574\":1,\"575\":7,\"577\":2,\"672\":2,\"1309\":3}}],[\"sessionmanagement\",{\"1\":{\"446\":1}}],[\"sessioncreationpolicy\",{\"1\":{\"446\":3}}],[\"section\",{\"1\":{\"1316\":1}}],[\"sec\",{\"1\":{\"1270\":1}}],[\"secretkey\",{\"1\":{\"1100\":2,\"1147\":1}}],[\"securedenabled\",{\"1\":{\"446\":1,\"465\":1}}],[\"securityexception\",{\"1\":{\"1045\":1}}],[\"securityutils\",{\"1\":{\"467\":2}}],[\"securityconfig\",{\"1\":{\"446\":1,\"465\":1}}],[\"security配置\",{\"1\":{\"446\":1}}],[\"security\",{\"1\":{\"445\":3,\"446\":16,\"465\":4}}],[\"seconds\",{\"1\":{\"1158\":2,\"1201\":1,\"1204\":2,\"1207\":1,\"1398\":1,\"1399\":1}}],[\"second存储节点编号\",{\"1\":{\"353\":1}}],[\"second>\",{\"1\":{\"257\":1}}],[\"second\",{\"1\":{\"122\":4,\"206\":1,\"223\":1,\"224\":2,\"278\":2,\"342\":2,\"353\":1,\"376\":1,\"422\":2,\"431\":2,\"694\":3,\"857\":1,\"1082\":1}}],[\"secondlist\",{\"1\":{\"70\":6}}],[\"seq\",{\"1\":{\"224\":6}}],[\"segment\",{\"1\":{\"1264\":4,\"1276\":8}}],[\"segmenttree\",{\"1\":{\"157\":4}}],[\"segs\",{\"1\":{\"342\":5}}],[\"seg2\",{\"1\":{\"206\":7}}],[\"seg\",{\"1\":{\"206\":11,\"342\":5}}],[\"selfinterrupt\",{\"1\":{\"1251\":1,\"1495\":1,\"1503\":1,\"1510\":1}}],[\"self\",{\"1\":{\"121\":3,\"255\":3,\"1191\":3}}],[\"select等\",{\"1\":{\"592\":1}}],[\"selectone\",{\"1\":{\"575\":1}}],[\"selectorderlist\",{\"1\":{\"465\":1}}],[\"selectcount\",{\"1\":{\"568\":1}}],[\"selectjobbyid\",{\"1\":{\"482\":1}}],[\"select>\",{\"1\":{\"471\":1}}],[\"selectmenutreebyuserid\",{\"1\":{\"462\":1}}],[\"select\",{\"1\":{\"30\":5,\"37\":2,\"56\":3,\"181\":2,\"471\":11,\"525\":3,\"592\":3,\"912\":2,\"929\":1,\"930\":4,\"931\":1,\"932\":1,\"933\":1,\"934\":1,\"935\":1,\"942\":4,\"944\":2,\"945\":2,\"947\":6,\"1095\":1}}],[\"searching\",{\"1\":{\"1317\":1}}],[\"searchprefix\",{\"1\":{\"803\":3}}],[\"searchparams\",{\"1\":{\"589\":1}}],[\"search=\",{\"1\":{\"592\":1}}],[\"searchconfig\",{\"1\":{\"587\":1}}],[\"searchusers\",{\"1\":{\"578\":1,\"592\":2}}],[\"search\",{\"1\":{\"46\":1,\"129\":6,\"578\":1,\"801\":1,\"803\":1,\"1075\":1,\"1088\":1}}],[\"setheadandpropagate\",{\"1\":{\"1510\":1}}],[\"sethead\",{\"1\":{\"1504\":1,\"1505\":4,\"1507\":1,\"1508\":1}}],[\"setinitialvalue\",{\"1\":{\"1302\":3}}],[\"setisdirty\",{\"1\":{\"1184\":1}}],[\"setstate\",{\"1\":{\"1232\":2,\"1233\":1,\"1239\":1,\"1240\":1,\"1494\":1,\"1495\":1,\"1496\":3}}],[\"setstatus\",{\"1\":{\"482\":1,\"575\":1}}],[\"setexclusiveownerthread\",{\"1\":{\"1232\":2,\"1233\":1,\"1239\":1,\"1240\":1,\"1496\":2}}],[\"setexpire\",{\"1\":{\"1210\":1,\"1211\":1}}],[\"setexpiretime\",{\"1\":{\"1201\":1}}],[\"setemail\",{\"1\":{\"567\":1,\"575\":1}}],[\"setkey\",{\"1\":{\"1201\":1}}],[\"setbeautifulgirl\",{\"1\":{\"1133\":1}}],[\"setbucketpolicyargs\",{\"1\":{\"1102\":1}}],[\"setbucketpolicy\",{\"1\":{\"1102\":1}}],[\"setvalue\",{\"1\":{\"1074\":1,\"1201\":1}}],[\"setdaemon\",{\"1\":{\"1060\":1,\"1158\":3,\"1340\":3}}],[\"setnextruntime\",{\"1\":{\"1368\":2}}],[\"setnameformat\",{\"1\":{\"1158\":3}}],[\"setname\",{\"1\":{\"1059\":2,\"1063\":2}}],[\"setnickname\",{\"1\":{\"567\":1,\"575\":1}}],[\"setcolor\",{\"1\":{\"1028\":1}}],[\"setcharat\",{\"1\":{\"1007\":1}}],[\"sety\",{\"1\":{\"1027\":1}}],[\"setxx\",{\"1\":{\"1154\":3}}],[\"setx\",{\"1\":{\"1027\":1}}],[\"setthreshold\",{\"1\":{\"1306\":4}}],[\"settabat\",{\"1\":{\"1268\":2,\"1274\":6}}],[\"setter\",{\"1\":{\"1133\":4,\"1472\":1}}],[\"setting\",{\"1\":{\"592\":1,\"1267\":1,\"1496\":1}}],[\"settings\",{\"1\":{\"576\":1,\"587\":1,\"591\":3}}],[\"settimeout\",{\"1\":{\"592\":1}}],[\"settype\",{\"1\":{\"587\":2}}],[\"setremark\",{\"1\":{\"575\":1}}],[\"setlasttime\",{\"1\":{\"575\":1}}],[\"setarray\",{\"1\":{\"1292\":1,\"1294\":1,\"1295\":1}}],[\"setattribute\",{\"1\":{\"575\":1}}],[\"setavatar\",{\"1\":{\"567\":1,\"575\":1}}],[\"setpriority\",{\"1\":{\"1339\":1}}],[\"setproperty\",{\"1\":{\"1149\":1,\"1177\":2}}],[\"setphone\",{\"1\":{\"567\":1,\"575\":1}}],[\"setpassword\",{\"1\":{\"567\":1,\"568\":1}}],[\"setgender\",{\"1\":{\"567\":1,\"575\":1}}],[\"setuserloginstate\",{\"1\":{\"589\":1}}],[\"setuserrole\",{\"1\":{\"567\":1,\"575\":1}}],[\"setusername\",{\"1\":{\"567\":1,\"568\":1,\"575\":1}}],[\"setuserid\",{\"1\":{\"526\":1,\"575\":1}}],[\"setupdateby\",{\"1\":{\"481\":1}}],[\"setquestionpage\",{\"1\":{\"523\":1}}],[\"setquestionbankid\",{\"1\":{\"523\":1}}],[\"set<map\",{\"1\":{\"1074\":1}}],[\"set<e>\",{\"1\":{\"1073\":2}}],[\"set<k>\",{\"1\":{\"1039\":1,\"1074\":1}}],[\"set<long>\",{\"1\":{\"525\":1}}],[\"set<integer>\",{\"1\":{\"157\":2,\"1072\":1}}],[\"set<string>>\",{\"1\":{\"129\":2}}],[\"set<string>\",{\"1\":{\"88\":1,\"129\":2}}],[\"set\",{\"0\":{\"1039\":1,\"1073\":1,\"1301\":1,\"1306\":1},\"1\":{\"31\":2,\"36\":1,\"40\":3,\"58\":1,\"215\":13,\"422\":5,\"538\":1,\"613\":1,\"672\":2,\"852\":1,\"926\":2,\"1036\":1,\"1055\":1,\"1072\":1,\"1073\":3,\"1239\":1,\"1242\":1,\"1252\":2,\"1267\":2,\"1301\":5,\"1302\":3,\"1303\":1,\"1304\":2,\"1306\":9,\"1307\":2,\"1309\":1,\"1313\":1,\"1314\":4,\"1315\":1,\"1317\":1,\"1318\":1,\"1351\":1,\"1387\":1,\"1505\":1,\"1511\":1}}],[\"此图来源于\",{\"1\":{\"1325\":1,\"1334\":1}}],[\"此次循环结束在下次循环中进行重试\",{\"1\":{\"1283\":1}}],[\"此异常由\",{\"1\":{\"1045\":1}}],[\"此类异常是程序的致命异常\",{\"1\":{\"1042\":1}}],[\"此类查询需求\",{\"1\":{\"26\":1}}],[\"此题就变成了寻找最长的连续的\",{\"1\":{\"845\":1}}],[\"此账号只能通过\",{\"1\":{\"675\":1}}],[\"此密码只会在首次启动时出现\",{\"1\":{\"670\":1}}],[\"此方法会跳转到\",{\"1\":{\"587\":1}}],[\"此处无须显示的return语句\",{\"1\":{\"1020\":1}}],[\"此处有bug\",{\"1\":{\"575\":1}}],[\"此处选择第二种方式\",{\"1\":{\"525\":1}}],[\"此处存放自己写和一些优秀的开源项目\",{\"1\":{\"18\":1}}],[\"此处存放前后端常用框架的笔记\",{\"1\":{\"17\":1}}],[\"此处存放一些程序员相关的资源文件\",{\"1\":{\"19\":1}}],[\"此处存放一些计算机大类的笔记\",{\"1\":{\"7\":1}}],[\"此处存放一些关于\",{\"1\":{\"1\":1}}],[\"此处存放刷题时的思路和笔记\",{\"1\":{\"2\":1}}],[\"此功能涉及前端相关的代码位于\",{\"1\":{\"447\":1}}],[\"此后\",{\"1\":{\"168\":1}}],[\"此外\",{\"1\":{\"31\":1,\"33\":1,\"34\":1,\"40\":3,\"819\":1}}],[\"此时这两个操作就存在数据依赖性\",{\"1\":{\"1418\":1}}],[\"此时的结果是不可预知的\",{\"1\":{\"1476\":1}}],[\"此时的\",{\"1\":{\"1407\":1}}],[\"此时的队列状态如下图\",{\"1\":{\"1284\":1}}],[\"此时的队列状态示意图如下图所示\",{\"1\":{\"1283\":1}}],[\"此时队列状态为下图\",{\"1\":{\"1285\":1}}],[\"此时队列的状态如下图所示\",{\"1\":{\"1284\":1}}],[\"此时队列的尾节点应该为\",{\"1\":{\"1283\":1}}],[\"此时线程\",{\"1\":{\"1285\":2}}],[\"此时先让\",{\"1\":{\"1284\":1}}],[\"此时第\",{\"1\":{\"1284\":1}}],[\"此时状态图为下图\",{\"1\":{\"1284\":1}}],[\"此时该行代码的执行结果为\",{\"1\":{\"1283\":1}}],[\"此时会修改\",{\"1\":{\"1283\":1}}],[\"此时读取了变量\",{\"1\":{\"1283\":1}}],[\"此时nexttable=null\",{\"1\":{\"1275\":1}}],[\"此时将新值\",{\"1\":{\"1266\":1}}],[\"此时在数据量大的情况下\",{\"1\":{\"958\":1}}],[\"此时就会形成一个单向链表\",{\"1\":{\"958\":1}}],[\"此时只能够使用别名来指定字段\",{\"1\":{\"944\":1}}],[\"此时出于提高查询效率的考虑\",{\"1\":{\"938\":1}}],[\"此时二者的距离为\",{\"1\":{\"777\":1}}],[\"此时父节点相当于当前节点\",{\"1\":{\"731\":1}}],[\"此时可以使用\",{\"1\":{\"1376\":1}}],[\"此时可以在浏览器中访问\",{\"1\":{\"670\":1}}],[\"此时可以利用\",{\"1\":{\"31\":1}}],[\"此时想到\",{\"1\":{\"587\":1}}],[\"此时\",{\"1\":{\"540\":1,\"1011\":1,\"1017\":1,\"1281\":1,\"1283\":5,\"1284\":2,\"1315\":1,\"1316\":1}}],[\"此时为了防止死循环\",{\"1\":{\"322\":1}}],[\"此时算法就退化成了\",{\"1\":{\"216\":1}}],[\"此时需要特判一下\",{\"1\":{\"174\":1}}],[\"此时需要读取全部评论的全部特征\",{\"1\":{\"40\":1}}],[\"此时计数可能偏大\",{\"1\":{\"37\":1}}],[\"此时计数可能偏大或偏小\",{\"1\":{\"37\":1}}],[\"此时a事务计数更新的前提被破坏\",{\"1\":{\"37\":1}}],[\"此时告知用户操作失败也没有意义\",{\"1\":{\"37\":1}}],[\"此时也可能出现写放大\",{\"1\":{\"30\":1}}],[\"此时所有数据已准备好\",{\"1\":{\"28\":1}}],[\"关闭线程池\",{\"1\":{\"1360\":1}}],[\"关闭自我保护模式\",{\"1\":{\"1191\":1}}],[\"关闭终端后服务就会停止\",{\"1\":{\"1090\":1}}],[\"关闭评论区\",{\"1\":{\"37\":1}}],[\"关联\",{\"1\":{\"1251\":1}}],[\"关联另外一方的主键\",{\"1\":{\"938\":1}}],[\"关联查询条件复杂\",{\"1\":{\"26\":1}}],[\"关系如下图所示\",{\"1\":{\"1455\":1}}],[\"关系如图所示\",{\"1\":{\"1432\":1}}],[\"关系后我们现在就来进一步分析\",{\"1\":{\"1456\":1}}],[\"关系后\",{\"1\":{\"1433\":1}}],[\"关系可知线程\",{\"1\":{\"1432\":1}}],[\"关系并不代表了最终的执行顺序\",{\"1\":{\"1421\":1}}],[\"关系给编写正确同步的多线程程序的程序员创造了一个幻境\",{\"1\":{\"1420\":1}}],[\"关系保证正确同步的多线程程序的执行结果不被改变\",{\"1\":{\"1420\":1}}],[\"关系本质上和\",{\"1\":{\"1420\":1}}],[\"关系来执行的结果一致\",{\"1\":{\"1420\":1}}],[\"关系指定的顺序来执行\",{\"1\":{\"1420\":1}}],[\"关系向程序员提供跨线程的内存可见性保证\",{\"1\":{\"1420\":1}}],[\"关系\",{\"0\":{\"1432\":1,\"1455\":1},\"1\":{\"939\":1,\"1420\":3,\"1421\":1,\"1432\":3,\"1455\":2}}],[\"关系投影\",{\"0\":{\"440\":1}}],[\"关系运算符\",{\"1\":{\"338\":1}}],[\"关系类\",{\"1\":{\"30\":1}}],[\"关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致\",{\"1\":{\"1512\":1}}],[\"关于线程安全问题\",{\"1\":{\"1415\":1}}],[\"关于生产者\",{\"1\":{\"1411\":1}}],[\"关于更多介绍可以看\",{\"1\":{\"1306\":1}}],[\"关于两种方式的比较\",{\"1\":{\"1306\":1}}],[\"关于这个问题可以看这篇文章\",{\"1\":{\"1305\":1}}],[\"关于这个在同步组件的实现中被频繁使用的\",{\"1\":{\"1258\":1}}],[\"关于读写锁可以看这篇文章\",{\"1\":{\"1290\":1}}],[\"关于读写锁的特性\",{\"1\":{\"1237\":1}}],[\"关于扩容操作\",{\"1\":{\"1272\":1}}],[\"关于锁降级下面的示例代码摘自\",{\"1\":{\"1244\":1}}],[\"关于同步组件的实现层级结构可以看这篇文章\",{\"1\":{\"1239\":1}}],[\"关于表结构的操作也是包含四个部分\",{\"1\":{\"916\":1}}],[\"关于\",{\"1\":{\"559\":1,\"1252\":1,\"1253\":1,\"1270\":1,\"1272\":1,\"1281\":1,\"1292\":1,\"1302\":1,\"1306\":1,\"1313\":1,\"1326\":1,\"1337\":1,\"1344\":1,\"1369\":1,\"1410\":1,\"1411\":1,\"1476\":1}}],[\"关于为什么求\",{\"1\":{\"411\":1}}],[\"关于距离\",{\"0\":{\"217\":1}}],[\"关于中间件\",{\"1\":{\"14\":1}}],[\"关键信息请看注释\",{\"1\":{\"1507\":1}}],[\"关键核心在于对队列同步器\",{\"1\":{\"1493\":1}}],[\"关键在于它所调用的\",{\"1\":{\"1370\":1}}],[\"关键在于我们需要回答如下四个问题\",{\"1\":{\"1129\":1}}],[\"关键操作\",{\"0\":{\"1268\":1}}],[\"关键内部类\",{\"0\":{\"1267\":1}}],[\"关键属性\",{\"0\":{\"1266\":1}}],[\"关键属性及类\",{\"0\":{\"1265\":1}}],[\"关键逻辑请看注释\",{\"1\":{\"1252\":1}}],[\"关键\",{\"1\":{\"955\":1}}],[\"关键字所不具备的同步特性\",{\"1\":{\"1492\":1}}],[\"关键字隐式加锁解锁的便捷性\",{\"1\":{\"1492\":1}}],[\"关键字实现锁功能的\",{\"1\":{\"1492\":1}}],[\"关键字之后独有的\",{\"1\":{\"1431\":1}}],[\"关键字使得每次\",{\"1\":{\"1417\":1}}],[\"关键字中\",{\"1\":{\"1231\":1}}],[\"关键字\",{\"1\":{\"919\":1,\"1290\":1,\"1482\":1}}],[\"关键是要找出一个最优的瓶子访问顺序\",{\"1\":{\"166\":1}}],[\"关键索引是评论区\",{\"1\":{\"30\":1}}],[\"关注在稳定性\",{\"1\":{\"46\":1}}],[\"关注在业务平台化逻辑上\",{\"1\":{\"46\":1}}],[\"组件加载静态资源\",{\"1\":{\"543\":1}}],[\"组件进行了更高级别的封装\",{\"1\":{\"540\":1}}],[\"组件库\",{\"1\":{\"499\":1,\"557\":1}}],[\"组件中\",{\"1\":{\"447\":1}}],[\"组\",{\"1\":{\"484\":2}}],[\"组名等\",{\"1\":{\"479\":1}}],[\"组询问\",{\"1\":{\"389\":1}}],[\"组物品和一个容量是\",{\"1\":{\"299\":1}}],[\"组成集群时\",{\"1\":{\"1192\":1}}],[\"组成了有效括号对\",{\"1\":{\"846\":1}}],[\"组成有效括号对的字符\",{\"1\":{\"846\":1}}],[\"组成一对有效括号\",{\"1\":{\"846\":1}}],[\"组成一个\",{\"1\":{\"30\":1}}],[\"组成最小生成树\",{\"1\":{\"361\":1}}],[\"组成\",{\"1\":{\"71\":1,\"88\":1,\"958\":1}}],[\"组成的的二维网格\",{\"1\":{\"819\":1}}],[\"组成的解决方案\",{\"1\":{\"437\":1}}],[\"组成的字符串中查找最长的\",{\"1\":{\"244\":1}}],[\"组成的字符串\",{\"1\":{\"71\":1}}],[\"组成的\",{\"1\":{\"49\":1,\"958\":1}}],[\"组合数问题\",{\"1\":{\"126\":1}}],[\"组合在一起\",{\"1\":{\"121\":1}}],[\"组合\",{\"1\":{\"26\":1,\"181\":1}}],[\"组装到各个评论卡片之中\",{\"1\":{\"25\":1}}],[\"运动员出发\",{\"1\":{\"1393\":7}}],[\"运动员准备进场\",{\"1\":{\"1393\":2}}],[\"运动员\",{\"1\":{\"1392\":1,\"1393\":7}}],[\"运动员等待裁判员响哨\",{\"1\":{\"1392\":7}}],[\"运动员进行跑步比赛时\",{\"1\":{\"1392\":1}}],[\"运用前缀和的思想\",{\"1\":{\"881\":1}}],[\"运用\",{\"1\":{\"493\":1}}],[\"运用双指针的思想\",{\"1\":{\"318\":1}}],[\"运算结果并不依赖于变量的当前值\",{\"1\":{\"1482\":1}}],[\"运算等价于对长度\",{\"1\":{\"1272\":1}}],[\"运算时会将其当做整数\",{\"1\":{\"1004\":1}}],[\"运算符\",{\"0\":{\"979\":1},\"1\":{\"423\":2,\"979\":1}}],[\"运算符的优先级比算术运算符\",{\"1\":{\"338\":1}}],[\"运算的结果\",{\"1\":{\"398\":1}}],[\"运算\",{\"1\":{\"338\":1}}],[\"运算规则\",{\"1\":{\"337\":1,\"338\":4}}],[\"运营后台的检索条件都是组合的\",{\"1\":{\"50\":1}}],[\"运营体系的数据大量都是检索\",{\"1\":{\"46\":1}}],[\"运营精选且带\",{\"1\":{\"39\":1}}],[\"运营人员的数据查询具有\",{\"1\":{\"26\":1}}],[\"运行中的线程有时需要暂停\",{\"1\":{\"1331\":1}}],[\"运行结束\",{\"1\":{\"1305\":1}}],[\"运行结果不同\",{\"1\":{\"1029\":1}}],[\"运行方式\",{\"1\":{\"1107\":1}}],[\"运行公开的读\",{\"1\":{\"1102\":1}}],[\"运行项目\",{\"1\":{\"520\":1}}],[\"运行后生成的代码在根目录的\",{\"1\":{\"516\":1}}],[\"运行时异常都是\",{\"1\":{\"1044\":1}}],[\"运行时异常和非运行时异常的区别\",{\"0\":{\"1044\":1}}],[\"运行时异常\",{\"1\":{\"37\":1}}],[\"运行和集成的平台\",{\"1\":{\"14\":1}}],[\"设从根到\",{\"1\":{\"881\":1}}],[\"设从x出发共有k条有向边\",{\"1\":{\"398\":1}}],[\"设前序遍历中根节点的索引为\",{\"1\":{\"766\":1}}],[\"设g1\",{\"1\":{\"399\":1}}],[\"设s表示一个非负整数集合\",{\"1\":{\"397\":1}}],[\"设\",{\"1\":{\"182\":1,\"338\":1}}],[\"设置失败则说明\",{\"1\":{\"1505\":1}}],[\"设置失败则此次循环结束等待下一次循环进行重试\",{\"1\":{\"1284\":1}}],[\"设置新哈希表的threshhold和size属性\",{\"1\":{\"1306\":1}}],[\"设置成\",{\"1\":{\"1505\":1}}],[\"设置成了\",{\"1\":{\"1458\":1}}],[\"设置成功\",{\"1\":{\"1284\":1}}],[\"设置成当前队列尾节点\",{\"1\":{\"1283\":1}}],[\"设置为队列的队尾节点\",{\"1\":{\"1283\":1}}],[\"设置为新容量的\",{\"1\":{\"1274\":1}}],[\"设置advance为true\",{\"1\":{\"1274\":1}}],[\"设置3秒过期\",{\"1\":{\"1211\":1}}],[\"设置缓存写入间隔多久过期\",{\"1\":{\"1207\":1}}],[\"设置写入3秒后过期\",{\"1\":{\"1204\":1}}],[\"设置了默认值\",{\"1\":{\"1149\":1}}],[\"设置该存储桶里面的文件的访问策略\",{\"1\":{\"1102\":1}}],[\"设置别名\",{\"1\":{\"930\":1}}],[\"设置开机启动\",{\"1\":{\"671\":1}}],[\"设置开机自动启动\",{\"1\":{\"671\":1}}],[\"设置登录后自动跳转\",{\"0\":{\"591\":1}}],[\"设置登录参数\",{\"1\":{\"589\":1}}],[\"设置\",{\"1\":{\"575\":1,\"577\":1,\"888\":1,\"1283\":1,\"1485\":1}}],[\"设置一些值\",{\"1\":{\"575\":1}}],[\"设置中开启代码美化插件\",{\"1\":{\"539\":1}}],[\"设置这些url对所有用户可访问\",{\"1\":{\"446\":1}}],[\"设置两个头尾指针\",{\"1\":{\"317\":1}}],[\"设置节点状态位为\",{\"1\":{\"1505\":1}}],[\"设置节点\",{\"1\":{\"215\":1}}],[\"设置初始状态\",{\"1\":{\"72\":1}}],[\"设置不同的降级处理\",{\"1\":{\"25\":1}}],[\"设计者的角度\",{\"1\":{\"1423\":1}}],[\"设计了\",{\"1\":{\"1276\":1}}],[\"设计和使用哈希表时需要仔细考虑哈希函数的选择\",{\"1\":{\"973\":1}}],[\"设计递归函数\",{\"1\":{\"881\":1}}],[\"设计\",{\"1\":{\"61\":1,\"555\":1}}],[\"设计的api需要体现清晰的系统边界\",{\"1\":{\"25\":1}}],[\"设计一套基于视图模型的api\",{\"1\":{\"25\":1}}],[\"设计模式\",{\"0\":{\"13\":1},\"2\":{\"964\":1,\"968\":1}}],[\"结点的定义为\",{\"1\":{\"1350\":1}}],[\"结点并不影响尾部倒数第\",{\"1\":{\"777\":1}}],[\"结婚就行了\",{\"1\":{\"1131\":1}}],[\"结束开始notify\",{\"1\":{\"1406\":2}}],[\"结束wait\",{\"1\":{\"1406\":2}}],[\"结束后即\",{\"1\":{\"1337\":1}}],[\"结束后向查找过程\",{\"1\":{\"1317\":1}}],[\"结束时间\",{\"1\":{\"938\":1}}],[\"结束执行时间\",{\"1\":{\"476\":1}}],[\"结束\",{\"1\":{\"412\":1}}],[\"结尾的\",{\"1\":{\"851\":2}}],[\"结尾的长度为偶数的权值为奇数的子字符串的数量\",{\"1\":{\"120\":1}}],[\"结尾的长度为偶数并且权值为偶数的子字符串的数量\",{\"1\":{\"120\":1}}],[\"结尾\",{\"1\":{\"412\":1}}],[\"结构图\",{\"1\":{\"1272\":1}}],[\"结构如下图所示\",{\"1\":{\"1152\":1}}],[\"结构中如何避免这个问题\",{\"1\":{\"958\":1}}],[\"结构组织的索引\",{\"1\":{\"958\":1}}],[\"结构化查询语言\",{\"1\":{\"907\":1}}],[\"结构\",{\"0\":{\"958\":1},\"1\":{\"532\":1,\"958\":1}}],[\"结构和样式\",{\"1\":{\"532\":1}}],[\"结构和\",{\"1\":{\"532\":3}}],[\"结构对应的类\",{\"1\":{\"517\":1}}],[\"结构体存储\",{\"1\":{\"361\":1}}],[\"结构性提升了复杂调用场景下的接口性能下限\",{\"1\":{\"25\":1}}],[\"结论\",{\"1\":{\"349\":1,\"368\":1,\"388\":1}}],[\"结果都不是这个数\",{\"1\":{\"1429\":1}}],[\"结果会填充0或false值\",{\"1\":{\"1067\":1}}],[\"结果就是\",{\"1\":{\"958\":1}}],[\"结果很明显\",{\"1\":{\"471\":1}}],[\"结果为零\",{\"1\":{\"338\":1}}],[\"结果才为0\",{\"1\":{\"337\":1}}],[\"结果才为1\",{\"1\":{\"337\":1}}],[\"结果\",{\"1\":{\"115\":1,\"579\":1,\"596\":2}}],[\"结合具体的实例看一看\",{\"1\":{\"1336\":1}}],[\"结合上面的加载配置文件的分析\",{\"1\":{\"1150\":1}}],[\"结合上述分析\",{\"1\":{\"958\":1}}],[\"结合使用\",{\"0\":{\"535\":1}}],[\"结合一系列数据管理工具\",{\"1\":{\"437\":1}}],[\"结合评论网关层的排序策略路由\",{\"1\":{\"40\":1}}],[\"结合评论的产品功能要求\",{\"1\":{\"30\":1}}],[\"结合各种逻辑算子构成一个规则表达式\",{\"1\":{\"40\":1}}],[\"结合ai和人工\",{\"1\":{\"22\":1}}],[\"结合b站以及其他互联网平台的评论产品特点\",{\"1\":{\"22\":1}}],[\"前向环形未搜索到脏\",{\"1\":{\"1317\":2}}],[\"前向环形搜索到脏\",{\"1\":{\"1317\":1}}],[\"前向没有脏\",{\"1\":{\"1317\":1}}],[\"前向搜索过程结束\",{\"1\":{\"1317\":4}}],[\"前向有脏\",{\"1\":{\"1317\":1}}],[\"前后两次读取的变量\",{\"1\":{\"1283\":1}}],[\"前后端交互\",{\"0\":{\"584\":1}}],[\"前两行是设置环境名称\",{\"1\":{\"1149\":1}}],[\"前台启动\",{\"1\":{\"1087\":1}}],[\"前者是\",{\"1\":{\"1069\":1,\"1248\":1}}],[\"前序\",{\"1\":{\"766\":1,\"767\":1}}],[\"前序遍历是最快的\",{\"1\":{\"899\":1}}],[\"前序遍历在某些数据下不需要递归到叶子节点就能返回\",{\"1\":{\"899\":1}}],[\"前序遍历\",{\"0\":{\"899\":1},\"1\":{\"766\":1}}],[\"前序遍历的首元素\",{\"1\":{\"766\":1}}],[\"前序遍历性质\",{\"1\":{\"766\":1}}],[\"前阵子出现了各大知名博主\",{\"1\":{\"668\":1}}],[\"前端在请求服务端时\",{\"1\":{\"935\":1}}],[\"前端查询数据库的流程\",{\"1\":{\"935\":1}}],[\"前端优化\",{\"0\":{\"600\":1}}],[\"前端用户退出\",{\"1\":{\"596\":1}}],[\"前端使用\",{\"1\":{\"585\":1}}],[\"前端需要向后端发送请求才能获取数据\",{\"1\":{\"585\":1}}],[\"前端请求\",{\"0\":{\"585\":1}}],[\"前端再次请求后端的时候\",{\"1\":{\"575\":1}}],[\"前端接收到后端的命令后\",{\"1\":{\"575\":1}}],[\"前端瘦身\",{\"1\":{\"559\":1}}],[\"前端框架\",{\"1\":{\"559\":1}}],[\"前端初始化\",{\"0\":{\"559\":1}}],[\"前端整合多个工具时\",{\"1\":{\"539\":1}}],[\"前端万用模板\",{\"0\":{\"536\":1}}],[\"前端的部分基础页面\",{\"1\":{\"529\":1}}],[\"前端模板开发\",{\"1\":{\"529\":1}}],[\"前端模版开发\",{\"0\":{\"529\":1}}],[\"前端根据不同的场景\",{\"1\":{\"523\":1}}],[\"前端工程化配置\",{\"0\":{\"539\":1}}],[\"前端工程化\",{\"1\":{\"499\":1}}],[\"前端代码生成\",{\"1\":{\"499\":1}}],[\"前端代码\",{\"1\":{\"477\":1}}],[\"前端封装了一个指令权限\",{\"1\":{\"457\":1}}],[\"前端\",{\"0\":{\"448\":1,\"453\":1,\"459\":1,\"499\":1},\"1\":{\"502\":1,\"557\":1}}],[\"前端将点击数据发送到后端服务器\",{\"1\":{\"151\":1}}],[\"前期建设开支很大\",{\"1\":{\"438\":1}}],[\"前置知识\",{\"1\":{\"385\":1}}],[\"前置依赖较多的可以流水线调用\",{\"1\":{\"25\":1}}],[\"前提\",{\"1\":{\"328\":1}}],[\"前提是\",{\"1\":{\"126\":1,\"795\":1,\"893\":1}}],[\"前\",{\"1\":{\"308\":2,\"1398\":2}}],[\"前六个测试点满足\",{\"1\":{\"262\":1}}],[\"前面说过数组引用是\",{\"1\":{\"1294\":1}}],[\"前面我们已经知道\",{\"1\":{\"1252\":1}}],[\"前面我们说过\",{\"1\":{\"1250\":1}}],[\"前面还是为了实现getreadholdcount等新功能\",{\"1\":{\"1243\":1}}],[\"前面在\",{\"1\":{\"576\":1}}],[\"前面讲到的几种方式可以结合使用\",{\"1\":{\"535\":1}}],[\"前面\",{\"1\":{\"289\":1}}],[\"前面有几个\",{\"1\":{\"261\":1}}],[\"前面任意一块能到达\",{\"1\":{\"194\":1}}],[\"前1块能到达草地的最大值\",{\"1\":{\"194\":1}}],[\"前一个线程将接力棒传给下一个线程\",{\"1\":{\"1337\":1}}],[\"前一个更大的元素\",{\"1\":{\"174\":1}}],[\"前一个字符串为待匹配的字符串\",{\"1\":{\"127\":1}}],[\"前缀的指令会引起处理器缓存写回内存\",{\"1\":{\"1454\":1}}],[\"前缀的指令在多核处理器下会发现什么事情了\",{\"1\":{\"1454\":1}}],[\"前缀的指令\",{\"1\":{\"1454\":2}}],[\"前缀不存在退出查找\",{\"1\":{\"802\":1}}],[\"前缀树\",{\"0\":{\"800\":1},\"1\":{\"800\":1,\"801\":1}}],[\"前缀方便管理\",{\"1\":{\"576\":1}}],[\"前缀部分\",{\"1\":{\"309\":1}}],[\"前缀和相当于从根节点开始的路径元素和\",{\"1\":{\"881\":1}}],[\"前缀和相关题型\",{\"0\":{\"260\":1},\"1\":{\"4\":1}}],[\"前缀和与差分\",{\"0\":{\"331\":1}}],[\"前缀和的值\",{\"1\":{\"261\":1}}],[\"前缀和\",{\"1\":{\"261\":2},\"2\":{\"265\":1,\"884\":1}}],[\"前缀染色\",{\"0\":{\"157\":1}}],[\"前需要做一个异构的\",{\"1\":{\"50\":1}}],[\"同生共死\",{\"1\":{\"1482\":1}}],[\"同学获取到笔\",{\"1\":{\"1398\":11}}],[\"同学准备获取笔\",{\"1\":{\"1398\":11}}],[\"同学之间就不会产生冲突\",{\"1\":{\"1313\":1}}],[\"同acquire方法功能基本一样\",{\"1\":{\"1398\":1}}],[\"同第二种\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"同上一个方法功能基本一样\",{\"1\":{\"1399\":1}}],[\"同上面的\",{\"1\":{\"1317\":1}}],[\"同上\",{\"1\":{\"1069\":3}}],[\"同步队列是一个双向队列\",{\"1\":{\"1501\":1}}],[\"同步队列\",{\"0\":{\"1501\":1},\"1\":{\"1500\":1}}],[\"同步队列以及执行线程状态之间的关系\",{\"1\":{\"1431\":1}}],[\"同步器会调用\",{\"1\":{\"1506\":1}}],[\"同步器是面向锁的实现者\",{\"1\":{\"1494\":1}}],[\"同步器是实现锁\",{\"1\":{\"1494\":1}}],[\"同步器是用来构建锁和其他同步组件的基础框架\",{\"1\":{\"1494\":1}}],[\"同步器既支持独占式获取同步状态\",{\"1\":{\"1494\":1}}],[\"同步器自身没有实现任何同步接口\",{\"1\":{\"1494\":1}}],[\"同步块执行完成或者遇到异常是锁会自动释放\",{\"1\":{\"1492\":1}}],[\"同步机制以\",{\"1\":{\"1313\":1}}],[\"同步机制就是通过控制线程访问共享对象的顺序\",{\"1\":{\"1313\":1}}],[\"同步就相当于\",{\"1\":{\"1313\":1}}],[\"同步组件的实现者通过使用\",{\"1\":{\"1500\":1}}],[\"同步组件的实现聚合了同步器\",{\"1\":{\"1239\":1}}],[\"同步组件专注于对当前同步状态的逻辑判断\",{\"1\":{\"1496\":1}}],[\"同步组件实现者的角度\",{\"1\":{\"1496\":1}}],[\"同步组件以及\",{\"1\":{\"1496\":1}}],[\"同步组件语义的实现依赖于\",{\"1\":{\"1496\":1}}],[\"同步组件通过重写\",{\"1\":{\"1496\":1}}],[\"同步组件通过\",{\"1\":{\"1495\":1}}],[\"同步组件\",{\"1\":{\"1495\":1}}],[\"同步组件主要是通过重写\",{\"1\":{\"1232\":1}}],[\"同步状态减去写状态\",{\"1\":{\"1240\":1}}],[\"同步状态减1\",{\"1\":{\"1232\":1}}],[\"同步状态的高\",{\"1\":{\"1239\":1,\"1242\":1}}],[\"同步状态的低\",{\"1\":{\"1239\":1}}],[\"同步状态加\",{\"1\":{\"1232\":1}}],[\"同步语义的学习\",{\"1\":{\"1231\":1}}],[\"同步方法调用一开始\",{\"1\":{\"1223\":1}}],[\"同步和异步通常用来形容一次方法调用\",{\"1\":{\"1223\":1}}],[\"同步vs异步\",{\"0\":{\"1223\":1}}],[\"同步的过程会消耗时间\",{\"1\":{\"1075\":1}}],[\"同步\",{\"0\":{\"1062\":1}}],[\"同步失败则直接导致最终不一致\",{\"1\":{\"37\":1}}],[\"同构渲染\",{\"1\":{\"535\":2}}],[\"同端登录冲突检测\",{\"1\":{\"493\":1,\"497\":1,\"508\":1}}],[\"同加法一样处理进位\",{\"1\":{\"329\":1}}],[\"同理更新\",{\"1\":{\"852\":2}}],[\"同理再处理该节点和该节点的右子节点\",{\"1\":{\"731\":1}}],[\"同理队尾\",{\"1\":{\"409\":1}}],[\"同理\",{\"1\":{\"327\":1,\"328\":1,\"899\":1}}],[\"同理输入一个二维数组\",{\"1\":{\"229\":1}}],[\"同\",{\"1\":{\"257\":1,\"1306\":1}}],[\"同一个类的实例\",{\"1\":{\"1029\":1}}],[\"同一个包或者子类中可以访问\",{\"1\":{\"1027\":1}}],[\"同一个节点在一条路径序列中\",{\"1\":{\"717\":1}}],[\"同一个数也可以被反复选择\",{\"1\":{\"104\":1}}],[\"同一组内的物品最多只能选一个\",{\"1\":{\"299\":1}}],[\"同一行内的数升序排列\",{\"1\":{\"289\":1}}],[\"同一行内的数必须升序排列\",{\"1\":{\"287\":1}}],[\"同一行相邻两个数用一个空格隔开\",{\"1\":{\"288\":1}}],[\"同一层级的可以并发调用\",{\"1\":{\"25\":1}}],[\"同程旅行笔试\",{\"0\":{\"86\":1}}],[\"同样来看一段代码\",{\"1\":{\"1467\":1}}],[\"同样根据\",{\"1\":{\"1455\":1}}],[\"同样是需要排队\",{\"1\":{\"1434\":1}}],[\"同样也提供了相应的原子操作类\",{\"1\":{\"1388\":1}}],[\"同样都是当前线程会交出处理器资源\",{\"1\":{\"1339\":1}}],[\"同样可以调用\",{\"1\":{\"1336\":1}}],[\"同样可以通过中断的方式实现线程间的简单交互\",{\"1\":{\"1336\":1}}],[\"同样可以通过\",{\"1\":{\"1221\":1}}],[\"同样满足\",{\"1\":{\"1326\":1}}],[\"同样会阻塞插入数据的线程\",{\"1\":{\"1325\":1}}],[\"同样会往前递进找到队列真正的队头节点\",{\"1\":{\"1285\":1}}],[\"同样为脏\",{\"1\":{\"1316\":1}}],[\"同样将其清理掉\",{\"1\":{\"1316\":1}}],[\"同样\",{\"1\":{\"1264\":1,\"1416\":1}}],[\"同样的在\",{\"1\":{\"1486\":1}}],[\"同样的也会释放对象锁\",{\"1\":{\"1407\":1}}],[\"同样的可以看出\",{\"1\":{\"1317\":1}}],[\"同样的还是来看看源码\",{\"1\":{\"1302\":1}}],[\"同样的\",{\"1\":{\"1158\":1,\"1248\":1,\"1250\":1,\"1305\":1,\"1326\":1}}],[\"同样表示字符串\",{\"1\":{\"1112\":1}}],[\"同样先计算键的哈希值\",{\"1\":{\"971\":1}}],[\"同样我们也可以通过外键来体现一对一之间的关系\",{\"1\":{\"938\":1}}],[\"同样有\",{\"1\":{\"886\":1}}],[\"同样首先遍历左子节点的左子树\",{\"1\":{\"729\":1}}],[\"同样地\",{\"1\":{\"70\":1}}],[\"同样减少了对\",{\"1\":{\"60\":1}}],[\"同进程只交给一个人去获取\",{\"1\":{\"60\":1}}],[\"同时在\",{\"1\":{\"1508\":1}}],[\"同时在新建一个同步组件时需要把握的两个关键点是\",{\"1\":{\"1496\":1}}],[\"同时很明显\",{\"1\":{\"1504\":1}}],[\"同时实现包括获取锁失败的线程进行入队\",{\"1\":{\"1501\":1}}],[\"同时返回获取的数据\",{\"1\":{\"1399\":1}}],[\"同时该线程可以调用\",{\"1\":{\"1336\":1}}],[\"同时将\",{\"1\":{\"1308\":1}}],[\"同时如果过小\",{\"1\":{\"1306\":1}}],[\"同时如果注销的用户名较多的话\",{\"1\":{\"613\":1}}],[\"同时线程\",{\"1\":{\"1284\":1}}],[\"同时可以看出等待队列是一个不带头结点的链式队列\",{\"1\":{\"1251\":1}}],[\"同时可能需要查询到题库内的题目列表\",{\"1\":{\"523\":1}}],[\"同时还有一点需要注意的是\",{\"1\":{\"1250\":1}}],[\"同时还有一个方法值得我们注意\",{\"1\":{\"1239\":1}}],[\"同时还能够为该应用程序提供相关的服务的软件\",{\"1\":{\"14\":1}}],[\"同时进行\",{\"1\":{\"1224\":1}}],[\"同时也能够获取读锁\",{\"1\":{\"1237\":1}}],[\"同时也把你交给其他需要你的东西\",{\"1\":{\"1131\":1}}],[\"同时也很危险\",{\"1\":{\"662\":1}}],[\"同时却也降低了\",{\"1\":{\"957\":1}}],[\"同时用哈希表\",{\"1\":{\"881\":1}}],[\"同时节点的标志位还必须为\",{\"1\":{\"802\":1}}],[\"同时向前走\",{\"1\":{\"777\":1}}],[\"同时屏蔽掉项目框架本身的异常\",{\"1\":{\"599\":1}}],[\"同时环湖的服务彼此之间也可以轻松交换数据\",{\"1\":{\"438\":1}}],[\"同时这些移到湖里的数据\",{\"1\":{\"438\":1}}],[\"同时这个租约\",{\"1\":{\"60\":1}}],[\"同时不捕获其他变量\",{\"1\":{\"255\":1}}],[\"同时我们需要在\",{\"1\":{\"180\":1}}],[\"同时要考虑路径上的怪物对小红血量的影响\",{\"1\":{\"180\":1}}],[\"同时你可以得到\",{\"1\":{\"178\":1}}],[\"同时数组中所有等于\",{\"1\":{\"178\":1}}],[\"同时增加到\",{\"1\":{\"167\":1}}],[\"同时维护这个区间内的价格和\",{\"1\":{\"140\":1}}],[\"同时使用另一个\",{\"1\":{\"129\":1}}],[\"同时需要在\",{\"1\":{\"46\":1}}],[\"同时支持配置并行度\",{\"1\":{\"33\":1}}],[\"同时\",{\"1\":{\"28\":2,\"50\":1,\"56\":1,\"141\":1,\"151\":1,\"213\":1,\"394\":1,\"1280\":1,\"1313\":1,\"1316\":1,\"1423\":1,\"1473\":1,\"1506\":1}}],[\"同时做好安全校验和流量控制\",{\"1\":{\"25\":1}}],[\"服务启动1秒之后\",{\"1\":{\"1201\":1}}],[\"服务已启动时间\",{\"1\":{\"1194\":1}}],[\"服务是可用的\",{\"1\":{\"1191\":1}}],[\"服务上\",{\"1\":{\"1175\":1}}],[\"服务的\",{\"1\":{\"1157\":1}}],[\"服务中的\",{\"1\":{\"1157\":1}}],[\"服务实例信息\",{\"0\":{\"1195\":1}}],[\"服务实例\",{\"1\":{\"1154\":1}}],[\"服务注册的\",{\"1\":{\"1153\":1}}],[\"服务配置管理器\",{\"1\":{\"1153\":1}}],[\"服务进行配置和操作\",{\"1\":{\"1100\":1}}],[\"服务进行降级\",{\"1\":{\"51\":1}}],[\"服务端状态\",{\"1\":{\"1195\":1}}],[\"服务端\",{\"1\":{\"1195\":1}}],[\"服务端无法使用\",{\"1\":{\"546\":1}}],[\"服务端渲染的过程如下\",{\"1\":{\"533\":1}}],[\"服务端渲染\",{\"0\":{\"530\":1,\"533\":1},\"1\":{\"493\":1,\"499\":1,\"531\":1}}],[\"服务器中获取\",{\"1\":{\"1191\":1}}],[\"服务器地址和端口\",{\"1\":{\"1100\":1}}],[\"服务器地点一般选择\",{\"1\":{\"662\":1}}],[\"服务器的所有正常输出\",{\"1\":{\"1087\":1}}],[\"服务器ip\",{\"1\":{\"670\":1}}],[\"服务器b\",{\"1\":{\"664\":4}}],[\"服务器a\",{\"1\":{\"662\":2,\"664\":3}}],[\"服务器\",{\"1\":{\"557\":1,\"586\":2,\"665\":2,\"671\":1,\"672\":2,\"906\":2,\"1087\":1,\"1089\":1,\"1090\":1,\"1095\":1}}],[\"服务器会将渲染好的\",{\"1\":{\"533\":1}}],[\"服务器会执行页面的渲染逻辑\",{\"1\":{\"533\":1}}],[\"服务器压力较大\",{\"1\":{\"533\":1}}],[\"服务器将渲染好的\",{\"1\":{\"533\":1}}],[\"服务器使用获取到的数据和事先定义好的模板引擎\",{\"1\":{\"533\":1}}],[\"服务器从数据库或其他数据源中获取所需的数据\",{\"1\":{\"533\":1}}],[\"服务器只需提供基本的\",{\"1\":{\"532\":1}}],[\"服务器接收到请求后\",{\"1\":{\"532\":1,\"533\":1}}],[\"服务器处理请求\",{\"1\":{\"532\":1,\"533\":1}}],[\"服务器在接收到客户端请求后\",{\"1\":{\"531\":1}}],[\"服务器返回一个基本的\",{\"1\":{\"531\":1}}],[\"服务器开发\",{\"1\":{\"125\":1}}],[\"服务开发\",{\"0\":{\"519\":1}}],[\"服务等等\",{\"1\":{\"438\":1}}],[\"服务来实现\",{\"1\":{\"51\":1}}],[\"服务去\",{\"1\":{\"48\":1}}],[\"服务内部\",{\"1\":{\"48\":1}}],[\"服务\",{\"1\":{\"46\":1,\"51\":1,\"662\":1,\"1087\":1,\"1089\":1,\"1090\":1,\"1094\":2}}],[\"服务层\",{\"1\":{\"46\":2}}],[\"服务集群总qps与节点数的关系\",{\"1\":{\"33\":1}}],[\"服务编排拆分为若干个层级\",{\"1\":{\"25\":1}}],[\"服务或公司的评估\",{\"1\":{\"21\":1}}],[\"对超时时间的处理上\",{\"1\":{\"1508\":1}}],[\"对同步状态的管理的基石\",{\"1\":{\"1500\":1}}],[\"对同一个监视器的解锁\",{\"1\":{\"1432\":1}}],[\"对语句\",{\"1\":{\"1482\":1}}],[\"对底层的约束就很少\",{\"1\":{\"1473\":1}}],[\"对底层尽量减少约束\",{\"1\":{\"1418\":1}}],[\"对final引用数据类型person进行更改\",{\"1\":{\"1467\":1}}],[\"对并发分析的切入点可以分为\",{\"1\":{\"1455\":1}}],[\"对编译器和处理器的束缚已经尽可能少\",{\"1\":{\"1423\":1}}],[\"对编译器和处理器不做要求\",{\"1\":{\"1423\":1}}],[\"对编译器和处理器重排序的约束原则\",{\"1\":{\"1420\":1}}],[\"对线程\",{\"1\":{\"1421\":1,\"1433\":1}}],[\"对一个\",{\"1\":{\"1421\":1,\"1455\":1}}],[\"对一个锁的解锁\",{\"1\":{\"1421\":1}}],[\"对一个队列来说\",{\"1\":{\"1283\":1}}],[\"对程序员的承诺\",{\"1\":{\"1420\":1}}],[\"对最终结果也不会存在关系\",{\"1\":{\"1418\":1}}],[\"对上面的代码进行更正\",{\"1\":{\"1406\":1}}],[\"对数组元素的写入可能看到也可能看不到\",{\"1\":{\"1476\":1}}],[\"对数组中索引为1的位置的元素加5\",{\"1\":{\"1386\":1}}],[\"对数据元素的基本操作有\",{\"1\":{\"1325\":1}}],[\"对数据结构做了进一步的优化\",{\"1\":{\"1272\":1}}],[\"对基本变量的操作比如自增\",{\"1\":{\"1385\":1}}],[\"对异步任务进行进一步封装\",{\"1\":{\"1368\":1}}],[\"对当前线程进行中断操作\",{\"1\":{\"1336\":1}}],[\"对当前容量大小进行检查\",{\"1\":{\"1272\":2}}],[\"对脏\",{\"1\":{\"1317\":1}}],[\"对这两种不同性质的重排序\",{\"1\":{\"1423\":1}}],[\"对这一点从文字上还是很难理解\",{\"1\":{\"1295\":1}}],[\"对这个业务的系统有比较深的理解\",{\"1\":{\"45\":1}}],[\"对读线程而言\",{\"1\":{\"1295\":1}}],[\"对方法进行修饰\",{\"1\":{\"1290\":1}}],[\"对红黑树进行操作的时候针对的是\",{\"1\":{\"1272\":1}}],[\"对未来的一种预测\",{\"1\":{\"1218\":1}}],[\"对资源的抽象\",{\"1\":{\"1135\":1}}],[\"对用户而言\",{\"1\":{\"1100\":2}}],[\"对用户的基本信息查询频率特别的高\",{\"1\":{\"938\":1}}],[\"对用户的查询或者修改\",{\"1\":{\"556\":1}}],[\"对浮点数四舍五入\",{\"1\":{\"1080\":1}}],[\"对浮点数向下取整\",{\"1\":{\"1080\":1}}],[\"对浮点数向上取整\",{\"1\":{\"1080\":1}}],[\"对元素采用的是堆排序\",{\"1\":{\"1078\":1}}],[\"对原来的list和返回的list做的\",{\"1\":{\"1072\":1}}],[\"对形参的改动不会影响实参的初始值\",{\"1\":{\"1017\":1}}],[\"对null值不作为统计\",{\"1\":{\"932\":1}}],[\"对二叉树进行递归遍历\",{\"1\":{\"881\":1}}],[\"对二叉树进行层序遍历\",{\"1\":{\"737\":1}}],[\"对称二叉树\",{\"0\":{\"806\":1},\"1\":{\"806\":1}}],[\"对每个节点的进行相同的递归处理\",{\"1\":{\"730\":1}}],[\"对每辆车进行枚举\",{\"1\":{\"290\":1}}],[\"对其他线程的执行过程\",{\"1\":{\"1398\":1}}],[\"对其进行了封装\",{\"1\":{\"1385\":1}}],[\"对其进行读写操作\",{\"1\":{\"674\":1}}],[\"对其按升序排序\",{\"1\":{\"134\":1}}],[\"对接等功能的短链接系统\",{\"1\":{\"634\":1}}],[\"对接等功能\",{\"1\":{\"634\":1}}],[\"对需要存储的数据使用哈希函数计算得到\",{\"1\":{\"613\":1}}],[\"对比\",{\"1\":{\"592\":1}}],[\"对比之美\",{\"0\":{\"147\":1}}],[\"对密码进行md5盐值加密\",{\"1\":{\"568\":1,\"575\":1}}],[\"对密码进行加密\",{\"1\":{\"568\":1}}],[\"对服务器的性能要求较高\",{\"1\":{\"533\":1}}],[\"对兼容性要求较高\",{\"1\":{\"532\":1}}],[\"对浏览器兼容性要求较高\",{\"1\":{\"532\":1}}],[\"对搜索引擎优化不友好\",{\"1\":{\"532\":1}}],[\"对搜索引擎的可访问性较差\",{\"1\":{\"531\":1}}],[\"对创建的数据进行校验\",{\"1\":{\"526\":1}}],[\"对后端项目初始化\",{\"1\":{\"514\":1}}],[\"对目标方法进行拦截\",{\"1\":{\"471\":1}}],[\"对自定义的结构体\",{\"1\":{\"423\":1}}],[\"对两个迭代器\",{\"1\":{\"423\":1}}],[\"对两个子序列分别设置个指针\",{\"1\":{\"318\":1}}],[\"对字符串也适用\",{\"1\":{\"422\":1}}],[\"对阶乘分解质因数之后\",{\"1\":{\"390\":1}}],[\"对朴素筛法的优化\",{\"1\":{\"371\":1}}],[\"对无符号数\",{\"1\":{\"337\":1}}],[\"对a提前判断一下\",{\"1\":{\"291\":1}}],[\"对\",{\"1\":{\"243\":1,\"557\":2,\"1100\":1,\"1140\":1,\"1267\":1,\"1272\":1,\"1286\":1,\"1291\":1,\"1292\":1,\"1295\":1,\"1318\":1,\"1366\":1,\"1370\":1,\"1375\":1,\"1392\":1,\"1406\":1,\"1476\":3,\"1477\":1,\"1482\":2,\"1504\":1}}],[\"对角线上相邻\",{\"1\":{\"228\":1}}],[\"对角公式\",{\"1\":{\"219\":1}}],[\"对角距离\",{\"0\":{\"219\":1},\"1\":{\"216\":1,\"219\":1}}],[\"对象头里的\",{\"1\":{\"1440\":1}}],[\"对象头\",{\"0\":{\"1440\":1}}],[\"对象监视器\",{\"1\":{\"1431\":1}}],[\"对象监视器上只能拥有一个同步队列和一个等待队列\",{\"1\":{\"1250\":1}}],[\"对象锁\",{\"0\":{\"1431\":1}}],[\"对象时\",{\"1\":{\"1326\":1}}],[\"对象实例是从应用层面\",{\"1\":{\"1309\":1}}],[\"对象实例\",{\"1\":{\"1309\":1}}],[\"对象创建出来后\",{\"1\":{\"1306\":1}}],[\"对象都天然继承于\",{\"1\":{\"1248\":1}}],[\"对象启动了一个延迟\",{\"1\":{\"1185\":1}}],[\"对象的markword变化为下图\",{\"1\":{\"1440\":1}}],[\"对象的对象头\",{\"1\":{\"1440\":1}}],[\"对象的\",{\"1\":{\"1330\":1,\"1404\":1,\"1475\":1}}],[\"对象的入参会有什么不同的地方了\",{\"1\":{\"1259\":1}}],[\"对象的过程非常复杂\",{\"1\":{\"1158\":1}}],[\"对象的迭代器list\",{\"1\":{\"200\":1}}],[\"对象里面有很多\",{\"1\":{\"1151\":1}}],[\"对象而言\",{\"1\":{\"1133\":1}}],[\"对象构造完毕后就可以直接使用\",{\"1\":{\"1133\":1}}],[\"对象始终会和其他的接口或类藕合起来\",{\"1\":{\"1131\":1}}],[\"对象是通过\",{\"1\":{\"1250\":1}}],[\"对象是单例的\",{\"1\":{\"1100\":1}}],[\"对象是类这种类型对应的实例\",{\"1\":{\"1025\":1}}],[\"对象即可实现对\",{\"1\":{\"1100\":1}}],[\"对象存储可以作为主存储层\",{\"1\":{\"1095\":1}}],[\"对象存储的读\",{\"1\":{\"1095\":1}}],[\"对象存储\",{\"1\":{\"1094\":1}}],[\"对象来拼接\",{\"1\":{\"1068\":1}}],[\"对象上\",{\"1\":{\"1062\":1}}],[\"对象栈层次\",{\"1\":{\"1046\":1}}],[\"对象代表异常原因\",{\"1\":{\"1046\":1}}],[\"对象和数据库的关联\",{\"1\":{\"567\":1}}],[\"对象中的\",{\"1\":{\"471\":1,\"1388\":1}}],[\"对象中\",{\"1\":{\"200\":2,\"448\":1,\"453\":1,\"459\":1,\"935\":1,\"1388\":1}}],[\"对象\",{\"1\":{\"200\":1,\"557\":1,\"1100\":2,\"1132\":1,\"1138\":1,\"1147\":1,\"1151\":1,\"1153\":1,\"1158\":1,\"1160\":1,\"1248\":1,\"1250\":2,\"1259\":3,\"1267\":2,\"1270\":1,\"1376\":1,\"1385\":1,\"1387\":2,\"1421\":1,\"1475\":1}}],[\"对合并后的结果进行升序排序\",{\"1\":{\"181\":1}}],[\"对第\",{\"1\":{\"103\":1}}],[\"对以落点为圆心\",{\"1\":{\"97\":1}}],[\"对输入的文本字符串进行简单的压缩\",{\"1\":{\"82\":1}}],[\"对重算排序的收益进行预估\",{\"1\":{\"40\":1}}],[\"对特征的导入与更新都提出了挑战\",{\"1\":{\"40\":1}}],[\"对性能的影响较大\",{\"1\":{\"37\":1}}],[\"对各类数据写操作\",{\"1\":{\"36\":1}}],[\"对于能够支持多个线程同时访问的并发组件\",{\"1\":{\"1511\":1}}],[\"对于底层而言\",{\"1\":{\"1473\":1}}],[\"对于编译器来说\",{\"1\":{\"1457\":1}}],[\"对于文章开头的现象\",{\"1\":{\"1449\":1}}],[\"对于不会改变程序执行结果的重排序\",{\"1\":{\"1423\":1}}],[\"对于会改变程序执行结果的重排序\",{\"1\":{\"1423\":1}}],[\"对于裁判员来说就少了一个计时任务\",{\"1\":{\"1392\":1}}],[\"对于像手机这样的小型设备可能使用协作式调度\",{\"1\":{\"1331\":1}}],[\"对于这个估计值\",{\"1\":{\"1275\":1}}],[\"对于这个例子来说\",{\"1\":{\"152\":1}}],[\"对于数据库锁\",{\"1\":{\"1221\":1}}],[\"对于数据结构复制\",{\"1\":{\"887\":1}}],[\"对于调用接口方法的地方是透明的\",{\"1\":{\"1147\":1}}],[\"对于相似的变量\",{\"1\":{\"1147\":1}}],[\"对于个人来说\",{\"1\":{\"1094\":1}}],[\"对于企业来说\",{\"1\":{\"1094\":1}}],[\"对于某个具体的对象而言\",{\"1\":{\"1131\":1}}],[\"对于某个页面私有的组件\",{\"1\":{\"544\":1}}],[\"对于某一个硬币\",{\"1\":{\"894\":1}}],[\"对于动态规划问题\",{\"1\":{\"852\":1}}],[\"对于回溯\",{\"1\":{\"851\":1}}],[\"对于后\",{\"1\":{\"783\":1}}],[\"对于树的左\",{\"1\":{\"766\":1}}],[\"对于链表问题\",{\"1\":{\"699\":1}}],[\"对于布隆过滤器无法删除元素这个缺点\",{\"1\":{\"613\":1}}],[\"对于项目中多页面公用的组件\",{\"1\":{\"544\":1}}],[\"对于需要实时更新内容的网站\",{\"1\":{\"534\":1}}],[\"对于有根树\",{\"1\":{\"753\":1}}],[\"对于有些不需要关联查询题目列表的页面\",{\"1\":{\"523\":1}}],[\"对于有明确终点的问题来说\",{\"1\":{\"212\":1}}],[\"对于登录login\",{\"1\":{\"446\":1}}],[\"对于既想修湖\",{\"1\":{\"438\":1}}],[\"对于先手来说是一个必败状态\",{\"1\":{\"394\":1}}],[\"对于先手来说是一个必胜状态\",{\"1\":{\"394\":1}}],[\"对于大多数情况\",{\"1\":{\"377\":1}}],[\"对于所有的点都\",{\"1\":{\"354\":1}}],[\"对于所有待遍历的节点\",{\"1\":{\"213\":1}}],[\"对于两个序列\",{\"1\":{\"340\":1}}],[\"对于两个数列\",{\"1\":{\"304\":1}}],[\"对于两个不同的行\",{\"1\":{\"288\":1,\"289\":1}}],[\"对于没有选任何数的方案\",{\"1\":{\"287\":1}}],[\"对于询问\",{\"1\":{\"273\":1}}],[\"对于我们的关于亲戚关系的提问\",{\"1\":{\"273\":1}}],[\"对于网格形式的图\",{\"1\":{\"216\":1}}],[\"对于三\",{\"1\":{\"200\":1}}],[\"对于二\",{\"1\":{\"200\":1}}],[\"对于二级的子楼层\",{\"1\":{\"56\":1}}],[\"对于一个新项目\",{\"1\":{\"541\":1}}],[\"对于一个序列\",{\"1\":{\"340\":1}}],[\"对于一个区间内的木桩\",{\"1\":{\"78\":1}}],[\"对于一般的树可能出现极端不平衡的情况\",{\"1\":{\"274\":1}}],[\"对于一\",{\"1\":{\"200\":1}}],[\"对于第二层每个元素有指针\",{\"1\":{\"958\":1}}],[\"对于第二个询问\",{\"1\":{\"196\":1}}],[\"对于第二组\",{\"1\":{\"147\":1}}],[\"对于第一个询问\",{\"1\":{\"196\":1}}],[\"对于第三组\",{\"1\":{\"147\":1}}],[\"对于第\",{\"1\":{\"146\":1}}],[\"对于尾数为\",{\"1\":{\"139\":3}}],[\"对于任何正整数\",{\"1\":{\"139\":1}}],[\"对于\",{\"1\":{\"77\":1,\"411\":1,\"783\":1,\"839\":1,\"1131\":1,\"1133\":1,\"1275\":1,\"1424\":1}}],[\"对于每两个式子\",{\"1\":{\"384\":1}}],[\"对于每批客人\",{\"1\":{\"162\":1}}],[\"对于每组数据\",{\"1\":{\"147\":1}}],[\"对于每组测试数据输出一行一个整数\",{\"1\":{\"156\":1}}],[\"对于每组测试数据输出一行答案\",{\"1\":{\"97\":1}}],[\"对于每组测试数据\",{\"1\":{\"97\":1}}],[\"对于每次询问\",{\"1\":{\"202\":1,\"305\":1}}],[\"对于每次速通记录\",{\"1\":{\"146\":1}}],[\"对于每次注册\",{\"1\":{\"88\":1}}],[\"对于每一个\",{\"1\":{\"274\":1}}],[\"对于每一个元素使用单调栈处理\",{\"1\":{\"174\":1}}],[\"对于每一个测试用例\",{\"1\":{\"127\":1}}],[\"对于每一组数据\",{\"1\":{\"66\":2}}],[\"对于每个加入的字符串我们一定能在树中找到一条路径还原它\",{\"1\":{\"802\":1}}],[\"对于每个结点\",{\"1\":{\"712\":1}}],[\"对于每个节点x\",{\"1\":{\"398\":1}}],[\"对于每个点k\",{\"1\":{\"345\":1}}],[\"对于每个询问输出一行\",{\"1\":{\"174\":1}}],[\"对于每个顾客的查询\",{\"1\":{\"168\":1}}],[\"对于每个元素\",{\"1\":{\"128\":1,\"178\":1}}],[\"对于每个可能的和\",{\"1\":{\"126\":1}}],[\"对于每个可能的位置\",{\"1\":{\"72\":1}}],[\"对于每个数字\",{\"1\":{\"135\":1}}],[\"对于每个数\",{\"1\":{\"126\":1}}],[\"对于每个完全平方数\",{\"1\":{\"115\":1}}],[\"对于每个\",{\"1\":{\"115\":1,\"129\":1,\"411\":2}}],[\"对于每个位置\",{\"1\":{\"110\":1,\"142\":1}}],[\"对于每个状态\",{\"1\":{\"109\":1}}],[\"对于每个偶数位置\",{\"1\":{\"87\":1}}],[\"对于每个奇数位置\",{\"1\":{\"87\":1}}],[\"对于每个查找操作\",{\"1\":{\"77\":1}}],[\"对于热门的主题\",{\"1\":{\"60\":1}}],[\"对于嵌套层次多的\",{\"1\":{\"56\":1}}],[\"对于入队的消息\",{\"1\":{\"49\":1}}],[\"对于写的设计上\",{\"1\":{\"49\":1}}],[\"对于重建逻辑\",{\"1\":{\"48\":1}}],[\"对于弱依赖\",{\"1\":{\"34\":1}}],[\"对于用户来说\",{\"1\":{\"28\":1}}],[\"对下游来说也是读放大\",{\"1\":{\"33\":1}}],[\"对应新节点\",{\"1\":{\"888\":1}}],[\"对应到本题中\",{\"1\":{\"772\":1}}],[\"对应返回数据对象的属性\",{\"1\":{\"592\":1}}],[\"对应官方文档\",{\"1\":{\"543\":2}}],[\"对应下标的数一一比较\",{\"1\":{\"288\":1,\"289\":1}}],[\"对应积分的列表中\",{\"1\":{\"129\":2}}],[\"对应评论内容数据\",{\"1\":{\"58\":1}}],[\"对应主题的缓存\",{\"1\":{\"58\":1}}],[\"对应的关键字\",{\"1\":{\"937\":1}}],[\"对应的节点就在右视图中\",{\"1\":{\"736\":1}}],[\"对应的就是\",{\"1\":{\"56\":1}}],[\"对应的\",{\"1\":{\"31\":1}}],[\"对应于\",{\"1\":{\"31\":4}}],[\"对应嵌套多次点击\",{\"1\":{\"30\":1}}],[\"对评论业务来说\",{\"1\":{\"25\":1}}],[\"对作品录音作品的音乐评论\",{\"1\":{\"21\":1}}],[\"编译之后\",{\"1\":{\"1431\":1}}],[\"编译器\",{\"1\":{\"1418\":1}}],[\"编译器和处理器会进行指令重排序\",{\"1\":{\"1485\":1}}],[\"编译器和处理器希望实现一个弱内存模型\",{\"1\":{\"1423\":1}}],[\"编译器和处理器希望内存模型对它们的束缚越少越好\",{\"1\":{\"1423\":1}}],[\"编译器和处理器对内存模型的实现\",{\"1\":{\"1423\":1}}],[\"编译器和处理器怎么优化都行\",{\"1\":{\"1420\":1,\"1423\":1}}],[\"编译器和处理器为了提供并行度\",{\"1\":{\"1418\":1}}],[\"编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序\",{\"1\":{\"1418\":1}}],[\"编译器和处理器在重排序时\",{\"1\":{\"1418\":1}}],[\"编译器和处理器常常会对指令进行重排序\",{\"1\":{\"1418\":1}}],[\"编译器在生成字节码时\",{\"1\":{\"1457\":1}}],[\"编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序\",{\"1\":{\"1418\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"1418\":1}}],[\"编译器优化的重排序\",{\"1\":{\"1418\":1}}],[\"编译器会在\",{\"1\":{\"1475\":1}}],[\"编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序\",{\"1\":{\"1457\":1}}],[\"编译器会直接替换成该变量的值\",{\"1\":{\"1467\":1}}],[\"编译器会根据实参的类型选择最匹配的函数来执行\",{\"1\":{\"1022\":1}}],[\"编译器会拋出\",{\"1\":{\"243\":1}}],[\"编译报错的解决方案\",{\"0\":{\"1169\":1}}],[\"编辑\",{\"1\":{\"592\":1}}],[\"编辑时间\",{\"1\":{\"510\":1,\"511\":1,\"512\":1}}],[\"编辑距离\",{\"0\":{\"305\":1}}],[\"编程\",{\"1\":{\"471\":1}}],[\"编程式判断是否有角色权限\",{\"1\":{\"467\":1}}],[\"编程式判断是否有资源权限\",{\"1\":{\"467\":1}}],[\"编程语言\",{\"0\":{\"9\":1}}],[\"编制数据目录等等\",{\"1\":{\"437\":1}}],[\"编写函数\",{\"0\":{\"1010\":1}}],[\"编写sql语句对数据表中的数据进行增删改查操作\",{\"1\":{\"910\":1}}],[\"编写全局异常处理器\",{\"1\":{\"599\":1}}],[\"编写测试类\",{\"1\":{\"567\":1}}],[\"编写移除题库题目关联接口\",{\"1\":{\"526\":1}}],[\"编写\",{\"1\":{\"181\":1}}],[\"编号\",{\"1\":{\"110\":2,\"223\":1}}],[\"编排后下发给客户端\",{\"1\":{\"25\":1}}],[\"b3\",{\"1\":{\"1069\":1}}],[\"b2\",{\"1\":{\"1069\":2}}],[\"b2​\",{\"1\":{\"103\":1,\"168\":1}}],[\"b1\",{\"1\":{\"1069\":1}}],[\"b1​\",{\"1\":{\"103\":1,\"168\":1}}],[\"bw\",{\"1\":{\"982\":3,\"1049\":3}}],[\"b+tree\",{\"1\":{\"958\":8}}],[\"bst\",{\"1\":{\"814\":1}}],[\"bsearch\",{\"1\":{\"321\":1,\"322\":1,\"325\":1}}],[\"black\",{\"1\":{\"1267\":1}}],[\"blank\",{\"1\":{\"549\":1,\"588\":1,\"592\":1}}],[\"blockingdeque\",{\"1\":{\"1326\":2}}],[\"blockingdueue\",{\"1\":{\"1326\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"1359\":1}}],[\"blockingqueue\",{\"0\":{\"1323\":1,\"1324\":1,\"1326\":1,\"1411\":1},\"1\":{\"1324\":2,\"1325\":4,\"1326\":5,\"1344\":2,\"1365\":1,\"1402\":1,\"1411\":9}}],[\"blocked\",{\"1\":{\"1259\":1,\"1329\":1,\"1334\":2,\"1431\":2}}],[\"blocker\",{\"1\":{\"1259\":4,\"1319\":1}}],[\"block\",{\"1\":{\"1049\":1,\"1242\":1,\"1340\":3}}],[\"blog\",{\"0\":{\"1130\":1},\"1\":{\"567\":1,\"576\":1,\"1140\":1,\"1171\":1}}],[\"blob\",{\"1\":{\"484\":1,\"920\":1,\"1095\":1}}],[\"bloomfilter\",{\"1\":{\"500\":1}}],[\"bloom\",{\"1\":{\"40\":1}}],[\"bcryptpasswordencoder\",{\"1\":{\"446\":5}}],[\"bcrypt\",{\"1\":{\"446\":1}}],[\"b∗x\",{\"1\":{\"388\":1}}],[\"bmin\",{\"1\":{\"1083\":1}}],[\"bmax\",{\"1\":{\"1083\":1}}],[\"bm−2\",{\"1\":{\"388\":2}}],[\"bm​\",{\"1\":{\"168\":1}}],[\"b−1\",{\"1\":{\"388\":1}}],[\"b=0\",{\"1\":{\"383\":1}}],[\"b=0\",{\"1\":{\"383\":1}}],[\"b=cn−ca\",{\"1\":{\"291\":1}}],[\"b是否连通的方法为\",{\"1\":{\"361\":1}}],[\"b不连通\",{\"1\":{\"361\":1}}],[\"b表示入点\",{\"1\":{\"354\":1}}],[\"b​\",{\"1\":{\"306\":1,\"372\":4}}],[\"b代表进制位数\",{\"1\":{\"245\":1}}],[\"b走到t后再从a这条路走到t\",{\"1\":{\"221\":1}}],[\"bfs\",{\"0\":{\"278\":1,\"279\":1,\"821\":1},\"1\":{\"180\":6,\"224\":2,\"278\":2,\"279\":2,\"742\":1,\"821\":2,\"869\":1,\"870\":2},\"2\":{\"285\":1,\"745\":1,\"824\":1,\"872\":1}}],[\"bff\",{\"0\":{\"51\":1},\"1\":{\"46\":3,\"51\":1}}],[\"bff层实现了页面请求级的热点本地缓存\",{\"1\":{\"33\":1}}],[\"bff层负责组织业务数据模型\",{\"1\":{\"25\":1}}],[\"befor\",{\"1\":{\"1432\":1}}],[\"before\",{\"0\":{\"1414\":1,\"1419\":1,\"1420\":1,\"1424\":1,\"1432\":1,\"1455\":1},\"1\":{\"1244\":3,\"1274\":2,\"1294\":1,\"1295\":1,\"1316\":1,\"1420\":16,\"1421\":14,\"1422\":1,\"1423\":4,\"1424\":2,\"1429\":1,\"1432\":11,\"1433\":3,\"1455\":10,\"1456\":1,\"1505\":1}}],[\"beforeeach\",{\"1\":{\"453\":1,\"459\":1}}],[\"bet\",{\"1\":{\"1283\":1}}],[\"better\",{\"1\":{\"1283\":1}}],[\"between\",{\"1\":{\"931\":1,\"1316\":2}}],[\"become\",{\"1\":{\"1283\":2}}],[\"because\",{\"1\":{\"1242\":2,\"1244\":1,\"1275\":1,\"1306\":1,\"1314\":1,\"1316\":1,\"1351\":1,\"1359\":1}}],[\"been\",{\"1\":{\"1252\":1,\"1315\":1,\"1316\":2}}],[\"being\",{\"1\":{\"1191\":1}}],[\"be\",{\"1\":{\"1149\":1,\"1191\":2,\"1252\":1,\"1275\":2,\"1283\":1,\"1284\":1,\"1293\":1,\"1305\":1,\"1306\":1,\"1315\":2,\"1317\":2,\"1359\":1,\"1505\":1}}],[\"best\",{\"1\":{\"541\":1}}],[\"bestfirst\",{\"1\":{\"214\":1}}],[\"beautifulgirl\",{\"1\":{\"1133\":10}}],[\"beauty\",{\"1\":{\"141\":6}}],[\"beandefinitionreader\",{\"0\":{\"1139\":1},\"1\":{\"1139\":2}}],[\"beandefinition\",{\"0\":{\"1138\":1},\"1\":{\"1137\":2,\"1138\":2,\"1139\":1}}],[\"beanfactory\",{\"0\":{\"1137\":1},\"1\":{\"1137\":4,\"1140\":3}}],[\"beanutils\",{\"1\":{\"526\":1}}],[\"bean\",{\"1\":{\"446\":3,\"465\":1,\"1100\":2,\"1137\":2,\"1138\":1}}],[\"beans\",{\"1\":{\"446\":1,\"1137\":1,\"1138\":1,\"1139\":1,\"1141\":1}}],[\"bellman\",{\"0\":{\"354\":1},\"1\":{\"351\":1,\"354\":2}}],[\"ben\",{\"1\":{\"181\":2,\"1206\":1}}],[\"beginindex\",{\"1\":{\"1005\":2}}],[\"begin\",{\"1\":{\"140\":1,\"141\":1,\"173\":1,\"174\":6,\"224\":1,\"250\":1,\"254\":1,\"256\":6,\"302\":1,\"324\":4,\"330\":1,\"341\":2,\"342\":1,\"375\":1,\"422\":4,\"423\":6,\"431\":1,\"954\":1,\"1067\":5,\"1069\":3}}],[\"boy\",{\"1\":{\"1399\":2}}],[\"both\",{\"1\":{\"1243\":1}}],[\"bottom\",{\"1\":{\"549\":1}}],[\"bourne\",{\"1\":{\"1107\":2}}],[\"bound\",{\"1\":{\"129\":2,\"174\":2,\"302\":1,\"324\":6,\"422\":8,\"423\":7,\"1274\":3}}],[\"border\",{\"1\":{\"540\":1}}],[\"box\",{\"1\":{\"540\":2}}],[\"book\",{\"0\":{\"1527\":1}}],[\"boot\",{\"1\":{\"493\":1,\"500\":1,\"634\":1,\"639\":1}}],[\"boolean>\",{\"1\":{\"784\":2}}],[\"boolean\",{\"1\":{\"98\":1,\"127\":3,\"162\":2,\"180\":2,\"187\":2,\"523\":2,\"526\":3,\"567\":1,\"578\":1,\"579\":1,\"589\":1,\"591\":1,\"688\":1,\"772\":1,\"783\":3,\"784\":3,\"801\":2,\"803\":3,\"809\":2,\"876\":6,\"899\":2,\"900\":1,\"901\":1,\"978\":1,\"992\":1,\"994\":1,\"1063\":2,\"1102\":2,\"1232\":3,\"1233\":3,\"1239\":1,\"1240\":2,\"1243\":1,\"1248\":2,\"1251\":2,\"1252\":1,\"1254\":1,\"1267\":1,\"1268\":1,\"1272\":1,\"1274\":2,\"1275\":1,\"1282\":2,\"1283\":1,\"1294\":1,\"1315\":2,\"1346\":1,\"1368\":1,\"1385\":7,\"1393\":1,\"1398\":5,\"1406\":3,\"1407\":1,\"1410\":2,\"1455\":1,\"1458\":1,\"1493\":2,\"1495\":2,\"1496\":7,\"1500\":4,\"1504\":3,\"1505\":2,\"1506\":1,\"1507\":1,\"1508\":3,\"1510\":2,\"1511\":1}}],[\"bool\",{\"1\":{\"93\":1,\"108\":1,\"173\":1,\"223\":1,\"281\":1,\"288\":1,\"291\":2,\"309\":1,\"311\":2,\"325\":1,\"328\":1,\"349\":1,\"352\":1,\"353\":1,\"355\":1,\"356\":2,\"360\":1,\"361\":1,\"362\":3,\"363\":2,\"367\":1,\"369\":1,\"371\":1,\"372\":2,\"373\":1,\"380\":1,\"390\":1,\"419\":1,\"423\":2,\"427\":1,\"428\":1,\"429\":1,\"430\":2}}],[\"body>\",{\"1\":{\"540\":1,\"548\":1}}],[\"body是函数体\",{\"1\":{\"255\":1}}],[\"body\",{\"1\":{\"255\":1,\"540\":1,\"672\":1}}],[\"bob\",{\"1\":{\"129\":1,\"1069\":1}}],[\"brokenbarrierexception\",{\"1\":{\"1393\":3}}],[\"bromon\",{\"0\":{\"1130\":1}}],[\"braumace\",{\"1\":{\"515\":1,\"517\":1,\"526\":2,\"549\":2,\"567\":3,\"568\":2,\"576\":3,\"580\":1,\"668\":1,\"672\":4}}],[\"br\",{\"1\":{\"128\":3,\"157\":3,\"981\":2,\"1049\":2}}],[\"break\",{\"0\":{\"992\":1},\"1\":{\"77\":4,\"99\":1,\"109\":1,\"129\":4,\"221\":1,\"224\":2,\"311\":1,\"362\":2,\"373\":1,\"380\":1,\"390\":1,\"392\":1,\"430\":2,\"986\":8,\"992\":1,\"994\":1,\"1020\":1,\"1251\":4,\"1271\":1,\"1272\":7,\"1275\":1,\"1511\":1}}],[\"bq​\",{\"1\":{\"103\":1}}],[\"baomidou\",{\"1\":{\"575\":1}}],[\"bash\",{\"1\":{\"1107\":7,\"1119\":1}}],[\"basiclayout>\",{\"1\":{\"548\":1}}],[\"basiclayout\",{\"1\":{\"548\":3,\"549\":1}}],[\"basecount\",{\"1\":{\"1275\":6}}],[\"baseresponse<boolean>\",{\"1\":{\"526\":1}}],[\"baseresponse<long>\",{\"1\":{\"526\":1}}],[\"baseresponse<page<question>>\",{\"1\":{\"525\":1}}],[\"baseresponse<questionbankvo>\",{\"1\":{\"523\":1}}],[\"baseentity\",{\"1\":{\"471\":2}}],[\"base\",{\"1\":{\"309\":8,\"827\":1,\"1090\":3}}],[\"based\",{\"1\":{\"77\":1,\"1408\":1}}],[\"bank\",{\"1\":{\"511\":1,\"513\":1,\"525\":1}}],[\"ban\",{\"1\":{\"510\":1}}],[\"barrieraction\",{\"1\":{\"1393\":2,\"1394\":1}}],[\"barrier\",{\"1\":{\"1393\":4}}],[\"bar\",{\"1\":{\"255\":2}}],[\"backwards\",{\"1\":{\"1506\":1}}],[\"backward\",{\"1\":{\"1317\":1}}],[\"background\",{\"1\":{\"549\":1}}],[\"backup\",{\"1\":{\"291\":5,\"354\":2,\"1504\":1}}],[\"back\",{\"1\":{\"92\":6,\"108\":1,\"110\":4,\"121\":4,\"122\":5,\"133\":2,\"141\":1,\"173\":1,\"174\":9,\"200\":1,\"298\":2,\"302\":3,\"309\":2,\"311\":1,\"327\":4,\"328\":5,\"329\":4,\"330\":4,\"342\":2,\"345\":2,\"369\":2,\"375\":2,\"390\":3,\"422\":7,\"431\":3,\"857\":1,\"1317\":1,\"1359\":1}}],[\"bab\",{\"1\":{\"71\":1}}],[\"balance\",{\"1\":{\"40\":1}}],[\"bbab\",{\"1\":{\"71\":1}}],[\"bbbab\",{\"1\":{\"71\":1}}],[\"busythread\",{\"1\":{\"1336\":9}}],[\"busythread一直执行死循环\",{\"1\":{\"1336\":1}}],[\"businesstype\",{\"1\":{\"481\":2,\"482\":2}}],[\"bug\",{\"1\":{\"1319\":1}}],[\"bunches\",{\"1\":{\"1317\":1}}],[\"but\",{\"1\":{\"1243\":1,\"1315\":2,\"1505\":1,\"1506\":1,\"1511\":1}}],[\"button>\",{\"1\":{\"457\":4}}],[\"button\",{\"1\":{\"457\":4}}],[\"bufferedwriter\",{\"1\":{\"982\":3,\"1049\":2}}],[\"bufferedreader\",{\"1\":{\"128\":2,\"157\":2,\"981\":3,\"1049\":2}}],[\"builtin\",{\"1\":{\"121\":1}}],[\"builder\",{\"1\":{\"1100\":1,\"1102\":5,\"1103\":7,\"1154\":5}}],[\"builders\",{\"1\":{\"446\":2}}],[\"buildgraph\",{\"1\":{\"875\":1}}],[\"buildtree\",{\"1\":{\"767\":2}}],[\"building\",{\"1\":{\"542\":1,\"543\":1}}],[\"buildmenus\",{\"1\":{\"462\":1}}],[\"build\",{\"0\":{\"1528\":1},\"1\":{\"60\":1,\"203\":2,\"206\":4,\"767\":8,\"1100\":1,\"1102\":5,\"1103\":7,\"1154\":1,\"1158\":3,\"1204\":1,\"1207\":1,\"1211\":1}}],[\"bucketlist\",{\"1\":{\"1102\":2}}],[\"bucket已经存在\",{\"1\":{\"1102\":1}}],[\"bucketname\",{\"1\":{\"1102\":5}}],[\"bucketexistsargs\",{\"1\":{\"1102\":2}}],[\"bucketexists\",{\"1\":{\"1102\":3}}],[\"bucket\",{\"0\":{\"1102\":1},\"1\":{\"61\":1,\"1094\":2,\"1100\":6,\"1102\":10,\"1103\":7}}],[\"b\",{\"0\":{\"247\":1},\"1\":{\"44\":1,\"56\":1,\"65\":3,\"71\":4,\"83\":8,\"92\":10,\"103\":2,\"109\":1,\"140\":2,\"141\":2,\"156\":4,\"162\":2,\"166\":5,\"167\":23,\"197\":3,\"221\":3,\"223\":8,\"245\":1,\"248\":3,\"257\":1,\"273\":5,\"279\":2,\"291\":8,\"298\":4,\"303\":6,\"304\":8,\"305\":3,\"306\":6,\"309\":8,\"314\":4,\"324\":4,\"327\":14,\"328\":28,\"329\":11,\"330\":11,\"334\":2,\"338\":5,\"345\":12,\"352\":8,\"353\":2,\"354\":9,\"355\":3,\"358\":1,\"360\":5,\"361\":6,\"372\":13,\"376\":2,\"377\":7,\"381\":2,\"383\":17,\"384\":9,\"387\":2,\"388\":13,\"389\":16,\"390\":8,\"415\":2,\"416\":1,\"417\":4,\"423\":6,\"682\":11,\"789\":2,\"808\":2,\"876\":1,\"942\":1,\"943\":1,\"978\":1,\"979\":16,\"980\":4,\"984\":21,\"985\":5,\"988\":4,\"990\":4,\"997\":1,\"998\":2,\"1000\":1,\"1004\":4,\"1005\":3,\"1021\":3,\"1022\":6,\"1055\":2,\"1069\":7,\"1072\":1,\"1080\":4,\"1145\":2,\"1221\":8,\"1274\":3,\"1275\":3,\"1283\":2,\"1284\":3,\"1285\":6,\"1313\":2,\"1384\":2,\"1387\":3,\"1417\":4,\"1418\":6,\"1420\":7,\"1421\":11,\"1423\":1,\"1432\":6,\"1433\":5,\"1439\":1,\"1449\":1,\"1455\":5,\"1456\":8,\"1475\":15,\"1476\":4,\"1478\":1,\"1482\":4,\"1485\":2}}],[\"bywave\",{\"1\":{\"661\":1}}],[\"bytes\",{\"1\":{\"920\":10}}],[\"bytecloud\",{\"1\":{\"668\":1}}],[\"bytehouse\",{\"1\":{\"639\":1}}],[\"byte\",{\"1\":{\"587\":1,\"978\":1,\"1069\":5,\"1083\":2}}],[\"bytelighting\",{\"1\":{\"567\":1}}],[\"by\",{\"1\":{\"30\":2,\"31\":1,\"40\":2,\"41\":2,\"56\":2,\"181\":1,\"248\":2,\"383\":3,\"471\":2,\"929\":4,\"933\":1,\"934\":2,\"1090\":1,\"1221\":2,\"1242\":2,\"1244\":1,\"1301\":1,\"1315\":1,\"1316\":1,\"1350\":2,\"1351\":2,\"1359\":1,\"1496\":1,\"1506\":1}}],[\"biasedlockingstartupdelay\",{\"1\":{\"1444\":1}}],[\"bigint\",{\"1\":{\"510\":1,\"511\":2,\"512\":2,\"513\":4,\"566\":2,\"920\":1}}],[\"big\",{\"0\":{\"1521\":1},\"1\":{\"434\":1,\"984\":3}}],[\"bits\",{\"1\":{\"1272\":1}}],[\"bitset<10000>\",{\"1\":{\"422\":1}}],[\"bitset\",{\"1\":{\"422\":1}}],[\"bit\",{\"1\":{\"338\":1,\"613\":1}}],[\"bitmap\",{\"1\":{\"30\":1,\"500\":1,\"613\":1}}],[\"bi\",{\"1\":{\"196\":2,\"436\":1}}],[\"bincount\",{\"1\":{\"1272\":10}}],[\"bin\",{\"1\":{\"1107\":7,\"1119\":1,\"1272\":1}}],[\"binarysearch\",{\"1\":{\"162\":2,\"1081\":1}}],[\"binlog\",{\"1\":{\"28\":1,\"31\":4,\"46\":1,\"50\":1}}],[\"bi​=1\",{\"1\":{\"168\":1}}],[\"bi​=0\",{\"1\":{\"168\":1}}],[\"bi​≤n\",{\"1\":{\"103\":1}}],[\"bi​\",{\"1\":{\"103\":1,\"162\":2,\"874\":2}}],[\"bilibili\",{\"1\":{\"41\":2}}],[\"b站千亿级点赞系统服务架构设计\",{\"1\":{\"649\":1}}],[\"b站直播s14保障全解析\",{\"1\":{\"627\":1}}],[\"b站创作端接入自研剪辑引擎\",{\"1\":{\"618\":1}}],[\"b站竟成为最大赢家\",{\"1\":{\"41\":1}}],[\"b站评论区流量巨大\",{\"1\":{\"41\":1}}],[\"b站评论系统历史悠久\",{\"1\":{\"25\":1}}],[\"b站评论系统架构设计\",{\"0\":{\"20\":1},\"1\":{\"20\":1}}],[\"b站的评论系统逐渐组件化\",{\"1\":{\"21\":1}}],[\"是带头结点的还是不带头节点的\",{\"1\":{\"1501\":1}}],[\"是单向还是双向\",{\"1\":{\"1501\":1}}],[\"是核心部分\",{\"1\":{\"1500\":1}}],[\"是个没有完全初始化的对象\",{\"1\":{\"1478\":1}}],[\"是引用数据类型呢\",{\"1\":{\"1467\":1}}],[\"是阻塞式同步\",{\"1\":{\"1453\":1}}],[\"是其他并发容器实现的基础\",{\"1\":{\"1429\":1}}],[\"是语言级的内存模型\",{\"1\":{\"1423\":1}}],[\"是特别合适的\",{\"1\":{\"1398\":1}}],[\"是不能复用的\",{\"1\":{\"1394\":1}}],[\"是不是整体的效率变高速率变快了\",{\"1\":{\"1434\":1}}],[\"是不是特殊的节点呢\",{\"1\":{\"1272\":1}}],[\"是不是刚好是\",{\"1\":{\"1271\":1}}],[\"是不是在多的一方添加外键\",{\"1\":{\"938\":1}}],[\"是不是偶数\",{\"1\":{\"338\":1}}],[\"是循环的意思\",{\"1\":{\"1393\":1}}],[\"是临界点\",{\"1\":{\"1393\":1}}],[\"是采用乐观锁策略\",{\"1\":{\"1385\":1}}],[\"是用链表实现的有界阻塞队列\",{\"1\":{\"1326\":1,\"1349\":1}}],[\"是用来初始化\",{\"1\":{\"1178\":1}}],[\"是用来构造\",{\"1\":{\"1154\":1}}],[\"是被弱引用修饰的\",{\"1\":{\"1318\":1}}],[\"是被延迟更新的\",{\"1\":{\"1283\":1}}],[\"是应该值得我们思考和注意的问题\",{\"1\":{\"1305\":1}}],[\"是弱引用\",{\"1\":{\"1305\":2}}],[\"是什么\",{\"1\":{\"1301\":1,\"1305\":1}}],[\"是什么关系呢\",{\"1\":{\"1178\":1}}],[\"是延迟更新的\",{\"1\":{\"1283\":1,\"1286\":1}}],[\"是线程安全\",{\"1\":{\"1280\":1}}],[\"是线程的阻塞原语\",{\"1\":{\"1258\":1}}],[\"是很像的\",{\"1\":{\"1274\":1}}],[\"是标准的链地址的解决方式\",{\"1\":{\"1272\":1}}],[\"是通过它提供的静态方法进行创建\",{\"1\":{\"1388\":1}}],[\"是通过判断该节点的\",{\"1\":{\"1272\":1}}],[\"是通过\",{\"1\":{\"1266\":1,\"1301\":1,\"1306\":1,\"1326\":1,\"1393\":1}}],[\"是通过获取\",{\"1\":{\"434\":1}}],[\"是绑定在一起的\",{\"1\":{\"1250\":1}}],[\"是与对象监视器配合完成线程间的等待\",{\"1\":{\"1248\":1}}],[\"是靠\",{\"1\":{\"1242\":1}}],[\"是将同步状态\",{\"1\":{\"1239\":1}}],[\"是针对获取锁而言的\",{\"1\":{\"1233\":1}}],[\"是怎么算的\",{\"1\":{\"1271\":1}}],[\"是怎么向\",{\"1\":{\"1184\":1}}],[\"是怎样实现了\",{\"1\":{\"1454\":1}}],[\"是怎样实现的\",{\"1\":{\"1232\":1}}],[\"是怎样来的\",{\"1\":{\"1301\":1}}],[\"是怎样将当前线程添加到等待队列中去的\",{\"1\":{\"1251\":1}}],[\"是基于链表数据结构的有界阻塞双端队列\",{\"1\":{\"1326\":1}}],[\"是基于\",{\"1\":{\"1205\":1}}],[\"是往哪个\",{\"1\":{\"1194\":1}}],[\"是非常粗暴的在方法上用\",{\"1\":{\"1280\":1}}],[\"是非常有意义的\",{\"1\":{\"1191\":1}}],[\"是非负整数\",{\"1\":{\"108\":1}}],[\"是拷贝副本的意思\",{\"1\":{\"1184\":1}}],[\"是会有多个\",{\"1\":{\"1157\":1}}],[\"是包含在\",{\"1\":{\"1157\":1}}],[\"是这么优秀的语言😀\",{\"1\":{\"1434\":1}}],[\"是这样定义的\",{\"1\":{\"1149\":1}}],[\"是这个评论的父评论\",{\"1\":{\"56\":1}}],[\"是屌丝的话\",{\"1\":{\"1140\":1}}],[\"是它的基本结构\",{\"1\":{\"1137\":1}}],[\"是如何将\",{\"1\":{\"1186\":1}}],[\"是如何将注册信息保存到自己注册表里面的呢\",{\"1\":{\"1184\":1}}],[\"是如何注册的呢\",{\"1\":{\"1175\":1}}],[\"是如何实现的呢\",{\"1\":{\"1132\":1}}],[\"是如何做的呢\",{\"1\":{\"1131\":1}}],[\"是由数组实现的有界阻塞队列\",{\"1\":{\"1326\":1}}],[\"是由\",{\"1\":{\"1132\":1}}],[\"是由一组\",{\"1\":{\"49\":1}}],[\"是文件名\",{\"1\":{\"1119\":1}}],[\"是第二个参数\",{\"1\":{\"1119\":1}}],[\"是第一个参数\",{\"1\":{\"1119\":1}}],[\"是第一个支持\",{\"1\":{\"1095\":1}}],[\"是我们通过命令行与操作系统沟通的语言\",{\"1\":{\"1107\":1}}],[\"是存放在了\",{\"1\":{\"1301\":1}}],[\"是存储到\",{\"1\":{\"1100\":1}}],[\"是存储\",{\"1\":{\"1100\":1}}],[\"是存在\",{\"1\":{\"49\":1}}],[\"是全世界内大家都认可的标准\",{\"1\":{\"1095\":1}}],[\"是在新的数组中插入数据的\",{\"1\":{\"1294\":1}}],[\"是在全球范围内达到共识的对象存储的协议\",{\"1\":{\"1095\":1}}],[\"是在此基础上进一步封装的高级业务组件库\",{\"1\":{\"540\":1}}],[\"是程序本身可以处理的异常\",{\"1\":{\"1042\":1}}],[\"是程序无法处理的错误\",{\"1\":{\"1042\":1}}],[\"是无法捕获处理的\",{\"1\":{\"1042\":1}}],[\"是97\",{\"1\":{\"1004\":1}}],[\"是65\",{\"1\":{\"1004\":1}}],[\"是条件表达式\",{\"1\":{\"990\":1}}],[\"是每次判断\",{\"1\":{\"988\":1}}],[\"是按照从大到小\",{\"1\":{\"958\":1}}],[\"是帮助数据库高效获取数据的数据结构\",{\"1\":{\"957\":1}}],[\"是分组之后对结果进行过滤\",{\"1\":{\"933\":1}}],[\"是分组之前进行过滤\",{\"1\":{\"933\":1}}],[\"是null\",{\"1\":{\"931\":1}}],[\"是变长字符串\",{\"1\":{\"920\":1}}],[\"是定长字符串\",{\"1\":{\"920\":1}}],[\"是固定的\",{\"1\":{\"894\":1}}],[\"是完全平方数\",{\"1\":{\"795\":1}}],[\"是同一棵树的中序遍历\",{\"1\":{\"765\":1}}],[\"是同一个级别的类型\",{\"1\":{\"351\":1}}],[\"是二叉树的先序遍历\",{\"1\":{\"765\":1}}],[\"是树中节点的个数\",{\"1\":{\"724\":1}}],[\"是路径中各节点值的总和\",{\"1\":{\"717\":1}}],[\"是因为我们不知道子树的结点数量\",{\"1\":{\"712\":1}}],[\"是数组\",{\"1\":{\"850\":1}}],[\"是数组中连续的\",{\"1\":{\"704\":1}}],[\"是数据冗余造成的\",{\"1\":{\"37\":1}}],[\"是linux\",{\"1\":{\"671\":1}}],[\"是常用的题目搜索条件\",{\"1\":{\"512\":1}}],[\"是唯一的\",{\"1\":{\"510\":2}}],[\"是为了解决cas的aba问题\",{\"1\":{\"1388\":1}}],[\"是为了解决对象不能被多线程共享访问的问题\",{\"1\":{\"1313\":1}}],[\"是为了实现公众号登录的\",{\"1\":{\"510\":1}}],[\"是为了减少一次二级索引查找\",{\"1\":{\"56\":1}}],[\"是实现了\",{\"1\":{\"1150\":1}}],[\"是实现\",{\"1\":{\"438\":1,\"1231\":1}}],[\"是指\",{\"1\":{\"1022\":1}}],[\"是指该树所有节点的左右子树的深度相差不超过\",{\"1\":{\"813\":1}}],[\"是指树中任意两个节点之间最长路径的\",{\"1\":{\"759\":1}}],[\"是指从根节点到最远叶子节点的最长路径上的节点数\",{\"1\":{\"747\":1}}],[\"是指在多个页面间复用的\",{\"1\":{\"547\":1}}],[\"是指同一套代码可以在服务端和客户端运行\",{\"1\":{\"535\":1}}],[\"是指的一个\",{\"1\":{\"465\":1}}],[\"是指规模巨大\",{\"1\":{\"434\":1}}],[\"是指迷宫的出口在地图的边界\",{\"1\":{\"237\":1}}],[\"是越界的\",{\"1\":{\"423\":1}}],[\"是堆顶\",{\"1\":{\"417\":1}}],[\"是m个有向图游戏\",{\"1\":{\"399\":1}}],[\"是质数\",{\"1\":{\"389\":1}}],[\"是增广矩阵\",{\"1\":{\"385\":1}}],[\"是满足条件的第一个数\",{\"1\":{\"373\":1}}],[\"是bellman\",{\"1\":{\"351\":1}}],[\"是的输出\",{\"1\":{\"274\":1}}],[\"是亲戚\",{\"1\":{\"273\":3}}],[\"是泛化的\",{\"1\":{\"257\":1}}],[\"是返回值类型\",{\"1\":{\"255\":1}}],[\"是函数选项\",{\"1\":{\"255\":1}}],[\"是参数表\",{\"1\":{\"255\":1}}],[\"是捕获列表\",{\"1\":{\"255\":1}}],[\"是整数\",{\"1\":{\"248\":1,\"383\":1}}],[\"是c语言标准库中的函数\",{\"1\":{\"243\":1}}],[\"是节点\",{\"1\":{\"215\":3}}],[\"是要和\",{\"1\":{\"1250\":1}}],[\"是要操作的\",{\"1\":{\"200\":1}}],[\"是要增量追加的\",{\"1\":{\"58\":1}}],[\"是否有线程正在等待获取许可证\",{\"1\":{\"1398\":1}}],[\"是否有权限执行某些操作或访问特定资源\",{\"1\":{\"445\":1}}],[\"是否减至为\",{\"1\":{\"1392\":1}}],[\"是否依赖其他系统资源\",{\"1\":{\"1361\":1}}],[\"是否是树节点\",{\"1\":{\"1272\":1}}],[\"是否启用租约过期\",{\"1\":{\"1190\":1}}],[\"是否需要抓取注册表信息等等\",{\"1\":{\"1177\":1}}],[\"是否包含子串str\",{\"1\":{\"1069\":1}}],[\"是否包含关键字\",{\"1\":{\"1040\":1}}],[\"是否包含某个元素\",{\"1\":{\"1039\":1}}],[\"是否为查找的节点\",{\"1\":{\"1273\":1}}],[\"是否为空\",{\"1\":{\"1036\":1,\"1038\":1,\"1039\":1,\"1040\":1}}],[\"是否为亲戚\",{\"1\":{\"273\":1}}],[\"是否存在默认值等信息\",{\"1\":{\"921\":1}}],[\"是否可以为null\",{\"1\":{\"921\":1}}],[\"是否可以种\",{\"1\":{\"173\":1}}],[\"是否出现在\",{\"1\":{\"783\":1}}],[\"是否已存在并得到对应的\",{\"1\":{\"687\":1}}],[\"是否允许缩略\",{\"1\":{\"592\":1}}],[\"是否允许复制\",{\"1\":{\"592\":1}}],[\"是否符合要求\",{\"1\":{\"568\":2,\"575\":1}}],[\"是否返回为true\",{\"1\":{\"567\":1}}],[\"是否要关联查询题库下的题目列表\",{\"1\":{\"523\":1}}],[\"是否要关联查询题目列表\",{\"1\":{\"523\":1}}],[\"是否删除\",{\"1\":{\"510\":1,\"511\":1,\"512\":1,\"515\":1,\"566\":2}}],[\"是否走到末尾\",{\"1\":{\"411\":1}}],[\"是否能到达\",{\"1\":{\"354\":1}}],[\"是否记下ans\",{\"1\":{\"323\":1}}],[\"是否满足条件\",{\"1\":{\"291\":1}}],[\"是否在同一集合内\",{\"1\":{\"274\":1}}],[\"是否比原来更小\",{\"1\":{\"215\":1}}],[\"是否成立\",{\"1\":{\"66\":1,\"291\":1}}],[\"是\",{\"1\":{\"127\":3,\"261\":1,\"380\":1,\"465\":3,\"540\":1,\"568\":1,\"585\":1,\"753\":1,\"838\":1,\"1081\":1,\"1089\":1,\"1094\":1,\"1182\":1,\"1250\":1,\"1305\":1,\"1338\":1}}],[\"是普通字符\",{\"1\":{\"127\":1}}],[\"是字典序最小的\",{\"1\":{\"119\":1}}],[\"是所有满足要求的排列中字典序最小的\",{\"1\":{\"119\":1}}],[\"是右括号\",{\"1\":{\"93\":1}}],[\"是左括号\",{\"1\":{\"93\":1}}],[\"是偶数\",{\"1\":{\"87\":1}}],[\"是奇数\",{\"1\":{\"87\":1}}],[\"是可见的\",{\"1\":{\"1433\":2}}],[\"是可见态才允许下发\",{\"1\":{\"36\":1}}],[\"是可以成功操作的\",{\"1\":{\"1467\":1}}],[\"是可以共享的\",{\"1\":{\"1416\":1}}],[\"是可以复用的\",{\"1\":{\"1394\":1}}],[\"是可以通过从另一个数组删除或不删除某些元素\",{\"1\":{\"850\":1}}],[\"是可根据优先级排序的队列\",{\"1\":{\"1371\":1}}],[\"是可能达到的最远和最近的位置\",{\"1\":{\"72\":1}}],[\"是有必要的\",{\"1\":{\"61\":1}}],[\"是物理组织形式存放的\",{\"1\":{\"56\":1}}],[\"是该评论的根评论\",{\"1\":{\"56\":1}}],[\"是主题类型\",{\"1\":{\"56\":1}}],[\"是主题\",{\"1\":{\"56\":1,\"58\":1}}],[\"是面向端\",{\"1\":{\"51\":1}}],[\"是做到服务里的\",{\"1\":{\"48\":1}}],[\"是敏感词过滤服务\",{\"1\":{\"46\":1}}],[\"是多数据源的\",{\"1\":{\"40\":1}}],[\"是容易出现误差累积的\",{\"1\":{\"37\":1}}],[\"是评论\",{\"1\":{\"31\":1}}],[\"是评论系统的接入层\",{\"1\":{\"25\":1}}],[\"是一类在后台运行的系统服务进程\",{\"1\":{\"671\":1}}],[\"是一类能够为一种或多种应用程序合作互通\",{\"1\":{\"14\":1}}],[\"是一条链\",{\"1\":{\"103\":1}}],[\"是一层\",{\"1\":{\"47\":1}}],[\"是一个用于线程间协作的工具类\",{\"1\":{\"1399\":1}}],[\"是一个优先级队列\",{\"1\":{\"1369\":1}}],[\"是一个基于堆的数据结构\",{\"1\":{\"1369\":1}}],[\"是一个存放实现\",{\"1\":{\"1326\":1}}],[\"是一个由链表数据结构构成的无界阻塞队列\",{\"1\":{\"1326\":1}}],[\"是一个支持优先级的无界阻塞队列\",{\"1\":{\"1326\":1}}],[\"是一个支持多家云存储驱动的公有云文件系统\",{\"1\":{\"669\":1}}],[\"是一个以\",{\"1\":{\"1305\":1}}],[\"是一个哈希桶数组\",{\"1\":{\"1272\":1}}],[\"是一个接口\",{\"1\":{\"1147\":1}}],[\"是一个非常纯粹的\",{\"1\":{\"1137\":1}}],[\"是一个高性能的分布式对象存储系统\",{\"1\":{\"1093\":1}}],[\"是一个不可分割的工作单元\",{\"1\":{\"955\":1}}],[\"是一个整数\",{\"1\":{\"794\":1}}],[\"是一个正整数\",{\"1\":{\"680\":1}}],[\"是一个轻量级的进程管理工具\",{\"1\":{\"671\":1}}],[\"是一个功能强大的\",{\"1\":{\"445\":1}}],[\"是一个质数\",{\"1\":{\"388\":1}}],[\"是一个边的集合\",{\"1\":{\"363\":1}}],[\"是一个确定的值\",{\"1\":{\"354\":1}}],[\"是一个二进制数\",{\"1\":{\"311\":1}}],[\"是一个好数组\",{\"1\":{\"122\":1}}],[\"是一个\",{\"1\":{\"31\":1,\"559\":1,\"1504\":1}}],[\"是一种乐观锁策略\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"是一种恢复丢失和损坏数据的数学算法\",{\"1\":{\"1095\":1}}],[\"是一种数据存储架构\",{\"1\":{\"1094\":1}}],[\"是一种没有重复元素的集合\",{\"1\":{\"1073\":1}}],[\"是一种通过哈希函数将键\",{\"1\":{\"971\":1}}],[\"是一种树形数据结构\",{\"1\":{\"801\":1}}],[\"是一种基于\",{\"1\":{\"674\":1}}],[\"是一种隐私保护技术\",{\"1\":{\"574\":1}}],[\"是一种将服务端渲染\",{\"1\":{\"535\":1}}],[\"是一种在构建阶段生成静态\",{\"1\":{\"534\":1}}],[\"是一种在系统软件和用户应用软件之间连接的软件\",{\"1\":{\"14\":1}}],[\"是一种能够高效存储和查找字符串集合的数据结构\",{\"1\":{\"412\":1}}],[\"是一种应用于分布式系统的基础软件\",{\"1\":{\"14\":1}}],[\"是一种独立的系统软件或服务程序\",{\"1\":{\"14\":1}}],[\"一会是编译器重排序一会是处理器重排序\",{\"1\":{\"1419\":1}}],[\"一篇文章彻底弄懂生产者\",{\"0\":{\"1402\":1}}],[\"一篇文章等\",{\"1\":{\"56\":1}}],[\"一致\",{\"1\":{\"1385\":1}}],[\"一致性\",{\"1\":{\"40\":1,\"955\":2}}],[\"一书\",{\"1\":{\"1375\":1,\"1495\":1}}],[\"一书中\",{\"1\":{\"1334\":1}}],[\"一书中有过一个实验\",{\"1\":{\"1220\":1}}],[\"一部分\",{\"1\":{\"1283\":1}}],[\"一共给我们提供了\",{\"1\":{\"1270\":1}}],[\"一共提供了如下几个构造器方法\",{\"1\":{\"1270\":1}}],[\"一共有四种操作\",{\"1\":{\"129\":1}}],[\"一共有以下模块\",{\"1\":{\"46\":1}}],[\"一张\",{\"1\":{\"1218\":1}}],[\"一切都将变得简单明了\",{\"1\":{\"1132\":1}}],[\"一种方式是\",{\"1\":{\"1416\":1}}],[\"一种是生产者线程用于生产数据\",{\"1\":{\"1402\":1}}],[\"一种特殊的返回类型是\",{\"1\":{\"1014\":1}}],[\"一种更简洁的写法是将走过的陆地都给\",{\"1\":{\"228\":1}}],[\"一门课程也可以供多个学生选择\",{\"1\":{\"939\":1}}],[\"一门操作关系型数据库的编程语言\",{\"1\":{\"907\":1}}],[\"一对一的应用场景\",{\"1\":{\"938\":1}}],[\"一对一关系表在实际开发中应用起来比较简单\",{\"1\":{\"938\":1}}],[\"一对一\",{\"0\":{\"938\":1},\"1\":{\"936\":1,\"938\":1}}],[\"一对多我们是怎么设计表关系的\",{\"1\":{\"938\":1}}],[\"一对多关系实现\",{\"1\":{\"937\":1}}],[\"一对多\",{\"0\":{\"937\":1},\"1\":{\"936\":1}}],[\"一夜之内能够偷窃到的最高金额\",{\"1\":{\"826\":1}}],[\"一位\",{\"1\":{\"698\":1}}],[\"一台国外\",{\"1\":{\"662\":1}}],[\"一台国内\",{\"1\":{\"662\":1}}],[\"一股脑全部接收\",{\"1\":{\"437\":1}}],[\"一些常见的用途有求连通子图\",{\"1\":{\"267\":1}}],[\"一些经验和技巧\",{\"0\":{\"241\":1},\"1\":{\"4\":1}}],[\"一维数组\",{\"0\":{\"996\":1}}],[\"一维差分\",{\"0\":{\"334\":1}}],[\"一维前缀和\",{\"0\":{\"332\":1}}],[\"一维优化\",{\"1\":{\"308\":1}}],[\"一维优化写法\",{\"1\":{\"298\":1}}],[\"一维\",{\"1\":{\"254\":1,\"296\":1,\"297\":1}}],[\"一维平面上有\",{\"1\":{\"166\":1}}],[\"一旦赋值后就不能再次更改\",{\"1\":{\"1467\":1}}],[\"一旦赋值之后再次赋值就会出错\",{\"1\":{\"1466\":1}}],[\"一旦锁升级成重量级锁\",{\"1\":{\"1447\":1}}],[\"一旦任务执行结束\",{\"1\":{\"1375\":1}}],[\"一旦任务积压在阻塞队列中的话就会占用过多的内存资源\",{\"1\":{\"1361\":1}}],[\"一旦执行\",{\"1\":{\"1339\":1}}],[\"一旦一个线程开始运行\",{\"1\":{\"1331\":1}}],[\"一旦调用\",{\"1\":{\"1331\":1}}],[\"一旦\",{\"1\":{\"1326\":1,\"1336\":1}}],[\"一旦创建\",{\"1\":{\"1326\":1}}],[\"一旦出现拉链过长\",{\"1\":{\"1272\":1}}],[\"一旦临界区资源被一个线程占有\",{\"1\":{\"1226\":1}}],[\"一旦产生死锁就会造成系统功能不可用\",{\"1\":{\"1221\":1}}],[\"一旦为表起了别名\",{\"1\":{\"944\":1}}],[\"一旦服务器故障\",{\"1\":{\"484\":1}}],[\"一旦程序使用长度超过\",{\"1\":{\"243\":1}}],[\"一旦到达终点\",{\"1\":{\"212\":1}}],[\"一旦到达终点便可以提前终止算法\",{\"1\":{\"212\":1}}],[\"一样的锁功能\",{\"1\":{\"1492\":1}}],[\"一样具有等待计数的功能\",{\"1\":{\"1393\":1}}],[\"一样让其他线程都停下来让你去统计\",{\"1\":{\"1275\":1}}],[\"一样\",{\"1\":{\"257\":1,\"796\":1,\"1410\":1}}],[\"一样简单的把它给\",{\"1\":{\"235\":1}}],[\"一样向外扩张\",{\"1\":{\"212\":1}}],[\"一定会先读这个包含这个\",{\"1\":{\"1475\":1}}],[\"一定是某个链表的头节点\",{\"1\":{\"789\":1}}],[\"一定是\",{\"1\":{\"772\":1}}],[\"一定是有解才有\",{\"1\":{\"221\":1}}],[\"一定不是脏\",{\"1\":{\"1316\":1}}],[\"一定不在\",{\"1\":{\"613\":1}}],[\"一定不含有奇数环\",{\"1\":{\"362\":1}}],[\"一定要注意\",{\"1\":{\"537\":1}}],[\"一定要先累加\",{\"1\":{\"360\":1}}],[\"一定等于\",{\"1\":{\"388\":1}}],[\"一定在\",{\"1\":{\"384\":1}}],[\"一定满足\",{\"1\":{\"354\":1}}],[\"一定至少存在一个入度为\",{\"1\":{\"349\":1}}],[\"一定存在整数对\",{\"1\":{\"383\":1}}],[\"一定存在整数\",{\"1\":{\"248\":1,\"383\":1}}],[\"一定命中某一个节点\",{\"1\":{\"61\":1}}],[\"一直以来\",{\"1\":{\"1218\":1}}],[\"一直递归寻找最下层的左节点\",{\"1\":{\"731\":1}}],[\"一直重复上边的过程\",{\"1\":{\"724\":1}}],[\"一直走到底层\",{\"1\":{\"301\":1}}],[\"一直找到祖先的祖先\",{\"1\":{\"270\":1}}],[\"一直达到起点\",{\"1\":{\"215\":1}}],[\"一直删到剩余的数字个数少于\",{\"1\":{\"99\":1}}],[\"一\",{\"0\":{\"977\":1,\"1145\":1,\"1176\":1},\"1\":{\"200\":1,\"299\":1,\"302\":1}}],[\"一层一层地遍历\",{\"1\":{\"133\":1}}],[\"一次性输出结果\",{\"1\":{\"128\":1}}],[\"一次性输出答案\",{\"1\":{\"128\":1}}],[\"一行一列\",{\"1\":{\"947\":1}}],[\"一行一个整数\",{\"1\":{\"146\":1}}],[\"一行\",{\"1\":{\"128\":1,\"147\":1,\"199\":1}}],[\"一行输入五个正整数\",{\"1\":{\"97\":1}}],[\"一百倍\",{\"0\":{\"76\":1}}],[\"一个锁能够防止多个线程同时访问共享资源\",{\"1\":{\"1492\":1}}],[\"一个操作一旦开始\",{\"1\":{\"1482\":1}}],[\"一个处理器的缓存回写到内存会导致其他处理器的缓存失效\",{\"1\":{\"1454\":1}}],[\"一个很经典的例子就是\",{\"1\":{\"1418\":1}}],[\"一个很酷的学习交流平台\",{\"1\":{\"587\":1}}],[\"一个好的内存模型实际上会放松对处理器和编译器规则的束缚\",{\"1\":{\"1418\":1}}],[\"一个好数组要求任意连续的\",{\"1\":{\"122\":1}}],[\"一个针对的是\",{\"1\":{\"1385\":1}}],[\"一个基友先走在前面突然看见另一个基友落在后面了\",{\"1\":{\"1337\":1}}],[\"一个基于\",{\"1\":{\"634\":1}}],[\"一个线程中的每个操作\",{\"1\":{\"1421\":1}}],[\"一个线程会继承构造它的那个线程的优先级\",{\"1\":{\"1339\":1}}],[\"一个线程的输入可能非常依赖于另一个线程的输出\",{\"1\":{\"1337\":1}}],[\"一个线程只有在调用\",{\"1\":{\"1331\":1}}],[\"一个线程被另一个线程中断\",{\"1\":{\"1045\":1}}],[\"一个可运行的线程可能正在运行\",{\"1\":{\"1331\":1}}],[\"一个静态内部类\",{\"1\":{\"1305\":1}}],[\"一个是\",{\"1\":{\"1406\":1}}],[\"一个是数据域\",{\"1\":{\"1281\":1}}],[\"一个是原链表\",{\"1\":{\"1274\":1}}],[\"一个例子\",{\"0\":{\"1254\":1,\"1260\":1,\"1449\":1,\"1458\":1,\"1496\":1},\"1\":{\"1398\":1,\"1399\":1}}],[\"一个用来刷新缓存\",{\"1\":{\"1182\":1}}],[\"一个用来心跳检测\",{\"1\":{\"1182\":1}}],[\"一个用户的事务不能被其他用户的事务干扰\",{\"1\":{\"955\":1}}],[\"一个用户只能对应一个身份证\",{\"1\":{\"938\":1}}],[\"一个对象的初始化完成\",{\"1\":{\"1421\":1}}],[\"一个对象的方式来创建对象\",{\"1\":{\"1129\":1}}],[\"一个对象会被分成\",{\"1\":{\"1095\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"1030\":1}}],[\"一个源文件可以有多个非\",{\"1\":{\"1026\":1}}],[\"一个源文件中只能有一个\",{\"1\":{\"1026\":1}}],[\"一个典型的函数定义包括以下部分\",{\"1\":{\"1009\":1}}],[\"一个不好的哈希函数可能导致性能下降\",{\"1\":{\"973\":1}}],[\"一个指针占\",{\"1\":{\"958\":1}}],[\"一个指向后\",{\"1\":{\"404\":1}}],[\"一个指向前\",{\"1\":{\"404\":1}}],[\"一个节点可以保存多个数据\",{\"1\":{\"958\":1}}],[\"一个节点下面只能有两个子节点\",{\"1\":{\"958\":1}}],[\"一个节点也可以是它自己的祖先\",{\"1\":{\"753\":1}}],[\"一个事务一旦被提交或回滚\",{\"1\":{\"955\":1}}],[\"一个事务的成功或者失败对于其他的事务是没有影响\",{\"1\":{\"955\":1}}],[\"一个事务完成之后数据都必须处于一致性状态\",{\"1\":{\"955\":1}}],[\"一个业务要发送多条\",{\"1\":{\"953\":1}}],[\"一个课程也可以供多个学生选修\",{\"1\":{\"939\":1}}],[\"一个学生可以选修多门课程\",{\"1\":{\"939\":2}}],[\"一个学生可以有多个授课老师\",{\"1\":{\"939\":1}}],[\"一个授课老师也可以有多个学生\",{\"1\":{\"939\":1}}],[\"一个哈希表\",{\"1\":{\"887\":1}}],[\"一个表示\",{\"1\":{\"886\":1}}],[\"一个字符串的子序列是指这样一个新的字符串\",{\"1\":{\"838\":1}}],[\"一个企业级高并发短链接服务项目分享\",{\"1\":{\"634\":1}}],[\"一个设置\",{\"1\":{\"575\":1}}],[\"一个简单模式的脚手架\",{\"1\":{\"559\":1}}],[\"一个题目可以属于多个题库\",{\"1\":{\"513\":1}}],[\"一个前期成本高\",{\"1\":{\"438\":1}}],[\"一个后期成本高\",{\"1\":{\"438\":1}}],[\"一个图所有匹配中\",{\"1\":{\"363\":1}}],[\"一个有向无环图\",{\"1\":{\"349\":1}}],[\"一个有趣的问题是\",{\"1\":{\"28\":1}}],[\"一个数的倍数一定是合数\",{\"1\":{\"371\":1}}],[\"一个数\",{\"1\":{\"302\":1}}],[\"一个正整数\",{\"1\":{\"291\":1,\"308\":1}}],[\"一个整数表示答案\",{\"1\":{\"280\":1}}],[\"一个整数\",{\"1\":{\"193\":1,\"288\":1,\"1045\":1}}],[\"一个名字单词以大写字母开头\",{\"1\":{\"172\":1}}],[\"一个游戏玩家有\",{\"1\":{\"142\":1}}],[\"一个长度为\",{\"1\":{\"120\":1}}],[\"一个人去做加载存储\",{\"1\":{\"60\":1}}],[\"一个主题可能是一个视频稿件\",{\"1\":{\"56\":1}}],[\"一个\",{\"1\":{\"49\":1,\"363\":1,\"488\":1,\"958\":1,\"1131\":1,\"1283\":1,\"1301\":1,\"1330\":1,\"1424\":1}}],[\"一文详解物化视图改写\",{\"1\":{\"647\":1}}],[\"一文从内容运营层面\",{\"1\":{\"39\":1}}],[\"一文所使用的sdk\",{\"1\":{\"33\":1}}],[\"一方面是审核和风控\",{\"1\":{\"36\":1}}],[\"一开始都是独立的\",{\"1\":{\"269\":1}}],[\"一开始最不习惯的就是变量命名方式的改变\",{\"1\":{\"98\":1}}],[\"一开始\",{\"1\":{\"30\":1,\"269\":1}}],[\"一般处理器不会重排序这两个操作\",{\"1\":{\"1475\":1}}],[\"一般重排序可以分为如下三种\",{\"1\":{\"1418\":1}}],[\"一般在结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源\",{\"1\":{\"1336\":1}}],[\"一般有四种方式\",{\"1\":{\"1330\":1}}],[\"一般表示为要删除的节点或者是空节点\",{\"1\":{\"1283\":1}}],[\"一般都要在\",{\"1\":{\"1406\":1,\"1407\":1}}],[\"一般都要配合一个\",{\"1\":{\"1406\":1}}],[\"一般都不推荐这种方式\",{\"1\":{\"1133\":1}}],[\"一般都是自己创建工程\",{\"1\":{\"560\":1}}],[\"一般情况下不自定义检查型异常\",{\"1\":{\"1044\":1}}],[\"一般与\",{\"1\":{\"992\":1}}],[\"一般负责修改循环变量\",{\"1\":{\"990\":1}}],[\"一般用于一组线程互相等待至某个状态\",{\"1\":{\"1394\":1}}],[\"一般用于某个线程\",{\"1\":{\"1394\":1}}],[\"一般用于凸显发评人的身份等\",{\"1\":{\"22\":1}}],[\"一般用来初始化循环变量\",{\"1\":{\"990\":1}}],[\"一般需要同时修改公共字段\",{\"1\":{\"926\":1}}],[\"一般格式为\",{\"1\":{\"598\":1}}],[\"一般可以在官方文档中搜索\",{\"1\":{\"541\":1}}],[\"一般项目不需要修改\",{\"1\":{\"539\":1}}],[\"一般由管理员维护\",{\"1\":{\"513\":1}}],[\"一般是添加一个状态标志\",{\"1\":{\"1406\":1}}],[\"一般是\",{\"1\":{\"329\":1,\"330\":1}}],[\"一般是按照主题\",{\"1\":{\"61\":1}}],[\"一般\",{\"1\":{\"242\":1,\"526\":1}}],[\"一般不需要使用分布式锁\",{\"1\":{\"60\":1}}],[\"一般会选择线程终止\",{\"1\":{\"1042\":1}}],[\"一般会存储检索\",{\"1\":{\"50\":1}}],[\"一般会使用\",{\"1\":{\"48\":1}}],[\"一般会在有评论发布或者删除时修改\",{\"1\":{\"30\":1}}],[\"一般出于性能考虑\",{\"1\":{\"37\":1}}],[\"一般采用\",{\"1\":{\"28\":1}}],[\"一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等\",{\"1\":{\"1415\":1}}],[\"一般来说会希望大家看到的评论排序都大致相同\",{\"1\":{\"40\":1}}],[\"一般来说\",{\"1\":{\"27\":1,\"40\":1,\"50\":1,\"323\":1,\"1492\":1}}],[\"一是用实参初始化函数对应的形参\",{\"1\":{\"1011\":1}}],[\"一是\",{\"1\":{\"235\":1}}],[\"一是服务编排\",{\"1\":{\"25\":1}}],[\"一是客户端的评论组件\",{\"1\":{\"25\":1}}],[\"一写一读\",{\"1\":{\"25\":1}}],[\"分代年龄和锁标记位\",{\"1\":{\"1440\":1}}],[\"分为了3种状态\",{\"1\":{\"1375\":1}}],[\"分为两步\",{\"1\":{\"1145\":1}}],[\"分为两种情况\",{\"1\":{\"380\":1}}],[\"分为两大类\",{\"1\":{\"351\":1,\"437\":1}}],[\"分为两个步骤\",{\"1\":{\"25\":1}}],[\"分发处理发送给给\",{\"1\":{\"1330\":1}}],[\"分配对象的内存空间\",{\"1\":{\"1485\":1}}],[\"分配到具体的哈希桶中去\",{\"1\":{\"1306\":1}}],[\"分配给各个线程的时间\",{\"1\":{\"1220\":1}}],[\"分散链表法使用链表解决冲突\",{\"1\":{\"1306\":1}}],[\"分离链表法示意图\",{\"1\":{\"1306\":1}}],[\"分离链表法\",{\"1\":{\"1306\":2}}],[\"分段锁的思想\",{\"1\":{\"1220\":1}}],[\"分子除以分母\",{\"1\":{\"979\":1}}],[\"分库分表等\",{\"1\":{\"910\":1}}],[\"分类\",{\"0\":{\"909\":1,\"943\":1},\"1\":{\"909\":1}}],[\"分类讨论\",{\"1\":{\"754\":2}}],[\"分钟收到客户端实例续约的总数\",{\"1\":{\"1190\":1}}],[\"分钟\",{\"1\":{\"1160\":1,\"1194\":1}}],[\"分钟开始\",{\"1\":{\"869\":1}}],[\"分钟左右就能批下来\",{\"1\":{\"672\":1}}],[\"分治\",{\"0\":{\"790\":1}}],[\"分治算法都有三步\",{\"1\":{\"317\":1}}],[\"分组之后\",{\"1\":{\"933\":1}}],[\"分组后过滤条件\",{\"1\":{\"933\":1}}],[\"分组后条件列表\",{\"1\":{\"929\":1}}],[\"分组字段\",{\"1\":{\"934\":1}}],[\"分组字段名\",{\"1\":{\"933\":1}}],[\"分组字段列表\",{\"1\":{\"929\":1}}],[\"分组其实就是按列进行分类\",{\"1\":{\"933\":1}}],[\"分组\",{\"1\":{\"933\":1}}],[\"分组查询通常会使用聚合函数进行计算\",{\"1\":{\"933\":1}}],[\"分组查询\",{\"0\":{\"933\":1},\"1\":{\"929\":1}}],[\"分组管理\",{\"1\":{\"634\":1}}],[\"分组背包\",{\"0\":{\"299\":1}}],[\"分级题目反爬虫策略\",{\"1\":{\"497\":1,\"508\":1}}],[\"分级反爬虫策略来提升系统和内容的安全性\",{\"1\":{\"493\":1}}],[\"分词题目搜索\",{\"1\":{\"497\":1,\"508\":1}}],[\"分词检索题目\",{\"1\":{\"493\":1}}],[\"分析中\",{\"1\":{\"1486\":1}}],[\"分析完\",{\"1\":{\"1456\":1}}],[\"分析并设计表结构\",{\"1\":{\"936\":1}}],[\"分析工具\",{\"1\":{\"437\":1}}],[\"分析\",{\"1\":{\"434\":1,\"439\":1,\"523\":1,\"525\":1,\"526\":1,\"1141\":1,\"1283\":1}}],[\"分析和可视化等多个方面的复杂系统\",{\"1\":{\"434\":1}}],[\"分析方面大大超出了传统数据库软件工具能力范围的数据集合\",{\"1\":{\"434\":1}}],[\"分解质因数的方式比较好用\",{\"1\":{\"390\":1}}],[\"分解质因数法求组合数\",{\"0\":{\"390\":1}}],[\"分解质因数\",{\"1\":{\"379\":1}}],[\"分成子问题\",{\"1\":{\"317\":2}}],[\"分成了\",{\"1\":{\"56\":3}}],[\"分数不考虑约分的情况\",{\"1\":{\"291\":1}}],[\"分割成若干个\",{\"1\":{\"1276\":1}}],[\"分割成两部分\",{\"1\":{\"834\":1}}],[\"分割字符串\",{\"1\":{\"1005\":1}}],[\"分割字符串的得分\",{\"1\":{\"71\":1}}],[\"分割等和子集\",{\"0\":{\"770\":1},\"1\":{\"770\":1}}],[\"分割链表\",{\"1\":{\"134\":2}}],[\"分别睡眠\",{\"1\":{\"1496\":1}}],[\"分别为\",{\"1\":{\"1292\":1}}],[\"分别保存了对应基本类型的最大值与最小值\",{\"1\":{\"1083\":1}}],[\"分别关联两方主键\",{\"1\":{\"939\":1}}],[\"分别指向原\",{\"1\":{\"888\":1}}],[\"分别记录注册和登录的请求参数\",{\"1\":{\"576\":1}}],[\"分别到达节点y1\",{\"1\":{\"398\":1}}],[\"分别适用于不同情况\",{\"1\":{\"320\":1}}],[\"分别出现且只出现一次\",{\"1\":{\"291\":1}}],[\"分别代表目标的\",{\"1\":{\"263\":1}}],[\"分别代表地图上的目标数目和正方形包含的横纵位置数量\",{\"1\":{\"263\":1}}],[\"分别代表桌子数和客人的批次\",{\"1\":{\"162\":1}}],[\"分别用来求最大元素和最小元素的值\",{\"1\":{\"256\":1}}],[\"分别用来求最大元素和最小元素的位置\",{\"1\":{\"256\":1}}],[\"分别用于存储牛可乐和牛马茶的保质期信息\",{\"1\":{\"168\":1}}],[\"分别用于存储最大和最少优惠券数\",{\"1\":{\"109\":1}}],[\"分别表示起点\",{\"1\":{\"223\":1}}],[\"分别表示工人的数量\",{\"1\":{\"173\":1}}],[\"分别表示第\",{\"1\":{\"162\":1}}],[\"分别是\",{\"1\":{\"671\":1}}],[\"分别是给定的元组集合的数量和等级差\",{\"1\":{\"140\":1}}],[\"分别是字符串\",{\"1\":{\"127\":1}}],[\"分别来转移即可\",{\"1\":{\"104\":1}}],[\"分别有他们各自的空闲日程区间列表\",{\"1\":{\"70\":1}}],[\"分\",{\"1\":{\"86\":1,\"178\":1,\"574\":1}}],[\"分页操作在业务系统开发时\",{\"1\":{\"935\":1}}],[\"分页查询是数据库的方言\",{\"1\":{\"935\":1}}],[\"分页查询语法\",{\"1\":{\"935\":1}}],[\"分页查询\",{\"0\":{\"935\":1},\"1\":{\"929\":1}}],[\"分页参数\",{\"1\":{\"929\":1}}],[\"分页获取题目列表\",{\"1\":{\"525\":1}}],[\"分页获取题目接口\",{\"1\":{\"521\":1}}],[\"分页获取题库接口\",{\"1\":{\"521\":1}}],[\"分页\",{\"1\":{\"46\":1,\"523\":1}}],[\"分片存储\",{\"1\":{\"613\":1}}],[\"分片\",{\"1\":{\"31\":1}}],[\"分享链接\",{\"1\":{\"22\":1}}],[\"分布式架构\",{\"1\":{\"642\":1}}],[\"分布式锁\",{\"1\":{\"500\":1,\"526\":1}}],[\"分布式缓存\",{\"1\":{\"500\":1}}],[\"分布式计算\",{\"1\":{\"434\":1}}],[\"分布式计算中间件等\",{\"1\":{\"14\":1}}],[\"分布式存储\",{\"1\":{\"434\":1}}],[\"分布式数据库\",{\"1\":{\"151\":1}}],[\"分布式应用软件借助这种软件在不同的技术之间共享资源\",{\"1\":{\"14\":1}}],[\"5生产数据355412953\",{\"1\":{\"1411\":1}}],[\"5生产数据\",{\"1\":{\"1411\":2}}],[\"5正在全力冲刺\",{\"1\":{\"1392\":1}}],[\"5n=1\",{\"1\":{\"1274\":1}}],[\"5n\",{\"1\":{\"1274\":3}}],[\"56\",{\"1\":{\"980\":1}}],[\"56098191\",{\"1\":{\"576\":1}}],[\"598\",{\"1\":{\"1194\":1}}],[\"59\",{\"1\":{\"920\":6,\"1069\":1,\"1317\":3}}],[\"535396055\",{\"1\":{\"1409\":1}}],[\"535\",{\"1\":{\"920\":2}}],[\"5212\",{\"1\":{\"670\":2,\"672\":1}}],[\"5个基本操作\",{\"1\":{\"417\":1}}],[\"510\",{\"1\":{\"301\":1,\"352\":1}}],[\"512\",{\"1\":{\"510\":2,\"566\":1}}],[\"512m\",{\"1\":{\"246\":1}}],[\"512<<20\",{\"1\":{\"246\":1}}],[\"5e3\",{\"1\":{\"263\":1}}],[\"57\",{\"1\":{\"1004\":1}}],[\"572\",{\"1\":{\"185\":1}}],[\"57021517\",{\"1\":{\"41\":1}}],[\"5−1=4\",{\"1\":{\"152\":1}}],[\"543\",{\"1\":{\"758\":1}}],[\"54\",{\"1\":{\"72\":1}}],[\"58同城笔试\",{\"0\":{\"69\":1}}],[\"50x\",{\"1\":{\"672\":2}}],[\"504\",{\"1\":{\"672\":1}}],[\"503\",{\"1\":{\"598\":1,\"672\":1}}],[\"502\",{\"1\":{\"598\":1,\"672\":1}}],[\"500\",{\"1\":{\"484\":1,\"598\":1,\"672\":1,\"1201\":2,\"1340\":1,\"1429\":1,\"1449\":1,\"1458\":1}}],[\"5001\",{\"1\":{\"263\":5}}],[\"50\",{\"1\":{\"56\":1,\"86\":1,\"147\":1,\"920\":1}}],[\"5\",{\"0\":{\"28\":1,\"33\":1,\"34\":1,\"217\":1,\"218\":1,\"219\":1,\"220\":1,\"246\":1,\"283\":1,\"305\":1,\"309\":1,\"331\":1,\"332\":1,\"333\":1,\"334\":1,\"335\":1,\"356\":1,\"359\":1,\"360\":1,\"361\":1,\"382\":1,\"391\":1,\"398\":1,\"412\":1,\"431\":1,\"440\":1,\"458\":1,\"459\":1,\"460\":1,\"463\":1,\"480\":1,\"519\":1,\"535\":1,\"541\":1,\"542\":1,\"543\":1,\"544\":1,\"545\":1,\"546\":2,\"590\":1,\"645\":1,\"933\":1,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"951\":1,\"982\":1,\"994\":1,\"1004\":1,\"1005\":1,\"1006\":1,\"1007\":1,\"1014\":1,\"1023\":1,\"1040\":1,\"1046\":1,\"1116\":1,\"1139\":1,\"1161\":1,\"1162\":1,\"1163\":1,\"1164\":1,\"1165\":1,\"1208\":1,\"1209\":1,\"1210\":1,\"1211\":1,\"1274\":1,\"1286\":1,\"1319\":1,\"1334\":1,\"1361\":1,\"1371\":1,\"1387\":1,\"1419\":1,\"1420\":1,\"1421\":1,\"1448\":1,\"1457\":1,\"1477\":1},\"1\":{\"22\":1,\"30\":1,\"33\":1,\"41\":1,\"60\":2,\"70\":2,\"71\":2,\"99\":3,\"104\":2,\"108\":1,\"119\":2,\"120\":1,\"121\":4,\"122\":4,\"135\":5,\"139\":2,\"141\":1,\"146\":1,\"152\":2,\"157\":2,\"179\":1,\"193\":5,\"196\":3,\"199\":4,\"221\":2,\"223\":1,\"224\":10,\"243\":1,\"261\":2,\"262\":2,\"273\":2,\"278\":2,\"279\":9,\"289\":8,\"290\":1,\"301\":2,\"327\":1,\"328\":1,\"338\":1,\"354\":1,\"417\":1,\"423\":1,\"431\":1,\"540\":1,\"568\":1,\"592\":1,\"852\":3,\"978\":1,\"980\":2,\"982\":1,\"984\":4,\"986\":1,\"990\":1,\"999\":1,\"1000\":1,\"1001\":1,\"1011\":2,\"1017\":1,\"1018\":1,\"1047\":3,\"1063\":2,\"1069\":1,\"1099\":1,\"1117\":1,\"1150\":1,\"1151\":1,\"1158\":1,\"1160\":1,\"1170\":1,\"1204\":1,\"1207\":1,\"1251\":1,\"1259\":2,\"1270\":3,\"1272\":2,\"1274\":1,\"1283\":3,\"1284\":1,\"1294\":1,\"1295\":4,\"1302\":1,\"1306\":1,\"1316\":1,\"1337\":1,\"1339\":1,\"1375\":1,\"1383\":1,\"1386\":2,\"1388\":2,\"1392\":2,\"1393\":2,\"1398\":12,\"1409\":11,\"1410\":11,\"1411\":1,\"1432\":3,\"1433\":2,\"1437\":1,\"1439\":1,\"1475\":1,\"1476\":1}}],[\"点是\",{\"1\":{\"1420\":2}}],[\"点进去看下这个方法做了什么\",{\"1\":{\"1145\":1}}],[\"点个赞吧\",{\"1\":{\"649\":1}}],[\"点\",{\"1\":{\"484\":1}}],[\"点击添加\",{\"1\":{\"676\":1}}],[\"点击登录后成功跳转到后台页面\",{\"1\":{\"591\":1}}],[\"点击登录后获取到用户信息后跳转到主页\",{\"1\":{\"589\":1}}],[\"点击登录按钮\",{\"1\":{\"447\":1}}],[\"点击注册<\",{\"1\":{\"588\":1}}],[\"点击\",{\"1\":{\"448\":1,\"665\":1,\"672\":1,\"676\":1}}],[\"点击数据需要实时处理并回传给外部广告平台\",{\"1\":{\"151\":1}}],[\"点的数量\",{\"1\":{\"353\":1}}],[\"点数和边数\",{\"1\":{\"352\":1}}],[\"点多\",{\"1\":{\"351\":1}}],[\"点少边比较多\",{\"1\":{\"351\":1}}],[\"点从\",{\"1\":{\"312\":1}}],[\"点距离最大\",{\"1\":{\"166\":1}}],[\"点距离\",{\"1\":{\"166\":2}}],[\"点体力\",{\"1\":{\"142\":1}}],[\"点踩\",{\"1\":{\"22\":1}}],[\"点赞率=点赞数\",{\"1\":{\"40\":1}}],[\"点赞数是一个频繁更新的值\",{\"1\":{\"40\":1}}],[\"点赞高\",{\"1\":{\"39\":1}}],[\"点赞\",{\"1\":{\"22\":1}}],[\"4生产数据2006106757\",{\"1\":{\"1411\":1}}],[\"4生产数据2091628867\",{\"1\":{\"1411\":1}}],[\"4生产数据1475197572\",{\"1\":{\"1411\":1}}],[\"4生产数据\",{\"1\":{\"1411\":2}}],[\"4正在全力冲刺\",{\"1\":{\"1392\":1}}],[\"47\",{\"1\":{\"1317\":2}}],[\"47043143\",{\"1\":{\"1140\":1}}],[\"41\",{\"1\":{\"1317\":3}}],[\"416\",{\"1\":{\"770\":1}}],[\"4ghz\",{\"1\":{\"1218\":2}}],[\"42\",{\"1\":{\"1012\":1,\"1317\":3}}],[\"4294967295\",{\"1\":{\"920\":1}}],[\"45\",{\"1\":{\"1005\":1}}],[\"456d\",{\"1\":{\"982\":1}}],[\"456\",{\"1\":{\"664\":12}}],[\"4bytes\",{\"1\":{\"920\":2}}],[\"437\",{\"1\":{\"879\":1}}],[\"482766516\",{\"1\":{\"1409\":1}}],[\"48\",{\"1\":{\"592\":1,\"1004\":1,\"1317\":1}}],[\"4v\",{\"1\":{\"434\":1}}],[\"402823466351\",{\"1\":{\"920\":1}}],[\"402823466\",{\"1\":{\"920\":2}}],[\"40x\",{\"1\":{\"672\":1}}],[\"404\",{\"1\":{\"598\":1,\"672\":2,\"1515\":1}}],[\"4006245\",{\"1\":{\"1319\":1}}],[\"4000\",{\"1\":{\"1207\":1,\"1211\":1}}],[\"400\",{\"1\":{\"592\":1,\"984\":1,\"985\":1}}],[\"40\",{\"1\":{\"152\":1,\"1184\":3,\"1185\":1,\"1186\":1,\"1317\":3}}],[\"406920470238773354\",{\"1\":{\"41\":1}}],[\"443\",{\"1\":{\"672\":2}}],[\"44\",{\"1\":{\"72\":1}}],[\"4\",{\"0\":{\"27\":1,\"30\":1,\"31\":1,\"216\":1,\"245\":1,\"282\":1,\"299\":1,\"304\":1,\"308\":1,\"325\":1,\"326\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":2,\"335\":1,\"350\":1,\"351\":1,\"352\":1,\"353\":1,\"354\":1,\"355\":2,\"356\":1,\"357\":1,\"358\":1,\"381\":1,\"390\":1,\"397\":1,\"411\":1,\"430\":1,\"439\":1,\"452\":1,\"453\":1,\"454\":1,\"457\":1,\"468\":1,\"479\":1,\"489\":1,\"498\":1,\"499\":1,\"500\":1,\"513\":1,\"518\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"525\":1,\"526\":1,\"534\":1,\"540\":1,\"545\":1,\"551\":1,\"558\":1,\"559\":1,\"560\":1,\"576\":1,\"589\":1,\"635\":1,\"646\":1,\"915\":1,\"923\":1,\"928\":1,\"929\":1,\"930\":1,\"931\":1,\"932\":2,\"933\":1,\"934\":1,\"935\":1,\"946\":1,\"947\":1,\"948\":1,\"949\":1,\"950\":2,\"951\":1,\"981\":1,\"991\":1,\"992\":1,\"993\":1,\"996\":1,\"997\":1,\"998\":1,\"999\":1,\"1000\":1,\"1001\":1,\"1002\":1,\"1007\":1,\"1013\":1,\"1022\":1,\"1029\":1,\"1034\":1,\"1039\":1,\"1045\":1,\"1115\":1,\"1121\":1,\"1122\":1,\"1123\":1,\"1124\":1,\"1125\":2,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":2,\"1139\":1,\"1140\":1,\"1141\":1,\"1151\":1,\"1159\":1,\"1160\":1,\"1165\":1,\"1180\":1,\"1205\":1,\"1206\":1,\"1207\":1,\"1226\":1,\"1227\":1,\"1244\":1,\"1254\":1,\"1273\":1,\"1276\":1,\"1285\":1,\"1295\":1,\"1308\":1,\"1309\":1,\"1318\":1,\"1333\":1,\"1339\":1,\"1353\":1,\"1360\":1,\"1370\":1,\"1386\":1,\"1418\":1,\"1439\":1,\"1445\":1,\"1446\":1,\"1447\":1,\"1449\":1,\"1456\":1,\"1473\":1,\"1474\":1,\"1475\":1,\"1476\":1,\"1487\":1,\"1508\":1,\"1509\":1,\"1510\":1,\"1511\":1,\"1512\":1},\"1\":{\"22\":2,\"30\":2,\"33\":1,\"39\":1,\"40\":1,\"41\":1,\"65\":3,\"71\":2,\"87\":1,\"88\":1,\"99\":2,\"104\":1,\"108\":1,\"115\":1,\"119\":1,\"121\":1,\"129\":1,\"139\":5,\"140\":1,\"142\":1,\"146\":1,\"157\":3,\"178\":1,\"180\":1,\"182\":1,\"196\":1,\"197\":1,\"199\":5,\"205\":3,\"221\":1,\"223\":1,\"224\":12,\"228\":5,\"229\":3,\"235\":3,\"236\":3,\"237\":3,\"256\":1,\"257\":2,\"261\":1,\"262\":2,\"273\":2,\"274\":4,\"278\":3,\"279\":12,\"289\":6,\"301\":3,\"304\":1,\"327\":1,\"328\":1,\"338\":7,\"354\":1,\"355\":1,\"371\":1,\"403\":1,\"417\":2,\"423\":1,\"471\":1,\"568\":3,\"574\":1,\"575\":3,\"587\":1,\"789\":1,\"794\":1,\"795\":1,\"821\":1,\"852\":4,\"868\":1,\"870\":1,\"908\":1,\"920\":3,\"978\":3,\"980\":1,\"982\":2,\"984\":2,\"985\":1,\"986\":1,\"990\":1,\"1000\":4,\"1001\":1,\"1015\":1,\"1018\":1,\"1020\":1,\"1022\":2,\"1029\":1,\"1052\":1,\"1053\":1,\"1055\":2,\"1119\":2,\"1151\":1,\"1158\":1,\"1184\":1,\"1204\":1,\"1218\":1,\"1242\":1,\"1251\":1,\"1266\":1,\"1267\":2,\"1270\":2,\"1271\":2,\"1272\":2,\"1273\":1,\"1274\":7,\"1283\":1,\"1294\":1,\"1295\":3,\"1301\":1,\"1302\":1,\"1306\":1,\"1307\":1,\"1316\":3,\"1317\":1,\"1330\":1,\"1337\":1,\"1375\":1,\"1392\":3,\"1393\":2,\"1398\":5,\"1410\":2,\"1432\":1,\"1440\":1,\"1455\":1,\"1475\":1,\"1476\":1,\"1478\":1,\"1482\":2,\"1508\":2}}],[\"3生产数据\",{\"1\":{\"1411\":2}}],[\"3生产数据906921688\",{\"1\":{\"1411\":1}}],[\"3正在全力冲刺\",{\"1\":{\"1392\":1}}],[\"3c\",{\"1\":{\"1384\":1}}],[\"34\",{\"1\":{\"1221\":1}}],[\"34+56\",{\"1\":{\"83\":1}}],[\"3<\",{\"1\":{\"1206\":1}}],[\"38\",{\"1\":{\"920\":1}}],[\"3bytes\",{\"1\":{\"920\":1}}],[\"33\",{\"1\":{\"997\":1}}],[\"3306\",{\"1\":{\"906\":1}}],[\"337\",{\"1\":{\"41\":1}}],[\"3553317334228624372l\",{\"1\":{\"576\":2}}],[\"3种初始化\",{\"0\":{\"560\":1}}],[\"3s\",{\"1\":{\"262\":1,\"1496\":1}}],[\"3×3\",{\"1\":{\"224\":3,\"279\":3}}],[\"32​\",{\"1\":{\"1306\":3}}],[\"32767\",{\"1\":{\"920\":1}}],[\"32768\",{\"1\":{\"920\":1}}],[\"322\",{\"1\":{\"891\":1}}],[\"32px\",{\"1\":{\"587\":1}}],[\"32\",{\"1\":{\"162\":1,\"704\":1,\"843\":1,\"1012\":1,\"1440\":1}}],[\"3−1=2\",{\"1\":{\"152\":1}}],[\"3≤n≤1e5\",{\"1\":{\"128\":1}}],[\"3≤n≤106\",{\"1\":{\"78\":1}}],[\"310\",{\"1\":{\"307\":1}}],[\"31\",{\"1\":{\"110\":1,\"920\":2}}],[\"3q\",{\"1\":{\"103\":1}}],[\"307680655\",{\"1\":{\"1410\":1}}],[\"304\",{\"1\":{\"1259\":1}}],[\"308\",{\"1\":{\"920\":1}}],[\"300m\",{\"1\":{\"1295\":1}}],[\"300\",{\"1\":{\"849\":1}}],[\"3000\",{\"1\":{\"304\":1,\"1221\":1,\"1260\":1,\"1406\":2,\"1496\":1}}],[\"3010\",{\"1\":{\"304\":1}}],[\"30\",{\"0\":{\"617\":1,\"653\":1},\"1\":{\"65\":2,\"289\":1,\"979\":1,\"1000\":1,\"1158\":2}}],[\"36\",{\"1\":{\"157\":1}}],[\"3650\",{\"1\":{\"65\":2}}],[\"365\",{\"1\":{\"65\":2}}],[\"360笔试\",{\"0\":{\"64\":1}}],[\"36kr\",{\"1\":{\"41\":1}}],[\"3\",{\"0\":{\"24\":1,\"25\":1,\"26\":2,\"27\":1,\"28\":1,\"41\":1,\"214\":1,\"215\":1,\"220\":1,\"244\":1,\"271\":1,\"298\":1,\"303\":1,\"307\":1,\"319\":1,\"320\":1,\"323\":1,\"324\":2,\"325\":1,\"329\":1,\"334\":1,\"339\":1,\"349\":1,\"354\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":2,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"389\":1,\"396\":1,\"408\":1,\"409\":1,\"410\":1,\"416\":1,\"421\":1,\"429\":1,\"438\":1,\"447\":1,\"448\":1,\"449\":1,\"457\":1,\"463\":1,\"467\":1,\"478\":1,\"488\":1,\"495\":1,\"496\":1,\"497\":1,\"512\":1,\"514\":1,\"515\":1,\"516\":1,\"517\":2,\"518\":1,\"519\":1,\"520\":1,\"533\":1,\"539\":1,\"544\":1,\"550\":1,\"557\":1,\"567\":1,\"575\":1,\"580\":1,\"588\":1,\"647\":1,\"914\":1,\"920\":1,\"922\":1,\"924\":1,\"925\":1,\"926\":1,\"927\":2,\"931\":1,\"939\":1,\"944\":1,\"945\":1,\"949\":1,\"955\":1,\"959\":1,\"980\":1,\"986\":1,\"988\":1,\"989\":1,\"990\":2,\"991\":1,\"992\":1,\"993\":1,\"994\":1,\"999\":1,\"1001\":1,\"1002\":1,\"1006\":1,\"1012\":1,\"1019\":1,\"1020\":1,\"1021\":1,\"1028\":1,\"1033\":1,\"1038\":1,\"1044\":1,\"1062\":1,\"1063\":1,\"1114\":1,\"1118\":1,\"1119\":1,\"1120\":1,\"1124\":1,\"1133\":1,\"1137\":1,\"1150\":1,\"1155\":1,\"1156\":1,\"1157\":1,\"1158\":1,\"1164\":1,\"1179\":1,\"1184\":1,\"1189\":1,\"1202\":1,\"1203\":1,\"1204\":1,\"1211\":1,\"1222\":1,\"1223\":1,\"1224\":1,\"1225\":2,\"1226\":1,\"1233\":1,\"1241\":1,\"1242\":1,\"1243\":1,\"1252\":1,\"1253\":1,\"1260\":1,\"1268\":1,\"1269\":1,\"1270\":1,\"1271\":1,\"1272\":2,\"1273\":1,\"1274\":1,\"1275\":1,\"1284\":1,\"1292\":1,\"1293\":1,\"1294\":1,\"1303\":1,\"1304\":1,\"1305\":1,\"1306\":1,\"1307\":2,\"1308\":1,\"1317\":1,\"1320\":1,\"1326\":1,\"1332\":1,\"1338\":1,\"1348\":1,\"1349\":1,\"1350\":1,\"1351\":1,\"1352\":2,\"1359\":1,\"1369\":1,\"1384\":1,\"1385\":1,\"1394\":1,\"1408\":1,\"1409\":1,\"1411\":1,\"1417\":1,\"1425\":1,\"1433\":1,\"1434\":1,\"1435\":1,\"1436\":1,\"1437\":1,\"1438\":2,\"1439\":1,\"1440\":1,\"1441\":2,\"1442\":2,\"1443\":2,\"1444\":3,\"1445\":1,\"1446\":1,\"1447\":1,\"1448\":1,\"1455\":1,\"1471\":1,\"1472\":1,\"1486\":1,\"1495\":1,\"1496\":1,\"1502\":1,\"1503\":1,\"1504\":1,\"1505\":1,\"1506\":1,\"1507\":2,\"1508\":1,\"1512\":1},\"1\":{\"22\":2,\"26\":1,\"30\":3,\"31\":1,\"33\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":2,\"41\":1,\"56\":2,\"70\":2,\"71\":3,\"72\":5,\"76\":1,\"87\":2,\"92\":4,\"99\":3,\"103\":1,\"104\":1,\"108\":1,\"115\":1,\"119\":3,\"121\":1,\"122\":2,\"128\":1,\"133\":2,\"139\":1,\"140\":1,\"141\":2,\"146\":3,\"147\":2,\"152\":3,\"157\":3,\"167\":3,\"178\":2,\"179\":7,\"180\":4,\"182\":8,\"193\":3,\"196\":7,\"199\":3,\"202\":3,\"205\":3,\"221\":1,\"224\":21,\"227\":1,\"234\":1,\"243\":1,\"256\":1,\"257\":2,\"261\":1,\"262\":9,\"267\":1,\"269\":1,\"273\":5,\"274\":2,\"279\":15,\"281\":7,\"287\":5,\"288\":7,\"289\":9,\"301\":1,\"304\":2,\"325\":1,\"327\":1,\"328\":1,\"338\":3,\"339\":1,\"345\":1,\"354\":1,\"355\":1,\"361\":1,\"371\":2,\"385\":1,\"390\":1,\"395\":1,\"403\":1,\"417\":2,\"422\":1,\"423\":1,\"471\":1,\"559\":2,\"568\":2,\"575\":2,\"670\":4,\"766\":2,\"789\":1,\"794\":1,\"850\":2,\"852\":3,\"908\":1,\"920\":5,\"958\":1,\"978\":2,\"980\":3,\"982\":1,\"984\":1,\"985\":1,\"986\":1,\"988\":1,\"990\":2,\"998\":1,\"1000\":3,\"1001\":1,\"1014\":1,\"1015\":1,\"1018\":1,\"1020\":1,\"1022\":2,\"1029\":1,\"1051\":1,\"1052\":1,\"1053\":1,\"1055\":2,\"1103\":1,\"1119\":2,\"1122\":1,\"1123\":1,\"1132\":1,\"1133\":1,\"1151\":1,\"1155\":1,\"1158\":1,\"1170\":1,\"1184\":1,\"1185\":1,\"1190\":1,\"1191\":1,\"1201\":1,\"1204\":1,\"1207\":1,\"1211\":1,\"1232\":2,\"1239\":5,\"1240\":1,\"1242\":2,\"1251\":2,\"1259\":1,\"1260\":1,\"1266\":1,\"1267\":1,\"1268\":1,\"1270\":3,\"1271\":1,\"1272\":2,\"1273\":1,\"1274\":3,\"1276\":1,\"1283\":4,\"1294\":1,\"1295\":4,\"1301\":1,\"1302\":1,\"1306\":3,\"1307\":1,\"1316\":5,\"1317\":2,\"1330\":2,\"1337\":1,\"1358\":1,\"1359\":2,\"1375\":1,\"1386\":1,\"1392\":2,\"1393\":2,\"1398\":5,\"1399\":1,\"1404\":1,\"1407\":1,\"1410\":2,\"1418\":3,\"1432\":1,\"1455\":3,\"1475\":1,\"1476\":3,\"1478\":1,\"1482\":2,\"1485\":2,\"1495\":1,\"1501\":1,\"1508\":10}}],[\"热门推荐\",{\"1\":{\"634\":1}}],[\"热数据\",{\"1\":{\"438\":1}}],[\"热\",{\"1\":{\"39\":1,\"493\":1}}],[\"热评\",{\"1\":{\"40\":1,\"41\":1}}],[\"热评列表都需要能够访问到全部评论\",{\"1\":{\"40\":1}}],[\"热评开始几乎完全依赖\",{\"1\":{\"40\":1}}],[\"热评用户流量大\",{\"1\":{\"39\":1}}],[\"热评排序最关键的计算模块\",{\"1\":{\"40\":1}}],[\"热评排序涉及的特征\",{\"1\":{\"40\":1}}],[\"热评排序是全排序\",{\"1\":{\"40\":1}}],[\"热评排序的挑战点主要在于\",{\"1\":{\"40\":1}}],[\"热评排序与\",{\"1\":{\"40\":1}}],[\"热评排序逻辑一般包括点赞数\",{\"1\":{\"39\":1}}],[\"热评排序等\",{\"1\":{\"37\":1}}],[\"热评设计\",{\"0\":{\"38\":1}}],[\"热评管理\",{\"1\":{\"22\":1}}],[\"热点\",{\"0\":{\"61\":1}}],[\"热点探测\",{\"1\":{\"500\":1}}],[\"热点探测的实现基于单机的滑动窗口+lfu\",{\"1\":{\"33\":1}}],[\"热点探测等性能优化手段\",{\"1\":{\"27\":1}}],[\"热点评论区发评论的tps提升了10倍以上\",{\"1\":{\"33\":1}}],[\"热度排序\",{\"1\":{\"22\":1,\"45\":1}}],[\"热题\",{\"1\":{\"6\":1}}],[\"2生产数据1724595968\",{\"1\":{\"1411\":1}}],[\"2生产数据1994678907\",{\"1\":{\"1411\":1}}],[\"2生产数据822954707\",{\"1\":{\"1411\":1}}],[\"2生产数据564860122\",{\"1\":{\"1411\":1}}],[\"2生产数据\",{\"1\":{\"1411\":2}}],[\"2正在全力冲刺\",{\"1\":{\"1392\":1}}],[\"2b\",{\"1\":{\"1384\":1}}],[\"2bytes\",{\"1\":{\"920\":1}}],[\"2秒后过期\",{\"1\":{\"1201\":1}}],[\"2>\",{\"1\":{\"1087\":2}}],[\"2d\",{\"1\":{\"978\":1}}],[\"2dust\",{\"1\":{\"665\":2}}],[\"2f\",{\"1\":{\"978\":1,\"982\":1,\"1069\":1}}],[\"28\",{\"0\":{\"619\":1}}],[\"280\",{\"1\":{\"587\":1}}],[\"245820912\",{\"1\":{\"1411\":1}}],[\"24\",{\"1\":{\"577\":1,\"691\":1,\"1467\":1}}],[\"24年秋招\",{\"1\":{\"165\":1,\"171\":1}}],[\"2^64\",{\"1\":{\"421\":2,\"920\":1}}],[\"2^31\",{\"1\":{\"110\":1}}],[\"2x+1\",{\"1\":{\"417\":1}}],[\"2x\",{\"1\":{\"417\":1}}],[\"2ll\",{\"1\":{\"372\":1}}],[\"2k\",{\"1\":{\"338\":2}}],[\"2e9\",{\"1\":{\"302\":1,\"342\":4,\"427\":1,\"430\":1,\"431\":4}}],[\"2e5+5\",{\"1\":{\"274\":1}}],[\"2e5\",{\"1\":{\"200\":1,\"223\":1,\"324\":1,\"361\":1}}],[\"295\",{\"1\":{\"920\":2}}],[\"294\",{\"1\":{\"920\":2}}],[\"29\",{\"0\":{\"618\":1},\"1\":{\"290\":1}}],[\"2∼n+1\",{\"1\":{\"290\":1}}],[\"2表示未选\",{\"1\":{\"287\":1}}],[\"232820990\",{\"1\":{\"1409\":2}}],[\"239\",{\"1\":{\"855\":1}}],[\"236\",{\"1\":{\"752\":1}}],[\"230\",{\"1\":{\"708\":1}}],[\"231−1\",{\"1\":{\"304\":1,\"899\":3}}],[\"23\",{\"0\":{\"623\":1},\"1\":{\"193\":1,\"623\":1,\"699\":1,\"787\":1,\"920\":1,\"958\":2,\"980\":1,\"1317\":3}}],[\"2≤n\",{\"1\":{\"174\":1,\"180\":1}}],[\"2≤s\",{\"1\":{\"71\":1}}],[\"22\",{\"1\":{\"1467\":2}}],[\"2250738585072014\",{\"1\":{\"920\":1}}],[\"226\",{\"1\":{\"861\":1}}],[\"222222\",{\"1\":{\"161\":1}}],[\"22−33+4∗4\",{\"1\":{\"83\":1}}],[\"22−33+44\",{\"1\":{\"83\":1}}],[\"2×m\",{\"1\":{\"147\":1}}],[\"2​<\",{\"1\":{\"146\":1}}],[\"2​\",{\"1\":{\"146\":1}}],[\"255\",{\"1\":{\"920\":4}}],[\"256\",{\"1\":{\"251\":1,\"510\":5,\"511\":1,\"512\":1,\"566\":4}}],[\"25\",{\"0\":{\"622\":1},\"1\":{\"135\":3,\"679\":1,\"1309\":1}}],[\"2个优惠券\",{\"1\":{\"109\":1}}],[\"279\",{\"1\":{\"793\":1}}],[\"27\",{\"0\":{\"620\":1},\"1\":{\"109\":1,\"140\":1,\"1283\":3}}],[\"2m​\",{\"1\":{\"87\":3}}],[\"2m+1​\",{\"1\":{\"87\":3}}],[\"2n∗0\",{\"1\":{\"1274\":1}}],[\"2n−0\",{\"1\":{\"1274\":1}}],[\"2n−1​\",{\"1\":{\"87\":1}}],[\"2n×lnp​\",{\"1\":{\"613\":1}}],[\"2n\",{\"1\":{\"384\":1,\"391\":1,\"1274\":1,\"1361\":1}}],[\"2n​\",{\"1\":{\"87\":2,\"1274\":1}}],[\"2n+1​\",{\"1\":{\"87\":1,\"179\":1}}],[\"2155\",{\"1\":{\"920\":1}}],[\"215\",{\"1\":{\"920\":2}}],[\"2147483648\",{\"1\":{\"920\":1}}],[\"2147483647\",{\"1\":{\"899\":1,\"920\":1}}],[\"21\",{\"0\":{\"624\":1},\"1\":{\"83\":1,\"109\":2,\"997\":1,\"1284\":1}}],[\"263\",{\"1\":{\"83\":2,\"920\":2}}],[\"26\",{\"0\":{\"621\":1},\"1\":{\"82\":1,\"203\":2,\"412\":1,\"802\":2,\"803\":1}}],[\"2038\",{\"1\":{\"920\":1}}],[\"207\",{\"1\":{\"873\":1}}],[\"208\",{\"1\":{\"800\":1}}],[\"20456\",{\"1\":{\"664\":4}}],[\"2048\",{\"1\":{\"511\":1}}],[\"2019\",{\"1\":{\"1309\":1}}],[\"2019年版\",{\"1\":{\"41\":1}}],[\"2012\",{\"1\":{\"1102\":1}}],[\"2010\",{\"1\":{\"298\":2}}],[\"2024\",{\"0\":{\"616\":1,\"638\":1},\"1\":{\"652\":2}}],[\"20240817143806315\",{\"1\":{\"477\":1}}],[\"2025届秋招\",{\"1\":{\"75\":1}}],[\"2020年的腾讯的辣椒酱不香了\",{\"1\":{\"33\":1}}],[\"200m\",{\"1\":{\"1295\":1}}],[\"2004年\",{\"1\":{\"1218\":1}}],[\"2000w+\",{\"1\":{\"958\":1}}],[\"20000m\",{\"1\":{\"672\":1}}],[\"2000\",{\"1\":{\"619\":1}}],[\"20005\",{\"1\":{\"273\":1}}],[\"200\",{\"1\":{\"56\":2,\"228\":1,\"598\":1,\"818\":1,\"979\":1}}],[\"20\",{\"0\":{\"625\":1},\"1\":{\"30\":1,\"88\":1,\"109\":1,\"133\":2,\"193\":1,\"261\":2,\"287\":1,\"290\":1,\"291\":1,\"312\":1,\"392\":1,\"979\":1,\"1000\":1,\"1211\":1,\"1221\":1}}],[\"2\",{\"0\":{\"25\":1,\"31\":1,\"34\":1,\"37\":1,\"40\":1,\"211\":1,\"212\":1,\"213\":2,\"214\":1,\"219\":1,\"243\":1,\"270\":1,\"297\":1,\"300\":1,\"301\":1,\"302\":2,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"312\":1,\"318\":1,\"323\":1,\"328\":1,\"333\":1,\"338\":1,\"346\":1,\"353\":1,\"357\":1,\"358\":1,\"361\":1,\"368\":1,\"372\":1,\"374\":1,\"375\":1,\"376\":2,\"377\":1,\"380\":1,\"388\":1,\"395\":1,\"404\":1,\"405\":1,\"406\":1,\"407\":1,\"410\":1,\"415\":1,\"420\":1,\"428\":1,\"435\":1,\"436\":1,\"437\":2,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"446\":1,\"449\":1,\"454\":1,\"460\":1,\"466\":1,\"471\":1,\"477\":1,\"483\":1,\"484\":1,\"485\":2,\"486\":2,\"487\":3,\"488\":2,\"489\":2,\"494\":1,\"497\":1,\"500\":1,\"508\":1,\"509\":1,\"510\":1,\"511\":2,\"512\":1,\"513\":1,\"516\":1,\"524\":1,\"525\":1,\"526\":2,\"532\":1,\"536\":1,\"537\":1,\"538\":2,\"539\":1,\"540\":1,\"541\":1,\"542\":1,\"543\":2,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"548\":1,\"549\":2,\"550\":1,\"551\":1,\"556\":1,\"560\":1,\"566\":1,\"568\":1,\"574\":1,\"577\":1,\"578\":1,\"579\":2,\"580\":1,\"586\":1,\"587\":1,\"648\":1,\"907\":1,\"908\":1,\"909\":2,\"910\":1,\"911\":1,\"912\":1,\"913\":2,\"914\":1,\"915\":1,\"916\":2,\"917\":2,\"918\":2,\"919\":3,\"920\":2,\"921\":3,\"922\":2,\"923\":2,\"926\":1,\"930\":1,\"938\":1,\"943\":1,\"948\":1,\"954\":1,\"958\":1,\"979\":1,\"984\":1,\"985\":2,\"986\":1,\"989\":1,\"993\":1,\"998\":1,\"1000\":1,\"1005\":1,\"1011\":1,\"1016\":1,\"1017\":1,\"1018\":2,\"1021\":1,\"1027\":1,\"1030\":1,\"1031\":1,\"1032\":2,\"1033\":1,\"1034\":1,\"1037\":1,\"1043\":1,\"1053\":1,\"1054\":1,\"1055\":1,\"1056\":2,\"1060\":1,\"1061\":1,\"1110\":1,\"1111\":1,\"1112\":1,\"1113\":2,\"1114\":1,\"1115\":1,\"1116\":1,\"1117\":1,\"1120\":1,\"1123\":1,\"1130\":1,\"1131\":1,\"1132\":2,\"1136\":1,\"1147\":1,\"1148\":1,\"1149\":3,\"1150\":1,\"1151\":1,\"1152\":2,\"1153\":2,\"1154\":3,\"1155\":2,\"1156\":1,\"1157\":1,\"1158\":2,\"1159\":1,\"1160\":1,\"1161\":1,\"1162\":1,\"1163\":2,\"1164\":1,\"1165\":1,\"1166\":1,\"1167\":1,\"1168\":2,\"1169\":1,\"1171\":1,\"1175\":1,\"1178\":1,\"1182\":1,\"1201\":1,\"1204\":1,\"1207\":1,\"1210\":1,\"1219\":1,\"1220\":1,\"1221\":2,\"1224\":1,\"1232\":1,\"1238\":1,\"1239\":1,\"1240\":2,\"1243\":1,\"1249\":1,\"1250\":1,\"1251\":2,\"1252\":1,\"1259\":1,\"1265\":1,\"1266\":1,\"1267\":2,\"1268\":1,\"1271\":1,\"1282\":1,\"1283\":1,\"1291\":1,\"1294\":1,\"1300\":1,\"1301\":1,\"1302\":2,\"1303\":1,\"1306\":1,\"1314\":1,\"1315\":1,\"1316\":2,\"1317\":1,\"1318\":1,\"1319\":1,\"1325\":1,\"1331\":1,\"1337\":1,\"1345\":1,\"1346\":1,\"1347\":2,\"1348\":1,\"1351\":1,\"1358\":1,\"1367\":1,\"1368\":1,\"1376\":1,\"1381\":1,\"1382\":1,\"1383\":2,\"1384\":1,\"1393\":1,\"1399\":1,\"1405\":1,\"1406\":1,\"1407\":2,\"1408\":1,\"1410\":1,\"1416\":1,\"1421\":1,\"1424\":1,\"1430\":1,\"1431\":1,\"1432\":2,\"1433\":1,\"1437\":1,\"1440\":1,\"1443\":1,\"1447\":1,\"1454\":1,\"1463\":1,\"1464\":1,\"1465\":1,\"1466\":2,\"1467\":2,\"1468\":2,\"1469\":2,\"1470\":3,\"1471\":1,\"1476\":1,\"1483\":1,\"1484\":1,\"1485\":2,\"1492\":1,\"1493\":1,\"1494\":2,\"1495\":1,\"1501\":1,\"1505\":1,\"1506\":1,\"1511\":1},\"1\":{\"22\":2,\"26\":1,\"28\":1,\"30\":3,\"31\":2,\"33\":2,\"36\":1,\"37\":3,\"39\":1,\"40\":3,\"41\":1,\"65\":1,\"66\":1,\"70\":2,\"71\":3,\"72\":7,\"76\":1,\"83\":1,\"87\":4,\"92\":2,\"99\":2,\"103\":2,\"104\":7,\"108\":1,\"109\":1,\"115\":1,\"119\":2,\"120\":2,\"121\":1,\"127\":11,\"128\":1,\"129\":5,\"134\":2,\"135\":1,\"139\":3,\"140\":1,\"141\":1,\"142\":1,\"146\":1,\"147\":11,\"152\":2,\"157\":18,\"161\":1,\"162\":2,\"166\":1,\"167\":4,\"173\":1,\"174\":5,\"178\":4,\"179\":3,\"180\":3,\"182\":4,\"193\":1,\"196\":22,\"199\":2,\"202\":1,\"205\":2,\"219\":1,\"221\":2,\"223\":7,\"224\":10,\"227\":1,\"234\":1,\"243\":1,\"251\":1,\"254\":1,\"255\":1,\"256\":6,\"257\":2,\"261\":2,\"262\":5,\"263\":1,\"267\":2,\"269\":1,\"273\":4,\"274\":9,\"279\":9,\"280\":1,\"281\":6,\"287\":5,\"288\":6,\"289\":6,\"290\":2,\"298\":2,\"301\":3,\"304\":5,\"307\":2,\"308\":4,\"309\":2,\"314\":2,\"317\":2,\"318\":1,\"322\":2,\"325\":1,\"327\":1,\"328\":2,\"332\":1,\"338\":9,\"340\":1,\"341\":1,\"345\":2,\"349\":1,\"351\":1,\"352\":1,\"354\":3,\"355\":1,\"358\":1,\"360\":2,\"361\":1,\"362\":2,\"367\":2,\"368\":1,\"369\":2,\"371\":5,\"372\":2,\"373\":1,\"376\":1,\"379\":1,\"380\":1,\"384\":1,\"385\":2,\"388\":1,\"389\":1,\"390\":2,\"392\":1,\"395\":1,\"403\":1,\"404\":1,\"411\":1,\"417\":13,\"422\":1,\"423\":1,\"428\":1,\"445\":1,\"467\":1,\"471\":3,\"477\":1,\"525\":1,\"526\":2,\"531\":1,\"537\":1,\"538\":3,\"542\":1,\"543\":1,\"568\":2,\"575\":2,\"592\":1,\"646\":2,\"697\":1,\"766\":1,\"772\":5,\"789\":1,\"815\":1,\"827\":1,\"828\":2,\"846\":22,\"850\":3,\"852\":9,\"868\":1,\"870\":4,\"888\":2,\"893\":2,\"894\":11,\"908\":1,\"920\":1,\"978\":4,\"979\":1,\"980\":4,\"982\":1,\"984\":2,\"985\":1,\"986\":1,\"988\":1,\"990\":2,\"992\":1,\"993\":1,\"994\":2,\"998\":2,\"999\":4,\"1000\":1,\"1001\":1,\"1004\":1,\"1014\":1,\"1018\":1,\"1023\":2,\"1029\":1,\"1051\":1,\"1052\":1,\"1053\":1,\"1055\":1,\"1059\":2,\"1095\":2,\"1119\":2,\"1122\":1,\"1123\":1,\"1133\":1,\"1151\":1,\"1155\":1,\"1158\":2,\"1184\":1,\"1185\":1,\"1190\":1,\"1191\":1,\"1194\":1,\"1201\":1,\"1232\":2,\"1239\":3,\"1240\":1,\"1242\":3,\"1250\":1,\"1251\":1,\"1252\":3,\"1266\":2,\"1267\":2,\"1268\":1,\"1270\":9,\"1271\":3,\"1272\":6,\"1273\":1,\"1274\":3,\"1275\":3,\"1276\":2,\"1283\":8,\"1294\":1,\"1295\":4,\"1301\":1,\"1302\":1,\"1303\":1,\"1305\":1,\"1306\":5,\"1307\":1,\"1315\":3,\"1316\":5,\"1317\":7,\"1330\":2,\"1337\":1,\"1358\":1,\"1359\":1,\"1375\":1,\"1385\":1,\"1386\":3,\"1387\":1,\"1392\":2,\"1393\":2,\"1398\":4,\"1399\":1,\"1404\":1,\"1407\":1,\"1410\":2,\"1418\":1,\"1420\":1,\"1423\":1,\"1432\":2,\"1433\":2,\"1434\":1,\"1443\":1,\"1455\":2,\"1475\":2,\"1476\":3,\"1478\":4,\"1482\":2,\"1485\":2,\"1501\":2,\"1504\":9,\"1508\":4}}],[\"1生产数据\",{\"1\":{\"1411\":1}}],[\"1生产数据369331507\",{\"1\":{\"1411\":1}}],[\"1正在全力冲刺\",{\"1\":{\"1392\":1}}],[\"1a\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"1s\",{\"1\":{\"1336\":1}}],[\"1分钟更新一次\",{\"1\":{\"1190\":1}}],[\"1~100\",{\"1\":{\"988\":1,\"990\":1,\"993\":1,\"994\":2}}],[\"1~n\",{\"1\":{\"371\":1}}],[\"1~n表示放的哪些数\",{\"1\":{\"288\":1}}],[\"1kb\",{\"1\":{\"958\":1}}],[\"1byte\",{\"1\":{\"920\":1}}],[\"1m\",{\"1\":{\"672\":1}}],[\"1l\",{\"1\":{\"517\":1,\"523\":1,\"526\":2,\"1272\":1}}],[\"1ll\",{\"1\":{\"345\":1}}],[\"1用户表\",{\"0\":{\"510\":1}}],[\"170\",{\"1\":{\"1467\":1}}],[\"1774364499\",{\"1\":{\"1411\":2}}],[\"175\",{\"1\":{\"1259\":1}}],[\"175494351\",{\"1\":{\"920\":1}}],[\"171gb\",{\"1\":{\"1095\":1}}],[\"17\",{\"1\":{\"502\":2,\"1102\":1}}],[\"1是右端点\",{\"1\":{\"404\":1}}],[\"1变0\",{\"1\":{\"337\":1}}],[\"1的最短距离\",{\"1\":{\"312\":1}}],[\"1×2\",{\"1\":{\"311\":1}}],[\"1×1\",{\"1\":{\"77\":1}}],[\"1个0\",{\"1\":{\"309\":1}}],[\"1个9\",{\"1\":{\"309\":1}}],[\"1表示不存在\",{\"1\":{\"403\":1}}],[\"1表示黑色\",{\"1\":{\"362\":1}}],[\"1表示未染色\",{\"1\":{\"362\":1}}],[\"1表示已选\",{\"1\":{\"287\":1}}],[\"1表示选中\",{\"1\":{\"109\":1}}],[\"1∼9\",{\"1\":{\"291\":3}}],[\"1∼n\",{\"1\":{\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"379\":1}}],[\"1∼8\",{\"1\":{\"224\":1,\"279\":1}}],[\"1⩽ci​⩽w⩽108\",{\"1\":{\"290\":1}}],[\"1⩽q⩽1000000\",{\"1\":{\"273\":1}}],[\"1⩽m⩽1000000\",{\"1\":{\"273\":1}}],[\"1⩽n<106\",{\"1\":{\"291\":1}}],[\"1⩽n⩽9\",{\"1\":{\"288\":1}}],[\"1⩽n⩽18\",{\"1\":{\"290\":1}}],[\"1⩽n⩽15\",{\"1\":{\"287\":1}}],[\"1⩽n⩽1000\",{\"1\":{\"280\":1}}],[\"1⩽n⩽105\",{\"1\":{\"262\":1}}],[\"1⩽n⩽10\",{\"1\":{\"262\":1}}],[\"1⩽n⩽7\",{\"1\":{\"281\":1}}],[\"1⩽n⩽20000\",{\"1\":{\"273\":1}}],[\"1⩽n\",{\"1\":{\"261\":1,\"278\":1}}],[\"1会导致数组越界\",{\"1\":{\"263\":1}}],[\"1​<ai\",{\"1\":{\"146\":1}}],[\"1​\",{\"1\":{\"146\":1}}],[\"14正在消费数据564860122\",{\"1\":{\"1411\":1}}],[\"14正在消费数据\",{\"1\":{\"1411\":2}}],[\"1432164130\",{\"1\":{\"1409\":1}}],[\"148\",{\"1\":{\"831\":1}}],[\"146\",{\"1\":{\"685\":1}}],[\"14\",{\"0\":{\"255\":1},\"1\":{\"140\":1,\"146\":1,\"223\":1,\"537\":1,\"538\":3,\"559\":1,\"920\":1,\"1145\":1,\"1284\":3,\"1418\":2}}],[\"1e\",{\"1\":{\"325\":1,\"385\":1}}],[\"1e3\",{\"1\":{\"308\":1}}],[\"1e5\",{\"1\":{\"261\":1,\"262\":1,\"263\":1,\"360\":1,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"431\":1}}],[\"1e10\",{\"1\":{\"221\":1}}],[\"1e18\",{\"1\":{\"65\":1}}],[\"1e6\",{\"1\":{\"203\":1,\"206\":1,\"327\":1}}],[\"1e9+7\",{\"1\":{\"387\":1}}],[\"1e9\",{\"1\":{\"135\":1,\"243\":1,\"301\":1,\"307\":1,\"308\":1,\"376\":1}}],[\"1<<n\",{\"1\":{\"312\":1}}],[\"1<<j\",{\"1\":{\"312\":2}}],[\"1<hi​<1e9\",{\"1\":{\"128\":1}}],[\"1<n<30000\",{\"1\":{\"104\":1}}],[\"1<n\",{\"1\":{\"77\":1}}],[\"1622505717\",{\"1\":{\"1411\":2}}],[\"1617438932\",{\"1\":{\"1409\":1}}],[\"16∗32​=10\",{\"1\":{\"1306\":1}}],[\"16384\",{\"1\":{\"958\":1}}],[\"16kb\",{\"1\":{\"958\":2}}],[\"16777215\",{\"1\":{\"920\":1}}],[\"1693717911\",{\"1\":{\"567\":1}}],[\"16937\",{\"1\":{\"567\":1,\"568\":1}}],[\"16px\",{\"1\":{\"549\":1}}],[\"16=16\",{\"1\":{\"115\":1}}],[\"16\",{\"0\":{\"257\":1,\"627\":1},\"1\":{\"115\":1,\"140\":1,\"559\":1,\"794\":1,\"795\":1,\"920\":2,\"958\":3,\"1239\":7,\"1240\":1,\"1242\":1,\"1270\":1,\"1271\":1,\"1272\":3,\"1284\":1,\"1306\":3,\"1369\":1}}],[\"1～x\",{\"1\":{\"110\":1}}],[\"183gb\",{\"1\":{\"1095\":1}}],[\"18\",{\"0\":{\"626\":1},\"1\":{\"109\":1,\"140\":1,\"499\":1,\"502\":2,\"537\":2,\"1005\":3,\"1194\":1,\"1270\":1,\"1284\":1}}],[\"1905436249\",{\"1\":{\"1410\":1}}],[\"1901\",{\"1\":{\"920\":1}}],[\"1917220008\",{\"1\":{\"1410\":1}}],[\"1961046169\",{\"1\":{\"1410\":1}}],[\"1970\",{\"1\":{\"920\":1}}],[\"199\",{\"1\":{\"734\":1}}],[\"1994\",{\"1\":{\"290\":1}}],[\"1996\",{\"1\":{\"290\":1}}],[\"198\",{\"1\":{\"139\":1,\"825\":1}}],[\"19\",{\"1\":{\"109\":1,\"196\":1,\"279\":1,\"775\":1,\"920\":1,\"1283\":2,\"1285\":2,\"1340\":1}}],[\"15正在消费数据\",{\"1\":{\"1411\":1}}],[\"1508001019\",{\"1\":{\"1410\":1}}],[\"1500$\",{\"1\":{\"133\":1}}],[\"152\",{\"1\":{\"703\":1}}],[\"15\",{\"0\":{\"256\":1},\"1\":{\"104\":1,\"133\":2,\"305\":1,\"1409\":11,\"1410\":1,\"1411\":1}}],[\"1292015016\",{\"1\":{\"1411\":1}}],[\"129343870\",{\"1\":{\"576\":1}}],[\"12正在消费数据2091628867\",{\"1\":{\"1411\":1}}],[\"12正在消费数据\",{\"1\":{\"1411\":1}}],[\"1201395916\",{\"1\":{\"1409\":1}}],[\"12010\",{\"1\":{\"298\":1}}],[\"122\",{\"1\":{\"1004\":1}}],[\"124\",{\"1\":{\"716\":1}}],[\"128\",{\"1\":{\"566\":1,\"920\":1,\"1004\":1}}],[\"1237535349\",{\"1\":{\"1409\":1}}],[\"1234\",{\"1\":{\"568\":1}}],[\"123457899\",{\"1\":{\"568\":1}}],[\"1234567891011l\",{\"1\":{\"978\":1}}],[\"123456789\",{\"1\":{\"978\":1}}],[\"12345678900\",{\"1\":{\"567\":1}}],[\"12345678\",{\"1\":{\"567\":1,\"568\":5}}],[\"12345678x\",{\"1\":{\"224\":1,\"279\":1}}],[\"123456\",{\"1\":{\"327\":1,\"328\":1}}],[\"12345\",{\"1\":{\"110\":2,\"978\":1}}],[\"123\",{\"1\":{\"251\":7,\"662\":8,\"663\":4,\"664\":12,\"978\":1,\"982\":3,\"997\":1,\"1005\":1,\"1103\":1}}],[\"1254\",{\"1\":{\"229\":1}}],[\"127809610\",{\"1\":{\"1411\":2}}],[\"1270658620\",{\"1\":{\"1410\":1}}],[\"127\",{\"1\":{\"109\":2,\"672\":1,\"906\":1,\"920\":1,\"1004\":1}}],[\"12\",{\"0\":{\"253\":1,\"629\":1,\"638\":1,\"639\":1,\"640\":1,\"641\":1,\"642\":1,\"643\":1,\"644\":1,\"645\":1,\"646\":1,\"647\":1,\"648\":1,\"649\":1},\"1\":{\"88\":2,\"99\":1,\"141\":1,\"146\":1,\"179\":1,\"290\":1,\"311\":1,\"568\":1,\"652\":1,\"920\":2,\"978\":1,\"1095\":1,\"1194\":1,\"1271\":2,\"1284\":1,\"1285\":1}}],[\"1+2\",{\"1\":{\"83\":1}}],[\"1+2+34−56\",{\"1\":{\"83\":2}}],[\"10∗1000000=10000000\",{\"1\":{\"1429\":1,\"1449\":1}}],[\"1070853639\",{\"1\":{\"1411\":1}}],[\"10正在消费数据369331507\",{\"1\":{\"1411\":1}}],[\"10×10\",{\"1\":{\"994\":1}}],[\"108\",{\"1\":{\"812\":1}}],[\"104\",{\"1\":{\"746\":1}}],[\"104+1\",{\"1\":{\"178\":1}}],[\"102\",{\"1\":{\"740\":1}}],[\"1024×768\",{\"1\":{\"1218\":1}}],[\"1024字节\",{\"1\":{\"958\":1}}],[\"1024\",{\"1\":{\"510\":1,\"512\":1,\"566\":1}}],[\"10min\",{\"1\":{\"1508\":1}}],[\"10m\",{\"1\":{\"672\":1}}],[\"10分钟入门flink\",{\"1\":{\"645\":1}}],[\"10的二进制表示为4位数\",{\"1\":{\"339\":1}}],[\"1057090222\",{\"1\":{\"1409\":1}}],[\"105\",{\"1\":{\"291\":1,\"764\":1,\"766\":1}}],[\"109\",{\"1\":{\"134\":1}}],[\"109+7\",{\"1\":{\"72\":2,\"87\":2,\"135\":1,\"167\":2,\"182\":2}}],[\"10+98+19\",{\"1\":{\"109\":1}}],[\"10+10+7\",{\"1\":{\"109\":1}}],[\"101410137\",{\"1\":{\"1410\":1}}],[\"101\",{\"1\":{\"795\":1,\"796\":1,\"806\":1}}],[\"1011\",{\"1\":{\"338\":1}}],[\"1013\",{\"0\":{\"177\":1}}],[\"1015\",{\"0\":{\"155\":1}}],[\"101000\",{\"1\":{\"339\":1}}],[\"1010\",{\"0\":{\"150\":1},\"1\":{\"194\":1,\"197\":1,\"223\":1,\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"296\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"338\":8,\"339\":2,\"699\":1}}],[\"10123\",{\"1\":{\"662\":3,\"663\":5,\"664\":4}}],[\"1012\",{\"0\":{\"96\":1,\"102\":1}}],[\"1016\",{\"0\":{\"81\":1}}],[\"10\",{\"0\":{\"251\":1,\"393\":1,\"394\":1,\"395\":1,\"396\":1,\"397\":1,\"398\":1,\"399\":1,\"423\":1,\"640\":1,\"653\":1,\"1051\":1,\"1052\":1,\"1053\":1,\"1054\":1,\"1055\":1,\"1056\":1},\"1\":{\"70\":1,\"83\":1,\"99\":1,\"109\":1,\"121\":1,\"122\":3,\"127\":1,\"135\":3,\"139\":4,\"140\":1,\"157\":1,\"167\":1,\"180\":1,\"182\":1,\"200\":1,\"203\":1,\"206\":1,\"223\":1,\"261\":1,\"262\":1,\"263\":2,\"273\":2,\"281\":1,\"288\":1,\"291\":4,\"305\":2,\"309\":12,\"324\":1,\"327\":3,\"328\":3,\"329\":2,\"330\":1,\"339\":3,\"345\":1,\"360\":1,\"361\":1,\"390\":4,\"427\":1,\"428\":1,\"429\":1,\"430\":1,\"613\":1,\"620\":1,\"621\":1,\"672\":1,\"700\":2,\"978\":1,\"979\":2,\"980\":1,\"988\":1,\"990\":3,\"994\":2,\"997\":1,\"1000\":2,\"1001\":1,\"1012\":1,\"1017\":1,\"1033\":1,\"1034\":1,\"1059\":3,\"1102\":1,\"1204\":1,\"1207\":1,\"1250\":3,\"1284\":3,\"1285\":1,\"1306\":1,\"1309\":1,\"1326\":1,\"1337\":2,\"1339\":1,\"1398\":9,\"1409\":2,\"1410\":2,\"1411\":1,\"1429\":2,\"1449\":2,\"1482\":5,\"1496\":2}}],[\"100m\",{\"1\":{\"1295\":1}}],[\"100wqps短链系统\",{\"1\":{\"634\":1}}],[\"100vh\",{\"1\":{\"540\":1}}],[\"100vw\",{\"1\":{\"540\":1}}],[\"10010\",{\"1\":{\"411\":1}}],[\"1000305429\",{\"1\":{\"1410\":1}}],[\"1000∗60∗5\",{\"1\":{\"1150\":1}}],[\"10001\",{\"1\":{\"795\":1}}],[\"100010\",{\"1\":{\"302\":2,\"339\":1,\"411\":1}}],[\"1000\",{\"0\":{\"1196\":1},\"1\":{\"338\":1,\"339\":1,\"613\":1,\"920\":2,\"958\":1,\"1059\":3,\"1063\":1,\"1150\":1,\"1160\":3,\"1196\":4,\"1201\":1,\"1336\":1,\"1482\":1}}],[\"1000000\",{\"1\":{\"1429\":2,\"1449\":2}}],[\"1000000007\",{\"1\":{\"72\":1,\"87\":1}}],[\"100000\",{\"1\":{\"1061\":1,\"1062\":2,\"1482\":3}}],[\"100007\",{\"1\":{\"196\":1,\"197\":1}}],[\"10000\",{\"1\":{\"178\":3,\"1482\":3}}],[\"100=82+1973546​\",{\"1\":{\"291\":1}}],[\"100=3+71469258​\",{\"1\":{\"291\":1}}],[\"1009\",{\"0\":{\"160\":1}}],[\"1002\",{\"0\":{\"113\":1}}],[\"100\",{\"1\":{\"6\":1,\"76\":2,\"98\":1,\"129\":1,\"179\":1,\"291\":3,\"549\":1,\"592\":2,\"958\":1,\"984\":1,\"985\":1,\"988\":1,\"990\":1,\"993\":1,\"994\":1,\"1078\":2,\"1094\":1,\"1264\":1,\"1309\":1,\"1313\":2}}],[\"13正在消费数据1475197572\",{\"1\":{\"1411\":1}}],[\"1350268764\",{\"1\":{\"1411\":2}}],[\"135w∗16\",{\"1\":{\"958\":1}}],[\"135w\",{\"1\":{\"958\":2}}],[\"133\",{\"1\":{\"1420\":1}}],[\"133137235\",{\"1\":{\"1409\":1}}],[\"13331\",{\"1\":{\"421\":1}}],[\"1365\",{\"1\":{\"1340\":1}}],[\"138\",{\"1\":{\"885\":1}}],[\"139\",{\"1\":{\"781\":1}}],[\"131\",{\"1\":{\"421\":1}}],[\"13\",{\"0\":{\"254\":1,\"628\":1},\"1\":{\"70\":1,\"99\":5,\"146\":2,\"261\":1,\"922\":2,\"1283\":3,\"1410\":2}}],[\"11正在消费数据\",{\"1\":{\"1411\":1}}],[\"11正在消费数据1967302829\",{\"1\":{\"1411\":1}}],[\"1151855115\",{\"1\":{\"1411\":1}}],[\"1170∗1170=135w\",{\"1\":{\"958\":1}}],[\"1170\",{\"1\":{\"958\":3}}],[\"1146627506\",{\"1\":{\"1410\":1}}],[\"1143\",{\"1\":{\"837\":1}}],[\"114\",{\"1\":{\"722\":1}}],[\"1111\",{\"1\":{\"338\":7,\"392\":1}}],[\"1110\",{\"1\":{\"338\":8}}],[\"1100\",{\"1\":{\"297\":1}}],[\"110\",{\"1\":{\"235\":1,\"236\":1,\"237\":1,\"278\":1,\"298\":1,\"299\":2,\"376\":1,\"978\":1,\"1194\":1}}],[\"1103515245\",{\"1\":{\"110\":2}}],[\"11\",{\"0\":{\"252\":1,\"616\":1,\"617\":1,\"618\":1,\"619\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"624\":1,\"625\":1,\"626\":1,\"627\":1,\"628\":1,\"629\":1,\"630\":2,\"631\":1,\"632\":1,\"633\":1,\"634\":1,\"635\":1,\"636\":1,\"639\":1,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":1,\"1063\":1},\"1\":{\"70\":1,\"83\":1,\"99\":2,\"115\":1,\"146\":1,\"291\":2,\"385\":1,\"502\":3,\"652\":1,\"794\":1,\"920\":1,\"922\":2,\"1000\":1,\"1001\":1,\"1285\":1,\"1309\":1}}],[\"1≤q≤1000\",{\"1\":{\"202\":1}}],[\"1≤q≤105\",{\"1\":{\"196\":1}}],[\"1≤q≤2∗105\",{\"1\":{\"199\":1}}],[\"1≤y≤m\",{\"1\":{\"196\":1}}],[\"1≤bi​\",{\"1\":{\"196\":1}}],[\"1≤wi​≤100\",{\"1\":{\"193\":1}}],[\"1≤w≤n∗m\",{\"1\":{\"141\":1}}],[\"1≤w≤s\",{\"1\":{\"126\":1}}],[\"1≤l≤100\",{\"1\":{\"223\":1}}],[\"1≤l≤r≤n\",{\"1\":{\"174\":1}}],[\"1≤li​≤ri​≤m\",{\"1\":{\"168\":1}}],[\"1≤ki​≤m\",{\"1\":{\"168\":1}}],[\"1≤k≤1000\",{\"1\":{\"223\":1}}],[\"1≤k≤min\",{\"1\":{\"141\":1}}],[\"1≤k≤n≤2×105\",{\"1\":{\"122\":1}}],[\"1≤x\",{\"1\":{\"199\":1}}],[\"1≤x≤n\",{\"1\":{\"196\":1}}],[\"1≤x≤1010\",{\"1\":{\"140\":1}}],[\"1≤xi≤n\",{\"1\":{\"157\":1}}],[\"1≤m≤50000\",{\"1\":{\"162\":1}}],[\"1≤m≤105\",{\"1\":{\"157\":1}}],[\"1≤m≤300\",{\"1\":{\"146\":1}}],[\"1≤m≤n+1\",{\"1\":{\"121\":1}}],[\"1≤s\",{\"1\":{\"223\":1}}],[\"1≤s≤900\",{\"1\":{\"126\":1}}],[\"1≤sum≤1013\",{\"1\":{\"122\":1}}],[\"1≤startpos\",{\"1\":{\"72\":1}}],[\"1≤i≤m\",{\"1\":{\"157\":1}}],[\"1≤i≤w\",{\"1\":{\"141\":1}}],[\"1≤i≤k\",{\"1\":{\"120\":1}}],[\"1≤i≤n\",{\"1\":{\"115\":1,\"122\":1}}],[\"1≤n∗m≤2∗105\",{\"1\":{\"141\":1}}],[\"1≤n≤2∗105\",{\"1\":{\"199\":1}}],[\"1≤n≤50000\",{\"1\":{\"162\":1}}],[\"1≤n≤5000001≤x≤5000000≤seed≤231−11≤m≤109\",{\"1\":{\"110\":1}}],[\"1≤n≤1000\",{\"1\":{\"202\":1}}],[\"1≤n≤103\",{\"1\":{\"193\":1}}],[\"1≤n≤1018\",{\"1\":{\"182\":1}}],[\"1≤n≤109\",{\"1\":{\"157\":1}}],[\"1≤n≤105\",{\"1\":{\"65\":1,\"66\":1,\"135\":1,\"140\":1,\"166\":1,\"172\":1,\"178\":1}}],[\"1≤n≤3000\",{\"1\":{\"304\":1}}],[\"1≤n≤300\",{\"1\":{\"146\":1}}],[\"1≤n≤30\",{\"1\":{\"126\":1}}],[\"1≤n≤7\",{\"1\":{\"121\":1}}],[\"1≤n\",{\"1\":{\"103\":1,\"141\":1,\"147\":1,\"168\":1,\"173\":1,\"196\":1}}],[\"1≤r≤10\",{\"1\":{\"97\":1}}],[\"1≤v1​\",{\"1\":{\"97\":1}}],[\"1≤h\",{\"1\":{\"97\":1}}],[\"1≤hi​≤105\",{\"1\":{\"66\":1}}],[\"1≤t≤20\",{\"1\":{\"147\":1}}],[\"1≤t≤100\",{\"1\":{\"156\":1}}],[\"1≤t≤1000\",{\"1\":{\"97\":1}}],[\"1≤t≤105\",{\"1\":{\"88\":1}}],[\"1≤t≤5\",{\"1\":{\"66\":1}}],[\"1≤ai\",{\"1\":{\"146\":1}}],[\"1≤ai≤109\",{\"1\":{\"141\":1,\"174\":1}}],[\"1≤ai​≤n\",{\"1\":{\"199\":1}}],[\"1≤ai​≤10\",{\"1\":{\"193\":1}}],[\"1≤ai​≤104\",{\"1\":{\"178\":2}}],[\"1≤ai​≤109\",{\"1\":{\"78\":1}}],[\"1≤ai​≤2×105\",{\"1\":{\"173\":1}}],[\"1≤ai​<109\",{\"1\":{\"168\":1}}],[\"1≤ai​\",{\"1\":{\"103\":1,\"196\":1}}],[\"1≤a\",{\"1\":{\"65\":1,\"156\":1,\"167\":1}}],[\"1\",{\"0\":{\"24\":1,\"30\":1,\"33\":1,\"36\":1,\"39\":1,\"210\":1,\"212\":1,\"218\":1,\"242\":1,\"253\":1,\"269\":1,\"295\":1,\"296\":2,\"297\":1,\"298\":1,\"299\":1,\"301\":1,\"311\":1,\"314\":1,\"317\":1,\"320\":1,\"327\":1,\"332\":1,\"337\":1,\"345\":1,\"351\":1,\"352\":2,\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"360\":1,\"366\":1,\"367\":2,\"368\":1,\"370\":1,\"371\":2,\"372\":1,\"373\":1,\"375\":1,\"379\":1,\"387\":1,\"394\":1,\"402\":1,\"403\":2,\"404\":1,\"406\":1,\"407\":1,\"409\":1,\"414\":1,\"419\":1,\"426\":1,\"427\":2,\"428\":1,\"429\":1,\"430\":1,\"431\":1,\"434\":1,\"436\":1,\"445\":1,\"448\":1,\"453\":1,\"459\":1,\"465\":1,\"470\":1,\"475\":1,\"476\":2,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"484\":1,\"486\":1,\"493\":1,\"496\":1,\"499\":1,\"506\":1,\"507\":2,\"508\":1,\"515\":1,\"522\":1,\"523\":2,\"525\":1,\"530\":1,\"531\":2,\"532\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":1,\"542\":1,\"548\":1,\"555\":1,\"559\":1,\"564\":1,\"565\":2,\"566\":1,\"567\":1,\"572\":1,\"573\":2,\"574\":1,\"575\":1,\"576\":1,\"578\":1,\"584\":1,\"585\":2,\"586\":1,\"636\":1,\"649\":1,\"905\":1,\"906\":2,\"907\":1,\"908\":2,\"909\":1,\"911\":1,\"912\":2,\"913\":1,\"914\":1,\"915\":1,\"917\":1,\"918\":2,\"919\":1,\"920\":1,\"925\":1,\"929\":1,\"937\":1,\"941\":1,\"942\":2,\"943\":1,\"947\":1,\"953\":1,\"957\":1,\"963\":1,\"967\":1,\"978\":2,\"979\":1,\"980\":1,\"981\":1,\"982\":1,\"984\":1,\"988\":1,\"992\":1,\"996\":1,\"997\":2,\"998\":1,\"999\":1,\"1004\":1,\"1009\":1,\"1010\":2,\"1011\":1,\"1012\":1,\"1013\":1,\"1014\":1,\"1015\":1,\"1017\":1,\"1020\":1,\"1025\":1,\"1026\":2,\"1027\":1,\"1028\":1,\"1029\":1,\"1031\":1,\"1036\":1,\"1042\":1,\"1051\":1,\"1052\":2,\"1053\":1,\"1055\":1,\"1058\":1,\"1059\":2,\"1060\":1,\"1063\":1,\"1108\":1,\"1109\":2,\"1110\":1,\"1112\":1,\"1119\":1,\"1122\":1,\"1129\":1,\"1131\":1,\"1135\":1,\"1144\":1,\"1147\":1,\"1148\":2,\"1150\":1,\"1151\":1,\"1153\":1,\"1157\":1,\"1160\":1,\"1162\":1,\"1167\":1,\"1170\":1,\"1177\":2,\"1178\":1,\"1179\":1,\"1180\":1,\"1182\":1,\"1184\":1,\"1200\":1,\"1203\":1,\"1206\":1,\"1209\":1,\"1218\":1,\"1220\":1,\"1223\":1,\"1231\":1,\"1237\":1,\"1239\":1,\"1242\":1,\"1248\":1,\"1250\":1,\"1258\":1,\"1264\":1,\"1266\":1,\"1270\":1,\"1280\":1,\"1281\":2,\"1282\":1,\"1290\":1,\"1293\":1,\"1299\":1,\"1301\":1,\"1305\":1,\"1313\":1,\"1315\":1,\"1324\":1,\"1330\":1,\"1336\":1,\"1344\":1,\"1346\":1,\"1350\":1,\"1357\":1,\"1365\":1,\"1366\":2,\"1367\":1,\"1375\":1,\"1380\":1,\"1382\":1,\"1392\":1,\"1398\":1,\"1403\":1,\"1404\":2,\"1405\":1,\"1406\":2,\"1407\":1,\"1408\":1,\"1409\":1,\"1415\":1,\"1420\":1,\"1423\":1,\"1429\":1,\"1431\":1,\"1435\":1,\"1436\":2,\"1437\":1,\"1438\":1,\"1439\":1,\"1442\":1,\"1446\":1,\"1453\":1,\"1462\":1,\"1464\":1,\"1465\":2,\"1466\":1,\"1467\":1,\"1469\":1,\"1474\":1,\"1475\":2,\"1476\":1,\"1482\":1,\"1484\":1,\"1491\":1,\"1493\":1,\"1500\":1,\"1503\":1,\"1504\":2,\"1505\":1,\"1510\":1},\"1\":{\"22\":2,\"26\":1,\"28\":1,\"30\":3,\"31\":2,\"33\":3,\"36\":1,\"37\":4,\"39\":1,\"40\":3,\"41\":1,\"65\":7,\"66\":25,\"70\":2,\"71\":7,\"72\":24,\"77\":19,\"82\":6,\"83\":1,\"87\":10,\"92\":6,\"97\":6,\"99\":6,\"103\":4,\"104\":28,\"108\":9,\"109\":8,\"110\":10,\"115\":10,\"119\":7,\"120\":49,\"121\":10,\"122\":3,\"126\":16,\"127\":35,\"128\":5,\"129\":8,\"134\":3,\"135\":7,\"139\":8,\"141\":9,\"142\":12,\"146\":2,\"147\":5,\"152\":8,\"156\":1,\"157\":16,\"161\":5,\"162\":9,\"166\":1,\"167\":6,\"172\":1,\"173\":5,\"174\":26,\"178\":9,\"179\":2,\"180\":15,\"182\":11,\"193\":2,\"194\":6,\"196\":22,\"197\":11,\"199\":6,\"200\":2,\"202\":1,\"203\":1,\"205\":2,\"206\":30,\"221\":2,\"223\":7,\"224\":17,\"227\":1,\"228\":23,\"229\":10,\"230\":6,\"234\":1,\"235\":7,\"236\":9,\"237\":12,\"242\":3,\"243\":1,\"244\":3,\"245\":1,\"248\":1,\"251\":1,\"252\":2,\"253\":2,\"254\":5,\"255\":4,\"256\":1,\"257\":2,\"261\":11,\"262\":7,\"263\":13,\"267\":2,\"269\":2,\"273\":6,\"274\":12,\"278\":29,\"279\":16,\"280\":4,\"281\":8,\"287\":10,\"288\":11,\"289\":14,\"290\":6,\"291\":5,\"296\":5,\"297\":4,\"298\":9,\"299\":2,\"301\":20,\"302\":14,\"303\":14,\"304\":11,\"305\":15,\"306\":22,\"307\":17,\"308\":15,\"309\":20,\"311\":11,\"312\":8,\"314\":14,\"317\":5,\"318\":3,\"321\":6,\"322\":7,\"323\":3,\"327\":4,\"328\":7,\"329\":3,\"330\":4,\"332\":2,\"333\":4,\"334\":1,\"335\":4,\"338\":38,\"339\":9,\"340\":2,\"341\":4,\"345\":9,\"347\":1,\"348\":3,\"349\":5,\"351\":1,\"352\":9,\"353\":5,\"354\":6,\"355\":7,\"356\":3,\"358\":6,\"359\":1,\"360\":6,\"361\":5,\"362\":7,\"363\":2,\"368\":2,\"369\":4,\"371\":6,\"372\":1,\"373\":1,\"375\":1,\"376\":7,\"379\":3,\"380\":11,\"381\":9,\"383\":2,\"384\":7,\"385\":5,\"387\":4,\"388\":7,\"389\":8,\"390\":2,\"391\":1,\"392\":9,\"403\":2,\"404\":2,\"407\":1,\"409\":1,\"410\":1,\"411\":5,\"414\":1,\"415\":2,\"416\":1,\"417\":12,\"419\":1,\"421\":6,\"422\":2,\"423\":14,\"427\":4,\"428\":5,\"430\":2,\"445\":1,\"467\":1,\"471\":1,\"477\":1,\"526\":1,\"531\":1,\"542\":1,\"543\":1,\"566\":6,\"567\":1,\"568\":23,\"575\":8,\"580\":1,\"587\":1,\"592\":3,\"596\":3,\"613\":7,\"672\":2,\"681\":1,\"686\":2,\"687\":2,\"688\":2,\"699\":2,\"700\":1,\"705\":2,\"709\":1,\"712\":5,\"713\":4,\"723\":1,\"724\":1,\"736\":2,\"748\":1,\"761\":1,\"766\":5,\"767\":13,\"772\":1,\"777\":4,\"783\":1,\"784\":1,\"789\":4,\"794\":1,\"795\":11,\"796\":5,\"797\":4,\"802\":1,\"813\":1,\"815\":3,\"819\":1,\"820\":5,\"821\":7,\"822\":13,\"827\":3,\"828\":4,\"833\":1,\"839\":2,\"840\":20,\"845\":7,\"846\":29,\"850\":1,\"852\":14,\"868\":2,\"869\":1,\"870\":19,\"874\":3,\"875\":5,\"876\":1,\"882\":3,\"886\":1,\"888\":3,\"892\":1,\"893\":10,\"894\":10,\"901\":3,\"906\":1,\"908\":1,\"919\":1,\"920\":7,\"926\":1,\"935\":1,\"972\":1,\"978\":5,\"980\":2,\"982\":1,\"984\":9,\"985\":1,\"986\":1,\"988\":7,\"989\":4,\"990\":7,\"992\":1,\"993\":2,\"994\":1,\"998\":2,\"999\":8,\"1000\":1,\"1001\":1,\"1005\":1,\"1007\":1,\"1010\":2,\"1011\":2,\"1014\":1,\"1015\":1,\"1018\":2,\"1020\":5,\"1023\":2,\"1029\":1,\"1048\":1,\"1051\":1,\"1052\":1,\"1053\":1,\"1055\":1,\"1059\":2,\"1069\":5,\"1070\":2,\"1072\":6,\"1073\":4,\"1074\":10,\"1075\":6,\"1076\":5,\"1077\":6,\"1078\":1,\"1080\":1,\"1081\":1,\"1087\":2,\"1103\":1,\"1119\":2,\"1122\":2,\"1123\":2,\"1124\":1,\"1125\":1,\"1132\":1,\"1133\":1,\"1151\":1,\"1155\":1,\"1158\":3,\"1170\":2,\"1184\":1,\"1185\":1,\"1190\":1,\"1191\":1,\"1193\":1,\"1203\":1,\"1221\":4,\"1232\":3,\"1239\":7,\"1240\":1,\"1242\":7,\"1243\":2,\"1250\":1,\"1251\":3,\"1252\":3,\"1259\":3,\"1264\":3,\"1266\":1,\"1267\":2,\"1268\":1,\"1270\":9,\"1271\":3,\"1272\":9,\"1273\":2,\"1274\":14,\"1275\":6,\"1276\":4,\"1281\":1,\"1283\":6,\"1284\":4,\"1286\":2,\"1294\":2,\"1295\":5,\"1301\":1,\"1302\":1,\"1303\":1,\"1306\":8,\"1307\":2,\"1308\":1,\"1314\":1,\"1315\":3,\"1316\":3,\"1317\":7,\"1330\":2,\"1337\":2,\"1339\":1,\"1347\":1,\"1348\":1,\"1351\":2,\"1352\":2,\"1359\":1,\"1375\":1,\"1385\":8,\"1386\":7,\"1387\":1,\"1388\":3,\"1392\":25,\"1393\":14,\"1398\":46,\"1404\":1,\"1407\":4,\"1409\":33,\"1410\":33,\"1411\":36,\"1418\":2,\"1420\":1,\"1421\":1,\"1423\":1,\"1432\":2,\"1433\":3,\"1434\":1,\"1439\":1,\"1440\":1,\"1442\":1,\"1443\":1,\"1455\":2,\"1475\":2,\"1476\":5,\"1478\":4,\"1482\":3,\"1496\":10,\"1501\":3,\"1504\":5,\"1508\":3}}],[\"0接收到通知\",{\"1\":{\"1254\":1}}],[\"0当前条件不满足等待\",{\"1\":{\"1254\":1}}],[\"0x61c88647\",{\"1\":{\"1306\":3}}],[\"0x00dcf000\",{\"1\":{\"1259\":1}}],[\"0x00d6f000\",{\"1\":{\"1259\":1}}],[\"0x00010000\",{\"1\":{\"1242\":1}}],[\"0x0000ffff\",{\"1\":{\"1239\":2}}],[\"0x00000007d5ff53d8\",{\"1\":{\"1221\":1}}],[\"0x00000007d5ff53a8\",{\"1\":{\"1221\":1}}],[\"0x000000000b697c10\",{\"1\":{\"1221\":1}}],[\"0x000000000b695360\",{\"1\":{\"1221\":1}}],[\"0x3f3f3f3f\",{\"1\":{\"352\":1,\"353\":1,\"354\":1,\"355\":1}}],[\"0x3f\",{\"1\":{\"223\":1,\"312\":1,\"352\":2,\"353\":1,\"354\":1,\"355\":1,\"360\":2}}],[\"0l\",{\"1\":{\"882\":1,\"1275\":3,\"1508\":2}}],[\"0号点既是根节点\",{\"1\":{\"412\":1}}],[\"0和1都被占用了\",{\"1\":{\"404\":1}}],[\"0是左端点\",{\"1\":{\"404\":1}}],[\"0变1\",{\"1\":{\"337\":1}}],[\"0辆车\",{\"1\":{\"290\":1}}],[\"0只猫\",{\"1\":{\"290\":1}}],[\"0⩽m⩽n\",{\"1\":{\"289\":1}}],[\"0⩽r⩽1090<n⩽100000⩽xi​\",{\"1\":{\"263\":1}}],[\"0表示正常退出\",{\"1\":{\"1120\":1}}],[\"0表示相等\",{\"1\":{\"1005\":1}}],[\"0表示白色\",{\"1\":{\"362\":1}}],[\"0表示还没放数\",{\"1\":{\"288\":1}}],[\"0表示还没考虑\",{\"1\":{\"287\":1}}],[\"0表示未选中\",{\"1\":{\"109\":1}}],[\"0这种情况就要舍去\",{\"1\":{\"223\":1}}],[\"00<\",{\"1\":{\"1090\":1}}],[\"00\",{\"1\":{\"920\":5,\"1090\":1,\"1309\":1}}],[\"001\",{\"1\":{\"613\":3}}],[\"007\",{\"1\":{\"182\":1}}],[\"0001\",{\"1\":{\"338\":1,\"613\":1}}],[\"0000\",{\"1\":{\"338\":6}}],[\"000\",{\"1\":{\"182\":2}}],[\"0831\",{\"0\":{\"171\":1}}],[\"0819\",{\"0\":{\"125\":1}}],[\"0824\",{\"0\":{\"75\":1,\"165\":1}}],[\"0≤m≤104\",{\"1\":{\"223\":1}}],[\"0≤ti​≤1\",{\"1\":{\"168\":1}}],[\"0≤bi​≤1\",{\"1\":{\"168\":1}}],[\"0≤n≤109\",{\"1\":{\"161\":1}}],[\"0≤ai​≤109\",{\"1\":{\"122\":1}}],[\"0≤k≤108\",{\"1\":{\"121\":1}}],[\"0−n\",{\"1\":{\"121\":1}}],[\"0<\",{\"1\":{\"568\":1}}],[\"0<ai\",{\"1\":{\"146\":1}}],[\"0<m≤300<n≤30\",{\"1\":{\"142\":1}}],[\"0<n≤100000\",{\"1\":{\"134\":1}}],[\"0<n<=10000\",{\"1\":{\"115\":1}}],[\"0<n<30000\",{\"1\":{\"114\":1}}],[\"0<orderid<65536\",{\"1\":{\"114\":1}}],[\"0<i<n−1\",{\"1\":{\"104\":1}}],[\"0<starti​<endi​<starti+1​<10000\",{\"1\":{\"70\":1}}],[\"09\",{\"1\":{\"1309\":1}}],[\"0913\",{\"0\":{\"145\":1}}],[\"0910\",{\"0\":{\"138\":1}}],[\"0912\",{\"0\":{\"132\":1}}],[\"0914\",{\"0\":{\"64\":1}}],[\"0905\",{\"0\":{\"118\":1}}],[\"0907\",{\"0\":{\"107\":1}}],[\"0906\",{\"0\":{\"91\":1}}],[\"0924\",{\"0\":{\"86\":1}}],[\"0920\",{\"0\":{\"69\":1}}],[\"07\",{\"0\":{\"38\":1},\"1\":{\"920\":1}}],[\"06\",{\"0\":{\"35\":1}}],[\"05\",{\"0\":{\"32\":1}}],[\"0\",{\"1\":{\"30\":2,\"41\":4,\"56\":4,\"65\":8,\"66\":4,\"70\":5,\"71\":6,\"72\":5,\"76\":6,\"77\":3,\"82\":1,\"83\":6,\"87\":1,\"88\":1,\"92\":2,\"97\":6,\"99\":4,\"103\":5,\"104\":18,\"108\":5,\"109\":4,\"110\":13,\"114\":2,\"115\":4,\"119\":1,\"120\":35,\"121\":12,\"122\":6,\"126\":9,\"127\":8,\"128\":4,\"129\":2,\"133\":1,\"134\":3,\"135\":4,\"139\":6,\"140\":8,\"141\":13,\"142\":16,\"146\":8,\"147\":7,\"152\":2,\"157\":11,\"161\":8,\"162\":7,\"172\":4,\"173\":6,\"174\":11,\"178\":3,\"179\":2,\"180\":16,\"194\":3,\"197\":7,\"200\":1,\"203\":12,\"206\":3,\"215\":1,\"221\":1,\"223\":5,\"224\":14,\"228\":25,\"229\":22,\"230\":11,\"235\":15,\"236\":14,\"237\":17,\"242\":1,\"243\":1,\"244\":4,\"245\":3,\"246\":3,\"250\":1,\"251\":1,\"254\":1,\"255\":2,\"261\":7,\"262\":11,\"263\":4,\"273\":1,\"274\":1,\"278\":30,\"279\":10,\"281\":3,\"287\":5,\"288\":2,\"289\":2,\"290\":6,\"291\":5,\"296\":2,\"297\":2,\"298\":8,\"299\":9,\"301\":4,\"302\":11,\"303\":1,\"304\":2,\"305\":8,\"306\":5,\"307\":1,\"308\":7,\"309\":19,\"311\":13,\"312\":13,\"314\":16,\"318\":2,\"324\":4,\"327\":10,\"328\":19,\"329\":9,\"330\":9,\"338\":39,\"339\":4,\"340\":2,\"341\":1,\"345\":6,\"349\":3,\"352\":3,\"353\":2,\"354\":3,\"355\":1,\"358\":1,\"360\":3,\"361\":5,\"362\":2,\"363\":2,\"367\":1,\"368\":3,\"369\":3,\"372\":2,\"373\":4,\"375\":1,\"376\":2,\"379\":2,\"380\":4,\"381\":1,\"383\":1,\"384\":3,\"385\":5,\"387\":2,\"388\":3,\"389\":2,\"390\":8,\"392\":6,\"394\":3,\"403\":1,\"404\":2,\"406\":2,\"407\":1,\"409\":1,\"410\":2,\"411\":4,\"412\":6,\"414\":1,\"416\":1,\"420\":1,\"421\":1,\"427\":2,\"428\":1,\"429\":3,\"430\":4,\"431\":2,\"471\":2,\"510\":1,\"511\":1,\"512\":1,\"523\":1,\"540\":2,\"549\":1,\"566\":9,\"567\":1,\"568\":2,\"575\":2,\"579\":1,\"580\":1,\"587\":2,\"592\":3,\"613\":3,\"646\":2,\"672\":2,\"682\":1,\"688\":1,\"698\":2,\"699\":1,\"700\":2,\"705\":2,\"710\":3,\"713\":1,\"736\":1,\"737\":2,\"743\":1,\"748\":1,\"749\":2,\"761\":2,\"766\":1,\"767\":9,\"772\":11,\"778\":2,\"783\":3,\"784\":2,\"789\":1,\"795\":9,\"796\":10,\"797\":5,\"803\":2,\"815\":1,\"819\":1,\"820\":11,\"821\":15,\"822\":8,\"827\":4,\"828\":3,\"834\":1,\"838\":1,\"840\":7,\"845\":17,\"846\":10,\"850\":1,\"851\":3,\"852\":1,\"857\":1,\"868\":1,\"869\":5,\"870\":28,\"874\":3,\"875\":6,\"876\":3,\"881\":1,\"882\":3,\"886\":1,\"893\":7,\"894\":8,\"901\":2,\"906\":2,\"920\":17,\"935\":1,\"979\":1,\"984\":4,\"985\":3,\"988\":2,\"990\":3,\"992\":1,\"993\":1,\"994\":3,\"998\":1,\"999\":11,\"1000\":6,\"1001\":1,\"1004\":1,\"1005\":1,\"1007\":1,\"1012\":1,\"1018\":1,\"1020\":5,\"1022\":2,\"1047\":2,\"1059\":3,\"1061\":2,\"1062\":4,\"1063\":1,\"1069\":1,\"1074\":1,\"1080\":1,\"1093\":1,\"1117\":1,\"1122\":1,\"1123\":1,\"1158\":2,\"1170\":1,\"1201\":2,\"1221\":3,\"1232\":5,\"1233\":3,\"1239\":5,\"1240\":1,\"1242\":3,\"1243\":3,\"1250\":2,\"1251\":4,\"1252\":2,\"1266\":1,\"1270\":3,\"1271\":9,\"1272\":9,\"1273\":4,\"1274\":19,\"1275\":6,\"1284\":1,\"1306\":6,\"1309\":1,\"1315\":1,\"1326\":1,\"1337\":2,\"1346\":1,\"1347\":1,\"1348\":2,\"1351\":1,\"1352\":1,\"1359\":1,\"1366\":4,\"1369\":1,\"1370\":1,\"1375\":1,\"1385\":3,\"1392\":8,\"1393\":1,\"1398\":1,\"1407\":7,\"1409\":3,\"1410\":3,\"1411\":2,\"1418\":1,\"1429\":3,\"1432\":1,\"1433\":1,\"1444\":1,\"1449\":3,\"1455\":1,\"1476\":4,\"1482\":3,\"1496\":6,\"1501\":1,\"1505\":3,\"1506\":6,\"1510\":4,\"1511\":3}}],[\"04d\",{\"1\":{\"982\":1}}],[\"04\",{\"0\":{\"29\":1}}],[\"03\",{\"0\":{\"23\":1},\"1\":{\"920\":1}}],[\"023\",{\"1\":{\"699\":1}}],[\"02\",{\"0\":{\"22\":1}}],[\"01010\",{\"1\":{\"120\":1}}],[\"01\",{\"0\":{\"21\":1,\"296\":1},\"1\":{\"120\":1,\"613\":1,\"772\":2,\"920\":8}}],[\"管理后台\",{\"1\":{\"1089\":1}}],[\"管理命令\",{\"1\":{\"671\":1}}],[\"管理面板\",{\"1\":{\"670\":1,\"672\":1}}],[\"管理题目\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"管理题库\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"管理用户\",{\"1\":{\"496\":1,\"507\":1,\"521\":1}}],[\"管理员权限\",{\"1\":{\"580\":1}}],[\"管理员校验\",{\"1\":{\"578\":2}}],[\"管理员可以从题库中移除题目\",{\"1\":{\"526\":1}}],[\"管理员可以添加题目到题库\",{\"1\":{\"526\":1}}],[\"管理员可以创建题库\",{\"1\":{\"493\":1}}],[\"管理员\",{\"1\":{\"496\":3,\"497\":3,\"507\":3,\"508\":3,\"521\":4,\"566\":2,\"592\":1}}],[\"管理员在登录页面\",{\"1\":{\"447\":1}}],[\"管理的\",{\"1\":{\"465\":1}}],[\"管理\",{\"1\":{\"434\":1,\"1309\":1}}],[\"管理平台\",{\"1\":{\"46\":1}}],[\"管理评论\",{\"1\":{\"22\":1,\"45\":1}}],[\"管理不断上升的系统复杂度\",{\"1\":{\"21\":1}}],[\"管理计算资源和网络通信\",{\"1\":{\"14\":1}}],[\"随意性较强\",{\"1\":{\"1133\":1}}],[\"随着后期业务的拓展\",{\"1\":{\"580\":1}}],[\"随着静态网站内容越来越多\",{\"1\":{\"534\":1}}],[\"随着技术的进步\",{\"1\":{\"434\":1}}],[\"随着业务不断发展\",{\"1\":{\"21\":1}}],[\"随机指针指向的节点索引\",{\"1\":{\"886\":1}}],[\"随机链表的复制\",{\"0\":{\"885\":1},\"1\":{\"885\":1}}],[\"随机打乱\",{\"1\":{\"423\":1}}],[\"随机抽题0819\",{\"1\":{\"125\":1}}],[\"随后执行\",{\"1\":{\"1456\":1}}],[\"随后\",{\"1\":{\"77\":1,\"205\":1}}],[\"随之而来的是弹幕和评论区的各种讨论\",{\"1\":{\"21\":1}}],[\"而该方法其底层会调用\",{\"1\":{\"1507\":1}}],[\"而关于底层实现\",{\"1\":{\"1496\":1}}],[\"而对\",{\"1\":{\"1496\":2}}],[\"而对于引用类型变量而言\",{\"1\":{\"1467\":1}}],[\"而对于公司的高级领导或特定角色\",{\"1\":{\"470\":1}}],[\"而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法\",{\"1\":{\"1495\":1}}],[\"而同样的\",{\"1\":{\"1334\":1}}],[\"而用\",{\"1\":{\"1485\":1}}],[\"而用到的配置信息就是从\",{\"1\":{\"1154\":1}}],[\"而语句\",{\"1\":{\"1482\":1}}],[\"而写线程\",{\"1\":{\"1476\":1}}],[\"而普通域就不具有这个保障\",{\"1\":{\"1475\":1}}],[\"而实际上这个\",{\"1\":{\"1485\":1}}],[\"而实例变量则可以有三个时机赋初值\",{\"1\":{\"1465\":1}}],[\"而实例变量可以在声明变量的时候给实例变量赋初值\",{\"1\":{\"1465\":1}}],[\"而实现写锁的同步语义是通过重写\",{\"1\":{\"1239\":1}}],[\"而蓝色的就是根据传递性规则推导出来的\",{\"1\":{\"1455\":1}}],[\"而针对用户来说\",{\"1\":{\"1496\":1}}],[\"而针对\",{\"1\":{\"1453\":1}}],[\"而上层会有基于\",{\"1\":{\"1423\":1}}],[\"而此时当继承\",{\"1\":{\"1495\":1}}],[\"而此时线程\",{\"1\":{\"1417\":1}}],[\"而此时另一个数即为所求答案\",{\"1\":{\"377\":1}}],[\"而局部变量\",{\"1\":{\"1416\":1}}],[\"而解决线程安全的问题最重要的就是理解这两种问题是怎么来的\",{\"1\":{\"1415\":1}}],[\"而消费者只需要从共享数据区中去获取数据\",{\"1\":{\"1402\":1}}],[\"而消费者仅仅只需要在\",{\"1\":{\"1324\":1}}],[\"而可用的最大数据库连接只有\",{\"1\":{\"1398\":1}}],[\"而将这\",{\"1\":{\"1393\":1}}],[\"而其他线程执行的\",{\"1\":{\"1392\":1}}],[\"而为什么在更新的时候会带有版本号\",{\"1\":{\"1388\":1}}],[\"而任务也就是现在所说的\",{\"1\":{\"1368\":1}}],[\"而进入\",{\"1\":{\"1353\":1}}],[\"而它们不同的是\",{\"1\":{\"1339\":1}}],[\"而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性\",{\"1\":{\"1339\":1}}],[\"而没有启动新的线程\",{\"1\":{\"1330\":1}}],[\"而队尾数据则是当前队列最新的数据元素\",{\"1\":{\"1326\":1}}],[\"而至于为什么取模要通过位与运算的原因就是位运算的执行效率远远高于了取模运算\",{\"1\":{\"1306\":1}}],[\"而旧容器的对象还在使用\",{\"1\":{\"1295\":1}}],[\"而保证数据最终一致性\",{\"1\":{\"1295\":1}}],[\"而保障\",{\"1\":{\"1280\":1}}],[\"而什么时候会构造哨兵节点呢\",{\"1\":{\"1285\":1}}],[\"而取\",{\"1\":{\"1283\":1}}],[\"而采用\",{\"1\":{\"1276\":1}}],[\"而之前我们提过\",{\"1\":{\"1272\":1}}],[\"而红黑树的操作是针对\",{\"1\":{\"1267\":1}}],[\"而到了\",{\"1\":{\"1264\":1}}],[\"而调用\",{\"1\":{\"1259\":1,\"1394\":1}}],[\"而另一个线程\",{\"1\":{\"1253\":1}}],[\"而另一部分还有剩余\",{\"1\":{\"318\":1,\"833\":1}}],[\"而移入到同步队列后才有机会使得等待线程被唤醒\",{\"1\":{\"1252\":1}}],[\"而通过使用\",{\"1\":{\"1248\":1}}],[\"而如果在这种业务场景下\",{\"1\":{\"1237\":1}}],[\"而成为并发执行任务\",{\"1\":{\"1224\":1}}],[\"而异步调用了\",{\"1\":{\"1223\":1}}],[\"而异步调用\",{\"1\":{\"1223\":1}}],[\"而在此之前\",{\"1\":{\"1500\":1}}],[\"而在\",{\"1\":{\"1276\":1,\"1371\":2}}],[\"而在大量的同步组件和并发容器的实现中使用\",{\"1\":{\"1266\":1}}],[\"而在之前利用\",{\"1\":{\"1250\":1}}],[\"而在之前说\",{\"1\":{\"1250\":1}}],[\"而在一些业务场景中\",{\"1\":{\"1237\":1}}],[\"而在学习多线程编程技术的过程中也会让你收获颇丰\",{\"1\":{\"1221\":1}}],[\"而在创建\",{\"1\":{\"1150\":1}}],[\"而每次切换时\",{\"1\":{\"1220\":1}}],[\"而每个节点一共能存储\",{\"1\":{\"958\":1}}],[\"而并没有加锁\",{\"1\":{\"1274\":1}}],[\"而并发包中的\",{\"1\":{\"1250\":1}}],[\"而并发编程更能吻合这种业务拆分\",{\"1\":{\"1218\":1}}],[\"而并行则是指真正意义上的\",{\"1\":{\"1224\":1}}],[\"而并非是\",{\"1\":{\"354\":1}}],[\"而专业服务器则通常可以达到几个独立的\",{\"1\":{\"1218\":1}}],[\"而磁盘中的数据虽然读写性能很差\",{\"1\":{\"1200\":1}}],[\"而注册其实不是拷贝副本\",{\"1\":{\"1184\":1}}],[\"而服务之间是需要相互通信的\",{\"1\":{\"1157\":1}}],[\"而接口的方法是驼峰命名的\",{\"1\":{\"1147\":1}}],[\"而这些实际上则是\",{\"1\":{\"1500\":1}}],[\"而这些类的实现主要是依赖于\",{\"1\":{\"1491\":1}}],[\"而这三个操作无法构成原子操作\",{\"1\":{\"1482\":1}}],[\"而这几种常见的阻塞队列也是在实际编程中会常用的\",{\"1\":{\"1326\":1}}],[\"而这种机制能够解决最经典的问题就是\",{\"1\":{\"1253\":1}}],[\"而这段代码的逻辑就是告诉我们这三个问题的答案\",{\"1\":{\"1251\":1}}],[\"而这个方法锁的对象依然就这个类对象\",{\"1\":{\"1431\":1}}],[\"而这个方法实际上是会\",{\"1\":{\"1250\":1}}],[\"而这个获取的过程是互斥的\",{\"1\":{\"1431\":1}}],[\"而这个问题\",{\"1\":{\"1380\":1}}],[\"而这个锁目前被其他线程占有\",{\"1\":{\"1332\":1}}],[\"而这个值其实也是一个大概的数值\",{\"1\":{\"1275\":1}}],[\"而这个切换时非常损耗性能\",{\"1\":{\"1220\":1}}],[\"而这个\",{\"1\":{\"1132\":1}}],[\"而这道题有多个起点\",{\"1\":{\"869\":1}}],[\"而指定的类对象因为是一个接口或是一个抽象类而无法实例化时\",{\"1\":{\"1045\":1}}],[\"而我们在日常开发使用时\",{\"1\":{\"945\":1}}],[\"而一个节点总共容量是\",{\"1\":{\"958\":1}}],[\"而一个身份证也只能关联一个用户\",{\"1\":{\"938\":1}}],[\"而一个子网格的美观度等于种植其中花朵数量的总和\",{\"1\":{\"141\":1}}],[\"而第二张表存放的就是用户的身份信息\",{\"1\":{\"938\":1}}],[\"而中序遍历和后序遍历至少要递归到一个叶子节点\",{\"1\":{\"899\":1}}],[\"而节点的值范围在\",{\"1\":{\"899\":1}}],[\"而左子指针始终为\",{\"1\":{\"723\":1}}],[\"而当线程\",{\"1\":{\"1478\":1}}],[\"而当前位计算结束后同样需要更新进位值\",{\"1\":{\"699\":1}}],[\"而当业务发展到一定规模后\",{\"1\":{\"436\":1}}],[\"而使用在代码块中也可以分为三种\",{\"1\":{\"1430\":1}}],[\"而使用\",{\"1\":{\"1334\":1,\"1449\":1}}],[\"而使用多线程时\",{\"1\":{\"1224\":1}}],[\"而使用宝塔面板安装的\",{\"1\":{\"672\":1}}],[\"而使用反向代理时\",{\"1\":{\"586\":1}}],[\"而使用唯一性约束的方式\",{\"1\":{\"526\":1}}],[\"而无需重新构建整个站点\",{\"1\":{\"534\":1}}],[\"而且只能在这三个地方进行指定\",{\"1\":{\"1465\":1}}],[\"而且只能在这两个地方之一进行指定\",{\"1\":{\"1465\":1}}],[\"而且总是由同一线程多次获得\",{\"1\":{\"1441\":1}}],[\"而且每次运行结果都不一样\",{\"1\":{\"1429\":1}}],[\"而且也向程序员提供了足够强的内存可见性保证\",{\"1\":{\"1423\":1}}],[\"而且也不需要从其他`\",{\"1\":{\"1158\":1}}],[\"而且第一个操作的执行顺序排在第二个操作之前\",{\"1\":{\"1420\":1}}],[\"而且可以有多个线程并行运行\",{\"1\":{\"1331\":1}}],[\"而且逻辑更易懂\",{\"1\":{\"1286\":1}}],[\"而且在服务实例列表里面也会显示集群节点\",{\"1\":{\"1192\":1}}],[\"而且调用注册方法的类的名字起得也有争议\",{\"1\":{\"1184\":1}}],[\"而且链表构造过程需要指针移动\",{\"1\":{\"699\":1}}],[\"而且长度很短\",{\"1\":{\"670\":1}}],[\"而且公有云存储的存储有限\",{\"1\":{\"668\":1}}],[\"而且更换\",{\"1\":{\"664\":1}}],[\"而且并不安全\",{\"1\":{\"664\":1}}],[\"而且由于数据不变化\",{\"1\":{\"534\":1}}],[\"而且要注意\",{\"1\":{\"513\":1}}],[\"而超级管理员可以查看所有菜单的\",{\"1\":{\"458\":1}}],[\"而仓里的\",{\"1\":{\"438\":1}}],[\"而整数\",{\"1\":{\"388\":1}}],[\"而所有的公共上升子序列中最长的就是最长公共上升子序列了\",{\"1\":{\"304\":1}}],[\"而是先将系统内存的数据读到内部缓存\",{\"1\":{\"1454\":1}}],[\"而是先将当前容器进行\",{\"1\":{\"1291\":1}}],[\"而是会继续往下执行\",{\"1\":{\"1392\":1}}],[\"而是继续向后搜索\",{\"1\":{\"1316\":1}}],[\"而是代码继续往下走\",{\"1\":{\"1284\":1}}],[\"而是指向\",{\"1\":{\"1283\":1}}],[\"而是统计一次这个值\",{\"1\":{\"1275\":1}}],[\"而是希望利用并发处理去减少扩容带来的时间影响\",{\"1\":{\"1274\":1}}],[\"而是希望能够尽快找到一个路径即可\",{\"1\":{\"216\":1}}],[\"而是包装的很多\",{\"1\":{\"1267\":1}}],[\"而是将多个计算单元整合到了一起\",{\"1\":{\"1218\":1}}],[\"而是将新的注册信息发送到\",{\"1\":{\"1184\":1}}],[\"而是等待修复\",{\"1\":{\"1191\":1}}],[\"而是通过一个后台线程去做的\",{\"1\":{\"1184\":1}}],[\"而是通过系统的事件驱动或定时器来执行任务\",{\"1\":{\"671\":1}}],[\"而是\",{\"1\":{\"1131\":1,\"1264\":1}}],[\"而是有婚介这样一个类似容器的机构来控制\",{\"1\":{\"1131\":1}}],[\"而是exit\",{\"1\":{\"1120\":1}}],[\"而是记录这一层节点对应字符串的位置是否出现了某个字符\",{\"1\":{\"802\":1}}],[\"而是节点\",{\"1\":{\"789\":1}}],[\"而是利用一个全局变量\",{\"1\":{\"725\":1}}],[\"而是需要实际进行节点交换\",{\"1\":{\"680\":1}}],[\"而是打到数据库上\",{\"1\":{\"613\":1}}],[\"而是标记为已删除\",{\"1\":{\"575\":1}}],[\"而是应该根据特定规则放在\",{\"1\":{\"543\":1}}],[\"而是以\",{\"1\":{\"512\":1}}],[\"而是只有像\",{\"1\":{\"237\":1}}],[\"而不用再去理解底层重排序的规则\",{\"1\":{\"1419\":1}}],[\"而不是使用\",{\"1\":{\"1408\":1}}],[\"而不是在\",{\"1\":{\"1408\":1}}],[\"而不是在交互式用户界面下运行的进程\",{\"1\":{\"671\":1}}],[\"而不是它的元素\",{\"1\":{\"1295\":1}}],[\"而不是再追求单独的计算单元\",{\"1\":{\"1218\":1}}],[\"而不是\",{\"1\":{\"795\":1,\"893\":1,\"1267\":1,\"1272\":1,\"1276\":1}}],[\"而不是被初始值覆盖了\",{\"1\":{\"772\":1}}],[\"而不是重新生成整个站点\",{\"1\":{\"534\":1}}],[\"而不是用户请求时\",{\"1\":{\"534\":1}}],[\"而不是完整图片文件\",{\"1\":{\"511\":1}}],[\"而不是某个单一产品\",{\"1\":{\"437\":1}}],[\"而不是局部的\",{\"1\":{\"127\":1}}],[\"而不需要真正计算出\",{\"1\":{\"139\":1}}],[\"而不会继续去执行删除\",{\"1\":{\"1407\":1}}],[\"而不会再去查\",{\"1\":{\"60\":1}}],[\"而不会一下发到\",{\"1\":{\"49\":1}}],[\"而\",{\"1\":{\"58\":1,\"98\":1,\"115\":1,\"243\":1,\"290\":1,\"510\":1,\"567\":1,\"592\":1,\"794\":1,\"920\":1,\"933\":2,\"958\":1,\"1068\":1,\"1150\":1,\"1239\":1,\"1248\":3,\"1250\":1,\"1252\":1,\"1266\":1,\"1283\":4,\"1284\":1,\"1291\":1,\"1295\":1,\"1305\":1,\"1306\":1,\"1313\":3,\"1326\":1,\"1336\":1,\"1338\":4,\"1339\":1,\"1346\":1,\"1353\":2,\"1360\":1,\"1365\":1,\"1382\":1,\"1384\":1,\"1385\":2,\"1394\":3,\"1398\":1,\"1418\":1,\"1436\":1,\"1437\":1,\"1449\":1,\"1453\":1,\"1457\":1,\"1475\":2,\"1492\":2,\"1493\":1,\"1495\":2,\"1496\":4,\"1503\":1}}],[\"而非共享数据不会出现线程安全的问题\",{\"1\":{\"1416\":1}}],[\"而非进行耗时的挂起唤醒的操作\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"而非公平性则是指访问\",{\"1\":{\"1326\":1}}],[\"而非公平性锁则不一定\",{\"1\":{\"1233\":1}}],[\"而非公平锁会降低一定的上下文切换\",{\"1\":{\"1233\":1}}],[\"而非公平锁有可能刚释放锁的线程下次继续获取该锁\",{\"1\":{\"1233\":1}}],[\"而非阻塞就恰好相反\",{\"1\":{\"1225\":1}}],[\"而非对某个数的余数时\",{\"1\":{\"390\":1}}],[\"而非数据内容\",{\"1\":{\"58\":1}}],[\"而非一种软件\",{\"1\":{\"14\":1}}],[\"而分布式部署+负载均衡的网关\",{\"1\":{\"28\":1}}],[\"而点进评论区\",{\"1\":{\"21\":1}}],[\"如本文中的\",{\"1\":{\"1407\":1}}],[\"如数据库连接\",{\"1\":{\"1361\":1}}],[\"如实现\",{\"1\":{\"1324\":1}}],[\"如图在\",{\"1\":{\"1440\":1}}],[\"如图当前\",{\"1\":{\"1316\":1}}],[\"如图\",{\"1\":{\"1251\":1,\"1281\":1,\"1283\":5,\"1285\":1,\"1317\":4,\"1418\":1,\"1430\":1,\"1431\":1}}],[\"如图所示\",{\"1\":{\"1250\":1,\"1305\":1,\"1316\":1,\"1317\":1}}],[\"如图队列中的线程引用依次为\",{\"1\":{\"1250\":1}}],[\"如上述所说\",{\"1\":{\"1291\":1}}],[\"如上所述\",{\"1\":{\"1221\":1}}],[\"如上例中值为\",{\"1\":{\"1120\":2}}],[\"如上例中值为4\",{\"1\":{\"1120\":1}}],[\"如上图为\",{\"1\":{\"1417\":1}}],[\"如上图所示\",{\"1\":{\"56\":1,\"1326\":1}}],[\"如上图\",{\"1\":{\"46\":1,\"56\":1,\"1253\":1,\"1272\":1,\"1443\":1}}],[\"如用户\",{\"1\":{\"1094\":1}}],[\"如启动信息\",{\"1\":{\"1087\":1}}],[\"如此评价这种情况\",{\"1\":{\"1218\":1}}],[\"如此便可在访问原节点的\",{\"1\":{\"888\":1}}],[\"如此简单\",{\"1\":{\"648\":1}}],[\"如今有许多第三方文件管理器\",{\"1\":{\"674\":1}}],[\"如导航栏\",{\"1\":{\"535\":1}}],[\"如当前主节点信息等\",{\"1\":{\"484\":1}}],[\"如作业名称\",{\"1\":{\"484\":1}}],[\"如持久化的数据\",{\"1\":{\"484\":1}}],[\"如重复次数和间隔\",{\"1\":{\"484\":1}}],[\"如cron表达式\",{\"1\":{\"484\":1}}],[\"如cassandra\",{\"1\":{\"151\":1}}],[\"如触发器名称\",{\"1\":{\"484\":1}}],[\"如任务名\",{\"1\":{\"479\":1}}],[\"如任务名称\",{\"1\":{\"476\":1}}],[\"如文本\",{\"1\":{\"434\":1}}],[\"如点\",{\"1\":{\"354\":1}}],[\"如题\",{\"1\":{\"274\":1,\"724\":1}}],[\"如有必要可以使用\",{\"1\":{\"1444\":1}}],[\"如有必要\",{\"1\":{\"254\":1}}],[\"如需输出string对象中的字符串\",{\"1\":{\"243\":1}}],[\"如下代码所示\",{\"1\":{\"1182\":1}}],[\"如下操作\",{\"1\":{\"576\":1}}],[\"如下\",{\"1\":{\"465\":1,\"510\":1,\"511\":1,\"512\":1,\"513\":1,\"549\":2,\"580\":1,\"1133\":1,\"1423\":1,\"1475\":1}}],[\"如下所示创建前端项目\",{\"1\":{\"538\":1}}],[\"如下所示\",{\"1\":{\"228\":1,\"274\":1,\"280\":1,\"516\":1,\"541\":1,\"1150\":1}}],[\"如下图\",{\"1\":{\"61\":1,\"766\":1,\"1306\":1,\"1469\":1,\"1471\":1}}],[\"如下图所示的控制台界面\",{\"1\":{\"1186\":1}}],[\"如下图所示\",{\"1\":{\"30\":1,\"494\":1,\"515\":1,\"1306\":1,\"1330\":1,\"1491\":1}}],[\"如uuid\",{\"1\":{\"151\":1}}],[\"如kafka\",{\"1\":{\"151\":2}}],[\"如不能\",{\"1\":{\"142\":1}}],[\"如能达到终点\",{\"1\":{\"142\":1}}],[\"如能\",{\"1\":{\"142\":1}}],[\"如果理解了上面的内容对这部分的理解也是水到渠成的\",{\"1\":{\"1512\":1}}],[\"如果还没有超时\",{\"1\":{\"1508\":1}}],[\"如果还有剩余操作次数\",{\"1\":{\"167\":2}}],[\"如果同步状态释放成功\",{\"1\":{\"1506\":1}}],[\"如果先驱节点是头结点的并且成功获得同步状态的时候\",{\"1\":{\"1504\":1}}],[\"如果先向下走两步\",{\"1\":{\"180\":1}}],[\"如果去查看源码的实现\",{\"1\":{\"1493\":1}}],[\"如果以\",{\"1\":{\"1477\":1}}],[\"如果可见的\",{\"1\":{\"1476\":1}}],[\"如果可以拆分\",{\"1\":{\"1361\":1}}],[\"如果可以利用字典中出现的一个或多个单词拼接出\",{\"1\":{\"782\":1}}],[\"如果可以分配\",{\"1\":{\"162\":1}}],[\"如果可以\",{\"1\":{\"126\":1,\"874\":1}}],[\"如果失败\",{\"1\":{\"1446\":1,\"1447\":1}}],[\"如果失败去设置用户错误信息\",{\"1\":{\"589\":1}}],[\"如果设置了\",{\"1\":{\"1442\":1}}],[\"如果测试失败\",{\"1\":{\"1442\":1}}],[\"如果测试成功\",{\"1\":{\"1442\":1}}],[\"如果多线程间没有共享的数据也就是说多线程间并没有协作完成一件事情\",{\"1\":{\"1429\":1}}],[\"如果结果正确的话自然而然总数就应该是\",{\"1\":{\"1429\":1}}],[\"如果编译器经过细致的分析后\",{\"1\":{\"1423\":2}}],[\"如果重排序之后的执行结果\",{\"1\":{\"1420\":1}}],[\"如果重排序会对最终执行结果会存在影响\",{\"1\":{\"1418\":1}}],[\"如果采用\",{\"1\":{\"1410\":1}}],[\"如果采用无界队列的话\",{\"1\":{\"1361\":1}}],[\"如果唤醒的仍然是生产者线程\",{\"1\":{\"1408\":1}}],[\"如果通知早已发出的话\",{\"1\":{\"1406\":1}}],[\"如果再次获取到锁的话\",{\"1\":{\"1404\":1}}],[\"如果共享数据区为空的话\",{\"1\":{\"1402\":1}}],[\"如果共享数据区已满的话\",{\"1\":{\"1402\":1}}],[\"如果能够立即获取到或者在指定时间内能够获取到\",{\"1\":{\"1398\":1}}],[\"如果能够获取成功则立即返回true\",{\"1\":{\"1398\":1}}],[\"如果能减少\",{\"1\":{\"1286\":1}}],[\"如果刚好是\",{\"1\":{\"1393\":1}}],[\"如果出现冲突了怎么办\",{\"1\":{\"1382\":1,\"1436\":1}}],[\"如果出现并发问题\",{\"1\":{\"1359\":1}}],[\"如果执行\",{\"1\":{\"1375\":1}}],[\"如果上一个任务没有执行完毕\",{\"1\":{\"1367\":1}}],[\"如果上一个任务执行完毕\",{\"1\":{\"1367\":1}}],[\"如果等待的时间越长\",{\"1\":{\"1361\":1}}],[\"如果等待队列的\",{\"1\":{\"1251\":1}}],[\"如果运行的线程个数等于或者大于\",{\"1\":{\"1359\":1}}],[\"如果当阻塞队列已满时\",{\"1\":{\"1359\":1}}],[\"如果当前运行的线程少于\",{\"1\":{\"1359\":1}}],[\"如果当前任务无法放进阻塞队列中\",{\"1\":{\"1359\":1}}],[\"如果当前核心线程池的线程个数已经达到了\",{\"1\":{\"1359\":1}}],[\"如果当前核心线程池的线程个数没有达到\",{\"1\":{\"1359\":1}}],[\"如果当前满足移除元素的条件\",{\"1\":{\"1352\":1}}],[\"如果当前满足插入数据的条件\",{\"1\":{\"1347\":1}}],[\"如果当前队列为空的话\",{\"1\":{\"1348\":1}}],[\"如果当前队列为空队列\",{\"1\":{\"1284\":1}}],[\"如果当前队列已满\",{\"1\":{\"1347\":1}}],[\"如果当前所有的数据都还没有达到创建时所指定的延时期\",{\"1\":{\"1326\":1}}],[\"如果当前没有消费者线程消费数据\",{\"1\":{\"1326\":1}}],[\"如果当前没有消费者线程\",{\"1\":{\"1326\":1}}],[\"如果当前有线程正在临界点等待的话\",{\"1\":{\"1393\":1}}],[\"如果当前有线程\",{\"1\":{\"1326\":2}}],[\"如果当前有线程在插入数据时\",{\"1\":{\"1326\":1}}],[\"如果当前线程池已经关闭\",{\"1\":{\"1370\":1}}],[\"如果当前线程池的线程个数已经超过了\",{\"1\":{\"1359\":1}}],[\"如果当前线程不持有\",{\"1\":{\"1309\":1}}],[\"如果当前线程再迟迟不结束的话\",{\"1\":{\"1305\":1}}],[\"如果当前链表节点个数大于等于\",{\"1\":{\"1272\":1}}],[\"如果当前\",{\"1\":{\"1272\":2,\"1284\":2,\"1305\":1,\"1306\":1,\"1314\":2,\"1359\":1}}],[\"如果当前table还没有初始化先调用inittable方法将tab进行初始化\",{\"1\":{\"1272\":1}}],[\"如果当前数组为\",{\"1\":{\"1266\":1}}],[\"如果当前数能整除目标数\",{\"1\":{\"375\":1}}],[\"如果当前节点的前驱节点是头节点\",{\"1\":{\"1505\":1}}],[\"如果当前节点的先驱节点是头结点并且成功获取同步状态\",{\"1\":{\"1504\":1}}],[\"如果当前节点的数据域为\",{\"1\":{\"1284\":1}}],[\"如果当前节点释放同步状态会通知后继节点\",{\"1\":{\"1501\":1}}],[\"如果当前节点不为\",{\"1\":{\"1272\":1}}],[\"如果当前节点没有前驱节点的话\",{\"1\":{\"1233\":1}}],[\"如果当前节点走过了\",{\"1\":{\"876\":1}}],[\"如果当前节点\",{\"1\":{\"802\":2}}],[\"如果当前节点与\",{\"1\":{\"187\":1}}],[\"如果当前节点是空节点\",{\"1\":{\"187\":1}}],[\"如果当前是最后一次速通记录\",{\"1\":{\"146\":1}}],[\"如果当前字符不是下划线\",{\"1\":{\"98\":1}}],[\"如果当前字符是下划线\",{\"1\":{\"98\":1}}],[\"如果无法获取到\",{\"1\":{\"1398\":1}}],[\"如果无法从1走到n\",{\"1\":{\"354\":1}}],[\"如果无限制的创建\",{\"1\":{\"1357\":1}}],[\"如果线程仍然活着\",{\"1\":{\"1443\":1}}],[\"如果线程不处于活动状态\",{\"1\":{\"1443\":1}}],[\"如果线程在等待时接受到了通知\",{\"1\":{\"1407\":1}}],[\"如果线程个数已经超过了\",{\"1\":{\"1359\":1}}],[\"如果线程个数大于corepoolsize或者创建线程失败\",{\"1\":{\"1359\":1}}],[\"如果线程池的线程个数少于corepoolsize则创建新线程执行当前任务\",{\"1\":{\"1359\":1}}],[\"如果线程\",{\"1\":{\"1337\":1,\"1417\":1,\"1421\":2,\"1482\":1}}],[\"如果线程执行结束后\",{\"1\":{\"1313\":1}}],[\"如果需要更新对象的某个字段\",{\"1\":{\"1388\":1}}],[\"如果需要原子更新引用类型变量的话\",{\"1\":{\"1387\":1}}],[\"如果需要获得公平性的\",{\"1\":{\"1326\":1}}],[\"如果需要有序的数据\",{\"1\":{\"973\":1}}],[\"如果保证公平性\",{\"1\":{\"1326\":1}}],[\"如果被阻塞的线程超过了给定的时长\",{\"1\":{\"1325\":1}}],[\"如果向前未搜索到脏entry\",{\"1\":{\"1317\":1}}],[\"如果对声明了\",{\"1\":{\"1454\":1}}],[\"如果对多个共享变量进行操作\",{\"1\":{\"1439\":1}}],[\"如果对线程管理不善很容易导致系统问题\",{\"1\":{\"1357\":1}}],[\"如果对输入参数能够理解的话\",{\"1\":{\"1316\":1}}],[\"如果对这有疑问的话\",{\"1\":{\"1272\":1}}],[\"如果map不为null\",{\"1\":{\"1301\":1}}],[\"如果map中有key\",{\"1\":{\"1074\":1}}],[\"如果每个线程都使用自己的\",{\"1\":{\"1299\":1}}],[\"如果读线程能够立即读到新添加的数据的话就叫做能保证数据实时性\",{\"1\":{\"1295\":1}}],[\"如果简单的使用读写锁的话\",{\"1\":{\"1291\":1}}],[\"如果仅仅是将\",{\"1\":{\"1290\":1}}],[\"如果仅仅是读数据的话并不会影响数据正确性\",{\"1\":{\"1237\":1}}],[\"如果大于阈值就需要扩容\",{\"1\":{\"1306\":1}}],[\"如果大于等于60并且小于70\",{\"1\":{\"984\":1}}],[\"如果大于等于70并且小于85\",{\"1\":{\"984\":1}}],[\"如果大于等于85\",{\"1\":{\"984\":1}}],[\"如果大量的入队操作\",{\"1\":{\"1286\":1}}],[\"如果让我们设计\",{\"1\":{\"1422\":1}}],[\"如果让程序员再去了解这些底层的实现以及具体规则\",{\"1\":{\"1419\":1}}],[\"如果让\",{\"1\":{\"1286\":1,\"1482\":1}}],[\"如果队列已满\",{\"1\":{\"1351\":1}}],[\"如果队列为空\",{\"1\":{\"1348\":1}}],[\"如果队列为空则抛出\",{\"1\":{\"1325\":1}}],[\"如果队列为空时则抛出\",{\"1\":{\"1325\":1}}],[\"如果队列为空队列的话\",{\"1\":{\"1284\":1}}],[\"如果队列中已存在j\",{\"1\":{\"355\":1}}],[\"如果成功则方法结束返回\",{\"1\":{\"1503\":1}}],[\"如果成功\",{\"1\":{\"1446\":1,\"1447\":1}}],[\"如果成功插入\",{\"1\":{\"1283\":1}}],[\"如果成立\",{\"1\":{\"66\":1,\"988\":1}}],[\"如果check值大于等于0\",{\"1\":{\"1275\":1}}],[\"如果遍历到forwardingnode节点\",{\"1\":{\"1274\":1}}],[\"如果长度大于\",{\"1\":{\"1272\":1}}],[\"如果遇到哈希桶为\",{\"1\":{\"1316\":1}}],[\"如果遇到\",{\"1\":{\"1272\":1}}],[\"如果直到找到了链表的末尾都没有找到的话\",{\"1\":{\"1272\":1}}],[\"如果到数组尾部\",{\"1\":{\"1306\":1}}],[\"如果到链表末尾仍未找到\",{\"1\":{\"1272\":1}}],[\"如果到了末尾\",{\"1\":{\"420\":1}}],[\"如果插入值待插入的位置刚好所在的\",{\"1\":{\"1272\":1}}],[\"如果插入操作导致关键字数量超过\",{\"1\":{\"686\":1}}],[\"如果超过了临界值\",{\"1\":{\"1272\":2}}],[\"如果选择是无参的构造器的话\",{\"1\":{\"1271\":1}}],[\"如果选择当前数\",{\"1\":{\"126\":1}}],[\"如果指定值大于了所允许的最大值的话就取最大值\",{\"1\":{\"1270\":1}}],[\"如果调用了\",{\"1\":{\"1359\":1}}],[\"如果调用\",{\"1\":{\"1259\":1,\"1404\":2}}],[\"如果许可尚不可用\",{\"1\":{\"1258\":1}}],[\"如果获取失败则插入同步队列进行等待\",{\"1\":{\"1500\":1}}],[\"如果获取失败\",{\"1\":{\"1431\":1}}],[\"如果获取失败了\",{\"1\":{\"1160\":1}}],[\"如果获取\",{\"1\":{\"1302\":1}}],[\"如果获取的话再得到等待队列的头指针引用的节点\",{\"1\":{\"1252\":1}}],[\"如果释放成功则正常返回\",{\"1\":{\"1251\":1}}],[\"如果其他处理器缓存的值还是旧的\",{\"1\":{\"1454\":1}}],[\"如果其他线程调用\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"如果其中有一条\",{\"1\":{\"953\":1}}],[\"如果其中一段连续的子序列\",{\"1\":{\"261\":1}}],[\"如果写锁已经被获取并且获取写锁的线程不是当前线程的话\",{\"1\":{\"1242\":1}}],[\"如果锁的是类对象的话\",{\"1\":{\"1430\":1}}],[\"如果锁被获取\",{\"1\":{\"1232\":1}}],[\"如果锁已经被其他线程获取\",{\"1\":{\"1061\":1}}],[\"如果系统内只有一个\",{\"1\":{\"1224\":1}}],[\"如果系统用户量很大\",{\"1\":{\"613\":1}}],[\"如果一件物品没了\",{\"1\":{\"1223\":1}}],[\"如果一个操作\",{\"1\":{\"1420\":1}}],[\"如果一个线程先执行\",{\"1\":{\"1399\":1}}],[\"如果一个线程实例\",{\"1\":{\"1337\":1}}],[\"如果一个锁是公平的\",{\"1\":{\"1233\":1}}],[\"如果一个类只允许创建一个对象\",{\"1\":{\"963\":1}}],[\"如果一个位置为\",{\"1\":{\"821\":1,\"822\":1}}],[\"如果一个链表较短则在前面补\",{\"1\":{\"699\":1}}],[\"如果一个图的某个匹配中\",{\"1\":{\"363\":1}}],[\"如果key不存在\",{\"1\":{\"1207\":2}}],[\"如果配置成集群环境\",{\"1\":{\"1192\":1}}],[\"如果配置文件没有配置\",{\"1\":{\"1151\":1}}],[\"如果配置文件中没有配置\",{\"1\":{\"1150\":1}}],[\"如果应用丢失续约的占比在一定时间内超过了设定的百分比\",{\"1\":{\"1160\":1}}],[\"如果应用程序试图创建大小为负的数组\",{\"1\":{\"1045\":1}}],[\"如果beanfactory\",{\"1\":{\"1140\":1}}],[\"如果婚介给我们的人选不符合要求\",{\"1\":{\"1131\":1}}],[\"如果发现\",{\"1\":{\"1317\":1}}],[\"如果发现k\",{\"1\":{\"1074\":1}}],[\"如果发现不是二叉搜索树\",{\"1\":{\"901\":1}}],[\"如果修改了原list的大小\",{\"1\":{\"1072\":1}}],[\"如果end大于arr\",{\"1\":{\"1067\":1}}],[\"如果索引为负或大于等于数组大小\",{\"1\":{\"1045\":1}}],[\"如果程序执行到了这里\",{\"1\":{\"1020\":1}}],[\"如果打算修改字符串\",{\"1\":{\"1007\":1}}],[\"如果打不开或安装失败就多换几个安装包试试\",{\"1\":{\"665\":2}}],[\"如果条件成立\",{\"1\":{\"988\":1}}],[\"如果条件成立则记下答案\",{\"1\":{\"323\":1}}],[\"如果事务执行出现错误\",{\"1\":{\"955\":1}}],[\"如果事务成功的完成\",{\"1\":{\"955\":1}}],[\"如果查询的是第一页数据\",{\"1\":{\"935\":1}}],[\"如果查找失败\",{\"1\":{\"252\":1}}],[\"如果查找成功\",{\"1\":{\"252\":1}}],[\"如果未满\",{\"1\":{\"1358\":1}}],[\"如果未指定\",{\"1\":{\"1326\":1}}],[\"如果未指定该字段值\",{\"1\":{\"919\":1}}],[\"如果未越界\",{\"1\":{\"235\":1}}],[\"如果数据在规定的超时时间内没有消费者进行消费的话\",{\"1\":{\"1326\":1}}],[\"如果数据结构是红黑树\",{\"1\":{\"958\":1}}],[\"如果数据库存在\",{\"1\":{\"915\":1}}],[\"如果数字\",{\"1\":{\"99\":1}}],[\"如果删除一个不存在的数据库\",{\"1\":{\"915\":1}}],[\"如果均大于说明这个序列是升序的\",{\"1\":{\"900\":1}}],[\"如果原链表中有\",{\"1\":{\"886\":1}}],[\"如果想真正全方位的弄懂\",{\"1\":{\"1304\":1}}],[\"如果想\",{\"1\":{\"1290\":1}}],[\"如果想要优化时间复杂度\",{\"1\":{\"852\":1}}],[\"如果想将一个单元清零\",{\"1\":{\"338\":1}}],[\"如果之前的子序列是形如\",{\"1\":{\"846\":1}}],[\"如果之前已经插入的字符串\",{\"1\":{\"801\":1}}],[\"如果前面有和\",{\"1\":{\"846\":1}}],[\"如果前面的值返回\",{\"1\":{\"808\":1}}],[\"如果字符串\",{\"1\":{\"801\":1}}],[\"如果字符串长度很大\",{\"1\":{\"243\":1}}],[\"如果剩下的子串s\",{\"1\":{\"784\":1}}],[\"如果快速地删除指定结点并返回头结点呢\",{\"1\":{\"777\":1}}],[\"如果题目给的价值有负数\",{\"1\":{\"772\":1}}],[\"如果题目给的价值都是正整数\",{\"1\":{\"772\":1}}],[\"如果题目中给定的节点值存在重复的解法\",{\"1\":{\"766\":1}}],[\"如果背包容量为\",{\"1\":{\"772\":1}}],[\"如果left为空\",{\"1\":{\"755\":1}}],[\"如果left\",{\"1\":{\"755\":1}}],[\"如果二叉搜索树经常被修改\",{\"1\":{\"711\":1}}],[\"如果关键字\",{\"1\":{\"686\":2}}],[\"如果忘记了初始管理员密码\",{\"1\":{\"670\":1}}],[\"如果显示\",{\"1\":{\"663\":2}}],[\"如果步骤没问题\",{\"1\":{\"662\":1}}],[\"如果比较感兴趣\",{\"1\":{\"661\":1}}],[\"如果比父节点大\",{\"1\":{\"417\":1}}],[\"如果经过\",{\"1\":{\"613\":1}}],[\"如果这两个任务执行时间相差太大\",{\"1\":{\"1361\":1}}],[\"如果这些对象占用的内存比较大\",{\"1\":{\"1295\":1}}],[\"如果这里自旋时间过长对性能是很大的消耗\",{\"1\":{\"1384\":1,\"1439\":1}}],[\"如果这里\",{\"1\":{\"1283\":1}}],[\"如果这段代码在单线程环境执行时\",{\"1\":{\"1283\":1}}],[\"如果这一列中有\",{\"1\":{\"932\":1}}],[\"如果这层是首次遍历\",{\"1\":{\"736\":1}}],[\"如果这样做\",{\"1\":{\"725\":1}}],[\"如果这\",{\"1\":{\"613\":1}}],[\"如果这个节点的类型是\",{\"1\":{\"1272\":1}}],[\"如果这个位置为空\",{\"1\":{\"1274\":1}}],[\"如果这个位置存在结点\",{\"1\":{\"1272\":1}}],[\"如果这个位置是\",{\"1\":{\"1272\":1,\"1274\":2}}],[\"如果这个接口不进行校验\",{\"1\":{\"578\":1}}],[\"如果这个点未被匹配\",{\"1\":{\"363\":1}}],[\"如果这个距离不等于\",{\"1\":{\"108\":1}}],[\"如果将小明妈妈和小明作为两个线程\",{\"1\":{\"1416\":1}}],[\"如果将同步机制和\",{\"1\":{\"1313\":1}}],[\"如果将\",{\"1\":{\"1295\":1}}],[\"如果将状态直接写在登录逻辑里面\",{\"1\":{\"580\":1}}],[\"如果将题目移出题库\",{\"1\":{\"513\":1}}],[\"如果使用的是\",{\"1\":{\"1408\":1}}],[\"如果使用弱引用\",{\"1\":{\"1318\":1}}],[\"如果使用强引用\",{\"1\":{\"1318\":1}}],[\"如果使用上述地址测试后仍然无法连接\",{\"1\":{\"663\":1}}],[\"如果使用\",{\"1\":{\"576\":1}}],[\"如果已经持有\",{\"1\":{\"1309\":1}}],[\"如果已经获取锁的线程是当前线程的话则直接再次获取成功\",{\"1\":{\"1232\":1}}],[\"如果已经有其他线程在执行扩容操作\",{\"1\":{\"1275\":1}}],[\"如果已经有\",{\"1\":{\"1069\":1}}],[\"如果已经使用了\",{\"1\":{\"255\":1}}],[\"如果已有则插入失败\",{\"1\":{\"568\":1}}],[\"如果安装依赖卡住\",{\"1\":{\"538\":1}}],[\"如果页面内容过期或更新\",{\"1\":{\"534\":1}}],[\"如果给题库表增加题目总数字段\",{\"1\":{\"526\":1}}],[\"如果用同样的参数多次调用\",{\"1\":{\"526\":1}}],[\"如果用户ip和参数匹配\",{\"1\":{\"446\":1}}],[\"如果要弄懂\",{\"1\":{\"1381\":1}}],[\"如果要使用另外的对象\",{\"1\":{\"1131\":1}}],[\"如果要使用\",{\"1\":{\"1090\":1}}],[\"如果要使用本地存储策略\",{\"1\":{\"672\":1}}],[\"如果要查找一个完整的字符串\",{\"1\":{\"802\":1}}],[\"如果要引入\",{\"1\":{\"560\":1}}],[\"如果要对题目题库关联表和题目表同时进行过滤和分页查询\",{\"1\":{\"525\":1}}],[\"如果要启动任务\",{\"1\":{\"482\":1}}],[\"如果要插在k的左边\",{\"1\":{\"404\":1}}],[\"如果检查通过\",{\"1\":{\"465\":1}}],[\"如果两间相邻的房屋在同一晚上被小偷闯入\",{\"1\":{\"826\":1}}],[\"如果两个操作访问同一个变量\",{\"1\":{\"1418\":1}}],[\"如果两个数组长度相同\",{\"1\":{\"1067\":1}}],[\"如果两个值相等\",{\"1\":{\"1020\":1}}],[\"如果两个链表全部遍历完毕后\",{\"1\":{\"699\":1}}],[\"如果两个连通块不连通\",{\"1\":{\"361\":1}}],[\"如果两区间无法合并\",{\"1\":{\"431\":1}}],[\"如果x不在哈希表中\",{\"1\":{\"420\":1}}],[\"如果x在哈希表中\",{\"1\":{\"420\":1}}],[\"如果它是一个链表的头节点\",{\"1\":{\"1274\":1}}],[\"如果它本身不是最小的数\",{\"1\":{\"417\":1}}],[\"如果它们都包含一段位置不一定连续的数\",{\"1\":{\"304\":1}}],[\"如果窗口满足条件\",{\"1\":{\"410\":1}}],[\"如果取模的数是质数\",{\"1\":{\"388\":1}}],[\"如果满足条件\",{\"1\":{\"783\":1}}],[\"如果满足条件再输出结果\",{\"1\":{\"410\":1}}],[\"如果满足\",{\"1\":{\"388\":1}}],[\"如果最后\",{\"1\":{\"368\":1}}],[\"如果最高位有数\",{\"1\":{\"327\":1}}],[\"如果在一个线程观察另一个线程\",{\"1\":{\"1485\":1}}],[\"如果在本线程内观察\",{\"1\":{\"1485\":1}}],[\"如果在下一次竞争中\",{\"1\":{\"1339\":1}}],[\"如果在创建对象时未指定大小\",{\"1\":{\"1326\":1}}],[\"如果在整个查找过程中都还没有遇到脏\",{\"1\":{\"1317\":1}}],[\"如果在整个搜索过程没遇到脏\",{\"1\":{\"1315\":1}}],[\"如果在查找过程中没有找到可以覆盖的entry\",{\"1\":{\"1317\":1}}],[\"如果在查找过程中还未发现脏entry\",{\"1\":{\"1317\":1}}],[\"如果在查找过程中遇到脏\",{\"1\":{\"1307\":1}}],[\"如果在向后环形查找过程中发现key相同的entry就覆盖并且和脏entry进行交换\",{\"1\":{\"1317\":1}}],[\"如果在向后搜索过程中再次遇到脏entry\",{\"1\":{\"1316\":1}}],[\"如果在搜索过程中遇到脏\",{\"1\":{\"1316\":1}}],[\"如果在扫描过程中遇到脏\",{\"1\":{\"1315\":1}}],[\"如果在这种情况用到上述的方法\",{\"1\":{\"1290\":1}}],[\"如果在这一轮的匹配中\",{\"1\":{\"363\":1}}],[\"如果在红黑树中存在与待插入键值对的\",{\"1\":{\"1272\":1}}],[\"如果在同步队列中能够竞争到lock则可以从等待方法中返回\",{\"1\":{\"1410\":1}}],[\"如果在同步队列中能够竞争到\",{\"1\":{\"1248\":1}}],[\"如果在等待状态中被中断会抛出被中断异常\",{\"1\":{\"1248\":1,\"1410\":1}}],[\"如果在配置文件中定义了\",{\"1\":{\"1158\":1}}],[\"如果在业务系统当中\",{\"1\":{\"938\":1}}],[\"如果在所有轮次中\",{\"1\":{\"99\":1}}],[\"如果你确定应用程序里所有的锁通常情况下处于竞争状态\",{\"1\":{\"1444\":1}}],[\"如果你在调用了sublist返回了子list之后\",{\"1\":{\"1072\":1}}],[\"如果你已经自建代理服务并用起来了\",{\"1\":{\"664\":1}}],[\"如果你想找的妹子已经有了男朋友\",{\"1\":{\"363\":1}}],[\"如果你的程序问了一个无效的问题\",{\"1\":{\"249\":1}}],[\"如果途径另一个未匹配点\",{\"1\":{\"363\":1}}],[\"如果该方法返回的是小于等于\",{\"1\":{\"1326\":1}}],[\"如果该节点\",{\"1\":{\"1272\":1}}],[\"如果该许可可用\",{\"1\":{\"1258\":1}}],[\"如果该线程能够从\",{\"1\":{\"1251\":1}}],[\"如果该锁已经被线程所占有了\",{\"1\":{\"1232\":1}}],[\"如果该锁未被任何线程占有\",{\"1\":{\"1232\":1}}],[\"如果该二叉树的左子树不为空\",{\"1\":{\"899\":1}}],[\"如果该数没有被筛掉\",{\"1\":{\"371\":1}}],[\"如果该条边上的两个顶点在一个集合中\",{\"1\":{\"361\":1}}],[\"如果该元素大于栈顶元素\",{\"1\":{\"302\":1}}],[\"如果从1号点到x的最短路中包含至少n个点\",{\"1\":{\"356\":1}}],[\"如果从1号点无法走到n号点则返回\",{\"1\":{\"355\":1}}],[\"如果某个类包含的数据在系统中只应保存一份\",{\"1\":{\"963\":1}}],[\"如果某条最短路径上有n个点\",{\"1\":{\"356\":1}}],[\"如果某一位是奇数\",{\"1\":{\"161\":2}}],[\"如果变短且该点不在队列中\",{\"1\":{\"355\":1}}],[\"如果图不连通\",{\"1\":{\"360\":1}}],[\"如果图中存在负权回路\",{\"1\":{\"354\":1}}],[\"如果图形中允许斜着朝邻近的节点移动\",{\"1\":{\"219\":1}}],[\"如果图形中允许朝任意方向移动\",{\"1\":{\"220\":1}}],[\"如果图形中允许朝任何方向移动\",{\"1\":{\"216\":1}}],[\"如果图形中允许朝八个方向移动\",{\"1\":{\"216\":1}}],[\"如果图形中只允许朝上下左右四个方向移动\",{\"1\":{\"216\":1,\"218\":1}}],[\"如果t\",{\"1\":{\"328\":1}}],[\"如果a\",{\"1\":{\"328\":2,\"1420\":1}}],[\"如果i从0开始那么i\",{\"1\":{\"263\":1}}],[\"如果逆序对的数量是偶数\",{\"1\":{\"224\":1}}],[\"如果答案不唯一\",{\"1\":{\"224\":1}}],[\"如果初始网格如下所示\",{\"1\":{\"224\":1,\"279\":1}}],[\"如果走到一个中间点都cnt\",{\"1\":{\"223\":1}}],[\"如果终点已经被访问过k次了\",{\"1\":{\"223\":1}}],[\"如果第n次迭代仍然会松弛三角不等式\",{\"1\":{\"354\":1}}],[\"如果第三段不符合\",{\"1\":{\"262\":1}}],[\"如果第\",{\"1\":{\"223\":1}}],[\"如果所有右端点都小于l\",{\"1\":{\"430\":1}}],[\"如果所有点都入队了\",{\"1\":{\"349\":1}}],[\"如果所有节点都正方形\",{\"1\":{\"219\":1}}],[\"如果所执行移动的顺序不完全相同\",{\"1\":{\"72\":1}}],[\"如果更小则更新\",{\"1\":{\"215\":1}}],[\"如果邻近节点\",{\"1\":{\"215\":3}}],[\"如果节点总数不是\",{\"1\":{\"680\":1}}],[\"如果节点\",{\"1\":{\"215\":2}}],[\"如果起点和终点之间存在障碍物\",{\"1\":{\"214\":1}}],[\"如果我们需要更大范围的原子性操作就可以使用\",{\"1\":{\"1482\":1}}],[\"如果我们保证读线程无论什么时候都不被阻塞\",{\"1\":{\"1290\":1}}],[\"如果我们可以预先计算出每个节点到终点的距离\",{\"1\":{\"214\":1}}],[\"如果我们能保证最短的两根木桩之和大于最长的木桩\",{\"1\":{\"78\":1}}],[\"如果找到和查询的\",{\"1\":{\"1307\":1}}],[\"如果找到\",{\"1\":{\"1081\":1}}],[\"如果找到了环\",{\"1\":{\"876\":1}}],[\"如果找到了出口\",{\"1\":{\"235\":1}}],[\"如果找到则返回\",{\"1\":{\"187\":1}}],[\"如果找到符合条件的商品\",{\"1\":{\"168\":1}}],[\"如果是多消费者和多生产者情况\",{\"1\":{\"1408\":1}}],[\"如果是周期性执行任务的话\",{\"1\":{\"1368\":1}}],[\"如果是在\",{\"1\":{\"1315\":2}}],[\"如果是那样存的\",{\"1\":{\"1302\":1}}],[\"如果是树节点在红黑树中查找节点\",{\"1\":{\"1273\":1}}],[\"如果是链表节点\",{\"1\":{\"1272\":1}}],[\"如果是独占式锁的话\",{\"1\":{\"1250\":1}}],[\"如果是的话\",{\"1\":{\"1232\":1}}],[\"如果是用接口的方式\",{\"1\":{\"1147\":1}}],[\"如果是闰年输出yes\",{\"1\":{\"984\":1}}],[\"如果是升序\",{\"1\":{\"934\":1}}],[\"如果是顺数第\",{\"1\":{\"777\":1}}],[\"如果是二维\",{\"1\":{\"772\":1}}],[\"如果是\",{\"1\":{\"663\":1,\"1095\":1,\"1334\":1}}],[\"如果是登录或注册页面\",{\"1\":{\"591\":1}}],[\"如果是分布式环境\",{\"1\":{\"526\":1}}],[\"如果是相同的树\",{\"1\":{\"187\":1}}],[\"如果是偶数\",{\"1\":{\"161\":2}}],[\"如果存在冲突\",{\"1\":{\"971\":1}}],[\"如果存在则不创建\",{\"1\":{\"913\":1}}],[\"如果存在负环\",{\"1\":{\"356\":1}}],[\"如果存在\",{\"1\":{\"186\":1,\"224\":1,\"279\":1,\"384\":1}}],[\"如果存在缓存穿透的情况\",{\"1\":{\"60\":1}}],[\"如果小于\",{\"1\":{\"1270\":1,\"1273\":1}}],[\"如果小于60\",{\"1\":{\"984\":1}}],[\"如果小红无法到达右下角\",{\"1\":{\"180\":1}}],[\"如果小红血量为\",{\"1\":{\"180\":1}}],[\"如果小紫会被魔法水晶箭攻击到\",{\"1\":{\"97\":1}}],[\"如果小紫中途不更改行进方向和速度\",{\"1\":{\"97\":1}}],[\"如果区间大小只有\",{\"1\":{\"174\":1}}],[\"如果没有设置\",{\"1\":{\"1442\":1}}],[\"如果没有遇到脏\",{\"1\":{\"1315\":1}}],[\"如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处\",{\"1\":{\"1431\":1}}],[\"如果没有获取\",{\"1\":{\"1252\":1}}],[\"如果没有抓取到\",{\"1\":{\"1182\":1}}],[\"如果没有\",{\"1\":{\"1069\":1,\"1276\":1,\"1358\":1}}],[\"如果没有特别指明\",{\"1\":{\"958\":1}}],[\"如果没有条件\",{\"1\":{\"926\":1,\"927\":1}}],[\"如果没有任何一种硬币组合能组成总金额\",{\"1\":{\"892\":1}}],[\"如果没有登录\",{\"1\":{\"587\":1}}],[\"如果没有唯一性约束\",{\"1\":{\"526\":1}}],[\"如果没有在树中\",{\"1\":{\"360\":1}}],[\"如果没有重置\",{\"1\":{\"235\":1}}],[\"如果没有买到足够的商品\",{\"1\":{\"168\":1}}],[\"如果没有合法方案\",{\"1\":{\"126\":1}}],[\"如果下一块不存在的话\",{\"1\":{\"128\":1}}],[\"如果匹配则输出一行\",{\"1\":{\"127\":1}}],[\"如果往右移动\",{\"1\":{\"110\":1}}],[\"如果栈为空\",{\"1\":{\"93\":1}}],[\"如果栈不为空\",{\"1\":{\"93\":1,\"128\":2}}],[\"如果不出现线程安全的问题最终的结果应该就是\",{\"1\":{\"1482\":1}}],[\"如果不出现哈希冲突的时候\",{\"1\":{\"1272\":1}}],[\"如果不使用同步的话\",{\"1\":{\"1449\":1}}],[\"如果不使用脚手架\",{\"1\":{\"539\":1}}],[\"如果不用考虑这些线程在运行时环境下的调度和交替运行\",{\"1\":{\"1415\":1}}],[\"如果不处理\",{\"1\":{\"1044\":1}}],[\"如果不加该参数项\",{\"1\":{\"923\":1}}],[\"如果不在则直接返回\",{\"1\":{\"899\":1}}],[\"如果不在一个集合中\",{\"1\":{\"361\":1}}],[\"如果不指向任何节点\",{\"1\":{\"886\":1}}],[\"如果不可能\",{\"1\":{\"868\":1}}],[\"如果不是周期性任务\",{\"1\":{\"1368\":1}}],[\"如果不是周期性执行任务\",{\"1\":{\"1368\":1}}],[\"如果不是的话就直接调用\",{\"1\":{\"1368\":1}}],[\"如果不是\",{\"1\":{\"1358\":1}}],[\"如果不是树节点\",{\"1\":{\"1273\":1}}],[\"如果不是数值类型\",{\"1\":{\"932\":1}}],[\"如果不是首次遍历\",{\"1\":{\"736\":1}}],[\"如果不是起点\",{\"1\":{\"349\":1}}],[\"如果不将它注册为一个进程\",{\"1\":{\"671\":1}}],[\"如果不想用默认创建的管理员账号密码\",{\"1\":{\"670\":1}}],[\"如果不能覆盖掉右端点\",{\"1\":{\"427\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"1418\":1}}],[\"如果不存在公共子序列\",{\"1\":{\"838\":1}}],[\"如果不存在\",{\"1\":{\"353\":1,\"686\":1}}],[\"如果不存在则返回\",{\"1\":{\"352\":1}}],[\"如果不存在解决方案\",{\"1\":{\"224\":1,\"279\":1}}],[\"如果不选择当前数\",{\"1\":{\"126\":1}}],[\"如果不匹配则输出一行\",{\"1\":{\"127\":1}}],[\"如果不匹配\",{\"1\":{\"93\":1}}],[\"如果不这么做那么会有很多的进程向\",{\"1\":{\"60\":1}}],[\"如果有必要就重写\",{\"1\":{\"1472\":1}}],[\"如果有业务场景需要进行流量控制\",{\"1\":{\"1398\":1}}],[\"如果有前驱节点说明有线程比当前线程更早的请求资源\",{\"1\":{\"1233\":1}}],[\"如果有些接口是不需要验证权限可以公开访问的\",{\"1\":{\"468\":1}}],[\"如果有参数\",{\"1\":{\"446\":5}}],[\"如果有两个大于\",{\"1\":{\"368\":1}}],[\"如果有那就使在同一个集合中\",{\"1\":{\"361\":1}}],[\"如果有\",{\"1\":{\"328\":1,\"372\":1,\"1276\":1}}],[\"如果有一部分遍历完了\",{\"1\":{\"318\":1,\"833\":1}}],[\"如果有一位没用上\",{\"1\":{\"291\":1}}],[\"如果有多个队伍则会选择编号最小的队伍\",{\"1\":{\"205\":1}}],[\"如果有多个商品保质期相同\",{\"1\":{\"168\":2}}],[\"如果有多个满足条件的区间\",{\"1\":{\"78\":1}}],[\"如果有这个\",{\"1\":{\"60\":1}}],[\"如果和\",{\"1\":{\"56\":1}}],[\"如果\",{\"1\":{\"56\":1,\"87\":2,\"93\":2,\"99\":1,\"108\":2,\"127\":4,\"167\":1,\"174\":1,\"187\":1,\"215\":1,\"216\":4,\"261\":1,\"262\":1,\"317\":1,\"328\":1,\"361\":1,\"373\":1,\"376\":1,\"383\":1,\"384\":1,\"388\":1,\"407\":1,\"526\":1,\"712\":3,\"789\":1,\"795\":1,\"846\":1,\"852\":1,\"1242\":1,\"1253\":1,\"1283\":4,\"1284\":1,\"1313\":1,\"1317\":1,\"1375\":1,\"1384\":1,\"1420\":1,\"1421\":1,\"1432\":1,\"1439\":1,\"1455\":1,\"1466\":2,\"1467\":2,\"1485\":1,\"1504\":3}}],[\"如果为无穷大\",{\"1\":{\"352\":1}}],[\"如果为空\",{\"1\":{\"93\":1,\"525\":1}}],[\"如果为\",{\"1\":{\"56\":1,\"1266\":2}}],[\"如果短时间内多个服务节点的大量请求缓存未命中\",{\"1\":{\"28\":1}}],[\"如何关闭偏向锁\",{\"0\":{\"1444\":1}}],[\"如何合理配置线程池参数\",{\"0\":{\"1361\":1}}],[\"如何进行扩容\",{\"1\":{\"1306\":1}}],[\"如何正确理解由于jmm内存模型在原子性\",{\"1\":{\"1221\":1}}],[\"如何正确的使用多线程编程技术有很大的学问\",{\"1\":{\"1221\":1}}],[\"如何实现\",{\"0\":{\"1214\":1}}],[\"如何理解\",{\"1\":{\"1129\":1}}],[\"如何把头脑中的想法变成简洁的代码\",{\"1\":{\"987\":1}}],[\"如何翻转二叉树\",{\"1\":{\"863\":1}}],[\"如何自建代理服务\",{\"0\":{\"662\":1}}],[\"如何设计一个url短链服务\",{\"1\":{\"634\":1}}],[\"如何设计\",{\"1\":{\"632\":1,\"634\":1}}],[\"如何设计广告点击信息的处理流程\",{\"1\":{\"151\":1}}],[\"如何知道是哪个用户登录了\",{\"0\":{\"575\":1}}],[\"如何只交给同进程内\",{\"1\":{\"60\":1}}],[\"如何对文章下面的评论做排序\",{\"1\":{\"41\":1}}],[\"如何在b站评论区脱颖而出\",{\"1\":{\"39\":1,\"41\":1}}],[\"如粉丝勋章\",{\"1\":{\"34\":1}}],[\"如审核\",{\"1\":{\"34\":1}}],[\"如\",{\"1\":{\"31\":1,\"103\":1,\"115\":2,\"273\":1,\"355\":1,\"411\":1,\"434\":3,\"465\":1,\"915\":2,\"942\":1,\"958\":1,\"1044\":2,\"1135\":1,\"1306\":1,\"1326\":1}}],[\"如同调味剂\",{\"1\":{\"21\":1}}],[\"如汽车\",{\"1\":{\"21\":1}}],[\"播放器中直接滚动播放的弹幕\",{\"1\":{\"21\":1}}],[\"舞蹈或艺术展览\",{\"1\":{\"21\":1}}],[\"戏剧\",{\"1\":{\"21\":1}}],[\"电影\",{\"1\":{\"1093\":1}}],[\"电影评论\",{\"1\":{\"21\":1}}],[\"电子书\",{\"0\":{\"655\":1},\"2\":{\"657\":1}}],[\"电子游戏\",{\"1\":{\"21\":1}}],[\"电商库存系统的防超卖和高并发扣减方案\",{\"1\":{\"632\":1}}],[\"电话号\",{\"1\":{\"1131\":1}}],[\"电话\",{\"1\":{\"566\":2,\"592\":1}}],[\"评论内容可以使用\",{\"1\":{\"57\":1}}],[\"评论内容表\",{\"1\":{\"56\":1}}],[\"评论索引与评论内容分开两张表来存\",{\"1\":{\"57\":1}}],[\"评论索引表和主题表用一个事务更新\",{\"1\":{\"57\":1}}],[\"评论索引表\",{\"1\":{\"56\":1}}],[\"评论总数等\",{\"1\":{\"56\":1}}],[\"评论楼层\",{\"1\":{\"56\":1}}],[\"评论主题表\",{\"1\":{\"56\":1}}],[\"评论详情页等类似场景\",{\"1\":{\"40\":1}}],[\"评论策略层\",{\"1\":{\"40\":1}}],[\"评论计数不准\",{\"1\":{\"37\":1}}],[\"评论数据合规\",{\"1\":{\"36\":1}}],[\"评论系统分为三张表\",{\"1\":{\"56\":1}}],[\"评论系统和可用性设计\",{\"0\":{\"54\":1},\"1\":{\"54\":1}}],[\"评论系统可能有的功能\",{\"1\":{\"45\":1}}],[\"评论系统功能和架构设计\",{\"0\":{\"44\":1},\"1\":{\"44\":1}}],[\"评论系统\",{\"1\":{\"45\":1},\"2\":{\"43\":1,\"53\":1,\"63\":1}}],[\"评论系统的数据安全还包括\",{\"1\":{\"36\":1}}],[\"评论系统的安全性设计可以分为\",{\"1\":{\"35\":1}}],[\"评论系统是一个同城读双活的架构\",{\"1\":{\"34\":1}}],[\"评论系统对数据库的选型要求\",{\"1\":{\"30\":1}}],[\"评论列表的业务数据模型也包含部分个性化信息\",{\"1\":{\"33\":1}}],[\"评论表的插入\",{\"1\":{\"33\":1}}],[\"评论表和评论区表的字段主要包括4种\",{\"1\":{\"30\":1}}],[\"评论回复的树形关系\",{\"1\":{\"30\":1}}],[\"评论区作为b站社区的重要组成部分\",{\"1\":{\"41\":1}}],[\"评论区评论计数的更新\",{\"1\":{\"33\":1}}],[\"评论区维度的串行\",{\"1\":{\"33\":1}}],[\"评论区的一些关键属性\",{\"1\":{\"30\":1}}],[\"评论区属性是一个整型的\",{\"1\":{\"30\":1}}],[\"评论区属性等\",{\"1\":{\"30\":1}}],[\"评论区状态是一个枚举值\",{\"1\":{\"30\":1}}],[\"评论区状态\",{\"1\":{\"30\":1}}],[\"评论需要至少两张表\",{\"1\":{\"30\":1}}],[\"评论异步处理层\",{\"1\":{\"28\":1}}],[\"评论基础服务层集成了多级缓存\",{\"1\":{\"34\":1}}],[\"评论基础服务层\",{\"1\":{\"27\":1}}],[\"评论管理服务层\",{\"1\":{\"26\":1}}],[\"评论是主体内容的外延\",{\"1\":{\"23\":1}}],[\"评论是人们对出版物\",{\"1\":{\"21\":1}}],[\"评论装扮\",{\"1\":{\"22\":1}}],[\"评论标签\",{\"1\":{\"22\":1}}],[\"评论富文本展示\",{\"1\":{\"22\":1}}],[\"评论一般还包括一些更高阶的基础功能\",{\"1\":{\"22\":1}}],[\"评论互动\",{\"1\":{\"22\":1}}],[\"评论的读热点集中在评论列表的第一页\",{\"1\":{\"33\":1}}],[\"评论的读热点也有一些典型的特征\",{\"1\":{\"33\":1}}],[\"评论的基础功能模块是相对稳定的\",{\"1\":{\"22\":1}}],[\"评论的作者还可以对作品进行内容分级以表明其相对价值\",{\"1\":{\"21\":1}}],[\"评论\",{\"1\":{\"21\":1,\"30\":3,\"41\":1}}],[\"资料\",{\"1\":{\"661\":1}}],[\"资料等等\",{\"1\":{\"19\":1}}],[\"资源共享\",{\"1\":{\"14\":1}}],[\"常量的方式不易于修改\",{\"1\":{\"1147\":1}}],[\"常量的方式较容易取错变量\",{\"1\":{\"1147\":1}}],[\"常量\",{\"1\":{\"978\":1}}],[\"常作为临时表\",{\"1\":{\"951\":1}}],[\"常规的广度优先搜索只有一个起点\",{\"1\":{\"869\":1}}],[\"常规方法\",{\"1\":{\"693\":1}}],[\"常见命令以\",{\"1\":{\"671\":1}}],[\"常见的情况是\",{\"1\":{\"1131\":1}}],[\"常见的探测方法包括线性探测\",{\"1\":{\"971\":1}}],[\"常见的有阿里云对象存储服务\",{\"1\":{\"1094\":1}}],[\"常见的有\",{\"1\":{\"661\":1,\"1107\":1}}],[\"常见的几种路由规则如下\",{\"1\":{\"542\":1}}],[\"常见模型\",{\"1\":{\"407\":1,\"410\":1}}],[\"常见问题分类\",{\"1\":{\"340\":1}}],[\"常见中间件主要分为\",{\"1\":{\"14\":1}}],[\"常用语言的\",{\"1\":{\"1095\":1}}],[\"常用方法\",{\"1\":{\"1069\":1}}],[\"常用注解\",{\"0\":{\"1052\":1}}],[\"常用容器\",{\"0\":{\"1035\":1}}],[\"常用ascii值\",{\"1\":{\"1004\":1}}],[\"常用api\",{\"0\":{\"1002\":1,\"1055\":1,\"1060\":1,\"1066\":1},\"1\":{\"1005\":1}}],[\"常用比较运算符\",{\"1\":{\"984\":1}}],[\"常用聚合函数\",{\"1\":{\"932\":1}}],[\"常用的\",{\"0\":{\"1326\":1}}],[\"常用的操作符\",{\"1\":{\"948\":1,\"949\":1,\"950\":1}}],[\"常用的逻辑运算符如下\",{\"1\":{\"931\":1}}],[\"常用的比较运算符如下\",{\"1\":{\"931\":1}}],[\"常用的元信息文件不是放在\",{\"1\":{\"543\":1}}],[\"常用库函数\",{\"0\":{\"423\":1}}],[\"常用来对一个数据的某些位设置为1\",{\"1\":{\"338\":1}}],[\"常用模版\",{\"1\":{\"307\":1}}],[\"常用于配合\",{\"1\":{\"252\":1}}],[\"常用框架\",{\"0\":{\"17\":1},\"2\":{\"472\":1,\"490\":1,\"1142\":1,\"1173\":1,\"1187\":1,\"1197\":1}}],[\"为保证能够释放\",{\"1\":{\"1492\":1}}],[\"为保持\",{\"1\":{\"1081\":1}}],[\"为程序员在上层提供了六条规则\",{\"1\":{\"1419\":1}}],[\"为止\",{\"1\":{\"1392\":1}}],[\"为位置\",{\"1\":{\"1317\":2}}],[\"为哈希表已插入\",{\"1\":{\"1316\":1}}],[\"为哈希表的长度\",{\"1\":{\"1315\":1,\"1316\":1}}],[\"为每个线程都分配了一份对象\",{\"1\":{\"1313\":1}}],[\"为每一个\",{\"1\":{\"1264\":1}}],[\"为新容量的\",{\"1\":{\"1274\":1}}],[\"为红黑树的树节点时的操作为\",{\"1\":{\"1272\":1}}],[\"为红黑树的根节点\",{\"1\":{\"1272\":1}}],[\"为当前索引\",{\"1\":{\"1317\":1}}],[\"为当前\",{\"1\":{\"1315\":1}}],[\"为当前新增的\",{\"1\":{\"1283\":1}}],[\"为当前桶的所有的节点组成的链表的头结点\",{\"1\":{\"1272\":1}}],[\"为当前最大值\",{\"1\":{\"705\":1}}],[\"为链表的头结点\",{\"1\":{\"1272\":1}}],[\"为四分之三\",{\"1\":{\"1271\":1}}],[\"为0则释放写锁\",{\"1\":{\"1240\":1}}],[\"为最终默认实现\",{\"1\":{\"1137\":1}}],[\"为被注入对象提供被依赖对象有如下几种方式\",{\"1\":{\"1133\":1}}],[\"为被注入对象服务的目的\",{\"1\":{\"1129\":1}}],[\"为何是反转\",{\"1\":{\"1129\":2}}],[\"为脚本解释器\",{\"1\":{\"1107\":1}}],[\"为接口\",{\"1\":{\"1076\":1}}],[\"为根的子树\",{\"1\":{\"899\":1}}],[\"为根的这棵二叉树已经被翻转\",{\"1\":{\"864\":1}}],[\"为根的这棵二叉树翻转\",{\"1\":{\"864\":1}}],[\"为子节点\",{\"1\":{\"802\":2}}],[\"为头的这条链表进行翻转\",{\"1\":{\"681\":1}}],[\"为方便前后端联调显示用户的登录状态\",{\"1\":{\"580\":1}}],[\"为方法的参数\",{\"1\":{\"465\":1}}],[\"为基础模版\",{\"1\":{\"548\":1}}],[\"为具体的题库\",{\"1\":{\"525\":1}}],[\"为实用功能\",{\"1\":{\"506\":1}}],[\"为重点功能\",{\"1\":{\"506\":1}}],[\"为核心\",{\"1\":{\"506\":1}}],[\"为什么\",{\"0\":{\"1478\":1}}],[\"为什么使用弱引用\",{\"0\":{\"1318\":1}}],[\"为什么是遇到\",{\"1\":{\"1316\":1}}],[\"为什么要使用\",{\"1\":{\"1369\":1}}],[\"为什么要使用线程池\",{\"0\":{\"1357\":1}}],[\"为什么要用到并发\",{\"0\":{\"1218\":1}}],[\"为什么要配置进程守护呢\",{\"1\":{\"671\":1}}],[\"为什么还会有其他\",{\"1\":{\"1157\":1}}],[\"为什么每次遇到岛屿\",{\"1\":{\"820\":1}}],[\"为什么需要复制呢\",{\"1\":{\"1295\":1}}],[\"为什么需要\",{\"1\":{\"484\":1}}],[\"为什么基础功能的原子化实现需要架构的补充呢\",{\"1\":{\"28\":1}}],[\"为推动数仓和数据湖的打通融合\",{\"1\":{\"438\":1}}],[\"为解决复杂的业务问题提供了新的解决方案\",{\"1\":{\"434\":1}}],[\"为x的后继节点y1\",{\"1\":{\"398\":1}}],[\"为求出不属于集合s的最小非负整数的运算\",{\"1\":{\"397\":1}}],[\"为质数时\",{\"1\":{\"388\":1}}],[\"为避免这种情况\",{\"1\":{\"338\":1}}],[\"为右下角的子矩阵中的所有元素加上c\",{\"1\":{\"335\":1}}],[\"为右下角的子矩阵的和为\",{\"1\":{\"333\":1}}],[\"为左上角\",{\"1\":{\"333\":1,\"335\":1}}],[\"为左子字符串中\",{\"1\":{\"71\":1}}],[\"为高兴值\",{\"1\":{\"314\":1}}],[\"为父亲\",{\"1\":{\"314\":1}}],[\"为亲戚\",{\"1\":{\"273\":1}}],[\"为人数\",{\"1\":{\"273\":1}}],[\"为第\",{\"1\":{\"314\":2}}],[\"为第三段\",{\"1\":{\"262\":1}}],[\"为第一段\",{\"1\":{\"262\":1}}],[\"为路\",{\"1\":{\"236\":1,\"237\":1}}],[\"为墙\",{\"1\":{\"236\":1,\"237\":1}}],[\"为防止数组越界\",{\"1\":{\"228\":1}}],[\"为例的话\",{\"1\":{\"1477\":1}}],[\"为例来看看具体的使用\",{\"1\":{\"1388\":1}}],[\"为例总结常用的方法\",{\"1\":{\"1385\":1}}],[\"为例\",{\"1\":{\"228\":1,\"229\":1,\"230\":1,\"235\":1,\"236\":1,\"237\":1,\"517\":1,\"1387\":1}}],[\"为搜索方便\",{\"1\":{\"228\":1}}],[\"为节点\",{\"1\":{\"215\":1}}],[\"为终点\",{\"1\":{\"215\":1}}],[\"为起点进行\",{\"1\":{\"1317\":1}}],[\"为起点开始进行清理脏\",{\"1\":{\"1317\":4}}],[\"为起点在初始小范围\",{\"1\":{\"1316\":1}}],[\"为起点\",{\"1\":{\"197\":1,\"237\":1}}],[\"为空时\",{\"1\":{\"1407\":1}}],[\"为空节点\",{\"1\":{\"887\":1}}],[\"为空\",{\"1\":{\"187\":1,\"1407\":1}}],[\"为游戏节点的个数\",{\"1\":{\"146\":1}}],[\"为此\",{\"1\":{\"1457\":1}}],[\"为此他对该游戏速通了\",{\"1\":{\"146\":1}}],[\"为此需要一个游戏的排行榜\",{\"1\":{\"129\":1}}],[\"为设计漂亮美观的花坛\",{\"1\":{\"141\":1}}],[\"为正整数\",{\"1\":{\"139\":1}}],[\"为了避免无用的自旋\",{\"1\":{\"1447\":1}}],[\"为了避免删除倒数第一个元素时出现空指针异常\",{\"1\":{\"777\":1}}],[\"为了让线程获得锁的代价更低而引入了偏向锁\",{\"1\":{\"1441\":1}}],[\"为了禁止特定类型的重排序会对编译器和处理器指令序列加以控制\",{\"1\":{\"1423\":1}}],[\"为了平衡这种巨大的差距\",{\"1\":{\"1417\":1}}],[\"为了性能优化\",{\"1\":{\"1415\":1,\"1457\":1,\"1485\":1}}],[\"为了理解\",{\"1\":{\"1393\":1}}],[\"为了实现\",{\"1\":{\"1457\":2}}],[\"为了实现其\",{\"1\":{\"1369\":1}}],[\"为了实现数据实时性\",{\"1\":{\"1295\":1}}],[\"为了加深对阻塞队列的理解\",{\"1\":{\"1344\":1}}],[\"为了业务解耦和架构设计\",{\"1\":{\"1344\":1}}],[\"为了防止\",{\"1\":{\"1326\":1}}],[\"为了复用线程是不会结束的\",{\"1\":{\"1313\":1}}],[\"为了能够理解\",{\"1\":{\"1392\":1}}],[\"为了能够弄懂\",{\"1\":{\"1385\":1}}],[\"为了能够很好的理解这种情况\",{\"1\":{\"1283\":1}}],[\"为了能够更加精准知道报错的信息\",{\"1\":{\"598\":1}}],[\"为了方便下面的理解\",{\"1\":{\"1283\":1}}],[\"为了方面下面的讲解这里先直接给出\",{\"1\":{\"1272\":1}}],[\"为了统计元素个数\",{\"1\":{\"1275\":1}}],[\"为了保证各个处理器的缓存是一致的\",{\"1\":{\"1454\":1}}],[\"为了保证\",{\"1\":{\"1368\":1}}],[\"为了保证可阻塞式的插入删除数据利用的是\",{\"1\":{\"1346\":1}}],[\"为了保证线程安全\",{\"1\":{\"1346\":1,\"1387\":1}}],[\"为了保证能够正确初始化\",{\"1\":{\"1271\":1}}],[\"为了保证数据完整性\",{\"1\":{\"31\":1}}],[\"为了满足\",{\"1\":{\"1270\":1,\"1370\":1}}],[\"为了支持重入性\",{\"1\":{\"1232\":1}}],[\"为了提高处理速度\",{\"1\":{\"1454\":1}}],[\"为了提高性能\",{\"1\":{\"1418\":1}}],[\"为了提高范围查询效率\",{\"1\":{\"958\":1}}],[\"为了提升响应速度\",{\"1\":{\"1218\":1}}],[\"为了减少冲突\",{\"1\":{\"973\":1}}],[\"为了判断是否有永远不会腐烂的橘子\",{\"1\":{\"869\":1}}],[\"为了比大小\",{\"1\":{\"851\":1}}],[\"为了优化算法\",{\"1\":{\"712\":1}}],[\"为了更方便地管理防火墙和端口规则\",{\"1\":{\"663\":1}}],[\"为了某些学习目的\",{\"1\":{\"661\":1}}],[\"为了区分服务端和客户端渲染\",{\"1\":{\"545\":1}}],[\"为了简化实现\",{\"1\":{\"525\":1}}],[\"为了简化设计\",{\"1\":{\"512\":1}}],[\"为了解耦生产者和消费者的关系\",{\"1\":{\"1402\":1}}],[\"为了解决\",{\"1\":{\"1314\":1}}],[\"为了解决潜在的内存泄漏的问题\",{\"1\":{\"1307\":1}}],[\"为了解决散列冲突\",{\"1\":{\"1306\":1}}],[\"为了解决线程安全的问题\",{\"1\":{\"1272\":1,\"1280\":1}}],[\"为了解决这些问题\",{\"1\":{\"484\":1}}],[\"为了解答这个问题\",{\"1\":{\"481\":1}}],[\"为了节约成本\",{\"1\":{\"173\":1}}],[\"为了确定数字\",{\"1\":{\"99\":1}}],[\"为了找到两个用户群体都有空闲时间可以进行共同活动的时间段\",{\"1\":{\"70\":1}}],[\"为\",{\"1\":{\"56\":1,\"152\":1,\"274\":1,\"338\":2,\"388\":2,\"392\":1,\"662\":1,\"664\":1,\"672\":1,\"766\":1,\"845\":2,\"852\":1,\"922\":1,\"926\":1,\"1184\":1,\"1239\":3,\"1251\":1,\"1271\":1,\"1272\":1,\"1282\":1,\"1283\":4,\"1284\":2,\"1301\":3,\"1302\":4,\"1305\":5,\"1306\":2,\"1313\":2,\"1314\":1,\"1316\":6,\"1317\":9,\"1318\":1,\"1359\":1,\"1361\":1,\"1392\":1,\"1504\":1}}],[\"为业务在评论区获得更好的曝光展现\",{\"1\":{\"34\":1}}],[\"为一些长耗时\",{\"1\":{\"28\":1}}],[\"为评论基础功能的原子化实现\",{\"1\":{\"28\":1}}],[\"为多个内部管理后台提供服务\",{\"1\":{\"26\":1}}],[\"为用户营造更好的评论区氛围\",{\"1\":{\"22\":1}}],[\"为应用软件间共享资源提供了可复用的\",{\"1\":{\"14\":1}}],[\"为上层应用软件提供开发\",{\"1\":{\"14\":1}}],[\"并重写需要的\",{\"1\":{\"1496\":1}}],[\"并重写了\",{\"1\":{\"1371\":1}}],[\"并成功返回\",{\"1\":{\"1421\":1}}],[\"并成功更新\",{\"1\":{\"1383\":1,\"1437\":1}}],[\"并能保证线程安全的类去更新基本类型变量\",{\"1\":{\"1380\":1}}],[\"并抛出\",{\"1\":{\"1359\":1}}],[\"并满足线程安全的特性\",{\"1\":{\"1353\":1}}],[\"并执行完成功退出\",{\"1\":{\"1348\":1}}],[\"并等待这下次分配\",{\"1\":{\"1339\":1}}],[\"并等待被\",{\"1\":{\"1221\":1}}],[\"并给另一个线程一个机会来运行\",{\"1\":{\"1331\":1}}],[\"并由消费者提取\",{\"1\":{\"1326\":1}}],[\"并由于\",{\"1\":{\"1254\":1}}],[\"并未变化\",{\"1\":{\"1283\":1}}],[\"并拥有\",{\"1\":{\"1267\":1}}],[\"并通过\",{\"1\":{\"1283\":1,\"1368\":1,\"1371\":1}}],[\"并通过重写同步器\",{\"1\":{\"1239\":1}}],[\"并通知所有的等待线程后释放锁\",{\"1\":{\"1254\":1}}],[\"并省略了\",{\"1\":{\"1251\":1}}],[\"并没有初始化成功\",{\"1\":{\"1485\":1}}],[\"并没有\",{\"1\":{\"1431\":1}}],[\"并没有再次对等待条件进行判断\",{\"1\":{\"1407\":1}}],[\"并没有打印\",{\"1\":{\"1340\":1}}],[\"并没有闲下来\",{\"1\":{\"1316\":1}}],[\"并没有进行重试\",{\"1\":{\"1284\":1}}],[\"并没有考虑到当前同步队列中线程等待的情况\",{\"1\":{\"1233\":1}}],[\"并没有return\",{\"1\":{\"223\":1}}],[\"并行程序会比串行程序更适应业务需求\",{\"1\":{\"1218\":1}}],[\"并不能保证原子性\",{\"1\":{\"1482\":1}}],[\"并不意味着\",{\"1\":{\"1420\":1}}],[\"并不需要关心消费者的行为\",{\"1\":{\"1402\":1}}],[\"并不需要等待\",{\"1\":{\"1186\":1}}],[\"并不断的从阻塞对列中获取异步任务执行交给\",{\"1\":{\"1371\":1}}],[\"并不会进行垃圾回收\",{\"1\":{\"1318\":1}}],[\"并不会进行修改\",{\"1\":{\"1293\":1}}],[\"并不仅仅局限于处理当前已知的脏\",{\"1\":{\"1317\":1}}],[\"并不在\",{\"1\":{\"1299\":1}}],[\"并不是武断的间线程挂起\",{\"1\":{\"1384\":1,\"1437\":1}}],[\"并不是一种特别高效的解决方案\",{\"1\":{\"1380\":1}}],[\"并不是一个线程安全的容器\",{\"1\":{\"1290\":1}}],[\"并不是代表当前线程不再运行了\",{\"1\":{\"1339\":1}}],[\"并不是指向队列真正的尾节点\",{\"1\":{\"1283\":1}}],[\"并不是线程安全的\",{\"1\":{\"1264\":1,\"1290\":1}}],[\"并不是第一行\",{\"1\":{\"385\":1}}],[\"并放到\",{\"1\":{\"1149\":1}}],[\"并形成一个全局的命名空间\",{\"1\":{\"1095\":1}}],[\"并调整堆\",{\"1\":{\"1078\":1}}],[\"并调整布局\",{\"1\":{\"588\":1}}],[\"并令引用变量\",{\"1\":{\"1069\":1}}],[\"并填入arr的值\",{\"1\":{\"1067\":1}}],[\"并唤醒被该锁阻塞的其他线程\",{\"1\":{\"1061\":1}}],[\"并可根据\",{\"1\":{\"1137\":1}}],[\"并可能需要处理冲突链表或调整开放寻址中的空闲位置\",{\"1\":{\"971\":1}}],[\"并可以进行任意次操作\",{\"1\":{\"104\":1}}],[\"并复原原链表\",{\"1\":{\"888\":1}}],[\"并建立\",{\"1\":{\"887\":1}}],[\"并向\",{\"1\":{\"887\":1}}],[\"并使原链表和复制链表中的这些指针能够表示相同的链表状态\",{\"1\":{\"886\":1}}],[\"并使用列式存储优化\",{\"1\":{\"436\":1}}],[\"并判断其是否是\",{\"1\":{\"846\":1}}],[\"并以相同形式返回一个表示和的链表\",{\"1\":{\"698\":1}}],[\"并更改大小为理论最大文件尺寸\",{\"1\":{\"672\":1}}],[\"并更新最大岛屿面积\",{\"1\":{\"230\":1}}],[\"并更新全局最大值\",{\"1\":{\"66\":1}}],[\"并持续运行以提供某种服务或执行特定任务\",{\"1\":{\"671\":1}}],[\"并解压\",{\"1\":{\"665\":1}}],[\"并添加如下配置\",{\"1\":{\"664\":1}}],[\"并把协议链接录入测试\",{\"1\":{\"662\":1}}],[\"并设置端口为\",{\"1\":{\"662\":1}}],[\"并设置安全组开放\",{\"1\":{\"662\":1,\"664\":1}}],[\"并设置优先级为\",{\"1\":{\"215\":1}}],[\"并记得要在\",{\"1\":{\"575\":1}}],[\"并运行\",{\"1\":{\"559\":1}}],[\"并加载不同的题目\",{\"1\":{\"542\":1}}],[\"并加入\",{\"1\":{\"215\":1}}],[\"并继续处理动态交互\",{\"1\":{\"535\":1}}],[\"并继续比较后续节点\",{\"1\":{\"134\":1}}],[\"并减少构建时间\",{\"1\":{\"534\":1}}],[\"并进行必要的处理和转换\",{\"1\":{\"533\":1}}],[\"并进行路径压缩\",{\"1\":{\"270\":1}}],[\"并完成面试吧\",{\"1\":{\"529\":1}}],[\"并优化报错文案\",{\"1\":{\"526\":1}}],[\"并批量关联题目到题库\",{\"1\":{\"493\":1}}],[\"并根据数据动态生成页面内容\",{\"1\":{\"531\":1}}],[\"并根据状态判断是否执行任务调度\",{\"1\":{\"481\":1}}],[\"并根据结果升序排序\",{\"1\":{\"181\":1}}],[\"并构建起一个完整的菜单树结构\",{\"1\":{\"458\":1}}],[\"并移动数据\",{\"1\":{\"437\":1}}],[\"并回代得到方程的解\",{\"1\":{\"385\":1}}],[\"并逐位执行操作\",{\"1\":{\"337\":1}}],[\"并按引用捕获\",{\"1\":{\"255\":1}}],[\"并作为副本在函数体中使用\",{\"1\":{\"255\":1}}],[\"并作为引用在函数体中使用\",{\"1\":{\"255\":1}}],[\"并非真正的无穷大\",{\"1\":{\"354\":1}}],[\"并非字符串的首地址\",{\"1\":{\"243\":1}}],[\"并非所有场景下都能做到这一点\",{\"1\":{\"216\":1}}],[\"并返回旧值\",{\"1\":{\"1385\":1}}],[\"并返回最终相加后的结果\",{\"1\":{\"1385\":1}}],[\"并返回最后的结果\",{\"1\":{\"1385\":1}}],[\"并返回等待执行任务的列表\",{\"1\":{\"1360\":1}}],[\"并返回该方法返回的value\",{\"1\":{\"1302\":1}}],[\"并返回该子数组所对应的乘积\",{\"1\":{\"704\":1}}],[\"并返回原来的值\",{\"1\":{\"1074\":1}}],[\"并返回删除元素e\",{\"1\":{\"1072\":1}}],[\"并返回栈顶元素\",{\"1\":{\"1037\":1}}],[\"并返回其根节点\",{\"1\":{\"862\":1}}],[\"并返回交换后链表的头节点\",{\"1\":{\"692\":1}}],[\"并返回操作结果\",{\"1\":{\"482\":1}}],[\"并返回淹没的陆地面积\",{\"1\":{\"230\":1}}],[\"并返回\",{\"1\":{\"181\":1,\"447\":1,\"1010\":1,\"1302\":1}}],[\"并在某个时刻将工作内存的变量副本写回到主存中去\",{\"1\":{\"1417\":1}}],[\"并在多线程的情况下\",{\"1\":{\"1388\":1}}],[\"并在单线程里维持多个任务间的切换\",{\"1\":{\"1220\":1}}],[\"并在服务端渲染页面的初始内容\",{\"1\":{\"535\":1}}],[\"并在gi上行动一步\",{\"1\":{\"399\":1}}],[\"并在线段树中将该商品的保质期设为\",{\"1\":{\"168\":1}}],[\"并在后续将点击信息异步回传给外部广告平台\",{\"1\":{\"151\":1}}],[\"并从中挑选\",{\"1\":{\"168\":1}}],[\"并对\",{\"1\":{\"167\":1}}],[\"并标记该桌子已被占用\",{\"1\":{\"162\":1}}],[\"并保证数据的及时性和准确性\",{\"1\":{\"151\":1}}],[\"并与存储的加密密码进行比对\",{\"1\":{\"568\":1}}],[\"并与\",{\"1\":{\"146\":1}}],[\"并获得一次对应的优惠券\",{\"1\":{\"109\":1}}],[\"并将对象头中的\",{\"1\":{\"1446\":1}}],[\"并将对应指针向后移动一位\",{\"1\":{\"92\":1}}],[\"并将其插入到新的\",{\"1\":{\"1306\":1}}],[\"并将其转换成\",{\"1\":{\"1139\":1}}],[\"并将旧数组的数据复制到新数组中\",{\"1\":{\"1294\":1}}],[\"并将这些块分散存储在不同的磁盘上\",{\"1\":{\"1095\":1}}],[\"并将该对象转换为\",{\"1\":{\"935\":1}}],[\"并将该节点的左右子节点继续存到队列中进行下一层遍历\",{\"1\":{\"742\":1}}],[\"并将原链表和复制链表连在一起\",{\"1\":{\"888\":1}}],[\"并将下文\",{\"1\":{\"671\":1}}],[\"并将下一个字符转换为大写\",{\"1\":{\"98\":1}}],[\"并将热点标识传递至bff层\",{\"1\":{\"33\":1}}],[\"并输出其坐标\",{\"1\":{\"77\":4}}],[\"并且能够获得同步状态的话\",{\"1\":{\"1505\":1}}],[\"并且能够保证读线程间不阻塞\",{\"1\":{\"1291\":1}}],[\"并且重写了\",{\"1\":{\"1496\":1}}],[\"并且还有一个同步静态方法\",{\"1\":{\"1431\":1}}],[\"并且已经知道出现线程安全的主要来源于\",{\"1\":{\"1429\":1}}],[\"并且会把位于主存中的共享变量拷贝到自己的工作内存\",{\"1\":{\"1417\":1}}],[\"并且返回相加之前的值\",{\"1\":{\"1388\":1}}],[\"并且返回链表的头结点\",{\"1\":{\"776\":1}}],[\"并且需要设置想要更新的类和属性\",{\"1\":{\"1388\":1}}],[\"并且需要注意的是设置守护线程要先于\",{\"1\":{\"1340\":1}}],[\"并且需要对\",{\"1\":{\"662\":1}}],[\"并且再次获得\",{\"1\":{\"1338\":1}}],[\"并且线程空闲时间超过了\",{\"1\":{\"1359\":1}}],[\"并且线程调度器允许该线程持有这个锁时\",{\"1\":{\"1332\":1}}],[\"并且线程通过\",{\"1\":{\"1326\":1}}],[\"并且线程状态转换为等待状态\",{\"1\":{\"1250\":1}}],[\"并且在该过程并没有找到可以覆盖的\",{\"1\":{\"1317\":1}}],[\"并且在更新操作时\",{\"1\":{\"1286\":1}}],[\"并且该节点的状态值不为\",{\"1\":{\"1506\":1}}],[\"并且该方法会返回下一个哈希桶\",{\"1\":{\"1316\":1}}],[\"并且该数组引用是被\",{\"1\":{\"1292\":1}}],[\"并且是以当前\",{\"1\":{\"1301\":1}}],[\"并且通过\",{\"1\":{\"1284\":1,\"1306\":1}}],[\"并且此时\",{\"1\":{\"1283\":1}}],[\"并且由于\",{\"1\":{\"1283\":1,\"1385\":1}}],[\"并且都是用volatile进行修饰的\",{\"1\":{\"1281\":1}}],[\"并且防止拉链过长导致性能下降\",{\"1\":{\"1276\":1}}],[\"并且更新\",{\"1\":{\"1274\":1}}],[\"并且判断是否需要\",{\"1\":{\"1274\":1}}],[\"并且判断是否有解\",{\"1\":{\"384\":1}}],[\"并且当前线程池线程个数没有超过\",{\"1\":{\"1359\":1}}],[\"并且当前\",{\"1\":{\"1272\":1}}],[\"并且不为\",{\"1\":{\"1272\":1}}],[\"并且不同浏览器对\",{\"1\":{\"532\":1}}],[\"并且具有\",{\"1\":{\"1267\":1}}],[\"并且大量使用了\",{\"1\":{\"1264\":1}}],[\"并且可在线程中使用\",{\"1\":{\"1258\":1}}],[\"并且可以在语句执行完毕后确保每个资源都被自动关闭\",{\"1\":{\"1049\":1}}],[\"并且可以在任意一块草地结束它的吃草之旅\",{\"1\":{\"193\":1}}],[\"并且可以捕获一定范围内的变量\",{\"1\":{\"255\":1}}],[\"并且除了\",{\"1\":{\"1095\":1}}],[\"并且支持跨越多个数据中心\",{\"1\":{\"1095\":1}}],[\"并且忽略挂起\",{\"1\":{\"1087\":1}}],[\"并且相同索引对应的元素都相同\",{\"1\":{\"1067\":1}}],[\"并且底层已经实现了按照索引进行排序\",{\"1\":{\"958\":1}}],[\"并且设置外键为唯一的\",{\"1\":{\"938\":1}}],[\"并且学习课程\",{\"1\":{\"875\":1}}],[\"并且字典中的单词可以重复使用\",{\"1\":{\"782\":1}}],[\"并且你需要频繁地查找第\",{\"1\":{\"711\":1}}],[\"并且图片如果有修改\",{\"1\":{\"670\":1}}],[\"并且给该\",{\"1\":{\"575\":1}}],[\"并且给需求设置优先级\",{\"1\":{\"506\":1}}],[\"并且定期打包构建\",{\"1\":{\"546\":1}}],[\"并且对于相同前缀只存储一次\",{\"1\":{\"802\":1}}],[\"并且对于任意的整数\",{\"1\":{\"388\":1}}],[\"并且对搜索引擎友好\",{\"1\":{\"531\":1}}],[\"并且将对象锁释放出来\",{\"1\":{\"1407\":1}}],[\"并且将原来\",{\"1\":{\"1285\":1}}],[\"并且将无用的接口移除\",{\"1\":{\"518\":1}}],[\"并且将\",{\"1\":{\"517\":1,\"1316\":1}}],[\"并且从每个局面向沿着合法行动能够到达的下一个局面连有向边\",{\"1\":{\"396\":1}}],[\"并且边长之和最小\",{\"1\":{\"360\":1}}],[\"并且一般\",{\"1\":{\"307\":1}}],[\"并且速度很快\",{\"1\":{\"216\":1}}],[\"并且每座岛屿只能由水平方向和\",{\"1\":{\"819\":1}}],[\"并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息\",{\"1\":{\"1501\":1}}],[\"并且每个节点只能存储\",{\"1\":{\"698\":1}}],[\"并且每个节点之间的移动代价是相等的\",{\"1\":{\"213\":1}}],[\"并且每种花卉只能种在一个单元格里\",{\"1\":{\"141\":1}}],[\"并且这个格子的权重为\",{\"1\":{\"196\":1}}],[\"并且向右走到另一块草地\",{\"1\":{\"193\":1}}],[\"并且永远不会死\",{\"1\":{\"182\":1}}],[\"并且使用单调栈找到\",{\"1\":{\"174\":1}}],[\"并且她想知道要达到输赢状态所需的\",{\"1\":{\"174\":1}}],[\"并且尽可能摆放地好看\",{\"1\":{\"147\":1}}],[\"并且它们的价格之和最大\",{\"1\":{\"140\":1}}],[\"并且\",{\"1\":{\"119\":1,\"193\":1,\"438\":1,\"931\":1,\"1095\":1,\"1306\":1,\"1316\":1,\"1350\":1,\"1361\":1,\"1392\":1,\"1394\":1,\"1417\":1,\"1421\":1,\"1432\":1,\"1455\":1,\"1505\":1}}],[\"并且写出算法的复杂度\",{\"1\":{\"114\":1}}],[\"并且两个列表都已经按照时间顺序排好序\",{\"1\":{\"70\":1}}],[\"并且评论之间是通过赞数进行排序的\",{\"1\":{\"56\":1}}],[\"并提供了修改字符串的方法\",{\"1\":{\"1068\":1}}],[\"并提供给\",{\"1\":{\"436\":1}}],[\"并提供标准接口\",{\"1\":{\"14\":1}}],[\"并提升整个热评模块的可观测水平\",{\"1\":{\"40\":1}}],[\"并发包中增加了\",{\"1\":{\"1492\":1}}],[\"并发工具类中为我们提供了类似\",{\"1\":{\"1392\":1}}],[\"并发容器之\",{\"0\":{\"1263\":1,\"1279\":1,\"1289\":1,\"1298\":1,\"1323\":1,\"1343\":1}}],[\"并发知识图谱\",{\"0\":{\"1227\":1}}],[\"并发指的是多个任务交替进行\",{\"1\":{\"1224\":1}}],[\"并发和并行是十分容易混淆的概念\",{\"1\":{\"1224\":1}}],[\"并发与并行\",{\"0\":{\"1224\":1}}],[\"并发累加未必会比串行累加速度要快\",{\"1\":{\"1220\":1}}],[\"并发\",{\"1\":{\"1218\":1}}],[\"并发的优缺点\",{\"0\":{\"1217\":1}}],[\"并发编程系列的结尾篇\",{\"1\":{\"1411\":1}}],[\"并发编程有哪些缺点\",{\"0\":{\"1219\":1}}],[\"并发编程\",{\"0\":{\"1546\":1},\"1\":{\"500\":1},\"2\":{\"1228\":1,\"1234\":1,\"1245\":1,\"1255\":1,\"1261\":1,\"1277\":1,\"1287\":1,\"1296\":1,\"1310\":1,\"1321\":1,\"1327\":1,\"1341\":1,\"1354\":1,\"1362\":1,\"1372\":1,\"1377\":1,\"1389\":1,\"1395\":1,\"1400\":1,\"1412\":1,\"1426\":1,\"1450\":1,\"1459\":1,\"1479\":1,\"1488\":1,\"1497\":1,\"1513\":1}}],[\"并发事务导致的\",{\"1\":{\"37\":1}}],[\"并发查询楼中楼评论列表\",{\"1\":{\"30\":1}}],[\"并结合在线数据库刷新部分实时性要求较高的字段\",{\"1\":{\"26\":1}}],[\"并转换为视图模型\",{\"1\":{\"25\":1}}],[\"并查集核心操作\",{\"1\":{\"361\":1}}],[\"并查集的父节点数组\",{\"1\":{\"361\":1}}],[\"并查集是一种非常精巧实用的数据结构\",{\"1\":{\"267\":1}}],[\"并查集\",{\"0\":{\"266\":1,\"274\":1,\"413\":1,\"822\":1},\"1\":{\"4\":1},\"2\":{\"276\":1,\"824\":1}}],[\"lying\",{\"1\":{\"1316\":1}}],[\"lfu\",{\"1\":{\"1205\":1}}],[\"lfloor\",{\"1\":{\"795\":1}}],[\"lmbench3\",{\"1\":{\"1220\":1}}],[\"lmin\",{\"1\":{\"1083\":1}}],[\"lmax\",{\"1\":{\"1083\":1}}],[\"ldaps\",{\"1\":{\"481\":1}}],[\"ldap\",{\"1\":{\"481\":2}}],[\"l代表区间左端点\",{\"1\":{\"431\":1}}],[\"lucas\",{\"0\":{\"389\":1},\"1\":{\"389\":4}}],[\"lcs\",{\"1\":{\"839\":2,\"840\":4}}],[\"lc\",{\"1\":{\"766\":1,\"1274\":3}}],[\"lcm\",{\"1\":{\"377\":1}}],[\"lca\",{\"1\":{\"267\":1}}],[\"ln2\",{\"1\":{\"613\":1}}],[\"ln\",{\"1\":{\"371\":4,\"1274\":8}}],[\"lb\",{\"1\":{\"305\":4}}],[\"latch\",{\"1\":{\"1392\":1}}],[\"latest\",{\"1\":{\"538\":3,\"539\":1}}],[\"large\",{\"1\":{\"587\":3}}],[\"labelwidth\",{\"1\":{\"592\":1}}],[\"label\",{\"1\":{\"587\":1}}],[\"lang\",{\"1\":{\"1055\":8,\"1221\":8,\"1259\":4,\"1299\":1,\"1340\":2,\"1407\":1}}],[\"language\",{\"0\":{\"1535\":1},\"1\":{\"909\":4,\"911\":1,\"924\":1}}],[\"lang3<\",{\"1\":{\"568\":1}}],[\"lang3\",{\"1\":{\"568\":3}}],[\"lang=\",{\"1\":{\"540\":1,\"548\":1}}],[\"lacksrole\",{\"1\":{\"466\":1,\"467\":1}}],[\"lackspermi\",{\"1\":{\"466\":1,\"467\":1}}],[\"layouts\",{\"1\":{\"548\":1,\"549\":1}}],[\"layout\",{\"1\":{\"463\":3,\"540\":1,\"548\":1,\"587\":1}}],[\"lake\",{\"1\":{\"438\":2}}],[\"la\",{\"1\":{\"305\":4}}],[\"lamport\",{\"1\":{\"1420\":1}}],[\"lamda\",{\"1\":{\"255\":1}}],[\"lambdaquery\",{\"1\":{\"525\":1,\"526\":1}}],[\"lambdaquerywrapper\",{\"1\":{\"525\":2,\"526\":2}}],[\"lambdaquerywrapper<questionbankquestion>\",{\"1\":{\"525\":1,\"526\":1}}],[\"lambda\",{\"1\":{\"255\":4,\"525\":1}}],[\"lambda表达式\",{\"0\":{\"255\":1}}],[\"lastrun\",{\"1\":{\"1274\":5}}],[\"lastwaiter\",{\"1\":{\"1250\":1,\"1251\":5,\"1252\":2}}],[\"lastindexofsublist\",{\"1\":{\"1081\":1}}],[\"lastindexof\",{\"1\":{\"1005\":2,\"1069\":2}}],[\"lasttime\",{\"1\":{\"566\":2,\"589\":1}}],[\"last\",{\"1\":{\"200\":2,\"254\":2,\"309\":4,\"1073\":1,\"1190\":1,\"1196\":2,\"1250\":1,\"1283\":1,\"1350\":3,\"1359\":1}}],[\"lastdigit\",{\"1\":{\"139\":2}}],[\"lazysetnext\",{\"1\":{\"1282\":1,\"1284\":4}}],[\"lazy\",{\"1\":{\"58\":1,\"157\":18,\"526\":2}}],[\"l2或其他\",{\"1\":{\"1454\":1}}],[\"l2\",{\"1\":{\"134\":8,\"700\":2}}],[\"l1\",{\"1\":{\"134\":8,\"700\":2,\"1454\":1}}],[\"leslie\",{\"1\":{\"1420\":1}}],[\"less\",{\"1\":{\"1315\":1}}],[\"lesser\",{\"1\":{\"1191\":2}}],[\"lea\",{\"1\":{\"1491\":1}}],[\"least\",{\"1\":{\"1306\":1,\"1314\":1}}],[\"leases\",{\"1\":{\"1196\":2}}],[\"lease\",{\"1\":{\"1190\":1}}],[\"learn\",{\"1\":{\"1221\":2,\"1259\":2,\"1340\":1}}],[\"leaderboard\",{\"1\":{\"129\":9}}],[\"lee\",{\"1\":{\"181\":2}}],[\"leetcode\",{\"0\":{\"6\":1,\"1518\":1},\"1\":{\"766\":1}}],[\"level\",{\"1\":{\"140\":6}}],[\"levelorder\",{\"1\":{\"133\":1,\"743\":1}}],[\"leq\",{\"1\":{\"133\":2}}],[\"lemon\",{\"1\":{\"129\":2}}],[\"len++\",{\"1\":{\"244\":1,\"307\":2,\"845\":1}}],[\"len\",{\"1\":{\"76\":3,\"133\":2,\"244\":2,\"302\":5,\"307\":12,\"845\":3,\"1294\":3,\"1295\":3,\"1306\":8,\"1307\":2,\"1308\":3,\"1314\":3,\"1315\":5,\"1316\":8,\"1317\":14}}],[\"lengthoflis\",{\"1\":{\"851\":1,\"852\":2}}],[\"length≤500\",{\"1\":{\"71\":1}}],[\"length\",{\"1\":{\"70\":2,\"71\":1,\"72\":2,\"76\":1,\"82\":1,\"83\":1,\"88\":5,\"127\":2,\"128\":1,\"139\":9,\"152\":1,\"162\":1,\"172\":1,\"243\":6,\"422\":1,\"568\":3,\"575\":2,\"587\":1,\"705\":1,\"767\":7,\"772\":1,\"783\":3,\"784\":1,\"789\":2,\"803\":2,\"815\":1,\"820\":4,\"821\":2,\"822\":2,\"827\":2,\"828\":1,\"840\":2,\"845\":1,\"846\":1,\"851\":1,\"870\":4,\"893\":1,\"894\":1,\"1005\":2,\"1007\":1,\"1018\":1,\"1067\":1,\"1069\":1,\"1070\":1,\"1103\":1,\"1271\":2,\"1272\":1,\"1273\":1,\"1274\":2,\"1275\":3,\"1294\":1,\"1295\":1,\"1305\":1,\"1306\":2,\"1307\":2,\"1308\":1,\"1314\":1,\"1315\":3,\"1316\":1,\"1317\":3,\"1347\":3,\"1348\":1}}],[\"left+1\",{\"1\":{\"852\":2}}],[\"left++\",{\"1\":{\"140\":1}}],[\"leftnodes\",{\"1\":{\"712\":6,\"713\":6}}],[\"lefts\",{\"1\":{\"174\":4}}],[\"left\",{\"1\":{\"134\":2,\"140\":3,\"174\":10,\"187\":3,\"471\":2,\"710\":1,\"713\":3,\"724\":4,\"725\":2,\"736\":1,\"737\":2,\"743\":2,\"748\":1,\"749\":2,\"755\":4,\"761\":1,\"766\":2,\"767\":15,\"777\":3,\"778\":5,\"809\":3,\"815\":1,\"833\":1,\"834\":8,\"852\":6,\"864\":2,\"882\":1,\"899\":4,\"900\":1,\"901\":4,\"945\":1,\"1267\":1}}],[\"leftb++\",{\"1\":{\"71\":1}}],[\"leftb\",{\"1\":{\"71\":2}}],[\"lefta++\",{\"1\":{\"71\":1}}],[\"lefta\",{\"1\":{\"71\":2}}],[\"l\",{\"1\":{\"66\":10,\"77\":1,\"142\":11,\"157\":5,\"162\":5,\"173\":7,\"174\":26,\"206\":9,\"223\":2,\"224\":1,\"261\":8,\"302\":4,\"317\":8,\"318\":7,\"320\":2,\"321\":8,\"322\":8,\"323\":6,\"325\":5,\"332\":2,\"334\":2,\"341\":4,\"342\":5,\"404\":8,\"421\":4,\"427\":3,\"428\":5,\"429\":5,\"430\":10,\"431\":9,\"539\":1,\"748\":2,\"761\":3,\"815\":5,\"852\":10,\"864\":2,\"899\":4}}],[\"lld\",{\"1\":{\"345\":1,\"384\":6}}],[\"ll>\",{\"1\":{\"206\":1}}],[\"llong\",{\"1\":{\"110\":1}}],[\"ll\",{\"1\":{\"65\":1,\"110\":3,\"122\":6,\"141\":3,\"206\":4,\"261\":4,\"262\":3,\"263\":1,\"311\":2,\"324\":3,\"360\":1,\"372\":7,\"376\":4,\"384\":15,\"388\":4,\"389\":10,\"392\":2}}],[\"lotail\",{\"1\":{\"1274\":4}}],[\"lo\",{\"1\":{\"1274\":4}}],[\"looksupport\",{\"1\":{\"1505\":2,\"1506\":2}}],[\"lookup\",{\"1\":{\"481\":3}}],[\"loop\",{\"1\":{\"1242\":1,\"1511\":4}}],[\"lombok\",{\"1\":{\"517\":1}}],[\"locking\",{\"1\":{\"1485\":1}}],[\"lockinterruptibly\",{\"1\":{\"1347\":1,\"1348\":1,\"1351\":1,\"1352\":1,\"1493\":1,\"1496\":1,\"1507\":1}}],[\"lockobject\",{\"1\":{\"1406\":6,\"1407\":8}}],[\"locked\",{\"1\":{\"1221\":2,\"1275\":1,\"1496\":1}}],[\"lock\",{\"0\":{\"1410\":1,\"1490\":1,\"1492\":1,\"1493\":1},\"1\":{\"1061\":5,\"1221\":5,\"1231\":1,\"1232\":1,\"1233\":1,\"1237\":2,\"1239\":2,\"1242\":2,\"1243\":1,\"1244\":8,\"1248\":4,\"1250\":10,\"1251\":8,\"1252\":4,\"1253\":7,\"1254\":8,\"1267\":3,\"1272\":1,\"1294\":5,\"1299\":1,\"1334\":3,\"1345\":1,\"1346\":6,\"1347\":5,\"1348\":6,\"1350\":4,\"1351\":2,\"1353\":2,\"1369\":1,\"1402\":1,\"1406\":24,\"1407\":31,\"1408\":2,\"1410\":26,\"1438\":1,\"1454\":5,\"1482\":4,\"1486\":1,\"1491\":1,\"1492\":9,\"1493\":3,\"1495\":1,\"1496\":6,\"1503\":2,\"1507\":2,\"1508\":1}}],[\"lockstate\",{\"1\":{\"1267\":2}}],[\"locksupprt\",{\"1\":{\"1259\":1}}],[\"locksupprot\",{\"1\":{\"1258\":1}}],[\"locksupportdemo\",{\"1\":{\"1259\":4,\"1260\":1}}],[\"locksupport方法介绍\",{\"0\":{\"1259\":1}}],[\"locksupport\",{\"0\":{\"1257\":1,\"1258\":1},\"1\":{\"1251\":4,\"1252\":2,\"1258\":5,\"1259\":7,\"1260\":5,\"1334\":4,\"1505\":1,\"1506\":1,\"1508\":2}}],[\"locks\",{\"1\":{\"484\":1,\"1061\":1,\"1243\":1,\"1258\":1,\"1259\":2,\"1334\":1}}],[\"location\",{\"1\":{\"587\":4,\"589\":1,\"591\":1,\"672\":3}}],[\"localstorage\",{\"1\":{\"592\":1}}],[\"locales\",{\"1\":{\"559\":1}}],[\"localhost\",{\"1\":{\"520\":1,\"586\":2,\"587\":1,\"592\":1,\"1089\":1,\"1100\":1,\"1184\":1,\"1190\":1,\"1193\":1}}],[\"local\",{\"1\":{\"61\":2,\"1351\":1}}],[\"lowestcommonancestor\",{\"1\":{\"755\":3}}],[\"lowerbound\",{\"1\":{\"852\":4}}],[\"lower\",{\"1\":{\"129\":1,\"174\":1,\"302\":1,\"324\":3,\"422\":4,\"423\":4}}],[\"lowbit\",{\"1\":{\"339\":5}}],[\"lost\",{\"1\":{\"1271\":1,\"1283\":1}}],[\"lostlist\",{\"1\":{\"114\":2}}],[\"lose\",{\"1\":{\"174\":2}}],[\"longadder\",{\"1\":{\"1275\":1}}],[\"longtext\",{\"1\":{\"920\":1}}],[\"longblob\",{\"1\":{\"920\":1}}],[\"longestvalidparentheses\",{\"1\":{\"845\":1,\"846\":1}}],[\"longestcommonsubsequence\",{\"1\":{\"840\":1}}],[\"long>\",{\"1\":{\"142\":1}}],[\"long>>\",{\"1\":{\"142\":1}}],[\"long>>>\",{\"1\":{\"142\":1}}],[\"long\",{\"1\":{\"65\":2,\"72\":2,\"83\":10,\"87\":7,\"99\":4,\"110\":2,\"120\":2,\"122\":2,\"126\":2,\"140\":10,\"141\":2,\"142\":6,\"162\":1,\"182\":5,\"206\":2,\"261\":2,\"262\":2,\"263\":2,\"311\":2,\"324\":2,\"360\":2,\"372\":2,\"376\":2,\"384\":2,\"392\":2,\"421\":4,\"515\":1,\"517\":1,\"523\":2,\"525\":4,\"526\":11,\"568\":3,\"576\":3,\"579\":1,\"589\":1,\"882\":1,\"899\":5,\"900\":2,\"901\":12,\"935\":1,\"978\":1,\"1083\":2,\"1201\":3,\"1210\":1,\"1248\":5,\"1259\":4,\"1268\":3,\"1275\":13,\"1325\":2,\"1326\":1,\"1334\":3,\"1337\":2,\"1338\":1,\"1359\":1,\"1367\":6,\"1368\":1,\"1370\":1,\"1385\":3,\"1392\":2,\"1393\":1,\"1398\":2,\"1399\":1,\"1410\":3,\"1482\":1,\"1493\":1,\"1496\":1,\"1500\":2,\"1508\":3}}],[\"loadstore\",{\"1\":{\"1457\":2}}],[\"loadload屏障也会被省略掉\",{\"1\":{\"1477\":1}}],[\"loadload\",{\"1\":{\"1457\":2,\"1475\":1,\"1477\":1}}],[\"loadfactor\",{\"1\":{\"1266\":1,\"1270\":2}}],[\"loadproperties\",{\"1\":{\"1149\":1}}],[\"loadcascadedpropertiesfromresources\",{\"1\":{\"1149\":2}}],[\"loading\",{\"1\":{\"591\":1}}],[\"loaduserbyusername\",{\"1\":{\"451\":1}}],[\"load\",{\"1\":{\"61\":1,\"1306\":1,\"1482\":7}}],[\"log2​\",{\"1\":{\"1315\":4,\"1316\":2}}],[\"log2\",{\"1\":{\"1315\":2}}],[\"logger\",{\"1\":{\"1149\":1,\"1165\":2}}],[\"log>\",{\"1\":{\"1090\":1}}],[\"logpath>\",{\"1\":{\"1090\":1}}],[\"logs<\",{\"1\":{\"1090\":1}}],[\"log10\",{\"1\":{\"1080\":1}}],[\"logic\",{\"1\":{\"575\":4}}],[\"loginout\",{\"1\":{\"596\":1}}],[\"loginfailuremessage\",{\"1\":{\"589\":2}}],[\"loginform>\",{\"1\":{\"587\":1}}],[\"loginsuccessmessage\",{\"1\":{\"589\":2}}],[\"loginparams\",{\"1\":{\"587\":1,\"589\":4}}],[\"loginpath\",{\"1\":{\"587\":2,\"591\":3}}],[\"loginuser\",{\"1\":{\"451\":1,\"526\":2}}],[\"login\",{\"1\":{\"446\":1,\"447\":1,\"448\":5,\"450\":1,\"451\":1,\"453\":1,\"471\":4,\"575\":3,\"576\":1,\"578\":1,\"580\":1,\"586\":2,\"587\":2,\"589\":3,\"591\":3,\"596\":1}}],[\"logk\",{\"1\":{\"381\":1}}],[\"log\",{\"1\":{\"174\":7,\"361\":1,\"368\":1,\"377\":1,\"476\":1,\"481\":1,\"482\":1,\"575\":1,\"589\":2,\"592\":3,\"1080\":3,\"1087\":4,\"1315\":1}}],[\"logn\",{\"1\":{\"40\":1,\"58\":1,\"129\":2,\"168\":1,\"274\":2,\"422\":3,\"1067\":1,\"1078\":2,\"1081\":1,\"1369\":1}}],[\"logo=\",{\"1\":{\"587\":1}}],[\"logouturl\",{\"1\":{\"446\":1}}],[\"logoutsuccesshandler\",{\"1\":{\"446\":3}}],[\"logoutsuccesshandlerimpl\",{\"1\":{\"446\":2}}],[\"logoutfilter\",{\"1\":{\"446\":2}}],[\"logout\",{\"1\":{\"446\":3,\"596\":3}}],[\"logo\",{\"1\":{\"39\":1,\"543\":2,\"587\":2}}],[\"lrucache\",{\"1\":{\"686\":2,\"687\":2,\"688\":2}}],[\"lru缓存\",{\"1\":{\"685\":1}}],[\"lrud\",{\"1\":{\"77\":1}}],[\"lrudc\",{\"1\":{\"77\":1}}],[\"lru\",{\"0\":{\"685\":1,\"687\":1},\"1\":{\"60\":1,\"686\":2,\"688\":1,\"1202\":1,\"1205\":1}}],[\"live\",{\"1\":{\"1283\":2}}],[\"lived\",{\"1\":{\"60\":1}}],[\"license\",{\"1\":{\"1093\":1}}],[\"lis\",{\"1\":{\"851\":5,\"852\":1}}],[\"list以达到最大容量\",{\"1\":{\"1409\":3,\"1410\":6}}],[\"list为空\",{\"1\":{\"1407\":4,\"1409\":2,\"1410\":3}}],[\"listed\",{\"1\":{\"1221\":1}}],[\"listen\",{\"1\":{\"664\":1,\"672\":2}}],[\"listablebeanfactory\",{\"1\":{\"1137\":1}}],[\"listobjectsargs\",{\"1\":{\"1103\":1}}],[\"listobjects\",{\"1\":{\"1103\":4}}],[\"listbuckets\",{\"1\":{\"1102\":2}}],[\"list2\",{\"1\":{\"1081\":2}}],[\"list1\",{\"1\":{\"1081\":2}}],[\"lists\",{\"1\":{\"789\":4}}],[\"listsheight\",{\"1\":{\"592\":1}}],[\"listquestionbypage\",{\"1\":{\"523\":1,\"525\":3}}],[\"list<bucket>\",{\"1\":{\"1102\":1}}],[\"list<e>\",{\"1\":{\"1072\":2,\"1073\":1,\"1081\":4}}],[\"list<>\",{\"1\":{\"1036\":1}}],[\"list<list<integer>>\",{\"1\":{\"743\":2}}],[\"list<user>\",{\"1\":{\"578\":2}}],[\"list<questionbankquestion>\",{\"1\":{\"525\":1}}],[\"list<string>\",{\"1\":{\"517\":1,\"783\":1,\"784\":2,\"1407\":6}}],[\"list<sysxxxx>\",{\"1\":{\"468\":1}}],[\"list<\",{\"1\":{\"471\":2}}],[\"list<order>\",{\"1\":{\"465\":1}}],[\"list<t>\",{\"1\":{\"1280\":1}}],[\"list<treenode>\",{\"1\":{\"749\":2}}],[\"list<t\",{\"1\":{\"200\":3}}],[\"list<integer>\",{\"1\":{\"736\":3,\"737\":3,\"743\":1,\"852\":2,\"875\":3,\"876\":2,\"1072\":2,\"1409\":2,\"1410\":2}}],[\"list<int>>\",{\"1\":{\"200\":1}}],[\"list<int\",{\"1\":{\"70\":2,\"870\":2}}],[\"list\",{\"0\":{\"1036\":1,\"1072\":1,\"1214\":1},\"1\":{\"200\":10,\"465\":6,\"467\":4,\"468\":2,\"517\":2,\"525\":2,\"578\":1,\"591\":2,\"663\":2,\"737\":2,\"743\":4,\"935\":3,\"1072\":3,\"1073\":2,\"1076\":1,\"1280\":1,\"1283\":2,\"1290\":4,\"1292\":1,\"1324\":2,\"1350\":2,\"1407\":10,\"1409\":20,\"1410\":14}}],[\"listnode\",{\"1\":{\"134\":11,\"682\":8,\"694\":5,\"700\":8,\"778\":5,\"789\":7,\"834\":9}}],[\"lib\",{\"1\":{\"671\":1}}],[\"lighting\",{\"1\":{\"587\":1}}],[\"li​\",{\"1\":{\"168\":3}}],[\"links\",{\"1\":{\"1267\":1}}],[\"linked\",{\"1\":{\"1350\":2}}],[\"linkedtransferqueue\",{\"1\":{\"1326\":3}}],[\"linkedblockingqueue<>\",{\"1\":{\"1411\":1}}],[\"linkedblockingqueue<integer>\",{\"1\":{\"1411\":1}}],[\"linkedblockingqueue\",{\"0\":{\"1343\":1,\"1349\":1,\"1350\":1,\"1353\":1},\"1\":{\"1326\":7,\"1344\":1,\"1348\":1,\"1349\":2,\"1350\":2,\"1353\":3,\"1359\":1}}],[\"linkedblockingdeque\",{\"1\":{\"1326\":8}}],[\"linkedhashset\",{\"1\":{\"1073\":2}}],[\"linkedhashmap<>\",{\"1\":{\"687\":1}}],[\"linkedhashmap<integer\",{\"1\":{\"687\":1,\"688\":1}}],[\"linkedhashmap\",{\"1\":{\"687\":1,\"688\":3}}],[\"linkedlist\",{\"1\":{\"875\":1,\"876\":1,\"1072\":2,\"1075\":1,\"1076\":1,\"1409\":5,\"1410\":5}}],[\"linkedlist<>\",{\"1\":{\"180\":1,\"737\":1,\"743\":1,\"749\":2,\"821\":1,\"870\":1,\"875\":1,\"876\":1,\"1036\":1,\"1038\":1,\"1072\":1,\"1076\":1,\"1077\":1}}],[\"link>\",{\"1\":{\"588\":1}}],[\"link\",{\"1\":{\"588\":1,\"1275\":1}}],[\"linearization\",{\"1\":{\"1283\":1,\"1284\":1}}],[\"line\",{\"1\":{\"127\":2,\"981\":1,\"1049\":5}}],[\"linux运维\",{\"1\":{\"662\":1}}],[\"linux\",{\"0\":{\"607\":1,\"1087\":1,\"1538\":1},\"1\":{\"7\":1,\"670\":3,\"671\":2,\"672\":2,\"1087\":1,\"1107\":2},\"2\":{\"1126\":1}}],[\"like\",{\"1\":{\"30\":1,\"31\":1,\"40\":2,\"578\":1,\"931\":1,\"958\":1}}],[\"limit\",{\"1\":{\"30\":2,\"305\":3,\"929\":2,\"935\":3}}],[\"剑指\",{\"0\":{\"5\":1},\"1\":{\"655\":1}}],[\"笔试题\",{\"2\":{\"68\":1,\"74\":1,\"80\":1,\"85\":1,\"90\":1,\"95\":1,\"101\":1,\"106\":1,\"112\":1,\"117\":1,\"124\":1,\"131\":1,\"137\":1,\"144\":1,\"149\":1,\"154\":1,\"159\":1,\"164\":1,\"170\":1,\"176\":1,\"184\":1}}],[\"笔试题和面试题等\",{\"1\":{\"2\":1}}],[\"笔记\",{\"0\":{\"4\":1},\"2\":{\"225\":1,\"232\":1,\"239\":1,\"258\":1,\"264\":1,\"275\":1,\"284\":1,\"292\":1}}],[\"贪心\",{\"0\":{\"425\":1},\"1\":{\"3\":1,\"104\":1,\"141\":1,\"166\":1,\"167\":1},\"2\":{\"432\":1}}],[\"数值类型\",{\"1\":{\"920\":2}}],[\"数值相同的两个数视为不同的两个数\",{\"1\":{\"126\":1}}],[\"数仓建设保姆级5w字教程\",{\"1\":{\"638\":1}}],[\"数仓\",{\"1\":{\"438\":1}}],[\"数仓则恰恰相反\",{\"1\":{\"438\":1}}],[\"数学符号大全\",{\"1\":{\"658\":1}}],[\"数学运算\",{\"1\":{\"568\":1}}],[\"数学\",{\"2\":{\"400\":1}}],[\"数学知识\",{\"0\":{\"365\":1},\"1\":{\"3\":1}}],[\"数之间用空格隔开\",{\"1\":{\"384\":1}}],[\"数对\",{\"1\":{\"324\":1}}],[\"数位统计类dp\",{\"0\":{\"309\":1}}],[\"数列\",{\"1\":{\"304\":1}}],[\"数组元素\",{\"1\":{\"1380\":1}}],[\"数组元素为实现runnableschedulefuture接口的类\",{\"1\":{\"1369\":1}}],[\"数组元素为每个房子的主人回答的数字\",{\"1\":{\"108\":1}}],[\"数组设定为\",{\"1\":{\"1295\":1}}],[\"数组正在进行扩容\",{\"1\":{\"1272\":1}}],[\"数组进行初始化操作\",{\"1\":{\"1272\":1}}],[\"数组进行备份\",{\"1\":{\"354\":1}}],[\"数组还未初始化\",{\"1\":{\"1272\":1}}],[\"数组+链表\",{\"1\":{\"1272\":1}}],[\"数组为\",{\"1\":{\"1272\":1}}],[\"数组用小括号表示\",{\"1\":{\"1122\":1}}],[\"数组降序排序排序\",{\"1\":{\"1067\":1}}],[\"数组越界\",{\"1\":{\"1047\":1}}],[\"数组不可变长\",{\"1\":{\"1002\":1}}],[\"数组排序\",{\"1\":{\"1002\":1}}],[\"数组是否初始化了\",{\"1\":{\"1272\":1}}],[\"数组是存储数据的强而有力的手段\",{\"1\":{\"995\":1}}],[\"数组是上一次迭代后\",{\"1\":{\"354\":1}}],[\"数组记录遍历过的节点防止走回头路\",{\"1\":{\"820\":1}}],[\"数组在递推的过程中取得最大的价值\",{\"1\":{\"772\":1}}],[\"数组的情况如下图\",{\"1\":{\"1316\":1}}],[\"数组的索引\",{\"1\":{\"1272\":1}}],[\"数组的时候会使用默认大小为\",{\"1\":{\"1271\":1}}],[\"数组的工作\",{\"1\":{\"1270\":1}}],[\"数组的大小\",{\"1\":{\"1266\":1}}],[\"数组的大小总是为\",{\"1\":{\"1266\":1}}],[\"数组的范围遍历\",{\"0\":{\"1001\":1}}],[\"数组的初始化\",{\"0\":{\"998\":1}}],[\"数组的定义方式和变量类似\",{\"1\":{\"997\":1}}],[\"数组的定义\",{\"0\":{\"997\":1}}],[\"数组的长度为\",{\"1\":{\"1305\":1}}],[\"数组的长度\",{\"1\":{\"613\":1,\"1266\":1,\"1270\":1}}],[\"数组的备份\",{\"1\":{\"354\":1}}],[\"数组字符串的方式存储\",{\"1\":{\"512\":1}}],[\"数组时\",{\"1\":{\"411\":2}}],[\"数组和匹配的操作类似\",{\"1\":{\"411\":1}}],[\"数组模拟链表\",{\"0\":{\"402\":1}}],[\"数组b也是从低位\",{\"1\":{\"327\":1,\"328\":1}}],[\"数组a\",{\"1\":{\"327\":1,\"328\":1}}],[\"数组长度\",{\"0\":{\"1125\":1},\"1\":{\"1270\":1}}],[\"数组长度满足\",{\"1\":{\"178\":1}}],[\"数组长度为\",{\"1\":{\"108\":1}}],[\"数组中已有数据\",{\"1\":{\"1295\":1}}],[\"数组中\",{\"1\":{\"1272\":1,\"1306\":1}}],[\"数组中索引为\",{\"1\":{\"1268\":3}}],[\"数组中可以存放多个不同类型的值\",{\"1\":{\"1121\":1}}],[\"数组中只包含\",{\"1\":{\"278\":1}}],[\"数组中的每一个桶\",{\"1\":{\"1276\":1}}],[\"数组中的每个元素实际上是单链表的头结点或者红黑树的根节点\",{\"1\":{\"1272\":1}}],[\"数组中的元素的修改是不能保证可见性的\",{\"1\":{\"1295\":1}}],[\"数组中的元素而不改变其余元素的顺序\",{\"1\":{\"850\":1}}],[\"数组中的元素大小都满足\",{\"1\":{\"178\":1}}],[\"数组中的值累加到\",{\"1\":{\"146\":1}}],[\"数组中对应位置的值进行比较\",{\"1\":{\"146\":1}}],[\"数组中结果为\",{\"1\":{\"108\":1}}],[\"数组大小变为\",{\"1\":{\"114\":1}}],[\"数组大小为\",{\"1\":{\"109\":1}}],[\"数组\",{\"0\":{\"995\":1,\"1067\":1,\"1121\":1},\"1\":{\"104\":1,\"108\":1,\"109\":1,\"115\":1,\"120\":1,\"126\":1,\"127\":2,\"178\":1,\"182\":1,\"228\":1,\"274\":1,\"411\":2,\"423\":2,\"512\":1,\"771\":1,\"772\":3,\"783\":1,\"820\":1,\"822\":1,\"846\":1,\"1018\":1,\"1069\":1,\"1072\":1,\"1121\":1,\"1266\":1,\"1267\":2,\"1270\":1,\"1305\":2}}],[\"数组下标从0开始\",{\"1\":{\"999\":1}}],[\"数组下标从\",{\"1\":{\"87\":1}}],[\"数字类型包装类都支持两个常量\",{\"1\":{\"1083\":1}}],[\"数字三角形\",{\"0\":{\"301\":1}}],[\"数字间有空格隔开\",{\"1\":{\"147\":1}}],[\"数字之间用空格隔开\",{\"1\":{\"140\":1}}],[\"数字组合\",{\"0\":{\"135\":1}}],[\"数字的个数\",{\"1\":{\"126\":1}}],[\"数字\",{\"1\":{\"99\":1,\"180\":1,\"291\":1,\"698\":1,\"948\":1}}],[\"数字范围非常大\",{\"1\":{\"76\":1}}],[\"数轴包含负整数\",{\"1\":{\"72\":1}}],[\"数轴上位置\",{\"1\":{\"72\":1}}],[\"数据容器\",{\"1\":{\"1324\":1}}],[\"数据实质上是放在每个\",{\"1\":{\"1309\":1}}],[\"数据实体层\",{\"0\":{\"515\":1}}],[\"数据其实都放在了\",{\"1\":{\"1304\":1}}],[\"数据一致性问题\",{\"1\":{\"1295\":1}}],[\"数据进去\",{\"1\":{\"1295\":1}}],[\"数据中心\",{\"1\":{\"1190\":1}}],[\"数据列表\",{\"1\":{\"935\":1}}],[\"数据类型\",{\"0\":{\"920\":1},\"1\":{\"937\":1}}],[\"数据类型繁多\",{\"1\":{\"434\":1}}],[\"数据控制语言\",{\"1\":{\"909\":1}}],[\"数据查询语言\",{\"1\":{\"909\":1}}],[\"数据操作语言\",{\"1\":{\"909\":1,\"924\":1}}],[\"数据定义语言\",{\"1\":{\"909\":1,\"911\":1}}],[\"数据转换\",{\"1\":{\"568\":1}}],[\"数据更新时间\",{\"1\":{\"566\":1}}],[\"数据更新方式\",{\"1\":{\"40\":1}}],[\"数据插入时间\",{\"1\":{\"566\":1}}],[\"数据表\",{\"1\":{\"564\":1}}],[\"数据表设计\",{\"0\":{\"56\":1},\"1\":{\"56\":1}}],[\"数据获取和处理\",{\"1\":{\"532\":1,\"533\":1}}],[\"数据校验\",{\"1\":{\"526\":1}}],[\"数据模型层\",{\"0\":{\"517\":1}}],[\"数据模型包装类\",{\"1\":{\"516\":1}}],[\"数据权限的场景\",{\"1\":{\"470\":1}}],[\"数据权限的作用\",{\"1\":{\"470\":1}}],[\"数据权限介绍\",{\"0\":{\"470\":1}}],[\"数据权限\",{\"0\":{\"469\":1}}],[\"数据权限示例\",{\"1\":{\"467\":1}}],[\"数据服务环\",{\"1\":{\"438\":1}}],[\"数据可以流到仓里\",{\"1\":{\"438\":1}}],[\"数据集散地\",{\"1\":{\"438\":1}}],[\"数据上\",{\"1\":{\"437\":1}}],[\"数据也在不断堆积\",{\"1\":{\"437\":1}}],[\"数据湖和数仓作为两大\",{\"1\":{\"438\":1}}],[\"数据湖起步成本很低\",{\"1\":{\"438\":1}}],[\"数据湖则是一种架构\",{\"1\":{\"437\":1}}],[\"数据湖将数据照单全收\",{\"1\":{\"437\":1}}],[\"数据湖\",{\"0\":{\"437\":1},\"1\":{\"437\":2}}],[\"数据仓库之mpp架构\",{\"1\":{\"642\":1}}],[\"数据仓库可以是独立的标准化产品\",{\"1\":{\"437\":1}}],[\"数据仓库里的数据精挑细选\",{\"1\":{\"437\":1}}],[\"数据仓库中\",{\"1\":{\"437\":1}}],[\"数据仓库相当于一个集成化数据管理的平台\",{\"1\":{\"436\":1}}],[\"数据仓库\",{\"0\":{\"436\":1},\"1\":{\"436\":1,\"437\":1}}],[\"数据挖掘和机器学习\",{\"1\":{\"434\":1}}],[\"数据的质量和准确性\",{\"1\":{\"434\":1}}],[\"数据的生成和处理速度非常快\",{\"1\":{\"434\":1}}],[\"数据的规模非常大\",{\"1\":{\"434\":1}}],[\"数据用空格隔开\",{\"1\":{\"263\":2}}],[\"数据量也不大\",{\"1\":{\"525\":1}}],[\"数据量小\",{\"1\":{\"156\":1}}],[\"数据量级规模的增加\",{\"1\":{\"40\":1}}],[\"数据回传\",{\"1\":{\"151\":1}}],[\"数据存储高容错\",{\"1\":{\"1095\":1}}],[\"数据存储架构\",{\"1\":{\"437\":2}}],[\"数据存储\",{\"1\":{\"151\":1}}],[\"数据处理工具\",{\"1\":{\"437\":2}}],[\"数据处理\",{\"1\":{\"151\":1}}],[\"数据采集\",{\"1\":{\"151\":1}}],[\"数据保证\",{\"1\":{\"146\":1,\"278\":1}}],[\"数据范围过滤\",{\"1\":{\"471\":1}}],[\"数据范围较大时\",{\"1\":{\"298\":1}}],[\"数据范围\",{\"1\":{\"88\":1,\"134\":1,\"178\":1,\"180\":1,\"223\":1,\"261\":1,\"262\":1,\"263\":1,\"278\":1,\"280\":1,\"281\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"298\":1,\"304\":1}}],[\"数据\",{\"1\":{\"56\":1,\"60\":1,\"438\":1,\"958\":2,\"995\":1,\"1276\":1,\"1301\":1}}],[\"数据双向请求等\",{\"1\":{\"46\":1}}],[\"数据局部性集中与散列相结合\",{\"1\":{\"40\":1}}],[\"数据提供方很难也不应该承受热评业务的巨大流量\",{\"1\":{\"40\":1}}],[\"数据报表丰富\",{\"1\":{\"40\":1}}],[\"数据读写阶段均考虑了一致性风险\",{\"1\":{\"36\":1}}],[\"数据安全\",{\"0\":{\"36\":1},\"1\":{\"35\":1}}],[\"数据稀疏\",{\"1\":{\"33\":1}}],[\"数据组装在服务编排之后执行\",{\"1\":{\"25\":1}}],[\"数据字段多\",{\"1\":{\"25\":1}}],[\"数据库实际上会添加唯一索引\",{\"1\":{\"959\":1}}],[\"数据库支持的索引结构有很多\",{\"1\":{\"958\":1}}],[\"数据库系统提供的隔离机制\",{\"1\":{\"955\":1}}],[\"数据库自动生成\",{\"1\":{\"919\":1}}],[\"数据库不存在\",{\"1\":{\"913\":1}}],[\"数据库名\",{\"1\":{\"913\":1,\"914\":1,\"915\":1}}],[\"数据库操作\",{\"0\":{\"911\":1,\"924\":1,\"928\":1}}],[\"数据库操作阶段\",{\"1\":{\"910\":1}}],[\"数据库优化阶段\",{\"1\":{\"910\":1}}],[\"数据库的\",{\"1\":{\"908\":1}}],[\"数据库字段添加索引\",{\"1\":{\"565\":1}}],[\"数据库里有什么\",{\"1\":{\"564\":1}}],[\"数据库连接池\",{\"1\":{\"500\":1}}],[\"数据库主要用于\",{\"1\":{\"436\":1}}],[\"数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构\",{\"1\":{\"958\":1}}],[\"数据库中可以设计一个字段来标记数据是否已经回传\",{\"1\":{\"151\":1}}],[\"数据库中间件\",{\"1\":{\"14\":1}}],[\"数据库已经无法实现这样复杂的\",{\"1\":{\"40\":1}}],[\"数据库与缓存均是双机房独立部署的\",{\"1\":{\"34\":1}}],[\"数据库更新后\",{\"1\":{\"31\":1}}],[\"数据库设计阶段\",{\"1\":{\"910\":1}}],[\"数据库设计\",{\"0\":{\"30\":1,\"564\":1,\"910\":1}}],[\"数据库之间\",{\"1\":{\"14\":1}}],[\"数据库\",{\"0\":{\"11\":1},\"1\":{\"7\":1,\"57\":1,\"437\":1,\"500\":1,\"557\":1,\"909\":1,\"911\":1,\"915\":1}}],[\"数据结构中只需要经历两次磁盘\",{\"1\":{\"958\":1}}],[\"数据结构\",{\"0\":{\"401\":1,\"1305\":1},\"1\":{\"3\":1},\"2\":{\"189\":1,\"207\":1,\"275\":1,\"424\":1,\"683\":1,\"689\":1,\"695\":1,\"701\":1,\"714\":1,\"720\":1,\"726\":1,\"732\":1,\"738\":1,\"744\":1,\"750\":1,\"756\":1,\"762\":1,\"768\":1,\"779\":1,\"791\":1,\"810\":1,\"816\":1,\"835\":1,\"859\":1,\"865\":1,\"883\":1,\"889\":1,\"902\":1}}],[\"架构最重要的一点\",{\"1\":{\"438\":1}}],[\"架构\",{\"1\":{\"44\":1}}],[\"架构以及系统架构方面的笔记知识点\",{\"1\":{\"1\":1}}],[\"架构设计等同于数据设计\",{\"1\":{\"46\":1}}],[\"架构设计最重要的就是\",{\"1\":{\"45\":1}}],[\"架构设计\",{\"0\":{\"1\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"46\":1,\"501\":1},\"2\":{\"42\":1,\"52\":1,\"62\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
