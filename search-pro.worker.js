const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":758,\"nextId\":758,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2#模板\",\"3\":\"2#笔记\",\"4\":\"2#剑指-offer\",\"5\":\"2#leetcode\",\"6\":\"3\",\"7\":\"4\",\"8\":\"4#目录\",\"9\":\"4#编程语言\",\"10\":\"4#计算机网络\",\"11\":\"4#数据库\",\"12\":\"4#操作系统\",\"13\":\"4#设计模式\",\"14\":\"4#中间件\",\"15\":\"4#git\",\"16\":\"4#docker\",\"17\":\"5\",\"18\":\"6\",\"19\":\"7\",\"20\":\"8\",\"21\":\"8@0\",\"22\":\"8@1\",\"23\":\"9\",\"24\":\"9#题意\",\"25\":\"9#思路一\",\"26\":\"9#思路二-优化\",\"27\":\"9@0\",\"28\":\"9@1\",\"29\":\"10\",\"30\":\"10#_1-介绍\",\"31\":\"10#_2-搜索\",\"32\":\"10#_2-1-广度优先搜索\",\"33\":\"10#_2-2-dijkstra-算法\",\"34\":\"10#_2-3-最佳优先搜索\",\"35\":\"10#_3-a\",\"36\":\"10#_4-启发函数\",\"37\":\"10#_5-关于距离\",\"38\":\"10#_5-1-曼哈顿距离\",\"39\":\"10#_5-2-对角距离\",\"40\":\"10#_5-3-欧几里得距离\",\"41\":\"10#_6-补充\",\"42\":\"10#_7-例题\",\"43\":\"10#_7-1-第k短路\",\"44\":\"10#_7-2-八数码\",\"45\":\"10@0\",\"46\":\"10@1\",\"47\":\"11\",\"48\":\"11#岛屿数量\",\"49\":\"11#封闭岛屿数量\",\"50\":\"11#岛屿的最大面积\",\"51\":\"11#小结\",\"52\":\"11@0\",\"53\":\"11@1\",\"54\":\"12\",\"55\":\"12#能否逃出迷宫\",\"56\":\"12#逃出迷宫的最短路径\",\"57\":\"12#缺口迷宫\",\"58\":\"12#小结\",\"59\":\"12@0\",\"60\":\"12@1\",\"61\":\"13\",\"62\":\"13#_1-vector-维护一个动态数组\",\"63\":\"13#_2-字符串\",\"64\":\"13#_3-在一个数组中查找最长的相同连续子序列\",\"65\":\"13#_4-秦九韶算法\",\"66\":\"13#_5-开栈空间代码\",\"67\":\"13#_6-求-a-除以-b-的正余数\",\"68\":\"13#_7-裴蜀定理\",\"69\":\"13#_8-交互题\",\"70\":\"13#_9-mex函数\",\"71\":\"13#_10-string-与-int-之间的转化\",\"72\":\"13#_11-string-npos\",\"73\":\"13#_12-x-i-1\",\"74\":\"13#_13-assign\",\"75\":\"13#_14-lambda表达式\",\"76\":\"13#_15-max-element-与-min-element\",\"77\":\"13#_16-tuple\",\"78\":\"13@0\",\"79\":\"13@1\",\"80\":\"14\",\"81\":\"14#_1、1230-k倍区间\",\"82\":\"14#_2、3956-截断数组\",\"83\":\"14#_3、99-激光炸弹\",\"84\":\"14@0\",\"85\":\"14@1\",\"86\":\"15\",\"87\":\"15#简介\",\"88\":\"15#基本模板\",\"89\":\"15#_1-初始化\",\"90\":\"15#_2-查询-已路径压缩\",\"91\":\"15#_3-合并\",\"92\":\"15#典例分析\",\"93\":\"15#例一-亲戚关系\",\"94\":\"15#例二-洛谷-p3367-【模板】并查集\",\"95\":\"15@0\",\"96\":\"15@1\",\"97\":\"16\",\"98\":\"16#_1-844-走迷宫-bfs\",\"99\":\"16#_2-845-八数码-bfs\",\"100\":\"16#_3-1233-全球变暖\",\"101\":\"16#_4-842-排列数字-dfs\",\"102\":\"16#_4\",\"103\":\"16#_5\",\"104\":\"16@0\",\"105\":\"16@1\",\"106\":\"17\",\"107\":\"17#_1-92-递归实现指数型枚举\",\"108\":\"17#_2-94-递归实现排列型枚举\",\"109\":\"17#_3-93-递归实现组合型枚举\",\"110\":\"17#_4-165-小猫爬山\",\"111\":\"17#_5-1209-带分数\",\"112\":\"17@0\",\"113\":\"17@1\",\"114\":\"18\",\"115\":\"18#_1-背包问题\",\"116\":\"18#_1-1-01-背包\",\"117\":\"18#_1-2-完全背包\",\"118\":\"18#_1-3-多重背包\",\"119\":\"18#_1-4-分组背包\",\"120\":\"18#_2-线性dp\",\"121\":\"18#_2-1-数字三角形\",\"122\":\"18#_2-2-最长上升子序列\",\"123\":\"18#_2-3-最长公共子序列-不连续\",\"124\":\"18#_2-4-最长公共上升子序列\",\"125\":\"18#_2-5-编辑距离\",\"126\":\"18#_2-6-最短编辑距离\",\"127\":\"18#_3-区间dp\",\"128\":\"18#_4-计数类dp\",\"129\":\"18#_5-数位统计类dp\",\"130\":\"18#_6-状态压缩类dp\",\"131\":\"18#_6-1-蒙德里安的梦想\",\"132\":\"18#_6-2-最短hamilton路径\",\"133\":\"18#_7-树形dp\",\"134\":\"18#_7-1-没有上司的舞会\",\"135\":\"18@0\",\"136\":\"19\",\"137\":\"19#_1-快速排序\",\"138\":\"19#_2-归并排序\",\"139\":\"19#_3-二分算法\",\"140\":\"19#_3-1-二分查找算法模板\",\"141\":\"19#版本1\",\"142\":\"19#版本2\",\"143\":\"19#_3-2-二分答案模板\",\"144\":\"19#_3-3-整数二分\",\"145\":\"19#_3-4-浮点数二分\",\"146\":\"19#_4-高精度算法\",\"147\":\"19#_4-1-高精度加法\",\"148\":\"19#_4-2-高精度减法\",\"149\":\"19#_4-3-高精度整数乘法\",\"150\":\"19#_4-4-高精度整数除法\",\"151\":\"19#_5-前缀和与差分\",\"152\":\"19#_5-1-一维前缀和\",\"153\":\"19#_5-2-二维前缀和\",\"154\":\"19#_5-3-一维差分\",\"155\":\"19#_5-4-二维差分\",\"156\":\"19#_6-位运算\",\"157\":\"19#_6-1-位运算符\",\"158\":\"19#_6-2-用途\",\"159\":\"19#_6-3-例题\",\"160\":\"19#_7-双指针算法\",\"161\":\"19#_8-离散化\",\"162\":\"19#_9-区间合并\",\"163\":\"19@0\",\"164\":\"20\",\"165\":\"20#_1-树与图的存储\",\"166\":\"20#_2-树与图的遍历\",\"167\":\"20#深度优先遍历\",\"168\":\"20#宽度优先遍历\",\"169\":\"20#_3-拓扑排序\",\"170\":\"20#_4-最短路问题\",\"171\":\"20#_4-1-单源最短路\",\"172\":\"20#_4-1-1-朴素版-dijkstra算法\",\"173\":\"20#_4-1-2-堆优化版的dijkstra算法\",\"174\":\"20#_4-1-3-bellman-ford算法-存在负权边\",\"175\":\"20#_4-1-4-spfa算法-存在负权边\",\"176\":\"20#_4-1-5-spfa算法判断图中是否存在负环\",\"177\":\"20#_4-2-多源汇最短路\",\"178\":\"20#_4-2-1-floyd算法\",\"179\":\"20#_5-最小生成树问题\",\"180\":\"20#_5-1-朴素prim算法\",\"181\":\"20#_5-2-kruskal-算法\",\"182\":\"20#_6-染色法判别二分图\",\"183\":\"20#_7-匈牙利算法\",\"184\":\"20@0\",\"185\":\"21\",\"186\":\"21#_1-质数\",\"187\":\"21#_1-1-试除法判定质数\",\"188\":\"21#_1-2-试除法分解质因数\",\"189\":\"21#汇总\",\"190\":\"21#_1-3-筛法求素数\",\"191\":\"21#_1-3-1-朴素筛法-埃氏筛\",\"192\":\"21#_1-3-2-区间筛法\",\"193\":\"21#_1-3-3-线性筛-欧拉筛\",\"194\":\"21#_2-约数\",\"195\":\"21#_2-1-试除法求所有约数\",\"196\":\"21#_2-2-约数个数和约数之和\",\"197\":\"21#_2-3-最大公约数与最小公倍数\",\"198\":\"21#_3-欧拉函数\",\"199\":\"21#_3-1-求欧拉函数\",\"200\":\"21#_3-2-筛法求欧拉函数\",\"201\":\"21#_4-快速幂\",\"202\":\"21#_5-扩展欧几里得算法\",\"203\":\"21#裴蜀定理\",\"204\":\"21#_6-中国剩余定理\",\"205\":\"21#_7-高斯消元\",\"206\":\"21#_8-求组合数\",\"207\":\"21#_8-1-递推法求组合数\",\"208\":\"21#_8-2-通过预处理逆元的方式求组和数\",\"209\":\"21#_8-3-卢卡斯-lucas-定理求组合数\",\"210\":\"21#_8-4-分解质因数法求组合数\",\"211\":\"21#_8-5-卡特兰数\",\"212\":\"21#_9-容斥原理\",\"213\":\"21#_10-博弈论\",\"214\":\"21#_10-1-nim游戏\",\"215\":\"21#_10-2-公平组合游戏icg\",\"216\":\"21#_10-3-有向图游戏\",\"217\":\"21#_10-4-mex运算\",\"218\":\"21#_10-5-sg游戏\",\"219\":\"21#_10-6-有向图游戏的和\",\"220\":\"21@0\",\"221\":\"22\",\"222\":\"22#_1-数组模拟链表\",\"223\":\"22#_1-1-单链表\",\"224\":\"22#_1-2-双链表\",\"225\":\"22#_2-栈\",\"226\":\"22#_2-1-普通栈\",\"227\":\"22#_2-1-单调栈\",\"228\":\"22#_3-队列\",\"229\":\"22#_3-1-普通队列\",\"230\":\"22#_3-2-单调队列\",\"231\":\"22#_4-kmp\",\"232\":\"22#_5-trie树\",\"233\":\"22#_6-并查集\",\"234\":\"22#_6-1-朴素并查集\",\"235\":\"22#_6-2-维护size的并查集\",\"236\":\"22#_6-3-维护到祖宗节点距离的并查集\",\"237\":\"22#_7-堆\",\"238\":\"22#_8-哈希表\",\"239\":\"22#_8-1-拉链法\",\"240\":\"22#_8-2-开放寻址法\",\"241\":\"22#_8-3-字符串哈希\",\"242\":\"22#_9-c-stl简介\",\"243\":\"22#_10-常用库函数\",\"244\":\"22@0\",\"245\":\"23\",\"246\":\"23#_1-区间问题\",\"247\":\"23#_1-1-区间选点\",\"248\":\"23#_1-2-最大不相交区间数量\",\"249\":\"23#_1-3-区间分组\",\"250\":\"23#_1-4-区间覆盖\",\"251\":\"23#_1-5-区间合并\",\"252\":\"23@0\",\"253\":\"24\",\"254\":\"24#_01-背景\",\"255\":\"24#_02-基础功能模块\",\"256\":\"24#_03-架构设计\",\"257\":\"24#_3-1-架构设计-概览\",\"258\":\"24#_3-2-架构设计-reply-interface\",\"259\":\"24#_3-3-架构设计-reply-admin\",\"260\":\"24#_3-4-架构设计-reply-service\",\"261\":\"24#_3-5-架构设计-reply-job\",\"262\":\"24#_04-存储设计\",\"263\":\"24#_4-1-数据库设计\",\"264\":\"24#_4-2-缓存设计\",\"265\":\"24#_05-可用性设计\",\"266\":\"24#_5-1-写热点与读热点\",\"267\":\"24#_5-2-冗余与降级\",\"268\":\"24#_06-安全性设计\",\"269\":\"24#_6-1-数据安全\",\"270\":\"24#_6-2-舆论安全\",\"271\":\"24#_07-热评设计\",\"272\":\"24#_7-1-什么是热评\",\"273\":\"24#_7-2-挑战与应对\",\"274\":\"24#_7-3-愿景与规划\",\"275\":\"24@0\",\"276\":\"24@1\",\"277\":\"25\",\"278\":\"25#功能模块\",\"279\":\"25#架构设计\",\"280\":\"25#comment-service\",\"281\":\"25#读的核心逻辑\",\"282\":\"25#写的核心逻辑\",\"283\":\"25#comment-admin\",\"284\":\"25#bff-comment\",\"285\":\"25@0\",\"286\":\"25@1\",\"287\":\"26\",\"288\":\"26#存储设计\",\"289\":\"26#数据表设计\",\"290\":\"26#总结\",\"291\":\"26#缓存设计\",\"292\":\"26#可用性设计\",\"293\":\"26#缓存穿透\",\"294\":\"26#热点\",\"295\":\"26@0\",\"296\":\"26@1\",\"297\":\"27\",\"298\":\"27#_1、企业做项目流程\",\"299\":\"27#_2、需求分析\",\"300\":\"27#_3、技术选型\",\"301\":\"27#_4、初始化项目\",\"302\":\"27#_4-1-前端初始化\",\"303\":\"27#_4-2-后端初始化-3种初始化-java-项目的方式\",\"304\":\"27@0\",\"305\":\"27@1\",\"306\":\"28\",\"307\":\"28#_1、登录功能\",\"308\":\"28#_1-1-接口设计\",\"309\":\"28#_1-2-登录逻辑\",\"310\":\"28#_1-3-如何知道是哪个用户登录了\",\"311\":\"28#_1-4-登录接口\",\"312\":\"28#_2、用户管理\",\"313\":\"28#_2-1-查询用户\",\"314\":\"28#_2-2-删除用户\",\"315\":\"28#_2-3-用户状态优化\",\"316\":\"28@0\",\"317\":\"28@1\",\"318\":\"29\",\"319\":\"29#_1、数据库设计\",\"320\":\"29#_1-1-什么是设计数据库表\",\"321\":\"29#_1-2-用户表设计\",\"322\":\"29#_1-3-自动生成器的使用\",\"323\":\"29#_2、注册逻辑设计\",\"324\":\"29@0\",\"325\":\"29@1\",\"326\":\"30\",\"327\":\"30#_1、前后端交互\",\"328\":\"30#_1-1-前端请求\",\"329\":\"30#_1-2-代理的位置\",\"330\":\"30#_2、登录页面\",\"331\":\"30#_3、注册页面\",\"332\":\"30@0\",\"333\":\"30@1\",\"334\":\"31\",\"335\":\"31@0\",\"336\":\"31@1\",\"337\":\"32\",\"338\":\"32@0\",\"339\":\"32@1\",\"340\":\"33\",\"341\":\"33@0\",\"342\":\"33@1\",\"343\":\"34\",\"344\":\"34#如何自建代理服务\",\"345\":\"34#放行端口的步骤\",\"346\":\"34#保护你的代理服务器\",\"347\":\"34#本地代理客户端\",\"348\":\"34@0\",\"349\":\"34@1\",\"350\":\"35\",\"351\":\"35#什么是-cloudreve\",\"352\":\"35#搭建过程\",\"353\":\"35#配置进程守护\",\"354\":\"35#配置站点-url-及免费-https\",\"355\":\"35#配置-webdav\",\"356\":\"35#什么是-webdav\",\"357\":\"35#cloudreve-使用-webdav\",\"358\":\"35#windows-使用-webdav\",\"359\":\"35@0\",\"360\":\"35@1\",\"361\":\"36\",\"362\":\"36#题意\",\"363\":\"36#思路\",\"364\":\"36#进阶\",\"365\":\"36#思路-1\",\"366\":\"36#代码\",\"367\":\"36@0\",\"368\":\"36@1\",\"369\":\"37\",\"370\":\"37#题意\",\"371\":\"37#思路\",\"372\":\"37#代码\",\"373\":\"37@0\",\"374\":\"37@1\",\"375\":\"38\",\"376\":\"38#题意\",\"377\":\"38#思路一-先序遍历\",\"378\":\"38#思路二-递归\",\"379\":\"38@0\",\"380\":\"38@1\",\"381\":\"39\",\"382\":\"39#题意\",\"383\":\"39#思路一-递归\",\"384\":\"39#思路二-迭代\",\"385\":\"39@0\",\"386\":\"39@1\",\"387\":\"40\",\"388\":\"40#题意\",\"389\":\"40#思路一-递归遍历\",\"390\":\"40#思路二-层序遍历\",\"391\":\"40@0\",\"392\":\"40@1\",\"393\":\"41\",\"394\":\"41#题意\",\"395\":\"41#思路\",\"396\":\"41#代码\",\"397\":\"41@0\",\"398\":\"41@1\",\"399\":\"42\",\"400\":\"42#题意\",\"401\":\"42#思路一-后序遍历-递归\",\"402\":\"42#思路二-层序遍历-迭代\",\"403\":\"42@0\",\"404\":\"42@1\",\"405\":\"43\",\"406\":\"43#题意\",\"407\":\"43#思路\",\"408\":\"43#代码\",\"409\":\"43@0\",\"410\":\"43@1\",\"411\":\"44\",\"412\":\"44#题意\",\"413\":\"44#思路\",\"414\":\"44#代码\",\"415\":\"44@0\",\"416\":\"44@1\",\"417\":\"45\",\"418\":\"45#题意\",\"419\":\"45#思路\",\"420\":\"45#代码\",\"421\":\"45@0\",\"422\":\"45@1\",\"423\":\"46\",\"424\":\"46#题意\",\"425\":\"46#思路\",\"426\":\"46#代码\",\"427\":\"46@0\",\"428\":\"46@1\",\"429\":\"47\",\"430\":\"47#题意\",\"431\":\"47#思路\",\"432\":\"47#代码\",\"433\":\"47@0\",\"434\":\"47@1\",\"435\":\"48\",\"436\":\"48#题意\",\"437\":\"48#思路\",\"438\":\"48#代码\",\"439\":\"48@0\",\"440\":\"48@1\",\"441\":\"49\",\"442\":\"49#题意\",\"443\":\"49#思路一-dfs\",\"444\":\"49#思路二-bfs\",\"445\":\"49#思路三-并查集\",\"446\":\"49@0\",\"447\":\"49@1\",\"448\":\"50\",\"449\":\"50#题意\",\"450\":\"50#思路\",\"451\":\"50#代码\",\"452\":\"50@0\",\"453\":\"50@1\",\"454\":\"51\",\"455\":\"51#题意\",\"456\":\"51#思路一-优先队列\",\"457\":\"51#思路二-单调队列\",\"458\":\"51@0\",\"459\":\"51@1\",\"460\":\"52\",\"461\":\"52#题意\",\"462\":\"52#思路\",\"463\":\"52#代码\",\"464\":\"52@0\",\"465\":\"52@1\",\"466\":\"53\",\"467\":\"53#题意\",\"468\":\"53#思路\",\"469\":\"53#代码\",\"470\":\"53@0\",\"471\":\"53@1\",\"472\":\"54\",\"473\":\"54#题意\",\"474\":\"54#思路\",\"475\":\"54#代码\",\"476\":\"54@0\",\"477\":\"54@1\",\"478\":\"55\",\"479\":\"55#题意\",\"480\":\"55#思路\",\"481\":\"55#代码\",\"482\":\"55@0\",\"483\":\"55@1\",\"484\":\"56\",\"485\":\"56#题意\",\"486\":\"56#思路一-前序遍历\",\"487\":\"56#思路二-中序遍历\",\"488\":\"56#思路三-后序遍历\",\"489\":\"56@0\",\"490\":\"56@1\",\"491\":\"57\",\"492\":\"57#_1-基础\",\"493\":\"57#_1-1-连接\",\"494\":\"57#_1-2-sql-简介\",\"495\":\"57#_1-2-1-sql-通用语法\",\"496\":\"57#_1-2-2-分类\",\"497\":\"57#_2-数据库设计-ddl\",\"498\":\"57#_2-1-数据库操作\",\"499\":\"57#_2-1-1-查询数据库\",\"500\":\"57#_2-1-2-创建数据库\",\"501\":\"57#_2-1-3-使用数据库\",\"502\":\"57#_2-1-4-删除数据库\",\"503\":\"57#_2-2-表操作\",\"504\":\"57#_2-2-1-创建\",\"505\":\"57#_2-2-1-1-语法\",\"506\":\"57#_2-2-1-2-约束\",\"507\":\"57#_2-2-1-3-数据类型\",\"508\":\"57#_2-2-2-查询\",\"509\":\"57#_2-2-3-修改\",\"510\":\"57#_2-2-4-删除\",\"511\":\"57#_3-数据库操作-dml\",\"512\":\"57#_3-1-增加-insert\",\"513\":\"57#_3-2-修改-update\",\"514\":\"57#_3-3-删除-delete\",\"515\":\"57#_4-数据库操作-dql\",\"516\":\"57#_4-1-语法\",\"517\":\"57#_4-2-基本查询\",\"518\":\"57#_4-3-条件查询\",\"519\":\"57#_4-4-聚合函数\",\"520\":\"57#_4-5-分组查询\",\"521\":\"57#_4-6-排序查询\",\"522\":\"57#_4-7-分页查询\",\"523\":\"57#_5-多表设计\",\"524\":\"57#_5-1-一对多-外键约束\",\"525\":\"57#_5-2-一对一\",\"526\":\"57#_5-3-多对多\",\"527\":\"57#_6-多表查询\",\"528\":\"57#_6-1-概述\",\"529\":\"57#_6-1-1-介绍\",\"530\":\"57#_6-1-2-分类\",\"531\":\"57#_6-3-内连接\",\"532\":\"57#_6-3-外连接\",\"533\":\"57#_6-4-子查询\",\"534\":\"57#_6-4-1-介绍\",\"535\":\"57#_6-4-2-标量子查询\",\"536\":\"57#_6-4-3-列子查询\",\"537\":\"57#_6-4-4-行子查询\",\"538\":\"57#_6-4-5-表子查询\",\"539\":\"57#_7-事务\",\"540\":\"57#_7-1-介绍\",\"541\":\"57#_7-2-操作\",\"542\":\"57#_7-3-四大特性\",\"543\":\"57#_8-索引\",\"544\":\"57#_8-1-介绍\",\"545\":\"57#_8-2-结构\",\"546\":\"57#_8-3-语法\",\"547\":\"57@0\",\"548\":\"57@1\",\"549\":\"58\",\"550\":\"58#一、语法基础\",\"551\":\"58#_1-1-变量\",\"552\":\"58#_1-2-运算符\",\"553\":\"58#_1-3-表达式\",\"554\":\"58#_1-4-输入\",\"555\":\"58#_1-5-输出\",\"556\":\"58#二、判断语句\",\"557\":\"58#_2-1-if-语句\",\"558\":\"58#_2-2-条件表达式\",\"559\":\"58#_2-3-switch-语句\",\"560\":\"58#三、循环语句\",\"561\":\"58#_3-1-while-循环\",\"562\":\"58#_3-2-do-while-循环\",\"563\":\"58#_3-3-for-循环\",\"564\":\"58#_3-4-跳转语句\",\"565\":\"58#_3-4-1-break\",\"566\":\"58#_3-4-2-continue\",\"567\":\"58#_3-5-多层循环\",\"568\":\"58#四、数组\",\"569\":\"58#_4-1-一维数组\",\"570\":\"58#_4-1-1-数组的定义\",\"571\":\"58#_4-1-2-数组的初始化\",\"572\":\"58#_4-1-3-访问数组元素\",\"573\":\"58#_4-2-多维数组\",\"574\":\"58#_4-3-数组的范围遍历\",\"575\":\"58#_4-3-常用api\",\"576\":\"58#五、字符串\",\"577\":\"58#_5-1-字符与整数的联系——ascii码\",\"578\":\"58#_5-2-string-类\",\"579\":\"58#_5-3-输入与输出\",\"580\":\"58#_5-4-stringbuilder、stringbuffer\",\"581\":\"58#六、函数\",\"582\":\"58#_6-1-函数基础\",\"583\":\"58#_6-1-1-编写函数\",\"584\":\"58#_6-1-2-调用函数\",\"585\":\"58#_6-1-3-形参和实参\",\"586\":\"58#_6-1-4-函数的形参列表\",\"587\":\"58#_6-1-5-函数返回类型\",\"588\":\"58#_6-1-6-变量的作用域\",\"589\":\"58#_6-2-参数传递\",\"590\":\"58#_6-2-1-值传递\",\"591\":\"58#_6-2-2-引用传递\",\"592\":\"58#_6-3-返回类型和-return-语句\",\"593\":\"58#_6-3-1-无返回值函数\",\"594\":\"58#_6-3-2-有返回值的函数\",\"595\":\"58#_6-4-函数重载\",\"596\":\"58#_6-5-函数递归\",\"597\":\"58#七、类与接口\",\"598\":\"58#_7-1-类与对象\",\"599\":\"58#_7-1-1-源文件声明规则\",\"600\":\"58#_7-1-2-类的定义\",\"601\":\"58#_7-1-3-类的继承\",\"602\":\"58#_7-1-4-类的多态\",\"603\":\"58#_7-2-接口\",\"604\":\"58#_7-2-1-接口的定义\",\"605\":\"58#_7-2-2-接口的继承\",\"606\":\"58#_7-2-3-接口的实现\",\"607\":\"58#_7-2-4-接口的多态\",\"608\":\"58#八、常用容器\",\"609\":\"58#_8-1-list\",\"610\":\"58#_8-2-栈\",\"611\":\"58#_8-3-队列\",\"612\":\"58#_8-4-set\",\"613\":\"58#_8-5-map\",\"614\":\"58#九、异常处理\",\"615\":\"58#_9-1-error-与-exception-的区别\",\"616\":\"58#_9-2-exception类的继承关系\",\"617\":\"58#_9-3-运行时异常和非运行时异常的区别\",\"618\":\"58#_9-4-内置异常类\",\"619\":\"58#_9-5-内置异常方法\",\"620\":\"58#_9-6-捕获异常\",\"621\":\"58#_9-7-抛出异常\",\"622\":\"58#_9-8-try-with-resources\",\"623\":\"58#十、注解与反射\",\"624\":\"58#_10-1-注解\",\"625\":\"58#_10-1-1-常用注解\",\"626\":\"58#_10-1-2-元注解\",\"627\":\"58#_10-2-反射\",\"628\":\"58#_10-2-1-常用api\",\"629\":\"58#_10-2-2-优缺点\",\"630\":\"58#十一、多线程与锁\",\"631\":\"58#_11-1-多线程\",\"632\":\"58#_11-1-1-实现多线程\",\"633\":\"58#_11-1-2-常用api\",\"634\":\"58#_11-2-锁\",\"635\":\"58#_11-3-同步-synchronized\",\"636\":\"58#_11-3-1-wait-与-notify\",\"637\":\"58@0\",\"638\":\"58@1\",\"639\":\"59\",\"640\":\"59#数组\",\"641\":\"59#字符串\",\"642\":\"59#string\",\"643\":\"59#stringbuilder\",\"644\":\"59#集合\",\"645\":\"59#list-列表\",\"646\":\"59#set-集合\",\"647\":\"59#map-映射\",\"648\":\"59#栈\",\"649\":\"59#queue-队列\",\"650\":\"59#deque-双端队列\",\"651\":\"59#priorityqueue-优先队列\",\"652\":\"59#工具类\",\"653\":\"59#java-util-math\",\"654\":\"59#java-util-collections\",\"655\":\"59#javafx-util-pair-k-v\",\"656\":\"59#基本类型的最大值和最小值\",\"657\":\"59@0\",\"658\":\"59@1\",\"659\":\"60\",\"660\":\"60#linux-安装启动\",\"661\":\"60#docker-安装启动\",\"662\":\"60#windows-安装启动\",\"663\":\"60#windows-后台服务安装\",\"664\":\"60@0\",\"665\":\"60@1\",\"666\":\"61\",\"667\":\"61#什么是对象存储\",\"668\":\"61#特点\",\"669\":\"61@0\",\"670\":\"61@1\",\"671\":\"62\",\"672\":\"62#引入依赖\",\"673\":\"62#配置文件\",\"674\":\"62#minioclient-的常用-api\",\"675\":\"62#bucket-操作\",\"676\":\"62#object-操作\",\"677\":\"62@0\",\"678\":\"62@1\",\"679\":\"63\",\"680\":\"63#概论\",\"681\":\"63#_1-注释\",\"682\":\"63#_1-1-单行注释\",\"683\":\"63#_1-2-多行注释\",\"684\":\"63#_2-变量\",\"685\":\"63#_2-1-定义变量\",\"686\":\"63#_2-2-使用变量\",\"687\":\"63#_2-3-只读变量\",\"688\":\"63#_2-4-删除变量\",\"689\":\"63#_2-5-变量类型\",\"690\":\"63#_2-6-字符串\",\"691\":\"63#_3-默认变量\",\"692\":\"63#_3-1-文件参数变量\",\"693\":\"63#_3-2-其它参数相关变量\",\"694\":\"63#_4-数组\",\"695\":\"63#_4-1-定义\",\"696\":\"63#_4-2-读取数组中某个元素的值\",\"697\":\"63#_4-3-读取整个数组\",\"698\":\"63#_4-4-数组长度\",\"699\":\"63@0\",\"700\":\"63@1\",\"701\":\"64\",\"702\":\"64#一、初始化环境\",\"703\":\"64#二、初始化上下文\",\"704\":\"64#_2-1-加载-eureka-server-配置文件\",\"705\":\"64#_2-1-1-创建默认的-eureka-server-配置\",\"706\":\"64#_2-2-2-加载配置文件\",\"707\":\"64#_2-1-3-真正的配置项在哪\",\"708\":\"64#_2-1-4-加载配置文件小结\",\"709\":\"64#_2-2-构造实例信息管理器\",\"710\":\"64#_2-2-1-初始化服务实例的配置-instanceconfig\",\"711\":\"64#_2-2-2-构造服务实例-instanceinfo\",\"712\":\"64#_2-2-3-小结\",\"713\":\"64#_2-3-初始化-eureka-client\",\"714\":\"64#_2-3-1-初始化-eureka-client-配置\",\"715\":\"64#_2-3-2-初始化-eurekaclient\",\"716\":\"64#_2-4-处理注册相关的流程\",\"717\":\"64#_2-4-1-注册对象\",\"718\":\"64#_2-5-初始化上下文\",\"719\":\"64#_2-5-1-集群节点帮助类\",\"720\":\"64#_2-5-2-默认上下文\",\"721\":\"64#_2-5-3-创建上下文的持有者\",\"722\":\"64#_2-5-4-初始化上下文\",\"723\":\"64#_2-6-其他\",\"724\":\"64#_2-6-1-从相邻节点拷贝注册信息\",\"725\":\"64#_2-6-2-eureka-监控\",\"726\":\"64#_2-7-编译报错的解决方案\",\"727\":\"64#_1、异常1\",\"728\":\"64#_2、异常2\",\"729\":\"64#三、总结\",\"730\":\"64@0\",\"731\":\"64@1\",\"732\":\"65\",\"733\":\"65@0\",\"734\":\"65@1\",\"735\":\"66\",\"736\":\"67\",\"737\":\"68\",\"738\":\"69\",\"739\":\"70\",\"740\":\"71\",\"741\":\"72\",\"742\":\"73\",\"743\":\"74\",\"744\":\"75\",\"745\":\"76\",\"746\":\"77\",\"747\":\"78\",\"748\":\"79\",\"749\":\"80\",\"750\":\"81\",\"751\":\"82\",\"752\":\"83\",\"753\":\"84\",\"754\":\"85\",\"755\":\"86\",\"756\":\"87\",\"757\":\"88\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1,4],\"2\":[1,6],\"3\":[1,5],\"4\":[2],\"5\":[1,2],\"6\":[1,4],\"7\":[1,9],\"8\":[1],\"9\":[1],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[1],\"14\":[1,44],\"15\":[1],\"16\":[1],\"17\":[1,2],\"18\":[1,3],\"19\":[1,5],\"20\":[1],\"21\":[null,null,1],\"22\":[null,null,1],\"23\":[1,2],\"24\":[1,18],\"25\":[1,39],\"26\":[3,1],\"27\":[null,null,1],\"28\":[null,null,2],\"29\":[2],\"30\":[2,7],\"31\":[2],\"32\":[3,22],\"33\":[3,25],\"34\":[3,20],\"35\":[3,74],\"36\":[2,59],\"37\":[2],\"38\":[3,21],\"39\":[3,27],\"40\":[3,21],\"41\":[2,86],\"42\":[2],\"43\":[1,183],\"44\":[1,172],\"45\":[null,null,1],\"46\":[null,null,1],\"47\":[1,14],\"48\":[1,110],\"49\":[1,90],\"50\":[1,68],\"51\":[1,7],\"52\":[null,null,2],\"53\":[null,null,1],\"54\":[1,20],\"55\":[1,129],\"56\":[1,92],\"57\":[1,103],\"58\":[1,8],\"59\":[null,null,2],\"60\":[null,null,1],\"61\":[1],\"62\":[3,14],\"63\":[2,88],\"64\":[2,19],\"65\":[2,23],\"66\":[2,21],\"67\":[6,7],\"68\":[2,25],\"69\":[2,27],\"70\":[2,20],\"71\":[5,39],\"72\":[3,31],\"73\":[5,7],\"74\":[3,44],\"75\":[2,74],\"76\":[6,36],\"77\":[2,32],\"78\":[null,null,1],\"79\":[null,null,1],\"80\":[1],\"81\":[1,138],\"82\":[1,101],\"83\":[1,109],\"84\":[null,null,1],\"85\":[null,null,1],\"86\":[1],\"87\":[1,18],\"88\":[1],\"89\":[2,24],\"90\":[4,21],\"91\":[2,22],\"92\":[1],\"93\":[2,109],\"94\":[5,127],\"95\":[null,null,2],\"96\":[null,null,1],\"97\":[1],\"98\":[2,105],\"99\":[2,126],\"100\":[1,50],\"101\":[2,61],\"102\":[2],\"103\":[2],\"104\":[null,null,1],\"105\":[null,null,2],\"106\":[1],\"107\":[1,65],\"108\":[1,71],\"109\":[1,83],\"110\":[1,107],\"111\":[1,143],\"112\":[null,null,1],\"113\":[null,null,1],\"114\":[1],\"115\":[2,4],\"116\":[3,48],\"117\":[3,45],\"118\":[3,74],\"119\":[3,53],\"120\":[2],\"121\":[3,53],\"122\":[2,73],\"123\":[5,47],\"124\":[3,79],\"125\":[3,83],\"126\":[3,64],\"127\":[2,75],\"128\":[2,60],\"129\":[2,101],\"130\":[2],\"131\":[3,74],\"132\":[3,74],\"133\":[2],\"134\":[3,76],\"135\":[null,null,2],\"136\":[1],\"137\":[2,54],\"138\":[2,58],\"139\":[2],\"140\":[3,13],\"141\":[1,30],\"142\":[1,45],\"143\":[3,36],\"144\":[2,72],\"145\":[3,25],\"146\":[2],\"147\":[3,77],\"148\":[3,106],\"149\":[3,60],\"150\":[2,72],\"151\":[2],\"152\":[3,10],\"153\":[3,15],\"154\":[3,10],\"155\":[3,13],\"156\":[2],\"157\":[3,37],\"158\":[3,138],\"159\":[3,81],\"160\":[2,25],\"161\":[2,34],\"162\":[2,27],\"163\":[null,null,1],\"164\":[1],\"165\":[2,73],\"166\":[2,7],\"167\":[1,16],\"168\":[1,23],\"169\":[2,49],\"170\":[2],\"171\":[3,34],\"172\":[4,84],\"173\":[4,76],\"174\":[7,103],\"175\":[5,88],\"176\":[4,62],\"177\":[3],\"178\":[4,31],\"179\":[2,14],\"180\":[3,106],\"181\":[4,114],\"182\":[2,80],\"183\":[2,94],\"184\":[null,null,2],\"185\":[1],\"186\":[2],\"187\":[2,26],\"188\":[3,47],\"189\":[1,34],\"190\":[3],\"191\":[5,63],\"192\":[4,53],\"193\":[5,65],\"194\":[2],\"195\":[3,27],\"196\":[2,67],\"197\":[3,27],\"198\":[2],\"199\":[3,35],\"200\":[3,60],\"201\":[2,49],\"202\":[2],\"203\":[1,64],\"204\":[2,94],\"205\":[2,83],\"206\":[2],\"207\":[3,29],\"208\":[3,86],\"209\":[5,79],\"210\":[3,73],\"211\":[3,11],\"212\":[2,81],\"213\":[2],\"214\":[3,74],\"215\":[3,17],\"216\":[3,12],\"217\":[3,11],\"218\":[3,23],\"219\":[3,22],\"220\":[null,null,2],\"221\":[1],\"222\":[2],\"223\":[2,49],\"224\":[3,35],\"225\":[2,1],\"226\":[3,20],\"227\":[3,31],\"228\":[2,2],\"229\":[3,24],\"230\":[3,38],\"231\":[2,86],\"232\":[2,41],\"233\":[2],\"234\":[3,32],\"235\":[3,26],\"236\":[3,32],\"237\":[2,90],\"238\":[2],\"239\":[3,27],\"240\":[3,23],\"241\":[3,46],\"242\":[3,144],\"243\":[2,100],\"244\":[null,null,2],\"245\":[1],\"246\":[2],\"247\":[2,54],\"248\":[3,45],\"249\":[3,62],\"250\":[3,65],\"251\":[3,64],\"252\":[null,null,2],\"253\":[1,3],\"254\":[2,44],\"255\":[2,43],\"256\":[2,3],\"257\":[4,1],\"258\":[5,49],\"259\":[4,22],\"260\":[5,14],\"261\":[5,87],\"262\":[2],\"263\":[3,120],\"264\":[3,80],\"265\":[2],\"266\":[3,71],\"267\":[3,29],\"268\":[2,5],\"269\":[3,38],\"270\":[3,79],\"271\":[2],\"272\":[3,52],\"273\":[3,208],\"274\":[3,96],\"275\":[null,null,1],\"276\":[null,null,1],\"277\":[1,13],\"278\":[1,45],\"279\":[1,83],\"280\":[2,17],\"281\":[1,53],\"282\":[1,46],\"283\":[2,48],\"284\":[2,25],\"285\":[null,null,1],\"286\":[null,null,1],\"287\":[1,3],\"288\":[1],\"289\":[1,164],\"290\":[1,14],\"291\":[1,72],\"292\":[1],\"293\":[1,75],\"294\":[1,46],\"295\":[null,null,1],\"296\":[null,null,1],\"297\":[2,2],\"298\":[2,18],\"299\":[2,9],\"300\":[2,52],\"301\":[2],\"302\":[3,115],\"303\":[6,26],\"304\":[null,null,1],\"305\":[null,null,1],\"306\":[2,2],\"307\":[2],\"308\":[2,14],\"309\":[3,42],\"310\":[4,194],\"311\":[3,156],\"312\":[2,12],\"313\":[3,64],\"314\":[2,25],\"315\":[3,38],\"316\":[null,null,1],\"317\":[null,null,1],\"318\":[2,2],\"319\":[2,10],\"320\":[3,9],\"321\":[3,84],\"322\":[3,89],\"323\":[2,190],\"324\":[null,null,1],\"325\":[null,null,1],\"326\":[2,5],\"327\":[2],\"328\":[2,20],\"329\":[3,39],\"330\":[2],\"331\":[2],\"332\":[null,null,1],\"333\":[null,null,1],\"334\":[1,154],\"335\":[null,null,1],\"336\":[null,null,2],\"337\":[1,5],\"338\":[null,null,1],\"339\":[null,null,1],\"340\":[1,19],\"341\":[null,null,1],\"342\":[null,null,1],\"343\":[1,23],\"344\":[1,49],\"345\":[1,96],\"346\":[1,88],\"347\":[1,60],\"348\":[null,null,1],\"349\":[null,null,1],\"350\":[1,48],\"351\":[2,23],\"352\":[1,104],\"353\":[1,118],\"354\":[4,147],\"355\":[2],\"356\":[2,16],\"357\":[3,24],\"358\":[3,28],\"359\":[null,null,1],\"360\":[null,null,1],\"361\":[1,2],\"362\":[1,10],\"363\":[1,34],\"364\":[1,8],\"365\":[1,31],\"366\":[1,30],\"367\":[null,null,2],\"368\":[null,null,2],\"369\":[1,2],\"370\":[1,17],\"371\":[1],\"372\":[1],\"373\":[null,null,2],\"374\":[null,null,3],\"375\":[1,2],\"376\":[1,20],\"377\":[2,39],\"378\":[2,41],\"379\":[null,null,2],\"380\":[null,null,1],\"381\":[1,2],\"382\":[1,16],\"383\":[3,13],\"384\":[3,21],\"385\":[null,null,2],\"386\":[null,null,3],\"387\":[1,2],\"388\":[1,6],\"389\":[2,42],\"390\":[2,42],\"391\":[null,null,2],\"392\":[null,null,3],\"393\":[1,2],\"394\":[1,7],\"395\":[1,9],\"396\":[1,38],\"397\":[null,null,2],\"398\":[null,null,2],\"399\":[1,2],\"400\":[1,7],\"401\":[4,32],\"402\":[4,35],\"403\":[null,null,2],\"404\":[null,null,3],\"405\":[1,2],\"406\":[1,16],\"407\":[1,3],\"408\":[1,30],\"409\":[null,null,2],\"410\":[null,null,2],\"411\":[1,2],\"412\":[1,11],\"413\":[1,9],\"414\":[1,26],\"415\":[null,null,2],\"416\":[null,null,2],\"417\":[1,2],\"418\":[1,9],\"419\":[1,74],\"420\":[1,62],\"421\":[null,null,2],\"422\":[null,null,3],\"423\":[4,4],\"424\":[1,32],\"425\":[1,54],\"426\":[1,56],\"427\":[null,null,2],\"428\":[null,null,1],\"429\":[1,2],\"430\":[1,4],\"431\":[1,21],\"432\":[1,22],\"433\":[null,null,2],\"434\":[null,null,2],\"435\":[1,2],\"436\":[1,12],\"437\":[1,8],\"438\":[1,28],\"439\":[null,null,2],\"440\":[null,null,1],\"441\":[1,2],\"442\":[1,14],\"443\":[3,66],\"444\":[3,70],\"445\":[3,59],\"446\":[null,null,2],\"447\":[null,null,3],\"448\":[1,2],\"449\":[1,22],\"450\":[1,23],\"451\":[1,46],\"452\":[null,null,2],\"453\":[null,null,1],\"454\":[1,2],\"455\":[1,11],\"456\":[3,41],\"457\":[3],\"458\":[null,null,2],\"459\":[null,null,3],\"460\":[1,2],\"461\":[1,5],\"462\":[1,6],\"463\":[1,27],\"464\":[null,null,2],\"465\":[null,null,2],\"466\":[1,2],\"467\":[1,25],\"468\":[1,49],\"469\":[1,91],\"470\":[null,null,2],\"471\":[null,null,1],\"472\":[1,2],\"473\":[1,32],\"474\":[1,71],\"475\":[1,53],\"476\":[null,null,2],\"477\":[null,null,1],\"478\":[2,3],\"479\":[1,13],\"480\":[1,28],\"481\":[1,36],\"482\":[null,null,2],\"483\":[null,null,4],\"484\":[1,2],\"485\":[1,12],\"486\":[2,80],\"487\":[2,37],\"488\":[2,42],\"489\":[null,null,2],\"490\":[null,null,2],\"491\":[2],\"492\":[2],\"493\":[2,32],\"494\":[4,5],\"495\":[4,19],\"496\":[3,27],\"497\":[3,13],\"498\":[3,15],\"499\":[3,11],\"500\":[3,19],\"501\":[4,9],\"502\":[4,28],\"503\":[2,6],\"504\":[3],\"505\":[3,18],\"506\":[3,55],\"507\":[4,156],\"508\":[2,14],\"509\":[3,39],\"510\":[3,13],\"511\":[3,15],\"512\":[5,22],\"513\":[5,37],\"514\":[4,23],\"515\":[3],\"516\":[3,31],\"517\":[3,22],\"518\":[3,52],\"519\":[2,40],\"520\":[3,39],\"521\":[3,27],\"522\":[3,65],\"523\":[2,11],\"524\":[4,52],\"525\":[3,45],\"526\":[3,17],\"527\":[2],\"528\":[3],\"529\":[3,34],\"530\":[4,14],\"531\":[3,29],\"532\":[3,31],\"533\":[3],\"534\":[4,36],\"535\":[4,8],\"536\":[4,11],\"537\":[3,8],\"538\":[4,4],\"539\":[2],\"540\":[3,24],\"541\":[3,32],\"542\":[3,41],\"543\":[2],\"544\":[3,24],\"545\":[3,161],\"546\":[3,19],\"547\":[null,null,1],\"548\":[null,null,1],\"549\":[2],\"550\":[2],\"551\":[2,57],\"552\":[3,37],\"553\":[3,38],\"554\":[3,52],\"555\":[3,67],\"556\":[2,4],\"557\":[4,102],\"558\":[2,51],\"559\":[4,52],\"560\":[2,8],\"561\":[4,69],\"562\":[5,27],\"563\":[3,82],\"564\":[3],\"565\":[4,46],\"566\":[4,34],\"567\":[3,43],\"568\":[2,7],\"569\":[3],\"570\":[3,25],\"571\":[4,25],\"572\":[4,58],\"573\":[3,52],\"574\":[3,37],\"575\":[3,19],\"576\":[2,2],\"577\":[4,48],\"578\":[4,101],\"579\":[3,37],\"580\":[4,33],\"581\":[2,3],\"582\":[3,6],\"583\":[3,26],\"584\":[4,34],\"585\":[4,20],\"586\":[4,16],\"587\":[4,34],\"588\":[3,32],\"589\":[3],\"590\":[4,24],\"591\":[3,53],\"592\":[5,5],\"593\":[4,48],\"594\":[4,38],\"595\":[3,33],\"596\":[3,34],\"597\":[2,3],\"598\":[3,14],\"599\":[3,14],\"600\":[4,43],\"601\":[4,25],\"602\":[4,28],\"603\":[3,8],\"604\":[4,11],\"605\":[3,9],\"606\":[4,27],\"607\":[4,35],\"608\":[2],\"609\":[3,24],\"610\":[3,18],\"611\":[3,27],\"612\":[3,29],\"613\":[3,42],\"614\":[2,2],\"615\":[6,18],\"616\":[3,2],\"617\":[3,27],\"618\":[3,86],\"619\":[3,29],\"620\":[3,42],\"621\":[3,43],\"622\":[5,54],\"623\":[2],\"624\":[3,28],\"625\":[3,20],\"626\":[4,16],\"627\":[3,5],\"628\":[4,69],\"629\":[3,5],\"630\":[2],\"631\":[3],\"632\":[3,55],\"633\":[4,14],\"634\":[3,50],\"635\":[5,51],\"636\":[6,59],\"637\":[null,null,1],\"638\":[null,null,1],\"639\":[1,4],\"640\":[1,28],\"641\":[1,25],\"642\":[1,156],\"643\":[1,21],\"644\":[1],\"645\":[2,70],\"646\":[2,43],\"647\":[2,113],\"648\":[1,60],\"649\":[2,42],\"650\":[2,33],\"651\":[2,69],\"652\":[1],\"653\":[3,35],\"654\":[3,44],\"655\":[4,32],\"656\":[1,28],\"657\":[null,null,1],\"658\":[null,null,1],\"659\":[2,16],\"660\":[2,85],\"661\":[2,20],\"662\":[2,42],\"663\":[2,78],\"664\":[null,null,1],\"665\":[null,null,1],\"666\":[2,40],\"667\":[2,56],\"668\":[1,143],\"669\":[null,null,1],\"670\":[null,null,1],\"671\":[3],\"672\":[1,12],\"673\":[1,85],\"674\":[3],\"675\":[2,76],\"676\":[2,95],\"677\":[null,null,1],\"678\":[null,null,1],\"679\":[2],\"680\":[1,60],\"681\":[2],\"682\":[2,7],\"683\":[3,13],\"684\":[2],\"685\":[3,13],\"686\":[2,14],\"687\":[3,12],\"688\":[3,7],\"689\":[3,22],\"690\":[3,28],\"691\":[2],\"692\":[3,37],\"693\":[3,27],\"694\":[2,6],\"695\":[3,17],\"696\":[3,15],\"697\":[3,12],\"698\":[2,12],\"699\":[null,null,1],\"700\":[null,null,1],\"701\":[5,7],\"702\":[2,67],\"703\":[2,14],\"704\":[6,44],\"705\":[6,10],\"706\":[2,103],\"707\":[5,67],\"708\":[4,47],\"709\":[2,2],\"710\":[4,30],\"711\":[3,23],\"712\":[3,13],\"713\":[5],\"714\":[7,43],\"715\":[4,115],\"716\":[3],\"717\":[4,57],\"718\":[3],\"719\":[4,14],\"720\":[3,12],\"721\":[4,32],\"722\":[4,33],\"723\":[3],\"724\":[4,6],\"725\":[4,3],\"726\":[3],\"727\":[2,18],\"728\":[2,20],\"729\":[2,4],\"730\":[null,null,1],\"731\":[null,null,1],\"732\":[6],\"733\":[null,null,1],\"734\":[null,null,1],\"735\":[1,3],\"736\":[2],\"737\":[1],\"738\":[1],\"739\":[1],\"740\":[2],\"741\":[2],\"742\":[2],\"743\":[1],\"744\":[2],\"745\":[1],\"746\":[1],\"747\":[1],\"748\":[1],\"749\":[1],\"750\":[2],\"751\":[1],\"752\":[1],\"753\":[2],\"754\":[1],\"755\":[2],\"756\":[2],\"757\":[1]},\"averageFieldLength\":[2.3149480880651776,40.475280622950976,0.642765607755527],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"个人介绍和档案放置在此。\"]},\"1\":{\"h\":\"算法笔记\",\"t\":[\"此处存放刷题时的思路和笔记，包括算法题、笔试题和面试题等。\"]},\"2\":{\"h\":\"模板\",\"t\":[\"基础算法\",\"数据结构\",\"搜索与图论\",\"数学知识\",\"动态规划\",\"贪心\"]},\"3\":{\"h\":\"笔记\",\"t\":[\"并查集\",\"递归相关题型\",\"前缀和相关题型\",\"搜索\",\"一些经验和技巧\"]},\"4\":{\"h\":\"剑指 offer\"},\"5\":{\"h\":\"LeetCode\",\"t\":[\"热题 100\"]},\"6\":{\"h\":\"架构设计\",\"t\":[\"此处存放一些关于 Java 架构以及系统架构方面的笔记知识点。\"]},\"7\":{\"h\":\"计算机\",\"t\":[\"此处存放一些计算机大类的笔记，包括编程语言、计算机网络、操作系统、数据库、Linux、Git、Docker等等。\"]},\"8\":{\"h\":\"目录\"},\"9\":{\"h\":\"编程语言\"},\"10\":{\"h\":\"计算机网络\"},\"11\":{\"h\":\"数据库\"},\"12\":{\"h\":\"操作系统\"},\"13\":{\"h\":\"设计模式\"},\"14\":{\"h\":\"中间件\",\"t\":[\"中间件（英语：Middleware）：是一种在系统软件和用户应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件在客户服务器的操作系统、网络和数据库之上，管理计算资源和网络通信。总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。\",\"也就是说，关于中间件，可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。中间件是一类软件统称，而非一种软件；中间件不仅仅实现互连，还要实现应用之间的互操作。\",\"中间件与操作系统和数据库共同构成基础软件三大支柱，是一种应用于分布式系统的基础软件，位于应用与操作系统、数据库之间，为上层应用软件提供开发、运行和集成的平台。中间件解决了异构网络环境下软件互联和互操作等共性问题，并提供标准接口、协议，为应用软件间共享资源提供了可复用的“标准件”。\",\"常见中间件主要分为：Web中间件、数据库中间件、消息中间件、安全中间件、事务中间件、应用程序服务器中间件、分布式计算中间件等。\"]},\"15\":{\"h\":\"Git\"},\"16\":{\"h\":\"Docker\"},\"17\":{\"h\":\"常用框架\",\"t\":[\"此处存放前后端常用框架的笔记。\"]},\"18\":{\"h\":\"开源项目\",\"t\":[\"此处存放自己写和一些优秀的开源项目，帮助学习。\"]},\"19\":{\"h\":\"程序人生\",\"t\":[\"此处存放一些程序员相关的资源文件，包括但不限于书籍、文章、资料等等。\"]},\"20\":{\"h\":\"剑指offer\"},\"21\":{\"c\":[\"algorithm\"]},\"22\":{\"c\":[\"offer\"]},\"23\":{\"h\":\"另一棵树的子树\",\"t\":[\"572.另一棵树的子树\"]},\"24\":{\"h\":\"题意\",\"t\":[\"给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。\",\"二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。\"]},\"25\":{\"h\":\"思路一\",\"t\":[\"直接递归判断:\",\"如果 subRoot 为空，则和叶节点的空子节点匹配，返回 true\",\"如果当前节点是空节点，无法与 subRoot 匹配，返回 false。\",\"如果当前节点与 subRoot 根节点相同，则递归往下判断，如果是相同的树，返回 true。\",\"否则，递归左右子树，看是否能找到匹配的，如果找到则返回 true。\",\"代码:\",\"class Solution { boolean isSametree(TreeNode p, TreeNode q) { if (p == null || q == null) return p == q; return p.val == q.val && isSametree(p.left, q.left) && isSametree(p.right, q.right); } public boolean isSubtree(TreeNode root, TreeNode subRoot) { if (subRoot == null) return true; if (root == null) return false; return isSametree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); } }\"]},\"26\":{\"h\":\"思路二（优化）\",\"t\":[\"只在高度相同时匹配\"]},\"27\":{\"c\":[\"数据结构\"]},\"28\":{\"c\":[\"二叉树\",\"递归\"]},\"29\":{\"h\":\"A* 算法\"},\"30\":{\"h\":\"1. 介绍\",\"t\":[\"A∗（念做：A Star）算法是一种很常用的路径查找和图形遍历算法。它有较好的性能和准确度。\"]},\"31\":{\"h\":\"2. 搜索\"},\"32\":{\"h\":\"2.1 广度优先搜索\",\"t\":[\"广度优先搜索以广度做为优先级进行搜索。\",\"从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。\",\"这种算法就像洪水（Floodfill）一样向外扩张。\",\"对于有明确终点的问题来说，一旦到达终点便可以提前终止算法，下面这幅图对比了这种情况：\",\"搜索\",\"在执行算法的过程中，每个点需要记录达到该点的前一个点的位置 -- 可以称之为父节点。这样做之后，一旦到达终点，便可以从终点开始，反过来顺着父节点的顺序找到起点，由此就构成了一条路径。\"]},\"33\":{\"h\":\"2.2 Dijkstra 算法\",\"t\":[\"Dijkstra 算法用来寻找图形中节点之间的最短路径。\",\"考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。\",\"在 Dijkstra 算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。\",\"在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。\",\"注意\",\"当图形为网格图，并且每个节点之间的移动代价是相等的，那么 Dijkstra 算法将和广度优先算法变得一样。\"]},\"34\":{\"h\":\"2.3 最佳优先搜索\",\"t\":[\"在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。\",\"其原理也很简单。与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（BestFirst）算法。可以大大加快路径的搜索速度。\",\"但是算法也有缺点，如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径。\"]},\"35\":{\"h\":\"3. A*\",\"t\":[\"A∗ 算法通过下面这个函数来计算每个节点的优先级。\",\"A*函数\",\"其中：\",\"f(n) 是节点 n 的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。\",\"g(n) 是节点 n 距离起点的代价。\",\"h(n) 是节点 n 距离终点的预计代价，即 A∗ 算法的启发函数。\",\"A∗ 算法在运算过程中，每次从优先队列中选取 f(n) 值最小（优先级最高）的节点作为下一个待遍历的节点。\",\"另外，A∗ 算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为 open_set 和 close_set。\",\"完整的 A∗ 算法描述如下：\",\"* 初始化 open_set 和 close_set； * 将起点加入 open_set 中，并设置优先级为 0（优先级最高）； * 如果 open_set 不为空，则从 open_set 中选取优先级最高的节点 n： * 如果节点 n 为终点，则： * 从终点开始逐步追踪 parent 节点，一直达到起点； * 返回找到的结果路径，算法结束； * 如果节点 n 不是终点，则： * 将节点 n 从 open_set 中删除，并加入 close_set 中； * 遍历节点 n 所有的邻近节点： * 如果邻近节点 m 在 close_set 中，则： * 跳过，选取下一个邻近节点 * 如果邻近节点 m 在 open_set 中，则： * 比较 gcost 是否比原来更小 * 如果更小则更新 parent * 如果邻近节点 m 也不在 open_set 中，则： * 设置节点 m 的 parent 为节点 n * 计算节点 m 的优先级 * 将节点 m 加入 open_set 中\"]},\"36\":{\"h\":\"4. 启发函数\",\"t\":[\"启发函数会影响 A∗ 算法的行为。\",\"在极端情况下，当启发函数 h(n) 始终为0，则将由 g(n) 决定节点的优先级，此时算法就退化成了 Dijkstra 算法。\",\"如果 h(n) 始终小于等于节点 n 到终点的代价，则 A∗ 算法保证一定能够找到最短路径。但是当 h(n) 的值越小，算法将遍历越多的节点，也就导致算法越慢。\",\"如果 h(n) 完全等于节点 n 到终点的代价，则 A∗ 算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。\",\"如果 h(n) 的值比节点 n 到终点的代价要大，则 A∗ 算法不能保证找到最短路径，不过此时会很快。\",\"在另外一个极端情况下，如果 h(n) 相较于 g(n) 大很多，则此时只有 h(n) 产生效果，这也就变成了最佳优先搜索。\",\"由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是 A∗ 算法比较灵活的地方。\",\"对于网格形式的图，有以下这些启发函数可以使用：\",\"如果图形中只允许朝上下左右四个方向移动，则可以使用 曼哈顿距离 （Manhattandistance）。\",\"如果图形中允许朝八个方向移动，则可以使用 对角距离。\",\"如果图形中允许朝任何方向移动，则可以使用 欧几里得距离（Euclideandistance）。\"]},\"37\":{\"h\":\"5. 关于距离\"},\"38\":{\"h\":\"5.1 曼哈顿距离\",\"t\":[\"如果图形中只允许朝上下左右四个方向移动，则启发函数可以使用曼哈顿距离，它的计算方法如下图所示：\",\"曼哈顿距离\",\"计算曼哈顿距离的函数如下，这里的D是指两个相邻节点之间的移动代价，通常是一个固定的常数。\",\"function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * (dx + dy)\"]},\"39\":{\"h\":\"5.2 对角距离\",\"t\":[\"如果图形中允许斜着朝邻近的节点移动，则启发函数可以使用对角距离。它的计算方法如下：\",\"对角距离\",\"计算对角距离的函数如下，这里的 D2 指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就是\",\"对角公式\",\"function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\"]},\"40\":{\"h\":\"5.3 欧几里得距离\",\"t\":[\"如果图形中允许朝任意方向移动，则可以使用欧几里得距离。\",\"欧几里得距离是指两个节点之间的直线距离，因此其计算方法也是我们比较熟悉的：\",\"欧几里得公式\",\"其函数表示如下：\",\"function heuristic(node) = dx = abs(node.x - goal.x) dy = abs(node.y - goal.y) return D * sqrt(dx * dx + dy * dy)\"]},\"41\":{\"h\":\"6.补充\",\"t\":[\"1. A* 应用场景: 起点 → 终点的最短距离 状态空间 >> 1e10 启发函数减小搜索空间 2. A* 算法: while(q.size()) t ← 优先队列的队头 小根堆 当终点第一次出队时 break; 从起点到当前点的真实距离 d_real 从当前点到终点的估计距离 d_estimate 选择一个估计距离最小的点 min(d_estimate) for j in ne[t]: 将邻边入队 3. A* 算法条件: 估计距离 <= 真实距离 d[state] + f[state] = 起点到state的真实距离 + state到终点的估计距离=估计距离 ^ d[state] + g[state] = 起点到state的真实距离 + state到终点的真实距离=真实距离 一定是有解才有 d[i] >= d[最优] = d[u]+f[u] f[u] >= 0 4. 证明终点第一次出队列即最优解 (1)假设终点第一次出队列时不是最优 则说明当前队列中存在点u 有 d[估计]< d[真实] d[u] + f[u] <= d[u] + g[u] = d[队头终点] 即队列中存在比d[终点]小的值 (2)但我们维护的是一个小根堆, 没有比d[队头终点]小的d[u], 矛盾, 证毕. 5. A* 不用判重 以边权都为1为例 A o→o→o ↑ ↓ S o→o→o→o→o→o→o T B dist[A] = dist[S]+1 + f[A] = 7 dist[B] = dist[S]+1 + f[B] = 5 则会优先从B这条路走到T B走到T后再从A这条路走到T\"]},\"42\":{\"h\":\"7. 例题\"},\"43\":{\"h\":\"\",\"t\":[\"给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。\",\"注意： 每条最短路中至少要包含一条边。\",\"输入格式\",\"第一行包含两个整数 N 和 M。 接下来 M 行，每行包含三个整数 A,B 和 L，表示点 A 与点 B 之间存在有向边，且边长为 L。 最后一行包含三个整数 S,T 和 K，分别表示起点 S，终点 T 和第 K 短路。\",\"输出格式\",\"输出占一行，包含一个整数，表示第 K 短路的长度，如果第 K 短路不存在，则输出 −1。\",\"数据范围\",\"1≤S,T≤N≤1000,0≤M≤104,1≤K≤1000,1≤L≤100\",\"输入样例：\",\"2 2 1 2 5 2 1 4 1 2 2\",\"输出样例：\",\"14\",\"注意\",\"本题估价函数使用 dijkstra 反向建边求终点到各点的距离作为估计值 f[u].\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #define PII pair<int, int> #define PIII pair<int, PII> #define x first #define y second using namespace std; const int N = 1010, M = 2e5 + 10; int n, m, S, T, K; int h[N], rh[N], e[M], w[M], ne[M], idx; int dist[N], cnt[N]; bool st[N]; void add(int h[], int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } void dijkstra() { // 存储距离和起点 // 反向搜索，从终点开始，小根堆 priority_queue<PII, vector<PII>, greater<PII>> heap; heap.push({0, T}); memset(dist, 0x3f, sizeof dist); dist[T] = 0; while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y; if (st[ver]) continue; st[ver] = true; for (int i = rh[ver]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] > dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int astar() { // {当前距离+估计到终点的距离, {当前距离, 当前节点}} priority_queue<PIII, vector<PIII>, greater<PIII>> heap; heap.push({dist[S], {0, S}}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y.y, distance = t.y.x; cnt[ver]++; //如果终点已经被访问过k次了, 则此时的ver就是终点T, 返回答案 if (cnt[T] == K) return distance; for (int i = h[ver]; ~i; i = ne[i]) { int j = e[i]; /* 如果走到一个中间点都cnt[j]>=K, 则说明j已经出队k次了, 且astar()并没有return distance, 说明从j出发找不到第k短路(让终点出队k次)， 即继续让j入队的话依然无解， 那么就没必要让j继续入队了 */ if (cnt[j] < K) { // 按 真实值+估计值 = d[j]+f[j] = dist[S->t] + w[t->j] + dist[j->T] 堆排 // 真实值 dist[S->t] = distance+w[i] heap.push({distance + w[i] + dist[j], {distance + w[i], j}}); } } } return -1; } int main() { cin >> m >> n; memset(h, -1, sizeof h); memset(rh, -1, sizeof rh); for (int i = 0; i < n; i++){ int a, b, c; cin >> a >> b >> c; add(h, a, b, c); add(rh, b, a, c); } cin >> S >> T >> K; // 起点==终点时 则d[S→S] = 0这种情况就要舍去, 总共第K大变为总共第K+1大 if (S == T) K++; // 从各点到终点的最短路距离 作为估计函数f[u] dijkstra(); cout << astar() << endl; return 0; }\"]},\"44\":{\"h\":\"\",\"t\":[\"在一个 3×3 的网格中，1∼8 这 8 个数字和一个 X 恰好不重不漏地分布在这 3×3 的网格中。\",\"例如：\",\"1 2 3 X 4 6 7 5 8\",\"在游戏过程中，可以把 X 与其上、下、左、右四个方向之一的数字交换（如果存在）。\",\"我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：\",\"1 2 3 4 5 6 7 8 X\",\"例如，示例中图形就可以通过让 X 先后与右、下、右三个方向的数字交换成功得到正确排列。\",\"交换过程如下：\",\"1 2 3 1 2 3 1 2 3 1 2 3 X 4 6 4 X 6 4 5 6 4 5 6 7 5 8 7 5 8 7 X 8 7 8 X\",\"把 X 与上下左右方向数字交换的行动记录为 u、d、l、r。\",\"现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。\",\"输入格式\",\"输入占一行，将 3×3 的初始网格描绘出来。 例如，如果初始网格如下所示：\",\"1 2 3 x 4 6 7 5 8\",\"则输入为：1 2 3 x 4 6 7 5 8\",\"输出格式\",\"输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。 如果答案不唯一，输出任意一种合法方案即可。 如果不存在解决方案，则输出 unsolvable。\",\"输入样例：\",\"2 3 4 1 5 x 7 6 8\",\"输出样例：\",\"ullddrurdllurdruldr\",\"八数码 A*高级解法\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #include <unordered_map> #define PIS pair<int, string> using namespace std; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; char op[5] = \\\"urdl\\\"; // 从该状态到达目标状态的估价函数 // 计算各个点与目标状态的曼哈顿距离之和 int f(string state) { int res = 0; for (int i = 0; i < state.size(); i++){ if (state[i] != 'x') { int t = state[i] - '1'; res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3); } } return res; } string bfs(string start) { string end = \\\"12345678x\\\"; unordered_map<string, int> dist; unordered_map<string, pair<string, char>> prev; // 记录到达此状态的操作和上一步状态 // 初始化小根堆 // 第一元素：从起点到该状态的真实距离+该状态到目标状态的估价距离 // 第二元素：存储该状态 priority_queue<PIS, vector<PIS>, greater<PIS>> heap; heap.push({f(start), start}); dist[start] = 0; while (heap.size()) { auto t = heap.top(); heap.pop(); string state = t.second; if (state == end) break; // 求'x'的坐标 int x, y; for (int i = 0; i < state.size(); i++){ if (state[i] == 'x'){ x = i / 3, y = i % 3; break; } } int step = dist[state]; // 记录原来到达该状态的距离 string source = state; // 存储备份该状态 for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; if (xx >= 0 && xx < 3 && yy >= 0 && yy < 3){ swap(state[x * 3 + y], state[xx * 3 + yy]); // 交换 if (!dist.count(state) || dist[state] > step + 1) { dist[state] = step + 1; prev[state] = {source, op[i]}; heap.push({dist[state] + f(state), state}); } swap(state[x * 3 + y], state[xx * 3 + yy]); // 恢复 } } } // 回推路径 string res; while (end != start) { res += prev[end].second; end = prev[end].first; } reverse(res.begin(), res.end()); return res; } int main() { string g, c, seq; while (cin >> c) { g += c; if (c != \\\"x\\\") seq += c; } // 记录逆序对的对数 // 如果逆序对的数量是偶数，那就一定有解 int cnt = 0; for (int i = 0; i < seq.size(); i++){ for (int j = i + 1; j < seq.size(); j++){ if (seq[i] > seq[j]) cnt++; } } if (cnt % 2) puts(\\\"unsolvable\\\"); else cout << bfs(g) << endl; return 0; }\"]},\"45\":{\"c\":[\"笔记\"]},\"46\":{\"c\":[\"图论\"]},\"47\":{\"h\":\"DFS之岛屿问题\",\"t\":[\"三种岛屿问题的 DFS 模板：1.岛屿数量，2.封闭岛屿的树木，3.岛屿的最大面积\",\"本文主要针对常见的岛屿问题，总结出相应的 DFS 模板，在面对具体题目时，只需要稍加修改即可。\"]},\"48\":{\"h\":\"岛屿数量\",\"t\":[\"输入一个二维数组，其中 0 代表海水，1 代表陆地，且每座岛屿只能由上下左右四个方向相连的陆地组成。为搜索方便，可定义方向数组来进行遍历，如下所示：\",\"int dx[4] = {1, 0, -1, 0}; //横轴x方向 int dy[4] = {0, 1, 0, -1}; //纵轴y方向\",\"通常来说，都是上下左右四个方向，但某些题目会描述为“四周环绕”或“水平、垂直、对角线上相邻”，那么就需要搜索八个方向。那么对应的方向数组也需要做出改变：\",\"int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1}; int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\",\"大多数 DFS 中会使用一个标记数组 vis[][]（初始化数组元素为 0 ，将走过的元素标记为 1 ）来记录搜索过的元素，但对于 “岛屿数量” 这种单纯的题型，一种更简洁的写法是将走过的陆地都给 “淹” 了，将其赋值为海水，避免维护 vis 数组，更省事。\",\"以 200.岛屿数量 为例，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> #define N 1010 //定义地图范围，为防止数组越界，通常比所给数据范围大一点 using namespace std; int n, m, cnt; //定义行、列、岛屿数量 char mp[N][N]; //题中所给数据大多都是字符，所以常常定义字符数组 void dfs(int x, int y){ if (x < 0 || y < 0 || x >= n || y >= m ){ //若超出地图边界，则返回 return; } if (mp[x][y] == '0'){ //若已经是海水了，则也返回 return; } //将搜索过的mp[x][y]淹了变成海水 mp[x][y] = '0'; //定义方向数组，用来遍历上下左右四个方向 int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; dfs(xx, yy); //递归 } } int main(){ cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } //初始化岛屿数量为0 cnt = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == '1'){ cnt++; dfs(i, j); } } } //最后输出岛屿的数量 cout << cnt << endl; return 0;\"]},\"49\":{\"h\":\"封闭岛屿数量\",\"t\":[\"与上题类似，同理输入一个二维数组，其中 0 代表海水，1 代表陆地，且每座岛屿只能由上下左右四个方向相连的陆地组成。\",\"所谓 “封闭岛屿” ，就是上下左右全部被海水包围，靠边的陆地不算作封闭岛屿，所以我们可以先将地图边界的陆地 “淹” 了，搜索并将其赋值为海水。\",\"以 1254.统计封闭岛屿的数目 为例，不同的是它是⽤ 0 表示陆地，⽤ 1 表示海⽔。这里我们仍然用 0 代表海水，1 代表陆地，完整 C++ 代码如下（重复的注释就不再赘述了）：\",\"#include <bits/stdc++.h> using namespace std; #define N 1010 int n, m, cnt; char mp[N][N]; void dfs(int x, int y){ if (x < 0 || y < 0 || x >= n || y >= m || mp[x][y] == '0'){ //越界，或已经是海水了则返回 return; } //从（i，j）开始，将与之相邻的陆地都变成海水 mp[x][y] = '0'; //定义方向数组，用来遍历上下左右四个方向 int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; dfs(xx, yy); //递归 } } int main(){ cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } for (int i = 0; i < n; i++){ dfs(i, 0); //把靠左边的岛屿淹掉 dfs(i, m - 1); //把靠右边的岛屿淹掉 } for (int j = 0; j < m; j++){ dfs(0, j); //把上边的岛屿淹掉 dfs(n - 1, j); //把下边的岛屿淹掉 } //初始化岛屿数量为0 cnt = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == '1'){ cnt++; //每找到一个数量加一 dfs(i, j); } } } //最后输出岛屿的数目 cout << cnt << endl; return 0; }\"]},\"50\":{\"h\":\"岛屿的最大面积\",\"t\":[\"这种题的⼤体思路和之前完全⼀样，只不过 DFS 函数淹没岛屿的同时，还应该想办法记录这个岛屿的⾯积。 以 695.岛屿的最大面积 为例，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> using namespace std; #define N 1010 int n, m; char mp[N][N]; //淹没与（i，j）相邻的陆地，并返回淹没的陆地面积 int dfs(int x, int y){ if (x < 0 || y < 0 || x >= n || y >= m || mp[x][y] == '0'){ //超出地图边界，或已经是海水了 return 0; } //每次都将面积加一 //sum++; //将（i，j）变为海水 mp[x][y] = '0'; return dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1) + 1; //记得加上它本身 } int main(){ cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } //记录岛屿的最大面积 int res = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == '1'){ //淹没岛屿，并更新最大岛屿面积 res = max(res, dfs(i, j)); } } } //最后输出岛屿的最大面积 cout << res << endl; return 0; }\"]},\"51\":{\"h\":\"小结\",\"t\":[\"以上就是本文的内容，三种常见的岛屿问题，当然还会有很多相关的岛屿变型题，但都是大同小异，大体的思路都是一样的，理解了本质就可以傻瓜式地套用模板。\"]},\"52\":{\"c\":[\"笔记\",\"图论\"]},\"53\":{\"c\":[\"DFS\"]},\"54\":{\"h\":\"DFS之迷宫问题\",\"t\":[\"DFS 之迷宫问题：1.能否逃出迷宫，2.逃出迷宫的最短路径，3.缺口迷宫\",\"本文仅使用 DFS 算法不断回溯来解决迷宫问题，不涉及利用 “栈” 、“队列” 等数据结构来解决问题。 针对于最普通的也是最常见的迷宫问题，总结出相应的模板，不过具体问题还得具体分析，理解之后方才能从容不迫，游刃有余。\"]},\"55\":{\"h\":\"能否逃出迷宫\",\"t\":[\"最朴素的迷宫问题，通常给定一个 n × m 的二维字符数组作为迷宫，其中 S 表示起点，# 表示墙，无法通过，. 表示可走的路，T 表示出口，每次只能向上下左右四个方向移动。能逃出迷宫输出 yes ，否则输出 no.\",\"逃出这种迷宫，有两个关键点：\",\"一是：在 DFS 函数中判断能否找到出口，用一个布尔变量记录下来，找到则为真，找不到为假\",\"二是：每次递归之后都要回溯，将标记数组重置为 0，如果没有重置，那等于说走过一次就不能走了，但实际上后面的搜索中可能还是要走这条路的。\",\"这种题对于已访问的元素，我们不能像 “岛屿问题” 一样简单的把它给 “淹” 了，需要考虑回溯的问题，所以需要使用标记数组 vis[][] ，将已访问标记为 1，递归后再回溯，重置标记数组即可。\",\"下面以 计蒜客-T1595 为例，判断能否逃出迷宫，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> //万能头文件 using namespace std; const int N = 110; //定义地图范围，范围开大一点防止数组越界 //#define N 1010 //用define定义的话后面不用加分号 int n, m, ans; //ans用来标记是否找到出口 char mp[N][N]; //迷宫地图数组 int vis[N][N]; //标记数组 void dfs(int x, int y){ if (mp[x][y] == 'T'){ //如果找到了出口，标记为1，再返回 ans = 1; return; } //定义方向数组 int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; //如果未越界，可走且未访问 if (xx >= 0 && yy >= 0 && xx < n && yy < m && (mp[xx][yy] == '.' || mp[xx][yy] == 'T') && !vis[xx][yy]){ vis[xx][yy] = 1; //标记为已访问 dfs(xx, yy); //递归继续搜索 vis[xx][yy] = 0; //递归搜索完成后回退，将已访问状态重置为未访问 } } } int main(){ //初始化输入数据 cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; } } //标记默认为0 ans = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (mp[i][j] == 'S'){ //找到了起点，开始搜索 dfs(i, j); } } } //若ans为1，则为真，输出yes；若为0，则为假，输出no if (ans) cout << \\\"yes\\\" << endl; else cout << \\\"no\\\" << endl; return 0; }\"]},\"56\":{\"h\":\"逃出迷宫的最短路径\",\"t\":[\"与上题一样，唯一不同的是需要计算出每次逃出迷宫的路径，再进行比较得出最短路径。若无法逃出，则输出 -1.\",\"以 计蒜客-T1596 为例，题中 * 为墙，. 为路，完整 C++ 代码如下：\",\"#include <bits/stdc++.h> using namespace std; const int N = 110; int n, m; int sx, sy; //定义起点坐标 int tx, ty; //定义终点坐标 char mp[N][N]; //迷宫数组 int vis[N][N]; //标记数组 int minx; //记录最短路径 void dfs(int x, int y, int step){ //减枝，用来将之后多余的步数去掉 if (step >= minx) return; //找到了终点，比较路径是否最短 if (x == tx && y == ty){ if (step < minx){ minx = step; } return; } int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; //若可走且未访问 if (xx >= 0 && yy >= 0 && xx < n && yy < m && (mp[xx][yy] == '.' || mp[xx][yy] == 'T') && vis[xx][yy] == 0){ vis[xx][yy] = 1; //标记为已访问 dfs(xx, yy, step + 1); vis[xx][yy] = 0; //递归搜索完成后回退，重置为未访问 } } } int main(){ minx = 9999; //保证初始值足够大 cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; vis[i][j] = 0; //找到入口 if (mp[i][j] == 'S'){ sx = i; sy = j; } //找到出口 if (mp[i][j] == 'T'){ tx = i; ty = j; } } } //标记入口已走过 vis[sx][sy] = 1; //开始搜索，初始步数为0 dfs(sx, sy, 0); //输出结果 if (minx == 9999) cout << \\\"-1\\\" << endl; else cout << minx << endl; return 0;\"]},\"57\":{\"h\":\"缺口迷宫\",\"t\":[\"所谓缺口迷宫，是指迷宫的出口在地图的边界，出口处不一定有像 T这样的出口符号，而是只有像 . 这样的路。\",\"有些题只需要判断能不能逃出迷宫，有些题则在判断的同时需要计算出最短路径。\",\"这里我们计算下最短路径，与第二种迷宫差不多，只需要将 DFS 函数中迷宫出口的判断条件稍加修改即可。\",\"即将 return 条件由 mp[x][y] == 'T' 改为 mp[x][y] == '.' && (x == 0 || y == 0 || x == n - 1 || y == m - 1).\",\"以 计蒜客-T1597 为例，题中 @ 为起点，# 为墙，. 为路，若无法逃出，则输出 −1，完整的 C++ 代码如下：\",\"#include <bits/stdc++.h> using namespace std; const int N = 110; int sx, sy; //定义起点坐标 int n, m, minx; //定义行、列、最短路径 char mp[N][N]; //迷宫数组 int vis[N][N]; //标记数组 void dfs(int x, int y, int step){ //找到了位于边界上的出口，比较路径是否最短 if (mp[x][y] == '.' && (x == 0 || y == 0 || x == n - 1 || y == m - 1)){ if (step < minx){ minx = step; } return; } int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; for (int i = 0; i < 4; i++){ int xx = x + dx[i], yy = y + dy[i]; //若可走且未访问 if (xx >= 0 && yy >= 0 && xx < n && yy < m && mp[xx][yy] == '.' && vis[xx][yy] == 0){ vis[xx][yy] = 1; //标记为已访问 dfs(xx, yy, step + 1); vis[xx][yy] = 0; //递归搜索完成后回退，重置为未访问 } } } int main(){ //初始化 minx = 99999999;//保证初始值足够大 cin >> n >> m; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ cin >> mp[i][j]; //找到入口 if (mp[i][j] == '@'){ sx = i; sy = j; } } } //标记入口已走过 vis[sx][sy] = 1; //开始搜索，初始步数为0 dfs(sx, sy, 0); //输出结果 if (minx == 99999999) cout << \\\"-1\\\" << endl; else cout << minx << endl; return 0; }\"]},\"58\":{\"h\":\"小结\",\"t\":[\"当然，像这种迷宫问题，有很多种解法，这里展示的只是我个人总结下来的一些使用 DFS 递归解题的模板，多多少少也会有点不足。\"]},\"59\":{\"c\":[\"笔记\",\"图论\"]},\"60\":{\"c\":[\"DFS\"]},\"61\":{\"h\":\"一些经验和技巧\"},\"62\":{\"h\":\"1. vector 维护一个动态数组\",\"t\":[\"定义时初始化(一般 +1 防止数组越界) vector<int> a(n + 1, 0); 定义一个二维动态数组 vector<vector<int>> g(n + 1, vector<int>(n + 1));\"]},\"63\":{\"h\":\"2. 字符串\",\"t\":[\"size() 和 length()：这两个函数会返回 string 类型对象中的字符个数，且它们的执行效果相同\",\"strlen() ：是C语言标准库中的函数\",\"// 返回 string 长度，单位字节 size_t length() const noexcept; // 返回 string 长度，单位字节。作用等同于 length() size_t size() const noexcept; // C 标准库函数，返回C风格字符串长度，单位字节 size_t strlen ( const char * str );\",\"（1）当 string 中含有空字符’\\\\0’，使用 strlen() 获取 string 的长度时会被截断，使用成员函数 length() 和 size() 可以返回 string 的真实长度。\",\"（2）cout 对 string 输出时，会过滤掉空字符，输出不会被截断。\",\"（3）在构造或者拼接 string 时，建议同时指定 string 的长度，比如：\",\"如果字符串长度很大（例如超过 1e9）的时候，要使用 s.length() 获取字符串长度，使用 s.size() 会爆掉\",\"max_size()：返回 string 类型对象最多包含的字符数。一旦程序使用长度超过 max_size() 的 string 操作，编译器会拋出 length_error 异常。\",\"resize() ： 修改字符串的长度\",\"str.resize(5); // 长度修改为5\",\"capacity() ：该函数返回在重新分配内存之前，string 类型对象所能包含的最大字符数。\",\"使用 printf() 输出 string 类型\",\"① printf 函数输出字符串是针对 char * 的，即 printf 只能输出c语言的内置数据类型，而 string 不是c语言的内置数据类型。\",\"② string 类型的对象不止包含字符串，还包含了许多用于操作的函数，所以 &str 并非字符串的首地址。\",\"③ 如需输出string对象中的字符串，可以使用 string 的成员函数c_str()，该函数返回字符串的首字符的地址。\",\"string s = \\\"hello\\\"; printf(\\\"%s\\\", s.c_str()); //输出：hello\"]},\"64\":{\"h\":\"3. 在一个数组中查找最长的相同连续子序列\",\"t\":[\"// 在由 0、1 组成的字符串中查找最长的‘1’ for (int i = 0; i < n; i++) { if (s[i] == '1') len++; if (s[i] == '0'){ res = max(res, len); len = 0; } }\"]},\"65\":{\"h\":\"4. 秦九韶算法\",\"t\":[\"int res = 0; for (int i = 1; i <= n; i++) res = res * b + a[i]; //b代表进制位数\",\"将一个 i 进制的数转化为十进制\",\"int get(string s, int i) { int res = 0; for (auto c : s) res = res * i + c - '0'; return res; }\"]},\"66\":{\"h\":\"5. 开栈空间代码\",\"t\":[\"备份，以防爆栈风险\",\"int main() { int size(512<<20); // 512M __asm__ ( \\\"movq %0, %%rsp\\\\n\\\"::\\\"r\\\"((char*)malloc(size)+size)); // YOUR CODE ... exit(0); return 0; }\"]},\"67\":{\"h\":\"6. 求 a 除以 b 的正余数\",\"t\":[\"int get_mod(int a, int mod) { return (a % mod + mod) % mod; }\"]},\"68\":{\"h\":\"7. 裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\"]},\"69\":{\"h\":\"8. 交互题\",\"t\":[\"若要提问，请打印 “ ？+ 问题 ” ，然后从标准输入中输入响应\",\"如果你的程序问了一个无效的问题，或者问题用完了，交互器将立即终止，你的程序将得到一个判断错误的答案。\",\"要给出最终答案，请打印 “ ! + 答案 ”\",\"问完一个问题后，要输出行的末尾并刷新输出，否则将会得到超过限制限制的结果。\",\"C中的 fflush(stdout) 或者C++中的 cout.flush()； Java中的 System.out.flush()； Pascal中的 flush(output)； Python中的 stdout.flush().\"]},\"70\":{\"h\":\"9. mex函数\",\"t\":[\"auto mex = [](vector<int> w) { sort(w.begin(), w.end()); int mx = 0; for (int x : w) if (x == mx) ++mx; return mx; }; int z = mex(v);\"]},\"71\":{\"h\":\"10. string 与 int 之间的转化\",\"t\":[\"（1）int 转 string\",\"通过 to_string() 函数转换\",\"int num = 123; string s = to_string(num); cout << s << endl; // s = \\\"123\\\"\",\"通过 sprintf 转换\",\"int num = 123; char str[256]; sprintf(str, \\\"%d\\\", num); printf(\\\"%s\\\", str);\",\"这是一种C语言中的转换方式，sprintf 也可以换成更安全的 snprintf 函数\",\"（2）string 转 int\",\"通过 sscnaf 转换\",\"string str = \\\"123\\\"; int num = 0; sscanf(str.c_str(), \\\"%d\\\", &num); cout << num << endl; // num = 123\",\"sscanf 函数的第一个参数类型是 const char *，string类型的参数需要转换一下\",\"使用 atoi 转换\",\"string str = \\\"123\\\"; cout << atoi(str.c_str()); // 123\",\"atoi 函数的头文件是 stdlib.h\"]},\"72\":{\"h\":\"11. string::npos\",\"t\":[\"string::npos是一个静态成员常量，表示size_t的最大值（Maximum value for size_t）。该值表示“直到字符串结尾”**，**作为返回值它通常被用作表明没有匹配。\",\"string::npos是这样定义的：\",\"static const size_type npos = -1;\",\"常用于配合 find() 函数使用，该函数有唯一的返回类型，即 string::size_type , 即一个无符号整型类型，可能是整数，也可能是长整数。\",\"如果查找成功，返回按照查找规则找到的第一个字符或者子串的位置；\",\"如果查找失败，返回 string::npos , 即 -1\"]},\"73\":{\"h\":\"12. x >> i & 1\",\"t\":[\"x >> i & 1 用来判断 x 的二进制表示下的每一位是不是 1 .\"]},\"74\":{\"h\":\"13. assign()\",\"t\":[\"C++ 函数 std::vector::assign() 通过替换旧值为向量元素分配新值。 如有必要，它会修改矢量的大小。\",\"assign(n, val) 有两个参数，n — 容器大小，val — 重新赋给每个元素的值；\",\"assign(first, last) 区间，左闭右开\",\"功能：\",\"①将区间 [first,last) 的元素赋值到当前的 vector 容器中；\",\"②赋 n 个值为 x 的元素到 vector 容器中，会覆盖掉 vector 容器中以前的内容。\",\"1.第一种用法 vector<int> v1, v2; v2.assign(v1,begin(), v1.end()); 2.第二种用法 vector<int> a(n + 1); vector<vector<int>> g(n + 1); 一维：a.assign(n + 1, 0); 二维：g.assign(n + 1, vector<int>());\"]},\"75\":{\"h\":\"14. lambda表达式\",\"t\":[\"lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：\",\"[ capture ] ( params ) opt -> ret { body; };\",\"其中\",\"capture 是捕获列表，空表示不捕获任何变量；\",\"& 表示捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）；\",\"= 表示捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）；\",\"=，&foo 表示按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。\",\"bar 按值捕获 bar 变量，同时不捕获其他变量；\",\"this 表示捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。\",\"params 是参数表， opt 是函数选项， ret 是返回值类型， body是函数体\",\"写法示例：\",\"// 计算两个数的和 auto plus = [] (int v1, int v2) -> int { return v1 + v2; } int sum = plus(1, 2);\",\"递归 Lambda 表达式：\",\"//d vector<int> cnt(n); auto dfs = [&](auto self, int u, int p) -> void { for (auto v : adj[u]) { if (v != p) { self(self, v, u); cnt[u] += cnt[v]; } } if (cnt[u] == 0) { cnt[u] = 1; } }; dfs(dfs, 0, -1); //树的根节点从0开始，初始化为-1\"]},\"76\":{\"h\":\"15. max_element() 与 min_element()\",\"t\":[\"max_element() 与min_element() 分别用来求最大元素和最小元素的位置。\",\"接收参数：容器的首尾地址（迭代器）（可以是一个区间）\",\"返回：最值元素的地址（迭代器），需要减去序列头以转换为下标\",\"vector<int> v; int maxPos = max_element(v.begin(), v.end()) - v.begin(); //最大值下标 int minPos = min_element(v.begin(), v.end()) - v.begin();//最小值下标 2）普通数组 int a[] = {1,2,3,4}; int maxPos = max_element(a, a + 2) - a; //最大值下标 int minPos = min_element(a, a + 2) - a;//最小值下标\",\"max_element() 与 min_element() 分别用来求最大元素和最小元素的值。\",\"接收参数：容器的首尾地址（迭代器）（可以是一个区间）\",\"返回：最值元素的值\",\"int maxValue = *max_element(v.begin(), v.end()); //最大值 int minValue = *min_element(v.begin(), v.end()); //最小值 int maxValue = *max_element(a, a + 2); //最大值 int minValue = *min_element(a, a + 2); //最小值\"]},\"77\":{\"h\":\"16. tuple\",\"t\":[\"tuple 是泛化的 std::pair，我们通常是把它当作一个结构体使用，比如我们可以将多个参数整合为一个结构体传递到函数内部，实现一些简洁的操作。\",\"创建\",\"tuple<int,float,int,float> tu = make_tuple(1,2.f,3,4.f);//创建方式一 tuple<int,float,int,float> tu(1,2.f,3,4.f);//创建方式二 //相当于结构体： struct tu { int a; float b; int c; float d; }\",\"同 pair<first, second> 一样\"]},\"78\":{\"c\":[\"笔记\"]},\"79\":{\"c\":[\"经验\"]},\"80\":{\"h\":\"前缀和相关题型\"},\"81\":{\"h\":\"\",\"t\":[\"题目描述\",\"给定一个长度为 N 的数列，A1​,A2​,…AN​，如果其中一段连续的子序列 Ai​,Ai+1​,…Aj​ 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？\",\"输入格式\",\"第一行包含两个整数 N 和 K。 以下 N 行每行包含一个整数 Ai​。\",\"输出格式\",\"输出一个整数，代表 K 倍区间的数目。\",\"数据范围\",\"1⩽N,K⩽1000001⩽Ai​⩽100000\",\"输入样例：\",\"5 2 1 2 3 4 5\",\"输出样例：\",\"6\",\"思路\",\"翻译：求区间 [l,r] 的和是 k 的倍数的个数。\",\"求区间和，我们可以通过 前缀和 来求出。 定义 sum[i] 表示第 1 个元素到第 i 个元素的和，那么 s[r] - s[l-1] 就是区间 [l,r] 的和。 若满足条件：区间 [l,r] 的和是k的倍数，即 (s[r] - s[l-1]) % k == 0 ，等价于 s[r] % k == s[l-1] % k 。\",\"说人话，这也就意味着：\",\"如果 s[r] mod k 和 s[l - 1] mod k 的余数相等，那么 s[r] - s[l - 1] 的差值必然是 k 的倍数。\",\"比如：13 % 7 == 20 % 7，则 (20 - 7) % 7 == 0\",\"那么题目就是要我们求 前缀和%k==0 的组合有多少种。\",\"用 cnt[i] 存储目前为止前缀和相同的个数，i 表示这个前缀和的值。 每次用 res 来递加 cnt[i] 相同的个数，前面有几个 前缀和的值 和 当前前缀和 相等，那么这个前缀和就能和前面每一个组成一个组合，所以要 res += cnt[s[i]] ，然后再加上现在的前缀和，即 cnt[s[i]]++ 。 初始化 cnt[0] = 1 ，因为当 s[i] == 0 时，这个前缀和本身就是 k 的倍数，不需要再跟别的前缀和组合，计算结果时就要加上这一个。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 1e5 + 10; int n, k; ll s[N]; ll cnt[N]; int main() { cin >> n >> k; ll res = 0; cnt[0] = 1; for (int i = 1; i <= n; i++){ cin >> s[i]; s[i] = (s[i] + s[i - 1]) % k; // 每次前缀和都取模 res += cnt[s[i]]; // 和前面每一个都组合一下 cnt[s[i]]++; // 现在又多了一个 } cout << res << endl; return 0; }\"]},\"82\":{\"h\":\"\",\"t\":[\"题目描述\",\"给定一个长度为 n 的数组 a1​,a2​,…,an​ 。 现在，要将该数组从中间截断，得到三个非空子数组。 要求，三个子数组内各元素之和都相等。 请问，共有多少种不同的截断方法？\",\"输入格式\",\"第一行包含整数 n。 第二行包含 n 个整数 a1​,a2​,…,an​ 。\",\"输出格式\",\"输出一个整数，表示截断方法数量。\",\"数据范围\",\"前六个测试点满足 1⩽n⩽10。\",\"所有测试点满足 1⩽n⩽105,−10000⩽ai​⩽10000。\",\"输入样例1：\",\"4 1 2 3 3\",\"输出样例1：\",\"1\",\"输入样例2：\",\"5 1 2 3 4 5\",\"输出样例2：\",\"0\",\"输入样例3：\",\"2 0 0\",\"输出样例3：\",\"0\",\"思路\",\"先预处理前缀和，先判断如果 s[n] % 3 != 0，则不能被均分为三份，输出 0.\",\"然后从 i = 3 开始枚举前缀和数组，以 i 作为切割点，s[i - 2] 为第一段，s[n] - s[i - 1] 为第三段，如果 第一段 = 第三段 = 3s[n]​​，则第二段也一定相等，都符合条件。\",\"先判断第一段是否符合，记录个数，如果第三段不符合，则表示该切割点不行，继续后移，每次当第三段符合时，都加上第一段符合的个数即可。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 1e5 + 10; int n; ll s[N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> s[i]; s[i] += s[i - 1]; } if (s[n] % 3){ cout << 0 << endl; return 0; } ll cnt = 0, res = 0; for (int i = 3; i <= n; i++){ if (s[i - 2] == s[n] / 3) cnt++; if (s[n] - s[i - 1] == s[n] / 3) res += cnt; } cout << res << endl; return 0; }\"]},\"83\":{\"h\":\"\",\"t\":[\"题目描述\",\"地图上有 N 个目标，用整数 Xi​,Yi​ 表示目标在地图上的位置，每个目标都有一个价值 Wi​ 。\",\"注意：不同目标可能在同一位置。\",\"现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x,y 轴平行。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。\",\"输入格式\",\"第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。 接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi​,Yi​,Wi​ ，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。\",\"输出格式\",\"输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。\",\"数据范围\",\"0⩽R⩽1090<N⩽100000⩽Xi​,Yi​⩽50000⩽Wi​⩽1000\",\"输入样例：\",\"2 1 0 0 1 1 1 1\",\"输出样例：\",\"1\",\"思路\",\"递推求出二维前缀和 。\",\"因为题目的内存限制，我们直接用二维数组读入数据，边读边加。 然后我们再求其前缀和，再从地图右下角枚举边长为 R​ 的正方形，通过下式\",\"s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]\",\"即可计算出该正方形内所有目标的价值之和。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #define ll long long using namespace std; const int N = 5e3 + 10; // 不能开到 1e5 + 10，二维会爆栈 int n, r; int s[N][N]; int main() { cin >> n >> r; r = min(5001, r); // 因为r最大可取到10^9,但地图没有这么大 for (int i = 1; i <= n; i++){ int x, y, w; cin >> x >> y >> w; s[++x][++y] += w; // 因为数据范围是从0开始的 } //如果i从0开始那么i-1会导致数组越界 for (int i = 1; i <= 5001; i++){ for (int j = 1; j <= 5001; j++){ s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; } } int res = 0; for (int i = r; i <= 5001; i++){ for (int j = r; j <= 5001; j++){ res = max(res, s[i][j] - s[i - r][j] - s[i][j - r] + s[i - r][j - r]); } } cout << res << endl; return 0; }\"]},\"84\":{\"c\":[\"笔记\"]},\"85\":{\"c\":[\"前缀和\"]},\"86\":{\"h\":\"并查集\"},\"87\":{\"h\":\"简介\",\"t\":[\"1.并查集是一种非常精巧实用的数据结构，它主要用于处理一些不相交集合的合并问题。一些常见的用途有求连通子图，求最小生成树的 Kruskal 算法和求最近公共祖先（LCA）等。\",\"2.基本操作主要有：\",\"（1）初始化 init\",\"（2）查询 find\",\"（3）合并 union\"]},\"88\":{\"h\":\"基本模板\"},\"89\":{\"h\":\"1.初始化\",\"t\":[\"int fa[N]; void init(int n){ for (int i = 1; i <= n; i++) fa[i] = i; // 一开始都是独立的，父节点设置为自己 }\",\"假如有编号为 1，2，3，...，n 的 n 个元素，我们用一个数组 fa[N] 来存储每个元素的父节点。一开始，我们先将它们的父节点设为自己。\"]},\"90\":{\"h\":\"2.查询（已路径压缩）\",\"t\":[\"查询一定要进行路径压缩，不然大概率会超时。\",\"int find(int x){ //递归出口，当达到了祖先位置，就返回祖先 if (fa[x] == x) return x; else { //不断往上查找祖先，并进行路径压缩，一直找到祖先的祖先 fa[x] = find(fa[x]); return fa[x]; //返回父亲节点 } }\",\"也可以简写成这样：\",\"int fond(int x){ return fa[x] == x ? x : find(fa[x]); }\"]},\"91\":{\"h\":\"3.合并\",\"t\":[\"最简单的合并就是像下面这样，粗暴的把 i 所在树的根节点接到 j 所在树的根节点下面，但是有可能出现 “头重脚轻” 的不平衡状况，后面例二中将会给出解决方法。\",\"void union(int i, int j){ int x = find(i); // 找到i的根节点 int y = find(j); // 找到j的根节点 fa[x] = y; // i的根节点指向j的根节点 }\"]},\"92\":{\"h\":\"典例分析\"},\"93\":{\"h\":\"例一：亲戚关系\",\"t\":[\"现在有若干家族图谱关系，给出了一些亲戚关系，如 A 和 B 是亲戚，B 和 C 是亲戚，那么 A和 B 也是亲戚。请写一个程序，对于我们的关于亲戚关系的提问，以最快的速度给出答案。\",\"【输入格式】\",\"第一部分是以 N，M 开始。N 为人数（1⩽N⩽20000），这些人的编号为 1，2，3，...，N。 下面有 M行（1⩽M⩽1000000），每行有两个数 a，b，表示 a 和 b 是亲戚。\",\"第二部分是以 Q 开始。以下 Q 行有 Q 行询问（1⩽Q⩽1000000），每行为 c, d, 表示询问 c 和 d 是否为亲戚。\",\"【输出格式】\",\"对于询问 c, d, 输出一行：若 c, d 为亲戚，则输出 “YES” ，否则输出 “NO”。\",\"【输入样例】\",\"10 7 2 4 5 7 1 3 8 9 1 2 5 6 2 3 3 3 4 7 10 8 9\",\"【输出样例】\",\"YES NO YES\",\"【示例代码】\",\"#include <iostream> #include <cstdio> #include <cstdlib> using namespace std; const int N = 20005; int fa[N]; // 父亲数组 // 初始化父亲为它自己 void init (int n){ for (int i = 1; i <= n; i++) fa[i] = i; } // 查找根节点 int find(int x){ if (fa[x] == x) return x; else { // 压缩路径，不断向上寻找最初的根节点 fa[x] = find(fa[x]); return fa[x]; } } // 合并，子节点依附在根节点上 void union(int i, int j){ int x= find(i); int y = find(j); fa[x] = y; } int main(){ int n, m, x, y, q; cin >> n >> m; init(n); for (int i = 1; i <= m; i++){ cin >> x >> y; union(x, y); // 构建依附关系 } scanf(\\\"%d\\\", &q); for (int i = 1; i <= q; i++){ cin >> x >> y; // 询问是否存在依附关系 if (find(x) == find(y)) put(\\\"YES\\\"); else put(\\\"NO\\\"); } return 0; }\"]},\"94\":{\"h\":\"例二：洛谷 P3367 【模板】并查集\",\"t\":[\"find 的主要功能就是从某个节点向上遍历到根节点，其时间复杂度就是树的高度，我们可能习惯性地认为树的高度就是 logN ， 但是不一定。logN 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得 “树” 几乎退化成 “链表'，树的高度最坏情况下可能变成 N。\",\"问题的关键在于，该如何想办法避免树的不平衡呢？\",\"其实关键在于 union 过程。\",\"我们其实是希望，高度小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些。\",\"解决方法是额外使用一个 size 数组，记录每棵树包含的节点数，不妨称为 高度。\",\"如下所示：\",\"void union(int i, int j){ int x = find(i), y = find(j); if (x == y) return; // 小树接在大树下面，较平衡 if (size[x] >= size[y]){ fa[y] = x; size[x] += size[y]; } else { fa[x] = y; size[y] += size[x]; } return; }\",\"下面看题中完整的写法（题是比较简单的一道模板题，用这种写法不过是略微优化了一下）:\",\"【题目描述】\",\"如题，现在有一个并查集，你需要完成合并和查询操作。\",\"【输入格式】\",\"第一行包含两个整数 N, M, 表示共有 N 个元素和 M 个操作。 接下来 M 行，每行包含三个整数 Zi​,Xi​,Yi​。 当 Zi​=1 时，将 Xi​ 与 Yi​ 所在的集合合并。 当 Zi​=2 时，输出 Xi​ 与 Yi​ 是否在同一集合内，是的输出 Y；否则输出 N。\",\"【输出格式】\",\"对于每一个 Zi​=2 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。\",\"【输入样例】\",\"4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4\",\"【输出样例】\",\"N Y N Y\",\"【示例代码】\",\"#include <iostream> #include <cstdio> using namespace std; const int N = 2e5+5; // 父亲数组，高度数组 int fa[N], size[N]; // 初始化 int init(int n) { for (int i = 1; i <= n; i++){ fa[i] = i; // 初始根节点为它自己 size[i] = 1; // 初始高度为1 } } // 查找父节点 int find(int x) { if (fa[x] == x) return x; else fa[x] = find(fa[x]); // 扁平化处理，压缩路径 return fa[x]; } // 合并 void union(int i, int j) { int x = find(i), y = find(j); if (x == y) return; // 比较高度，高度小的接在高的下面，节省查找时间 if (size[x] >= size[y]){ fa[y] = x; size[x] += size[y]; } else { fa[x] = y; size[y] += size[x]; } } int main() { int n, m, z, x, y; cin >> n >> m; init(n);//初始化 for (int i = 1; i <= m; i++){ cin >> z >> x >> y; if (z == 1) union(x, y); if (z == 2){ if (find(x) == find(y)) cout << \\\"Y\\\" << endl; else cout << \\\"N\\\" << endl; } } return 0; }\"]},\"95\":{\"c\":[\"笔记\",\"数据结构\"]},\"96\":{\"c\":[\"并查集\"]},\"97\":{\"h\":\"搜索\"},\"98\":{\"h\":\"（BFS）\",\"t\":[\"题目描述\",\"给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1 ，其中 0 表示可以走的路，1 表示不可通过的墙壁。 最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。 数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。\",\"输入格式\",\"第一行包含两个整数 n 和 m。 接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。\",\"输出格式\",\"输出一个整数，表示从左上角移动至右下角的最少移动次数。\",\"数据范围\",\"1⩽n,m⩽100\",\"输入样例：\",\"5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0\",\"输出样例：\",\"8\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #define PII pair<int, int> using namespace std; const int N = 110; int n, m; int g[N][N]; int d[N][N]; int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; int bfs() { memset(d, -1, sizeof d); queue<PII> q; q.push({1, 1}); d[1][1] = 0; while (q.size()) { auto t = q.front(); q.pop(); for (int i = 0; i < 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x >= 1 && x <= n && y >= 1 && y <= m && g[x][y] == 0 && d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x, y}); } } } return d[n][m]; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; cout << bfs() << endl; return 0; }\"]},\"99\":{\"h\":\"（BFS）\",\"t\":[\"题目描述\",\"在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3 的网格中。\",\"例如：\",\"1 2 3 x 4 6 7 5 8\",\"在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。\",\"我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：\",\"1 2 3 4 5 6 7 8 x\",\"例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。\",\"交换过程如下：\",\"1 2 3 1 2 3 1 2 3 1 2 3 x 4 6 4 x 6 4 5 6 4 5 6 7 5 8 7 5 8 7 x 8 7 8 x\",\"现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。\",\"输入格式\",\"输入占一行，将 3×3 的初始网格描绘出来。\",\"例如，如果初始网格如下所示：\",\"1 2 3 x 4 6 7 5 8\",\"则输入为：1 2 3 x 4 6 7 5 8\",\"输出格式\",\"输出占一行，包含一个整数，表示最少交换次数。\",\"如果不存在解决方案，则输出 −1。\",\"输入样例：\",\"2 3 4 1 5 x 7 6 8\",\"输出样例\",\"19\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> #include <queue> #include <unordered_map> using namespace std; int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; int bfs(string a) { string b = \\\"12345678x\\\"; queue<string> q; // 存储变换后的字符串 unordered_map<string, int> d; // 表示变换到某个字符串时需要的交换次数 q.push(a); d[a] = 0; while (!q.empty()) { auto t = q.front(); q.pop(); int dist = d[t]; // 判断是否变成了目标串 if (t == b) return dist; // 状态转移，变换串 int k = t.find('x'); // 'x'在字符串中的位置 int x = k / 3, y = k % 3; // 'x'在网格中的位置 for (int i = 0; i < 4; i++) { int xx = x + dx[i], yy = y + dy[i]; if (xx >= 0 && xx < 3 && yy >= 0 && yy < 3) { swap(t[k], t[xx * 3 + yy]); // 交换位置 if (!d.count(t)) { d[t] = dist + 1; q.push(t); } swap(t[k], t[xx * 3 + yy]); // 还原，恢复现场 } } } // 找不到解决方案则输出-1 return -1; } int main() { string a; // 将a串变为b串 for (int i = 0; i < 9; i++) { char c; cin >> c; a += c; } cout << bfs(a) << endl; return 0; }\"]},\"100\":{\"h\":\"\",\"t\":[\"题目描述\",\"你有一张某海域 N×N 像素的照片，\\\".\\\" 表示海洋、\\\"#\\\" 表示陆地，如下所示：\",\"....... .##.... .##.... ....##. ..####. ...###. .......\",\"其中 “上下左右” 四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2 座岛屿。 由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。 具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。 例如上图中的海域未来会变成如下样子：\",\"....... ....... ....... ....... ....#.. ....... .......\",\"请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。\",\"输入格式\",\"第一行包含一个整数 N。 以下 N 行 N 列，包含一个由字符 \\\"#\\\" 和 \\\".\\\" 构成的 N×N 字符矩阵，代表一张海域照片，\\\"#\\\" 表示陆地，\\\".\\\" 表示海洋。 照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。\",\"输出格式\",\"一个整数表示答案。\",\"数据范围\",\"1⩽N⩽1000\",\"输入样例1：\",\"7 ....... .##.... .##.... ....##. ..####. ...###. .......\",\"输出样例1：\",\"1\",\"输入样例2：\",\"9 ......... .##.##... .#####... .##.##... ......... .##.#.... .#.###... .#..#.... .........\",\"输出样例2：\",\"1\",\"思路\",\"代码\"]},\"101\":{\"h\":\"（DFS）\",\"t\":[\"题目描述\",\"给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。\",\"现在，请你按照字典序将所有的排列方法输出。\",\"输入格式\",\"共一行，包含一个整数 n。\",\"输出格式\",\"按字典序输出所有排列方案，每个方案占一行。\",\"数据范围\",\"1⩽n⩽7\",\"输入样例：\",\"3\",\"输出样例：\",\"1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 10; int n; int path[N]; bool st[N]; void dfs(int u) { if (u == n){ for (int i = 0; i < n; i++){ printf(\\\"%d \\\", path[i]); } puts(\\\"\\\"); return; } for (int i = 1; i <= n; i++){ if (!st[i]) { path[u] = i; st[i] = true; dfs(u + 1); st[i] = false; } } } int main() { cin >> n; dfs(0); return 0; }\"]},\"102\":{\"h\":\"4.\"},\"103\":{\"h\":\"5.\"},\"104\":{\"c\":[\"笔记\"]},\"105\":{\"c\":[\"BFS\",\"DFS\"]},\"106\":{\"h\":\"递归相关题型\"},\"107\":{\"h\":\"\",\"t\":[\"题目描述\",\"从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。\",\"输入格式\",\"输入一个整数 n。\",\"输出格式\",\"每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。\",\"数据范围\",\"1⩽n⩽15\",\"输入样例：\",\"3\",\"输出样例：\",\"3 2 2 3 1 1 3 1 2 1 2 3\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n; int st[N]; // 0表示还没考虑，1表示已选，2表示未选 void dfs(int u) { if (u == n) { for (int i = 0; i < n; i++) if (st[i] == 1) cout << i + 1 << ' '; cout << endl; return; } st[u] = 2; dfs(u + 1); st[u] = 0; st[u] = 1; dfs(u + 1); st[u] = 0; } int main() { cin >> n; dfs(0); return 0; }\"]},\"108\":{\"h\":\"\",\"t\":[\"题目描述\",\"把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。\",\"输入格式\",\"一个整数 n。\",\"输出格式\",\"按照从小到大的顺序输出所有方案，每行 1 个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。\",\"数据范围\",\"1⩽n⩽9\",\"输入样例：\",\"3\",\"输出样例：\",\"1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 10; int n; int st[N]; // 0表示还没放数，1~n表示放的哪些数 bool vis[N]; // 标记是否使用过 void dfs(int u) { if (u > n) { for (int i = 1; i <= n; i++) // 输出方案 cout << st[i] << ' '; puts(\\\"\\\"); return; } // 依次枚举每个分支，即当前位置能填哪些数 for (int i = 1; i <= n; i++){ if (!vis[i]){ st[u] = i; vis[i] = true; dfs(u + 1); // 恢复现场 st[u] = 0; vis[i] = false; } } } int main() { cin >> n; dfs(1); return 0; }\"]},\"109\":{\"h\":\"\",\"t\":[\"题目描述\",\"从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。\",\"输入格式\",\"两个整数 n,m，在同一行用空格隔开。\",\"输出格式\",\"按照从小到大的顺序输出所有方案，每行 1 个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。\",\"数据范围\",\"n>0 , 0⩽m⩽n , n+(n−m)⩽25\",\"输入样例：\",\"5 3\",\"输出样例：\",\"1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 30; int n, m; int way[N]; void dfs(int u, int start) // u表示第几位，i表示从哪个数开始 { if (u + n - start < m) return; // 剪枝，若剩下可选的数字不能填满剩下的空位则回退 if (u > m) { for (int i = 1; i <= m; i++) cout << way[i] << ' '; puts(\\\"\\\"); return; } for (int i = start; i <= n; i++) // 从start开始枚举剩下的可选数字 { way[u] = i; dfs(u + 1, i + 1); way[u] = 0; // 恢复现场 } } int main() { cin >> n >> m; dfs(1, 1); return 0; }\"]},\"110\":{\"h\":\"\",\"t\":[\"题目描述\",\"翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。 经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕>_<）。 翰翰和达达只好花钱让它们坐索道下山。 索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1​、C2​……CN​。 当然，每辆缆车上的小猫的重量之和不能超过 W。 每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？\",\"输入格式\",\"第 1 行：包含两个用空格隔开的整数，N 和 W。 第 2∼N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci​。\",\"输出格式\",\"输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。\",\"数据范围\",\"1⩽N⩽18 , 1⩽Ci​⩽W⩽108\",\"输入样例：\",\"5 1996 1 2 1994 12 29\",\"输出样例：\",\"2\",\"思路\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n, m; int c[N]; // 每只猫的重量 int s[N]; // 每辆车所搭载的重量 int res = N; // 初始最坏情况下一只猫一辆车 void dfs(int u, int k) // u只猫，k辆车 { if (k >= res) return; if (u == n){ res = k; return; } for (int i = 0; i < k; i++) // 对每辆车进行枚举 { if (s[i] + c[u] <= m) // 若不超过最大载重 { s[i] += c[u]; dfs(u + 1, k); s[i] -= c[u]; } } // 否则需要再加一辆车 s[k] = c[u]; dfs(u + 1, k + 1); s[k] = 0; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> c[i]; sort(c, c + n, greater()); dfs(0, 0); // 0只猫，0辆车 cout << res << endl; return 0; }\"]},\"111\":{\"h\":\"\",\"t\":[\"题目描述\",\"100 可以表示为带分数的形式：100=3+71469258​\",\"还可以表示为：100=82+1973546​\",\"注意特征：带分数中，数字 1∼9 分别出现且只出现一次（不包含 0）。\",\"类似这样的带分数，100 有 11 种表示法。\",\"输入格式\",\"一个正整数。\",\"输出格式\",\"输出输入数字用数码 1∼9 不重复不遗漏地组成带分数表示的全部种数。\",\"数据范围\",\"1⩽N<106\",\"输入样例1：\",\"100\",\"输出样例1：\",\"11\",\"输入样例2：\",\"105\",\"输出样例2：\",\"6\",\"思路\",\"题目意思是说，用 1∼9 的 9 个数，构造成一个整数和一个分数，每个数都要用到且只出现一次，分数不考虑约分的情况。可以理解为，构造成 n=a+cb​ 的形式，要求将 9 个数划分给 a,b,c 三个数，9​ 个数必须不重不漏。\",\"步骤：\",\"枚举全排列\",\"枚举位数，a,b,c 三个数的位数可能都不一样\",\"将 a,b,c 转化为数字，带入等式中看是否成立\",\"将 n=a+cb​ 转化为 cn=ca+b ，只需要枚举 a 和 c 即可，最后判断 b=cn−ca 是否成立。从 a 开递递归枚举，每次递归的同时也对 c 枚举，然后每次都 check(a,c) 是否满足条件，若满足则答案 +1 。\",\"代码\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 20; int n; bool st[N], backup[N]; int ans; bool check(int a, int c) { int b = c * n - c * a; if (!a || !b || !c) return false; memcpy(backup, st, sizeof st); // 备份 while (b) { int x = b % 10; // 取出b的每一位 b /= 10; if (!x || backup[x]) // 判断每一位上的数字是否用过 return false; // 用过则不合法 backup[x] = true; // 没用过则标记 } for (int i = 1; i <= 9; i++) if (!backup[i]) // 如果有一位没用上，则不合法 return false; return true; } void dfs_c(int u, int a, int c) { if (u >= n) return; // 判断当前a和c是否满足条件，若满足则答案+1 if (check(a, c)) ans++; // 继续枚举 for (int i = 1; i <= 9; i++){ if (!st[i]) { st[i] = true; dfs_c(u + 1, a, c * 10 + i); // a不变，更新c st[i] = false; } } } void dfs_a(int u, int a) { if (u >= n) return; // 对a提前判断一下，能更快一点点 if (a) dfs_c(u, a, 0); // 枚举c：用了几个数，a是几，当前加入的数字是几 for (int i = 1; i <= 9; i++){ if (!st[i]) { st[i] = true; dfs_a(u + 1, a * 10 + i); // 用的数字个数+1，加入i后更新当前a的值 st[i] = false; } } } int main() { cin >> n; dfs_a(0, 0); // 枚举a：用了几个数，当前的值 cout << ans << endl; return 0; }\"]},\"112\":{\"c\":[\"笔记\"]},\"113\":{\"c\":[\"递归\"]},\"114\":{\"h\":\"动态规划\"},\"115\":{\"h\":\"1. 背包问题\",\"t\":[\"背包问题常用枚举方法\",\"第一维枚举物品\",\"第二维枚举体积\",\"第三维枚举决策\"]},\"116\":{\"h\":\"1.1 01 背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用一次。\",\"求所选物品的总体积不超过背包容量的条件下，最大的总价值。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++){ for (int j = 0; j <= m; j++){ f[i][j] = f[i - 1][j]; //左半边的子集 if (v[i] <= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } cout << f[n][m] << endl; */ //一维 //f[i] 表示总体积是i的情况下，最大价值是多少 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\"]},\"117\":{\"h\":\"1.2 完全背包\",\"t\":[\"有 n 件物品，背包容量为 m ，每件物品只能使用无限次。\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 1100; int n, m; int v[N], w[N]; int f[N]; //表示总体积是i的情况下，最大价值是多少 int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i]; /* 二维 for (int i = 1; i <= n; i++) for (int j = 0; j <= m; j++) { f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout << f[n][m] << endl; */ //一维 for (int i = 1; i <= n; i++) for (int j = v[i]; j <= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout << f[m] << endl; return 0; }\"]},\"118\":{\"h\":\"1.3 多重背包\",\"t\":[\"有 n 件物品，背包容量为 m，每件物品有有限个。\",\"数据范围 ≤100 的写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); cout << f[n][m] << endl; /* 一维优化写法 for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ for (int k = 0; k <= s[i] && k * v[i] <= j; k++) f[j] = max(f[j], f[j - k * v[i]] + w[i] * k); } } cout << f[m] << endl; */ return 0; }\",\"数据范围较大时，需要用多重背包的二进制优化方法：\",\"第一种写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; int f[M]; int main() { cin >> n >> m; int cnt = 0; for (int i = 1; i <= n; i++){ int a, b, s; cin >> a >> b >> s; int k = 1; while (k < s){ cnt++; v[cnt] += a * k; w[cnt] += b * k; s -= k; k *= 2; } if (s){ cnt++; v[cnt] += a * s; w[cnt] += b * s; } } n = cnt; for (int i = 1; i <= n; i++){ for (int j = m; j >= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout << f[m] << endl; return 0; }\",\"第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> #include <vector> using namespace std; const int N = 2010; int n, m; int f[N]; struct Good { int v, w; }; int main() { vector<Good> goods; cin >> n >> m; for (int i = 0; i < n; i++){ int v, w, s; cin >> v >> w >> s; for (int k = 1; k <= s; k *= 2){ s -= k; goods.push_back({v * k, w * k}); } if (s > 0) goods.push_back({v * s, w * s}); } for (auto good : goods){ for (int j = m; j >= good.v; j--){ f[j] = max(f[j], f[j - good.v] + good.w); } } cout << f[m] << endl; return 0; }\"]},\"119\":{\"h\":\"1.4 分组背包\",\"t\":[\"有 n 组物品和一个容量是 m 的背包。\",\"每组物品有若干个，同一组内的物品最多只能选一个。\",\"求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\",\"（一）第一种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++){ cin >> s[i]; for (int j = 0; j < s[i]; j++){ cin >> v[i][j] >> w[i][j]; } } for (int i = 1; i <= n; i++){ for (int j = m; j >= 0; j--){ for (int k = 0; k < s[i]; k++){ if (v[i][k] <= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } } cout << f[m] << endl; return 0; }\",\"（二）第二种写法：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 110; int n, m; int f[N], v[N], w[N]; int main() { cin >> n >> m; for (int i = 0; i < n; i++) { int s; cin >> s; for (int j = 0; j < s; j++) cin >> v[j] >> w[j]; for (int j = m; j >= 0; j--) for (int k = 0; k < s; k++) if (j >= v[k]) f[j] = max(f[j], f[j - v[k]] + w[k]); } cout << f[m] << endl; return 0; }\"]},\"120\":{\"h\":\"2. 线性DP\"},\"121\":{\"h\":\"2.1 数字三角形\",\"t\":[\"给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。\",\" 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5\",\"线性DP写法：\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 510, INF = 1e9; int n; int a[N][N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= i; j++) cin >> a[i][j]; for (int i = 0; i <= n; i++) for (int j = 0; j <= i + 1; j++) f[i][j] = -INF; //从上往下遍历 f[1][1] = a[1][1]; for (int i = 2; i <= n; i++) for (int j = 1; j <= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; // 状态转移方程 int ans = -INF; for (int i = 1; i <= n; i++) ans = max(ans, f[n][i]); cout << ans << endl; /*从下往上遍历 for (int i = n; i >= 1; i--) for (int j = n; j >= 1; j--) f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; cout << f[1][1] << endl; */ return 0; }\"]},\"122\":{\"h\":\"2.2 最长上升子序列\",\"t\":[\"求一个序列中严格递增的子序列的最大长度。\",\"（一）朴素DP写法：\",\"状态转移方程：if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1010; int n; int a[N]; int f[N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) { f[i] = 1; // 只有a[1]一个数 for (int j = 1; j <= i; j++) if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1); } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f[i]); cout << ans << endl; return 0; }\",\"（二）二分写法：\",\"#include <iostream> #include <cstdio> #include <algorithm> using namespace std; const int N = 100010; int n; int q[N]; int a[N]; int main() { cin >> n; for (int i = 0; i < n; i++) cin >> a[i]; int len = 0; q[0] = -2e9; for (int i = 0; i < n; i++) { int l = 0, r = len; while (l < r) { int mid = l + r + 1 >> 1; if (q[mid] < a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } cout << len << endl; return 0; }\",\"（三）单调队列写法：\",\"#include <iostream> #include <cstdio> #include <vector> #include <algorithm> using namespace std; const int N = 100010; int n; int main() { cin >> n; vector<int> arr(n); for (int i = 0; i < n; i++) cin >> arr[i]; vector<int> stk; //模拟堆栈 stk.push_back(arr[0]); for (int i = 1; i < n; i++) //单调队列思维 { if (arr[i] > stk.back()) //如果该元素大于栈顶元素，则将该元素入栈 stk.push_back(arr[i]); else //否则，替换掉第一个大于或等于这个数字的那个数 *lower_bound(stk.begin(), stk.end(), arr[i]) = arr[i]; } cout << stk.size() << endl; return 0; }\"]},\"123\":{\"h\":\"2.3 最长公共子序列（不连续）\",\"t\":[\"给定两个长度分别为 n 和 m 的字符串 A 和 B，\",\"求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\",\"状态转移方程：\",\"f[i][j] = max(f[i-1][j], f[i][j-1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin >> n >> m >> a + 1 >> b + 1; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"124\":{\"h\":\"2.4 最长公共上升子序列\",\"t\":[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。\",\"小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。\",\"小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。\",\"奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。\",\"不过，只要告诉奶牛它的长度就可以了。\",\"数列 A 和 B 的长度均不超过 3000。\",\"输入格式\",\"第一行包含一个整数 N，表示数列 A,B 的长度。 第二行包含 N 个整数，表示数列 A。 第三行包含 N 个整数，表示数列 B。\",\"输出格式\",\"输出一个整数，表示最长公共上升子序列的长度。\",\"数据范围\",\"1≤N≤3000 , 序列中的数字均不超过 231−1 。\",\"输入样例：\",\"4 2 2 1 3 2 1 2 3\",\"输出样例：\",\"2\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 3010; int n; int a[N], b[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; for (int i = 1; i <= n; i++){ int mx = 1; for (int j = 1; j <= n; j++){ f[i][j] = f[i - 1][j]; if (a[i] == b[j]) f[i][j] = max(f[i][j], mx); if (a[i] > b[j]) mx = max(mx, f[i - 1][j] + 1); } } int res = 0; for (int i = 1; i <= n; i++) res = max(res, f[n][i]); cout << res << endl; return 0; }\"]},\"125\":{\"h\":\"2.5 编辑距离\",\"t\":[\"给定 n 个长度不超过 10 的字符串以及 m 次询问，每次询问给出一个字符串和一个操作次数上限。\",\"对于每次询问，请你求出给定的 n 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。\",\"每个对字符串进行的单个字符的插入、删除或替换算作一次操作。\",\"输入格式\",\"第一行包含两个整数 n 和 m。 接下来 n 行，每行包含一个字符串，表示给定的字符串。 再接下来 m 行，每行包含一个字符串和一个整数，表示一次询问。 字符串中只包含小写字母，且长度均不超过 10。\",\"输出格式\",\"输出共 m​ 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。\",\"模板代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 15, M = 1010; int n, m; int f[N][N]; char str[M][N]; int edit_distance(char a[], char b[]) { int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i <= la; i++) f[i][0] = i; for (int j = 0; j <= lb; j++) f[0][j] = j; for (int i = 1; i <= la; i++) for (int j = 1; j <= lb; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } return f[la][lb]; } int main() { cin >> n >> m; for (int i = 0; i < n; i++) cin >> str[i] + 1; //下标从1开始存 while (m--){ char s[N]; int limit; cin >> s + 1 >> limit; int res = 0; for (int i = 0; i < n; i++) if (edit_distance(str[i], s) <= limit) res++; cout << res << endl; } return 0; }\"]},\"126\":{\"h\":\"2.6 最短编辑距离\",\"t\":[\"给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：\",\"删除 – 将字符串 A 中的某个字符删除。\",\"插入 – 在字符串 A 的某个位置插入某个字符。\",\"替换 – 将字符串 A 中的某个字符替换为另一个字符。\",\"现在请你求出，将 A 变为 B​ 至少需要进行多少次操作。\",\"状态转移方程：\",\"f[i][j] = min(f[i-1][j] + 1, f[i][j-1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i-1][j-1]); else f[i][j] = min(f[i][j], f[i-1][j-1] + 1); //状态转移方程\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; //所有将a[i]变成b[j]的操作方式 int main() { cin >> n >> a + 1; cin >> m >> b + 1; for (int i = 0; i <= n; i++) f[i][0] = i; for (int j = 0; j <= m; j++) f[0][j] = j; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } cout << f[n][m] << endl; return 0; }\"]},\"127\":{\"h\":\"3. 区间DP\",\"t\":[\"区间 DP 常用模版\",\"所有的区间 dp 问题枚举时，\",\"第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；\",\"第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）\",\"模板代码如下：\",\"for (int len = 1; len <= n; len++) { // 区间长度 for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点 int j = i + len - 1; // 区间终点 if (len == 1) { dp[i][j] = 初始值 continue; } for (int k = i; k < j; k++) { // 枚举分割点，构造状态转移方程 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); } } }\",\"代码：\",\"#include <iostream> #include <cstring> #include <algorithm> using namespace std; const int N = 310; int n; int a[N], s[N]; int f[N][N]; int main() { cin >> n; for (int i = 1; i <= n; i++){ cin >> a[i]; s[i] = s[i - 1] + a[i]; } //区间DP枚举套路：长度+左端点 for (int len = 2; len <= n; len++) //先枚举长度 { for (int i = 1; i + len - 1 <= n; i++) //再枚举左端点，且保证右端点不会超范围 { int j = i + len - 1; //自动得到右端点 f[i][j] = 1e9; //初始化大于1的区间为最大，长度为1的区间为0 for (int k = i; k <= j - 1; k++) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]); } } //得到总区间的最小代价 cout << f[1][n] << endl; return 0; }\"]},\"128\":{\"h\":\"4. 计数类DP\",\"t\":[\"一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。\",\"表示前 i 个整数（1,2…,i）恰好拼成 j 的方案数 求方案数：把集合选 0 个 i，1 个 i，2 个 i，…全部加起来\",\"f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;\",\"因此 f[i][j]=f[i−1][j]+f[i][j−i] （这一步类似完全背包的推导）\",\"朴素做法：\",\"// f[i][j] = f[i - 1][j] + f[i][j - i] #include <iostream> using namespace std; const int N = 1e3 + 7, mod = 1e9 + 7; int f[N][N]; int main() { int n; cin >> n; for (int i = 0; i <= n; i ++) { f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 } for (int i = 1; i <= n; i ++) { for (int j = 0; j <= n; j ++) { f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1 if (j >= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod; } } cout << f[n][n] << endl; }\",\"一维优化：\",\" f[0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 for (int i = 1; i <= n; i ++) { for (int j = i; j <= n; j ++) { f[j] = (f[j] + f[j - i]) % mod; } } cout << f[n] << endl;\"]},\"129\":{\"h\":\"5. 数位统计类DP\",\"t\":[\"给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0 ~ 9 的出现次数。\",\"#include <bits/stdc++.h> using namespace std; int base[10]; int f[10][10]; int g[10][10]; void init() { base[0] = 1; for(int i = 1 ; i <= 9 ; i++) base[i] = base[i-1]*10; //从00……0 - 99……9 的各位数字有多少个，其中i为数字个数（包含前导零） for(int i = 0 ; i <= 9 ; i++) f[1][i] = 1; for(int i = 2 ; i <= 9 ; i++) for(int j = 0 ; j <= 9 ; j++) f[i][j] = f[i-1][j]*10 + base[i-1]; //从1 - 99……9 的各位数字有多少个，其中i为数字个数（不包含前导零） for(int i = 1 ; i <= 9 ; i++) g[1][i] = 1;//循环从1开始 for(int i = 2 ; i <= 9 ; i++) { g[i][0] = g[i-1][0] + f[i-1][0]*9; for(int j = 1 ; j <= 9 ; j++) g[i][j] = g[i-1][j] + f[i-1][j]*9 + base[i-1]; } } vector<int> dp(int n) { vector<int> ans(10,0); //记录答案 if(n<=0) return ans; //边界条件 vector<int> nums; while(n) nums.push_back(n%10), n/=10; vector<int> last(10,0); //记录前缀中各个数字个数 //统计1 - 99……9(n-1个9)里面各个数字有多少个 for(int i = 0 ; i <= 9 ; i++) ans[i] = g[nums.size()-1][i]; //统计大于10……0(n-1个0) 的树里各个数字有多少个 for(int i = nums.size()-1 ; i >=0 ; i--) { //循环变量i可以表示剩下的数字有多少个 int x = nums[i]; for(int j = i==nums.size()-1 ; j < x ; j++) { //第一次循环不能有0 //前缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k] * base[i]; //当前位置部分 ans[j] += base[i]; //后缀部分 for(int k = 0 ; k <= 9 ; k++) ans[k] += f[i][k]; } //更新前缀计数器 last[x] ++; //统计叶子节点（这个数本身） if(!i) for(int k = 0 ; k <= 9 ; k++) ans[k] += last[k]; } return ans; } vector<int> ask(int a, int b) { auto x = dp(b); auto y = dp(a-1); vector<int> ans; for(int i = 0 ; i <= 9 ; i++) ans.push_back(x[i]-y[i]); return ans; } void print(vector<int> ans) { for(auto x:ans) printf(\\\"%d \\\",x); puts(\\\"\\\"); } bool check(int x) { auto t = ask(x,x); vector<int> cnt(10,0); while(x) cnt[x%10]++,x/=10; for(int i = 0 ; i <= 9 ; i++) if(cnt[i] != t[i]) return false; return true; } int main() { init(); int a,b; while(cin >> a >> b, a||b) { if(a>b) swap(a,b); auto t = ask(a,b); print(t); } return 0; }\"]},\"130\":{\"h\":\"6. 状态压缩类DP\"},\"131\":{\"h\":\"6.1 蒙德里安的梦想\",\"t\":[\"n×m 的棋盘可以摆放不同的 1×2 小方格的种类数。\",\"状态表示：f[i][j] 表示当前摆到第 i 列的状态是 j 的所有方案。\",\"(其中 j 是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。)\",\"去除无效状态的优化写法：\",\"#include <cstring> #include <iostream> #include <algorithm> #include <vector> using namespace std; typedef long long LL; const int N = 12, M = 1 << N; int n, m; LL f[N][M]; vector<int> state[M]; bool st[M]; int main() { while (cin >> n >> m, n || m) { for (int i = 0; i < 1 << n; i ++ ) { int cnt = 0; bool is_valid = true; for (int j = 0; j < n; j ++ ) if (i >> j & 1) { if (cnt & 1) { is_valid = false; break; } cnt = 0; } else cnt++; if (cnt & 1) is_valid = false; st[i] = is_valid; } for (int i = 0; i < 1 << n; i ++ ) { state[i].clear(); for (int j = 0; j < 1 << n; j ++ ) if ((i & j) == 0 && st[i | j]) state[i].push_back(j); } memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i <= m; i ++ ) for (int j = 0; j < 1 << n; j ++ ) for (auto k : state[j]) f[i][j] += f[i - 1][k]; cout << f[m][0] << endl; } return 0; }\"]},\"132\":{\"h\":\"6.2 最短Hamilton路径\",\"t\":[\"给定一张 n 个点的带权无向图，点从 0 ~ n−1 标号，求起点 0 到终点 n−1 的最短Hamilton路径。\",\"Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。\",\"f[i][j] 表示从 0 走到 j ，走过的所有点的情况是 i 的所有路径。\",\"状态转移方程：f[i][j] = min(f[i][j], f[i-(1<<j)][k] + w[k][j]);\",\"#include<iostream> #include<cstring> #include<algorithm> using namespace std; const int N = 20, M = 1 << N; int n; int f[M][N], w[N][N];//w表示的是无权图 int main() { cin>>n; for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) cin >> w[i][j]; memset(f, 0x3f, sizeof(f)); // 因为要求最小值，所以初始化为无穷大 f[1][0] = 0; // 因为零是起点,所以f[1][0]=0; for (int i = 0; i < 1 << n; i++) // i表示所有的情况 for (int j = 0; j < n; j++) // j表示走到哪一个点 if (i >> j & 1) for (int k = 0; k < n; k++) // k表示走到j这个点之前,以k为终点的最短距离 if (i >> k & 1) // 更新最短距离 f[i][j] = min(f[i][j], f[i - (1<<j)][k] + w[k][j]); // 表示所有点都走过了,且终点是n-1的最短距离 cout << f[(1<<n) - 1][n - 1] << endl; return 0; }\"]},\"133\":{\"h\":\"7. 树形DP\"},\"134\":{\"h\":\"7.1 没有上司的舞会\",\"t\":[\"选了某个节点就不能选父节点和子节点。求最大权值和。\",\"每个人只有两种状态，则设 dp[0][i] 为第 i 个人不来，他的下属所能获得的最大快乐值；\",\"dp[1][i] 为第 i 个人来，他的下属所能获得的最大快乐值。\",\"状态转移方程：\",\"dp[0][i]=∑u=sons​max(dp[1][u],dp[0][u]) 当前节点不选，那么子节点随意\",\"dp[1][i]=∑u=sons​dp[0][u]+happy[i] 当前节点选，子节点不能选\",\"#include <bit/stdc++.h> using namespace std; int n; int dp[2][6010]; int f[2][6010]; // f[0]为父亲，f[1]为高兴值 int ind[6010]; // 入度 int vis[6010]; // 访问标记 int root; // 树的根 void dfs(int u) // 递归从后往前更新 { if (!u) return; vis[u] = 1; // 已访问 root = u; // 最后一个访问到的一定是根，所以一直更新根就行了 dp[0][f[0][u]] += max(dp[1][u] + f[1][u], dp[0][u]); // 给父亲更新 dp[1][f[0][u]] += dp[0][u]; ind[f[0][u]]--; // 更新完一个子节点 if(!ind[f[0][u]]) dfs(f[0][u]); // 在所有子节点更新后再更新（入度为0） } int main() { cin >> n; for (int i = 1; i <= n; i++) scanf(\\\"%d\\\", &f[1][i]); int a,b; for (int i = 1; i < n; i++){ scanf(\\\"%d%d\\\", &a, &b); f[0][a] = b; // 保存节点信息 ind[b]++; } for (int i = 1; i <= n; i++) if(!vis[i] && !ind[i]) // 没有被访问过，没有入度，说明是叶子节点 dfs(i); // 取根节点两种方案的最大值 printf(\\\"%d\\\\n\\\", max(dp[0][root], dp[1][root] + f[1][root])); return 0; }\"]},\"135\":{\"c\":[\"模板\",\"动态规划\"]},\"136\":{\"h\":\"基础算法\"},\"137\":{\"h\":\"1. 快速排序\",\"t\":[\"快排属于分治算法，分治算法都有三步：\",\"分成子问题\",\"递归处理子问题\",\"子问题合并\",\"主要步骤：\",\"确定分界点，可以任选 a[l]，a[r]，a[(l + r) / 2] 其中一个作为分界点。\",\"设置两个头尾指针 i, j，初始化 i = l - 1, j = r + 1 (避免发生边界问题导致死循环) ，向中间移动。每次循环都先将 i 右移和 j 左移，然后判断，如果 a[i] > a[j] 且 i < j，就交换 a[i] 和 a[j].\",\"最后根据分界点分别递归左右两部分。\",\"快排的一般写法如下：\",\"void quick_sort(int q[], int l, int r) { //递归的终止情况 if(l >= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[(l + r) / 2]; while(i < j) { do i++; while(q[i] < x); do j--; while(q[j] > x); if(i < j) swap(q[i], q[j]); } //第二步：递归处理子问题 quick_sort(q, l, j); quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤 }\"]},\"138\":{\"h\":\"2. 归并排序\",\"t\":[\"运用双指针的思想，先递归再合并。\",\"主要步骤：\",\"确定分界点。与快排不同，归并每次都将中点作为分界点，将整个序列均分为两部分。mid = (l + r) / 2\",\"递归排序。对两个子序列分别设置个指针 i, j，从头开始遍历，每次比较 a[i] 和 a[j]，将小的放入一个临时序列 temp[] 中。如果有一部分遍历完了，而另一部分还有剩余，则将剩余那一部分直接接在临时序列的后面，因为剩下的这部分一定是大于前面的。\",\"归并，合二为一。将临时序列放入原序列中。\",\"归并的一般写法如下：\",\"void merge_sort(int a[], int l, int r) { if (l >= r) return; //确定中间分界点 int mid = (l + r) >> 1; //两边递归 merge_sort(a, l, mid); merge_sort(a, mid + 1, r); int k = 0; int i = l, j = mid + 1; //比较左右两半边 while (i <= mid && j <= r) if (a[i] < a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; while (i <= mid)//左半边剩下的 temp[k++] = a[i++]; while (j <= r)//右半边剩下的 temp[k++] = a[j++]; //合并区间 for (i = l, j = 0; i <= r; i++, j++) a[i] = temp[j]; }\"]},\"139\":{\"h\":\"3. 二分算法\"},\"140\":{\"h\":\"3.1 二分查找算法模板\",\"t\":[\"二分模板一共有两个，分别适用于不同情况。\",\"算法思路：假设目标值在闭区间 [l, r]中， 每次将区间长度缩小一半，当 l = r时，我们就找到了目标值。\"]},\"141\":{\"h\":\"版本1\",\"t\":[\"当我们将区间 [l, r]划分成 [l, mid] 和 [mid + 1, r] 时，其更新操作是 r = mid 或者 l = mid + 1; ，计算 mid 时不需要加 1。\",\"C++代码模板：\",\"int bsearch_1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (a[mid] >= x) r = mid; //答案在左边界，要向下取整 else l = mid + 1; //找左端点 } return l; }\"]},\"142\":{\"h\":\"版本2\",\"t\":[\"当我们将区间 [l, r] 划分成 [l, mid - 1] 和 [mid, r] 时，其更新操作是 r = mid - 1 或者 l = mid; ，此时为了防止死循环，计算 mid 时需要加 1。\",\"C++代码模板：\",\"int bsearch_2(int l, int r) { while (l < r) { int mid = l + r + 1 >> 1; if (a[mid] <= k) l = mid; //答案在右边界，要上取整 else r = mid - 1; //找右端点 } return l; }\",\"简单来说就是：\",\"可以将模板 1 中的 check[mid] 换成a[mid] >= x ，用来查找大于等于 x 的第一个元素；\",\"将模板 2 中的 check[mid] 换成 a[mid] <= x ，用来查找小于等于 x 的最后一个元素。\"]},\"143\":{\"h\":\"3.2 二分答案模板\",\"t\":[\"一般来说，二分答案可以用来处理 “最大的最小” 或 “最小的最大” 的问题。\",\"定义区间为闭区间 [l, r] ，每次只需判断答案是否需要更新（是否记下ans）和（可能的）答案在哪一侧（改 L 还是 R ）即可。\",\"int ans; int find(int l, int r) { while (l <= r) { int mid = l + r >> 1; if (check(mid)){ ans = mid; //如果条件成立则记下答案 r = mid - 1; //判断可能的答案更新区间 } else l = mid + 1; } return ans; }\"]},\"144\":{\"h\":\"3.3 整数二分\",\"t\":[\"【例二】A-B 数对\",\"题目描述：给出一串数以及一个数字 C ，要求计算出所有 A - B = C 的数对的个数（不同位置的数字一样的数对算不同的数对）。\",\"这里使用库函数二分的写法：\",\"依次枚举 A ，将问题转变成统计数列中 B + C 出现了多少次。先对数列排序，那么 B + C 会对应这个数列的连续一段，只要找到这个连续段的左端点和右端点即可。(需使用头文件 algorithm )\",\"① lower_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 第一次出现的位置；\",\"② upper_bound(begin, end, val) 可以在区间 [begin, end) 中找到 val 最后一次出现的位置的__后面一位__ 。\",\"则这个数出现的次数就可以表示为 upper_bound() - lower_bound() ，时间复杂度为 O(nlogn).\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; const int N = 2e5 + 10; int n, c; ll a[N]; int main() { cin >> n >> c; for (int i = 0; i < n; i++) cin >> a[i]; sort(a, a + n); ll tot = 0; for (int i = 0; i < n; i++) tot += upper_bound(a, a + n, a[i] + c) - lower_bound(a, a + n, a[i] + c); cout << tot << endl; return 0; }\"]},\"145\":{\"h\":\"3.4 浮点数二分\",\"t\":[\"bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l > eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; }\"]},\"146\":{\"h\":\"4. 高精度算法\"},\"147\":{\"h\":\"4.1 高精度加法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的和。 （C = A + B，A >= 0， B >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; const int N = 1e6 + 10; // C = A + B vector<int> add(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; int t = 0; //进位，低位满10向高位进位，低位变为0 for (int i = 0; i < A.size() || i < B.size(); i++){ //两个if把两个数组相同位上的数相加 if (i < A.size()) t += A[i]; if (i < B.size()) t += B[i]; //把相加后的结果除以10求余，压入C数组中 C.push_back(t % 10); //t再除以10，放入高位 t /= 10; } //如果最高位有数，则压入C数组中 if (t) C.push_back(t); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //使用auto编译器会自动判断数据是什么类型 auto C = add(A, B); for (int i = C.size() - 1; i >= 0; i--) printf(\\\"%d\\\", C[i]); return 0; }\"]},\"148\":{\"h\":\"4.2 高精度减法\",\"t\":[\"给定两个正整数（不含前导0），计算它们的差，计算结果可能为负数。\",\"1、前提： C = A - B，满足 A >= B，A >= 0，B >= 0 （如果 B >= A，则将其转化为 -(B - A) ）\",\"2、代码段：(只考虑正数的情况)\",\"#include <iostream> #include <vector> using namespace std; //判断是否有 A >= B bool cmp(vector<int> &A, vector<int> &B) { //A长度不等于B，若A大于B，返回true，否则返回false if (A.size() != B.size()) return A.size() > B.size(); //因为是倒序数组，高位在后面，所以从后遍历 //如果A > B, 返回true，否则返回flase for (int i = A.size() - 1; i >= 0; i--){ if (A[i] != B[i]) return A[i] > B[i]; } return true; } // C = A - B vector<int> sub(vector<int> &A, vector<int> &B) //加上&直接搜索数组A和B，不用全部遍历，节省时间 { vector<int> C; //定义一个借位的情况 int t = 0; for (int i = 0; i < A.size(); i++){ //t = A的这一位数 t = A[i] - t; //判断B在这一位上有没有数，如果有，则减去B[i] if (i < B.size()) t -= B[i]; //这种写法包含了两种情况：如果t >= 0, 则直接减；若t < 0, 则向高位借位(即t + 10)后再减 //将这一位相减后的结果压入C中 C.push_back((t + 10) % 10); if (t < 0) //t < 0，需要借位，标记为1 t = 1; else //t >= 0，不需要借位，标记为0 t = 0; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); //最后返回C数组 return C; } int main(){ string a, b; vector<int> A, B; cin >> a >> b; //例如 a = \\\"123456\\\" for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); //倒序存放, 数组A = [6, 5, 4, 3, 2, 1] for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); //同理, 数组B也是从低位(个位)存储, 从小到大 //如果A > B，返回A - B if (cmp(A, B)){ auto C = sub(A, B); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", C[i]); } //否则返回 -(B - A) else { auto C = sub(B, A); printf(\\\"-\\\"); for (int i = C.size(); i >= 0; i--) printf(\\\"%d\\\", c[i]); } return 0; }\"]},\"149\":{\"h\":\"4.3 高精度整数乘法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A × B 的值\",\"一般是 高精 × 低精，用 A × b 表示 （C = A * b，A >= 0，b >= 0）\",\"代码如下：\",\"#include <iostream> #include <vector> using namespace std; //C = A * b vector<int> mul(vector<int> &A, int b) { vector<int> C; int t = 0; for (int i = 0; i < A.size() || t; i++) { if (i < A.size()) t += A[i] * b; //同加法一样处理进位，逐位压入数组中 C.push_back(t % 10); t /= 10; } //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int b; cin >> a >> b; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) //倒序插入 A.push_back(a[i] - '0'); auto C = mul(A, b); for (int i = C.size() - 1; i >= 0; i--) //倒序输出 printf(\\\"%d\\\", C[i]); return 0; }\"]},\"150\":{\"h\":\"4.4 高精度整数除法\",\"t\":[\"给定两个非负整数（不含前导0）A 和 B，要求计算 A / B 的商和余数 (第一行输出所求的商，第二行输出所求余数)\",\"一般是 高精 ÷ 低精，用 A ÷ b 表示 （A / b = C ··· r，A >= 0，b > 0）\",\"代码如下：\",\"#include <iostream> #include <vector> #include <algorithm> using namespace std; vector<int> div(vector<int> &A, int b, int &t) //传入t的地址，便于直接对余数进行处理 { vector<int> C; t = 0; for (int i = A.size() - 1; i >= 0; i--) { //将上次的余数×10再加上当前位的数字，得到该位的被除数 t = t * 10 + A[i]; //所得即为商在这一位的数字 C.push_back(t / b); t %= b; } //由于在除法运算中，从高位到低位运算，因此前导0在数组前面，所以需要将其翻转，将前导0置于尾部，从而便于删除前导0 reverse(C.begin(), C.end()); //删除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } int main() { string a; int B; cin >> a >> B; vector<int> A; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); int t; //t为余数 auto C = div(A, B, t); for (int i = C.size() - 1; i >= 0; i--) cout << C[i]; cout << endl << t << endl; return 0; }\"]},\"151\":{\"h\":\"5. 前缀和与差分\"},\"152\":{\"h\":\"5.1 一维前缀和\",\"t\":[\"S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1]\"]},\"153\":{\"h\":\"5.2 二维前缀和\",\"t\":[\"S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\"]},\"154\":{\"h\":\"5.3 一维差分\",\"t\":[\"给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\"]},\"155\":{\"h\":\"5.4 二维差分\",\"t\":[\"给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\"]},\"156\":{\"h\":\"6. 位运算\"},\"157\":{\"h\":\"6.1 位运算符\",\"t\":[\"位运算符作用于位，并逐位执行操作。\",\"符号\",\"描述\",\"运算规则\",\"&\",\"与\",\"两个位都为1时，结果才为1\",\"|\",\"或\",\"两个位都为0时，结果才为0\",\"^\",\"异或\",\"两个位相同为0，不同为1\",\"~\",\"取反\",\"0变1，1变0\",\"<<\",\"左移\",\"各二进位全部左移若干位，高位丢弃，低位补0\",\">>\",\"右移\",\"各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）\"]},\"158\":{\"h\":\"6.2 用途\",\"t\":[\"1、按位与 (&)\",\"运算规则（全为 1，才为1）\",\"0 & 0 = 0\",\"0 & 1 = 0\",\"1 & 0 = 0\",\"1 & 1 = 1\",\"注意：负数按补码形式参加按位与运算。\",\"（1）清零\",\"如果想将一个单元清零，使其全部二进制位为 0，只要__与一个各位都为零的数值相与__，结果为零。\",\"（2）取一个数的指定位\",\"比如取数 X = 1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位与运算（X & Y = 0000 1110）即可得到 X 的指定位。\",\"（3）判断奇偶\",\"只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。因此可以用 if ((a & 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。\",\"2、按位或 (|)\",\"运算规则（全为 0，才为 0）\",\"0 | 0 = 0\",\"0 | 1 = 1\",\"1 | 0 = 1\",\"1 | 1 = 1\",\"（1）常用来对一个数据的某些位设置为1\",\"比如将数 X = 1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行按位或运算（X | Y = 1010 1111）即可得到。\",\"3、按位异或 (^)\",\"运算规则（相同为 0，不同为 1）\",\"0 ^ 0 = 0\",\"0 ^ 1 = 1\",\"1 ^ 0 = 1\",\"1 ^ 1 = 0\",\"（1）翻转指定位\",\"比如将数 X = 1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y = 0000 1111，然后将 X 与 Y 进行异或运算（X ^ Y = 1010 0001）即可得到。\",\"（2）与 0 相异或值不变\",\"例如：1010 1110 ^ 0000 0000 = 1010 1110\",\"（3）交换两个数\",\"当 x == y 时，直接异或运算进行整数交换后，会导致 x = 0, y = x.\",\"为避免这种情况，必须首先判断两个数是否相等。\",\"void swap(int &a, int &b){ if (a != b){ a ^= b; b ^= a; a ^= b; } }\",\"4、按位取反 (~)\",\"运算规则（0 变 1，1 变 0）\",\"~1 = 0\",\"~0 = 1\",\"（1）使一个数的最低位为 0\",\"使 x 的最低位为 0，可以表示为：a & ~1 。~1 的值为 1111 1111 1111 1110 ，再按 与 运算，最低位一定为 0。因为 ~ 运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。\",\"5、左移 (<<)\",\"定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\",\"设 a = 1010 1110，a = a << 2 将 a 的二进制位 左移2位、右补0，即得 a = 1011 1000。\",\"若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2 。比如 左移 k 位，即乘上 2k .\",\"6、右移 (>>)\",\"定义：将一个数的各二进制位全部右移若干位，正数左补 0 ，负数左补 1 ，右边丢弃。\",\"例如：a = a >> 2 将 a 的二进制位右移 2 位，左补 0 或者 左补 1 得看被移数是正还是负。\",\"操作数每右移一位，相当于该数除以 2。比如 右移 k 位，即除以 2k .\",\"bit_operation\"]},\"159\":{\"h\":\"6.3 例题\",\"t\":[\"【例题一】n 的二进制表示中第 k 位数\",\"思路：先把第 k 位数字移动到最后一位，n 右移 k 位，即 n >> k ，再看个位是几，用 n & 1 ，合并两步后，即 n >> k & 1 .\",\"例如求 10 的二进制表示，代码如下：\",\"#include <iostream> using namespace std; int main() { int n = 10; //10的二进制表示为4位数 for (int k = 3; k >= 0; k--) cout << (n >> k & 1); return 0; }\",\"输出如下：\",\"1010\",\"【例题二】二进制中1的个数\",\"给定一个长度为 1 的数列，请你求出数列中每个数的二进制表示中 1 的个数。\",\"输入格式\",\"第一行包含整数 n .\",\"第二行包含 n 个整数，表示整个数列\",\"输出格式\",\"共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。\",\"思路：使用 lowbit(x) 来解决，其表达式为 x & -x ，其中 -x 表示补码，即源码取反加 1 ，-x = (~x + 1)。 作用：返回 x 的最后一位 1，比如 x = 1010, 则 lowbit(x) = 10 ，x = 101000, 则 lowbit(x) = 1000 .\",\"代码如下：\",\"#include <iostream> using namespace std; const int N = 100010; int lowbit(int x) { return x & -x; } int main() { int n; cin >> n; while (n--){ int x; cin >> x; int res = 0; while (x){ x -= lowbit(x); res++; } cout << res << \\\" \\\"; } return 0; }\"]},\"160\":{\"h\":\"7. 双指针算法\",\"t\":[\"for (int i = 0, j = 0; i < n; i++) { while (j < i && check(i, j)) j++; // 具体问题的逻辑 // 例如求长度 res = max(res, i - j + 1); } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\"]},\"161\":{\"h\":\"8. 离散化\",\"t\":[\"vector<int> alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l < r) { int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n }\"]},\"162\":{\"h\":\"9. 区间合并\",\"t\":[\"// 将所有存在交集的区间合并 void merge(vector<PII> &segs) { vector<PII> res; sort(segs.begin(), segs.end()); int L = -2e9, R = -2e9; for (auto seg : segs) if (R < seg.first) { if (st != -2e9) res.push_back({L, R}); L = seg.first, R = seg.second; } else R = max(R, seg.second); if (L != -2e9) res.push_back({L, R}); segs = res; }\"]},\"163\":{\"c\":[\"模板\"]},\"164\":{\"h\":\"搜索与图论\"},\"165\":{\"h\":\"1. 树与图的存储\",\"t\":[\"(1) 邻接矩阵：g [a] [b] 存储边 a -> b\",\"(2) 动态邻接矩阵：\",\"int n; struct Edge { int id, w; }; vector<Edge> h[N]; int dist[N]; void dfs(int u, int father, int distance) { dist[u] = distance; for (auto node : h[u]) if (node.id != father) dfs(node.id, u, distance + node.w); } int main() { scanf(\\\"%d\\\", &n); for (int i = 0; i < n - 1; i ++ ) { int a, b, c; scanf(\\\"%d%d%d\\\", &a, &b, &c); h[a].push_back({b, c}); h[b].push_back({a, c}); } dfs(1, -1, 0); // 寻找两点之间的最大距离 int u = 1; for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; dfs(u, -1, 0); for (int i = 1; i <= n; i ++ ) if (dist[i] > dist[u]) u = i; int s = dist[u]; printf(\\\"%lld\\\\n\\\", s * 10 + s * (s + 1ll) / 2); return 0; }\",\"(3) 邻接表：\",\"int n, m; //n代表点数，m代表边数 // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a->b void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } // 初始化 idx = 0; memset(h, -1, sizeof h); //存边 for (int i = 0; i < n; i++){ int a, b; cin >> a >> b; add(a, b); //无向图就再写一遍 add(b, a) }\"]},\"166\":{\"h\":\"2. 树与图的遍历\",\"t\":[\"时间复杂度 O(n + m), n 表示点数， m 表示边数\"]},\"167\":{\"h\":\"深度优先遍历\",\"t\":[\"int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } }\"]},\"168\":{\"h\":\"宽度优先遍历\",\"t\":[\"queue<int> q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } }\"]},\"169\":{\"h\":\"3. 拓扑排序\",\"t\":[\"时间复杂度 O(n+m), n 表示点数，m 表示边数\",\"1、图的拓扑序列是针对于有向图而言的，无向图是没有拓扑序列的。有向无环图被称为拓扑图。\",\"2、结论：一个有向无环图，一定至少存在一个入度为 0 的点。\",\"bool topsort() { //采用数组模拟队列的写法，头尾指针 int hh = 0, tt = -1; // d[i] 存储点i的入度，起点的入度为0 for (int i = 1; i <= n; i++) if (!d[i]) //如果不是起点 q[++tt] = i; while (hh <= tt) { int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (--d[j] == 0) q[++tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; }\"]},\"170\":{\"h\":\"4. 最短路问题\"},\"171\":{\"h\":\"4.1 单源最短路\",\"t\":[\"求从一个点到其他所有点的最短距离。\",\"分为两大类：\",\"1、所有边权都是正数（n 个点，m 条边）\",\"朴素版的Dijkstra算法，时间复杂度为 O(n2 + m) ，适合稠密图（边多，点少边比较多）\",\"堆优化版的Dijkstra算法，时间复杂度为 O(mlogn)，适合稀疏图（点多，指边相对于点不多，m 和 n 是同一个级别的类型）\",\"2、存在负权边\",\"Bellman-Ford 算法，时间复杂度为 O(nm)\",\"SPFA 算法，时间复杂度一般为 O(m)，最坏情况为 O(nm)，是Bellman-Ford算法的优化\"]},\"172\":{\"h\":\"4.1.1 朴素版 Dijkstra算法\",\"t\":[\"稠密图用邻接矩阵，稀疏图用邻接表\",\"1.逐个遍历，找到与起点最近的且未确定最短路径的点，访问加入集合并标记。\",\"2.更新第一个点到起点的最短距离，直到第n个点。\",\"__时间复杂度是 O(n2 + m)， n 表示点数，m 表示边数 __\",\"#include <iostream> #include <cstring> #include <algortihm> using namespace std; const int N = 510; int n, m; //点数和边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { //距离都初始化为无穷大 memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i < n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 //遍历n个点，找到一个未加入集合且距离最近的点 for (int j = 1; j <= n; j ++ ) if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; st[t] = true; //标记为已加入到集合中 // 用t更新其他点的距离 for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); } //如果为无穷大，说明不连通，无法形成最短路 if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { cin >> n >> m; //邻接矩阵初始化为无穷大 memset(g, 0x3f, sizeof(g)); while (m--){ int a, b, c; cin >> a >> b >> c; //存入a和b两点之间的距离（有向图） g[a][b] = min(g[a][b], c); //无向图 //g[a][b] = min(g[a][b], c); //g[b][a] = min(a[a][b], c); } cout << dijkstra() << endl; return 0; }\"]},\"173\":{\"h\":\"4.1.2 堆优化版的Dijkstra算法\",\"t\":[\"稀疏图改用__邻接表__的形式存储，可以不需要考虑重边\",\"时间复杂度是 O(mlogn)， n 表示点数，m 表示边数\",\"#define PII pair<int, int> int n; //点的数量 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //存储所有点到1号点的距离 bool st[N]; //存储每个点的最短距离是否已确定 void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; //定义一个小根堆 priority_queue<PII, vector<PII>, greater<PII>> heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"174\":{\"h\":\"4.1.3 Bellman-ford算法（存在负权边）\",\"t\":[\"1.可以用结构体存储点和边，包括负权边。\",\"2.具体步骤：两重 for 循环，迭代 n-1 次，每次备份一下，每次循环遍历所有边，更新两点之间的最短距离，如点 a->b 的更新方式为（松弛操作）\",\"for n 次 for 所有边 a, b, w (松弛操作) dist[b] = min(dist[b], backup[a] + w);\",\"backup[ ] 数组是上一次迭代后 dist[ ] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[ ] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点。\",\"3.循环 n-1 次之后，对于所有的点都 一定满足 dist[b] <= dist[a] + w，该式被称为三角不等式。\",\"4.如果图中存在负权回路，那么最短路可能为负无穷。（不是一定）\",\"5.是否能到达 n 号点的判断中需要进行 if(dist[n] > INF/2) 判断，而并非是 if(dist[n] == INF) 判断，原因是 INF 是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，``dist[n]大于某个与INF` 相同数量级的数即可。\",\"6.bellman-ford算法擅长解决有边数限制的最短路问题。\",\"时间复杂度 O(nm)， n 表示点数，m 表示边数\",\"int n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i < n; i ++ ) { for (int j = 0; j < m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] > dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] > 0x3f3f3f3f / 2) return -1; return dist[n]; }\"]},\"175\":{\"h\":\"4.1.4 SPFA算法 （存在负权边）\",\"t\":[\"1.用队列来存储\",\"2.while queue 不为空，\",\"取出作为 t ，t = q.front; q.pop();\",\"更新 t 的所有出边，如：t -> b, 把b加入 queue\",\"3.基本步骤\",\"建立一个队列，初始时队列里只有起始点\",\"再建立一个数组记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到它本身的路径赋为0）\",\"再建立一个数组，标记点是否在队列中\",\"队头不断出队，计算起始点经过队头到其他点的距离是否变短，如果变短且该点不在队列中，则把该点加入到队尾\",\"重复执行直到队列为空\",\"在保存最短路径的数组中，就得到了最短路径\",\"4.SPFA求最短路\",\"时间复杂度 平均情况下 O(m)， 最坏情况下 O(nm)， n 表示点数， m 表示边数\",\"int n, m; // 总点数和总边数 int h[N], e[M], w[M], ne[M], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 int add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++; } // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue<int> q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; }\"]},\"176\":{\"h\":\"4.1.5 SPFA算法判断图中是否存在负环\",\"t\":[\"时间复杂度 O(nm)， n 表示点数， m 表示边数\",\"int n; //总点数 int h[N], w[N], e[N], ne[N], idx; //邻接表存储所有边 int dist[N]; //dist[x]存储1号点到x的最短距离， int cnt[N]; //cnt[x]存储1到x的最短路中经过的点数 bool st[N]; //存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue<int> q; for (int i = 1; i <= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] > dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (cnt[j] >= n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; }\"]},\"177\":{\"h\":\"4.2 多源汇最短路\"},\"178\":{\"h\":\"4.2.1 Floyd算法\",\"t\":[\"1.使用邻接矩阵存图\",\"2.三重循环，时间复杂度O(n^3)\",\"初始化： for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (i == j) d[i][j] = 0; else d[i][j] = INF; //算法结束后，d[a][b]表示a到b的距离 for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\"]},\"179\":{\"h\":\"5. 最小生成树问题\",\"t\":[\"最小生成树就是将 n 个顶点， n - 1 条边，通过一个连接起来，且使权值最小的一种结构。\",\"换句话来说，就是给定一个无向图，在图中选择若干条边把图中的所有节点连接起来，要求边长之和最小。在图论中，叫做求最小生成树。\"]},\"180\":{\"h\":\"5.1 朴素Prim算法\",\"t\":[\"可理解为 “加点法”， 每次迭代找到不在连通块中的距离最近的点，加入到连通块中，将连通块逐渐扩大，最后将整个图连通起来，并且边长之和最小。\",\"1、先把所有距离初始化为正无穷\",\"dist[i] = +INF;\",\"2、n次迭代，找到不在集合当中的最小的点，这个集合指当前已经在连通块中的所有点，找到该点赋给 t ，用 t 更新其他点到集合的距离，再把 t 加到集合当中去\",\"先累加，再更新\",\"for (int i = 0; i < n; i++) t <- 距离最近的点; t = ture;更新t\",\"时间复杂度为 O(n2 + m)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> #define ll long long using namespace std; const int N = 1e5 + 10, M = N * 2; int n, m; // n表示点数，m表示边数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; //最小生成树所有边的长度之和 for (int i = 0; i < n; i++) { int t = -1; for (int j = 1; j <= n; j++) //如果没有在树中，且到树的距离最短，则选择该点 if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j; //一定要先累加，再进行更新生成树 if (i && dist[t] == INF) return INF; if (i) //(不是起点)把找到的符合条件的点的长度加上 res += dist[t]; st[t] = true; for (int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { cin >> n >> m; memset(g, 0x3f, sizeof g); for (int i = 1; i <= m; i++){ int a, b, c; cin >> a >> b >> c; g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(\\\"impossible\\\"); else printf(\\\"%d\\\\n\\\", t); }\"]},\"181\":{\"h\":\"5.2 Kruskal 算法\",\"t\":[\"可理解为 “加边法”，最初最小生成树的边数为 0，每次迭代选择一条不在集合内的权值最短的边，加入到集合中，组成最小生成树。\",\"1、使用快排将所有边按权值从小到大排序。时间复杂度为 O(log n).\",\"2、从小到大依次枚举每组边 a 、b，权重 c ，如果 a、b不连通，就将这条边加入集合中，直到具有 n 个顶点的连通块筛选出来 n-1 条边为止。时间复杂度为 O(n) .\",\"3、判断 a、b是否连通的方法为：使用并查集。\",\"初始化各个顶点在不同的集合中，父节点为它自己。\",\"按快排的从小到大的顺序遍历每条边，判断这条边的两个顶点是否有相同的父节点，如果有那就使在同一个集合中。\",\"如果该条边上的两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则加入这条边到集合中，连通这两个顶点。\",\"时间复杂度是 O(mlogm)， n 表示点数， m 表示边数\",\"#include <bits/stdc++.h> using namespace std; const int N = 2e5 + 10; int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 int rank[N]; // 树的高度 //结构体存储 两点及其权值 struct Edge { int a, b, w; //重载小于号，因为再给边排序的时候是按照边的权重进行排序的，这样当两个边进行比较的时候就会使用他们的权重进行比较了 bool operator< (const Edge &W)const { return w < W.w; } }edges[M]; void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int x, int y) { int px = find(x), py = find(y); if (px == py) return; if (rank[px] < rank[py]){ p[px] = py; } else { p[py] = px; if (rank[px] == rank[py]) rank[px]++; } } int kruskal() { sort(edges, edges + m); init(n); int res = 0; //存的是最小生成树的所有边的权值 int cnt = 0; //存的是当前加入的边数 for (int i = 0; i < m; i++) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; pa = find(a), pb = find(b); if (pa != pb) // 如果两个连通块不连通，则将这两个连通块合并 { union(a, b); res += w; cnt++; } } //只有当 cnt == n - 1 时才能表示已经将所有点加入到集合中，可以生成最小生成树 if (cnt < n - 1) return INF; return res; }\"]},\"182\":{\"h\":\"6. 染色法判别二分图\",\"t\":[\"二分图： 将所有点分成__两个集合__，使得__所有边__只出现在集合之间，就是 二分图\",\"性质： 一定不含有奇数环，可能包含长度为偶数的环，不一定是__连通图__。\",\"DFS思路：\",\"染色可以使用 1 和 2 区分__不同颜色__，用 0 表示 未染色\",\"遍历所有点，每次将__未染色的点__进行 dfs，默认染成 1 或 2\",\"由于某个点染色成功并不代表整个图就是二分图，因此只有某个点染色失败才能立刻 break/return，__染色失败__相当于存在两个相邻的点染成了相同的颜色\",\"时间复杂度 O(n + m)， n 表示点数，m 表示边数\",\"int n, m; //n表示点数，m表示边数 int h[N], e[M], ne[M], idx; //邻接表存储图 int color[N]; //表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 //参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i <= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; }\"]},\"183\":{\"h\":\"7. 匈牙利算法\",\"t\":[\"相关概念：\",\"匹配：在图论中，一个 [匹配] 是一个边的集合，其中任意两条边都不依附于同一个顶点。\",\"最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。\",\"完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。\",\"交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边...形成的路径叫交替路。\",\"增广路：从一个未匹配路出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。\",\"算法描述：\",\"如果你想找的妹子已经有了男朋友，\",\"你就去问问她男朋友，\",\"你有没有备胎，\",\"把这个让给我好吧\",\"多么真实而实用的算法\",\"tips：因为你要去问的都是男孩子，所以存边的时候，都是由男孩子指向女孩子\",\"时间复杂度是 O(nm)， n 表示点数，m 表示边数\",\"int n1, n2; //n1表示第一个集合中的点数，n2表示第二个集合中的点数 // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int h[N], e[M], ne[M], idx; int match[N]; //存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; //表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { //遍历所有点 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) //如果在这一轮的匹配中，这个点还未被匹配 { st[j] = true; //那就匹配并标记 //如果这个点未被匹配，且原来匹配的点能找到另一个点(下家)匹配，则匹配成功 if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i <= n1; i ++ ) { //因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化 memset(st, false, sizeof st); if (find(i)) res++; }\"]},\"184\":{\"c\":[\"模板\",\"图论\"]},\"185\":{\"h\":\"数学知识\"},\"186\":{\"h\":\"1. 质数\"},\"187\":{\"h\":\"1.1 试除法判定质数\",\"t\":[\"从小到大遍历，只判断能否被小于 sqrt(x) 的数整除。\",\"时间复杂度为 O(sqrt(n)).\",\"bool is_prime(int x) { if (x < 2) return false; for (int i = 2; i <= x / i; i++) if (x % i == 0) return false; return true; }\"]},\"188\":{\"h\":\"1.2 试除法分解质因数\",\"t\":[\"从小到大尝试 n 的所有因数，每个正整数都能够以唯一的方式表示成它的质因数的乘积。\",\"结论：n 中最多只包含一个大于 sqrt(n) 的因子。\",\"反证法证明：如果有两个大于 sqrt(n) 的因子，那么相乘会大于 n。于是我们发现只有一个大于 sqrt(n) 的因子，可以对其进行优化。如果最后 n 还是 >1，说明这就是大于 sqrt(n) 的唯一质因子，输出即可。\",\"时间复杂度为 O(log n) ~ O(sqrt(n)).\",\"void divide(int x) { for (int i = 2; i <= x / i; i++) if (x % i == 0) { int s = 0; //s表示次幂 while (x % i == 0) { x /= i; s++; } cout << i << ' ' << s << endl; //输出i的s次幂 } if (x > 1) cout << x << ' ' << 1 << endl; cout << endl; }\"]},\"189\":{\"h\":\"汇总\",\"t\":[\"// 假设输入都是正数 // 素数测试 O(√n) bool is_prime(int n) { for (int i = 2; i <= n / i; i++){ if (n % i == 0) return false; } return n != 1; } // 约数枚举 O(√n) vector<int> divisor(int n) { vector<int> res; for (int i = 1; i <= n / i; i++){ if (n % i == 0){ res.push_back(i); if (i != n / i) res.push_back(n / i); } } return res; } // 整数分解 O(√n) map<int, int> prime_factor(int n) { map<int, int> res; for (int i = 2; i <= n / i; i++){ while (n % i == 0){ ++res[i]; n /= i; } } if (n != 1) res[n] = 1; return res; }\"]},\"190\":{\"h\":\"1.3 筛法求素数\"},\"191\":{\"h\":\"1.3.1 朴素筛法（埃氏筛）\",\"t\":[\"从 2 到 n 枚举，（一个数的倍数一定是合数）筛掉它的倍数，如果该数没有被筛掉，那它就是一个质数。\",\"（1）调和级数：当 n 趋于无穷大时，1 + 1/2 + 1/3 + … + 1/n = ln n + C.\",\"（2）对朴素筛法的优化：任何一个合数都能写成几个质数相乘的形式。只需要判断 2 ~ n-1 中的所有质数，只要它不是 n 的约数，那么 n 就是一个质因数。\",\"（3）质数定理：1~n 当中有 n/ln n 个质数。\",\"（4）思路：从小到大枚举所有的质数，然后删去它们的所有的倍数，就删去了所有的合数，剩下的就是质数。\",\"时间复杂度为 O(n ln ln n).\",\"int primes[N], cnt; // primes[]存储所有素数，cnt记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (st[i]) continue; primes[cnt++] = i; for (int j = i; j <= n; j += i) //用质数把其所有的倍数都筛掉 st[j] = true; } }\"]},\"192\":{\"h\":\"1.3.2 区间筛法\",\"t\":[\"给定整数 a 和 b ，问区间 [a,b) 内有多少个素数。\",\"解法：\",\"因为 b 以内的合数的最小质因数一定不超过 b​ ，如果有 b​ 以内的素数表的话，就可以把埃氏筛法运用在 [a,b) 上了。\",\"所以先预处理好 [a,b​) 和 [a,b) 的素数表，然后从 [a,b​) 的表中筛得素数的同时，也将其倍数从 [a,b) 的表中划去，最后剩下的就是区间 [a,b) 内的素数了。\",\"#define ll long long bool is_primes[N]; bool is_primes2[N]; void get_prime(ll a, ll b) { for (int i = 0; (ll)i * i < b; i++) is_primes2[i] = true; for (int i = 0; i < b - a; i++) is_prime[i] = true; // is_primes[i - a] = true => i是素数 for (int i = 2; (ll)i * i < b; i++){ if (is_primes2[i]){ for (int j = 2 * i; (ll)j * j < b; j += i) is_primes2[j] = true; for (ll j = max(2LL, (a + i - 1) / i; j < b; j += i) is_primes[j - a] = false; } } }\"]},\"193\":{\"h\":\"1.3.3 线性筛（欧拉筛）\",\"t\":[\"核心思路：用最小质因子去筛合数。\",\"当 i % primes[j] != 0 时， 说明此时遍历到的 primes[j] 不是 i 的质因子，只可能是此时 primes[j] 的最小质因子， 所以 primes[j] * i 的最小质因子就是 primes[j].\",\"当有 i % primes[j] == 0 时， 因为我们是从小到大遍历的，说明此时的 prime[j] 是满足条件的第一个数，即找到了 primes[j] 就是 i 的最小质因子， 因此 primes[j] * i 的最小质因子也就是 primes[j]， 之后用 st[primes[j + 1] * i] = true 去筛合数时，就不是用最小质因子去更新了， 所以此时应该退出循环，避免重复筛选。\",\"时间复杂度为 O(k)\",\"int primes[N]; // primes[]存储所有素数 int cnt; //记录素数个数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i <= n; i++) { if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] <= n / i; j++) { //标记，pj一定是pj*i的最小质因子 st[primes[j] * i] = true; //从小到大遍历，如果 i%pj=0，则pj一定是i的最小公因子 if (i % primes[j] == 0) break; } } }\"]},\"194\":{\"h\":\"2. 约数\"},\"195\":{\"h\":\"2.1 试除法求所有约数\",\"t\":[\"从小到大判断，如果当前数能整除目标数，说明这个数是它的一个约数。\",\"vector<int> get_divisors(int x) { vector<int> res; //从小到大枚举n的所有约数对里面比较小的那一个 for (int i = 1; i <= x / i; i++) if (x % i == 0) { res.push_back(i); //特判最中间的数 if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; }\"]},\"196\":{\"h\":\"2.2 约数个数和约数之和\",\"t\":[\"如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\",\"约数之和\",\"#include <iostream> #include <algorithm> #include <unordered_map> #include <vector> using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin >> n; unordered_map<int, int> primes; while (n -- ) { int x; cin >> x; for (int i = 2; i <= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x > 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; } cout << res << endl; return 0; }\"]},\"197\":{\"h\":\"2.3 最大公约数与最小公倍数\",\"t\":[\"欧几里得算法（辗转相除法)：\",\"每次都让较大的数对较小数取模，可以缩小问题规模而保持最大公约数不变，然后重复(递归)这个步骤。递归边界使某数变成了0，而此时另一个数即为所求答案.\",\"最坏情况下的时间复杂度为 O(log max(x, y))。\",\"对于大多数情况，辗转相除法时间可以忽略不计。\",\"int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\",\"用两数之积除以他们的最大公约数可得最小公倍数：\",\"int lcm(int a, int b) { return a * gcd(a, b) / b; //注意乘除的先后顺序，防止溢出 }\"]},\"198\":{\"h\":\"3. 欧拉函数\"},\"199\":{\"h\":\"3.1 求欧拉函数\",\"t\":[\"欧拉函数的定义\",\"1∼N 中与 N 互质的数的个数被称为欧拉函数，记为 ϕ(N)。 若在算数基本定理中，N=p1a1​​p2a2​​...pmam​​ ，则： ϕ(N)=N×p1​p1​−1​×p2​p2​−1​×…×pm​pm​−1​\",\"//求x的欧拉函数 int phi(int x) { int res = x; for (int i = 2; i <= x / i; i++) //分解质因数 if (x % i == 0) { res = res / i * (i - 1); //用上面的公式定义求，先整除再乘 while (x % i == 0) x /= i; } if (x > 1) res = res / x * (x - 1); return res; }\"]},\"200\":{\"h\":\"3.2 筛法求欧拉函数\",\"t\":[\"思路：质数 i 的欧拉函数即为 phi[i] = i - 1：1 ~ i−1均与 i 互质，共 i−1个。 phi[primes[j] * i] 分为两种情况： ① i % primes[j] == 0 时：primes[j] 是 i 的最小质因子，也是 primes[j] * i 的最小质因子，因此 1 - 1 / primes[j] 这一项在 phi[i] 中计算过了，只需将基数 N 修正为 primes[j] 倍，最终结果为 phi[i] * primes[j] 。 ② i % primes[j] != 0：primes[j] 不是 i 的质因子，只是 primes[j] * i 的最小质因子，因此不仅需要将基数 N 修正为 primes[j] 倍，还需要补上 1 - 1 / primes[j] 这一项，因此最终结果 phi[i] * (primes[j] - 1) 。\",\"int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i <= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] <= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } }\"]},\"201\":{\"h\":\"4. 快速幂\",\"t\":[\"基本思路：\",\"预处理出 a20,a21,a22,...,a2logk 这 k 个数\",\"将 ab 用 a20,a21,a22,...,a2logk 这 k 个数来组合，即组合成 ab=a2x1​×a2x2​×...×a2xt​=a2x1​+2x2​+...+2xt​​\",\"即用二进制来表示\",\"k&1 就是判断 k 的二进制表示中第 0 位上的数是否为 1，若为 1，则为 true，反之为 false.\",\"k&1 也可以用来判断奇数和偶数，b&1 = true 时为奇数，b&1 = false 时为偶数。\",\"求 ak mod p， 时间复杂度为 O(logk)\",\"int qmi(int a, int k, int p) { int res = 1 % p; while (k) { if (k&1) res = res * a % p; k >>= 1; a = a * a % p; } return res; }\"]},\"202\":{\"h\":\"5. 扩展欧几里得算法\"},\"203\":{\"h\":\"裴蜀定理\",\"t\":[\"若 a, b 是整数,且 gcd(a,b) = d ，那么对于任意的整数 x, y, ax+by 都一定是 d 的倍数。特别地，一定存在整数 x, y，使 ax + by = d 成立。\",\"它的一个重要推论是：\",\"a, b 互质的充分必要条件是存在整数 x, y 使 ax + by = 1 .\",\"用于求解方程 ax+by=gcd(a,b)​ 的解\",\"当 b=0 时，ax+by=a 所以有 x=1,y=0\",\"当 b=0 时 ，因为 $gcd(a, b) = gcd(b, a % b) $\",\"​ 所以 x=y′,y=x′−[a/b]∗y′\",\"求整数 x 和 y 使得 ax+by=1\",\"如果 gcd(a,b)=1，显然无解。反之，若 gcd(a,b)=1 ，则可以通过扩展欧几里得来求解。\",\"事实上，一定存在整数对 (x,y) 使得 ax+by=gcd(a,b) .\",\"// 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; }\"]},\"204\":{\"h\":\"6. 中国剩余定理\",\"t\":[\"给定 2n 个整数 a1​,a2​,...,an​ 和 m1​,m2​,...,mn​ ，求一个最小的非负整数 x ，满足 ∀i∈[1,n],x≡mi​(modai​) .\",\"输入格式\",\"第 1 行包含整数 n。\",\"第 2...n+1 行：每 i+1 行包含两个整数 ai​ 和 mi​ ，数之间用空格隔开。\",\"输出格式\",\"输出最小非负整数 x ，如果 x 不存在，则输出 -1.\",\"如果存在 x ，则数据保证 x 一定在 64 位整数范围内。\",\"思路\",\"对于每两个式子，将其等价转换\",\"用扩展欧几里得算法找出一组解\",\"并且判断是否有解\",\"找到最小整数解\",\"等效替代\",\"相当于是每次考虑合并两个式子，将这 n 个式子合并 n - 1 次后变为一个式子。最后剩下的式子就满足我们的答案。\",\"#include <iostream> #include <algorithm> #define ll long long using namespace std; //扩展欧几里得 ll exgcd(ll a, ll b, ll &x, ll &y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } //可能为负数，取模加模再取模 ll inline mod(ll a, ll b) { return ((a % b) + b) % b; } int main() { ll n; scanf(\\\"%lld\\\", &n); ll a1, m1; scanf(\\\"%lld%lld\\\", &a1, &m1); for (ll i = 1; i < n; i++) { ll a2, m2, k1, k2; scanf(\\\"%lld%lld\\\", &a2, &m2); ll d = exgcd(a1, -a2, k1, k2); if ((m2 - m1) % d) { puts(\\\"-1\\\"); return 0; } k1 = k1 * (m2 - m1) / d; k1 = mod(k1, abs(a2 / d)); m1 = m1 + k1 * a1; a1 = abs(a1 / d * a2); } printf(\\\"%lld\\\\n\\\", m1); return 0; }\"]},\"205\":{\"h\":\"7. 高斯消元\",\"t\":[\"给定一个包含 n 个方程 n 个未知数的线性方程组。方程组中的系数为实数。\",\"要求求解这个方程组。\",\"（线性代数方法解非齐次线性方程组）\",\"前置知识：初等行（列）变换\",\"把某一行乘一个非00的数 (方程的两边同时乘上一个非00数不改变方程的解)\",\"交换某两行 (交换两个方程的位置)\",\"把某行的若干倍加到另一行上去 （把一个方程的若干倍加到另一个方程上去）\",\"高斯消元适用解法\",\"通过初等行变换把 增广矩阵 化为 阶梯型矩阵 并回代得到方程的解\",\"适用于求解包含 n 个方程，n 个未知数的多元线性方程组\",\"算法步骤\",\"枚举每一列c,\",\"找到当前列绝对值最大的一行\",\"用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）\",\"用初等行变换(1) 将该行的第一个数变成 11 （其余所有的数字依次跟着变化）\",\"用初等行变换(3) 将下面所有行的当且列的值变成 0\",\"时间复杂度为 O(n^3)\",\"const int eps = 1e-6; //控制精度，小于eps视为0 int a[N][N]; // a[N][N]是增广矩阵 int gauss() { int r, c; //行row,列col for (r = 0, c = 0; c < n; c ++ ) { int t = r; // 找到绝对值最大的行 for (int i = r; i < n; i ++ ) if (abs(a[i][c]) > abs(a[t][c])) t = i; if (abs(a[t][c]) < eps) continue; // 将绝对值最大的行换到最顶端 for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); // 将当前行的首位变成1 for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; // 用当前行将下面所有的列消成0 for (int i = r + 1; i < n; i ++ ) if (fabs(a[i][c]) > eps) for (int j = n; j >= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r < n) { for (int i = r; i < n; i ++ ) if (fabs(a[i][n]) > eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i >= 0; i -- ) for (int j = i + 1; j < n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 }\"]},\"206\":{\"h\":\"8. 求组合数\"},\"207\":{\"h\":\"8.1 递推法求组合数\",\"t\":[\"适用题型：\",\"给定两个正整数 a 与 b ，求 Cab​mod(1e9+7)\",\"递推式：\",\"Cab​=Ca−1b−1​+Ca−1b​\",\"// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i < N; i++) for (int j = 0; j <= i; j++) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\"]},\"208\":{\"h\":\"8.2 通过预处理逆元的方式求组和数\",\"t\":[\"用 infact(a!) 表示 a! 的逆元\",\"Cab​=b!∗(a−b)!a!​=a!∗infact(b!)∗infact((a−b)!)\",\"快速幂求逆元\",\"费马小定理：如果 p 是一个质数，而整数 a 不是 p 的倍数，则有 ap−1≡1(modp) .\",\"乘法逆元的定义\",\"若整数 b, m 互质，并且对于任意的整数 a，如果满足 b | a，则存在一个整数 x，使得 a / b ≡ a * x (mod m) ，则称 x 为 b 的模 m 乘法逆元，记为 b−1(modm) .\",\"b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，bm−2 即为 b 的乘法逆元。\",\"结论：当 b 与 m 互质时，b 的乘法逆元为 bm−2.\",\"​ 当 b 为 m 的倍数时，b 的逆元不存在。b∗x%m==0 ，b 乘任意一个 x % m 一定等于 0.\",\"首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i < N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; }\"]},\"209\":{\"h\":\"8.3 卢卡斯(Lucas)定理求组合数\",\"t\":[\"给定 n 组询问，每组询问给定三个整数 a,b,p，其中 p 是质数，请你输出 Cab​modp 的值。\",\"Lucas 定理：Cab​≡Ca%pb%p​∗Cpa​pb​​(modp)\",\"Cba​=(a−b!)∗b!a!​=(a−b)∗(a−b−1)∗…∗1∗b!a∗(a−1)∗(a−2)∗…∗(a−b+1)∗(a−b)∗…∗1​=b!a∗(a−1)∗(a−2)∗…(a−b+1)​\",\"因此可以递推的每次乘 a 然后 除以 b ，因为从 a 到 a - b + 1，所以是乘 b 次。\",\"若p是质数，则对于任意整数 1 <= m <= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k, int p) // 快速幂模板 { int res = 1 % p; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a < b) return 0; LL x = 1, y = 1; // x是分子，y是分母 for (int i = a, j = 1; j <= b; i --, j ++ ) { x = (LL)x * i % p; y = (LL)y * j % p; } return x * (LL)qmi(y, p - 2, p) % p; } int lucas(LL a, LL b, int p) { if (a < p && b < p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } int main() { int n; cin >> n; while (n--) { ll a, b, p; cin >> a >> b >> p; cout << lucas(a, b, p) << endl; } return 0; }\"]},\"210\":{\"h\":\"8.4 分解质因数法求组合数\",\"t\":[\"输入 a, b，求 Cab​ 的值。\",\"方法：对阶乘分解质因数之后，用高精度相乘即可。\",\"步骤：\",\"筛素数\",\"求每个质数的次数\",\"用高精度乘法把所有质因子乘上\",\"当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i <= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] <= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n!中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector<int> mul(vector<int> a, int b) // 高精度乘低精度模板 { vector<int> c; int t = 0; for (int i = 0; i < a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i < cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector<int> res; res.push_back(1); for (int i = 0; i < cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j < sum[i]; j ++ ) res = mul(res, primes[i]);\"]},\"211\":{\"h\":\"8.5 卡特兰数\",\"t\":[\"给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\"]},\"212\":{\"h\":\"9. 容斥原理\",\"t\":[\"给定一个整数 n 和 m 个不同的质数 p1​,p2​,...,pm​ .\",\"请你求出 1 ~ n 中能被 p1​,p2​,...,pm​​ 中至少一个数整除的整数有多少个。\",\"记 Si​ 为 1 ~ n 中能整除 pi​​ 的集合，根据容斥原理，所有数的个数为各个集合的并集，计算公式如下\",\"#include<iostream> using namespace std; #define ll long long const int N = 20; int p[N], n, m; int main() { cin >> n >> m; for(int i = 0; i < m; i++) cin >> p[i]; int res = 0; //枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合) for(int i = 1; i < 1 << m; i++) { int t = 1; //选中集合对应质数的乘积 int s = 0; //选中的集合数量 //枚举当前状态的每一位 for(int j = 0; j < m; j++){ //选中一个集合 if(i >> j & 1){ //乘积大于n, 则n/t = 0, 跳出这轮循环 if((LL)t * p[j] > n){ t = -1; break; } s++; //有一个1，集合数量+1 t *= p[j]; } } if(t != -1) { if (s % 2) //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量 res += n / t; else //反之则为 -1 res -= n / t; } } cout << res << endl; return 0; }\"]},\"213\":{\"h\":\"10. 博弈论\"},\"214\":{\"h\":\"10.1 NIM游戏\",\"t\":[\"必胜状态和必败状态\",\"必胜状态，先手进行__某一个操作__，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即__先手可以走到某一个必败状态__。\",\"必败状态，先手__无论如何操作__，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即__先手走不到任何一个必败状态__。\",\"给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\",\"我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\",\"定理： NIM博弈先手必胜，当且仅当 a1 ^ a2 ^ … ^ an != 0\",\"#include <iostream> #include <algorithm> using namespace std; int main() { int n; cin >> n; int res = 0; while (n--) { int x; cin >> x; res ^= x; //每次异或操作 } if (res) puts(\\\"Yes\\\"); else puts(\\\"No\\\"); return 0; }\"]},\"215\":{\"h\":\"10.2 公平组合游戏ICG\",\"t\":[\"若一个游戏满足：\",\"由两名玩家交替行动；\",\"在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\",\"不能行动的玩家判负；\",\"则称该游戏为一个公平组合游戏。\",\"NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件 2 和条件 3 。\"]},\"216\":{\"h\":\"10.3 有向图游戏\",\"t\":[\"给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\"]},\"217\":{\"h\":\"10.4 Mex运算\",\"t\":[\"设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\"]},\"218\":{\"h\":\"10.5 SG游戏\",\"t\":[\"在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\"]},\"219\":{\"h\":\"10.6 有向图游戏的和\",\"t\":[\"设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\",\"定理\",\"有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\"]},\"220\":{\"c\":[\"模板\",\"数学\"]},\"221\":{\"h\":\"数据结构\"},\"222\":{\"h\":\"1. 数组模拟链表\"},\"223\":{\"h\":\"1.1 单链表\",\"t\":[\"也称静态链表（邻接表：n 个链表，主要应用：存储图和树）单链表只能存储当前节点的值和指向下一节点的指针，无法存储上一节点\",\"// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; //-1表示不存在， idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a,; ne[idx] = head,; head = idx ++ ; } // 将一个新的节点x插入下标是k的后面 void add(int k, int x){ e[idx] = x; // 1.先存值 ne[idx] = ne[k]; // 2.新节点的下一节点指向 k 指向的下一节点 ne[k] = idx; // 3.k指向的下一节点指向新节点 idx++; // 4.index指向下一个指针 } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将下标是k的点后面的点删掉 void remove(int x){ // 直接将其指向下下个节点，在算法竞赛中一般不需要考虑删除的那个节点该如何处理 ne[k] = ne[ne[k]]; }\"]},\"224\":{\"h\":\"1.2 双链表\",\"t\":[\"（主要用来优化某些问题）有两个指针，一个指向前，一个指向后。\",\"// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { // 0是左端点，1是右端点 r[0] = 1; l[1] = 0; idx = 2; // 0和1都被占用了，所以idx从2开始 } // 在节点k的右边插入一个数x // 如果要插在k的左边，就把k改为l[k] void insert(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx++; } // 删除第k个点 void remove(int k) { l[r[k]] = l[k]; r[l[k]] = r[k]; }\"]},\"225\":{\"h\":\"2. 栈\",\"t\":[\"先进后出\"]},\"226\":{\"h\":\"2.1 普通栈\",\"t\":[\"// tt表示栈顶 int stk[N]; //栈数组从0开始 int tt = 0; // 向栈顶插入一个数 stk[++tt] = x; // 从栈顶弹出一个数 tt--; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt > 0) not empty { } else empty\"]},\"227\":{\"h\":\"2.1 单调栈\",\"t\":[\"给定一个序列，找到每一个数左边离他最近的比它小的数。\",\"性质：如果 ax​≥ay​,x<y，那么 ax​ 永远不会被输出，可以删掉。比如 a3​≥a5​，那么 a3​ 永远不会被输出。\",\"常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i <= n; i++) { while (tt && check(stk[tt], i)) tt--; stk[++tt] = i; }\"]},\"228\":{\"h\":\"3. 队列\",\"t\":[\"先进先出，后进后出\"]},\"229\":{\"h\":\"3.1 普通队列\",\"t\":[\"// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[++tt] = x; // 从队头弹出一个数 hh++; // 队头的值 q[hh]; //同理队尾 q[tt] // 判断队列是否为空 if (hh <= tt) not empty { } else empty\"]},\"230\":{\"h\":\"3.2 单调队列\",\"t\":[\"求滑动窗口里的最大值和最小值。用单调队列来优化。\",\"步骤：\",\"判断队头是否已经滑出窗口\",\"判断当前元素与队尾元素是否满足单调性问题\",\"若满足条件，弹出队尾元素，将当前元素加入队尾\",\"如果窗口满足条件，则输出结果\",\"【注意】队列里面存的是下标\",\"常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i < n; i++) { //判断队头是否滑出窗口 if (hh <= tt && check_out(q[hh])) hh++; //判断当前元素与队尾元素是否满足单调性问题 while (hh <= tt && check(q[tt], i)) tt--; q[++tt] = i; //将当前元素加入到队尾 //如果满足条件再输出结果 if() }\"]},\"231\":{\"h\":\"4. KMP\",\"t\":[\"关于为什么求 next 数组和匹配的操作类似： 因为本质是一样的：对于 S 串每一个特定的下标 i，在满足 s[i-j+1，i]=p[0，j] 的前提下，我们需要找出 j 的最大值。 唯一不同的在于，求 next 数组时，我们关心对于每个不同的下标 i,j 能走多远；匹配时，我们只关心 j 是否走到末尾.\",\"非常有意思的说法是： 求 next 数组时，对于每个 i：\\\"j走到哪了呀？我用数组记录一下你的位置\\\" 匹配时，对于每个 i：\\\"到终点和我说声，匹配完我输出一下，没事别叫我。\\\"\",\"#include <iostream> using namespace std; const int N = 100010, M = 10010; // N为模式串长度，M匹配串长度 int n, m; int ne[M]; // next[]数组，避免和头文件next冲突 char s[N], p[M]; // s为模式串， p为匹配串 int main() { cin >> n >> s+1; cin >> m >> p+1; //下标从1开始 // 求next[]数组 for (int i = 2, j = 0; i <= m; i++) { while (j && p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; } // 匹配操作 for (int i = 1, j = 0; i <= n; i++) { while (j && s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == m) // 满足匹配条件，打印开头下标, 从0开始 { // 匹配完成后的具体操作 // 如：输出以0开始的匹配子串的首字母下标 // printf(\\\"%d \\\", i - m); (若从1开始，加1) j = ne[j]; // 再次继续匹配 } } return 0; }\"]},\"232\":{\"h\":\"5. Trie树\",\"t\":[\"Trie 树又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构。\",\"存储形式如下：\",\"Trie树存储形式\",\"// son[][]存储树中每个节点的子节点，因为存的都是英文字母，最多有26个 int son[N][26]; int cnt[N]; // cnt[]存储以每个节点结尾的单词数量 int idx; // 存储当前用到的下标，0号点既是根节点，又是空节点 // 插入一个字符串 void insert(char *str) { int p = 0; // 字符串以'0'结尾，所以可以用str[i]结束 for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; }\"]},\"233\":{\"h\":\"6. 并查集\"},\"234\":{\"h\":\"6.1 朴素并查集\",\"t\":[\" int p[N]; // 存储每个点的祖宗节点 int rank[N]; // 树的高度 // 初始化，假定节点编号是1~n void init(int n) { for (int i = 1; i <= n; i++){ p[i] = i; rank[i] = 0; } } // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 合并x和y所在的两个集合： void union(int x, int y) { int px = find(x), py = find(y); if (rank[px] < rank[py]){ p[px] = py; rank[py] += rank[px]; } else { p[py] = px; rank[px] += rank[py]; } }\"]},\"235\":{\"h\":\"6.2 维护size的并查集\",\"t\":[\" int p[N], size[N]; // p[]存储每个点的祖宗节点 // size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);\"]},\"236\":{\"h\":\"6.3 维护到祖宗节点距离的并查集\",\"t\":[\" int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i <= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\"]},\"237\":{\"h\":\"7. 堆\",\"t\":[\"1、作用：维护一个数组集合\",\"2、堆是一棵（完全）二叉树，长得非常平衡，除最后一层节点，所有节点均不为空，最后一层节点从左向右排列，根节点小于等于左右两个子节点，即小根堆。\",\"3、存储：用一个一维数组存储树，下标从 1 开始。其中元素 x 的左儿子为 2x，x 的右儿子为 2x+1.\",\"4、5个基本操作\",\"heap 表示堆，size 表示大小\",\"1. 插入一个数 heap[++size] = x; up(size); 2. 求集合当中的最小值 heap[1]; 3. 删除最小值 heap[1] = heap[size]; size--; down(1); 4. 删除任意一个元素 heap[k] = heap[size]; size--; down(k); up(k); //down和up只会执行其中一个 5. 修改任意一个元素 heap[K] = x; down(k); up(k);\",\"// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) // 跟两个儿子比较大小 { // t表示该元素与它的左、右儿子相比最小的元素，初始化为它自身 int t = u; // 若左二子小于它，则最小的数为左二子 if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2; // 若右儿子小于它，则最小的数为右儿子 if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1; // 如果它本身不是最小的数，则往下沉，继续down()操作 if (u != t) { heap_swap(u, t); down(t); } } void up(int u) //只需要跟一个父亲比较大小就行 { // 如果比父节点大，就交换位置，上浮 while (u / 2 && h[u] < h[u / 2]) { heap_swap(u, u / 2); u >>= 1; //x /= 2 } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i);\"]},\"238\":{\"h\":\"8. 哈希表\"},\"239\":{\"h\":\"8.1 拉链法\",\"t\":[\"int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { //哈希函数离散化 int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; }\"]},\"240\":{\"h\":\"8.2 开放寻址法\",\"t\":[\"int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { // 哈希函数 int k = (x % N + N) % N; while (h[k] != null && h[k] != x) { k++; // 如果到了末尾，那么再从头开始查找 if (k == N) k = 0; } return k; }\"]},\"241\":{\"h\":\"8.3 字符串哈希\",\"t\":[\"核心思想：将字符串看成 P 进制数，P 的经验值是 131 或 13331，取这两个值的冲突概率低 小技巧：取模的数用 2^64，这样直接用 unsigned long long 存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N]; // h[k]存储字符串前k个字母的哈希值 ULL p[N]; // p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i <= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }\"]},\"242\":{\"h\":\"9. C++ STL简介\",\"t\":[\"vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair<int, int> first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string, 字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列，本身就是有序的，默认按 key 排序 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 没找到则返回end() count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 (3) 例如：s.erase(unique(s.begin(), d.end()), s,end()) 将一个容器中重复的元素删除，对字符串也适用 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() 用 first 和 second 查找每个键值对的元素 [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 都可以是‘哈希表’ 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset<10000> s; ~, &, |, ^ >>, << ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反\"]},\"243\":{\"h\":\"10. 常用库函数\",\"t\":[\"1. reverse 翻转\",\"翻转一个 vector ：\",\"reverse(a.begin(), a.end());\",\"翻转一个数组，元素存放在下标 1 ~ n ：\",\"reverse(a + 1, a + n + 1);\",\"2. unique 去重\",\"返回去重（只去掉相邻的相同元素）之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。\",\"把一个 vector 去重：\",\"int m = unique(a.begin(), a.end()) – a.begin();\",\"把一个数组去重，元素存放在下标 1 ~ n：\",\"int m = unique(a + 1, a + n + 1) – (a + 1);\",\"3. random_shuffle 随机打乱： 用法与 reverse 相同。\",\"4. sort 排序：\",\"对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载 “小于号” 运算符。\",\"把一个 int 数组（元素存放在下标 1 ~ n ）从大到小排序，传入比较函数：\",\"int a[MAX_SIZE]; bool cmp(int a, int b) { return a > b; } sort(a + 1, a + n + 1, cmp);\",\"从大到小排序需要加入第三个参数：\",\"sort(a.begin(), a.end(), greater<int>());\",\"对自定义的结构体 vector 排序，重载 \\\"小于号\\\" 运算符：\",\"struct node { int id, x, y; }; vector<node> a; bool operator < (const node &a, const node &b) { return a.x < b.x || a.x == b.x && a.y < b.y; } sort(a.begin(), a.end());\",\"5. lower_bound / upper_bound 二分：\",\"lower_bound 的第三个参数传入一个元素 x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于 x 的元素的位置的迭代器（指针）。\",\"upper_bound 的用法和 lower_bound 大致相同，唯一的区别是查找第一个大于 x 的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。\",\"在有序 int 数组（元素存放在下标 1 ~ n ）中查找大于等于 x 的最小整数的下标：\",\"int i = lower_bound(a + 1, a + 1 + n, x) - a;\",\"在有序 vector<int> 中查找小于等于 x 的最大整数（假设一定存在）：\",\"int y = *--upper_bound(a.begin(), a.end(), x);\",\"找不到则返回最后一个元素的下标+1，是越界的。\"]},\"244\":{\"c\":[\"模板\",\"数据结构\"]},\"245\":{\"h\":\"贪心\"},\"246\":{\"h\":\"1. 区间问题\"},\"247\":{\"h\":\"1.1 区间选点\",\"t\":[\"给定 N个闭区间 ，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node &W) const { return r < W.r; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; //按右端点从小到大排序 sort(arr + 1, arr + 1 + n); int ans = 0; int R = -2e9; //R表示上一连续区间的最右端的点 for (int i = 1; i <= n; i++) { if (arr[i].l > R) //如果不能覆盖掉右端点，则点数+1，更新右端点 { ans++; R = arr[i].r; } } cout << ans << endl; return 0; }\"]},\"248\":{\"h\":\"1.2 最大不相交区间数量\",\"t\":[\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct node { int l, r; bool operator < (const node & W) const { return l < W.l; } } arr[N]; int main() { int n; cin >> n; for (int i = 1; i <= n; i++) cin >> arr[i].l >> arr[i].r; sort(arr + 1, arr + 1 + n); int res = 1, R = arr[1].r; for (int i = 2; i <= n; i++){ if (arr[i].l <= R) R = min(R, arr[i].r); else { res++; R = arr[i].r; } } cout << res << endl; return 0; }\"]},\"249\":{\"h\":\"1.3 区间分组\",\"t\":[\"给定 N个闭区间 ，要求分成若干组，使得每组内部区间两两之间没有交集，求分成的最小组数。\",\"#include <iostream> #include <algorithm> #include <queue> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; //重载小于运算符，按左端点从小到大排序 bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); //用一个小根堆来维护所有组的右端点 priority_queue<int, vector<int>, greater<int>> heap; for (int i = 0; i < n; i++){ auto t = Range[i]; if (heap.empty() || heap.top() >= t.l) //放不进去则新开一组 heap.push(t.r); else { heap.pop(); heap.push(t.r); //放进去并更新右端点 } } cout << heap.size() << endl; return 0; }\"]},\"250\":{\"h\":\"1.4 区间覆盖\",\"t\":[\"给定 N 个闭区间，以及一个线段区间，请你选择尽量少的区间，将指定线段区间完全覆盖。\",\"#include <iostream> #include <algorithm> using namespace std; const int N = 1e5 + 10; struct Range { int l, r; bool operator < (const Range &W) const { return l < W.l; } } Range[N]; int main() { int n; int L, R; cin >> L >> R; cin >> n; for (int i = 0; i < n; i++) cin >> Range[i].l >> Range[i].r; sort(Range, Range + n); int res = 0; bool f = false; for (int i = 0; i < n; ){ //依次遍历每个区间 int j = i, r = -2e9; //j表示第几个区间 //遍历所有左端点在L的左边的区间，选出右端点最大的 while (j < n && Range[j].l <= L){ r = max(r, Range[j].r); j++; } if (r < L){ //如果所有右端点都小于L，则无解 res = -1; break; } res++; if (r >= R){ //循环出口 f = true; break; } //更新端点和遍历的区间 L = r; i = j; } if (!f) res = -1; cout << res << endl; return 0; }\"]},\"251\":{\"h\":\"1.5 区间合并\",\"t\":[\"#include <iostream> #include <cstdio> #include <algorithm> #include <vector> #define PII pair<int, int> using namespace std; const int N = 1e5 + 5; int n; vector <PII> nums, ans; void merge(vector<PII> &nums){ //按左端点排序 sort(nums.begin(), nums.end()); //l代表区间左端点，r代表区间右端点 int l = -2e9, r = -2e9; for (auto num : nums){ //如果两区间无法合并 if (r < num.first){ if (l != -2e9) ans.push_back({l, r});//将新的区间放入ans数组中 l = num.first, r = num.second;//更新区间 } //若两区间部分存在交集，小的合并到大的中 else r = max(r, num.second); } if (l != -2e9) ans.push_back({l, r}); } int main() { cin >> n; for (int i = 0; i < n; i++){ int l, r; cin >> l >> r; nums.push_back({l, r}); } merge(nums); cout << ans.size() << endl; return 0; }\"]},\"252\":{\"c\":[\"模板\",\"贪心\"]},\"253\":{\"h\":\"B站评论系统架构设计\",\"t\":[\"转载自哔哩哔哩技术，原文链接：B站评论系统架构设计\"]},\"254\":{\"h\":\"01 背景\",\"t\":[\"维基百科对「评论」的定义是：评论是人们对出版物、服务或公司的评估，例如电影（电影评论）、电子游戏（视频游戏评论）、音乐制作（对作品录音作品的音乐评论）、图书（书评）、硬件，如汽车、家用电器或电子计算机、商业软件、活动或表演，例如音乐会、戏剧、音乐剧、舞蹈或艺术展览。除了批判性评论之外，评论的作者还可以对作品进行内容分级以表明其相对价值。\",\"在B站，UP主每天都会发布海量的视频、动态、专栏等内容，随之而来的是弹幕和评论区的各种讨论。播放器中直接滚动播放的弹幕，如同调味剂，重在提升视频观看体验；而点进评论区，相对而言评论文本更长，内容的观点、形式都更丰富，更像是饭后甜点。\",\"随着业务不断发展，B站的评论系统逐渐组件化、平台化；通过持续演进架构设计，管理不断上升的系统复杂度，从而更好地满足各类用户的需求。\"]},\"255\":{\"h\":\"02 基础功能模块\",\"t\":[\"评论的基础功能模块是相对稳定的。\",\"1. 发布评论：支持无限盖楼回复。\",\"2. 读取评论：按照时间、热度排序；显示评论数、楼中楼等。\",\"3. 删除评论：用户删除、UP主删除等。\",\"4. 评论互动：点赞、点踩、举报等。\",\"5. 管理评论：置顶、精选、后台运营管理（搜索、删除、审核等）。\",\"结合B站以及其他互联网平台的评论产品特点，评论一般还包括一些更高阶的基础功能：\",\"1. 评论富文本展示：例如表情、@、分享链接、广告等。\",\"2. 评论标签：例如UP主点赞、UP主回复、好友点赞等。\",\"3. 评论装扮：一般用于凸显发评人的身份等。\",\"4. 热评管理：结合AI和人工，为用户营造更好的评论区氛围。\"]},\"256\":{\"h\":\"03 架构设计\",\"t\":[\"评论是主体内容的外延。因此一般会作为一个独立系统拆分设计。\"]},\"257\":{\"h\":\"3.1 架构设计 - 概览\",\"t\":[\"图片\"]},\"258\":{\"h\":\"3.2 架构设计 - reply-interface\",\"t\":[\"reply-interface 是评论系统的接入层，主要服务于两种调用者：一是客户端的评论组件，二是基于评论系统做二次开发或存在业务关联的其他业务后端。\",\"面向移动端/WEB场景，设计一套基于视图模型的API，利用客户端提供的布局能力，BFF层负责组织业务数据模型，并转换为视图模型，编排后下发给客户端。\",\"面向服务端场景，设计的API需要体现清晰的系统边界，最小可用原则对外提供数据，同时做好安全校验和流量控制。\",\"图片\",\"对评论业务来说，业务数据模型是最为复杂的。B站评论系统历史悠久，承载的功能模块相当之多，其中最核心的是发布类接口以及列表类接口，一写一读，数据字段多、依赖服务多、调用关系复杂，特别是一些依赖的变更，容易造成整个系统的腐化。\",\"因此，我们将整个业务数据模型组装，分为两个步骤，一是服务编排，二是数据组装。服务编排拆分为若干个层级，同一层级的可以并发调用，前置依赖较多的可以流水线调用，结构性提升了复杂调用场景下的接口性能下限；针对不同依赖服务所提供的 SLA 不同，设置不同的降级处理、超时控制和服务限流方案，保证少数弱依赖抖动甚至完全不可用情况下评论服务可用。数据组装在服务编排之后执行，例如在批量查询评论发布人的粉丝勋章数据之后，将其转换、组装到各个评论卡片之中。\"]},\"259\":{\"h\":\"3.3 架构设计 - reply-admin\",\"t\":[\"评论管理服务层，为多个内部管理后台提供服务。运营人员的数据查询具有：\",\"1. 组合、关联查询条件复杂；\",\"2. 刚需关键词检索能力；\",\"3. 写后读的可靠性与实时性要求高等特征。\",\"此类查询需求，ES 几乎是不二选择。但是由于业务数据量较大，需要为多个不同的查询场景建立多种索引分片，且数据更新实时性不高。因此，我们基于 ES 做了一层封装，提供统一化的数据检索能力，并结合在线数据库刷新部分实时性要求较高的字段。\",\"图片\"]},\"260\":{\"h\":\"3.4 架构设计 - reply-service\",\"t\":[\"评论基础服务层，专注于评论功能的原子化实现，例如查询评论列表、删除评论等。一般来说，这一层是较少做业务逻辑变更的，但是需要提供极高的可用性与性能吞吐。因此，reply-service 集成了多级缓存、布隆过滤器、热点探测等性能优化手段。\",\"图片\"]},\"261\":{\"h\":\"3.5 架构设计 - reply-job\",\"t\":[\"评论异步处理层，主要有两个职责：\",\"1. 与 reply-service 协同，为评论基础功能的原子化实现，做架构上的补充。\",\"为什么基础功能的原子化实现需要架构的补充呢？最典型的案例就是缓存的更新。一般采用 Cache Aside 模式，先读缓存，再读DB；缓存的重建，就是读请求未命中缓存穿透到DB，从DB读取到内容之后反写缓存。这一套流程对外提供了一个原子化的数据读取功能。但由于部分缓存数据项的重建代价较高，比如评论列表（由于列表是分页的，重建时会启用预加载），如果短时间内多个服务节点的大量请求缓存未命中，容易造成DB抖动。解决方案是利用消息队列，实现「单个评论列表，只重建一次缓存」。归纳而言，所谓架构上的补充，即是「用单线程解决分布式无状态服务的共性问题」。另一方面，reply-job 还作为数据库 binlog 的消费者，执行缓存的更新操作。\",\"图片\",\"2. 与 reply-interface 协同，为一些长耗时/高吞吐的调用做异步化/削峰处理。\",\"诸如评论发布等操作，基于安全/策略考量，会有非常重的前置调用逻辑。对于用户来说，这个长耗时几乎是不可接受的。同时，时事热点容易造成发评论的瞬间峰值流量。因此，reply-interface 在处理完一些必要校验逻辑之后，会通过消息队列送至 reply-job 异步处理，包括送审、写DB、发通知等。同时，这里也利用了消息队列的「有序」特性，将单个评论区内的发评串行处理，避免了并行处理导致的一些数据错乱风险。那么异步处理后用户体验是如何保证的呢？首先是C端的发评接口会返回展示新评论所需的数据内容，客户端据此展示新评论，完成一次用户交互。若用户重新刷新页面，因为发评的异步处理端到端延迟基本在2s以内，此时所有数据已准备好，不会影响用户体验。\",\"一个有趣的问题是，早年间评论显示楼层号，楼层号实际是计数器，且在一个评论区范围内不能出现重复。因此，这个楼层发号操作必须是在一个评论区范围内串行的（或者用更复杂的锁实现），否则两条同时发布的评论，获取的楼层号就是重复的。而分布式部署+负载均衡的网关，处理发评论请求是无法实现这种串行的，因此需要放到消息队列中处理。\"]},\"262\":{\"h\":\"04 存储设计\"},\"263\":{\"h\":\"4.1 数据库设计\",\"t\":[\"结合评论的产品功能要求，评论需要至少两张表：首先是评论表，主键是评论 id，关键索引是评论区 id；其次是评论区表，主键是评论区 id，平台化之后增加一个评论区 type 字段，与评论区 id 组成一个“联合主键”。\",\"由于评论内容是大字段，且相对独立、很少修改，因此独立设计第3张表。主键也是评论 id。\",\"评论表和评论区表的字段主要包括4种：\",\"1. 关系类，包括发布人、父评论等，这些关系型数据是发布时已经确定的，基本不会修改。\",\"2. 计数类，包括总评论数、根评论数、子评论数等，一般会在有评论发布或者删除时修改。\",\"3. 状态类，包括评论/评论区状态、评论/评论区属性等，评论/评论区状态是一个枚举值，描述的是正常、审核、删除等可见性状态；评论/评论区属性是一个整型的 bitmap，可用于描述评论/评论区的一些关键属性，例如UP主点赞等。\",\"4. 其他，包括 meta 等，可用于存储一些关键的附属信息。\",\"评论回复的树形关系，如下图所示：\",\"图片\",\"以评论列表的访问为例，我们的查询SQL可能是（已简化）：\",\"1. 查询评论区基础信息：\",\"SELECT * FROM subject WHERE obj_id=? AND obj_type=?\",\"2. 查询时间序一级评论列表：\",\"SELECT id FROM reply_index WHERE obj_id=? AND obj_type=? AND root=0 AND state=0 ORDER BY floor=? LIMIT 0,20\",\"3. 批量查询根评论基础信息：\",\"SELECT * FROM reply_index,reply_content WHERE rpid in (?,?,...)\",\"4. 并发查询楼中楼评论列表：\",\"SELECT id FROM reply_index WHERE obj_id=? AND obj_type=? AND root=? ORDER BY like_count LIMIT 0,3\",\"5. 批量查询楼中楼评论基础信息：\",\"SELECT * FROM reply_index,reply_content WHERE rpid in (?,?,...)\",\"产品形态上，单个页面只有二级列表（更多嵌套层次，对应嵌套多次点击），且评论计数也只有两级。若回复数也要无限套娃，则一条子评论的发布，需要级联更新所有的父评论的回复数，当前的数据库设计不能满足该需求。\",\"再者，产品侧定义是，若一级评论被删除，其回复也等价于全部删除，若直接删除，此时也可能出现写放大。因此结合查询逻辑，可以不对回复做更新操作，但是评论区的计数更新操作，需要多减去该一级评论的回复数。\",\"评论系统对数据库的选型要求，有两个基本且重要的特征：\",\"1. 必须有事务；\",\"2. 必须容量大。\",\"一开始，我们采用的是MySQL分表来满足这两个需求。但随着B站社区破圈起量，原来的MySQL分表架构很快到达存储瓶颈。于是从2020年起，我们逐步迁移到TiDB，从而具备了水平扩容能力。\"]},\"264\":{\"h\":\"4.2 缓存设计\",\"t\":[\"我们基于数据库设计进行缓存设计，选用 redis 作为主力缓存。主要有3项缓存：\",\"1. subject，对应于「查询评论区基础信息」，redis string 类型，value 使用JSON序列化方式存入。\",\"2. reply_index，对应于「查询xxx评论列表」，redis sorted set 类型。member 是评论 id，score 对应于 ORDER BY 的字段，如 floor、like_count 等。\",\"3. reply_content，对应于「查询xxx评论基础信息」，存储内容包括同一个评论 id 对应的 reply_index 表和 reply_content 表的两部分字段。\",\"reply_index 是一个 sorted set，为了保证数据完整性，必须要判定 key 存在才能增量追加。由于存在性判定和增量追加不是原子化的，判定存在后、增量追加前可能出现缓存过期，因此选用 redis 的 EXPIRE 命令来执行存在性判定，避免此类极端情况导致的数据缺失。此外，缓存的一致性依赖 binlog 刷新，主要有几个关键细节：\",\"1. binlog 投递到消息队列，分片 key 选择的是评论区，保证单个评论区和单个评论的更新操作是串行的，消费者顺序执行，保证对同一个 member 的 zadd 和 zrem 操作不会顺序错乱。\",\"2. 数据库更新后，程序主动写缓存和 binlog 刷缓存，都采用删除缓存而非直接更新的方式，避免并发写操作时，特别是诸如 binlog 延迟、网络抖动等异常场景下的数据错乱。那大量写操作后读操作缓存命中率低的问题如何解决呢？此时可以利用 singleflight 进行控制，防止缓存击穿。\"]},\"265\":{\"h\":\"05 可用性设计\"},\"266\":{\"h\":\"5.1 写热点与读热点\",\"t\":[\"2020年的腾讯的辣椒酱不香了[1]，引发一场评论区的狂欢。由于上文所述各类「评论区维度的串行」，当时评论发布的吞吐较低，面对如此大的流量出现了严重延迟。\",\"图片\",\"痛定思痛，我们剖析瓶颈并做了如下优化：\",\"1. 评论区评论计数的更新，先做内存合并再更新，可以减少热点场景下的SQL执行条数；评论表的插入，改成批量写入。\",\"2. 非数据库写操作的其他业务逻辑，拆分为前置和后置两部分，从数据写入主线程中剥离，交由其他的线程池并发执行。\",\"改造后，系统的并发处理能力有了极大提升，同时支持配置并行度/聚合粒度，在吞吐方面具备更大的弹性，热点评论区发评论的TPS提升了10倍以上。\",\"图片\",\"除了写热点，评论的读热点也有一些典型的特征：\",\"1. 由于大量接口都需要读取评论区基础信息，存在读放大，因此该操作是最先感知到读热点存在的。\",\"2. 由于评论业务的下游依赖较多，且多是批量查询，对下游来说也是读放大。此外，很多依赖是体量相对小的业务单元，数据稀疏，难以承载评论的大流量。\",\"3. 评论的读热点集中在评论列表的第一页，以及热评的热评。\",\"4. 评论列表的业务数据模型也包含部分个性化信息。\",\"因此，我们利用 《直播场景下 高并发的热点处理实践》[5] 一文所使用的SDK，在读取评论区基础信息阶段探测热点，并将热点标识传递至BFF层；BFF层实现了页面请求级的热点本地缓存，感知到热点后即读取本地缓存，然后再加载个性化信息。\",\"图片\",\"热点探测的实现基于单机的滑动窗口+LFU，那么如何定义、计算相应的热点条件阈值呢？\",\"首先，我们进行系统容量设计，列出容量计算的数学公式，主要包括各接口QPS的关系、服务集群总QPS与节点数的关系、接口QPS与CPU/网络吞吐的关系等；然后，收集系统内部以及相应依赖方的一些的热点相关统计信息，通过前面列出的公式，计算出探测数据项的单机QPS热点阈值。最后通过热点压测，来验证相应的热点配置与代码实现是符合预期的。\"]},\"267\":{\"h\":\"5.2 冗余与降级\",\"t\":[\"上文提到，评论基础服务层集成了多级缓存，在上一级缓存未命中或者出现网络错误后，可以视具体场景要求降级至下一级缓存。各级缓存可能有功能上的略微差异，但都能保障用户的基础体验。\",\"此外，评论系统是一个同城读双活的架构。数据库与缓存均是双机房独立部署的，均支持多副本，具备水平扩容的弹性。针对双机房架构下特有的副机房数据延迟故障，支持入口层切流/跨机房重试/应用层补偿，尽可能保证极端情况下用户无感。\",\"在功能层面，我们做了重要级别划分，把相应的依赖划分为强依赖（如审核）、弱依赖（如粉丝勋章）。对于弱依赖，我们一方面在异常情况下坚决限流熔断，另一方面也通过超时控制、请求预过滤、优化调用编排甚至技术方案重构等方式持续优化提升非核心功能的可用性，为业务在评论区获得更好的曝光展现。\"]},\"268\":{\"h\":\"06 安全性设计\",\"t\":[\"评论系统的安全性设计可以分为「数据安全」与「舆论安全」。\"]},\"269\":{\"h\":\"6.1 数据安全\",\"t\":[\"除了数据安全法所要求的以外，评论系统的数据安全还包括「合规性要求」。评论数据合规，一方面是审核和风控，另一方面对工程侧的要求主要是「状态一致性」。例如，有害评论被删除后，在客户端不能展现，也不能通过API等对外暴露。这就对数据一致性，包括缓存，提出了较高要求。在设计层面主要有两方面实践：\",\"1. 数据读写阶段均考虑了一致性风险，严格保证时序性。\",\"2. 对各类数据写操作，定义了优先级，避免高优先级操作被低优先级操作覆盖，例如审核删除的有害评论，不能被其他普通运营人员/自动化策略放出。\",\"3. 通过冗余校验，避免风险数据外泄。例如评论列表的露出，读取 sorted set 中的 id 列表后，还需要校验对应评论的状态，是可见态才允许下发。\"]},\"270\":{\"h\":\"6.2 舆论安全\",\"t\":[\"舆论安全问题更为泛化。接口错误导致用户操作失败、关闭评论区、评论计数不准，甚至新功能上线、用户不满意的评论被顶到热评前排等问题均可能引发舆情问题。\",\"1. 不对用户暴露用户无法处理和不值得处理的错误。 例如评论点赞点踩、某个数据项读取失败这一类的轻量级操作，不值得用户重试，此时告知用户操作失败也没有意义。系统可以考虑自行重试，甚至直接忽略。\",\"2. 优化产品功能及其技术实现，例如评论计数、热评排序等。\",\"计数不一致的根源，是数据冗余造成的。 一般出于性能考虑，会在评论列表以外，给这个列表记录一个长度。也就是用 SELECT count FROM subject，代替 SELECT count(*) FROM reply_index。基于这种冗余设计，count 字段大部分都是增量更新，即+1、-1，是容易出现误差累积的。\",\"1. 并发事务导致的「写倾斜（write skew）」，例如依据评论的状态来做评论区的计数更新。在A事务中读取的评论状态，可能在B事务中被修改，此时A事务计数更新的前提被破坏，也就造成了错误的增量更新。此时计数可能偏大或偏小。\",\"2. 运行时异常、脏数据或者非常规的展示侧控制，导致部分数据被过滤。此时计数可能偏大。\",\"3. 计数冗余同步至其他系统，例如视频表的评论数，延迟导致了过程不一致，同步失败则直接导致最终不一致。\",\"1. 事务加锁。综合评估而言，对性能的影响较大，特别是存在“锁放大”，越需要加锁的场景，越容易出现“锁冲突”。\",\"2. 串行化。将评论区的所有操作，抽象为一个排队的 Domain Events，串行处理，不容易出错。那为什么不能按照评论维度进行拆分，更加不容易出现评论区维度的热点？因为上文提到，删除一级评论时，实际也会从计数上删除其回复；删除二级评论时，也会更新其根评论的计数。多个评论的操作相互影响，因此按照评论维度进行拆分仍然存在并发事务问题。\"]},\"271\":{\"h\":\"07 热评设计\"},\"272\":{\"h\":\"7.1 什么是热评\",\"t\":[\"早期的热评，实际就是按照评论点赞数降序。后来衍生了更为复杂的热评：既包括类似「妙评」这种用户推荐、运营精选且带 logo 突出展示的产品形态，也包括各类热评排序算法，且热评排序算法应用场景也不仅局限于评论主列表的热度序，还包括楼中楼（外露子评论）、动态外露评论等。\",\"热评排序逻辑一般包括点赞数、回复数、内容相关、负反馈数、“时间衰退因子”、字数加权、用户等级加权等等。如何在B站评论区脱颖而出？[7]一文从内容运营层面，介绍了什么样的评论更容易上热评前排。\",\"咬文嚼字来说，我们对「热」的理解，大致分为几个阶段：\",\"1. 点赞高，就代表热度高。→ 解决热评的有无问题\",\"2. 基于用户正负样本投票的，加权平均高，就代表热度高。→ 解决高赞高踩的负面热评问题\",\"3. 短时间内点赞率高，就代表热度高。→ 解决高赞永远高赞的马太效应\",\"4. 热评用户流量大，社区影响也大。要权衡社会价值观引导、公司战略导向、商业利益、UP主与用户的「情绪」等。→ 追求用户价值平衡\"]},\"273\":{\"h\":\"7.2 挑战与应对\",\"t\":[\"显然，我们在不同阶段对热评的理解，在系统设计上也提出了不同层面的要求：\",\"1. 按照点赞绝对值排序，即要实现 ORDER BY like_count 的分页排序。点赞数是一个频繁更新的值，MySQL，特别是TiDB，由于扫描行数约等于 OFFSET，因此在 OFFSET 较大时查询性能特别差，很难找到一个完美的优化方案。此外，由于 like_count 的分布可能出现同一个值堆叠多个元素，比如评论区所有的评论都没有赞，我们更多依赖 redis 的 sorted set 来执行分页查询，这就要求缓存命中率要非常高。\",\"2. 按照正负样本加权平均的，即Reddit：威尔逊排序[6]，到这个阶段，数据库已经无法实现这样复杂的 ORDER BY，热评开始几乎完全依赖 sorted set 这样的数据结构，预先计算好排序分数并写入。于是在架构设计上，新增了 feed-service 和 feed-job 来支撑热评列表的读写。\",\"图片\",\"3. 按照点赞率排序，需要实现点赞率的近实时计算。点赞率=点赞数/曝光数，曝光的数据来源是客户端上报的展现日志，量级非常大，可以说是一个写多读少的场景：只有重算排序的时候才会读取曝光数。\",\"4. 追求用户价值平衡，需要处理各种细分场景下的差异化需求。热评排序与 feed 排序很像，但也有一点根本性差异：feed 排序我们往往都希望是个性化的，每个人看到的都不相同，但评论往往不会如此激进，一般来说会希望大家看到的评论排序都大致相同。由于排序问题的解决方案是探索型的，因此系统设计层面需要提供更多元、更易扩展的工程化能力，包括算法和策略的快速迭代、实验能力等，并提升整个热评模块的可观测水平，监控完善、数据报表丰富、排序过程可解释等等。在架构上，新增了 strategy-service 和 strategy-job 来承担这部分策略探索型业务。\",\"此外，数据量级规模的增加，也对系统的吞吐能力提出了更高要求：不管热评的算法如何变化，一般来说，热评列表都需要能够访问到全部评论，且基本维持相同的热评排序逻辑。在评论数过百万甚至千万的评论区，热评排序的挑战点主要在于：\",\"1. 大 key 问题：例如单个 sorted set 过大，读写性能都受影响（时间复杂度的基数可以认为都是O(logN)）；全量更新时，还可能遇到 redis pipeline 的瓶颈。\",\"2. 实时性放大存储压力：多样化的数据源，对特征的导入与更新都提出了挑战，需要支持较丰富的数据结构，和尽可能高的写吞吐（想象一下曝光数作为排序特征的变态要求）；与推荐排序不同，热评排序是全排序，此时需要读取全部评论的全部特征，查询压力也会非常大。\",\"这一阶段，我们仍然在持续优化，在工程落地层面尽可能还原理想的排序算法设计，保障用户的热评浏览体验。目前形成的系统架构总体如下图所示：\",\"图片\",\"图示的「评论策略层」，负责建立一套热评调控体系化能力，通过召回机制来实现想要的“balance“。即先通过策略工程，召回一批应该沉底的不良评论或者应该进前排的优秀评论，然后在排序分计算阶段根据召回结果实现这样的效果。\",\"这样做的好处是，可以保留一套通用的底层排序算法，然后通过迭代细分场景下的召回策略，来实现差异化评论排序的平衡。\",\"召回策略的工程设计，按照分层设计的原则拆分为3个部分：\",\"1. 因子机。主要职责是维护策略所需的全部「因子」，包括一些已有的在线/离线数据，也包括为了策略迭代而需要新开发的流式的窗口聚合数据。因子机的重难点是需要管理各种数据获取的拓扑关系，以及通过缓存来保护下游（数据提供方很难也不应该承受热评业务的巨大流量）。所有的因子可以构成一个有向无环图，通过梳理依赖关系和推导计算，实现并发提效、减少冗余。\",\"2. 规则机。实现了一套声明式规则语法，可以直接引用因子机预定义的因子，结合各种逻辑算子构成一个规则表达式。规则机执行命中后，会向下游传递预先声明的召回决策，例如排序提权。\",\"3. 召回处理中心。这一层的职责就是接收规则机返回的各种决策并执行，需要处理不同决策的优先级PK、不同规则的决策叠加作用、决策豁免等。\",\"热评排序涉及的特征，是多数据源的，数据更新方式、更新频率、查询性能也天差万别。因此我们针对数据源的特点做了多级缓存，通过多级冗余与跨级合并，提升了特征读取的稳定性与性能上限。当然，其中的数据实时性、一致性、可用性，仍然处于一个动态权衡取舍的过程。举个例子，曝光数使用 redis 计数器维护，受限于成本并未持久化；各类静态模型分存在4到5层冗余。此外，还应用了内部稀疏数据的 bloom-filter 查询、数据局部性集中与散列相结合、近实时大窗口聚合计数等多种性能优化手段。需要指出的是，召回和排序两阶段都需要查询因子/特征，得以复用「因子机」，完成各个特征的差异化实现与维护。\",\"热评排序最关键的计算模块，首先是引入了自适应的冷却算法，根据评论区的评论数、活跃程度等，对重算排序的收益进行预估，拦截了大部分低价值重排请求。其次在全量打分排序阶段，「排序策略」贯穿上下文，既支持传统的静态的经验算分公式，也支持动态的模型打分，支撑AI模型的快速部署快速迭代。通过组合与继承，支持排序策略的叠加、微调，结合评论网关层的排序策略路由，可实现各类定制化排序，完成热评排序系统的平台化。\",\"除了大家点开评论区看到的“热评”，在楼中楼、动态外露评论、评论详情页等类似场景，我们同样应用了这套热评系统，在工程上实现了架构的统一。\"]},\"274\":{\"h\":\"7.3 愿景与规划\",\"t\":[\"评论区作为B站社区的重要组成部分，致力于为中文互联网提供一个和谐、有趣的交流环境。另一方面，B站评论区流量巨大，所具备的商业化价值也是需要持续探索的。不管是氛围还是商业，都具有非常强的头部效应。因此，热评，尤其是热评的头部，我们会持续优化产品功能，持续探索排序策略，期望能为用户带来更好的体验：用户可以在这里看到自己喜欢的评论内容，有知识、有温度，也可以看到一些多元化的观点；可以炫一下自己的装扮，也可以守护新人UP主成长；可以倾诉自己的故事，也可以发一条友善的评论，更可以来一个段子，逗乐每一个在互联网里冲浪的有缘人。\",\"参考资料：\",\"[1] https://t.bilibili.com/406920470238773354?spm_id_from=333.999.0.0\",\"[2] 维基百科：评论 (https://zh.wikipedia.org/wiki/%E8%A9%95%E8%AB%96)\",\"[3] 百度评论中台的设计与探索 (https://juejin.cn/post/7108973163333025805)\",\"[4] 腾讯老干妈大瓜背后，B站竟成为最大赢家 (https://36kr.com/p/783469249310599)\",\"[5] 直播场景下 高并发的热点处理实践 (https://www.bilibili.com/read/cv15278397?from=search&spm_id_from=333.337.0.0)\",\"[6] Evan Miller: How Not To Sort By Average Rating (https://www.evanmiller.org/how-not-to-sort-by-average-rating.html)\",\"[7] 如何在B站评论区脱颖而出？\",\"[8] 如何对文章下面的评论做排序（2019年版）(https://zhuanlan.zhihu.com/p/57021517)\"]},\"275\":{\"c\":[\"架构设计\"]},\"276\":{\"c\":[\"评论系统\"]},\"277\":{\"h\":\"评论系统功能和架构设计\",\"t\":[\"转载自stormspirit，原文链接：评论系统功能和架构设计\",\"本周会以 B 站的评论系统为样本，来介绍该系统的功能、架构、存储、可用性设计等。\",\"首先在设计一个评论系统之前，我们必须要对这个系统的功能以及定位有一个清晰的了解。\"]},\"278\":{\"h\":\"功能模块\",\"t\":[\"架构设计最重要的就是 「理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。」 深入到业务里面，了解业务本身的本质。成为某个业务领域的专家，对这个业务的系统有比较深的理解，才能设计出一个全面的架构。\",\"评论系统，我们往小里做就是视频评论系统，往大了做就是评论平台，可以接入各种业务形态，比如在漫画、文章等业务下也能接入一样的评论系统。再往大做可以是一个评论中台，只需要设置不同的评论策略，比方说先审后发或者先发后审，或者高于多少等级的用户才能发表评论，这样不同的业务只需要设计自己的策略接入评论系统即可。\",\"评论系统可能有的功能：\",\"发布评论: 支持回复楼层、楼中楼。\",\"读取评论: 按照时间、热度排序。\",\"删除评论: 用户删除、作者删除。\",\"管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。\",\"在前期花足够时间去反复思考设计，会减少之后大量的返工。「在动手设计前，反复思考，真正编码的时间只有5%。」\"]},\"279\":{\"h\":\"架构设计\",\"t\":[\"图片\",\"如上图，一共有以下模块：\",\"网关层：api gateway，可能是 nginx 、kong 等。\",\"BFF 层：comment 模块。\",\"复杂评论业务的服务编排，比如访问账号服务进行等级判定，同时需要在 BFF 面向移动端/WEB场景来设计 API，「这一层抽象把评论的本身的内容列表处理(加载、分页、排序等)进行了隔离，关注在业务平台化逻辑上」。\",\"服务层：comment-service。\",\"服务层，去平台业务的逻辑，专注在评论功能的 API 实现上，比如发布、读取、删除等，「关注在稳定性、可用性上，这样让上游可以灵活组织逻辑，从而把基础能力和业务能力剥离」。\",\"Job：comment-job。\",\"消息队列的最大用途是**「削峰处理」**。\",\"Admin: comment-admin。\",\"管理平台，「按照安全等级划分服务」，尤其划分运营平台，他们会共享服务层的存储层(MySQL、Redis)。运营体系的数据大量都是检索，我们使用 canal 订阅 MySQL 的 binlog 进行同步到 ES 中，整个数据的展示都是通过 ES，再通过业务主键更新业务数据层，这样运营端的查询压力就下方给了独立的 fulltext search 系统。\",\"Dependency: account-service、filter-service。\",\"整个评论服务还会依赖一些外部 gRPC 服务，统一的平台业务逻辑在 comment BFF 层收敛，这里 account-service 主要是账号服务，filter-service 是敏感词过滤服务。\",\"架构设计等同于数据设计，梳理清楚数据的走向和逻辑。尽量避免**「环形依赖」**、数据双向请求等（比如两个服务互相调用）。\"]},\"280\":{\"h\":\"comment-service\",\"t\":[\"comment-service，专注在评论数据处理（Separation of Concerns）。\",\"图片\",\"注意\",\"我们一开始是 comment-service 和 comment 是一层，业务耦合和功能耦合在一起，非常不利于迭代，当然在设计层面可以考虑目录结构进行拆分，但是架构层次来说，迭代隔离也是好的。\"]},\"281\":{\"h\":\"读的核心逻辑\",\"t\":[\"Cache-Aside 模式，先读取缓存，再读取存储。\",\"早期 cache rebuild 是做到服务里的，对于重建逻辑，一般会使用 read ahead 的思路，即 「预读」，用户访问了第一页，很有可能访问第二页，所以缓存会超前加载，避免频繁 cache miss。当缓存抖动时候，特别容易引起集群 thundering herd 现象（惊群问题）。大量的请求会在 「comment 服务内部」 触发 cache rebuild，容易导致服务 OOM。\",\"所以在回源的逻辑里，我们使用了消息队列来进行逻辑异步化。发生缓存 miss 时，服务去 db 把数据拿出来返回，然后发送一条消息给 kafka，说明哪个 topic 或者 key cache miss 了，之后再在 comment-job 里消费消息，从 db 里拿出对应的数据再更新到缓存里。\"]},\"282\":{\"h\":\"写的核心逻辑\",\"t\":[\"写可以认为是 「透穿到存储层」 的，系统的瓶颈往往就来自于存储层，或者有状态层。\",\"对于写的设计上，把对存储的直接冲击 「下放到消息队列」，按照消息反压的思路，即如果存储 mysql 延迟升高，消费能力就下降，然后消息堆积，系统始终以最大化方式消费。意思就是把消息都暂存在 kafka 中，而不会一下发到 mysql ，这就是做一个削峰的处理。\",\"Kafka 是存在 partition 概念的，可以认为是物理上的一个小队列，一个 topic 是由一组 partition 组成的，所以 Kafka 的吞吐模型理解为: 「全局并行，局部串行的生产消费方式」。对于入队的消息，可以按照 hash(comment_subject) % N(partitions) 的方式进行分发。即某个评论主题的数据都在一个分区里，这样方便我们串行消费，顺序不会乱。\",\"处理之前的回源消息也是类似的思路。\"]},\"283\":{\"h\":\"comment-admin\",\"t\":[\"mysql binlog 中的数据被 canal 中间件流式消费，获取到业务的原始 CRUD 操作，需要回放录入到 es 中，但是 es 中的数据最终是面向运营体系提供服务能力，需要检索的数据维度比较多，在入 es 前需要做一个异构的 joiner，把单表变宽预处理好 join 逻辑，然后导入到 es 中。 一般来说，运营后台的检索条件都是组合的，使用 es 的好处是 「避免依赖 mysql 来做多条件组合检索」（索引越多写入速度会越慢），同时 mysql 毕竟是 OLTP 面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。\",\"es 一般会存储检索、展示、primary key 等数据，当我们操作编辑的时候，找到记录的 primary key，最后交由 comment-admin 进行运营测的 CRUD 操作。\",\"内部运营体系基本都是基于 es 来完成的。\"]},\"284\":{\"h\":\"BFF-comment\",\"t\":[\"comment 作为 BFF，是面向端，面向平台，面向业务组合的服务。所以平台扩展的能力，我们都在 comment 服务来实现，方便统一和准入平台，以统一的接口形式提供平台化的能力。\",\"依赖其他 gRPC 服务，整合统一平台测的逻辑(比如发布评论用户等级限定)。\",\"直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上 SDK。\",\"需要对非核心依赖的 gRPC 服务进行降级，当这些服务不稳定时。\"]},\"285\":{\"c\":[\"架构设计\"]},\"286\":{\"c\":[\"评论系统\"]},\"287\":{\"h\":\"评论系统和可用性设计\",\"t\":[\"转载自stormspirit，原文链接：评论系统和可用性设计\"]},\"288\":{\"h\":\"存储设计\"},\"289\":{\"h\":\"数据表设计\",\"t\":[\"先看一张 b 站的评论图：\",\"图片\",\"如上图所示，主评论下面有子评论，子评论之间也可以互相评论，并且评论之间是通过赞数进行排序的。\",\"数据表设计：\",\"图片\",\"如上图，评论系统分为三张表。\",\"comment_subject\",\"评论主题表。一个主题可能是一个视频稿件、一篇文章等。分成了 50 张表。自增 id 做主键。\",\"obj_id 是主题 id， obj_type 是主题类型。\",\"另外还保存了一些计数字段，比如评论总数等。这样做是为了避免每次需要统计总数时都要做一次 select count(*) ，这样效率很低，所以直接每次新增评论的时候就把相应字段 +1 即可。\",\"comment_index\",\"评论索引表。主要存的是评论的 id 与评论主题的对应关系，以及该评论的一些相关信息，比如是不是根评论、评论楼层，评论总数等。分成了 200 张表。使用自增 id 做主键，主键 id 就是评论 id。\",\"root 是该评论的根评论 id，比如上面评论图红框里的就是根评论。不为 0 就是回复的评论，为 0 就是根评论。\",\"parent 是这个评论的父评论，也就是它是回复哪条评论的，如果为 0 那这个评论就是根评论。\",\"其他的都是一些统计信息等等。\",\"comment_content\",\"评论内容表。主要存的是评论实际内容。分成了 200 张表。\",\"它直接使用 comment_id（对应的就是 comment_index 表的 id ）作为主键，这样的好处是：\",\"表都有主键，即 cluster index，是物理组织形式存放的，comment_content 没有 id，是为了减少一次二级索引查找，直接基于主键检索，同时 comment_id 在写入要尽可能的顺序自增。\",\"意思是从 comment_index 表里捞出来一堆 comment_id ，那就可以直接通过这些 comment_id 作为主键去查询 comment_content 表了。如果 content 表还有自己的自增主键的话，那么通过 comment_id 去查必然需要先查到自己的主键 id ，然后再通过 id 去查到这一行数据，多了一步操作。\",\"索引、内容分离，方便 mysql datapage 缓存更多的 row，如果和 content 耦合，会导致更大的 IO。长远来看 content 信息可以直接使用 KV storage 存储。比如 Rocks DB 等。\",\"这也是一种 「索引内容分离」 的设计思想。\",\"写数据\",\"事务更新 comment_subject，comment_index，comment_content 三张表，其中 content 属于非强制需要一致性考虑的。可以先写入 content，之后事务更新其他表。即便 content 先成功，后续失败仅仅存在一条 ghost 数据。\",\"读数据\",\"基于 obj_id + obj_type 在 comment_index 表找到根评论列表，比如：\",\"select id from comment_index where obj_id = 'x' and obj_type = 'y' and root = 0 ORDER BY floor;\",\"对于二级的子楼层，由于一般只查询 3 层子楼层：\",\"select id from comment_index where parent/root in (上面查询出来的 id) and floor <= 3 order by floor;\",\"之后根据 comment_index 的 id 字段捞出 comment_content 的评论内容。\",\"因为产品形态上只存在 「二级列表」，因此只需要迭代查询两次即可。对于嵌套层次多的，产品上，可以通过二次点击支持。\",\"这种迭代查询的方式也可以直接用图数据库来实现，可能更好，比如 DGraph、HugeGraph 类似的图存储思路。\"]},\"290\":{\"h\":\"总结\",\"t\":[\"主题一张表，评论索引与评论内容分开两张表来存，表里有一些统计字段，避免每次都重新统计。内容表的主键直接使用评论 id，避免使用评论 id 查询还需要回表。评论内容可以使用 kv 数据库。写入时可以先写评论内容表，评论索引表和主题表用一个事务更新。\"]},\"291\":{\"h\":\"缓存设计\",\"t\":[\"图片\",\"图片\",\"图片\",\"comment_subject_cache\",\"对应主题的缓存，value 使用 protobuf 序列化的方式存入。\",\"comment_index_cache\",\"使用 redis sortedset 进行索引的缓存。key 是主题 id + 主题 type + 排序方式， member 就是评论 id，score 就是根据各种要素排序的得分。这样就可以根据某个主题查询，得到排序过后的评论 id 列表。然后就可以通过评论 id 列表去批量查询评论内容了。\",\"提示\",\"索引即数据的组织顺序，而非数据内容。参考过百度的贴吧，他们使用自己研发的拉链存储来组织索引，我认为 mysql 作为主力存储，利用 redis 来做加速完全足够，因为 cache miss 的构建，我们前面讲过使用 kafka 的消费者中处理，预加载少量数据，通过增量加载的方式逐渐预热填充缓存，而 redis sortedset skiplist 的实现，可以做到 O(logN) + O(M) 的时间复杂度，效率很高。\",\"sorted set 是要增量追加的，因此必须判定 key 存在，才能 zdd。\",\"comment_content_cache\",\"对应评论内容数据，使用 protobuf 序列化的方式存入。\",\"缓存使用增量加载 + lazy 加载模式，也就是在查询第一页的时候会将后两页评论数据也一起加载进缓存。可以使用 kafka 进行缓存的异步构建。\"]},\"292\":{\"h\":\"可用性设计\"},\"293\":{\"h\":\"缓存穿透\",\"t\":[\"singleflight\",\"图片\",\"对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储？\",\"使用归并回源的思路 singleflight，singleflight 的原理可以看这篇文章 Go并发编程(十二) Singleflight。\",\"同进程只交给一个人去获取 mysql 数据，然后批量返回。\",\"同时这个租约 owner 投递一个 kafka 消息，做该 key 的 cache build 的操作。这样可以大大减少查询 mysql 的压力，以及大量透穿导致的密集写 kafka 的问题（如果不这么做那么会有很多的进程向 kafka 发送 cache rebuild 的指令，然后它们都会去 mysql 里查询数据写缓存）。\",\"更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个过期时间为 5 秒的 short-lived flag，标记最近有一个人投递了同一个 key 的 cache rebuild 的消息，如果有这个 flag ，那么相同的 kafka 消息直接 drop 而不会再去查 mysql 构建缓存，这样 mysql 的压力更小。\",\"再进一步，可以在 comment-job 内存里设置一个过期时间很短的比如 5 秒的 LRU cache， 有一个线程去 mysql 里查到了数据就更新这个缓存，然后其他的线程直接从这个缓存里拿数据即可，这样就不用重复去 mysql 里查了，同样减少了对 mysql 的查询压力。\",\"一般不需要使用分布式锁，实现起来太复杂而且很容易出错。\"]},\"294\":{\"h\":\"热点\",\"t\":[\"流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此做 cache 的升级 local cache 是有必要的，我们一般使用**「单进程自适应发现热点」**的思路，附加一个短时的 ttl local cache，可以在进程内吞掉大量的读请求。\",\"在内存中使用 hashmap 统计每个 key 的访问频次，这里可以使用滑动窗口统计（如下图），即每个窗口中，维护一个 hashmap，之后统计所有未过期的 bucket，汇总所有 key 的数据。\",\"之后使用小顶堆计算 TopK 的数据，自动进行热点识别。把 TopK 的 key 统一 load 到本地缓存。\",\"图片\"]},\"295\":{\"c\":[\"架构设计\"]},\"296\":{\"c\":[\"评论系统\"]},\"297\":{\"h\":\"第一期 - 上\",\"t\":[\"用户中心笔记第一期 - 上\"]},\"298\":{\"h\":\"1、企业做项目流程\",\"t\":[\"需求分析\",\"设计（概要设计、详细设计）\",\"技术选型\",\"初始化 / 引入需要的技术\",\"写 Demo\",\"写代码（实现业务逻辑）\",\"测试（单元测试、系统测试）\",\"代码提交 / 代码评审\",\"部署\",\"发布上线\"]},\"299\":{\"h\":\"2、需求分析\",\"t\":[\"登录 / 注册\",\"用户管理（仅管理员可见）对用户的查询或者修改\",\"用户校验（注册校验，权限校验）\"]},\"300\":{\"h\":\"3、技术选型\",\"t\":[\"前端：\",\"HTML+CSS+JavaScript 三件套\",\"React 开发框架\",\"组件库 Ant Design\",\"Umi 开发框架\",\"Umi Request 开发框架Ant Design Pro（现成的管理系统）\",\"后端：\",\"java\",\"spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）\",\"springmvc（web 框架，提供接口访问、restful接口等能力）\",\"mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）\",\"mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）\",\"springboot（快速启动 / 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）\",\"junit 单元测试库\",\"mysql 数据库\",\"部署：服务器 / 容器（平台）\"]},\"301\":{\"h\":\"4、初始化项目\"},\"302\":{\"h\":\"4.1 前端初始化\",\"t\":[\"按照 Nodejs 版本 16.14 以上\",\"Ant Design Pro 前端框架\",\"先新建一个文件夹 user-center，进入到目录，在地址栏输入 cmd，打开终端，输入以下命令初始化前端：\",\"npm i @ant-design/pro-cli -g pro create user-center-ui\",\"步骤\",\"执行后进入前端框架初始化过程，这里选择使用 umi@3 和 simple 一个简单模式的脚手架，然后通过 webstorm 进入 user-center-ui 文件夹，打开终端，输入 yarn，自动安装相关依赖。安装依赖完成后，找到 package.json。scripts 下有很多脚本，找到 start 并运行。即可启动 ant design pro.\",\"关于 Umi UI 插件的构建，因为我们之前已经选择的是 umi@3，进入 myapp 文件夹的 terminal 是一个 Umi UI 可视化辅助工具，但是区块一直无法显示，挂了梯子以及修改了 hosts 之后还是不行，所以实在不行可以跳过，不影响后续开发。\",\"安装 Umi UI\",\"yarn add @umijs/preset-ui -D\",\"使用该工具可以帮助我们快速生成页面\",\"前端瘦身\",\"删除国际化 \",\"执行 package.json 的 scripts 下的 i18n-remove 脚本，移除国际化\",\"删除前端路径下 src/locales 文件夹\",\"删除项目路径下 src/e2e 文件夹 \",\"e2e 文件夹里面定义的是一系列测试流程\",\"若前面有使用 Umi UI 添加页面，可把该页面删除 \",\"注意：需要在路劲为 config/routes.ts 的文件夹下，删除对应的路由规则\",\"删除项目路径下 src/services/swagger 文件夹 \",\"swagger 文件夹里面定义了一系列后台接口程序\",\"删除项目路径下 config/oneapi.json 文件 \",\"oneapi.json 定义了整个项目用到的一些接口\",\"删除项目根路径下 tests 文件夹 \",\"tests 文件夹主要是和测试相关的\",\"删除项目根路径下 jest.config.js 文件 \",\"jest.config.js 测试相关的配置文件\",\"删除项目根路径下 playwright.config.ts 文件 \",\"playwright.config.ts -> 自动化测试工具，帮你在火狐或谷歌自动测试，不用真实地打开浏览器就能测试\"]},\"303\":{\"h\":\"4.2 后端初始化：3种初始化 Java 项目的方式\",\"t\":[\"GitHub 搜现成的代码\",\"SpringBoot 官方的模板生成器（https://start.spring.io/）\",\"直接在 IDEA 开发工具中生成 （一般都是自己创建工程） 如果要引入 java 的包，可以去 maven 中心仓库寻找（http://mvnrepository.com/）新建好工程，然后整合 MyBatis-Plus 跟着官网来就可以了\"]},\"304\":{\"c\":[\"项目\"]},\"305\":{\"c\":[\"用户中心\"]},\"306\":{\"h\":\"第三期 - 下\",\"t\":[\"用户中心笔记第三期 - 下\"]},\"307\":{\"h\":\"1、登录功能\"},\"308\":{\"h\":\"1.1 接口设计\",\"t\":[\"接收参数：用户名、密码 请求类型：POST 请求体：JSON 格式的数据 返回值：用户信息（脱敏）\",\"注意\",\"请求体很长时不建议用 get\"]},\"309\":{\"h\":\"1.2 登录逻辑\",\"t\":[\"校验用户账户和密码是否合法 \",\"非空\",\"账户长度不小于 4 位\",\"密码就不小于 8 位\",\"账户不包含特殊字符\",\"校验密码是否输入正确，要和数据库中的密文密码（注册时加密后的）去对比\",\"用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露\",\"我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录 cookie）\",\"返回脱敏后的用户信息\",\"脱敏\",\"信息脱敏（Data Masking）是一种隐私保护技术，通过对敏感数据进行修改或者替换的方 式，来保护数据的隐私和安全。信息脱敏通常应用于需要处理敏感数据的场景，例如测试、开发、分 析等环境。在信息脱敏技术中，被保护的敏感数据通常会被替换成某种规则定义的非敏感数据或者格 式，以避免敏感数据泄露和数据窃取的风险，主要就是防止信息泄露，隐藏敏感信息\"]},\"310\":{\"h\":\"1.3 如何知道是哪个用户登录了？\",\"t\":[\"连接服务器端后，得到一个 session 状态（匿名会话），返回给前端（用户已经有了会话，但是这个会 在用户登录成功之后才会保存到 Session）\",\"登录成功后，得到了登录成功的 session，并且给该 session 设置一些值（比如用户信息），返回给前端 一个设置 cookie 的 命令 session => cookie\",\"前端接收到后端的命令后，设置 cookie，保存到浏览器内\",\"前端再次请求后端的时候（相同的域名），在请求头中带上 cookie 去请求\",\"后端拿到前端传来的 cookie，找到对应的 session\",\"后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）\",\"登录实现代码：\",\"/** * 用户登录实现 * @param userName 用户名 * @param password 用户密码 * @param request 请求对象 * @return 用户信息 */ @Override public User userLogin(String userName, String password, HttpServletRequest request) { // 1.校验用户的用户名、密码、校验密码，是否符合要求 // 1.1 非空校验 if (StringUtils.isAnyBlank(userName, password)) { return null; } // 1.2 用户名长度不小于4位 if (userName.length() < 4) { return null; } // 1.3 密码不小于8位 if (password.length() < 8) { return null; } // 1.4 用户名不包含特殊字符 String validPattern = \\\"[`~!@#$%^&*()+=|{}':;',\\\\\\\\\\\\\\\\[\\\\\\\\\\\\\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]\\\"; // 使用正则表达式进行校验 Matcher matcher = Pattern.compile(validPattern).matcher(userName); if (matcher.find()) { return null; } // 2.对密码进行md5盐值加密（密码千万不要直接明文存到数据库中） String encryptPassword = DigestUtils.md5DigestAsHex((SALT + password).getBytes()); // 查询用户是否存在 // TODO：此处有bug，会将逻辑删除的用户也查找出来，在 application.yml 中配置全局逻辑删除属性 QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.eq(\\\"userAccount\\\", userName); queryWrapper.eq(\\\"userPassword\\\", encryptPassword); User user = userMapper.selectOne(queryWrapper); if (user == null) { log.info(\\\"user login failed, userAccount cannot match userPassword\\\"); return null; } // 3.用户信息脱敏 User safetyUser = getSafetyUser(user); // 4.用户登录成功 // USER_LOGIN_STATE 用于记录用户的登录状态，后面用户状态优化会提到 request.getSession().setAttribute(USER_LOGIN_STATE, safetyUser); return safetyUser; } /** * 用户脱敏 * @param originUser 原始用户信息 * @return 脱敏后用户信息 */ @Override public User getSafetyUser(User originUser) { if (originUser == null) { return null; } User safetyUser = new User(); safetyUser.setUserId(originUser.getUserId()); safetyUser.setUserName(originUser.getUserName()); safetyUser.setNickName(originUser.getNickName()); safetyUser.setAvatar(originUser.getAvatar()); safetyUser.setGender(originUser.getGender()); safetyUser.setPhone(originUser.getPhone()); safetyUser.setEmail(originUser.getEmail()); safetyUser.setStatus(originUser.getStatus()); safetyUser.setLastTime(originUser.getLastTime()); safetyUser.setUserRole(originUser.getUserRole()); safetyUser.setRemark(originUser.getRemark()); return safetyUser; }\",\"逻辑删除\",\"逻辑删除是指在数据库中不是真正删除记录，而是标记为已删除，使得这些记录在系统中看起来像已被删除。这比物理删除更加安全、可靠，也能够满足许多场景下的需求。\",\"MyBatis-Plus 有一个逻辑删除，默认会帮助我们查询出来没有被删的用户，官方文档：https://baomidou.com/guides/logic-delete/\",\"按照文档在 application.yml 中配置全局逻辑删除属性：\",\"mybatis-plus: global-config: db-config: logic-delete-field: isDelete # 全局逻辑删除字段名 logic-delete-value: 1 # 1 - 删除 logic-not-delete-value: 0 # 0 - 正常\",\"并记得要在 User 实体类的 isDelete 字段上加上 @TableLogic 注解。\"]},\"311\":{\"h\":\"1.4 登录接口\",\"t\":[\"控制层 Controller 的主要工作：\",\"接收请求并解析参数\",\"调用 Service 执行具体的业务代码（可能包含参数校验）\",\"捕获业务逻辑异常做出反馈\",\"业务逻辑执行成功做出响应\",\"使用统一的 API 前缀方便管理：\",\"# application.yml 指定接口全局路径前缀 server: servlet: context-path: /api\",\"使用控制器注解：\",\"// 适用于编写 restful 风格的 api，返回值默认为 json 类型 @RestController\",\"RestFul 风格\",\"参考：https://blog.csdn.net/qq_56098191/article/details/129343870\",\"如果使用 JSON 格式参数的话，最好封装一个对象来记录所有的请求参数，这里我们在 model.domain.request 包下新建两个对象，分别记录注册和登录的请求参数。\",\"/** * 用户注册请求体 * @author BraumAce */ @Data public class UserRegisterRequest implements Serializable { // 序列化 private static final long serialVersionUID = 3553317334228624372L; // 用户名 private String userName; // 用户密码 private String password; // 校验密码 private String checkPassword; }\",\"/** * 用户登录请求体 * @author BraumAce */ @Data public class UserLoginRequest implements Serializable { // 序列化 private static final long serialVersionUID = 3553317334228624372L; // 用户名 private String userName; // 用户密码 private String password; }\",\"实现序列化接口\",\"在 implements Serializable 上右键选择 Generate -> serialVersionUID，生成序列化 ID。\",\"不过有可能点击 Generate 后并没有出现 serialVersionUID，于是可以去 settings -> editor -> Inspections，搜索 UID，如下操作：\",\"配置serialVersionUID\",\"光标放在 UserRegisterRequest，按下快捷键 Alt+Enter，选择 add'serialVersionUlD'fileld 即可。\",\"最后写一下校验，实现接口的调用，那么校验写在哪里？\",\"controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）\",\"service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）\",\"前面在 service 层已经写好了注册和登录的业务逻辑，接下来在 controller 层实现业务请求。\",\"使用 @RequestMapping，定义请求的路径，这里设置为 /user。\",\"/** * 用户控制器 * @author BraumAce */ @RestController @RequestMapping(\\\"/user\\\") public class UserController { @Resource private UserService userService; /** * 用户注册 * @param userRegisterRequest 用户注册请求 * @return 用户ID */ @PostMapping(\\\"/register\\\") public Long userRegister(@RequestBody UserRegisterRequest userRegisterRequest) { if (userRegisterRequest == null) { return null; } String userName = userRegisterRequest.getUserName(); String password = userRegisterRequest.getPassword(); String checkPassword = userRegisterRequest.getCheckPassword(); if (StringUtils.isAnyBlank(userName, password, checkPassword)) { return null; } return userService.userRegister(userName, password, checkPassword); } /** * 用户登录 * @param userLoginRequest 用户登录请求 * @param request 请求对象 * @return 用户信息 */ @PostMapping(\\\"/login\\\") public User userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request) { if (userLoginRequest == null) { return null; } String userName = userLoginRequest.getUserName(); String password = userLoginRequest.getPassword(); if (StringUtils.isAnyBlank(userName, password)) { return null; } return userService.userLogin(userName, password, request); } }\"]},\"312\":{\"h\":\"2、用户管理\",\"t\":[\"设置 Session 过期时间为 24 小时\",\"spring: session: timeout: 86400\",\"接口设计关键：必须鉴权！！且只能管理员使用\"]},\"313\":{\"h\":\"2.1 查询用户\",\"t\":[\"在 UserController 类下编写查询用户接口，不过要先进行管理员校验，只有管理员才能管理用户。如果这个接口不进行校验，那么人人都可以调用，这是非常不安全的。\",\"先进行管理员校验：\",\"private boolean isAdmin(HttpServletRequest request) { // 管理员校验 User user = (User) request.getSession().getAttribute(USER_LOGIN_STATE); if (user == null || user.getUserRole() != ADMIN_ROLE) { return false; } return true; }\",\"实现查询用户接口：\",\"/** * 查询用户 * @param userName 用户名 * @param request 请求对象 * @return 用户列表 */ @GetMapping(\\\"/search\\\") public List<User> searchUsers(String userName, HttpServletRequest request) { // 管理员校验 if (isAdmin(request)) { return new ArrayList<>(); } QueryWrapper<User> queryWrapper = new QueryWrapper<>(); if (StringUtils.isNotBlank(userName)) { queryWrapper.like(\\\"userName\\\", userName); } List<User> userList = userService.list(queryWrapper); return userList.stream() .map(userService::getSafetyUser) .collect(Collectors.toList()); }\"]},\"314\":{\"h\":\"2.2 删除用户\",\"t\":[\"实现删除用户接口：\",\"/** * 删除用户 * @param userId 用户ID * @param request 请求对象 * @return 结果 */ @DeleteMapping(\\\"/delete\\\") public boolean deleteUser(@RequestBody long userId, HttpServletRequest request) { if (!isAdmin(request)) { return false; } if (userId < 0 ) { return false; } return userService.removeById(userId); }\"]},\"315\":{\"h\":\"2.3 用户状态优化\",\"t\":[\"为方便前后端联调显示用户的登录状态，有必要在用户登录后记录用户状态。如果将状态直接写在登录逻辑里面，不利于后续维护和拓展，随着后期业务的拓展，其他地方也要调用用户状态，所以需要将用户的各种状态抽出来封装为常量。\",\"我们新建一个 constant 包，用来存储各种常量，新建一个 UserConstant 接口，记录用户的状态，以及再加上两个权限常量，如下：\",\"/** * 用户常量 * @author BraumAce */ public interface UserConstant { // 用户登录态键 String USER_LOGIN_STATE = \\\"登录成功\\\"; // 默认权限 int DEFAULT_ROLE = 0; // 管理员权限 int ADMIN_ROLE = 1; }\"]},\"316\":{\"c\":[\"项目\"]},\"317\":{\"c\":[\"用户中心\"]},\"318\":{\"h\":\"第二期 - 中\",\"t\":[\"用户中心笔记第二期 - 中\"]},\"319\":{\"h\":\"1、数据库设计\",\"t\":[\"什么是数据库？存储数据\",\"数据库里有什么？数据表（理解为 excel 表格）\",\"java 操作数据库？程序代替人工\"]},\"320\":{\"h\":\"1.1 什么是设计数据库表？\",\"t\":[\"有哪些表（模型）？\",\"表中有哪些字段？\",\"字段的类型？\",\"数据库字段添加索引？\",\"表与表之间的关联？\",\"性别是否需要加索引？\",\"不需要.区分度不大的字段没必要加索引\"]},\"321\":{\"h\":\"1.2 用户表设计\",\"t\":[\"可选字段：\",\"字段\",\"说明\",\"类型\",\"id\",\"主键，唯一标识\",\"bigint\",\"username\",\"用户名\",\"varchar\",\"userAccount\",\"用户昵称\",\"varchar\",\"password\",\"密码\",\"varchar\",\"avatar\",\"用户头像\",\"varchar\",\"gender\",\"性别\",\"tinyint\",\"phone\",\"电话\",\"varchar\",\"email\",\"邮箱\",\"varchar\",\"status\",\"账户状态(0 - 正常 1 - 停用)\",\"int\",\"lastTime\",\"上次登录时间\",\"datetime\",\"userRole\",\"用户权限(0 - 普通用户 1 - 管理员)\",\"int\",\"remark\",\"备注\",\"varchar\",\"必要字段\",\"字段\",\"说明\",\"类型\",\"createTime\",\"创建时间(数据插入时间)\",\"datetime\",\"updateTime\",\"更新时间(数据更新时间)\",\"datetime\",\"isDelete\",\"是否删除(逻辑删除)\",\"tinyint\",\"建表语句:\",\"create table user ( userId bigint auto_increment comment '用户ID' primary key, userName varchar(256) not null comment '用户名', nickName varchar(256) null comment '用户昵称', password varchar(256) not null comment '密码', avatar varchar(1024) null comment '用户头像', gender tinyint null comment '性别（0 - 男 1 - 女）', phone varchar(128) null comment '电话', email varchar(256) null comment '邮箱', status int default 0 not null comment '账号状态（0 - 正常 1 - 停用）', isDelete tinyint default 0 not null comment '是否删除（0 - 正常 1 - 删除）', lastTime timestamp default CURRENT_TIMESTAMP null comment '最后登录时间', createTime timestamp default CURRENT_TIMESTAMP null comment '创建时间', updateTime timestamp default CURRENT_TIMESTAMP null comment '更新时间', userRole int default 0 null comment '用户角色（0 - 普通用户 1 - 管理员）', remark varchar(512) null comment '备注', constraint user_userId_uindex unique (userId) ) comment '用户表';\"]},\"322\":{\"h\":\"1.3 自动生成器的使用\",\"t\":[\"使用 MyBatisX 插件，根据数据库表结构自动生成代码：\",\"domain：实体对象\",\"mapper：操作数据库的对象\",\"mapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL\",\"service：包含常用的增删改查\",\"serviceImpl：具体实现 service\",\"第一步\",\"第二步\",\"将生成的代码拖到对应的包路径下之后，编写测试类，测试类如下：\",\"@Test void testInsertUser() { User user = new User(); user.setUserName(\\\"16937\\\"); user.setNickName(\\\"BraumAce\\\"); user.setPassword(\\\"12345678\\\"); user.setAvatar(\\\"https://blog.braumace.cn/ByteLighting/BraumAce.jpg\\\"); user.setGender(0); user.setPhone(\\\"12345678900\\\"); user.setEmail(\\\"1693717911@qq.com\\\"); user.setUserRole(1); boolean result = userService.save(user); System.out.println(\\\"新增用户ID：\\\" + user.getUserId()); // 断言，判断是否符合预期结果：assertTrue -- 是否返回为true Assertions.assertTrue(result); }\",\"可能的报错\",\"由于在建表时，字段均为驼峰命名，在生成实体类时用 @TableFiled 指定了字段映射关系，而 Mybatis-Plus 会自动进行驼峰命令转换，会导致找不到属性对应的字段，所以需要在配置文件中关闭：\",\"# 自动转换为驼峰 mybatis-plus: configuration: map-underscore-to-camel-case: false\"]},\"323\":{\"h\":\"2、注册逻辑设计\",\"t\":[\"用户在前端输入账户和密码、以及校验码\",\"校验用户的账户、密码、校验密码，是否符合要求 \",\"非空\",\"账户长度 不小于 4 位\",\"密码 不小于 8 位\",\"账户不能重复\",\"账户不包含特殊字符\",\"密码和校验密码相同\",\"用户编号不得大于15位\",\"对密码进行加密（密码千万不要直接以明文存储到数据库中）\",\"向数据库插入用户数据\",\"引入依赖：\",\"<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --> <dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-lang3</artifactId> <version>3.12.0</version> </dependency>\",\"commons-lang3\",\"Apache Commons Lang3 是 Apache 软件基金会开发的一组 Java 工具类库，提供各种常用字符串 处理、数学运算、数据转换、校验等常用功能实现的工具类\",\"盐值加密\",\"Java 中的盐值和密码混淆都是用来提高密码安全性的防护措施。盐值是一种用于增加密码破解难度的技术，在存储用户密码时，会将用户密码和一个随机生成的字符串（称为盐）进行组合，然后再进行加密存储。每个用户的盐值都是随机生成的，这样可以防止攻击者使用相同的方式对一组用户的密码执行攻击。在验证用户登录时，系统会使用相同的盐和用户输入的密码进行组合，并与存储的加密密码进行比对，以验证密码是否正确。\",\"完整代码如下：\",\"/** * 用户逻辑实现 * @author BraumAce */ @Service @slf4j public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService { @Resource private UserMapper userMapper; // 盐值,将密码进行混淆 private static final String SALT = \\\"braumace\\\"; /** * 用户注册实现 * @param userName 用户名 * @param password 用户密码 * @param checkPassword 校验密码 * @return 用户ID */ @Override public long userRegister(String userName, String password, String checkPassword) { // 1.校验用户的用户名、密码、校验密码，是否符合要求 // 1.1 非空校验 if (StringUtils.isAnyBlank(userName, password, checkPassword)) { return -1; } // 1.2 用户名长度不小于4位 if (userName.length() < 4) { return -1; } // 1.3 密码不小于8位 if (password.length() < 8 || checkPassword.length() < 8) { return -1; } // 1.4 用户名不包含特殊字符 String validPattern = \\\"[`~!@#$%^&*()+=|{}':;',\\\\\\\\\\\\\\\\[\\\\\\\\\\\\\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]\\\"; // 使用正则表达式进行校验 Matcher matcher = Pattern.compile(validPattern).matcher(userName); if (matcher.find()) { return -1; } // 1.5 密码和校验密码是否相同 if (!password.equals(checkPassword)) { return -1; } // 1.6 用户名不能重复，查询数据库当中是否存在相同用户名 QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.eq(\\\"userName\\\", userName); long count = userMapper.selectCount(queryWrapper); if (count > 0) { return -1; } // 2.对密码进行md5盐值加密（密码千万不要直接明文存到数据库中） String encryptPassword = DigestUtils.md5DigestAsHex((SALT + password).getBytes()); // 3.将用户数据插入到数据库 User user = new User(); user.setUserName(userName); user.setPassword(encryptPassword); int result = userMapper.insert(user); if (result < 0) { return -1; } return user.getUserId(); } }\",\"测试注册功能：\",\"/** * 测试出错的情况 */ @Test void testUserRegister() { // 测试非空 String usernName = \\\"zhangsan\\\"; String passward = \\\"\\\"; String checkPassword = \\\"12345678\\\"; long result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试账户长度小于4 usernName = \\\"zhang\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试密码小于6位 usernName = \\\"zhangsan\\\"; passward = \\\"1234\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试特殊字符 usernName = \\\"zhangsan@\\\"; passward = \\\"12345678\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试密码和校验密码不相同 usernName = \\\"zhangsan\\\"; checkPassword = \\\"123457899\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 测试账号不重复 usernName = \\\"zhangsan\\\"; checkPassword = \\\"12345678\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); // 插入数据，如果已有则插入失败，返回-1 usernName = \\\"16937\\\"; passward = \\\"12345678\\\"; checkPassword = \\\"12345678\\\"; result = userService.userRegister(usernName, passward, checkPassword); Assertions.assertEquals(-1, result); }\"]},\"324\":{\"c\":[\"项目\"]},\"325\":{\"c\":[\"用户中心\"]},\"326\":{\"h\":\"第四期 - 终\",\"t\":[\"用户中心笔记第四期 - 终\",\"先修改前端代码，将框架预生成的样式自己想要的样式。\"]},\"327\":{\"h\":\"1、前后端交互\"},\"328\":{\"h\":\"1.1 前端请求\",\"t\":[\"前端需要向后端发送请求才能获取数据 / 执行操作。\",\"怎么发请求：前端使用 ajax 来请求后端\",\"axios 封装了 ajax\",\"request 是 ant design 项目又封装了一次\",\"追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件\"]},\"329\":{\"h\":\"1.2 代理的位置\",\"t\":[\"正向代理：替客户端向服务器发送请求，可以解决跨域问题\",\"反向代理：替服务器统一接收请求。\",\"怎么实现代理？\",\"Nginx 服务器\",\"Node.js 服务器\",\"举例：\",\"原来请求是：http://localhost:8000/api/user/login 通过反向代理到请求：http://localhost:8080/api/user/login\",\"过程如下：\",\"正向与反向代理的区别\",\"主要区别：\",\"代理的位置：正向代理靠近客户端，反向代理靠近服务器端。\",\"客户端的意识：使用正向代理时，客户端意识到代理的存在；而使用反向代理时，客户端通常不知道代理的存在。\",\"主要目的：正向代理主要用于客户端的访问控制和匿名性；反向代理主要用于服务器端的负载均衡、安全性和高可用性。\",\"配置方式：正向代理需要客户端进行配置；反向代理通常由服务器管理员配置。\"]},\"330\":{\"h\":\"2、登录页面\"},\"331\":{\"h\":\"3、注册页面\"},\"332\":{\"c\":[\"项目\"]},\"333\":{\"c\":[\"用户中心\"]},\"334\":{\"h\":\"布隆过滤器在项目中的使用\",\"t\":[\"使用 布隆过滤器 快速判断某个元素是否在集合中出现了，可以用于解决 缓存穿透 的问题。\",\"布隆过滤器提供一组 哈希函数 h1, h2, ..., hk，对需要存储的数据使用哈希函数计算得到 k 个哈希值，将 BitMap 中这 k 个位置都设置为 1，如果这 k 个位置都是 1，则 可能 在集合中，但是如果都不是 1，则 一定不在 集合中。\",\"因此布隆过滤器会出现 误判 问题，可能将不在集合中的元素判断为在集合中，解决方法之一是可以通过 增加数组长度 来降低误判率。\",\"缓存穿透： 请求的数据在数据库中不存在，因此数据也不会在缓存中，每次请求都不会命中缓存，而是打到数据库上，也就是直接穿过缓存打到数据库中，导致数据库压力很大甚至崩溃，这就是缓存穿透。\",\"那么缓存穿透的话，可以使用 Redis 的 布隆过滤器 来解决：下载 RedisBloom 插件，该插件是 Redis 的布隆过滤器模块，下载之后在 Redis 的 conf 文件中配置之后即可使用\",\"具体解决缓存穿透的场景，比如： 用户注册场景 ，如果系统用户量很大，在用户注册的时候，需要判断用户的用户名是否重复，初始将用户名的信息都初始化在布隆过滤器中，那么在用户注册时，先去布隆过滤器中快速进行判断用户名是否已经被使用，如果经过 k 次哈希计算发现这 k 次哈希值的位置上都为 1，说明 该用户名可能已经被使用了 ，用户注册用户名重复的话，大不了就换一个用户名就好了，这种情况是可以容忍的，之后用户注册成功之后，再将注册成功的用户名也放入的布隆过滤器中，这样在 用户注册时可以通过布隆过滤器快速判断用户名是否重复。\",\"上边说了布隆过滤器可能存在 误判 的情况，误判是可以容忍的，但是布隆过滤器解决缓存穿透还存在另外一个缺点：无法删除元素。\",\"无法删除元素 会导致如果用户注销帐号了，那么该用户名是无法从布隆过滤器中删除的，因此会导致其他用户也无法注册这个用户名，可以考虑再添加一层 Redis 缓存 来存储已经注销的用户名，同时如果注销的用户名较多的话，可能存在 大 key 问题 ，可以考虑分片存储来解决。\",\"这里总结一下如何通过 布隆过滤器解决缓存穿透：\",\"首先将用户名都初始化在布隆过滤器中，用户注册的时候通过 布隆过滤器 快速判断该用户名是否已经被使用了，系统可以容忍一定的误判率，对于布隆过滤器无法删除元素这个缺点，添加一层 Redis 缓存，将已经注销的用户名放在这个 Redis 中的 set 里，这样就可以解决布隆过滤器无法删除元素的缺点了，不过如果注销用户名多了，可能会存在大 key 问题，因此要考虑 分片存储 解决大 key 问题，也可以从业务角度上，限制每个用户注销的次数。\",\"最后再说一下布隆过滤器中容量的计算：\",\"先说一下各个参数的含义：\",\"m： 布隆过滤器中二进制 bit 数组的长度\",\"n： 需要对多少个元素进行存储，比如说我们要存储 1000 万个用户名，那么 n=1000 万\",\"p： 期望的误判率，可以设置 p=0.001(0.1%) 或者 p=0.0001(0.01%)\",\"m=(ln2)2n×lnp​\",\"将 n、p 带入上述公式即可计算出来理想情况下布隆过滤器的二进制数组的长度，也可以根据此公式算出来存储这么多元素大概需要占用多少内存空间，比如需要存储 10 亿个用户名，期望误判率为 0.001，也就是将 n=10 亿、p=0.001 带入，得到 m 约为 1.67GB ，因此这个布隆过滤器大约占用 1.67GB 的空间（可以搜索在线布隆过滤器容量计算）\"]},\"335\":{\"c\":[\"项目\"]},\"336\":{\"c\":[\"用户匹配系统\",\"布隆过滤器\"]},\"337\":{\"h\":\"电子书\",\"t\":[\"剑指 OFFER 名企面试官精讲典型编程题(第2版)\"]},\"338\":{\"c\":[\"书籍\"]},\"339\":{\"c\":[\"电子书\"]},\"340\":{\"h\":\"插件\",\"t\":[\"我做了一款vuepress的音乐可视化播放插件\",\"vuepress-plugin-player\",\"Vuepress 音乐播放器 & 沉浸式 源码：RayShineHub.github.io\",\"搭建 VuePress 博客，你可能会用到的一些插件\",\"博客搭建系列 - 冴羽\",\"Markdown 数学符号大全\"]},\"341\":{\"c\":[\"教程\"]},\"342\":{\"c\":[\"Blog\"]},\"343\":{\"h\":\"科学上网与本地代理\",\"t\":[\"为了某些学习目的，访问国外的一些优秀网站速度会很慢，甚至无法访问，无法查阅到想要的“资料”。\",\"在这种时候就可能需要一些代理手段，帮助我们更科学地上网📶。\",\"常见的有 ByWave 和 Clash，都是挺不错的选择，流量包推荐 性价比机场.com，详情请自行了解。\",\"当然，如果比较感兴趣、喜欢动手的朋友，也可以自己搭建一个代理服务（只能自己偷偷用哦，不然要被请去喝茶了）。\"]},\"344\":{\"h\":\"如何自建代理服务\",\"t\":[\"注意\",\"以下方案需要准备两台服务器，一台国内，一台国外，并且需要对 Linux运维 和 采购云服务器 有一定的熟练度。\",\"准备一台 海外服务器，假设名为 服务器A（IP 为 123.123.123.123），并设置安全组开放 10123 端口（开放端口很重要，同时也很危险，详见 放行端口的步骤）。\",\"然后在 服务器A 上搭建 v2ray 服务，跟着说明文档配置，并设置端口为 10123。如果步骤没问题，你将会获得一些配置参数和 v2ray 协议链接。\",\"然后下载一个 代理客户端，并把协议链接录入测试 123.123.123.123.10123 的代理服务是否可用。\",\"相关信息\",\"海外服务器的采购可以使用 阿里云 等国内厂商没有问题，但依然推荐一些国外厂商的云主机，比如 硅云，也可以去找一些小众更便宜的云服务器提供商。\",\"服务器地点一般选择 香港、新加坡 等靠近国内的延迟会比较低。\"]},\"345\":{\"h\":\"放行端口的步骤\",\"t\":[\"以阿里云服务器为例，版本为 CentOS 7.x，首先设置安全组，添加 10123 端口为公开：\",\"然后还要在服务器上，开启防火墙并开放指定端口：\",\"查看防火墙状态并开启\",\"systemctl status firewalld\",\"如果是 active(dead) 就表示停止，需要开启防火墙\",\"systemctl start firewalld\",\"开放指定端口\",\"firewall-cmd --zone=public --add-port=10123/tcp --permanent\",\"参数解释\",\"参数\",\"注释\",\"–zone=public\",\"作用域，公开的\",\"–add-port=10123/tcp\",\"添加端口，格式为：端口/通讯协议\",\"–permanent\",\"永久生效，没有此参数重启后失效\",\"重启防火墙\",\"firewall-cmd --reload\",\"查看端口号命令\",\"查看端口是否放行成功\",\"firewall-cmd --list-all # 查看防火墙规则 或者 firewall-cmd --list-ports # 查看防火墙端口\",\"查看当前所有 tcp 端口信息\",\"netstat -ntlp\",\"查看 10123 端口使用情况\",\"netstat -ntulp | grep 10123\",\"测试端口是否能连接上\",\"打开：https://tcp.ping.pe/\",\"写上 IP 地址和端口，内容为 ip:端口，示例：123.123.123.123:10123，然后点击 Go 或者直接回车\",\"如果显示 successful，证明端口能连接；如果显示 failed，那就是无法连接上端口。\",\"更简单的办法\",\"正常来说，上面这些步骤执行后，端口一般都能连接上，如果使用上述地址测试后仍然无法连接，可能还存在外部防火墙没关或者端口放行方向不正确等问题。\",\"为了更方便地管理防火墙和端口规则，推荐使用宝塔面板来操作。\",\"配置好宝塔后，找到 安全 界面，添加端口规则，输入 10123 端口点击确定，其他保持默认即可。\"]},\"346\":{\"h\":\"保护你的代理服务器\",\"t\":[\"注意\",\"如果你已经自建代理服务并用起来了，但是别开心的太早，因为 123.123.123.123 的 IP 可能过几天就会被 GFW 扫描并封禁。 虽然你可以更换 IP ，但是这毕竟很麻烦，而且并不安全，而且更换 IP 会产生一定的费用。 这个时候你需要采用如下做法来保护你的海外服务器以及 IP。\",\"再准备一台国内的服务器，假设名为 服务器B（IP为 456.456.456.456），并设置安全组开放 20456 端口。\",\"在 服务器B 中安装 Nginx 并添加如下配置：\",\"stream { upstream v2ray { server 123.123.123.123:10123; } server { listen 20456; proxy_pass v2ray; ssl_preread on; } }\",\"配置解释\",\"这一步的意思是：将 国内服务器B 中来自 20456 端口的请求全部转发给 国外服务器A 的 10123 端口。\",\"打开 代理客户端 的设置界面，将 123.123.123.123.10123 代理服务修改为 456.456.456.456.20456。然后测试代理服务是否可用。示例配置在 本地代理客户端\",\"详情\",\"这一步的意思是，在其它设置不变的情况下，将原本的 服务器A 的地址和端口换成 服务器B 的。\",\"到这一步之后，你每次使用代理客户端时，实际上全都是在请求国内的服务器，这时 GFW 的扫描不会发觉任何异常，也无法封禁国内 IP。\",\"修改 服务器A 的安全组，在宝塔上配置，让 10123 端口只允许 IP 为 456.456.456.456 的机器访问。\",\"详情\",\"到这一步之后 GFW 扫描 服务器A 就不会发现任何异常，毕竟这个端口的安全组会阻拦 GFW 的访问，表面看它就是一个平平无奇的服务器而已。 然后国内的 服务器B 本身就在国内，不受 GFW 约束。\",\"日常的代理客户端，只会被抓到它在请求国内服务器，则 IP 地址安全。\",\"当然，两台服务的成本确实会有点点高，实测这种方案最为安全和稳定。\"]},\"347\":{\"h\":\"本地代理客户端\",\"t\":[\"https://github.com/v2rayU/v2rayU\",\"Windows：https://github.com/2dust/v2rayn/releases 下载 v2rayN-With-Core.zip 和 v2rayN.zip 并解压，然后将前者目录中的内容覆盖替换到后者目录中，然后就可以双击 v2rayN.exe 文件进行使用了。\",\"Android：https://github.com/2dust/v2rayNG/releases 下载对应的 apk 文件安装即可。如果打不开或安装失败就多换几个安装包试试。\",\"MacOS：https://github.com/yanue/V2rayU/releases 下载对应的 .dmg 文件安装即可。如果打不开或安装失败就多换几个安装包试试。\",\"Windows 客户端配置如下：\",\"找到「服务器」菜单，点击 添加[VMess]服务器\",\"输入代理的 IP 和端口，像上面我们配置了请求转发，那这里就填 国内服务器B 的配置，然后点击生成用户 ID，最后点击确定。\",\"确定后就会自动开始代理服务了。然后系统代理选择 自动配置系统代理（这样就不用到设置里面配置代理了），路由选择 绕过大陆（这样如果国内能访问就优先用国内线路，访问不了再用代理线路）。\",\"因为我自己有加速器，科学上网的需求也不是很高，所以用的国外服务器配置很一般，网速有点慢🤣.\",\"客户端配置\",\"本地已自动配置\"]},\"348\":{\"c\":[\"工具搭建\"]},\"349\":{\"c\":[\"教程\"]},\"350\":{\"h\":\"自建网盘兼图床\",\"t\":[\"继自建博客之后，需要展示图片，使用了一段时间 七牛云 + CDN 加速，前阵子出现了各大知名博主 CDN 流量被盗刷事件，不禁有点害怕。\",\"再加上文件放在云存储上，毕竟是公家的，文件上传都会被扫描一遍，毫无隐私可言，万一想存点嘿嘿的东西，那怎么办呢？而且公有云存储的存储有限，其次安全性和稳定性也不能一直保证，毕竟是放在别人家里，别人未必会帮你好好保存。\",\"于是利用之前学过的，用 MinIO 在服务器上搭建了一个对象存储服务，可以在网页端上传和下载文件，但很快发现，它仅仅只能用来存储，不能实现外部的访问。比如我想实现一个图床，其自身并不能提供一个外部链接，供所有人访问。\",\"其实解决方法也有，MinIO 提供了 SDK 和 API，可以给第三方调用，配合 Typora 或 PicGo 使用，也有很不错的效果，详情可自行百度。\",\"这里我结合日常使用习惯和需要，选择使用 Cloudreve。\"]},\"351\":{\"h\":\"什么是 Cloudreve\",\"t\":[\"Cloudreve 是一个支持多家云存储驱动的公有云文件系统，可助你即刻构建出兼备自用或公用的网盘服务，以跨平台、多用户、多存储节点、存储无关的方式，通过多种存储策略的支持、虚拟文件系统等特性实现灵活的文件管理体验。\",\"具有非常多的功能，可以分布式部署，集成了多家云存储端，既可以将文件存储在本地，也可以存储在外部，实现无差别存取；可以创建外链分享文件以及目录；支持 WebDAV 协议，可以从多种设备和应用上访问等等，可以说 Cloudreve 完美满足了我所需要的功能。\"]},\"352\":{\"h\":\"搭建过程\",\"t\":[\"根据 官方文档，快速部署。\",\"在 GitHub Release 中下载已构建打包好的压缩包，选择 linux_amd64.tar.gz 版本。\",\"直接放上压缩包（它真的太方便了）：cloudreve_3.8.3_linux_amd64.tar.gz\",\"转到下载的文件夹目录，解压并启动。\",\"#解压获取到的主程序 tar -zxvf cloudreve_3.8.3_linux_amd64.tar.gz # 赋予执行权限 chmod +x ./cloudreve # 启动 Cloudreve ./cloudreve\",\"启动后如下图所示：\",\"Cloudreve 在首次启动时，会创建初始管理员账号（上图黄色部分），请注意保管管理员密码，此密码只会在首次启动时出现。如果忘记了初始管理员密码，需要删除同级目录下的 cloudreve.db，重新启动主程序以初始化新的管理员账户。\",\"启动后 Cloudreve 默认会监听 5212 端口，此时可以在浏览器中访问 http://服务器IP:5212，输入管理员账号密码进入 Cloudreve。\",\"其实到这一步，这个网盘就已经搭建完成可以使用了。下面是一些个人配置。\",\"右上角「个人 - 管理面板」，配置站点信息\",\"配置存储策略\",\"本机存储 即存储在安装 Cloudreve 的机器上，从机存储 用于配置分布式存储，另外也提供了常见的云存储供应商选项，可以将文件存储在第三方，通过 Cloudreve 访问。\",\"配置存储策略：存储目录为 Cloudreve 安装路径下的相对路径，也可以是机器的绝对路径。存储路径和文件名都可以使用 魔法变量，非常方便。\",\"最重要的是配置直链，开启后每个文件都会生成一个链接，允许外部访问，而且长度很短，只要不删除就能一直保留。有需要的话也可以配置 CDN 域名加速访问。\",\"开启直链后的效果如下，任何一个文件都可以拥有一个外链，且不随文件位置的改变而变化，只与文件名有关。\",\"这样就实现了一个图床的效果，且后面配合 WebDAV，本地保存图片后，云端生成外链使用，且图片如果有修改，只要文件名不变，外链也不用改。\",\"后面的配置自行设置即可。新添加一个存储策略时采用的是 向导模式编辑，后续可以通过 专家模式 进行更详细的配置。\",\"在用户组里面，可以指定用户使用的存储策略和可用的最大容量，以及下载限速（当然不建议这么做）、创建分享链接等等。默认的下载不限速，下载速度只和机器自身的性能相关。\",\"如果不想用默认创建的管理员账号密码，可以进行修改。\"]},\"353\":{\"h\":\"配置进程守护\",\"t\":[\"什么是守护进程：深入理解守护进程：守护进程干嘛的？\",\"相关信息\",\"守护进程（Daemon）：是一类在后台运行的系统服务进程，而不是在交互式用户界面下运行的进程。它们通常在系统启动时启动，并持续运行以提供某种服务或执行特定任务。守护进程独立于任何终端会话，通常不接受用户输入，而是通过系统的事件驱动或定时器来执行任务。\",\"Linux 系统有很多守护进程，大多数服务都是用守护进程实现的。例如常见的常见的守护进程包括系统日志进程 syslogd、 Web 服务器 httpd、邮件服务器 sendmail 和数据库服务器 mysqld 等。\",\"为什么要配置进程守护呢？\",\"因为我们的 Cloudreve 作为一个网盘，相当于是一个文件服务器，其要求一定是能稳定运行，这样我们才能随时随地使用它。如果不将它注册为一个进程，进行进程守护，万一服务器突然宕机或停电等，我们的网盘服务将变得不可用。\",\"注意\",\"从前面使用 ./cloudreve 命令启动服务可以看出，其实 Cloudreve 默认启动方式是前台启动，好处是可以提供即时的交互体验和日志查看，但坏处是它会占用大量的系统资源，除非关闭否则无法使用其他 Linux 命令、无法使用其他应用程序，且运行不稳定，容易受到干扰而崩溃停止。\",\"所以需要将 Cloudreve 注册为一个进程，设置开机自动启动，当服务器宕机后恢复也能够重启服务。\",\"官方文档中提供了两种配置进程守护的方法，分别是 Systemd 和 Supervisor。\",\"Systemd 是Linux 自带的系统和服务管理器，常见命令以 systemctl 开头。\",\"Supervisor 是一个轻量级的进程管理工具，推荐搭配宝塔面板使用，效果更好。\",\"这里我使用 Systemd 配置进程守护：\",\"创建配置文件\",\"vim /usr/lib/systemd/system/cloudreve.service\",\"将下面代码粘贴到配置文件中，并将下文 PATH_TO_CLOUDREVE 更换为程序所在目录\",\"[Unit] Description=Cloudreve Documentation=https://docs.cloudreve.org After=network.target After=mysqld.service Wants=network.target [Service] WorkingDirectory=/PATH_TO_CLOUDREVE ExecStart=/PATH_TO_CLOUDREVE/cloudreve Restart=on-abnormal RestartSec=5s KillMode=mixed StandardOutput=null StandardError=syslog [Install] WantedBy=multi-user.target\",\"更新配置并设置开机启动\",\"# 更新配置 systemctl daemon-reload # 启动服务 systemctl start cloudreve # 设置开机启动 systemctl enable cloudreve\",\"管理命令：\",\"# 启动服务 systemctl start cloudreve # 停止服务 systemctl stop cloudreve # 重启服务 systemctl restart cloudreve # 查看状态 systemctl status cloudreve\"]},\"354\":{\"h\":\"配置站点 URL 及免费 HTTPS\",\"t\":[\"先去阿里云服务器配置 域名解析DNS，添加记录，填写想配置的「二级域名」，再填写「服务器 IP 地址」即可。\",\"再去 阿里云数字证书管理服务 申请免费的 SSL 证书。\",\"原「免费证书」已经换成了「个人测试证书」，点击「创建证书」。\",\"输入想要配置的域名，勾选「快捷签发」，第一次申请的时候要填个人信息，签发速度会比较慢，大概 1 个小时，后面再申请的时候就很快了，10 分钟左右就能批下来。\",\"得到 SSL 证书后，下载证书，选择服务器类型为 Nginx。\",\"解压后将 pem 和 key 文件上传至 Linux 服务器，建议放在 Nginx 目录下，然后修改 Nginx 的配置文件 nginx.conf。\",\"提示\",\"使用 Linux 命令安装的 Nginx，默认路径在 /usr/nginx/\",\"而使用宝塔面板安装的 Nginx，默认路径在 /www/server/panel/vhost/nginx\",\"可以通过查看 nginx 的运行进程，显示 nginx 的 安装目录\",\"ps -aux | grep nginx\",\"在 nginx.conf 中添加如下配置：\",\"http { server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name cloud.braumace.cn; # 指定域名 root /usr/share/nginx/html; ssl_certificate /etc/pki/nginx/cloud.braumace.cn.pem; # pem存放路径 ssl_certificate_key /etc/pki/nginx/cloud.braumace.cn.key; # key存放路径 ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers PROFILE=SYSTEM; ssl_prefer_server_ciphers on; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://127.0.0.1:5212; # 本地访问端口 # 如果要使用本地存储策略，请将下一行注释符删除，并更改大小为理论最大文件尺寸 client_max_body_size 20000m; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } }\",\"最后在 Cloudreve 管理面板，「站点信息」里面配置站点 URL 为 https://cloud.braumace.cn 即可。\"]},\"355\":{\"h\":\"配置 WebDAV\"},\"356\":{\"h\":\"什么是 WebDAV\",\"t\":[\"WebDAV 是一种基于 HTTP 协议的文件传输协议，如今有许多第三方文件管理器、视频播放器等产品都支持通过 WebDAV 协议访问 Cloudreve 中的文件，可以借此实现跨平台的文件共享与同步。\",\"简单来说，WebDAV 就像一个存储服务，各种应用都可以连接到它，允许应用直接访问我们的云盘内容，对其进行读写操作。\"]},\"357\":{\"h\":\"Cloudreve 使用 WebDAV\",\"t\":[\"Cloudreve 要使用 WebDAV，要先在后台管理面板为对应用户组开启 WebDAV 使用权限。WebDAV 所使用的账号与 Cloudreve 账号并不互通，需要单独创建。\",\"再前往前台 「导航左侧 - 连接 - 创建新账号」 创建供 WebDAV 使用的账号信息。创建完成后系统会为此账号自动生成密码，得到 WebDAV 的连接地址，密码则为系统所生成的密码。\",\"创建 WebDAV 账号时，可以为此账号指定相对根目录，此账号只能通过 WebDAV 访问所指定相对根目录下的目录及文件。\"]},\"358\":{\"h\":\"Windows 使用 WebDAV\",\"t\":[\"在上方菜单中，找到「计算机 - 映射网络驱动器」，点击添加。\",\"指定驱动器号，将 Cloudreve 系统生成的连接地址填入，点击「完成」再填入账号和生成的密码。\",\"连接成功后如下所示：\",\"这样就实现了无感知地调用，可以像操作本地磁盘一样操作网盘了，包括文件的读取、存储，第三方平台对文件的读取保存都和本地一模一样。 （不过存储空间是映射的本地 C 盘的，应该是 Windows 本身的 WebDAV 不支持，获取不到实际的存储大小）\"]},\"359\":{\"c\":[\"工具搭建\"]},\"360\":{\"c\":[\"教程\"]},\"361\":{\"h\":\"二叉搜索树中第K小的元素\",\"t\":[\"230.二叉搜索树中第K小的元素\"]},\"362\":{\"h\":\"题意\",\"t\":[\"给定一个二叉搜索树的根节点 root，和一个整数 k，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。\"]},\"363\":{\"h\":\"思路\",\"t\":[\"利用二叉搜索树的重要性质：二叉搜索树的中序遍历为递增序列。\",\"也就是说，本题可被转化为求中序遍历的第 k 个节点。\",\"转化为求中序遍历的第k个节点\",\"使用 ans 记录并更新遍历到的节点，当 k = 0 时，返回即可。\",\"代码：\",\"class Solution { int k; int ans; void dfs(TreeNode root) { if (root == null) return; dfs(root.left); if (k == 0) return; if (--k == 0) ans = root.val; dfs(root.right); } public int kthSmallest(TreeNode root, int k) { this.k = k; dfs(root); return ans; } }\"]},\"364\":{\"h\":\"进阶\",\"t\":[\"如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\"]},\"365\":{\"h\":\"思路\",\"t\":[\"在前面的方法中，我们之所以需要中序遍历前 k 个元素，是因为我们不知道子树的结点数量，不得不通过遍历子树的方式来获知。为了优化算法，我们可以记录每个子树的结点数。对于每个结点，先记录左子树中的结点数 leftNodes，然后缩小查找第 k 小的元素的范围。\",\"判断：\",\"如果 leftNodes = k − 1，则当前结点值即为第 k 小的元素，返回当前结点值。\",\"如果 leftNodes > k − 1，则第 k 小的元素一定在左子树中，因此在左子树中寻找第 k 小的元素。\",\"如果 leftNodes < k − 1，则第 k 小的元素一定在右子树中，由于以当前结点为根结点的子树中的大于右子结点值的结点数等于 leftNodes + 1，因此在右子树中寻找第 k − leftNodes − 1 小的元素。\"]},\"366\":{\"h\":\"代码\",\"t\":[\"class Solution { // 左右子树返回信息只需要节点数，无需额外定义数据结构 public int countNodes(TreeNode root) { if(root == null) return 0; // 递归处理左右子树并接收返回值 int leftNodes = countNodes(root.left); int rightNodes = countNodes(root.right); // 判断分析本层递归返回值的具体值 return leftNodes + rightNodes + 1; } public int kthSmallest(TreeNode root, int k) { int leftNodes = countNodes(root.left); if (leftNodes < k - 1) { // 答案存在右子树中 return kthSmallest(root.right,k - leftNodes - 1); } else if (leftNodes == k - 1) { return root.val; } else { return kthSmallest(root.left,k); } } }\"]},\"367\":{\"c\":[\"hot100\",\"数据结构\"]},\"368\":{\"c\":[\"二叉树\",\"递归\"]},\"369\":{\"h\":\"二叉树中的最大路径和\",\"t\":[\"124.二叉树中的最大路径和\"]},\"370\":{\"h\":\"题意\",\"t\":[\"二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\",\"路径和 是路径中各节点值的总和。\",\"给你一个二叉树的根节点 root ，返回其 最大路径和 。\"]},\"371\":{\"h\":\"思路\"},\"372\":{\"h\":\"代码\"},\"373\":{\"c\":[\"hot100\",\"数据结构\"]},\"374\":{\"c\":[\"二叉树\",\"递归\",\"树形DP\"]},\"375\":{\"h\":\"二叉树展开为链表\",\"t\":[\"114.二叉树展开为链表\"]},\"376\":{\"h\":\"题意\",\"t\":[\"给你二叉树的根结点 root ，请你将它展开为一个单链表：\",\"展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。\",\"进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？\"]},\"377\":{\"h\":\"思路一：先序遍历\",\"t\":[\"如题，展开的顺序其实就是二叉树的先序遍历。先序遍历的访问顺序是 “根、左子树、右子树”，左子树最后一个节点访问完后，接着会访问根节点的右子树节点。\",\"将左子树插入到右子树的地方\",\"将原来的右子树接到左子树的最右边节点\",\"考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null.\",\"时间复杂度 O(n)，其中 n 是树中节点的个数。空间复杂度 O(1)。\",\"代码：\",\"class Solution { public void flatten(TreeNode root) { while (root != null) { if (root.left != null) { // 找到当前节点左子树的最右节点 TreeNode pre = root.left; while (pre.right != null) { pre = pre.right; } // 将左子树的最右节点指向原来的右子树 pre.right = root.right; // 将当前节点指向左子树 root.right = root.left; root.left = null; } root = root.right; } } }\"]},\"378\":{\"h\":\"思路二：递归\",\"t\":[\"尝试直接在原来的节点上改变指向，利用先序遍历的代码，每遍历一个节点，就将上一个节点的右指针更新为当前节点。\",\"发现，如果这样做，原本的右子树就丢失了。\",\"用递归的思维，要解决这个问题的话，可以逆过来进行。逆序遍历，每遍历一个节点就将当前节点的右指针更新为上一个节点。这样就不会有丢失子树的问题了，因为更新当前的右指针的时候，当前节点的右子树已经访问过了。\",\"即使用变形后的后序遍历，遍历顺序是 右子树->左子树->根节点。这里我们不再打印根节点，而是利用一个全局变量 pre，更新当前根节点的右指针为 pre，左指针为 null.\",\"代码：\",\"class Solution { TreeNode pre = null; public void flatten(TreeNode root) { if (root == null) return; flatten(root.right); flatten(root.left); root.right = pre; root.left = null; pre = root; } }\"]},\"379\":{\"c\":[\"hot100\",\"数据结构\"]},\"380\":{\"c\":[\"二叉树\"]},\"381\":{\"h\":\"二叉树的中序遍历\",\"t\":[\"94.二叉树的中序遍历\"]},\"382\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\",\"二叉树的 中序遍历: 从根节点开始，首先遍历左子树，然后访问根节点，最后访问右子树。然后在遍历左子树的时候，同样首先遍历左子节点的左子树，然后访问根节点，最后遍历左子节点的右子树...\"]},\"383\":{\"h\":\"思路一（递归）\",\"t\":[\"按照中序遍历的过程，对每个节点的进行相同的递归处理。先处理这个节点的左子树，再处理这个节点，最后处理这个节点的右子树。\",\"递归终点：当处理的节点是空节点时，说明该节点的子树是空子树，无法继续向下处理了，递归结束，向上返回结果。\",\"代码：\"]},\"384\":{\"h\":\"思路二（迭代）\",\"t\":[\"在递归的方法中，其实隐式地维护了一个栈结构：一直递归寻找最下层的左节点，直到找到并处理完后，再返回处理上一层找到的节点。类似于栈中的先进后出，最后找到的节点处理完后，才会处理之前找到的节点。\",\"因此利用迭代的思想，使用一个栈，迭代地寻找当前节点的左子节点，找到后处理并弹出，同理再处理该节点和该节点的右子节点。全部弹出后，最后返回上一层，即当前节点的父节点。此时父节点相当于当前节点，当前节点相当于左节点，继续上述迭代处理即可。\",\"代码：\"]},\"385\":{\"c\":[\"hot100\",\"数据结构\"]},\"386\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"387\":{\"h\":\"二叉树的右视图\",\"t\":[\"199.二叉树的右视图\"]},\"388\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的 根节点root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\"]},\"389\":{\"h\":\"思路一：递归遍历\",\"t\":[\"其实就是找每一层最右边的节点。\",\"先递归右子树，再递归左子树，保证每往下遍历新一层时，第一个访问的一定是最右边的节点。记录当前层的深度，判断当前深度，对应的节点就在右视图中。\",\"代码：\",\"class Solution { void dfs(TreeNode root, int depth, List<Integer> ans) { if (root == null) return; // 如果这层是首次遍历，将节点加入到右视图中 // 如果不是首次遍历，则depth一定小于ans.size if (depth == ans.size()) ans.add(root.val); // 先递归右子树，保证首次遍历的一定是最右边的节点 dfs(root.right, depth + 1, ans); dfs(root.left, depth + 1, ans); } public List<Integer> rightSideView(TreeNode root) { List<Integer> ans = new ArrayList<>(); dfs(root, 0, ans); return ans; } }\"]},\"390\":{\"h\":\"思路二：层序遍历\",\"t\":[\"对二叉树进行层序遍历，每一层都从左到右遍历，将最后访问到的节点加入到右视图中。最后返回即可。\",\"代码：\",\"class Solution { public List<Integer> rightSideView(TreeNode root) { if (root == null) return List.of(); List<Integer> res = new ArrayList<>(); Queue<TreeNode> q = new LinkedList<>(); q.offer(root); while (!q.isEmpty()){ int n = q.size(); List<Integer> list = new ArrayList<>(n); while (n-- > 0){ TreeNode node = q.poll(); // 将每层最后一个加入到结果中 if (n == 0) res.add(node.val); if (node.left != null) q.offer(node.left); if (node.right != null) q.offer(node.right); } } return res; } }\"]},\"391\":{\"c\":[\"hot100\",\"数据结构\"]},\"392\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"393\":{\"h\":\"二叉树的层序遍历\",\"t\":[\"102.二叉树的层序遍历\"]},\"394\":{\"h\":\"题意\",\"t\":[\"给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\"]},\"395\":{\"h\":\"思路\",\"t\":[\"二叉树层序遍历使用 BFS 实现。\",\"使用队列存储每一层的节点，逐层遍历，取出遍历到的节点，并将该节点的左右子节点继续存到队列中进行下一层遍历，重复上述步骤即可。\"]},\"396\":{\"h\":\"代码\",\"t\":[\"class Solution { public List<List<Integer>> levelOrder(TreeNode root) { if (root == null) return List.of(); List<List<Integer>> ans = new ArrayList<>(); Queue<TreeNode> q = new LinkedList<>(); q.offer(root); while (!q.isEmpty()){ int n = q.size(); List<Integer> list = new ArrayList<>(n); // 预分配空间 while (n-- > 0){ TreeNode node = q.poll(); list.add(node.val); if (node.left != null) q.offer(node.left); if (node.right != null) q.offer(node.right); } ans.add(list); } return ans; } }\"]},\"397\":{\"c\":[\"hot100\",\"数据结构\"]},\"398\":{\"c\":[\"二叉树\",\"BFS\"]},\"399\":{\"h\":\"二叉树的最大深度\",\"t\":[\"104.二叉树的最大深度\"]},\"400\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树 root ，返回其最大深度。\",\"二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\"]},\"401\":{\"h\":\"思路一：后序遍历（递归）\",\"t\":[\"递归实现：树深度 等于 左子树的深度 与 右子树的深度 中的 最大值 +1 。\",\"代码：\",\"class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; int l = maxDepth(root.left); int r = maxDepth(root.right); return Math.max(l, r) + 1; } }\"]},\"402\":{\"h\":\"思路二：层序遍历（迭代）\",\"t\":[\"队列实现：每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。\",\"代码：\",\"class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; List<TreeNode> q = new LinkedList<>(); q.add(root); int res = 0; while (!q.isEmpty()){ List<TreeNode> tmp = new LinkedList<>(); for (TreeNode node : q){ if (node.left != null) tmp.add(node.left); if (node.right != null) tmp.add(node.right); } q = tmp; res++; } return res; } }\"]},\"403\":{\"c\":[\"hot100\",\"数据结构\"]},\"404\":{\"c\":[\"二叉树\",\"递归\",\"迭代\"]},\"405\":{\"h\":\"二叉树的最近公共祖先\",\"t\":[\"236.二叉树的最近公共祖先\"]},\"406\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\",\"百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\"]},\"407\":{\"h\":\"思路\",\"t\":[\"递归 + 分类讨论：\",\"分类讨论\"]},\"408\":{\"h\":\"代码\",\"t\":[\"class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 只要当前根节点是p和q中的任意一个，就返回（因为不能比这个更深了，再深p和q中的一个就没了） if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // 如果left 和 right都不为空，说明此时root就是最近公共节点 // 如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之亦然。 if (left == null) return right; if (right == null) return left; return root; } }\"]},\"409\":{\"c\":[\"hot100\",\"数据结构\"]},\"410\":{\"c\":[\"二叉树\",\"递归\"]},\"411\":{\"h\":\"二叉树的直径\",\"t\":[\"543.二叉树的直径\"]},\"412\":{\"h\":\"题意\",\"t\":[\"给你一棵二叉树的根节点，返回该树的 直径 。\",\"二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。\",\"两节点之间路径的 长度 由它们之间边数表示。\"]},\"413\":{\"h\":\"思路\",\"t\":[\"转化一下：\",\"所谓二叉树的直径，就是根节点的左右子树的最大深度之和，即左子树最深节点和右子树最深节点的距离。\",\"那么就是对每个节点计算左右子树的最大高度，得出每个节点的直径，顺便更新最大直径，递归返回即可。\"]},\"414\":{\"h\":\"代码\",\"t\":[\"class Solution { int ans = 0; int dfs(TreeNode root) { if (root == null) return 0; int l = dfs(root.left); int r = dfs(root.right); ans = Math.max(ans, l + r); // 更新最长路径 // 返回该节点的最大深度 return Math.max(l, r) + 1; } public int diameterOfBinaryTree(TreeNode root) { dfs(root); return ans; } }\"]},\"415\":{\"c\":[\"hot100\",\"数据结构\"]},\"416\":{\"c\":[\"二叉树\",\"递归\"]},\"417\":{\"h\":\"从前序与中序遍历序列构造二叉树\",\"t\":[\"105.从前序与中序遍历序列构造二叉树\"]},\"418\":{\"h\":\"题意\",\"t\":[\"给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\"]},\"419\":{\"h\":\"思路\",\"t\":[\"前序遍历性质：节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。 中序遍历性质：节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。\",\"根据以上性质，可得出以下推论：\",\"前序遍历的首元素 为 树的根节点 node 的值。\",\"在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ]。\",\"根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ]。\",\"如下图:\",\"前序 + 中序建树\",\"通过以上三步，可确定 三个节点 ：1.树的根节点、2.左子树根节点、3.右子树根节点。\",\"根据分治思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。\",\"递归建树:\",\"先建立根节点：从前序遍历数组的第一个元素开始，根节点为 preorder[0]\",\"再划分左右子树：确定根节点再中序遍历中的位置 i，划分左子树范围 [left, i - 1]，右子树范围 [i + 1, right]\",\"最后构建左右子树：开始左右子树递归\",\"设前序遍历中根节点的索引为 root，则左子节点索引为 root + 1，右子节点索引为 root + i - left + 1.\",\"由于是根据前序遍历的节点来确定中序遍历中节点的位置，所以使用 Map 存储中序遍历的节点与索引的映射关系。\",\"注意\",\"本文方法只适用于 “无重复节点值” 的二叉树。\",\"如果题目中给定的节点值存在重复的解法：https://doocs.github.io/leetcode/lc/105/#_3\"]},\"420\":{\"h\":\"代码\",\"t\":[\"class Solution { int[] preorder; HashMap<Integer, Integer> mp = new HashMap<>(); TreeNode build(int root, int left, int right) { if (left > right) return null; // 递归终止 TreeNode node = new TreeNode(preorder[root]); // 建立根节点 int i = mp.get(preorder[root]); // 划分根节点、左子树、右子树 node.left = build(root + 1, left, i - 1); // 开启左子树递归 node.right = build(root + i - left + 1, i + 1, right); // 开启右子树递归 return node; // 回溯返回根节点 } public TreeNode buildTree(int[] preorder, int[] inorder) { this.preorder = preorder; for(int i = 0; i < inorder.length; i++){ mp.put(inorder[i], i); } return build(0, 0, inorder.length - 1); } }\",\"另外一种 K 神的写法：\",\"class Solution { // map存节点和对应的下标 Map<Integer, Integer> premap = new HashMap<>(); // 前序 Map<Integer, Integer> inmap = new HashMap<>(); // 中序 // 当left = right时返回 TreeNode build(int rootIndex, int left, int right, int[] preorder, int[] inorder) { if (left > right) return null; if (left == right) return new TreeNode(inorder[left]); int rootPreIndex = premap.get(rootIndex); int rootInIndex = inmap.get(rootIndex); TreeNode root = new TreeNode(rootIndex); // 建立左子树 if (rootPreIndex + 1 > 0 && rootPreIndex < preorder.length){ root.left = build(preorder[rootPreIndex + 1], left, rootInIndex - 1, preorder, inorder); } else { root.left = null; } // 建立右子树 if (rootPreIndex + rootInIndex - left + 1 > 0 && rootPreIndex + rootInIndex - left + 1 < preorder.length){ root.right = build(preorder[rootPreIndex + rootInIndex - left + 1], rootInIndex + 1, right, preorder, inorder); } else { root.right = null; } // 返回根节点 return root; } public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i < preorder.length; i++){ premap.put(preorder[i], i); } for (int i = 0; i < inorder.length; i++){ inmap.put(inorder[i], i); } return build(preorder[0], 0, preorder.length - 1, preorder, inorder); } }\"]},\"421\":{\"c\":[\"hot100\",\"数据结构\"]},\"422\":{\"c\":[\"二叉树\",\"递归\",\"哈希\"]},\"423\":{\"h\":\"实现 Trie（前缀树）\",\"t\":[\"208.实现Trie（前缀树）\"]},\"424\":{\"h\":\"题意\",\"t\":[\"（发音类似 \\\"try\\\"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\",\"请你实现 Trie 类：\",\"Trie() 初始化前缀树对象。\",\"void insert(String word) 向前缀树中插入字符串 word 。\",\"boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\",\"boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\"]},\"425\":{\"h\":\"思路\",\"t\":[\"基于前缀树结构，每一层的节点并不是直接存储了某个字符，而是记录这一层节点对应字符串的位置是否出现了某个字符。比如根节点就是记录了字符串首个位置，第二层节点就是记录了字符串索引 1 的位置。\",\"树的结构\",\"我们可以将每一个字符串存储到树中，并且对于相同前缀只存储一次「从根节点出发到任一个节点都是一个前缀」。对于每个加入的字符串我们一定能在树中找到一条路径还原它。\",\"初始化：\",\"因为字符串中只存在小写字母，因此每个节点最多有 26 个子节点。\",\"使用 children[26] 的列表存储当前节点对应出现过的字符的子节点。\",\"使用布尔字段 isEnd，表示该节点是否为字符串的结尾。\",\"isEnd\",\"如果要查找一个完整的字符串，当我们找到时，我们如何知道找到的这部分是一个完整的字符串还是某个字符串的前缀呢？\",\"因此我们对每个节点引入一个标志 isEnd 标记当前节点对应一个完整字符串，我们在插入字符串的时候将最后一个字符对应的节点的标志位置为 True。\",\"当我们查找一个完整字符串时，既要能找到对应的节点，同时节点的标志位还必须为 true。\",\"插入字符串：\",\"假设当前节点为 node，当前要加入的字符为 ch：\",\"如果当前节点 node 的子节点列表中，ch 位置没有节点，则新建一个节点\",\"然后更新 node 为子节点，加入下一个字符\",\"node 初始为前缀树的根节点 root\",\"查找前缀：\",\"假设当前节点为 node，当前要查找的字符为 ch：\",\"如果当前节点 node 的子节点列表中，ch 位置没有节点，说明这个字符没有匹配上，前缀不存在退出查找\",\"否则更新 node 为子节点，寻找下一个字符\",\"node 初始为前缀树的根节点 root\"]},\"426\":{\"h\":\"代码\",\"t\":[\"class Trie { private Trie[] children; // 子节点列表 private boolean isEnd; // 标记是否尾节点 public Trie() { children = new Trie[26]; isEnd = false; } public void insert(String word) { Trie node = this; // 从根节点开始构造这个word对应的路径节点 int n = word.length(); for (int i = 0; i < n; i++){ // 将当前字符添加到当前节点对应的子节点位置，然后递归更新 int idx = word.charAt(i) - 'a'; if (node.children[idx] == null){ node.children[idx] = new Trie(); } node = node.children[idx]; } node.isEnd = true; // 最后一个节点的isEnd置为true，表示一个完整的字符串 } public boolean search(String word) { Trie node = searchPrefix(word); // 返回不为空且节点标记为尾节点，则包含word这个完整的字符串 return node != null && node.isEnd; } public boolean startsWith(String prefix) { return searchPrefix(prefix) != null; // 返回不为空，则包含了prefix前缀 } // 查找字典树是否包含word前缀 private Trie searchPrefix(String word) { Trie node = this; // 从根节点依次开始匹配每个字符 int n = word.length(); for (int i = 0; i < n; i++){ int idx = word.charAt(i) - 'a'; node = node.children[idx]; // 根据当前字符获取对应的子节点 if (node == null){ return null; // 只要当前节点为空，则不包含这个字符串，直接返回空指针 } } return node; // 否则匹配成功返回node } }\"]},\"427\":{\"c\":[\"hot100\",\"图论\"]},\"428\":{\"c\":[\"字典树\"]},\"429\":{\"h\":\"对称二叉树\",\"t\":[\"101.对称二叉树\"]},\"430\":{\"h\":\"题意\",\"t\":[\"给你一个二叉树的根节点 root ， 检查它是否轴对称。\"]},\"431\":{\"h\":\"思路\",\"t\":[\"递归结束条件：\",\"都为空指针返回 true\",\"只有一个为空返回 false\",\"递归过程：\",\"判断两个指针当前节点值是否相等\",\"判断 A 的右子树与 B 的左子树是否对称\",\"判断 A 的左子树与 B 的右子树是否对称\",\"短路原则：\",\"在递归判断过程中存在短路现象，也就是做 与 操作时，如果前面的值返回 false 则后面的不再进行计算\"]},\"432\":{\"h\":\"代码\",\"t\":[\"class Solution { boolean isSameTree(TreeNode p, TreeNode q) { if (p == null || q == null) return p == q; // 左对右，右对左，判断对应的两个节点是否相等 return p.val == q.val && isSameTree(p.left, q.right) && isSameTree(p.right, q.left); } public boolean isSymmetric(TreeNode root) { return isSameTree(root.left, root.right); } }\"]},\"433\":{\"c\":[\"hot100\",\"数据结构\"]},\"434\":{\"c\":[\"二叉树\",\"递归\"]},\"435\":{\"h\":\"将有序数组转换为二叉搜索树\",\"t\":[\"108.将有序数组转换为二叉搜索树\"]},\"436\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。\",\"平衡二叉树：是指该树所有节点的左右子树的深度相差不超过 1。\"]},\"437\":{\"h\":\"思路\",\"t\":[\"由于 BST 的中序遍历是升序的，所以本题等同于根据中序遍历的序列建立二叉搜索树。\",\"因为本题要求高度平衡，所以选择序列的中间值作为根节点，不断二分递归建立左子树和右子树。\"]},\"438\":{\"h\":\"代码\",\"t\":[\"class Solution { TreeNode dfs(int[] nums, int l, int r) { if (l > r) return null; // 以升序数组的中间元素作为根节点 int mid = l + (r - l) / 2; TreeNode root = new TreeNode(nums[mid]); // 递归的构建左子树与右子树 root.left = dfs(nums, l, mid - 1); root.right = dfs(nums, mid + 1, r); return root; } public TreeNode sortedArrayToBST(int[] nums) { return dfs(nums, 0, nums.length - 1); } }\"]},\"439\":{\"c\":[\"hot100\",\"数据结构\"]},\"440\":{\"c\":[\"二叉树\"]},\"441\":{\"h\":\"岛屿数量\",\"t\":[\"200.岛屿数量\"]},\"442\":{\"h\":\"题意\",\"t\":[\"给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\",\"岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\",\"此外，你可以假设该网格的四条边均被水包围。\"]},\"443\":{\"h\":\"思路一（DFS）\",\"t\":[\"解决岛屿题目最常见的就是 DFS 了，每次遇到一个岛屿中的陆地，就用 DFS 把这个岛屿「淹掉」。\",\"把二维数组中的每个格子看做「图」中的一个节点，这个节点和周围的四个节点连通，这样二维矩阵就被抽象成了一幅网状的「图」。\",\"为什么每次遇到岛屿，都要用 DFS 把岛屿「淹了」呢？主要是为了省事，避免维护 visited 数组。因为遍历图是需要 visited 数组记录遍历过的节点防止走回头路。\",\"由于 dfs 函数遍历到值为 0 的位置会直接返回，所以只要把经过的位置都设置为 0，就可以起到不走回头路的作用。\",\"最终岛屿的数量就是每次发现新岛屿的次数。\",\"代码：\",\"class Solution { void dfs(char[][] g, int i, int j) { int n = g.length, m = g[0].length; // 先判断范围和条件 if (i < 0 || i >= n || j < 0 || j >= m) return; if (g[i][j] == '0') return; // 将遍历过的陆地淹没 g[i][j] = '0'; // 遍历上下左右四个方向 dfs(g, i + 1, j); dfs(g, i, j + 1); dfs(g, i - 1, j); dfs(g, i, j - 1); } public int numIslands(char[][] g) { int res = 0; int n = g.length, m = g[0].length; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ // 每发现一个新岛屿，加入进来 if (g[i][j] == '1'){ res++; // 使用dfs将连通的陆地块淹掉 dfs(g, i, j); } } } return res; } }\"]},\"444\":{\"h\":\"思路二（BFS）\",\"t\":[\"广搜需要通过队列实现，每走过一个节点，就要加入队列并标记为「淹没」。\",\"遍历整个二维数组。如果一个位置为 '1'，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 '1' 都会被重新标记为 '0'。直到队列为空，搜索结束。\",\"最终岛屿的数量就是进行广度优先搜索的次数。\",\"class Solution { int n, m; char[][] g; int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1}; void bfs(int i, int j) { Queue<Pair<Integer, Integer>> q = new LinkedList<>(); q.offer(new Pair<>(i, j)); g[i][j] = '0'; while (!q.isEmpty()){ Pair<Integer, Integer> t = q.poll(); int x = t.getKey(); int y = t.getValue(); for (int k = 0; k < 4; k++){ int xx = x + dx[k], yy = y + dy[k]; if (xx < 0 || xx >= n || yy < 0 || yy >= m || g[xx][yy] == '0') continue; q.offer(new Pair<>(xx, yy)); g[xx][yy] = '0'; } } } public int numIslands(char[][] g) { n = g.length; m = g[0].length; this.g = g; int res = 0; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (g[i][j] == '1'){ bfs(i, j); res++; } } } return res; } }\"]},\"445\":{\"h\":\"思路三（并查集）\",\"t\":[\"遍历整个二维数组。如果一个位置为 '1'，则将其与相邻四个方向上的 '1' 在并查集中进行合并。\",\"因为是从（0,0）往（n，m）按顺序遍历，所以可以优化为每次只搜「右边」和「下边」的位置，因为「左边」和「上边」在之前的搜索中已经加入到集合了，不需要再搜了。\",\"最终岛屿的数量就是并查集中连通分量的数目。\",\"代码：\",\"class Solution { int[] p; int res; int find(int i) { return p[i] == i ? p[i] : find(p[i]); } void union(int i, int j){ if (find(i) == find(j)) return; // 避免重复合并操作 p[find(i)] = p[find(j)]; res--; } public int numIslands(char[][] g) { int n = g.length, m = g[0].length; p = new int[n * m]; res = 0; // 初始化 parent 数组，记录初始岛屿数（也就是 '1' 的数目） for (int i = 0; i < n; i++){ for(int j = 0; j < m; j++){ int idx = i * m + j; p[idx] = idx; if(g[i][j] == '1') res++; } } for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { int idx = i * m + j; if (g[i][j] == '1') { // 合并岛屿 if (i + 1 < n && g[i + 1][j] == '1') { union(idx, (i + 1) * m + j); } if (j + 1 < m && g[i][j + 1] == '1') { union(idx, i * m + j + 1); } } } } return res; } }\"]},\"446\":{\"c\":[\"hot100\",\"图论\"]},\"447\":{\"c\":[\"DFS\",\"BFS\",\"并查集\"]},\"448\":{\"h\":\"最长公共子序列\",\"t\":[\"1143.最长公共子序列\"]},\"449\":{\"h\":\"题意\",\"t\":[\"给定两个字符串 s1 和 s2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。\",\"一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\",\"例如，\\\"ace\\\" 是 \\\"abcde\\\" 的子序列，但 \\\"aec\\\" 不是 \\\"abcde\\\" 的子序列。\",\"两个字符串的公共子序列是这两个字符串所共同拥有的子序列。\"]},\"450\":{\"h\":\"思路\",\"t\":[\"用两个指针 i, j 在两个字符串上游走，这就是「状态」，字符串中的每个字符都有两种「选择」，要么在 lcs 中，要么不在。\",\"f[i][j] 的含义是：对于 s1[1..i] 和 s2[1..j]，它们的 LCS 长度是 f[i][j]。\"]},\"451\":{\"h\":\"代码\",\"t\":[\"class Solution { public int longestCommonSubsequence(String s1, String s2) { // 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 f[i][j] // 目标：s1[0..n-1] 和 s2[0..m-1] 的 lcs 长度，即 f[n][m] int n = s1.length(), m = s2.length(); // 初始化：f[0][..] = f[..][0] = 0 int f[][] = new int[n + 1][m + 1]; for (int i = 1; i <= n; i++) { for (int j = 1; j <= m; j++) { // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中 f[i][j] = Math.max(f[i][j - 1], f[i - 1][j]); // 因为 i 和 j 从 1 开始，所以要减一 if (s1.charAt(i - 1) == s2.charAt(j - 1)) // s1[i-1] 和 s2[j-1] 必然在 lcs 中 f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; } }\"]},\"452\":{\"c\":[\"hot100\",\"动态规划\"]},\"453\":{\"c\":[\"线性DP\"]},\"454\":{\"h\":\"滑动窗口最大值\",\"t\":[\"239.滑动窗口最大值\"]},\"455\":{\"h\":\"题意\",\"t\":[\"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\",\"返回 滑动窗口中的最大值 。\"]},\"456\":{\"h\":\"思路一（优先队列）\",\"t\":[\"使用优先队列，维护值和下标，窗口每次移动，判断当前最大值的位置，若已滑出窗口，则更新最大值，否则不更新。将每次移动的最大值保存在 ans[]中。\",\"代码：\",\"class Solution { public: vector<int> maxSlidingWindow(vector<int>& nums, int k) { int n = nums.size(); priority_queue<pair<int, int>> q; for (int i = 0; i < k; i++){ q.push({nums[i], i}); } vector<int> ans = {q.top().first}; for (int i = k; i < n; i++){ q.push({nums[i], i}); while (q.top().second <= i - k){ q.pop(); } ans.push_back(q.top().first); } return ans; } };\"]},\"457\":{\"h\":\"思路二（单调队列）\"},\"458\":{\"c\":[\"hot100\",\"数据结构\"]},\"459\":{\"c\":[\"滑动窗口\",\"优先队列\",\"单调队列\"]},\"460\":{\"h\":\"翻转二叉树\",\"t\":[\"226.翻转二叉树\"]},\"461\":{\"h\":\"题意\",\"t\":[\"给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\"]},\"462\":{\"h\":\"思路\",\"t\":[\"如何翻转二叉树？其实就是把二叉树上的每个节点的左右子节点都交换一下。\",\"利用给出的函数定义，递归地交换每个节点的左右子树，返回每次的根节点即可。\"]},\"463\":{\"h\":\"代码\",\"t\":[\"class Solution { // 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点 public TreeNode invertTree(TreeNode root) { if (root == null) return null; // 利用函数定义，先翻转左右子树 TreeNode l = invertTree(root.left); TreeNode r = invertTree(root.right); // 然后交换左右子节点 root.left = r; root.right = l; // 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root return root; } }\"]},\"464\":{\"c\":[\"hot100\",\"数据结构\"]},\"465\":{\"c\":[\"二叉树\",\"递归\"]},\"466\":{\"h\":\"腐烂的橘子\",\"t\":[\"994.腐烂的橘子\"]},\"467\":{\"h\":\"题意\",\"t\":[\"在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\",\"值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\",\"返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\"]},\"468\":{\"h\":\"思路\",\"t\":[\"从初始的 0 分钟开始，当前分钟的烂橘子都使其相邻位置的橘子也腐烂，从而不断扩散直到没有新鲜橘子或者无法扩散。\",\"这个过程与广度优先搜索的过程一致，常规的广度优先搜索只有一个起点，而这道题有多个起点，因为烂橘子不止一个，每个烂橘子都会去扩散腐烂周边的新鲜橘子。所以每次扩散需要考虑每一层（即最外层）的烂橘子，使用 size 记录每层烂橘子的数量，将每层的扩散情况都加入队列。\",\"重复上述步骤，即可得到最终的花费时间。\",\"另外，为了判断是否有永远不会腐烂的橘子，我们可以统计初始新鲜橘子的个数 fresh。在 BFS 中，每有一个新鲜橘子被腐烂，就把 fresh 减一，这样最后如果发现 fresh > 0，就意味着有橘子永远不会腐烂，返回 −1。\",\"初始化时间 time = -1，在每层遍历的时候 time++，这样初始的烂橘子时间为 0，因为它们是本来就有的。但要注意，在全为烂橘子的情况下要返回 0，可是在这种情况下 time 仍为其初始值 −1，所以最后要返回 max(time,0)。\"]},\"469\":{\"h\":\"代码\",\"t\":[\"使用链表作为队列，提取BFS方法\",\"class Solution { int n, m; int g[][]; int dx[] = {1, 0, -1, 0}; // x方向数组 int dy[] = {0, 1, 0, -1}; // y方向数组 int fresh = 0; int time = -1; // 初始化时间为-1 Queue<Pair<Integer, Integer>> q = new LinkedList<>(); // 将BFS过程提取为单独的一个方法 void bfs() { while (!q.isEmpty()){ time++; // 每遍历一层时间+1 int size = q.size(); // 取出这一层的烂橘子开始遍历 while (size-- > 0){ Pair<Integer, Integer> t = q.poll(); int x = t.getKey(); int y = t.getValue(); for (int k = 0; k < 4; k++){ // 开始扩散 int xx = x + dx[k], yy = y + dy[k]; if (xx >= 0 && xx < n && yy >= 0 && yy < m && g[xx][yy] == 1){ fresh--; q.offer(new Pair<>(xx, yy)); g[xx][yy] = 2; // 标记变成烂橘子 } } } } } public int orangesRotting(int[][] g) { n = g.length; m = g[0].length; this.g = g; for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (g[i][j] == 1){ fresh++; // 统计新鲜橘子数 } else if (g[i][j] == 2){ q.offer(new Pair<>(i, j)); // 将初始的烂橘子入队 } } } bfs(); return fresh > 0 ? -1 : Math.max(time, 0); } }\",\"更简洁的写法 - 使用数组列表作为队列（推荐）\",\"class Solution { int dd[][] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; // 四个方向 public int orangesRotting(int[][] g) { int n = g.length; int m = g[0].length; int fresh = 0; List<int[]> q = new ArrayList<>(); for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (g[i][j] == 1) fresh++; // 统计新鲜橘子个数 else if (g[i][j] == 2) q.add(new int[]{i, j}); // 初始的烂橘子 } } int time = -1; while (!q.isEmpty()) { time++; // 经过一分钟 List<int[]> tmp = q; // 取出当前最外层的烂橘子 q = new ArrayList<>(); // 记录下一层被扩散的烂橘子 for (int[] pos : tmp) { // 开始扩散 for (int[] d : dd) { int i = pos[0] + d[0]; int j = pos[1] + d[1]; if (0 <= i && i < n && 0 <= j && j < m && g[i][j] == 1) { fresh--; g[i][j] = 2; // 标记变成烂橘子 q.add(new int[]{i, j}); // 加入新的一层 } } } } return fresh > 0 ? -1 : Math.max(time, 0); } }\"]},\"470\":{\"c\":[\"hot100\",\"图论\"]},\"471\":{\"c\":[\"BFS\"]},\"472\":{\"h\":\"课程表\",\"t\":[\"207.课程表\"]},\"473\":{\"h\":\"题意\",\"t\":[\"你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。\",\"在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i]=[ai​,bi​] ，表示如果要学习课程 ai​ 则 必须 先学习课程 bi​ 。\",\"例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\"]},\"474\":{\"h\":\"思路\",\"t\":[\"判断条件：当存在循环依赖的时候，无法完成所有课程。\",\"比如：prerequisites = [[1,0],[0,1]]，在学习课程 1 之前，需要先完成​课程 0 ；并且学习课程 0 之前，还应先完成课程 1 。产生了循环依赖，所以不可能完成所有课程。\",\"所以，我们可以把题目的输入转化成一幅有向图，然后再判断图中是否存在环。\",\"使用邻接表建图：\",\"List<Integer>[] g; List<Integer>[] buildGraph(int n, int[][] edges) { // 图中共有 n 个节点 List<Integer>[] graph = new LinkedList[nu]; for (int i = 0; i < n; i++) { g[i] = new LinkedList<>(); } for (int[] edge : edges) { int from = edge[1], to = edge[0]; // 添加一条从 from 指向 to 的有向边 g[from].add(to); } return g; }\",\"接下来，遍历建好的图。\",\"要注意到图中并不一定所有节点都相连，所以要用一个 for 循环将所有节点都作为起点调用一次 DFS 搜索，用数组 st 标记所有走过的点，用数组 onPath 标记当前节点搜索时遍历过的节点，即路径节点，在搜索完当前所能走到的所有节点后，回退状态，以便给其他节点搜索。\",\"在一次搜索中，只要发现该节点已经被 onPath 标记了，表示回到了起点，成了一个环，那么就不满足条件，返回 false，否则返回 true。\"]},\"475\":{\"h\":\"代码\",\"t\":[\"class Solution { boolean onPath[]; // 记录一次DFS经过的节点 boolean st[]; // 记录遍历过的节点 boolean hasCycle = false; // 记录图中是否有环 void dfs(List<Integer>[] g, int x) { if (onPath[x]){ hasCycle = true; // 如果当前节点走过了，表示出现了环 } // 如果找到了环，就不用遍历了 if (st[x] || hasCycle) return; st[x] = true; onPath[x] = true; // 标记走过 for (int t : g[x]){ dfs(g, t); // 递归遍历 } onPath[x] = false; // 恢复现场 } // n为选修课程数，edges为先修课程关系 public boolean canFinish(int n, int[][] edges) { st = new boolean[n]; onPath = new boolean[n]; // 邻接表建图 g[a] -> b List<Integer>[] g = new LinkedList[n]; for (int i = 0; i < n; i++) g[i] = new LinkedList<>(); for (int[] edge : edges){ int from = edge[1]; int to = edge[0]; g[from].add(to); } for (int i = 0; i < n; i++){ dfs(g, i); } return !hasCycle; } }\"]},\"476\":{\"c\":[\"hot100\",\"图论\"]},\"477\":{\"c\":[\"DFS\"]},\"478\":{\"h\":\"路径总和 III\",\"t\":[\"437.路径总和 III\"]},\"479\":{\"h\":\"题意\",\"t\":[\"给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。\",\"路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\"]},\"480\":{\"h\":\"思路\",\"t\":[\"运用前缀和的思想，前缀和相当于从根节点开始的路径元素和。对二叉树进行递归遍历，同时用哈希表 cnt 统计从根节点到当前节点的路径上各个前缀和出现的次数。当我们递归到节点 node 时，设从根到 node 的路径元素和为 s，那么就找到了 cnt[s − targetSum] 个符合要求的路径，加入答案。\",\"设计递归函数 dfs(node,s)，表示当前遍历到的节点为 node，从根节点到当前节点的路径上的前缀和为 s。函数的返回值是统计以 node 节点及其子树节点作为路径终点且路径和为 targetSum 的路径数目。那么答案就是 dfs(root,0)。\"]},\"481\":{\"h\":\"代码\",\"t\":[\"class Solution { int targetSum; Map<Long, Integer> cnt = new HashMap<>(); int dfs(TreeNode root, long s){ if (root == null) return 0; s += root.val; int ans = cnt.getOrDefault(s - targetSum, 0); cnt.merge(s, 1, Integer::sum); ans += dfs(root.left, s); ans += dfs(root.right, s); cnt.merge(s, -1, Integer::sum); return ans; } public int pathSum(TreeNode root, int targetSum) { cnt.put(0L, 1); this.targetSum = targetSum; return dfs(root, 0); } }\"]},\"482\":{\"c\":[\"hot100\",\"数据结构\"]},\"483\":{\"c\":[\"二叉树\",\"递归\",\"前缀和\",\"哈希\"]},\"484\":{\"h\":\"验证二叉搜索树\",\"t\":[\"98.验证二叉搜索树\"]},\"485\":{\"h\":\"题意\",\"t\":[\"给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\",\"有效 二叉搜索树定义如下：\",\"节点的左子树只包含 小于 当前节点的数。\",\"节点的右子树只包含 大于 当前节点的数。\",\"所有左子树和右子树自身必须也是二叉搜索树。\"]},\"486\":{\"h\":\"思路一：前序遍历\",\"t\":[\"由题意可知：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。\",\"使用递归前序遍历，使用递归函数 isValidBST(node, l, r) 来判断，判断以 node 为根的子树，其所有的节点是否都在 (l,r) 的范围内，如果不在则直接返回。\",\"在递归调用左子树时，需要把上界 r 改为 node.val，因为左子树的所有节点都要小于根节点的值，所以可以缩小比较范围；同理，右子树下界 l 也改为 node.val.\",\"注意区间范围\",\"我们写的递归函数，判断区间为 (l,r)，注意是开区间，而节点的值范围在 [−231,231−1] 之间。\",\"本来看都是 int 类型，想当然地初始化上下界为 [Integer.MIN_VALUE, Integer.MAX_VALUE]，但是如果数据给的 root.val = 2147483647，即 231−1，会导致边界问题，判断 x < right 会出错，因为 Ingeger.MAX_VALUE = 231−1，两者相等，所以初始化范围还要更大些，故使用 Long 类型。\",\"前序遍历在某些数据下不需要递归到叶子节点就能返回（比如根节点左儿子的值大于根节点的值，左儿子就不会继续往下递归了），而中序遍历和后序遍历至少要递归到一个叶子节点。从这个角度上来说，前序遍历是最快的。\",\"代码：\",\"class Solution { boolean isValidBST(TreeNode node, long left, long right) { if (node == null) return true; int x = node.val; return left < x && x < right && isValidBST(node.left, left, x) && isValidBST(node.right, x, right); } public boolean isValidBST(TreeNode root) { return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } }\"]},\"487\":{\"h\":\"思路二：中序遍历\",\"t\":[\"中序遍历即层序遍历，先遍历左节点，再遍历根节点，最后遍历右子树。\",\"根据题意可知中序遍历得到的序列一定是升序的。所以我们在遍历的时候实时检查当前节点的值是否大于前一个遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。\",\"中序遍历很好地利用了二叉搜索树的性质，使用到的变量最少。\",\"代码：\",\"class Solution { long pre = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } if (!isValidBST(root.left) || root.val <= pre) { return false; } pre = root.val; return isValidBST(root.right); } }\"]},\"488\":{\"h\":\"思路三：后序遍历\",\"t\":[\"后序遍历先遍历左右子树，最后遍历根节点，即自底向上计算子问题的过程。\",\"需要遍历整棵树，先找到左右叶子节点，再一层层向上递归判断。\",\"代码：\",\"class Solution { long[] dfs(TreeNode node) { if (node == null) { return new long[]{Long.MAX_VALUE, Long.MIN_VALUE}; } long[] left = dfs(node.left); long[] right = dfs(node.right); long x = node.val; // 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了 if (right[0] <= x || x <= left[1]) { return new long[]{Long.MIN_VALUE, Long.MAX_VALUE}; } return new long[]{Math.min(left[0], x), Math.max(right[1], x)}; } public boolean isValidBST(TreeNode root) { return dfs(root)[1] != Long.MAX_VALUE; } }\"]},\"489\":{\"c\":[\"hot100\",\"数据结构\"]},\"490\":{\"c\":[\"二叉树\",\"递归\"]},\"491\":{\"h\":\"MySQL 基础知识\"},\"492\":{\"h\":\"1. 基础\"},\"493\":{\"h\":\"1.1 连接\",\"t\":[\"MySQL服务器启动完毕后，然后再使用如下指令，来连接 MySQL 服务器：\",\"mysql -u用户名 -p密码 [-h数据库服务器的IP地址 -P端口号]\",\"命令解释\",\"-h 参数不加，默认连接的是本地 127.0.0.1 的 MySQL 服务器\",\"-P 参数不加，默认连接的端口号是 3306\",\"上述指令，可以有两种形式：\",\"密码直接在 -p 参数之后直接指定 （这种方式不安全，密码直接以明文形式出现在命令行）\",\"密码在 -p 回车之后，在命令行中输入密码，然后回车\"]},\"494\":{\"h\":\"1.2 SQL 简介\",\"t\":[\"SQL：结构化查询语言。一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\"]},\"495\":{\"h\":\"1.2.1 SQL 通用语法\",\"t\":[\"1、SQL 语句可以单行或多行书写，以分号结尾。\",\"2、SQL 语句可以使用空格/缩进来增强语句的可读性。\",\"3、MySQL 数据库的 SQL 语句不区分大小写。\",\"4、注释：\",\"单行注释：-- 注释内容或 # 注释内容 (MySQL特有)\",\"多行注释： /* 注释内容 */\"]},\"496\":{\"h\":\"1.2.2 分类\",\"t\":[\"SQL 语句根据其功能被分为四大类：DDL、DML、DQL、DCL\",\"分类\",\"全称\",\"说明\",\"DDL\",\"Data Definition Language\",\"数据定义语言，用来定义数据库对象(数据库，表，字段)\",\"DML\",\"Data Manipulation Language\",\"数据操作语言，用来对数据库表中的数据进行增删改\",\"DQL\",\"Data Query Language\",\"数据查询语言，用来查询数据库中表的记录\",\"DCL\",\"Data Control Language\",\"数据控制语言，用来创建数据库用户、控制数据库的访问权限\"]},\"497\":{\"h\":\"2. 数据库设计-DDL\",\"t\":[\"针对于数据库设计，主要包括三个阶段：\",\"数据库设计阶段 \",\"参照页面原型以及需求文档设计数据库表结构\",\"数据库操作阶段 \",\"根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作\",\"数据库优化阶段 \",\"通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等\"]},\"498\":{\"h\":\"2.1 数据库操作\",\"t\":[\"DDL 英文全称是 Data Definition Language (数据定义语言)，用来定义数据库对象(数据库、表)。\",\"DDL 中数据库的常见操作：查询、创建、使用、删除。\"]},\"499\":{\"h\":\"2.1.1 查询数据库\",\"t\":[\"查询所有数据库：\",\"show databases;\",\"查询当前数据库：\",\"select database();\",\"用法\",\"我们要操作某一个数据库，必须要切换到对应的数据库中。\",\"通过指令 select database()，就可以查询到当前所处的数据库\"]},\"500\":{\"h\":\"2.1.2 创建数据库\",\"t\":[\"语法：\",\"create database [ if not exists ] 数据库名;\",\"注意：在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。\",\"可以使用 if not exists 来避免这个问题\",\"-- 数据库不存在,则创建该数据库；如果存在则不创建 create database if not extists my_database;\"]},\"501\":{\"h\":\"2.1.3 使用数据库\",\"t\":[\"语法：\",\"use 数据库名 ;\",\"切换数据库\",\"我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则不能操作。\"]},\"502\":{\"h\":\"2.1.4 删除数据库\",\"t\":[\"语法：\",\"drop database [ if exists ] 数据库名 ;\",\"如果删除一个不存在的数据库，将会报错。\",\"可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\",\"案例：删除 itcast 数据库\",\"drop database if exists itcast; -- itcast数据库存在时删除\",\"命令执行效果如下：\",\"说明\",\"上述语法中的 database，也可以替换成 schema\",\"如：create schema db01;\",\"如：show schemas;\"]},\"503\":{\"h\":\"2.2 表操作\",\"t\":[\"关于表结构的操作也是包含四个部分：创建表、查询表、修改表、删除表。\"]},\"504\":{\"h\":\"2.2.1 创建\"},\"505\":{\"h\":\"2.2.1.1 语法\",\"t\":[\"create table 表名( 字段1 字段1类型 [约束] [comment 字段1注释 ], 字段2 字段2类型 [约束] [comment 字段2注释 ], ...... 字段n 字段n类型 [约束] [comment 字段n注释 ] ) [ comment 表注释 ] ;\",\"注意： [ ] 中的内容为可选参数； 最后一个字段后面没有逗号\"]},\"506\":{\"h\":\"2.2.1.2 约束\",\"t\":[\"概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。\",\"作用：就是来保证数据库当中数据的正确性、有效性和完整性。\",\"在MySQL数据库当中，提供了以下5种约束：\",\"约束\",\"描述\",\"关键字\",\"非空约束\",\"限制该字段值不能为null\",\"not null\",\"唯一约束\",\"保证字段的所有数据都是唯一、不重复的\",\"unique\",\"主键约束\",\"主键是一行数据的唯一标识，要求非空且唯一\",\"primary key\",\"默认约束\",\"保存数据时，如果未指定该字段值，则采用默认值\",\"default\",\"外键约束\",\"让两张表的数据建立连接，保证数据的一致性和完整性\",\"foreign key\",\"注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。\",\"MySQL数据库为解决id问题，提供了一个关键字：auto_increment（自动增长）\",\"主键自增：auto_increment\",\"每次插入新的行记录时，数据库自动生成 id 字段(主键)下的值\",\"具有 auto_increment 的数据列是一个正数序列开始增长(从 1 开始自增)\"]},\"507\":{\"h\":\"2.2.1.3 数据类型\",\"t\":[\"MySQL中的数据类型主要分为三类：数值类型、字符串类型、日期时间类型。\",\"数值类型\",\"类型\",\"大小\",\"有符号(SIGNED)范围\",\"无符号(UNSIGNED)范围\",\"描述\",\"TINYINT\",\"1byte\",\"(-128，127)\",\"(0，255)\",\"小整数值\",\"SMALLINT\",\"2bytes\",\"(-32768，32767)\",\"(0，65535)\",\"大整数值\",\"MEDIUMINT\",\"3bytes\",\"(-8388608，8388607)\",\"(0，16777215)\",\"大整数值\",\"INT/INTEGER\",\"4bytes\",\"(-2147483648，2147483647)\",\"(0，4294967295)\",\"大整数值\",\"BIGINT\",\"8bytes\",\"(-263，263-1)\",\"(0，2^64-1)\",\"极大整数值\",\"FLOAT\",\"4bytes\",\"(-3.402823466 E+38，3.402823466351 E+38)\",\"0 和 (1.175494351 E-38，3.402823466 E+38)\",\"单精度浮点数值\",\"DOUBLE\",\"8bytes\",\"(-1.7976931348623157 E+308，1.7976931348623157 E+308)\",\"0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)\",\"双精度浮点数值\",\"DECIMAL\",\"依赖于M(精度)和D(标度)的值\",\"依赖于M(精度)和D(标度)的值\",\"小数值(精确定点数)\",\"字符串类型\",\"类型\",\"大小\",\"描述\",\"CHAR\",\"0-255 bytes\",\"定长字符串(需要指定长度)\",\"VARCHAR\",\"0-65535 bytes\",\"变长字符串(需要指定长度)\",\"TINYBLOB\",\"0-255 bytes\",\"不超过255个字符的二进制数据\",\"TINYTEXT\",\"0-255 bytes\",\"短文本字符串\",\"BLOB\",\"0-65 535 bytes\",\"二进制形式的长文本数据\",\"TEXT\",\"0-65 535 bytes\",\"长文本数据\",\"MEDIUMBLOB\",\"0-16 777 215 bytes\",\"二进制形式的中等长度文本数据\",\"MEDIUMTEXT\",\"0-16 777 215 bytes\",\"中等长度文本数据\",\"LONGBLOB\",\"0-4 294 967 295 bytes\",\"二进制形式的极大文本数据\",\"LONGTEXT\",\"0-4 294 967 295 bytes\",\"极大文本数据\",\"char 与 varchar 都可以描述字符串，char 是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。 而 varchar 是变长字符串，指定的长度为最大占用长度 。相对来说，char 的性能会更高些。\",\"示例： 用户名 username ---长度不定, 最长不会超过50 username varchar(50) 手机号 phone ---固定长度为11 phone char(11)\",\"日期时间类型\",\"类型\",\"大小\",\"范围\",\"格式\",\"描述\",\"DATE\",\"3\",\"1000-01-01 至 9999-12-31\",\"YYYY-MM-DD\",\"日期值\",\"TIME\",\"3\",\"-838:59:59 至 838:59:59\",\"HH:MM:SS\",\"时间值或持续时间\",\"YEAR\",\"1\",\"1901 至 2155\",\"YYYY\",\"年份值\",\"DATETIME\",\"8\",\"1000-01-01 00:00:00 至 9999-12-31 23:59:59\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值\",\"TIMESTAMP\",\"4\",\"1970-01-01 00:00:01 至 2038-01-19 03:14:07\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值，时间戳\"]},\"508\":{\"h\":\"2.2.2 查询\",\"t\":[\"查询当前数据库所有表\",\"show tables;\",\"查看指定表结构\",\"desc 表名 ; #可以查看指定表的字段、字段的类型、是否可以为NULL、是否存在默认值等信息\",\"查询指定表的建表语句\",\"show create table 表名 ;\"]},\"509\":{\"h\":\"2.2.3 修改\",\"t\":[\"添加字段\",\"alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];\",\"案例： 为 tb_emp 表添加字段 qq，字段类型为 varchar(11)\",\"alter table tb_emp add qq varchar(11) comment 'QQ号码';\",\"修改数据类型\",\"alter table 表名 modify 字段名 新数据类型(长度);\",\"alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];\",\"案例：修改 qq 字段名为 qq_num，字段类型 varchar(13)\",\"alter table tb_emp change qq qq_num varchar(13) comment 'QQ号码';\",\"删除字段\",\"alter table 表名 drop 字段名;\",\"修改表名\",\"rename table 表名 to 新表名;\"]},\"510\":{\"h\":\"2.2.4 删除\",\"t\":[\"删除表语法：\",\"drop table [ if exists ] 表名;\",\"if exists ：只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。\"]},\"511\":{\"h\":\"3. 数据库操作-DML\",\"t\":[\"DML英文全称是 Data Manipulation Language (数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\",\"添加数据（INSERT）\",\"修改数据（UPDATE）\",\"删除数据（DELETE）\"]},\"512\":{\"h\":\"3.1 增加 (insert)\",\"t\":[\"insert 语法：\",\"向指定字段添加数据\",\"insert into 表名 (字段名1, 字段名2) values (值1, 值2);\",\"全部字段添加数据\",\"insert into 表名 values (值1, 值2, ...);\",\"批量添加数据（指定字段）\",\"insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2);\",\"批量添加数据（全部字段）\",\"insert into 表名 values (值1, 值2, ...), (值1, 值2, ...);\",\"Insert 操作的注意事项：\",\"插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\",\"字符串和日期型数据应该包含在引号中。\",\"插入的数据大小，应该在字段的规定范围内。\"]},\"513\":{\"h\":\"3.2 修改 (update)\",\"t\":[\"update 语法：\",\"update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [where 条件] ;\",\"案例：将 tb_emp 表中 id 为 1 的员工，姓名 name 字段更新为'张三'\",\"update tb_emp set name='张三',update_time=now() where id=1;\",\"注意事项\",\"修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\",\"在修改数据时，一般需要同时修改公共字段 update_time，将其修改为当前操作时间。\"]},\"514\":{\"h\":\"3.3 删除 (delete)\",\"t\":[\"delete 语法：\",\"delete from 表名 [where 条件] ;\",\"注意事项\",\"DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\",\"DELETE 语句不能删除某一个字段的值(可以使用 UPDATE，将该字段值置为 NULL 即可)。\",\"当进行删除全部数据操作时，会提示询问是否确认删除所有数据，直接点击 Execute 即可。\"]},\"515\":{\"h\":\"4. 数据库操作-DQL\"},\"516\":{\"h\":\"4.1 语法\",\"t\":[\"DQL 查询语句，语法结构如下：\",\"SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数\",\"查询分为以下几种类型：\",\"基本查询（不带任何条件）\",\"条件查询（where）\",\"分组查询（group by）\",\"排序查询（order by）\",\"分页查询（limit）\"]},\"517\":{\"h\":\"4.2 基本查询\",\"t\":[\"在基本查询的 DQL 语句中，不带任何的查询条件，语法如下：\",\"查询多个字段\",\"select 字段1, 字段2, 字段3 from 表名;\",\"查询所有字段（通配符）\",\"select * from 表名;\",\"设置别名\",\"select 字段1 [ as 别名1 ] , 字段2 [ as 别名2 ] from 表名;\",\"去除重复记录\",\"select distinct 字段列表 from 表名;\"]},\"518\":{\"h\":\"4.3 条件查询\",\"t\":[\"语法：\",\"select 字段列表 from 表名 where 条件列表 ; -- 条件列表：意味着可以有多个条件\",\"在SQL语句当中构造条件的运算符分为两类：\",\"比较运算符\",\"逻辑运算符\",\"常用的比较运算符如下:\",\"比较运算符\",\"功能\",\">\",\"大于\",\">=\",\"大于等于\",\"<\",\"小于\",\"<=\",\"小于等于\",\"=\",\"等于\",\"<> 或 !=\",\"不等于\",\"between ... and ...\",\"在某个范围之内(含最小、最大值)\",\"in(...)\",\"在in之后的列表中的值，多选一\",\"like 占位符\",\"模糊匹配(_匹配单个字符, %匹配任意个字符)\",\"is null\",\"是null\",\"常用的逻辑运算符如下:\",\"逻辑运算符\",\"功能\",\"and 或 &&\",\"并且 (多个条件同时成立)\",\"or 或 ||\",\"或者 (多个条件任意一个成立)\",\"not 或 !\",\"非 , 不是\"]},\"519\":{\"h\":\"4.4 聚合函数\",\"t\":[\"使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）\",\"语法：\",\"select 聚合函数(字段列表) from 表名 ;\",\"注意 : 聚合函数会忽略空值，对NULL值不作为统计。\",\"常用聚合函数：\",\"函数\",\"功能\",\"count\",\"统计数量\",\"max\",\"最大值\",\"min\",\"最小值\",\"avg\",\"平均值\",\"sum\",\"求和\",\"说明\",\"count ：按照列去统计有多少行数据。\",\"在根据指定的列统计的时候，如果这一列中有 null 的行，该行不会被统计在其中。\",\"sum ：计算指定列的数值和，如果不是数值类型，那么计算结果为0\",\"max ：计算指定列的最大值\",\"min ：计算指定列的最小值\",\"avg ：计算指定列的平均值\"]},\"520\":{\"h\":\"4.5 分组查询\",\"t\":[\"分组： 按照某一列或者某几列，把相同的数据进行合并输出。\",\"分组其实就是按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。\",\"分组查询通常会使用聚合函数进行计算。\",\"语法：\",\"select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\",\"注意事项\",\"分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\",\"执行顺序：where > 聚合函数 > having\",\"where 与 having 区别（面试题）\",\"执行时机不同：where 是分组之前进行过滤，不满足 where 条件，不参与分组；而 having 是分组之后对结果进行过滤。\",\"判断条件不同：where 不能对聚合函数进行判断，而 having 可以。\"]},\"521\":{\"h\":\"4.6 排序查询\",\"t\":[\"排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\",\"语法：\",\"select 字段列表 from 表名 [where 条件列表] [group by 分组字段 ] order by 字段1 排序方式1 , 字段2 排序方式2 … ;\",\"排序方式：\",\"ASC ：升序（默认值）\",\"DESC：降序\",\"注意事项：如果是升序, 可以不指定排序方式ASC\"]},\"522\":{\"h\":\"4.7 分页查询\",\"t\":[\"分页操作在业务系统开发时，也是非常常见的一个功能，日常我们在网站中看到的各种各样的分页条，后台也都需要借助于数据库的分页操作。\",\"分页查询语法：\",\"select 字段列表 from 表名 limit 起始索引, 查询记录数 ;\",\"注意事项\",\"起始索引从 0 开始。\",\"计算公式：起始索引 = （查询页码 - 1）* 每页显示记录数\",\"分页查询是数据库的方言，不同的数据库有不同的实现，MySQL 中是 LIMIT\",\"如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 条数\",\"前端查询数据库的流程：\",\"前端在请求服务端时，传递的参数 \",\"当前页码 page\",\"每页显示条数 pageSize\",\"后端需要响应什么数据给前端 \",\"所查询到的数据列表（存储到 List 集合中）\",\"总记录数\",\"示例\",\"后台给前端返回的数据包含：List 集合（数据列表）、total（总记录数）\",\"当数据量较大时，通常封装到 PageBean 对象中，并将该对象转换为 json 格式的数据响应回给浏览器。\",\"@Data @NoArgsConstructor @AllArgsConstructor public class PageBean { private Long total; // 总记录数 private List rows; // 当前页数据列表 }\"]},\"523\":{\"h\":\"5. 多表设计\",\"t\":[\"项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\",\"一对多（多对一）\",\"多对多\",\"一对一\"]},\"524\":{\"h\":\"5.1 一对多 - 外键约束\",\"t\":[\"一对多关系实现：在数据库表中多的一方，添加字段，来关联属于一这方的主键。\",\"外键约束：让两张表的数据建立连接，保证数据的一致性和完整性。\",\"对应的关键字：foreign key\",\"语法：\",\"-- 创建表时指定 create table 表名( 字段名 数据类型, ... [constraint] [外键名称] foreign key (外键字段名) references 主表 (主表列名) ); -- 建完表后，添加外键 alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);\",\"物理外键和逻辑外键\",\"物理外键\",\"概念：使用 foreign key 定义外键关联另外一张表。\",\"缺点： \",\"影响增、删、改的效率（需要检查外键关系）。\",\"仅用于单节点数据库，不适用与分布式、集群场景。\",\"容易引发数据库的死锁问题，消耗性能。\",\"逻辑外键\",\"概念：在业务层逻辑中，解决外键关联。\",\"通过逻辑外键，就可以很方便的解决上述问题。\",\"在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key\"]},\"525\":{\"h\":\"5.2 一对一\",\"t\":[\"一对一关系表在实际开发中应用起来比较简单，通常是用来做单表的拆分，也就是将一张大表拆分成两张小表，将大表中的一些基础字段放在一张表当中，将其他的字段放在另外一张表当中，以此来提高数据的操作效率。\",\"一对一的应用场景：用户表(基本信息+身份信息)\",\"基本信息：用户的ID、姓名、性别、手机号、学历\",\"身份信息：民族、生日、身份证号、身份证签发机关，身份证的有效期(开始时间、结束时间)\",\"如果在业务系统当中，对用户的基本信息查询频率特别的高，但是对于用户的身份信息查询频率很低，此时出于提高查询效率的考虑，可以将这张大表拆分成两张小表，第一张表存放的是用户的基本信息，而第二张表存放的就是用户的身份信息。他们两者之间一对一的关系，一个用户只能对应一个身份证，而一个身份证也只能关联一个用户。\",\"那么在数据库层面怎么去体现上述两者之间是一对一的关系呢？\",\"其实一对一我们可以看成一种特殊的一对多。一对多我们是怎么设计表关系的？是不是在多的一方添加外键。同样我们也可以通过外键来体现一对一之间的关系，我们只需要在任意一方来添加一个外键就可以了。\",\"一对一 ：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的 (UNIQUE)\"]},\"526\":{\"h\":\"5.3 多对多\",\"t\":[\"多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。\",\"案例：学生与课程的关系\",\"关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\",\"实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\"]},\"527\":{\"h\":\"6. 多表查询\"},\"528\":{\"h\":\"6.1 概述\"},\"529\":{\"h\":\"6.1.1 介绍\",\"t\":[\"多表查询：查询时从多张表中获取所需数据\",\"多表查询\",\"单表查询的 SQL 语句：select 字段列表 from 表名;\",\"那么要执行多表查询，只需要使用逗号分隔多张表即可，如：select 字段列表 from 表1, 表2;\",\"查询用户表和部门表中的数据：\",\"select * from tb_emp , tb_dept;\",\"笛卡尔积：笛卡尔乘积是指在数学中，两个集合（A 集合和 B 集合）的所有组合情况。\",\"在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据。\",\"在查询时给多表查询加上连接查询的条件：\",\"select * from tb_emp , tb_dept where tb_emp.dept_id = tb_dept.id ;\"]},\"530\":{\"h\":\"6.1.2 分类\",\"t\":[\"多表查询可以分为：\",\"连接查询\",\"内连接：相当于查询 A、B 交集部分数据\",\"外连接\",\"左外连接：查询左表所有数据(包括两张表交集部分数据)\",\"右外连接：查询右表所有数据(包括两张表交集部分数据)\",\"子查询\"]},\"531\":{\"h\":\"6.3 内连接\",\"t\":[\"内连接查询：查询两表或多表中交集部分数据。\",\"内连接从语法上可以分为：\",\"隐式内连接\",\"显式内连接\",\"隐式内连接语法：\",\"select 字段列表 from 表1 , 表2 where 条件 ... ;\",\"显式内连接语法：\",\"select 字段列表 from 表1 [ inner ] join 表2 on 连接条件 ... ;\",\"多表查询时给表起别名：\",\"- tableA as 别名1, tableB as 别名2 ; - tableA 别名1, tableB 别名2 ;\",\"注意事项\",\"一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\"]},\"532\":{\"h\":\"6.3 外连接\",\"t\":[\"外连接分为两种：左外连接 和 右外连接。\",\"左外连接语法结构：\",\"select 字段列表 from 表1 left [ outer ] join 表2 on 连接条件 ... ;\",\"左外连接相当于查询表1（左表）的所有数据，当然也包含表1和表2交集部分的数据。\",\"右外连接语法结构：\",\"select 字段列表 from 表1 right [ outer ] join 表2 on 连接条件 ... ;\",\"右外连接相当于查询表2（右表）的所有数据，当然也包含表1和表2交集部分的数据。\",\"注意事项\",\"左外连接和右外连接是可以相互替换的，只需要调整连接查询时 SQL 语句中表的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\"]},\"533\":{\"h\":\"6.4 子查询\"},\"534\":{\"h\":\"6.4.1 介绍\",\"t\":[\"SQL 语句中嵌套 select 语句，称为嵌套查询，又称子查询。\",\"SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 ... );\",\"子查询外部的语句可以是 insert / update / delete / select 的任何一个，最常见的是 select.\",\"根据子查询结果的不同分为：\",\"标量子查询（子查询结果为单个值「一行一列」）\",\"列子查询（子查询结果为一列，但可以是多行）\",\"行子查询（子查询结果为一行，但可以是多列）\",\"表子查询（子查询结果为多行多列「相当于子查询结果是一张表」）\",\"子查询可以书写的位置：\",\"where 之后\",\"from 之后\",\"select 之后\"]},\"535\":{\"h\":\"6.4.2 标量子查询\",\"t\":[\"子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。\",\"常用的操作符： =<>>>=<<=\"]},\"536\":{\"h\":\"6.4.3 列子查询\",\"t\":[\"子查询返回的结果是一列(可以是多行)，这种子查询称为列子查询。\",\"常用的操作符：\",\"操作符\",\"描述\",\"IN\",\"在指定的集合范围之内，多选一\",\"NOT IN\",\"不在指定的集合范围之内\"]},\"537\":{\"h\":\"6.4.4 行子查询\",\"t\":[\"子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。\",\"常用的操作符：= 、<> 、IN 、NOT IN\"]},\"538\":{\"h\":\"6.4.5 表子查询\",\"t\":[\"子查询返回的结果是多行多列，常作为临时表，这种子查询称为表子查询。\"]},\"539\":{\"h\":\"7. 事务\"},\"540\":{\"h\":\"7.1 介绍\",\"t\":[\"在实际的业务开发中，有些业务操作要多次访问数据库。一个业务要发送多条 SQL 语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的 SQL 语句全部执行成功。如果其中有一条 SQL 语句失败，就进行事务的回滚，所有的 SQL 语句全部执行失败。\",\"简而言之：事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\",\"事务作用：保证在一个事务中多次操作数据库表中数据时，要么全都成功,要么全都失败。\"]},\"541\":{\"h\":\"7.2 操作\",\"t\":[\"MYSQL中有两种方式进行事务的操作：\",\"自动提交事务：即执行一条 sql 语句提交一次事务。（默认 MySQL 的事务是自动提交）\",\"手动提交事务：先开启，再提交\",\"事务操作有关的 SQL 语句：\",\"SQL语句\",\"描述\",\"start transaction; / begin ;\",\"开启手动控制事务\",\"commit;\",\"提交事务\",\"rollback;\",\"回滚事务\",\"手动提交事务使用步骤：\",\"第1种情况：开启事务 => 执行SQL语句 => 成功 => 提交事务\",\"第2种情况：开启事务 => 执行SQL语句 => 失败 => 回滚事务\"]},\"542\":{\"h\":\"7.3 四大特性\",\"t\":[\"原子性（Atomicity） ：原子性是指事务包装的一组 sql 是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。\",\"一致性（Consistency）：一个事务完成之后数据都必须处于一致性状态。\",\"如果事务成功的完成，那么数据库的所有变化将生效。\",\"如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。\",\"隔离性（Isolation）：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。\",\"一个事务的成功或者失败对于其他的事务是没有影响。\",\"持久性（Durability）：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。\",\"关键\",\"面试题：事务有哪些特性？\",\"原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。\",\"一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\",\"隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\",\"持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\",\"事务的四大特性简称为：ACID\"]},\"543\":{\"h\":\"8. 索引\"},\"544\":{\"h\":\"8.1 介绍\",\"t\":[\"索引 index ：是帮助数据库高效获取数据的数据结构 。\",\"简单来讲，就是使用索引可以提高查询的效率。\",\"优点：\",\"提高数据查询的效率，降低数据库的 IO 成本。\",\"通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 消耗。\",\"缺点：\",\"索引会占用存储空间。\",\"索引大大提高了查询效率，同时却也降低了 insert、update、delete 的效率。\"]},\"545\":{\"h\":\"8.2 结构\",\"t\":[\"MySQL 数据库支持的索引结构有很多，如：Hash 索引、B+Tree 索引、Full-Text 索引等。\",\"我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\",\"二叉查找树\",\"二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大\",\"二叉查找树\",\"当我们向二叉查找树保存数据时，是按照从大到小（或从小到大）的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。\",\"退化的二叉查找树\",\"可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）\",\"平衡二叉树\",\"但是在 Mysql 数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构。\",\"思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？\",\"答案 最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。 因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会造成数的高度比较高，树的高度一旦高了，检索速度就会降低。 \",\"说明\",\"如果数据结构是红黑树，那么查询 1000 万条数据，根据计算树的高度大概是 23 左右，这样确实比之前的方式快了很多，但是如果高并发访问，那么一个用户有可能需要 23 次磁盘 IO，那么 100 万用户，那么会造成效率极其低下。\",\"所以为了减少红黑树的高度，那么就得增加树的宽度，就是不再像红黑树一样每个节点只能保存一个数据，可以引入另外一种数据结构，一个节点可以保存多个数据，这样宽度就会增加从而降低树的高度。而 B+Tree 就满足这种要求。\",\"B+Tree（多路平衡搜索树）结构中如何避免这个问题：\",\"B+Tree 结构：\",\"每一个节点，可以存储多个 key（有 n 个 key，就有 n 个指针）\",\"节点分为：叶子节点、非叶子节点 \",\"叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上\",\"非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key + 指针\",\"为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询\",\"拓展\",\"非叶子节点都是由 key + 指针域 组成的，一个 key 占 8 字节，一个指针占 6 字节，而一个节点总共容量是 16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节 / (8+6) = 1170 个元素。\",\"查看 mysql 索引节点大小：\",\"show global status like 'innodb_page_size'; -- 节点大小：16384\",\"当根节点中可以存储 1170 个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储 1170 个元素，那么第二层即第二次 IO 的时候就会找到数据大概是：1170∗1170=135W。也就是说 B+Tree 数据结构中只需要经历两次磁盘 IO 就可以找到 135W 条数据。\",\"对于第二层每个元素有指针，那么会找到第三层，第三层由 key + 数据 组成，假设 key + 数据 总大小是 1KB，而每个节点一共能存储 16KB，所以一个第三层一个节点大概可以存储 16 个元素(即 16 条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是 135W 个元素，那么第三层总元素大小就是：135W∗16 结果就是 2000W+ 的元素个数。\",\"结合上述分析 B+Tree 有如下优点：\",\"千万条数据，B+Tree 可以控制在小于等于 3 的高度\",\"所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找\"]},\"546\":{\"h\":\"8.3 语法\",\"t\":[\"创建索引\",\"create [ unique ] index 索引名 on 表名 (字段名,... ) ;\",\"查看索引\",\"show index from 表名;\",\"删除索引\",\"drop index 索引名 on 表名;\",\"注意事项\",\"主键字段，在建表时，会自动创建主键索引\",\"添加唯一约束时，数据库实际上会添加唯一索引\"]},\"547\":{\"c\":[\"MySQL\"]},\"548\":{\"c\":[\"基础\"]},\"549\":{\"h\":\"Java 基础知识\"},\"550\":{\"h\":\"一、语法基础\"},\"551\":{\"h\":\"1.1 变量\",\"t\":[\"变量必须先定义，才可以使用。不能重名。\",\"变量定义的方式：\",\"public class Main { public static void main(String[] args) { int a = 5; int b, c = a, d = 10 / 2; } }\",\"内置数据类型：\",\"类型\",\"字节数\",\"举例\",\"byte\",\"1\",\"123\",\"short\",\"2\",\"12345\",\"int\",\"4\",\"123456789\",\"long\",\"8\",\"1234567891011L\",\"float\",\"4\",\"1.2F\",\"double\",\"8\",\"1.2, 1.2D\",\"boolean\",\"1\",\"true, false\",\"char\",\"2\",\"‘A’\",\"常量：\",\"使用final修饰：\",\"final int N = 110;\",\"类型转化：\",\"显示转化：int x = (int)'A';\",\"隐式转化：double x = 12, y = 4 * 3.3;\"]},\"552\":{\"h\":\"1.2 运算符\",\"t\":[\"A = 10, B = 20\",\"运算符\",\"描述\",\"实例\",\"+\",\"把两个数相加\",\"A + B 将得到 30\",\"-\",\"从第一个数中减去第二个数\",\"A - B 将得到 -10\",\"*\",\"把两个数相乘\",\"A * B 将得到 200\",\"/\",\"分子除以分母\",\"B / A 将得到 2\",\"%\",\"取模运算符，向零整除后的余数，注意余数可能为负数\",\"B % A 将得到 0\",\"++\",\"自增运算符\",\"A++：先取值后加1；++A：先加1后取值\",\"--\",\"自减运算符\",\"A--：先取值后减1；--A：先减1后取值\",\"+=\",\"第一个数加上第二个数\",\"A = A + B 可以简写为 A += B\",\"-=\",\"第一个数减去第二个数\",\"A = A - B 可以简写为 A -= B\",\"*=\",\"第一个数乘以第二个数\",\"A = A * B 可以简写为 A *= B\",\"/=\",\"第一个数除以第二个数\",\"A = A / B 可以简写为 A /= B\",\"%=\",\"第一个对第二个数取余数\",\"A = A % B 可以简写为 A %= B\"]},\"553\":{\"h\":\"1.3 表达式\",\"t\":[\"整数的加减乘除四则运算：\",\"public class Main { public static void main(String[] args) { int a = 6 + 3 * 4 / 2 - 2; System.out.println(a); int b = a * 10 + 5 / 2; System.out.println(b); System.out.println(23 * 56 - 78 / 3); } }\",\"浮点数（小数）的运算：\",\"public class Main { public static void main(String[] args) { double x = 1.5, y = 3.2; System.out.println(x * y); System.out.println(x + y); System.out.println(x - y); System.out.println(x / y); } }\",\"整型变量的自增、自减：\",\"public class Main { public static void main(String[] args) { int a = 1; int b = a ++ ; System.out.println(a + \\\" \\\" + b); int c = ++ a; System.out.println(a + \\\" \\\" + c); } }\"]},\"554\":{\"h\":\"1.4 输入\",\"t\":[\"方式1：效率较低，输入规模较小时使用。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); String str = sc.next(); // 读入下一个字符串 int x = sc.nextInt(); // 读入下一个整数 float y = sc.nextFloat(); // 读入下一个单精度浮点数 double z = sc.nextDouble(); // 读入下一个双精度浮点数 String line = sc.nextLine(); // 读入下一行 } }\",\"方式2：效率较高，输入规模较大时使用。注意需要抛异常。\",\"import java.io.BufferedReader; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); System.out.println(str); } }\"]},\"555\":{\"h\":\"1.5 输出\",\"t\":[\"方式1：效率较低，输出规模较小时使用。\",\"public class Main { public static void main(String[] args) throws Exception { System.out.println(123); // 输出整数 + 换行 System.out.println(\\\"Hello World\\\"); // 输出字符串 + 换行 System.out.print(123); // 输出整数 System.out.print(\\\"yxc\\\\n\\\"); // 输出字符串 System.out.printf(\\\"%04d %.2f\\\\n\\\", 4, 123.456D); // 格式化输出，float与double都用%f输出 } }\",\"System.out.printf() 中不同类型变量的输出格式：\",\"(1) int：%d (2) float: %f, 默认保留6位小数 (3) double: %f， 默认保留6位小数 (4) char: %c, 回车也是一个字符，用 '\\\\n' 表示 (5) String: %s\",\"方式2：效率较高，输出规模较大时使用。注意需要抛异常。\",\"import java.io.BufferedWriter; import java.io.OutputStreamWriter; public class Main { public static void main(String[] args) throws Exception { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); bw.write(\\\"Hello World\\\\n\\\"); bw.flush(); // 需要手动刷新缓冲区 } }\"]},\"556\":{\"h\":\"二、判断语句\",\"t\":[\"学习语言最好的方式就是实践，每当掌握一个新功能时，就要立即将这个功能应用到实践中。——闫学灿\"]},\"557\":{\"h\":\"2.1 if 语句\",\"t\":[\"基本 if-else 语句\",\"当条件成立时，执行某些语句；否则执行另一些语句。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) { System.out.printf(\\\"%d is big!\\\\n\\\", a); System.out.printf(\\\"%d + 1 = %d\\\\n\\\", a, a + 1); } else { System.out.printf(\\\"%d is small!\\\\n\\\", a); System.out.printf(\\\"%d - 1 = %d\\\\n\\\", a, a - 1); } } }\",\"else 语句可以省略：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) { System.out.printf(\\\"%d is big!\\\\n\\\", a); System.out.printf(\\\"%d + 1 = %d\\\\n\\\", a, a + 1); } } }\",\"当只有一条语句时，大括号可以省略：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); if (a > 5) System.out.printf(\\\"%d is big!\\\\n\\\", a); else System.out.printf(\\\"%d is small!\\\\n\\\", a); } }\",\"练习：输入一个整数，输出这个数的绝对值。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); if (x > 0) System.out.println(x); else System.out.println(-x); } }\",\"练习：输入两个整数，输出两个数中较大的那个。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(); if (a > b) System.out.println(a); else System.out.println(b); } }\",\"if-else 语句内部也可以是 if-else 语句。\",\"练习：输入三个整数，输出三个数中最大的那个。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(); if (a > b) { if (a > c) System.out.println(a); else System.out.println(c); } else { if (b > c) System.out.println(b); else System.out.println(c); } } }\",\"常用比较运算符\",\"(1) 大于 > (2) 小于 < (3) 大于等于 >= (4) 小于等于 <= (5) 等于 == (6) 不等于 !=\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(); if (a > b) System.out.printf(\\\"%d > %d\\\\n\\\", a, b); if (a >= b) System.out.printf(\\\"%d >= %d\\\\n\\\", a, b); if (a < b) System.out.printf(\\\"%d < %d\\\\n\\\", a, b); if (a <= b) System.out.printf(\\\"%d <= %d\\\\n\\\", a, b); if (a == b) System.out.printf(\\\"%d == %d\\\\n\\\", a, b); if (a != b) System.out.printf(\\\"%d != %d\\\\n\\\", a, b); } }\",\"if-else连写：\",\"输入一个0到100之间的分数， 如果大于等于85，输出A； 如果大于等于70并且小于85，输出B； 如果大于等于60并且小于70，输出C； 如果小于60，输出 D；\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int s = sc.nextInt(); if (s >= 85) { System.out.println(\\\"A\\\"); } else if (s >= 70) { System.out.println(\\\"B\\\"); } else if (s >= 60) { System.out.println(\\\"C\\\"); } else { System.out.println(\\\"D\\\"); } } }\",\"练习：\",\"1.判断闰年。闰年有两种情况： (1) 能被100整除时，必须能被400整除； (2) 不能被100整除时，被4整除即可。 输入一个年份，如果是闰年输出yes，否则输出no。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int year = sc.nextInt(); if (year % 100 == 0) { if (year % 400 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } else { if (year % 4 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } } }\"]},\"558\":{\"h\":\"2.2 条件表达式\",\"t\":[\"​ (1) 与 && ​ (2) 或 || ​ (3) 非!\",\"例题：输入三个数，输出三个数中的最大值。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(); if (a >= b && a >= c) System.out.println(a); else if (b >= a && b >= c) System.out.println(b); else System.out.println(c); } }\",\"练习：用一条 if 语句，判断闰年。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int year = sc.nextInt(); if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } }\"]},\"559\":{\"h\":\"2.3 switch 语句\",\"t\":[\"注意： swtich 语句中如果不加 break 语句，则从上到下匹配到第一个 case 后，会顺次执行后面每个 case 中的语句。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int day = sc.nextInt(); String name; switch(day) { case 1: name = \\\"Monday\\\"; break; case 2: name = \\\"Tuesday\\\"; break; case 3: name = \\\"Wednesday\\\"; break; case 4: name = \\\"Thursday\\\"; break; case 5: name = \\\"Friday\\\"; break; case 6: name = \\\"Saturday\\\"; break; case 7: name = \\\"Sunday\\\"; break; default: name = \\\"not valid\\\"; } System.out.println(name); } }\"]},\"560\":{\"h\":\"三、循环语句\",\"t\":[\"学习编程语言语法是次要的，思维是主要的。如何把头脑中的想法变成简洁的代码，至关重要。——闫学灿\",\"学习循环语句只需要抓住一点 —— 代码执行顺序！\"]},\"561\":{\"h\":\"3. 1 while 循环\",\"t\":[\"可以简单理解为循环版的 if 语句。if 语句是判断一次，如果条件成立，则执行后面的语句；\",\"while 是每次判断，如果成立，则执行循环体中的语句，否则停止。\",\"public class Main { public static void main(String[] args) { int i = 0; while (i < 10) { System.out.println(i); i ++ ; } } }\",\"练习：求 1~100 中所有数的立方和。\",\"public class Main { public static void main(String[] args) { int i = 1, sum = 0; while (i <= 100) { sum += i * i * i; i ++ ; } System.out.println(sum); } }\",\"练习：求斐波那契数列的第 n 项。f(1)=1,f(2)=1,f(3)=2,f(n)=f(n−1)+f(n−2)。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int a = 1, b = 1, i = 1; while (i < n) { int c = a + b; a = b; b = c; i ++ ; } System.out.println(a); } }\",\"死循环：循环永久执行，无法结束。我们要避免写出死循环。\",\"public class Main { public static void main(String[] args) { int x = 1; while (x == 1) System.out.println(\\\"!\\\"); } }\"]},\"562\":{\"h\":\"3.2 do while 循环\",\"t\":[\"do while 循环不常用。\",\"do while语句与 while 语句非常相似。唯一的区别是，do while 语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。\",\"public class Main { public static void main(String[] args) { int x = 1; while (x < 1) { System.out.println(\\\"x!\\\"); } int y = 1; do { System.out.println(\\\"y!\\\"); } while (y < 1); } }\"]},\"563\":{\"h\":\"3.3 for 循环\",\"t\":[\"基本思想：把控制循环次数的变量从循环体中剥离。\",\"for (init-statement; condition; expression) { statement }\",\"init-statement 可以是声明语句、表达式、空语句，一般用来初始化循环变量；\",\"condition 是条件表达式，和 while 中的条件表达式作用一样；可以为空，空语句表示true；\",\"expression 一般负责修改循环变量，可以为空。\",\"public class Main { public static void main(String[] args) { for (int i = 0; i < 10; i ++ ) { // 循环体中只有一条语句时，可以不加大括号 System.out.println(i); } } }\",\"练习：求 1~100 中所有数的立方和。\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1; i <= 100; i ++ ) sum += i * i * i; System.out.println(sum); } }\",\"练习：求斐波那契数列的第 n 项。f(1)=1,f(2)=1,f(3)=2,f(n)=f(n−1)+f(n−2)。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int a = 1, b = 1; for (int i = 1; i < n; i ++ ) { int c = a + b; a = b; b = c; } System.out.println(a); } }\",\"init-statement 可以定义多个变量，expression 也可以修改多个变量。\",\"例如求 1 * 10 + 2 * 9 + 3 * 8 + 4 * 7 + 5 * 6：\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1, j = 10; i < j; i ++, j -- ) { sum += i * j; } System.out.println(sum); } }\"]},\"564\":{\"h\":\"3.4 跳转语句\"},\"565\":{\"h\":\"3.4.1 break\",\"t\":[\"可以提前从循环中退出，一般与 if 语句搭配。\",\"例题：判断一个大于 1 的数是否是质数：\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); boolean isPrime = true; for (int i = 2; i < n; i ++ ) if (n % i == 0) { isPrime = false; break; } if (isPrime) System.out.println(\\\"yes\\\"); else System.out.println(\\\"no\\\"); } }\"]},\"566\":{\"h\":\"3.4.2 continue\",\"t\":[\"可以直接跳到当前循环体的结尾。作用与 if 语句类似。\",\"例题：求 1~100 中所有偶数的和。\",\"public class Main { public static void main(String[] args) { int sum = 0; for (int i = 1; i <= 100; i ++ ) { if (i % 2 == 1) continue; sum += i; } System.out.println(sum); } }\"]},\"567\":{\"h\":\"3.5 多层循环\",\"t\":[\"将 1~100 打印到一个 10×10 的矩阵中：\",\"public class Main { public static void main(String[] args) { for (int i = 0, k = 1; i < 10; i ++ ) { for (int j = 0; j < 10; j ++, k ++ ) { System.out.printf(\\\"%d \\\", k); } System.out.println(); } } }\",\"练习：打印 1~100 中的所有质数\",\"public class Main { public static void main(String[] args) { for (int i = 2; i <= 100; i ++ ) { boolean isPrime = true; for (int j = 2; j < i; j ++ ) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) System.out.println(i); } } }\"]},\"568\":{\"h\":\"四、数组\",\"t\":[\"程序 = 逻辑 + 数据，数组是存储数据的强而有力的手段。 ——闫学灿\"]},\"569\":{\"h\":\"4.1 一维数组\"},\"570\":{\"h\":\"4.1.1 数组的定义\",\"t\":[\"数组的定义方式和变量类似。\",\"public class Main { public static void main(String[] args) { int[] a = new int[10], b; float[] f = new float[33]; double[] d = new double[123]; char[] c = new char[21]; } }\"]},\"571\":{\"h\":\"4.1.2 数组的初始化\",\"t\":[\"public class Main { public static void main(String[] args) { int[] a = {0, 1, 2}; // 含有3个元素的数组，元素分别是0, 1, 2 int[] b = new int[3]; // 含有3个元素的数组，元素的值均为0 char[] d = {'a', 'b', 'c'}; // 字符数组的初始化 } }\"]},\"572\":{\"h\":\"4.1.3 访问数组元素\",\"t\":[\"通过下标访问数组。\",\"public class Main { public static void main(String[] args) { int[] a = {0, 1, 2}; // 数组下标从0开始 System.out.printf(\\\"%d %d %d\\\\n\\\", a[0], a[1], a[2]); a[0] = 5; System.out.println(a[0]); } }\",\"练习题1： 使用数组实现求斐波那契数列的第 N 项。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] f = new int[n + 1]; f[0] = 0; f[1] = 1; for (int i = 2; i <= n; i ++ ) f[i] = f[i - 1] + f[i - 2]; System.out.println(f[n]); } }\",\"练习题2：输入一个 n，再输入 n 个整数。将这 n 个整数逆序输出。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i ++ ) a[i] = sc.nextInt(); for (int i = n - 1; i >= 0; i -- ) System.out.printf(\\\"%d \\\", a[i]); } }\",\"练习题3：输入 n 个数，将这 n 个数按从小到大的顺序输出。\",\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] a = new int[n]; for (int i = 0; i < n; i ++ ) a[i] = sc.nextInt(); for (int i = 0; i < n; i ++ ) for (int j = i + 1; j < n; j ++ ) if (a[i] > a[j]) { int t = a[i]; a[i] = a[j]; a[j] = t; } for (int i = 0; i < n; i ++ ) System.out.printf(\\\"%d \\\", a[i]); } }\"]},\"573\":{\"h\":\"4.2 多维数组\",\"t\":[\"多维数组就是数组的数组。\",\"public class Main { public static void main(String[] args) { int[][] a = new int[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组。 int[][][] b = new int[10][20][30]; // 将所有元素的初值为0 // 大小为10的数组，它的每个元素是含有20个数组的数组 // 这些数组的元素是含有30个整数的数组 } } public class Main { public static void main(String[] args) { int[][] a = { // 三个元素，每个元素都是大小为4的数组 {0, 1, 2, 3}, // 第1行的初始值 {4, 5, 6, 7}, // 第2行的初始值 {8, 9, 10, 11} // 第3行的初始值 }; for (int i = 0; i < 4; i ++ ) // 将第一行全部变成0 a[0][i] = 0; for (int i = 0; i < 3; i ++ ) { // 输出二维数组 for (int j = 0; j < 4; j ++ ) { System.out.printf(\\\"%d \\\", a[i][j]); } System.out.println(); } } }\"]},\"574\":{\"h\":\"4.3 数组的范围遍历\",\"t\":[\"import java.util.Scanner; public class Main { public static void main(String[] args) { int[][] a = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}, }; for (int[] row: a) { // 范围遍历 for (int x: row) // 范围遍历 System.out.printf(\\\"%d \\\", x); System.out.println(); } } }\"]},\"575\":{\"h\":\"4.3 常用API\",\"t\":[\"属性length：返回数组长度，注意不加小括号\",\"Arrays.sort()：数组排序\",\"Arrays.fill(int[] a, int val)：填充数组\",\"Arrays.toString()：将数组转化为字符串\",\"Arrays.deepToString()：将多维数组转化为字符串\",\"数组不可变长\",\"使用Arrays需要import java.util.Arrays\"]},\"576\":{\"h\":\"五、字符串\",\"t\":[\"字符串是计算机与人类沟通的重要手段。——闫学灿\"]},\"577\":{\"h\":\"5.1 字符与整数的联系——ASCII码\",\"t\":[\"每个常用字符都对应一个 -128 ~ 127 的数字，二者之间可以相互转化。\",\"注意：目前负数没有与之对应的字符。\",\"import java.util.Arrays; public class Main { public static void main(String[] args) { char c = 'a'; System.out.println((int)c); int a = 66; System.out.println((char)a); } }\",\"常用ASCII值：'A'- 'Z'是65 ~ 90，'a' - 'z'是97 - 122，0 - 9是 48 - 57。 字符可以参与运算，运算时会将其当做整数：\",\"import java.util.Arrays; public class Main { public static void main(String[] args) { int a = 'B' - 'A'; int b = 'A' * 'B'; char c = 'A' + 2; System.out.println(a); System.out.println(b); System.out.println(c); } }\"]},\"578\":{\"h\":\"5.2 String 类\",\"t\":[\"初始化：\",\"String a = \\\"Hello World\\\"; String b = \\\"My name is \\\"; String x = b; // 存储到了相同地址 String c = b + \\\"yxc\\\"; // String可以通过加号拼接 String d = \\\"My age is \\\" + 18; // int会被隐式转化成字符串\\\"18\\\" String str = String.format(\\\"My age is %d\\\", 18); // 格式化字符串，类似于C++中的sprintf String money_str = \\\"123.45\\\"; double money = Double.parseDouble(money_str); // String转double\",\"只读变量，不能修改，例如：\",\"String a = \\\"Hello \\\"; a += \\\"World\\\"; // 会构造一个新的字符串\",\"访问String中的字符：\",\"String str = \\\"Hello World\\\"; for (int i = 0; i < str.length(); i ++ ) { System.out.print(str.charAt(i)); // 只能读取，不能写入 }\",\"常用API：\",\"length()：返回长度\",\"charAt(i)：字符串的第i个位置的字符\",\"split(String regex)：分割字符串\",\"String[] strs = sc.nextLine().split(” “);\",\"indexOf(char c)、indexOf(String str)、lastIndexOf(char c)、lastIndexOf(String str)：查找，找不到返回-1\",\"equals()：判断两个字符串是否相等，注意不能直接用==\",\"compareTo()：判断两个字符串的字典序大小，负数表示小于，0表示相等，正数表示大于\",\"startsWith()：判断是否以某个前缀开头\",\"endsWith()：判断是否以某个后缀结尾\",\"trim()：去掉首尾的空白字符\",\"toLowerCase()：全部用小写字符\",\"toUpperCase()：全部用大写字符\",\"replace(char oldChar, char newChar)：替换字符\",\"replace(String oldRegex, String newRegex)：替换字符串\",\"substring(int beginIndex, int endIndex)：返回[beginIndex, endIndex)中的子串\",\"toCharArray()：将字符串转化成字符数组\",\"reverse()：翻转字符串\",\"范围遍历：\",\"String str = “Hello World”; for ( char c:str.toCharArray()) { System.out.print(c); }\"]},\"579\":{\"h\":\"5.3 输入与输出\",\"t\":[\"import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str1 = sc.next(); // 输入字符串，遇到空格、回车等空白字符时停止输入 String str2 = sc.nextLine(); // 输入一整行字符串，遇到空格不会停止输入，遇到回车才会停止 System.out.println(str1); // 可以直接输出 System.out.printf(\\\"%s\\\\n\\\", str2); // 也可以格式化输出，用 %s 表示字符串 } }\"]},\"580\":{\"h\":\"5.4 StringBuilder、StringBuffer\",\"t\":[\"String不能被修改，如果打算修改字符串，可以使用StringBuilder和StringBuffer。\",\"StringBuffer线程安全，速度较慢；StringBuilder线程不安全，速度较快。\",\"StringBuilder sb = new StringBuilder(\\\"Hello \\\"); // 初始化 sb.append(\\\"World\\\"); // 拼接字符串 System.out.println(sb); for (int i = 0; i < sb.length(); i ++ ) { sb.setCharAt(i, (char)(sb.charAt(i) + 1)); // 读取和写入字符 } System.out.println(sb);\"]},\"581\":{\"h\":\"六、函数\",\"t\":[\"理解函数，最重要的是理解代码的执行顺序。——闫学灿\"]},\"582\":{\"h\":\"6.1 函数基础\",\"t\":[\"一个典型的函数定义包括以下部分：修饰符、返回类型、函数名字、由0个或多个形参组成的列表以及函数体。\"]},\"583\":{\"h\":\"6.1.1 编写函数\",\"t\":[\"我们来编写一个求阶乘的程序。程序如下所示：\",\"private static int fact(int val) { int res = 1; for (int i = 1; i <= val; i ++ ) res *= i; return res; }\",\"函数名字是 fact，它作用于一个整型参数，返回一个整型值。return 语句负责结束 fact 并返回 res 的值。 修饰符包括 private、static 等，它们属于类相关的概念，会在下一章解释。\"]},\"584\":{\"h\":\"6.1.2 调用函数\",\"t\":[\"public class Main { private static int fact(int val) { int res = 1; for (int i = 1; i <= val; i ++ ) res *= i; return res; } public static void main(String[] args) { int res = fact(5); System.out.printf(\\\"5! is %d\\\\n\\\", res); } }\",\"函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。\"]},\"585\":{\"h\":\"6.1.3 形参和实参\",\"t\":[\"实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，依次类推。形参和实参的类型和个数必须匹配。\",\"fact(\\\"hello\\\"); // 错误：实参类型不正确 fact(); // 错误：实参数量不足 fact(42, 10, 0); // 错误：实参数量过多 fact(' '); // 正确：该实参能自动转换成int类型，' '的ASCII值为32，所以该操作等价于fact(32);\"]},\"586\":{\"h\":\"6.1.4 函数的形参列表\",\"t\":[\"函数的形参列表可以为空，但是不能省略。\",\"void f1() {/* …. */} // 空形参列表\",\"形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：\",\"int f3(int v1, v2) {/* … */} // 错误 int f4(int v1, int v2) {/* … */} // 正确\"]},\"587\":{\"h\":\"6.1.5 函数返回类型\",\"t\":[\"大多数类型都能用作函数的返回类型。一种特殊的返回类型是 void，它表示函数不返回任何值。 函数的返回类型也可以是数组、字符串或者其他对象：\",\"import java.util.Arrays; public class Main { private static int[] newArray() { int[] a = {1, 2, 3}; return a; } private static String newString() { return \\\"Hello World\\\"; } public static void main(String[] args) { System.out.println(Arrays.toString(newArray())); System.out.println(newString()); } }\"]},\"588\":{\"h\":\"6.1.6 变量的作用域\",\"t\":[\"本章中我们只使用静态成员变量和静态成员函数，非静态成员变量/函数及其区别会在下一章中介绍。\",\"函数内定义的变量为局部变量，只能在函数内部使用。\",\"定义在类中的变量为成员变量，可以在类的所有成员函数中调用。\",\"当局部变量与全局变量重名时，会优先使用局部变量。\",\"public class Main { private static int x = 4; private static void f1() { int x = 3; System.out.println(x); } private static void f2() { System.out.println(x); } private static void f3() { System.out.println(x + 1); } public static void main(String[] args) { f1(); f2(); f3(); } }\"]},\"589\":{\"h\":\"6.2 参数传递\"},\"590\":{\"h\":\"6.2.1 值传递\",\"t\":[\"八大基本数据类型和 String 类型等采用值传递。\",\"将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。\",\"public class Main { private static void f(int x) { x = 5; } public static void main(String[] args) { int x = 10; f(x); System.out.println(x); } }\"]},\"591\":{\"h\":\"6.2.2 引用传递\",\"t\":[\"除 String 以外的数据类型的对象，例如 数组、StringBuilder 等采用引用传递。\",\"将实参的引用（地址）传给形参，通过引用找到变量的真正地址，然后对地址中的值修改。所以此时对形参的修改会影响实参的初始值。\",\"import java.util.Arrays; public class Main { private static void f1(int[] a) { for (int i = 0, j = a.length - 1; i < j; i ++, j -- ) { int t = a[i]; a[i] = a[j]; a[j] = t; } } private static void f2(StringBuilder sb) { sb.append(\\\"Hello World\\\"); } public static void main(String[] args) { int[] a = {1, 2, 3, 4, 5}; f1(a); System.out.println(Arrays.toString(a)); StringBuilder sb = new StringBuilder(\\\"\\\"); f2(sb); System.out.println(sb); } }\"]},\"592\":{\"h\":\"6.3 返回类型和 return 语句\",\"t\":[\"return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。\",\"return 语句有两种形式：\",\"return; return expression;\"]},\"593\":{\"h\":\"6.3.1 无返回值函数\",\"t\":[\"没有返回值的 return 语句只能用在返回类型是 void 的函数中。 返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式地执行 return。\",\"通常情况下，void 函数如果想在它的中间位置提前退出，可以使用 return 语句。return 的这种用法有点类似于我们用 break 语句退出循环。\",\"public class Main { private static void swap(int[] a) { // 交换a[0]和a[1] // 如果两个值相等，则不需要交换，直接退出 if (a[0] == a[1]) return; // 如果程序执行到了这里，说明还需要继续完成某些功能 int tmp = a[0]; a[0] = a[1]; a[1] = tmp; // 此处无须显示的return语句 } public static void main(String[] args) { int[] a = {3, 4}; swap(a); System.out.printf(\\\"%d %d\\\\n\\\", a[0], a[1]); } }\"]},\"594\":{\"h\":\"6.3.2 有返回值的函数\",\"t\":[\"只要函数的返回类型不是 void，则该函数内的每个分支都必须有 return 语句，且每条 return 语句都必须返回一个值。return 语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换函数的返回类型。\",\"import java.util.Scanner; public class Main { private static int max(int a, int b) { if (a > b) return a; return b; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(), y = sc.nextInt(); System.out.println(max(x, y)); } }\"]},\"595\":{\"h\":\"6.4 函数重载\",\"t\":[\"函数重载 是指：在同一个类中存在多个函数，函数名称相同但参数列表不同。\",\"编译器会根据实参的类型选择最匹配的函数来执行。\",\"import java.util.Scanner; public class Main { private static int max(int a, int b) { System.out.println(\\\"int max\\\"); if (a > b) return a; return b; } private static double max(double a, double b) { System.out.println(\\\"double max\\\"); if (a > b) return a; return b; } public static void main(String[] args) { System.out.println(max(3, 4)); System.out.println(max(3.0, 4.0)); } }\"]},\"596\":{\"h\":\"6.5 函数递归\",\"t\":[\"在一个函数内部，也可以调用函数本身。\",\"import java.util.Scanner; public class Main { private static int fib(int n) { // 求斐波那切数列第n项 if (n <= 2) return 1; return fib(n - 1) + fib(n - 2); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(fib(n)); } }\"]},\"597\":{\"h\":\"七、类与接口\",\"t\":[\"类可以将变量、函数完美地打包在一起。——闫学灿\"]},\"598\":{\"h\":\"7.1 类与对象\",\"t\":[\"类定义一种全新的数据类型，包含一组变量和函数；对象是类这种类型对应的实例。\",\"例如在一间教室中，可以将 Student 定义成类，表示 “学生” 这个抽象的概念。那么每个同学就是 Student 类的一个对象（实例）。\"]},\"599\":{\"h\":\"7.1.1 源文件声明规则\",\"t\":[\"一个源文件中只能有一个 public 类。\",\"一个源文件可以有多个非 public 类。\",\"源文件的名称应该和 public 类的类名保持一致。\",\"每个源文件中，先写 package 语句，再写 import 语句，最后定义类。\"]},\"600\":{\"h\":\"7.1.2 类的定义\",\"t\":[\"public: 所有对象均可以访问\",\"private: 只有本类内部可以访问\",\"protected：同一个包或者子类中可以访问\",\"不添加修饰符：在同一个包中可以访问\",\"静态（带 static 修饰符）成员变量/函数与普通成员变量/函数的区别： \",\"所有 static 成员变量/函数在类中只有一份，被所有类的对象共享；\",\"所有普通成员变量/函数在类的每个对象中都有独立的一份；\",\"静态函数中只能调用静态函数/变量；访问静态变量最好通过类名；\",\"普通函数中既可以调用普通函数/变量，也可以调用静态函数/变量。\",\"class Point { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public int getX() { return x; } public int getY() { return y; } public String toString() { return String.format(\\\"(%d, %d)\\\", x, y); } }\"]},\"601\":{\"h\":\"7.1.3 类的继承\",\"t\":[\"每个类只能继承一个类。\",\"class ColorPoint extends Point { private String color; public ColorPoint(int x, int y, String color) { super(x, y); this.color = color; } public void setColor(String color) { this.color = color; } public String toString() { return String.format(\\\"(%d, %d, %s)\\\", super.getX(), super.getY(), this.color); } }\"]},\"602\":{\"h\":\"7.1.4 类的多态\",\"t\":[\"public class Main { public static void main(String[] args) { Point point = new Point(3, 4); Point colorPoint = new ColorPoint(1, 2, \\\"red\\\"); // 多态，同一个类的实例，调用相同的函数，运行结果不同 System.out.println(point.toString()); System.out.println(colorPoint.toString()); } }\"]},\"603\":{\"h\":\"7.2 接口\",\"t\":[\"interface 与 class 类似。主要用来定义类中所需包含的函数。\",\"接口也可以继承其他接口，一个类可以实现多个接口。\"]},\"604\":{\"h\":\"7.2.1 接口的定义\",\"t\":[\"接口中不添加修饰符时，默认为 public。\",\"interface Role { public void greet(); public void move(); public int getSpeed(); }\"]},\"605\":{\"h\":\"7.2.2 接口的继承\",\"t\":[\"每个接口可以继承多个接口\",\"interface Hero extends Role { public void attack(); }\"]},\"606\":{\"h\":\"7.2.3 接口的实现\",\"t\":[\"每个类可以实现多个接口\",\"class Zeus implements Hero { private final String name = \\\"Zeus\\\"; public void attack() { System.out.println(name + \\\": Attack!\\\"); } public void greet() { System.out.println(name + \\\": Hi!\\\"); } public void move() { System.out.println(name + \\\": Move!\\\"); } public int getSpeed() { return 10; } }\"]},\"607\":{\"h\":\"7.2.4 接口的多态\",\"t\":[\"class Athena implements Hero { private final String name = \\\"Athena\\\"; public void attack() { System.out.println(name + \\\": Attack!!!\\\"); } public void greet() { System.out.println(name + \\\": Hi!!!\\\"); } public void move() { System.out.println(name + \\\": Move!!!\\\"); } public int getSpeed() { return 10; } } public class Main { public static void main(String[] args) { Hero[] heros = {new Zeus(), new Athena()}; for (Hero hero: heros) { hero.greet(); } } }\"]},\"608\":{\"h\":\"八、常用容器\"},\"609\":{\"h\":\"8.1 List\",\"t\":[\"接口：java.util.List<>\",\"实现：\",\"java.util.ArrayList<>：变长数组\",\"java.util.LinkedList<>：双链表\",\"函数：\",\"add()：在末尾添加一个元素\",\"clear()：清空\",\"size()：返回长度\",\"isEmpty()：是否为空\",\"get(i)：获取第i个元素\",\"set(i, val)：将第i个元素设置为val\"]},\"610\":{\"h\":\"8.2 栈\",\"t\":[\"类：java.util.Stack<>\",\"函数：\",\"push()：压入元素\",\"pop()：弹出栈顶元素，并返回栈顶元素\",\"peek()：返回栈顶元素\",\"size()：返回长度\",\"empty()：栈是否为空\",\"clear()：清空\"]},\"611\":{\"h\":\"8.3 队列\",\"t\":[\"接口：java.util.Queue<>\",\"实现：\",\"java.util.LinkedList<>：双链表\",\"java.util.PriorityQueue<>：优先队列 \",\"默认是小根堆，大根堆写法：new PriorityQueue<>(Collections.reverseOrder())\",\"函数：\",\"add()：在队尾添加元素\",\"remove()：删除并返回队头\",\"isEmpty()：是否为空\",\"size()：返回长度\",\"peek()：返回队头\",\"clear()：清空\"]},\"612\":{\"h\":\"8.4 Set\",\"t\":[\"接口：java.util.Set<K>\",\"实现：\",\"java.util.HashSet<K>：哈希表\",\"java.util.TreeSet<K>：平衡树\",\"函数：\",\"add()：添加元素\",\"contains()：是否包含某个元素\",\"remove()：删除元素\",\"size()：返回元素数\",\"isEmpty()：是否为空\",\"clear()：清空\",\"java.util.TreeSet多的函数：\",\"ceiling(key)：返回大于等于key的最小元素，不存在则返回null\",\"floor(key)：返回小于等于key的最大元素，不存在则返回null\"]},\"613\":{\"h\":\"8.5 Map\",\"t\":[\"接口：java.util.Map<K, V>\",\"实现：\",\"java.util.HashMap<K, V>：哈希表\",\"java.util.TreeMap<K, V>：平衡树\",\"函数：\",\"put(key, value)：添加关键字和其对应的值\",\"get(key)：返回关键字对应的值\",\"containsKey(key)：是否包含关键字\",\"remove(key)：删除关键字\",\"size()：返回元素数\",\"isEmpty()：是否为空\",\"clear()：清空\",\"entrySet()：获取Map中的所有对象的集合\",\"Map.Entry<K, V>：Map中的对象类型 \",\"getKey()：获取关键字\",\"getValue()：获取值\",\"java.util.TreeMap<K, V>多的函数：\",\"ceilingEntry(key)：返回大于等于key的最小元素，不存在则返回null\",\"floorEntry(key)：返回小于等于key的最大元素，不存在则返回null\"]},\"614\":{\"h\":\"九、异常处理\",\"t\":[\"异常处理可以允许我们在程序运行时进行诊断和补救。—— 闫学灿\"]},\"615\":{\"h\":\"9.1 Error 与 Exception 的区别\",\"t\":[\"Error 是程序无法处理的错误，比如 OutOfMemoryError、ThreadDeath 等。这些异常发生时，Java 虚拟机 (JVM) 一般会选择线程终止。此类异常是程序的致命异常，是无法捕获处理的。\",\"Exception 是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。 程序中应当尽可能去处理这些异常。\"]},\"616\":{\"h\":\"9.2 Exception类的继承关系\",\"t\":[\"exception.png\"]},\"617\":{\"h\":\"9.3 运行时异常和非运行时异常的区别\",\"t\":[\"运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException、IndexOutOfBoundsException 等， 这些异常是非检查型异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\",\"非运行时异常是 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，这些是检查型异常。一般情况下不自定义检查型异常。\"]},\"618\":{\"h\":\"9.4 内置异常类\",\"t\":[\"非检查性异常：\",\"异常\",\"描述\",\"ArithmeticException\",\"当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。\",\"ArrayIndexOutOfBoundsException\",\"用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。\",\"ArrayStoreException\",\"试图将错误类型的对象存储到一个对象数组时抛出的异常。\",\"ClassCastException\",\"当试图将对象强制转换为不是实例的子类时，抛出该异常。\",\"IllegalArgumentException\",\"抛出的异常表明向方法传递了一个不合法或不正确的参数。\",\"IllegalMonitorStateException\",\"抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。\",\"IllegalStateException\",\"在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。\",\"IllegalThreadStateException\",\"线程没有处于请求操作所要求的适当状态时抛出的异常。\",\"IndexOutOfBoundsException\",\"指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\",\"NegativeArraySizeException\",\"如果应用程序试图创建大小为负的数组，则抛出该异常。\",\"NullPointerException\",\"当应用程序试图在需要对象的地方使用 null 时，抛出该异常。\",\"NumberFormatException\",\"当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\",\"SecurityException\",\"由安全管理器抛出的异常，指示存在安全侵犯。\",\"StringIndexOutOfBoundsException\",\"此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。\",\"UnsupportedOperationException\",\"当不支持请求的操作时，抛出该异常\",\"检查性异常：\",\"异常\",\"描述\",\"ClassNotFoundException\",\"应用程序试图加载类时，找不到相应的类，抛出该异常。\",\"CloneNotSupportedException\",\"当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。\",\"IllegalAccessException\",\"拒绝访问一个类的时候，抛出该异常。\",\"InstantiationException\",\"当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。\",\"InterruptedException\",\"一个线程被另一个线程中断，抛出该异常。\",\"NoSuchFieldException\",\"请求的变量不存在\",\"NoSuchMethodException\",\"请求的方法不存在\"]},\"619\":{\"h\":\"9.5 内置异常方法\",\"t\":[\"方法\",\"说明\",\"public String getMessage()\",\"返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。\",\"public Throwable getCause()\",\"返回一个 Throwable 对象代表异常原因。\",\"public String toString()\",\"返回此 Throwable 的简短描述。\",\"public void printStackTrace()\",\"将此 Throwable 及其回溯打印到标准错误流\",\"public StackTraceElement [] getStackTrace()\",\"返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\",\"public Throwable fillInStackTrace()\",\"用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。\"]},\"620\":{\"h\":\"9.6 捕获异常\",\"t\":[\"import java.util.Scanner; public class Main { private static void foo() { int[] array = new int[5]; for (int i = 0; i < 5; i ++ ) array[i] = i; Scanner sc = new Scanner(System.in); int k = sc.nextInt(); int x = sc.nextInt(); try { array[k] /= x; } catch (ArithmeticException e) { System.out.println(\\\"除零错误！\\\"); e.printStackTrace(); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\\\"数组越界！\\\"); e.printStackTrace(); } finally { for (int i = 0; i < 5; i ++ ) { System.out.println(array[i]); } } } public static void main(String[] args) { foo(); } }\"]},\"621\":{\"h\":\"9.7 抛出异常\",\"t\":[\"throw: 在函数内抛出一个异常。\",\"throws：在函数定义时抛出一些可能的异常。\",\"检查型异常必须被捕获或者抛出。\",\"import java.io.IOException; import java.util.Scanner; public class Main { private static void foo() throws IOException, NoSuchFieldException { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); if (x == 1) throw new IOException(\\\"找不到文件！！！\\\"); else throw new NoSuchFieldException(\\\"自定义异常\\\"); } public static void main(String[] args) { try { foo(); } catch (IOException e) { System.out.println(\\\"IOException!\\\"); e.printStackTrace(); } catch (NoSuchFieldException e) { System.out.println(\\\"NoSuchFieldException!\\\"); e.printStackTrace(); } } }\"]},\"622\":{\"h\":\"9.8 try-with-resources\",\"t\":[\"JDK7 之后，Java 新增的 try-with-resource 语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭 。\",\"try 用于声明和实例化资源，catch 用于处理关闭资源时可能引发的所有异常。\",\"import java.io.*; public class Main { public static void main(String[] args) { String line; try ( BufferedReader br = new BufferedReader(new FileReader(\\\"input.txt\\\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\\\"output.txt\\\")); ) { while ((line = br.readLine()) != null) { System.out.println(\\\"Line => \\\" + line); bw.write(\\\"copy: \\\" + line + \\\"\\\\n\\\"); } bw.flush(); } catch (IOException e) { System.out.println(\\\"IOException in try block =>\\\" + e.getMessage()); } } }\"]},\"623\":{\"h\":\"十、注解与反射\"},\"624\":{\"h\":\"10.1 注解\",\"t\":[\"(1) 注解（Annotation）也被称为元数据（Metadata），用于修饰包、方法、属性、构造器、局部变量等数据信息。\",\"(2) 注解不影响程序逻辑，但注解可以被编译或运行。\",\"(3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。\"]},\"625\":{\"h\":\"10.1.1 常用注解\",\"t\":[\"(1) @Override: 限定某个函数必须重写其他函数，该注解只能用于函数。函数名和参数列表必须相同。\",\"(2) @Overload: 限定某个函数必须重载其他函数，该注解只能用于函数。函数名必须相同，参数列表必须不同。\",\"(3) @Deprecated：用于表示某个程序元素（类、函数）已过时\",\"(4) @SuppressWarnings：抑制编译器警告\"]},\"626\":{\"h\":\"10.1.2 元注解\",\"t\":[\"修饰其他注解的注解，就被称为元注解。\",\"(1) Retention：指定注解的作用范围\",\"(2) Target：指定注解可以用在哪些地方\",\"(3) Document：注定注解是否出出现在 javadoc 中\",\"(4) Inherited：子类会继承父类的注解\"]},\"627\":{\"h\":\"10.2 反射\",\"t\":[\"反射：动态引入类、动态调用实例的成员函数、成员变量等。\"]},\"628\":{\"h\":\"10.2.1 常用API\",\"t\":[\"(1) java.lang.Class：获取类的实例对象\",\"(2) java.lang.reflect.Method：获取类或接口中的单个方法的信息\",\"(3) java.lang.reflect.Field：获取类或接口中的单个字段的信息\",\"(4) java.lang.reflect.Constructor：获取类中的单个构造函数的信息\",\"package org.yxc; public class Calculator { public String name; public Calculator() {} public Calculator(String name) { this.name = name; } public int add(int a, int b) { return a + b; } }\",\"package org.yxc; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { Class<?> cls = Class.forName(\\\"org.yxc.Calculator\\\"); Object o = cls.newInstance(); Method method = cls.getMethod(\\\"add\\\", int.class, int.class); int res = (int)method.invoke(o, 3, 4); System.out.println(res); Field field = cls.getField(\\\"name\\\"); field.set(o, \\\"My Calculator!\\\"); System.out.println(field.get(o)); Constructor<?> constructor = cls.getConstructor(String.class); Object new_o = constructor.newInstance(\\\"New Calculator!\\\"); System.out.println(new_o); } }\"]},\"629\":{\"h\":\"10.2.2 优缺点\",\"t\":[\"优点：可以动态创建和使用对象，使用灵活 缺点：执行速度慢\"]},\"630\":{\"h\":\"十一、多线程与锁\"},\"631\":{\"h\":\"11.1 多线程\"},\"632\":{\"h\":\"11.1.1 实现多线程\",\"t\":[\"写法1：继承 Thread 类\",\"class Worker extends Thread { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + this.getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) { Worker worker1 = new Worker(); Worker worker2 = new Worker(); worker1.setName(\\\"thread-1\\\"); worker2.setName(\\\"thread-2\\\"); worker1.start(); worker2.start(); } }\",\"写法2：实现 Runnable 接口\",\"class Worker1 implements Runnable { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + \\\"thread-1\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } class Worker2 implements Runnable { @Override public void run() { for (int i = 0; i < 10; i ++ ) { System.out.println(\\\"Hello! \\\" + \\\"thread-2\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) { new Thread(new Worker1()).start(); new Thread(new Worker2()).start(); } }\"]},\"633\":{\"h\":\"11.1.2 常用API\",\"t\":[\"start()：开启一个线程\",\"Thread.sleep(): 休眠一个线程\",\"join()：等待线程执行结束\",\"interrupt()：从休眠中中断线程（不能中断任何线程）\",\"setDaemon()：将线程设置为守护线程。当只剩下守护线程时，程序自动退出\"]},\"634\":{\"h\":\"11.2 锁\",\"t\":[\"lock：获取锁，如果锁已经被其他线程获取，则阻塞\",\"unlock：释放锁，并唤醒被该锁阻塞的其他线程\",\"import java.util.concurrent.locks.ReentrantLock; class Worker extends Thread { public static int cnt = 0; private static final ReentrantLock lock = new ReentrantLock(); @Override public void run() { for (int i = 0; i < 100000; i ++ ) { lock.lock(); try { cnt ++ ; } finally { lock.unlock(); } } } } public class Main { public static void main(String[] args) throws InterruptedException { Worker worker1 = new Worker(); Worker worker2 = new Worker(); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(Worker.cnt); } }\"]},\"635\":{\"h\":\"11.3 同步（Synchronized）\",\"t\":[\"写法1：将 Synchronized 加到代码块上\",\"class Count { public int cnt = 0; } class Worker extends Thread { public final Count count; public Worker(Count count) { this.count = count; } @Override public void run() { synchronized (count) { for (int i = 0; i < 100000; i ++ ) { count.cnt ++ ; } } } } public class Main { public static void main(String[] args) throws InterruptedException { Count count = new Count(); Worker worker1 = new Worker(count); Worker worker2 = new Worker(count); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(count.cnt); } }\",\"写法2：将 Synchronized 加到函数上（锁加到了 this 对象上）\",\"class Worker implements Runnable { public static int cnt = 0; private synchronized void work() { for (int i = 0; i < 100000; i ++ ) { cnt ++ ; } } @Override public void run() { work(); } } public class Main { public static void main(String[] args) throws InterruptedException { Worker worker = new Worker(); Thread worker1 = new Thread(worker); Thread worker2 = new Thread(worker); worker1.start(); worker2.start(); worker1.join(); worker2.join(); System.out.println(Worker.cnt); } }\"]},\"636\":{\"h\":\"11.3.1 wait 与 notify\",\"t\":[\"package org.yxc; class Worker extends Thread { private final Object object; private final boolean needWait; public Worker(Object object, boolean needWait) { this.object = object; this.needWait = needWait; } @Override public void run() { synchronized (object) { try { if (needWait) { object.wait(); System.out.println(this.getName() + \\\": 被唤醒啦！\\\"); } else { object.notifyAll(); } } catch (InterruptedException e) { throw new RuntimeException(e); } } } } public class Main { public static void main(String[] args) throws InterruptedException { Object object = new Object(); for (int i = 0; i < 5; i ++ ) { Worker worker = new Worker(object, true); worker.setName(\\\"thread-\\\" + i); worker.start(); } Worker worker = new Worker(object, false); worker.setName(\\\"thread-\\\" + 5); Thread.sleep(1000); worker.start(); } }\"]},\"637\":{\"c\":[\"Java\"]},\"638\":{\"c\":[\"基础\"]},\"639\":{\"h\":\"常用API\",\"t\":[\"整理 java 刷题过程中常用 API\"]},\"640\":{\"h\":\"数组\",\"t\":[\"toString(arr); // 返回一个字符串 copyOf(arr, begin, end); copyOfRange(arr, begin, end); // 返回与arr类型相同的一个数组，其长度为end或end-begin，并填入arr的值 // 如果end大于arr.length，结果会填充0或false值 sort(arr, begin, end); // 使用稳定的快排队数组进行排序 --- O(n logn) sort(arr, begin, end, Collections.reverseOrder()); // 数组降序排序排序 equals(arr1, arr2); // 如果两个数组长度相同，并且相同索引对应的元素都相同，则返回 true\"]},\"641\":{\"h\":\"字符串\",\"t\":[\"字符串分为两类：不可变字符串（String）和可变字符串（StringBuilder）。\",\"String 类用来表示那些创建后就不会再改变的字符串，而 StringBuilder 类用来表示内容可变的字符串，并提供了修改字符串的方法。\",\"表面上拼接字符串时，String 类使用 str1 + str2 这种形式拼接字符串，实际上是 JVM 帮助创建 StringBuilder 对象来拼接，StringBuilder 类却要调用一个 append() 方法来拼接，但其实 StringBuilder 类的效率更高。\"]},\"642\":{\"h\":\"String\",\"t\":[\"初始化有两种：\",\"String str = new String(\\\"XXX\\\"); // 参数可以是字符串常量，也可为字符数组 String str = \\\"XXX\\\"; // 参数可为字符串常量，可为String.valueOf()系列的返回值\",\"前者是 java 中标准的对象创建方式，其创建的对象将直接放置到堆中，每调用一次就会创建一个新的对象； 后者则会在栈中创建一个对象引用变量 str ，然后查看字符串池中是否存在 \\\"XXX\\\"，如果没有，则将 \\\"XXX\\\" 存放字符串池，并令引用变量 str 指向它；如果已经有 \\\"XXX\\\"，则直接令 str 指向它。\",\"常用方法：\",\"equals(); // 字符串比较必须能用equals()，相同返回true，否则返回false equalsIgnoreCase(); // 忽略大小写进行比较 charAt(int index); // 返回index位置的字符char --- O(1) length(); // 返回字符串长度 --- O(1) substring(int begin, int end); // 返回字符片段[begin, end) --- O(n) substring(int begin); // 返回从begin开始后面所有的字符片段 ---- O(n) contains(String str); // 是否包含子串str --- O(1) indexOf(String str); // 返回str第一个出现的位置，没找到则返回-1 --- O(m * n) m为原串长度， n为str长度 indexOf(String str, int index); // 同上，但从index开始找 --- O(m * n) lastIndexOf(String str); // 返回str最后出现的位置，没找到则返回-1 --- O(m * n) m为原串长度， n为str长度 lastIndexOf(String str, int index); // 同上，但从index开始从后往前找 [0 <- Index] --- O(m * n) replace(char oldChar, char newChar); // 返回一个新字符串String，其全部oldChar都替换成newChar --- O(n) toLowerCase(); // 返回一个新的字符串全部转成小写 --- O(n) toUpperCase(); // 返回一个新的字符串全部转成大写 --- O(n) trim(); // 去除首尾空白字符，包括 \\\\t \\\\r \\\\n --- O(n) strip(); // 去除首尾空白字符，还包括中文的空格字符 \\\\u3000 也会被移除 isEmpty(); // 判断字符串是否为空 isBlank(); // 判断是否为空白字符串 split(String regex); // 传入正则表达式分隔字符串 ---- O(n) // String s = \\\"A,B,C,D\\\"; // String[] ss = s.split(\\\"\\\\\\\\,\\\"); // {\\\"A\\\", \\\"B\\\", \\\"C\\\", \\\"D\\\"} join(); // 拼接字符串，用指定的字符串连接字符串数组 // String[] arr = {\\\"A\\\", \\\"B\\\", \\\"C\\\"}; // String s = String.join(\\\"***\\\", arr); // \\\"A***B***C\\\" formatted(); // 格式化字符串，通过传入其他参数，替换占位符，生成新的字符串 format(); // 同上 // String s = \\\"Hi %s, your score is %d!\\\"; // System.out.println(s.formatted(\\\"Alice\\\", 80)); // System.out.println(String.format(\\\"Hi %s, your score is %.2f!\\\", \\\"Bob\\\", 59.5));\",\"类型转换：\",\"valueOf(); // 将任意基本类型或引用类型转换为字符串 parseInt(); // 将字符串转换为int类型 parseBoolean(); // 将字符串转换为boolean类型 getInteger(); // 将该字符串对应的系统变量转换为Integer toCharArray(); // 将字符串转换为char[]数组 // char[] cs = \\\"Hello\\\".toCharArray(); // String -> char[] // String s = new String(cs); // char[] -> String // 将char[]转byte[] byte[] b1 = \\\"Hello\\\".getBytes(); // 按系统默认编码转换，不推荐 byte[] b2 = \\\"Hello\\\".getBytes(\\\"UTF-8\\\"); // 按UTF-8编码转换 byte[] b2 = \\\"Hello\\\".getBytes(\\\"GBK\\\"); // 按GBK编码转换 byte[] b3 = \\\"Hello\\\".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 // 将已知编码的byte[]转换为String byte[] b = ... String s1 = new String(b, \\\"GBK\\\"); // 按GBK转换 String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换\"]},\"643\":{\"h\":\"StringBuilder\",\"t\":[\"StringBuilder sb = new StringBuilder(); // 创建对象 charAt(int index); // 返回index位置的char --- O(1) length(); // 返回缓冲字符串长度 --- O(1) append(String str); // 拼接字符串 --- O(n) toString(); // 返回一个与构建起或缓冲器内容相同的字符串 --- O(n)\"]},\"644\":{\"h\":\"集合\"},\"645\":{\"h\":\"List 列表\",\"t\":[\"两个实现类：ArrayList、LinkedList\",\"ArrayList 底层是通过数组（动态扩容的数组）实现的，查询快\",\"LinkedList 底层是通过双向链表实现的，插入和删除快\",\"// E 表示泛型 List<E> array = new ArrayList<>(); // 顺序数组列表 List<E> array = new LinkedList<>(); // 顺序链表 ArrayList<E>(int initialCapacity); // 指定容量的空数组列表 // Set<Integer> a = new HashSet<Integer>(); List<Integer> b = new ArrayList<>(a); //接受一个集合容器 set(int index, E e); // 将元素e放在index位置，返回之前的内容 get(int index); // 返回元素位置在index的元素e --- 数组 O(1), 链表 O(n) add(E e); // 在尾部添加一个元素e --- O(1) add(int index, E e); // 后移元素，在index位置插一个元素e --- O(n) remove(int index); // 删除位于index的元素，并返回删除元素e --- 删除最后元素为O(1)， 其余为O(n) //删除最后元素 list.remove(list.size() - 1); size(); // 返回动态数组所存元素个数/链表长度 --- O(1) subList(int satrt, int end) // 相当于返回原数组的一个片段，但不要对其进行改动，改动会影响原数组 --- O(1) // List<Integer> list, 对原来的list和返回的list做的 \\\"非结构性修改\\\" // 都会影响到彼此对方. 如果你在调用了sublist返回了子list之后，如果修改了原list的大小，那么之前产生的子list将会失效，变得不可使用 trimToSize(); // 将数组列表的存储容量削减到其当前大小\"]},\"646\":{\"h\":\"Set 集合\",\"t\":[\"Set 是一种没有重复元素的集合，三个实现类：HashSet，LinkedHashSet，TreeSet。\",\"HashSet 元素乱序\",\"LinkedHashSet 保证元素添加顺序\",\"TreeSet 元素按自然顺序排序\",\"Set<E> set = new HashSet<>(); // 实例化 //List<E> list = new ArrayList<>(); Set<E> set = new HashSet<>(list); // 传参 add(E e); // 在集合中添加元素e，若成功添加则返回true，若集合中有元素e则返回false --- O(1) remove(E e); // 在集合中删除元素e，若删除成功返回true；若集合中没有元素e，返回false --- O(1) contains(E e); // 若存在元素e，则返回true，否则返回false --- O(1) isEmpty(); // 若集合为空返回true，否则返回false --- O(1) first()、last(); // 返回有序集合中第一个元素，最后一个元素，在TreeSet类中\"]},\"647\":{\"h\":\"Map 映射\",\"t\":[\"两个实现类：HashMap，TreeMap\",\"HashMap 键值对乱序\",\"TreeMap 键值对以 “键” 排序\",\"TreeSet 中的元素和 TreeMap 中键如果是基本数据类型（的包装类型）或者是字符串，那么就按照数值大小以及字典序排序即可，但是如果是自定义的实体类对象，就需要自己自定义排序方式。自定义排序时，需要用到 Comparable 接口或者是 Comparator 接口。\",\"自然排序 -- 使用 Comparable 接口\",\"定制排序 -- 使用 Comparator 接口\",\"Map<Characters, Integer> map = new HashMap<>(); // 实例化 put(K key, V value); // 在Map中加入键值对<key, value>，返回value值。如果Map中有key，则replace旧的value --- O(1) get(K key); // 返回Map中key对应的value。若Map中没有该key，则返回null --- O(1) getOrDefault(K key, V defaultValue); // 返回Map中key对应的value。若Map中没有该key，则返回defaultValue --- O(1) // For example: // Map<Character, Integer> map = new HashMap<>(); // if (...) // 如果发现k，则k在Map中的值加1。没一开始没有k，则从0开始加1。（相当于给了key在Map中的一个初试值） map.put('k', map.getOrDefault('k', 0) + 1); containsKey(Key key); // 在Map中若存在key，则返回true，否则返回false --- O(1) containsValue(Value value); // 在Map中若存在value，则返回true，否则返回false --- O(1) Set<Map.Entry<K, V>> entrySet(); // 返回Map.Entry对象的一个集视图，可以删除元素，但不能添加任何元素 Set<K> keySet(); // 返回一个Set,这个Set中包含Map中所有的Key --- O(1) // For example: // We want to get all keys in Map // Map<Character, Integer> map = new HashMap<>(); for (Character key : map.keySet()) { // Operate with each key } Collection<V> values(); // 返回一个Collection<V>，里面全是对应的每一个value --- O(1) // For example: // We want to get all values in Map // Map<Character, Integer> map = new HashMap<>(); for (Integer value : map.values()) { // Operate with each values } getKey(); // 返回这个映射的键 getValue(); // 返回这个映射的值 setValue(V newValue); // 将关联映射中的值改为新值，并返回原来的值 isEmpty() // 若Map为空返回true， 否则返回false --- O(1) size() // 返回Map中中键值对<K, V>的个数 --- O(1)\"]},\"648\":{\"h\":\"栈\",\"t\":[\"java 中 Stack 继承了 Vector 类，仅仅实现栈的操作。 另外，Deque 不仅有队列（双端队列，普通队列）的特性，也可以作为栈，用法同 Stack ，方法也相同。\",\"建议使用 Deque 用作堆栈而不是 Stack 类，因为 Stack 的方法是同步的，同步的过程会消耗时间。\",\"Deque 的实现类有 ArrayDeque 和 LinkedList，但最好使用 ArrayDeque 类在 Java 中实现堆栈数据结构。\",\"Stack<E> stack = new Stack<>(); // Stack类 Deque<E> stack = new ArrayDeque<>(); // Deque接口，ArrayDeque是Deque的一个实现类 push(E e); // 入栈元素e， 返回值为元素e --- O(1) pop(); // 出栈一个元素，返回出栈元素e --- O(1) peek(); // 查看栈顶元素， 返回值为栈顶元素e --- O(1) search(); // 从堆栈的顶部返回元素的位置 --- O(1) isEmpty() // 若栈空返回true，否则返回false --- O(1) size() // 返回栈中元素个数 --- O(1)\"]},\"649\":{\"h\":\"Queue 队列\",\"t\":[\"Queue 为接口，实现类是 LinkedList（既实现 List 接口，又实现 Queue 接口） ，特性是先进先出。\",\"Queue<E> q = new LinkedList<>(); //实例化 // 添加元素e到队尾 --- O(1) offer(E e); // 成功返回true，否则返回false add(E e); // 失败抛出异常 // 取队首元素并删除 --- O(1) poll(); // 成功返回队首元素，否则返回null remove(); // 失败抛出异常 // 不建议把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。 // 取队首元素但不删除 --- O(1) peek(); // 成功返回队首元素，否则返回null element(); // 失败抛出异常 isEmpty() // 若队空返回true，否则返回false --- O(1) size() // 返回队中元素个数 --- O(1)\"]},\"650\":{\"h\":\"Deque 双端队列\",\"t\":[\"Deque 接口实际上扩展自 Queue，Queue 中的方法在 Deque 中也可以使用，但不建议这么做。\",\"Deque<E> q = new LinkedList<>(); //实例化 offerFirst(E e); // 将元素添加到队首 --- O(1) offerLast(E e); // 将元素添加到队尾 --- O(1) pollFirst(); // 获取队首元素并删除 --- O(1) pollLast(); // 获取队尾元素并删除 --- O(1) peekFirst(); // 获取队首元素但不删除 --- O(1) peekLast(); // 获取队尾元素但不删除 --- O(1) isEmpty(); // 非空返回true，否则返回false size(); // 队列中元素个数\"]},\"651\":{\"h\":\"PriorityQueue 优先队列\",\"t\":[\"优先队列在添加元素的时候对元素的大小排序后再保存。PriorityQueue 对元素采用的是堆排序，头是按指定排序方式的最小元素。（堆排序只能保证根是最大/最小，整个堆并不是有序的）\",\"因此，放入 PriorityQueue 的元素，需要先定义好排序规则，才能够确保队列元素整体有序。\",\"PriorityQueue 默认按元素的排序规则排序（必须实现 Comparable 接口），也可以通过 Comparator 自定义排序算法（元素就不必实现 Comparable 接口）。\",\"// 默认实现小根堆。 PriorityQueue<E> minHeap = new PriorityQueue<>(); // 大根堆 PriorityQueue<E> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // 自定义实现最小/最大（e1-e2，升序 / e2-e1，降序） // 开始指定大小capacity = 100，当元素超过容量后会扩容 PriorityQueue<E> priorityQueue = new PriorityQueue<E>(100, new Comparator<E>(){ @Override public int compare(E e1, E e2) { return e2.val - e1.val; // 返回值大于0，表示两个元素需要更换位置，否则不需要更换 } }); offer(E e); // 在堆中加入元素，并调整堆。若成功入堆返回值true，否则返回false --- O(logN) poll(); // 获取堆顶元素并删除，重新调整堆 --- O(logN) peek(); // 获取堆顶元素但不删除 --- O(1) isEmpty(); // 判断队列是否为空 size(); // 队列中元素数量\"]},\"652\":{\"h\":\"工具类\"},\"653\":{\"h\":\"java.util.Math\",\"t\":[\"主要包含数学内的应用方法\",\"Math.abs(a); // 返回a的绝对值 Math.max(a, b); // 返回a和b的最大值 Math.min(a, b); // 返回a和b的最小值 Math.sqrt(a); // 开平方 Math.cbrt(b); // 开立方 Math.pow(a, b); // 返回a的b次方 Math.ceil(a); // 对浮点数向上取整 Math.floor(a); // 对浮点数向下取整 Math.round(a); // 对浮点数四舍五入 Math.log(a); // 以e为底取对数 Math.log10(a); // 以10为底取对数 Math.log(n) / Math.log(m); // 以m为底取n的对数 Math.random(); // 返回一个随机数，范围为[0,1)，返回类型为double\"]},\"654\":{\"h\":\"java.util.Collections\",\"t\":[\"主要对集合进行操作\",\"binarySearch(arr, start, end, v); // 使用二分查找算法在有序数组arr中查找值 v --- O(logn) // 如果找到 v，则返回相应的索引；否则返回一个负数值 r。-r-1 是 v 应插入的位置（为保持 a 有序） max(Collection<E> elements); // 返回集合中最大的元素 min(Collection<E> elements); // 返回集合中最小的元素 fill(Collection<E> c, V value); // 将集合的所有元素设置为 v addAll(Collection<E> c, V...values); // 将所有的值添加到给定的集合中 replaceAll(Collection<E> c, V oldvalue, V newvalue); // 用newValue替换所有等于oldValue的元素 indexOfSubList(List<E> list1, List<E> list2); // 返回list1中第一个等于list2的子列表的索引 lastIndexOfSubList(List<E> list1, List<E> list2); // 返回list1中最后一个等于list2的子列表的索引\"]},\"655\":{\"h\":\"javafx.util.Pair<K, V>\",\"t\":[\"Java 8 的 package.json 中新增了一个 Pair<K,V> 类，表示键值对，类似于 C++ 中的 pair 二元组，实现对 first 和 second 的操作。\",\"getKey(); // 返回该pair的key值 getValue(); // 返回该pair的value值 hashCode(); // 生成该pair的哈希值 equals(E e); // 判断该pair是否和对象元素e相等 toString(); // 返回该pair的字符串表示\"]},\"656\":{\"h\":\"基本类型的最大值和最小值\",\"t\":[\"数字类型包装类都支持两个常量：MAX_VALUE，MIN_VALUE，分别保存了对应基本类型的最大值与最小值。\",\"fmax = Float.MAX_VALUE; fmin = Float.MIN_VALUE; dmax = Double.MAX_VALUE; dmin = Double.MIN_VALUE; bmax = Byte.MAX_VALUE; bmin = Byte.MIN_VALUE; cmax = Character.MAX_VALUE; cmin = Character.MIN_VALUE; shmax = Short.MAX_VALUE; shmin = Short.MIN_VALUE; imax = Integer.MAX_VALUE; imin = Integer.MIN_VALUE; lmax = Long.MAX_VALUE; lmin = Long.MIN_VALUE;\"]},\"657\":{\"c\":[\"Java\"]},\"658\":{\"c\":[\"API\"]},\"659\":{\"h\":\"MinIO 安装与部署\",\"t\":[\"官方仓库\",\"GitHub：https://github.com/minio\",\"GItee镜像：https://gitee.com/mirrors/minio\",\"官网下载：https://www.minio.org.cn/download.shtml#/\"]},\"660\":{\"h\":\"Linux 安装启动\",\"t\":[\"下载安装包：\",\"wget https://dl.minio.org.cn/server/minio/release/linux-amd64/minio\",\"赋予可执行权限：\",\"chmod +x minio\",\"前台启动：\",\"MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address \\\":9001\\\"\",\"命令解释：\",\"MINIO_ROOT_USER=admin：指定MinIO的用户名\",\"MINIO_ROOT_PASSWORD=password：指定MinIO密码 （用户名和密码都可以省略，默认均为 minioadmin）\",\"./minio server：在 minio 所在目录下启动 minio 服务，可修改\",\"/mnt/data：指定数据存放位置，可以自定义修改\",\"--console-address \\\":9001\\\"：指定 MinIO 控制台的监听地址和端口\",\"后台启动：\",\"# 最简单的，只需要在最后面加上 & 即可，但关闭会话服务会停止 nohub ./minio server /mnt/data > /opt/minio/data/minio.log 2>&1 --console-address \\\":9001\\\" &\",\"命令解释：\",\"nohup：这是一个 Unix 命令，用于运行另一个命令在后台，并且忽略挂起（HUP）信号，即使你退出了终端或关闭了会话，该命令也会继续执行；\",\"> /opt/minio/data/minio.log：这部分是将标准输出（stdout）重定向到 /opt/minio/data/minio.log 文件，这意味着 MinIO 服务器的所有正常输出（如启动信息、状态更新等）都会被写入到这个日志文件中；\",\"2>&1：这部分是将标准错误输出（stderr）重定向到标准输出（stdout），即输出到 /opt/minio/data/minio.log 文件，这样，无论是标准输出还是错误输出，都会被写入到同一个日志文件中；\",\"&：这个符号是在命令的末尾，用于将命令放到后台执行，也就是即使你启动了 MinIO 服务器，你的终端或 shell 会话也不会被阻塞，你可以继续执行其他命令；\"]},\"661\":{\"h\":\"Docker 安装启动\",\"t\":[\"搜索 MinIO 镜像：\",\"docker search minio\",\"拉取 MinIO 镜像：\",\"docker pull minio/minio\",\"启动 MinIO 容器：\",\"docker run -p 9000:9000 -p 9001:9001 minio/minio server /mnt/docker/data --console-address \\\":9001\\\"\"]},\"662\":{\"h\":\"Windows 安装启动\",\"t\":[\"下载 Windows 版的 MinIO：\",\"https://dl.min.io/server/minio/release/windows-amd64/minio.exe\",\"进入到 minio.exe 所在的目录，导航栏输入 cmd 进入终端，执行：\",\"minio.exe server D:\\\\dev\\\\MinIO\\\\data --console-address \\\":9001\\\"\",\"启动 MinIO 服务，其中 D:\\\\dev\\\\MinIO\\\\data 是 MinIO 存储数据的目录路径\",\"在浏览器输入 http://localhost:9000/，登录 MinIO 服务器 web 管理后台\",\"提示\",\"默认用户名和密码都是 minioadmin\"]},\"663\":{\"h\":\"Windows 后台服务安装\",\"t\":[\"使用上述命令将 MinIO 在 Windows 上启动，关闭终端后服务就会停止。如果要使用 Windows 搭建 MinIO 服务器，需要将其注册为 Windows 服务。\",\"下载 WinSW-x64.exe：https://github.com/winsw/winsw/releases\",\"将 WinSW.exe 复制到自己指定的目录，重命名为 minio-server.exe.\",\"在同目录下创建 minio-server.xml。注意，xml 和 exe 必须同名。\",\"配置 minio-server.xml 文件，内容如下:\",\"<service> <id>minio-server</id> <name>minio-server</name> <description>minio文件存储服务</description> <executable>%BASE%\\\\minio.exe</executable> <arguments>server \\\"%BASE%\\\\data\\\"</arguments> <logpath>%BASE%\\\\logs</logpath> <log mode=\\\"roll-by-size-time\\\"> <sizeThreshold>10240</sizeThreshold> <pattern>yyyyMMdd</pattern> <autoRollAtTime>00:00:00</autoRollAtTime> <zipOlderThanNumDays>5<zipOlderThanNumDays> <zipDateFormat>yyyyMMdd</zipDateFormat> </log> </service>\",\"执行 cmd 命令注册系统服务\",\"minio-server.exe install\",\"卸载服务\",\"minio-server.exe uninstall\"]},\"664\":{\"c\":[\"中间件\"]},\"665\":{\"c\":[\"MinIO\"]},\"666\":{\"h\":\"MinIO 概述\",\"t\":[\"官网链接\",\"MinIO官网：https://min.io/\",\"中文官网：http://minio.org.cn/\",\"MinIO 是一个高性能的分布式对象存储系统，基于 Apache License v2.0 开源协议，兼容亚马逊 S3 云存储服务接口，非常适合存储大容量的数据，包括但不限于：\",\"文本数据：新闻报道、社交媒体文章、博客......\",\"语音数据：音频形式存储的数据，语音mp3文件......\",\"图像数据：各种图片......\",\"视频数据：各种视频、电影......\",\"非结构化数据：没有明确结构的数据，比如社交评论、日志文件......\"]},\"667\":{\"h\":\"什么是对象存储？\",\"t\":[\"对象存储（Object Storage）是一种数据存储架构，它以对象为单位来处理、存储和检索数据，每个对象都包含了数据本身以及元数据，适合存放任意类型的文件。通常通过基于 HTTP 或 HTTPS 协议的 API（应用程序编程接口）进行数据读写。常见的有阿里云对象存储服务（OSS）、腾讯云对象存储（COS）等。\",\"所以基于对象的形式， MinIO 存储的元数据主要包括对象的描述信息，如用户（account）、存储桶（bucket）以及存储桶索引（bucket index）等。\",\"对于企业来说，可以使用各种公有云提供的 OSS 服务，将业务数据存储在云上，既能节省存储成本，也能使用云存储服务提供的 API 接口，方便使用和管理数据。但对于数据传输的安全性和及时性有较高要求的业务来说，使用公有云的 OSS 服务，就要付出较高的公网带宽传输成本，以及对数据安全的保障服务。在这种情况下，利用 MinIO 轻便、高性能、可拓展性的特点，企业可以快速搭建自己的内部对象存储服务。\",\"当然，对于个人来说，MinIO 是 100% 开源的，这就意味着个人也可以基于 MinIO 搭建自己专属的对象存储服务器。\"]},\"668\":{\"h\":\"特点\",\"t\":[\"文档全面： MinIO 作为一款基于 Golang 语言开发的一款高性能的分布式式存储方案的开源项目，有十分完善的官方文档。\",\"MinIO 文档\",\"中文文档地址：https://www.minio.org.cn/docs/minio/\",\"高性能： MinIO 号称是目前速度最快的对象存储服务器。在标准硬件上，对象存储的读/写速度最高可以高达 183GB/s 和 171GB/s。对象存储可以作为主存储层，用来处理 Spark、Presto、TensorFlow、HAO.ai 等各种复杂工作负载以及成为 Hadoop HDFS 的替代品。\",\"云原生： 容器化、基于 K8S 的编排、多租户支持。 用作云原生应用程序的主要存储，和传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。\",\"可拓展： 不同 MinIO 集群可以组成联邦，并形成一个全局的命名空间，并且支持跨越多个数据中心。 并且除了 MinIO 自己的文件系统，还支持 DAS、 JBODs、NAS、Google 云存储和 Azure Blob 存储。\",\"Amazon S3 标准兼容: 亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界内大家都认可的标准。MinIO 在很早的时候就采用了 S3 兼容协议，并且 MinIO 是第一个支持 S3 Select 的产品。 使用 Amazon S3 v2 / v4 API，可以使用 MinIO SDK，MinIO Client，AWS SDK 和 AWS CLI 访问 MinIO 服务器。\",\"支持全面： 目前 MinIO 支持市面主流的开发语言并且可以通过 SDK 快速集成快速集成使用。\",\"常用语言的 SDK\",\"GO SDK：https://github.com/minio/minio-go\",\"Java SDK：https://github.com/minio/minio-java\",\"Python SDK：https://github.com/minio/minio-py\",\"可视化管理界面： MinIO 除了通过传统的命令行进行操作之外，还提供可视化的操作管理界面，在服务安装后，可以直接通过浏览器登录系统，完成文件夹、文件的管理，非常方便使用。\",\"数据存储高容错： Minio 的存储机制使用纠删码（Erasure Code）和校验和（CheckSum）。 校验和：保护数据免受硬件故障和无声数据损坏。 纠删码：是一种恢复丢失和损坏数据的数学算法。通过数学算法将数据分割成多个数据块和校验块，并将这些块分散存储在不同的磁盘上。这种机制使得即使部分磁盘发生故障，也能通过剩余的数据块和校验块恢复原始数据，从而提高系统的可靠性和容错能力。 具体地，MinIO 使用 Reed-Solomon 码作为其纠删码算法，将一个对象拆分成 N/2 份数据和 N/2 份奇偶校验块。如果是 12 块盘，一个对象会被分成 6 个数据块、 6 个奇偶校验块，可以丢失任意 6 块盘（不管其是存放的数据块还是奇偶校验块），仍可以从剩下的盘中的数据进行恢复。 这样的设计，保证了即使在最坏的情况，即丢失一半数量的硬盘的情况下仍能保证数据的安全性。\"]},\"669\":{\"c\":[\"中间件\"]},\"670\":{\"c\":[\"MinIO\"]},\"671\":{\"h\":\"SpringBoot 整合 MinIO\"},\"672\":{\"h\":\"引入依赖\",\"t\":[\"<dependency> <groupId>io.minio</groupId> <artifactId>minio</artifactId> <version>8.5.9</version> </dependency>\"]},\"673\":{\"h\":\"配置文件\",\"t\":[\"MinIO 中的 Bucket、Object\",\"Bucket 是存储 Object 的逻辑空间，每个 Bucket 之间的数据是相互隔离的，对用户而言，相当于存放文件的顶层文件夹\",\"Object 是存储到 MinIO 的基本对象，对用户而言，相当于文件\",\"SpringBoot 使用 MinIO 非常方便，只需要创建 MinIOClient 即可，后续通过调用 API 对 MinIO 服务进行配置和操作。\",\"在 application.yml 中配置 MinIO 连接信息\",\"minio: endpoint: http://localhost:9000 # 服务器地址和端口 accessKey: minioadmin # minio用户名 secretKey: minioadmin # minio密码 bucket: user-bucket # 使用的存储桶（可选）\",\"添加 MinIO 实体类\",\"@Data @Component @ConfigurationProperties(prefix = \\\"minio\\\") public class MinIOInfo { private String endpoint; private String accessKey; private String secretKey; private String bucket; }\",\"将 MinIOClient 注册为 Bean 对象，后续通过注入 minioClient 对象即可实现对 MinIO 的操作。\",\"@Configuration public class Config { @Resource private MinIOInfo minIOInfo; @Bean public MinioClient minioClient() { //链式编程，构建MinioClient对象 return MinioClient.builder() .endpoint(minIOInfo.getEndpoint()) .credentials(minIOInfo.getAccessKey(), minIOInfo.getSecretKey()) .build(); } }\",\"支持多线程\",\"MinioClient 对象是单例的，那么有没有线程安全问题呢？\",\"答案是：没有线程安全问题。MinIO 官方团队表示，可以多个线程共同使用一个 MinIOClient 对象。\"]},\"674\":{\"h\":\"MinioClient 的常用 API\"},\"675\":{\"h\":\"Bucket 操作\",\"t\":[\"bucketExists()：用于检查指定的存储桶是否存在，返回布尔值，表示存储桶是否存在\",\" void test01() throws Exception { boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(\\\"myfile\\\").build()); System.out.println(\\\"myfile目录是否存在：\\\" + isBucketExists); }\",\"makeBucket()：用于创建一个新的存储桶（bucket），需要指定存储桶的名称\",\" void test02() throws Exception { String bucketName = \\\"myfile2\\\"; boolean isBucketExists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build()); if (!isBucketExists) { minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build()); } else { System.out.println(\\\"bucket已经存在，不需要创建\\\"); } String policyJsonString = \\\"{\\\\\\\"Version\\\\\\\" : \\\\\\\"2012-10-17\\\\\\\",\\\\\\\"Statement\\\\\\\":[{\\\\\\\"Sid\\\\\\\":\\\\\\\"PublicRead\\\\\\\",\\\\\\\"Effect\\\\\\\":\\\\\\\"Allow\\\\\\\",\\\\\\\"Principal\\\\\\\":{\\\\\\\"AWS\\\\\\\":\\\\\\\"*\\\\\\\"},\\\\\\\"Action\\\\\\\":[\\\\\\\"s3:GetObject\\\\\\\"],\\\\\\\"Resource\\\\\\\":[\\\\\\\"arn:aws:s3:::\\\" + bucketName + \\\"/*\\\\\\\"]}]}\\\"; //创建存储桶的时候，设置该存储桶里面的文件的访问策略，运行公开的读； minioClient.setBucketPolicy(SetBucketPolicyArgs.builder() .bucket(bucketName) .config(policyJsonString)//json串，里面是访问策略 .build()); }\",\"listBuckets()：用于列出用户有权访问的所有存储桶，返回存储桶的列表\",\" void test03() throws Exception { List<Bucket> bucketList = minioClient.listBuckets(); bucketList.forEach(bucket -> { System.out.println(bucket.name() + \\\" -- \\\" + bucket.creationDate()); }); }\",\"removeBucket()：用于删除一个已存在的存储桶（bucket），删除失败会抛出异常\",\" void test04() throws Exception { minioClient.removeBucket(RemoveBucketArgs.builder().bucket(\\\"myfile2\\\").build()); }\"]},\"676\":{\"h\":\"Object 操作\",\"t\":[\"putObject()：用于上传文件到指定的存储桶\",\" void test05() throws Exception { File file = new File(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\"); // 文件路径 ObjectWriteResponse objectWriteResponse = minioClient.putObject(PutObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .stream(new FileInputStream(file), file.length(), -1) // 使用stream流读取文件，自动获取文件大小 .build() ); System.out.println(objectWriteResponse); ObjectWriteResponse objectWriteResponse2 = minioClient.uploadObject(UploadObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test2.jpg\\\") .filename(\\\"D:\\\\\\\\MinIO\\\\\\\\MinioClient.jpg\\\") // 指定文件路径 .build() ); System.out.println(objectWriteResponse); }\",\"statObject()：用于检查指定的对象（文件）的状态\",\" void test06() throws Exception { StatObjectResponse statObjectResponse = minioClient.statObject(StatObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(statObjectResponse); }\",\"getPresignedObjectUrl()：用于生成一个对象（文件）的签名URL，以便可以通过HTTP访问\",\" void test07() throws Exception { String presignedObjectUrl = minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .expiry(3, TimeUnit.MINUTES) .method(Method.GET) .build() ); System.out.println(presignedObjectUrl); }\",\"getObject()：用于从指定的存储桶中下载文件\",\" void test08() throws Exception { GetObjectResponse getObjectResponse = minioClient.getObject(GetObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); System.out.println(getObjectResponse.transferTo(new FileOutputStream(\\\"D:\\\\\\\\MinIO\\\\\\\\123.jpg\\\"))); }\",\"listObjects()：用于列出指定存储桶中的所有对象（文件）\",\" void test09() throws Exception { Iterable<Result<Item>> listObjects = minioClient.listObjects(ListObjectsArgs.builder() .bucket(\\\"myfile\\\") .build() ); listObjects.forEach( itemResult -> { try { Item item = itemResult.get(); System.out.println(item.objectName()); } catch (Exception e) { throw new RuntimeException(e); } }); }\",\"removeObject()：用于删除指定存储桶中的对象，需要指定存储桶名称和对象键\",\" void test10() throws Exception { minioClient.removeObject(RemoveObjectArgs.builder() .bucket(\\\"myfile\\\") .object(\\\"test.jpg\\\") .build() ); }\"]},\"677\":{\"c\":[\"中间件\"]},\"678\":{\"c\":[\"MinIO\"]},\"679\":{\"h\":\"Shell 语法\"},\"680\":{\"h\":\"概论\",\"t\":[\"shell 是我们通过命令行与操作系统沟通的语言。\",\"shell 脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 AC Terminal 中的命令行可以看成是一个\\\"shell脚本在逐行执行\\\"。\",\"Linux 中常见的 shell 脚本有很多种，常见的有：\",\"Bourne Shell ( /usr/bin/sh 或 /bin/sh )\",\"Bourne Again Shell ( /bin/bash )\",\"C Shell ( /usr/bin/csh )\",\"K Shell ( /usr/bin/ksh )\",\"zsh ...\",\"Linux 系统中一般默认使用 bash，所以接下来讲解 bash 中的语法。 文件开头需要写 #! /bin/bash ，指明 bash 为脚本解释器。\",\"学习技巧\",\"不要死记硬背，遇到含糊不清的地方，可以在 AC Terminal 里实际运行一遍。\",\"脚本示例\",\"新建一个 test.sh 文件，内容如下：\",\"#! /bin/bash echo \\\"Hello World!\\\"\",\"运行方式\",\"作为可执行文件\",\"acs@9e0ebfcd82d7:~$ chmod +x test.sh # 使脚本具有可执行权限 acs@9e0ebfcd82d7:~$ ./test.sh # 当前路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ /home/acs/test.sh # 绝对路径下执行 Hello World! # 脚本输出 acs@9e0ebfcd82d7:~$ ~/test.sh # 家目录路径下执行 Hello World! # 脚本输出\",\"用解释器执行\",\"acs@9e0ebfcd82d7:~$ bash test.sh Hello World! # 脚本输出\"]},\"681\":{\"h\":\"1. 注释\"},\"682\":{\"h\":\"1.1 单行注释\",\"t\":[\"每行中 # 之后的内容均是注释。\",\"# 这是一行注释 echo 'Hello World' # 这也是注释\"]},\"683\":{\"h\":\"1.2 多行注释\",\"t\":[\"格式：\",\":<<EOF 第一行注释 第二行注释 第三行注释 EOF\",\"其中 EOF 可以换成其它任意字符串。例如：\",\":<<abc 第一行注释 第二行注释 第三行注释 abc :<<! 第一行注释 第二行注释 第三行注释 !\"]},\"684\":{\"h\":\"2. 变量\"},\"685\":{\"h\":\"2.1 定义变量\",\"t\":[\"定义变量，不需要加 $ 符号，例如：\",\"name1='yxc' # 单引号定义字符串 name2=\\\"yxc\\\" # 双引号定义字符串 name3=yxc # 也可以不加引号，同样表示字符串\"]},\"686\":{\"h\":\"2.2 使用变量\",\"t\":[\"使用变量，需要加上 $ 符号，或者 ${} 符号。花括号是可选的，主要为了帮助解释器识别变量边界。\",\"name=yxc echo $name # 输出yxc echo ${name} # 输出yxc echo ${name}acwing # 输出yxcacwing\"]},\"687\":{\"h\":\"2.3 只读变量\",\"t\":[\"使用 readonly 或者 declare 可以将变量变为只读。\",\"name=yxc readonly name declare -r name # 两种写法均可 name=abc # 会报错，因为此时name只读\"]},\"688\":{\"h\":\"2.4 删除变量\",\"t\":[\"unset 可以删除变量。\",\"name=yxc unset name echo $name # 输出空行\"]},\"689\":{\"h\":\"2.5 变量类型\",\"t\":[\"自定义变量（局部变量）\",\"子进程不能访问的变量\",\"环境变量（全局变量）\",\"子进程可以访问的变量\",\"自定义变量改成环境变量：\",\"acs@9e0ebfcd82d7:~$ name=yxc # 定义变量 acs@9e0ebfcd82d7:~$ export name # 第一种方法 acs@9e0ebfcd82d7:~$ declare -x name # 第二种方法\",\"环境变量改为自定义变量：\",\"acs@9e0ebfcd82d7:~$ export name=yxc # 定义环境变量 acs@9e0ebfcd82d7:~$ declare +x name # 改为自定义变量\"]},\"690\":{\"h\":\"2.6 字符串\",\"t\":[\"字符串可以用单引号，也可以用双引号，也可以不用引号。\",\"单引号与双引号的区别：\",\"单引号中的内容会原样输出，不会执行、不会取变量；\",\"双引号中的内容可以执行、可以取变量；\",\"name=yxc # 不用引号 echo 'hello, $name \\\\\\\"hh\\\\\\\"' # 单引号字符串，输出 hello, $name \\\\\\\"hh\\\\\\\" echo \\\"hello, $name \\\\\\\"hh\\\\\\\"\\\" # 双引号字符串，输出 hello, yxc \\\"hh\\\"\",\"获取字符串长度\",\"name=\\\"yxc\\\" echo ${#name} # 输出3\",\"提取子串\",\"name=\\\"hello, yxc\\\" echo ${name:0:5} # 提取从0开始的5个字符\"]},\"691\":{\"h\":\"3. 默认变量\"},\"692\":{\"h\":\"3. 1 文件参数变量\",\"t\":[\"在执行 shell 脚本时，可以向脚本传递参数。$1 是第一个参数，$2 是第二个参数，以此类推。特殊的，$0 是文件名（包含路径）。例如：\",\"创建文件 test.sh ：\",\"#! /bin/bash echo \\\"文件名：\\\"$0 echo \\\"第一个参数：\\\"$1 echo \\\"第二个参数：\\\"$2 echo \\\"第三个参数：\\\"$3 echo \\\"第四个参数：\\\"$4\",\"然后执行该脚本：\",\"acs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4 文件名：./test.sh 第一个参数：1 第二个参数：2 第三个参数：3 第四个参数：4\"]},\"693\":{\"h\":\"3.2 其它参数相关变量\",\"t\":[\"参数\",\"说明\",\"$#\",\"代表文件传入的参数个数，如上例中值为4\",\"$*\",\"由所有参数构成的用空格隔开的字符串，如上例中值为 \\\"$1 $2 $3 $4\\\"\",\"$@\",\"每个参数分别用双引号括起来的字符串，如上例中值为 \\\"$1\\\" \\\"$2\\\" \\\"$3\\\" \\\"$4\\\"\",\"$$\",\"脚本当前运行的进程ID\",\"$?\",\"上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\",\"$(command)\",\"返回 command这条命令的stdout（可嵌套）\",\"command\",\"返回 command 这条命令的stdout（不可嵌套）\"]},\"694\":{\"h\":\"4. 数组\",\"t\":[\"数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。 数组 下标从0开始。\"]},\"695\":{\"h\":\"4.1 定义\",\"t\":[\"数组用小括号表示，元素之间用空格隔开。例如：\",\"array=(1 abc \\\"def\\\" yxc)\",\"也可以直接定义数组中某个元素的值：\",\"array[0]=1 array[1]=abc array[2]=\\\"def\\\" array[3]=yxc\"]},\"696\":{\"h\":\"4.2 读取数组中某个元素的值\",\"t\":[\"格式：\",\"${array[index]}\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${array[0]} echo ${array[1]} echo ${array[2]} echo ${array[3]}\"]},\"697\":{\"h\":\"4.3 读取整个数组\",\"t\":[\"格式：\",\"${array[@]} # 第一种写法 ${array[*]} # 第二种写法\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${array[@]} # 第一种写法 echo ${array[*]} # 第二种写法\"]},\"698\":{\"h\":\"4.4 数组长度\",\"t\":[\"类似于字符串\",\"${#array[@]} # 第一种写法 ${#array[*]} # 第二种写法\",\"例如：\",\"array=(1 abc \\\"def\\\" yxc) echo ${#array[@]} # 第一种写法 echo ${#array[*]} # 第二种写法\"]},\"699\":{\"c\":[\"Linux\"]},\"700\":{\"c\":[\"基础\"]},\"701\":{\"h\":\"1. 领导让我研究 Eureka 源码：启动过程\",\"t\":[\"转载自悟空聊架构，原文链接：领导让我研究 Eureka 源码 | 启动过程\"]},\"702\":{\"h\":\"一、初始化环境\",\"t\":[\"打开源码，找到这个启动类，EurekaBootStrap.java，在这个路径下：\",\"\\\\eureka\\\\eureka-core\\\\src\\\\main\\\\java\\\\com\\\\netflix\\\\eureka\\\\EurekaBootStrap.java\",\"启动时序图给大家画好了：\",\"初始化环境时序图\",\"启动代码：\",\"@Override public void contextInitialized(ServletContextEvent event) { initEurekaEnvironment(); initEurekaServerContext(); // 省略非核心代码 }\",\"分为两步，初始化环境和初始化上下文，先来看第一步。\",\"初始化环境的方法是 initEurekaEnvironment()，点进去看下这个方法做了什么。\",\"String dataCenter = ConfigurationManager.getConfigInstance() .getString(EUREKA_DATACENTER);\",\"就是获取配置管理类的一个单例。单例的实现方法用的是 双重检测 + volatile\",\"public static AbstractConfiguration getConfigInstance() { if (instance == null) { synchronized (ConfigurationManager.class) { if (instance == null) { instance = getConfigInstance(false)); } } } return instance; }\",\"instance 变量定义成了 volatile，保证可见性。\",\"static volatile AbstractConfiguration instance = null;\",\"线程 A 修改后，会将变量的值刷到主内存中，线程 B 会将主内存中的值刷回到自己的线程内存中，也就是说线程 A 改了后，线程 B 可以看到改了后的值。\",\"可以参考之前我写的文章：反制面试官 - 14 张原理图 - 再也不怕被问 volatile\"]},\"703\":{\"h\":\"二、初始化上下文\",\"t\":[\"初始化上下文的时序图如下：\",\"初始化上下文的时序图\",\"还是在 EurekaBootStrap.java 类中 contextInitialized 方法中，第二步调用了 initEurekaServerContext() 方法。\",\"initEurekaServerContext 里面主要的操作分为六步：\",\"第一步就是加载配置文件。\"]},\"704\":{\"h\":\"2.1 加载 eureka-server 配置文件\",\"t\":[\"基于接口的方式，获取配置项。\",\"initEurekaServerContext 方法创建了一个 eurekaServerConfig 对象：\",\"EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();\",\"图片\",\"EurekaServerConfig 是一个接口，里面定义了很多获取配置项的方法。和定义常量来获取配置项的方式不同。比如获取 AccessId 和 SecretKey。\",\"String getAWSAccessId(); String getAWSSecretKey();\",\"还有另外一种获取配置项的方式：Config.get(Constants.XX_XX)，这种方式和上面的接口的方式相比：\",\"常量的方式较容易取错变量。因为常量的定义都是大写，很可能拿到 XX_XY 变量，而接口的方法是驼峰命名的，更容易辨识，对于相似的变量，取一个辨识度更高的方法名即可。\",\"常量的方式不易于修改。假如修改了常量名称，则需要全局搜索用到的地方，都改掉。如果是用接口的方式，则只需要修改接口方法中引用常量的地方即可，对于调用接口方法的地方是透明的。\"]},\"705\":{\"h\":\"2.1.1 创建默认的 eureka server 配置\",\"t\":[\"new DefaultEurekaServerConfig()，会创建出一个默认的 server 配置，构造方法会调用 init 方法：\",\"public DefaultEurekaServerConfig() { init(); }\"]},\"706\":{\"h\":\"2.2.2 加载配置文件\",\"t\":[\"private void init() { String env = ConfigurationManager.getConfigInstance() .getString(EUREKA_ENVIRONMENT, TEST); ConfigurationManager.getConfigInstance() .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env); String eurekaPropsFile = EUREKA_PROPS_FILE.get(); try { ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile); } catch (IOException e) { logger.warn( \\\"Cannot find the properties specified : {}. This may be okay if there are other environment \\\" + \\\"specific properties or the configuration is installed with a different mechanism.\\\", eurekaPropsFile); } }\",\"前两行是设置环境名称，后面几行是关键语句：获取配置文件，并放到 ConfigurationManager 单例中。\",\"来看下 EUREKA_PROPS_FILE.get(); 做了什么。\",\"首先 EUREKA_PROPS_FILE 是这样定义的：\",\"private static final DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory.getInstance() .getStringProperty(\\\"eureka.server.props\\\", \\\"eureka-server\\\");\",\"用单例工厂 DynamicPropertyFactory 设置了默认值 eureka-server，然后 EUREKA_PROP_FILE.get() 就会从缓存里面这个默认值。\",\"然后再调用 loadCascadedPropertiesFromResources 方法，来加载配置文件。\",\"首先会拼接默认的配置文件：\",\"String defaultConfigFileName = configName + \\\".properties\\\";\",\"然后获取默认配置文件的配置项：\",\"Properties props = getPropertiesFromFile(url);\",\"然后再拼接当前环境的配置文件\",\"String envConfigFileName = configName + \\\"-\\\" + environment + \\\".properties\\\";\",\"然后获取环境的配置文件的配置项并覆盖之前的默认配置项。\",\"props.putAll(envProps);\",\"putAll 方法就是将这些属性放到一个 map 中。\",\"然后这些配置项统一都交给 ConfigurationManager 来管理：\",\"config.loadProperties(props);<br>\",\"其实就是加载这个文件：\",\"eureka-server.properties\",\"打开这个文件后，发现里面有几个 demo 配置项，不过都被注释了。\"]},\"707\":{\"h\":\"2.1.3 真正的配置项在哪？\",\"t\":[\"上面可以看到 eureka-server.properties 都是空的，那配置项都配置在哪呢？\",\"我们之前说过，DefaultEurekaServerConfig 是实现了 EurekaServerConfig 接口的，如下所示：\",\"public class DefaultEurekaServerConfig implements EurekaServerConfig\",\"在 EurekaServerConfig 接口里面定义很多 get 方法，而 DefaultEurekaServerConfig 实现了这些 get 方法，来看下怎么实现的：\",\"@Override public int getWaitTimeInMsWhenSyncEmpty() { return configInstance.getIntProperty( namespace + \\\"waitTimeInMsWhenSyncEmpty\\\", (1000 * 60 * 5)).get(); }\",\"里面的类似这样的 getXX 的方法，都有一个 default value，比如上面的是 1000∗60∗5，所以我们可以知道，配置项是在 DefaultEurekaServerConfig 类中定义的。\",\"configInstance 这个单例又是 DynamicPropertyFactory 类型的，而在创建 configInstance 单例的时候，ConfigurationManager 还做了一些事情：将配置文件中的配置项放到 DynamicPropertyFactory 单例中，这样的话，DefaultEurekaServerConfig 中的 get 方法就可以获取到配置文件中的配置项了。具体的代码在 DynamicPropertyFactory 类中的 initWithConfigurationSource 方法中。\",\"结合上面的加载配置文件的分析，可以得出结论：如果配置文件中没有配置，则用 DefaultEurekaServerConfig 定义的默认值。\"]},\"708\":{\"h\":\"2.1.4 加载配置文件小结\",\"t\":[\"（1）创建一个 DefaultEurekaServerConfig 对象，实现了 EurekaServerConfig 接口，里面有很多获取配置项的方法。\",\"（2）DefaultEurekaServerConfig 构造函数中调用了 init 方法。\",\"（3）init 方法会加载 eureka-server.properties 配置文件，把里面的配置项都放到一个 map 中，然后交给 ConfigurationManager 来管理。\",\"（4）DefaultEurekaServerConfig 对象里面有很多 get 方法，里面通过 hard code 定义了配置项的名称，当调用 get 方法时，调用的是 DynamicPropertyFactory 的获取配置项的方法，这些配置项如果在配置文件中有，则用配置项的。配置文件中的配置项是通过 ConfigurationManager 赋值给 DynamicPropertyFactory 的。\",\"（5）当要获取配置项时，就调用对应的 get 方法，如果配置文件没有配置，则用默认值。\"]},\"709\":{\"h\":\"2.2 构造实例信息管理器\",\"t\":[\"结构如下图所示：\",\"实例信息管理器\"]},\"710\":{\"h\":\"2.2.1 初始化服务实例的配置 instanceConfig\",\"t\":[\"创建了一个 ApplicationInfoManager 对象，服务配置管理器，Application 可以理解为一个 Eureka client，作为一个应用程序向 Eureka 服务注册的。\",\"applicationInfoManager = new ApplicationInfoManager( instanceConfig, new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());\",\"创建这个对象时，传了 instanceConfig，这个就是 eureka 实例的配置。这个 instanceConfig 和之前讲过的 EurekaServerConfig 很像，都是实现了一个接口，通过接口的 getXX 方法来获取配置信息。\"]},\"711\":{\"h\":\"2.2.2 构造服务实例 instanceInfo\",\"t\":[\"另外一个参数是 EurekaConfigBasedInstanceInfoProvider，这个 Provider 是用来构造 instanceInfo（服务实例）。\",\"怎么构造出来的呢？用到了设计模式中的 构造器模式，而用到的配置信息就是从 EurekaInstanceConfig 里面获取到的。\",\"InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder(vipAddressResolver); builder.setXX ... instanceInfo = builder.build();\",\"setXX 的代码如下所示：\",\"setXX 示例\"]},\"712\":{\"h\":\"2.2.3 小结\",\"t\":[\"（1）初始化服务实例的配置 instanceConfig。\",\"（2）用构造器模式初始化服务实例 instanceInfo。\",\"（3）将 instanceConfig 和 instanceInfo 传给了 ApplicationInfoManager，交由它来管理。\"]},\"713\":{\"h\":\"2.3 初始化 eureka-client\"},\"714\":{\"h\":\"2.3.1 初始化 eureka-client 配置\",\"t\":[\"eurekaClient 是包含在 eureka-server 服务中的，用来跟其他 eureka-server 进行通信的。为什么还会有其他 eureka-server，因为在集群环境中，是会有多个 eureka 服务的，而服务之间是需要相互通信的。\",\"初始化 eureka-client 代码：\",\"EurekaClientConfig eurekaClientConfig = new DefaultEurekaClientConfig(); eurekaClient = new DiscoveryClient(applicationInfoManager, eurekaClientConfig);\",\"第一行又是初始化了一个配置，和之前初始化 server config，instance config 的地方很相似。也是通过接口方法里面的 DynamicPropertyFactory 来获取配置项的值。\",\"eureka-client 也有一个加载配置文件的方法：\",\"Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);\",\"这个文件就是 eureka-client.properties。\",\"初始化配置的时候还初始化了一个 DefaultEurekaTransportConfig()，可以理解为传输的配置。\"]},\"715\":{\"h\":\"2.3.2 初始化 eurekaClient\",\"t\":[\"再来看下第二行代码，创建了一个 DiscoveryClient 对象，赋值给了 eurekaClient。\",\"创建 DiscoveryClient 对象的过程非常复杂，我们来细看下。\",\"（1） 拿到 eureka-client 的 config 、transport 的 config、instance 实例信息。\",\"（2） 判断是否要获取注册表信息，默认会获取。\",\"if (config.shouldFetchRegistry())\",\"如果在配置文件中定义了 fetch-registry: false，则不会获取，单机 eureka 情况下，配置为 false，因为自己就包含了注册表信息，而且也不需要从其他` eureka 实例上获取配置信息。当在集群环境下，才需要获取注册表信息。\",\"（3） 判断是否要把自己注册到其他 eureka 上，默认会注册。\",\"if (config.shouldRegisterWithEureka())\",\"单机情况下，配置 register-with-eureka: false。\",\"（4） 创建了一个支持任务调度的线程池。\",\"scheduler = Executors.newScheduledThreadPool(2, new ThreadFactoryBuilder() .setNameFormat(\\\"DiscoveryClient-%d\\\") .setDaemon(true) .build());\",\"（5） 创建了一个支持心跳检测的线程池。\",\"heartbeatExecutor = new ThreadPoolExecutor( 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactoryBuilder() .setNameFormat(\\\"DiscoveryClient-HeartbeatExecutor-%d\\\") .setDaemon(true) .build() ); // use direct handoff\",\"（6） 创建了一个支持缓存刷新的线程池。\",\"cacheRefreshExecutor = new ThreadPoolExecutor( 1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactoryBuilder() .setNameFormat(\\\"DiscoveryClient-CacheRefreshExecutor-%d\\\") .setDaemon(true) .build() ); // use direct handoff\",\"（7） 创建了一个支持 eureka client 和 eureka server 进行通信的对象\",\"eurekaTransport = new EurekaTransport();\",\"（8） 初始化调度任务\",\"initScheduledTasks();\",\"这个里面就会根据 fetch-registry 来判断是否需要开始调度执行刷新注册表信息，默认 30 s 调度一次。这个刷新的操作是由一个 CacheRefreshThread 线程来执行的。\",\"同样的，也会根据 register-with-eureka 来判断是否需要开始调度执行发送心跳，默认 30 s 调度一次。这个发送心跳的操作由一个 HeartbeatThread 线程来执行的。\",\"然后还创建了一个实例信息的副本，用来将自己本地的 instanceInfo 实例信息传给其他服务。什么时候发送这些信息呢？\",\"又创建了一个监听器 statusChangeListener，这个监听器监听到状态改变时，就调用副本的 onDemandUpdate() 方法，将 instanceInfo 传给其他服务。\"]},\"716\":{\"h\":\"2.4 处理注册相关的流程\"},\"717\":{\"h\":\"2.4.1 注册对象\",\"t\":[\"创建了一个 PeerAwareInstanceRegistryImpl 对象，通过名字可以知道是 可以感知集群实例注册表的实现类。通过官方注释可以知道这个类的作用：\",\"处理所有的拷贝操作到其他节点，让他们保持同步。复制的操作包含 注册，续约，摘除，过期和状态变更。\",\"当 eureka server 启动后，它尝试着从集群节点去获取所有的注册信息。如果获取失败了，当前 eureka server 在一段时间内不会让其他应用获取注册信息，默认 5 分钟。\",\"自我保护机制：如果应用丢失续约的占比在一定时间内超过了设定的百分比，则 eureka 会报警，然后停止执行过期应用。\",\"registry = new PeerAwareInstanceRegistryImpl( eurekaServerConfig, eurekaClient.getEurekaClientConfig(), serverCodecs, eurekaClient );\",\"PeerAwareInstanceRegistryImpl 继承 AbstractInstanceRegistry 抽象类，构造函数主要做了以下事情：\",\"初始化 server config 和 client config 的配置信息。\",\"this.serverConfig = serverConfig; this.clientConfig = clientConfig;\",\"初始化摘除的队列，队列长度为 1000。\",\"this.recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);\",\"初始化注册的队列。\",\"this.recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);\"]},\"718\":{\"h\":\"2.5 初始化上下文\"},\"719\":{\"h\":\"2.5.1 集群节点帮助类\",\"t\":[\"创建了一个 PeerEurekaNodes，它是一个帮助类，来管理集群节点的生命周期。\",\"PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes( registry, eurekaServerConfig, eurekaClient.getEurekaClientConfig(), serverCodecs, applicationInfoManager );\"]},\"720\":{\"h\":\"2.5.2 默认上下文\",\"t\":[\"创建了一个 DefaultEurekaServerContext 默认上下文。\",\"serverContext = new DefaultEurekaServerContext( eurekaServerConfig, serverCodecs, registry, peerEurekaNodes, applicationInfoManager );\"]},\"721\":{\"h\":\"2.5.3 创建上下文的持有者\",\"t\":[\"创建了一个 holder，用来持有上下文。其他地方想要获取上下文，就通过 holder 来获取。用到了单例模式。\",\"EurekaServerContextHolder.initialize(serverContext);\",\"holder 的 initialize() 初始化方法是一个线程安全的方法。\",\"public static synchronized void initialize(EurekaServerContext serverContext) { holder = new EurekaServerContextHolder(serverContext); }\",\"定义了一个静态的私有的 holder 变量\",\"private static EurekaServerContextHolder holder;\",\"其他地方想获取 holder 的话，就通过 getInstance() 方法来获取 holder。\",\"public static EurekaServerContextHolder getInstance() { return holder; }\",\"然后想要获取上下文的就调用 holder 的 getServerContext() 方法。\",\"public EurekaServerContext getServerContext() { return this.serverContext; }\"]},\"722\":{\"h\":\"2.5.4 初始化上下文\",\"t\":[\"调用 serverContext 的 initialize() 方法来初始化。\",\"public void initialize() throws Exception { logger.info(\\\"Initializing ...\\\"); peerEurekaNodes.start(); registry.init(peerEurekaNodes); logger.info(\\\"Initialized\\\"); }\",\"peerEurekaNodes.start();\",\"这个里面就是启动了一个定时任务，将集群节点的 URL 放到集合里面，这个集合不包含本地节点的 url。每隔一定时间，就更新 eureka server 集群的信息。\",\"registry.init(peerEurekaNodes);\",\"这个里面会初始化注册表，将集群中的 注册信息获取下，然后放到注册表里面。\"]},\"723\":{\"h\":\"2.6 其他\"},\"724\":{\"h\":\"2.6.1 从相邻节点拷贝注册信息\",\"t\":[\"int registryCount = registry.syncUp();\"]},\"725\":{\"h\":\"2.6.2 eureka 监控\",\"t\":[\"EurekaMonitors.registerAllStats();\"]},\"726\":{\"h\":\"2.7 编译报错的解决方案\"},\"727\":{\"h\":\"1、异常1\",\"t\":[\"An exception occurred applying plugin request [id: 'nebula.netflixoss', version: '3.6.0']\",\"解决方案\",\"plugins { id 'nebula.netflixoss' version '5.1.1' }\"]},\"728\":{\"h\":\"2、异常2\",\"t\":[\"eureka-server-governator Plugin with id 'jetty' not found.\",\"参考 https://blog.csdn.net/Sino_Crazy_Snail/article/details/79300058\"]},\"729\":{\"h\":\"三、总结\",\"t\":[\"来一份 Eureka 启动的整体流程图\",\"Eureka 启动过程\"]},\"730\":{\"c\":[\"常用框架\"]},\"731\":{\"c\":[\"SpringCloud\"]},\"732\":{\"h\":\"如何实现 List 转 Map 后依然有序？\"},\"733\":{\"c\":[\"杂项\"]},\"734\":{\"c\":[\"工作笔记\"]},\"735\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"736\":{\"h\":\"For Offer\"},\"737\":{\"h\":\"Leetcode\"},\"738\":{\"h\":\"Note\"},\"739\":{\"h\":\"Template\"},\"740\":{\"h\":\"System Design\"},\"741\":{\"h\":\"User Center\"},\"742\":{\"h\":\"User Match\"},\"743\":{\"h\":\"Book\"},\"744\":{\"h\":\"Tool Build\"},\"745\":{\"h\":\"Hot100\"},\"746\":{\"h\":\"Mysql\"},\"747\":{\"h\":\"Database\"},\"748\":{\"h\":\"Java\"},\"749\":{\"h\":\"Language\"},\"750\":{\"h\":\"Min IO\"},\"751\":{\"h\":\"Middleware\"},\"752\":{\"h\":\"Linux\"},\"753\":{\"h\":\"Operating System\"},\"754\":{\"h\":\"源码剖析\"},\"755\":{\"h\":\"Spring Cloud\"},\"756\":{\"h\":\"Work Note\"},\"757\":{\"h\":\"Sundry\"}},\"dirtCount\":0,\"index\":[[\"工作笔记\",{\"2\":{\"734\":1}}],[\"工具类\",{\"0\":{\"652\":1}}],[\"工具类库\",{\"1\":{\"323\":1}}],[\"工具搭建\",{\"2\":{\"348\":1,\"359\":1}}],[\"杂项\",{\"2\":{\"733\":1}}],[\"监控\",{\"0\":{\"725\":1}}],[\"监控完善\",{\"1\":{\"273\":1}}],[\"抽象类\",{\"1\":{\"717\":1}}],[\"抽象为一个排队的\",{\"1\":{\"270\":1}}],[\"摘除\",{\"1\":{\"717\":1}}],[\"续约\",{\"1\":{\"717\":1}}],[\"什么时候发送这些信息呢\",{\"1\":{\"715\":1}}],[\"什么是对象存储\",{\"0\":{\"667\":1}}],[\"什么是守护进程\",{\"1\":{\"353\":1}}],[\"什么是\",{\"0\":{\"351\":1,\"356\":1}}],[\"什么是设计数据库表\",{\"0\":{\"320\":1}}],[\"什么是数据库\",{\"1\":{\"319\":1}}],[\"什么是热评\",{\"0\":{\"272\":1}}],[\"情况下\",{\"1\":{\"715\":1}}],[\"情绪\",{\"1\":{\"272\":1}}],[\"拿到\",{\"1\":{\"715\":1}}],[\"赋值给了\",{\"1\":{\"715\":1}}],[\"赋值给\",{\"1\":{\"708\":1}}],[\"赋予可执行权限\",{\"1\":{\"660\":1}}],[\"赋予执行权限\",{\"1\":{\"352\":1}}],[\"省略非核心代码\",{\"1\":{\"702\":1}}],[\"领导让我研究\",{\"0\":{\"701\":1},\"1\":{\"701\":1}}],[\"花括号是可选的\",{\"1\":{\"686\":1}}],[\"家目录路径下执行\",{\"1\":{\"680\":1}}],[\"家用电器或电子计算机\",{\"1\":{\"254\":1}}],[\"绝对路径下执行\",{\"1\":{\"680\":1}}],[\"链式编程\",{\"1\":{\"673\":1}}],[\"链表长度\",{\"1\":{\"645\":1}}],[\"链表\",{\"1\":{\"94\":1,\"645\":1}}],[\"块盘\",{\"1\":{\"668\":2}}],[\"份奇偶校验块\",{\"1\":{\"668\":1}}],[\"份数据和\",{\"1\":{\"668\":1}}],[\"码作为其纠删码算法\",{\"1\":{\"668\":1}}],[\"纠删码\",{\"1\":{\"668\":1}}],[\"兼容协议\",{\"1\":{\"668\":1}}],[\"兼容亚马逊\",{\"1\":{\"666\":1}}],[\"亚马逊云的\",{\"1\":{\"668\":1}}],[\"号称是目前速度最快的对象存储服务器\",{\"1\":{\"668\":1}}],[\"号点的判断中需要进行\",{\"1\":{\"174\":1}}],[\"企业可以快速搭建自己的内部对象存储服务\",{\"1\":{\"667\":1}}],[\"企业做项目流程\",{\"0\":{\"298\":1}}],[\"轻便\",{\"1\":{\"667\":1}}],[\"腾讯云对象存储\",{\"1\":{\"667\":1}}],[\"腾讯老干妈大瓜背后\",{\"1\":{\"274\":1}}],[\"音频形式存储的数据\",{\"1\":{\"666\":1}}],[\"音乐播放器\",{\"1\":{\"340\":1}}],[\"音乐剧\",{\"1\":{\"254\":1}}],[\"音乐制作\",{\"1\":{\"254\":1}}],[\"社交媒体文章\",{\"1\":{\"666\":1}}],[\"社区影响也大\",{\"1\":{\"272\":1}}],[\"云存储和\",{\"1\":{\"668\":1}}],[\"云存储服务接口\",{\"1\":{\"666\":1}}],[\"云原生应用程序需要更高的吞吐量和更低的延迟\",{\"1\":{\"668\":1}}],[\"云原生\",{\"1\":{\"668\":1}}],[\"云端生成外链使用\",{\"1\":{\"352\":1}}],[\"卸载服务\",{\"1\":{\"663\":1}}],[\"复制的操作包含\",{\"1\":{\"717\":1}}],[\"复制到自己指定的目录\",{\"1\":{\"663\":1}}],[\"复杂评论业务的服务编排\",{\"1\":{\"279\":1}}],[\"版的\",{\"1\":{\"662\":1}}],[\"版本为\",{\"1\":{\"345\":1}}],[\"版本\",{\"1\":{\"302\":1,\"352\":1}}],[\"版本2\",{\"0\":{\"142\":1}}],[\"版本1\",{\"0\":{\"141\":1}}],[\"拉取\",{\"1\":{\"661\":1}}],[\"拉链法\",{\"0\":{\"239\":1}}],[\"镜像\",{\"1\":{\"661\":2}}],[\"信号\",{\"1\":{\"660\":1}}],[\"信息脱敏通常应用于需要处理敏感数据的场景\",{\"1\":{\"309\":1}}],[\"信息脱敏\",{\"1\":{\"309\":1}}],[\"信息可以直接使用\",{\"1\":{\"289\":1}}],[\"官网链接\",{\"1\":{\"666\":1}}],[\"官网下载\",{\"1\":{\"659\":1}}],[\"官方团队表示\",{\"1\":{\"673\":1}}],[\"官方仓库\",{\"1\":{\"659\":1}}],[\"官方文档中提供了两种配置进程守护的方法\",{\"1\":{\"353\":1}}],[\"官方文档\",{\"1\":{\"310\":1,\"352\":1}}],[\"官方的模板生成器\",{\"1\":{\"303\":1}}],[\"入栈元素e\",{\"1\":{\"648\":1}}],[\"入度为0\",{\"1\":{\"134\":1}}],[\"入度\",{\"1\":{\"134\":1}}],[\"键\",{\"1\":{\"647\":1}}],[\"键值对以\",{\"1\":{\"647\":1}}],[\"键值对乱序\",{\"1\":{\"647\":1}}],[\"底层是通过双向链表实现的\",{\"1\":{\"645\":1}}],[\"底层是通过数组\",{\"1\":{\"645\":1}}],[\"忽略大小写进行比较\",{\"1\":{\"642\":1}}],[\"忽略警告等\",{\"1\":{\"624\":1}}],[\"系列的返回值\",{\"1\":{\"642\":1}}],[\"系统中一般默认使用\",{\"1\":{\"680\":1}}],[\"系统生成的连接地址填入\",{\"1\":{\"358\":1}}],[\"系统有很多守护进程\",{\"1\":{\"353\":1}}],[\"系统可以容忍一定的误判率\",{\"1\":{\"334\":1}}],[\"系统可以考虑自行重试\",{\"1\":{\"270\":1}}],[\"系统会使用相同的盐和用户输入的密码进行组合\",{\"1\":{\"323\":1}}],[\"系统测试\",{\"1\":{\"298\":1}}],[\"系统始终以最大化方式消费\",{\"1\":{\"282\":1}}],[\"系统的瓶颈往往就来自于存储层\",{\"1\":{\"282\":1}}],[\"系统的并发处理能力有了极大提升\",{\"1\":{\"266\":1}}],[\"系统\",{\"1\":{\"279\":1}}],[\"释放锁\",{\"1\":{\"634\":1}}],[\"休眠一个线程\",{\"1\":{\"633\":1}}],[\"元注解\",{\"0\":{\"626\":1}}],[\"元素之间用空格隔开\",{\"1\":{\"695\":1}}],[\"元素就不必实现\",{\"1\":{\"651\":1}}],[\"元素按自然顺序排序\",{\"1\":{\"646\":1}}],[\"元素乱序\",{\"1\":{\"646\":1}}],[\"元素的值均为0\",{\"1\":{\"571\":1}}],[\"元素分别是0\",{\"1\":{\"571\":1}}],[\"元素存放在下标\",{\"1\":{\"243\":4}}],[\"抑制编译器警告\",{\"1\":{\"625\":1}}],[\"限定某个函数必须重载其他函数\",{\"1\":{\"625\":1}}],[\"限定某个函数必须重写其他函数\",{\"1\":{\"625\":1}}],[\"限制该字段值不能为null\",{\"1\":{\"506\":1}}],[\"限制每个用户注销的次数\",{\"1\":{\"334\":1}}],[\"旧版中所遗留的繁冗代码和\",{\"1\":{\"624\":1}}],[\"旧字段名\",{\"1\":{\"509\":1}}],[\"局部变量\",{\"1\":{\"689\":1}}],[\"局部变量等数据信息\",{\"1\":{\"624\":1}}],[\"局部串行的生产消费方式\",{\"1\":{\"282\":1}}],[\"十一\",{\"0\":{\"630\":1}}],[\"十\",{\"0\":{\"623\":1}}],[\"十二\",{\"1\":{\"293\":1}}],[\"拒绝访问一个类的时候\",{\"1\":{\"618\":1}}],[\"线程来执行的\",{\"1\":{\"715\":2}}],[\"线程\",{\"1\":{\"702\":3}}],[\"线程没有处于请求操作所要求的适当状态时抛出的异常\",{\"1\":{\"618\":1}}],[\"线性代数方法解非齐次线性方程组\",{\"1\":{\"205\":1}}],[\"线性筛法求素数\",{\"1\":{\"210\":1}}],[\"线性筛\",{\"0\":{\"193\":1}}],[\"线性dp写法\",{\"1\":{\"121\":1}}],[\"线性dp\",{\"0\":{\"120\":1},\"2\":{\"453\":1}}],[\"环境变量改为自定义变量\",{\"1\":{\"689\":1}}],[\"环境变量\",{\"1\":{\"689\":1}}],[\"环境或\",{\"1\":{\"618\":1}}],[\"环形依赖\",{\"1\":{\"279\":1}}],[\"抛出异常\",{\"0\":{\"621\":1}}],[\"抛出的异常表明某一线程已经试图等待对象的监视器\",{\"1\":{\"618\":1}}],[\"抛出的异常表明向方法传递了一个不合法或不正确的参数\",{\"1\":{\"618\":1}}],[\"抛出该异常\",{\"1\":{\"618\":9}}],[\"抛出此类的一个实例\",{\"1\":{\"618\":1}}],[\"抛出此异常\",{\"1\":{\"618\":1}}],[\"试图将错误类型的对象存储到一个对象数组时抛出的异常\",{\"1\":{\"618\":1}}],[\"试除法求所有约数\",{\"0\":{\"195\":1}}],[\"试除法分解质因数\",{\"0\":{\"188\":1}}],[\"试除法判定质数\",{\"0\":{\"187\":1}}],[\"虚拟机\",{\"1\":{\"615\":1}}],[\"虚拟文件系统等特性实现灵活的文件管理体验\",{\"1\":{\"351\":1}}],[\"九\",{\"0\":{\"614\":1}}],[\"静态函数中只能调用静态函数\",{\"1\":{\"600\":1}}],[\"静态\",{\"1\":{\"600\":1}}],[\"源文件的名称应该和\",{\"1\":{\"599\":1}}],[\"源文件声明规则\",{\"0\":{\"599\":1}}],[\"源码剖析\",{\"0\":{\"754\":1}}],[\"源码\",{\"0\":{\"701\":1},\"1\":{\"328\":1,\"340\":1,\"701\":1}}],[\"七\",{\"0\":{\"597\":1}}],[\"七牛云\",{\"1\":{\"350\":1}}],[\"八\",{\"0\":{\"608\":1}}],[\"八大基本数据类型和\",{\"1\":{\"590\":1}}],[\"八数码\",{\"1\":{\"44\":1}}],[\"错误\",{\"1\":{\"585\":3,\"586\":1}}],[\"六\",{\"0\":{\"581\":1}}],[\"拼接字符串\",{\"1\":{\"580\":1,\"642\":1,\"643\":1}}],[\"速度较快\",{\"1\":{\"580\":1}}],[\"速度较慢\",{\"1\":{\"580\":1}}],[\"遇到含糊不清的地方\",{\"1\":{\"680\":1}}],[\"遇到回车才会停止\",{\"1\":{\"579\":1}}],[\"遇到空格不会停止输入\",{\"1\":{\"579\":1}}],[\"遇到空格\",{\"1\":{\"579\":1}}],[\"五\",{\"0\":{\"576\":1}}],[\"填充数组\",{\"1\":{\"575\":1}}],[\"填写想配置的\",{\"1\":{\"354\":1}}],[\"属性\",{\"1\":{\"624\":1}}],[\"属性length\",{\"1\":{\"575\":1}}],[\"属于非强制需要一致性考虑的\",{\"1\":{\"289\":1}}],[\"含有3个元素的数组\",{\"1\":{\"571\":2}}],[\"含最小\",{\"1\":{\"518\":1}}],[\"死循环\",{\"1\":{\"561\":1}}],[\"项\",{\"1\":{\"561\":1,\"563\":1,\"572\":1}}],[\"项目开发中\",{\"1\":{\"523\":1}}],[\"项目又封装了一次\",{\"1\":{\"328\":1}}],[\"项目\",{\"2\":{\"304\":1,\"316\":1,\"324\":1,\"332\":1,\"335\":1}}],[\"项目的方式\",{\"0\":{\"303\":1}}],[\"闰年有两种情况\",{\"1\":{\"557\":1}}],[\"练习题3\",{\"1\":{\"572\":1}}],[\"练习题2\",{\"1\":{\"572\":1}}],[\"练习题1\",{\"1\":{\"572\":1}}],[\"练习\",{\"1\":{\"557\":4,\"558\":1,\"561\":2,\"563\":2,\"567\":1}}],[\"闫学灿\",{\"1\":{\"556\":1,\"560\":1,\"568\":1,\"576\":1,\"581\":1,\"597\":1,\"614\":1}}],[\"浮点数\",{\"1\":{\"553\":1}}],[\"浮点数二分\",{\"0\":{\"145\":1}}],[\"千万条数据\",{\"1\":{\"545\":1}}],[\"占\",{\"1\":{\"545\":1}}],[\"占位符\",{\"1\":{\"518\":1}}],[\"拓展\",{\"1\":{\"545\":1}}],[\"拓扑排序\",{\"0\":{\"169\":1}}],[\"叶子节点是一个双向链表\",{\"1\":{\"545\":1}}],[\"叶子节点形成了一个双向链表\",{\"1\":{\"545\":1}}],[\"叶子节点\",{\"1\":{\"545\":2}}],[\"思维是主要的\",{\"1\":{\"560\":1}}],[\"思考\",{\"1\":{\"545\":1}}],[\"思路三\",{\"0\":{\"445\":1,\"488\":1}}],[\"思路\",{\"0\":{\"363\":1,\"365\":1,\"371\":1,\"395\":1,\"407\":1,\"413\":1,\"419\":1,\"425\":1,\"431\":1,\"437\":1,\"450\":1,\"462\":1,\"468\":1,\"474\":1,\"480\":1},\"1\":{\"81\":1,\"82\":1,\"83\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"159\":2,\"191\":1,\"200\":1,\"204\":1}}],[\"思路二\",{\"0\":{\"26\":1,\"378\":1,\"384\":1,\"390\":1,\"402\":1,\"444\":1,\"457\":1,\"487\":1}}],[\"思路一\",{\"0\":{\"25\":1,\"377\":1,\"383\":1,\"389\":1,\"401\":1,\"443\":1,\"456\":1,\"486\":1}}],[\"退化的二叉查找树\",{\"1\":{\"545\":1}}],[\"降低\",{\"1\":{\"544\":1}}],[\"降低数据排序的成本\",{\"1\":{\"544\":1}}],[\"降低数据库的\",{\"1\":{\"544\":1}}],[\"降序\",{\"1\":{\"521\":1,\"651\":1}}],[\"哪怕数据库发生异常\",{\"1\":{\"542\":1}}],[\"隔离性\",{\"1\":{\"542\":2}}],[\"撤销\",{\"1\":{\"542\":1}}],[\"失败抛出异常\",{\"1\":{\"649\":3}}],[\"失败\",{\"1\":{\"541\":1}}],[\"手动提交事务使用步骤\",{\"1\":{\"541\":1}}],[\"手动提交事务\",{\"1\":{\"541\":1}}],[\"手机号\",{\"1\":{\"507\":1,\"525\":1}}],[\"又创建了一个监听器\",{\"1\":{\"715\":1}}],[\"又实现\",{\"1\":{\"649\":1}}],[\"又称子查询\",{\"1\":{\"534\":1}}],[\"又是空节点\",{\"1\":{\"232\":1}}],[\"隐式转化\",{\"1\":{\"551\":1}}],[\"隐式内连接语法\",{\"1\":{\"531\":1}}],[\"隐式内连接\",{\"1\":{\"531\":1}}],[\"隐藏敏感信息\",{\"1\":{\"309\":2}}],[\"笛卡尔乘积是指在数学中\",{\"1\":{\"529\":1}}],[\"笛卡尔积\",{\"1\":{\"529\":1}}],[\"学习技巧\",{\"1\":{\"680\":1}}],[\"学习循环语句只需要抓住一点\",{\"1\":{\"560\":1}}],[\"学习编程语言语法是次要的\",{\"1\":{\"560\":1}}],[\"学习语言最好的方式就是实践\",{\"1\":{\"556\":1}}],[\"学生\",{\"1\":{\"598\":1}}],[\"学生与课程的关系\",{\"1\":{\"526\":1}}],[\"学生和课程的关系\",{\"1\":{\"526\":1}}],[\"学生和老师的关系\",{\"1\":{\"526\":1}}],[\"学历\",{\"1\":{\"525\":1}}],[\"身份证的有效期\",{\"1\":{\"525\":1}}],[\"身份证签发机关\",{\"1\":{\"525\":1}}],[\"身份证号\",{\"1\":{\"525\":1}}],[\"身份信息\",{\"1\":{\"525\":1}}],[\"生成该pair的哈希值\",{\"1\":{\"655\":1}}],[\"生成新的字符串\",{\"1\":{\"642\":1}}],[\"生成序列化\",{\"1\":{\"311\":1}}],[\"生日\",{\"1\":{\"525\":1}}],[\"民族\",{\"1\":{\"525\":1}}],[\"仅仅实现栈的操作\",{\"1\":{\"648\":1}}],[\"仅用于单节点数据库\",{\"1\":{\"524\":1}}],[\"仅管理员可见\",{\"1\":{\"299\":1}}],[\"影响增\",{\"1\":{\"524\":1}}],[\"影响到下一个点\",{\"1\":{\"174\":1}}],[\"缺点\",{\"1\":{\"524\":1,\"544\":1,\"629\":1}}],[\"缺口迷宫\",{\"0\":{\"57\":1},\"1\":{\"54\":1}}],[\"物理外键\",{\"1\":{\"524\":1}}],[\"物理外键和逻辑外键\",{\"1\":{\"524\":1}}],[\"传给其他服务\",{\"1\":{\"715\":1}}],[\"传给了\",{\"1\":{\"712\":1}}],[\"传给形参\",{\"1\":{\"591\":1}}],[\"传了\",{\"1\":{\"710\":1}}],[\"传参\",{\"1\":{\"646\":1}}],[\"传递的参数\",{\"1\":{\"522\":1}}],[\"传入正则表达式分隔字符串\",{\"1\":{\"642\":1}}],[\"传入比较函数\",{\"1\":{\"243\":1}}],[\"传入t的地址\",{\"1\":{\"150\":1}}],[\"聚合函数会忽略空值\",{\"1\":{\"519\":1}}],[\"聚合函数\",{\"0\":{\"519\":1},\"1\":{\"519\":1,\"520\":1}}],[\"聚合粒度\",{\"1\":{\"266\":1}}],[\"意味着可以有多个条件\",{\"1\":{\"518\":1}}],[\"意思是从\",{\"1\":{\"289\":1}}],[\"意思就是把消息都暂存在\",{\"1\":{\"282\":1}}],[\"别名2\",{\"1\":{\"517\":1,\"531\":2}}],[\"别名1\",{\"1\":{\"517\":1,\"531\":2}}],[\"别人未必会帮你好好保存\",{\"1\":{\"350\":1}}],[\"张原理图\",{\"1\":{\"702\":1}}],[\"张三\",{\"1\":{\"513\":2}}],[\"张表\",{\"1\":{\"289\":3}}],[\"姓名\",{\"1\":{\"513\":1,\"525\":1}}],[\"批量添加数据\",{\"1\":{\"512\":2}}],[\"批量查询楼中楼评论基础信息\",{\"1\":{\"263\":1}}],[\"批量查询根评论基础信息\",{\"1\":{\"263\":1}}],[\"删\",{\"1\":{\"511\":1,\"524\":1}}],[\"删除变量\",{\"0\":{\"688\":1}}],[\"删除失败会抛出异常\",{\"1\":{\"675\":1}}],[\"删除最后元素\",{\"1\":{\"645\":1}}],[\"删除最后元素为o\",{\"1\":{\"645\":1}}],[\"删除最小值\",{\"1\":{\"237\":1}}],[\"删除位于index的元素\",{\"1\":{\"645\":1}}],[\"删除关键字\",{\"1\":{\"613\":1}}],[\"删除元素\",{\"1\":{\"612\":1}}],[\"删除并返回队头\",{\"1\":{\"611\":1}}],[\"删除索引\",{\"1\":{\"546\":1}}],[\"删除数据\",{\"1\":{\"511\":1}}],[\"删除数据库\",{\"0\":{\"502\":1}}],[\"删除一张不存在的表\",{\"1\":{\"510\":1}}],[\"删除一级评论时\",{\"1\":{\"270\":1}}],[\"删除字段\",{\"1\":{\"509\":1}}],[\"删除表语法\",{\"1\":{\"510\":1}}],[\"删除表\",{\"1\":{\"503\":1}}],[\"删除操作\",{\"1\":{\"364\":1}}],[\"删除用户\",{\"0\":{\"314\":1},\"1\":{\"314\":1}}],[\"删除项目根路径下\",{\"1\":{\"302\":3}}],[\"删除项目路径下\",{\"1\":{\"302\":3}}],[\"删除对应的路由规则\",{\"1\":{\"302\":1}}],[\"删除前端路径下\",{\"1\":{\"302\":1}}],[\"删除前导0\",{\"1\":{\"148\":1,\"149\":1,\"150\":1}}],[\"删除国际化\",{\"1\":{\"302\":1}}],[\"删除等\",{\"1\":{\"279\":1}}],[\"删除等可见性状态\",{\"1\":{\"263\":1}}],[\"删除二级评论时\",{\"1\":{\"270\":1}}],[\"删除评论等\",{\"1\":{\"260\":1}}],[\"删除评论\",{\"1\":{\"255\":1,\"278\":1}}],[\"删除这个迭代器\",{\"1\":{\"242\":1}}],[\"删除所有x\",{\"1\":{\"242\":1}}],[\"删除任意一个元素\",{\"1\":{\"237\":1}}],[\"删除第k个点\",{\"1\":{\"224\":1}}],[\"删除\",{\"0\":{\"510\":1,\"514\":1},\"1\":{\"126\":1,\"255\":1,\"278\":1,\"310\":1,\"321\":1,\"498\":1,\"502\":1}}],[\"删除或替换算作一次操作\",{\"1\":{\"125\":1}}],[\"混合日期和时间值\",{\"1\":{\"507\":2}}],[\"年份值\",{\"1\":{\"507\":1}}],[\"固定长度为11\",{\"1\":{\"507\":1}}],[\"极大文本数据\",{\"1\":{\"507\":1}}],[\"极大整数值\",{\"1\":{\"507\":1}}],[\"精确定点数\",{\"1\":{\"507\":1}}],[\"精度\",{\"1\":{\"507\":2}}],[\"精选\",{\"1\":{\"255\":1}}],[\"范围为\",{\"1\":{\"653\":1}}],[\"范围遍历\",{\"1\":{\"574\":2,\"578\":1}}],[\"范围\",{\"1\":{\"507\":3}}],[\"范围开大一点防止数组越界\",{\"1\":{\"55\":1}}],[\"日志文件\",{\"1\":{\"666\":1}}],[\"日常我们在网站中看到的各种各样的分页条\",{\"1\":{\"522\":1}}],[\"日常的代理客户端\",{\"1\":{\"346\":1}}],[\"日期等\",{\"1\":{\"535\":1}}],[\"日期值\",{\"1\":{\"507\":1}}],[\"日期时间类型\",{\"1\":{\"507\":2}}],[\"案例\",{\"1\":{\"502\":1,\"509\":2,\"513\":1,\"526\":1}}],[\"切换到对应的数据库下\",{\"1\":{\"501\":1}}],[\"切换数据库\",{\"1\":{\"501\":1}}],[\"语言开发的一款高性能的分布式式存储方案的开源项目\",{\"1\":{\"668\":1}}],[\"语音mp3文件\",{\"1\":{\"666\":1}}],[\"语音数据\",{\"1\":{\"666\":1}}],[\"语法糖来打开资源\",{\"1\":{\"622\":1}}],[\"语法基础\",{\"0\":{\"550\":1}}],[\"语法如下\",{\"1\":{\"517\":1}}],[\"语法结构如下\",{\"1\":{\"516\":1}}],[\"语法\",{\"0\":{\"505\":1,\"516\":1,\"546\":1,\"679\":1},\"1\":{\"500\":1,\"501\":1,\"502\":1,\"512\":1,\"513\":1,\"514\":1,\"518\":1,\"519\":1,\"520\":1,\"521\":1,\"524\":1}}],[\"语句返回值的类型必须与函数的返回类型相同\",{\"1\":{\"594\":1}}],[\"语句都必须返回一个值\",{\"1\":{\"594\":1}}],[\"语句退出循环\",{\"1\":{\"593\":1}}],[\"语句只能用在返回类型是\",{\"1\":{\"593\":1}}],[\"语句有两种形式\",{\"1\":{\"592\":1}}],[\"语句终止当前正在执行的函数并将控制权返回到调用该函数的地方\",{\"1\":{\"592\":1}}],[\"语句负责结束\",{\"1\":{\"583\":1}}],[\"语句类似\",{\"1\":{\"566\":1}}],[\"语句搭配\",{\"1\":{\"565\":1}}],[\"语句限制性循环体后检查条件\",{\"1\":{\"562\":1}}],[\"语句非常相似\",{\"1\":{\"562\":1}}],[\"语句是判断一次\",{\"1\":{\"561\":1}}],[\"语句内部也可以是\",{\"1\":{\"557\":1}}],[\"语句提交一次事务\",{\"1\":{\"541\":1}}],[\"语句全部执行失败\",{\"1\":{\"540\":1}}],[\"语句全部执行成功\",{\"1\":{\"540\":1}}],[\"语句失败\",{\"1\":{\"540\":1}}],[\"语句给数据库执行\",{\"1\":{\"540\":1}}],[\"语句\",{\"0\":{\"557\":1,\"559\":1,\"592\":1},\"1\":{\"529\":1,\"534\":1,\"541\":1,\"557\":2,\"558\":1,\"559\":1,\"561\":1,\"593\":2,\"594\":1,\"599\":2}}],[\"语句中如果不加\",{\"1\":{\"559\":1}}],[\"语句中嵌套\",{\"1\":{\"534\":1}}],[\"语句中表的先后顺序就可以了\",{\"1\":{\"532\":1}}],[\"语句中\",{\"1\":{\"517\":1}}],[\"语句不能删除某一个字段的值\",{\"1\":{\"514\":1}}],[\"语句不区分大小写\",{\"1\":{\"495\":1}}],[\"语句的条件可以有\",{\"1\":{\"514\":1}}],[\"语句根据其功能被分为四大类\",{\"1\":{\"496\":1}}],[\"语句可以省略\",{\"1\":{\"557\":1}}],[\"语句可以使用空格\",{\"1\":{\"495\":1}}],[\"语句可以单行或多行书写\",{\"1\":{\"495\":1}}],[\"英文全称是\",{\"1\":{\"498\":1}}],[\"英语\",{\"1\":{\"14\":1}}],[\"缩进来增强语句的可读性\",{\"1\":{\"495\":1}}],[\"故使用\",{\"1\":{\"486\":1}}],[\"验证二叉搜索树\",{\"0\":{\"484\":1},\"1\":{\"484\":1}}],[\"想当然地初始化上下界为\",{\"1\":{\"486\":1}}],[\"想要学习课程\",{\"1\":{\"473\":1}}],[\"想象自己站在它的右侧\",{\"1\":{\"388\":1}}],[\"想象一下曝光数作为排序特征的变态要求\",{\"1\":{\"273\":1}}],[\"门课程\",{\"1\":{\"473\":1}}],[\"课程表\",{\"0\":{\"472\":1},\"1\":{\"472\":1}}],[\"周围\",{\"1\":{\"467\":1}}],[\"腐烂的橘子\",{\"0\":{\"466\":1},\"1\":{\"466\":1,\"467\":1}}],[\"窗口每次移动\",{\"1\":{\"456\":1}}],[\"滑动窗口\",{\"2\":{\"459\":1}}],[\"滑动窗口中的最大值\",{\"1\":{\"455\":1}}],[\"滑动窗口每次只向右移动一位\",{\"1\":{\"455\":1}}],[\"滑动窗口最大值\",{\"0\":{\"454\":1},\"1\":{\"454\":1}}],[\"往\",{\"1\":{\"445\":1}}],[\"往大了做就是评论平台\",{\"1\":{\"278\":1}}],[\"呢\",{\"1\":{\"443\":1}}],[\"水\",{\"1\":{\"442\":1}}],[\"水平\",{\"1\":{\"48\":1}}],[\"陆地\",{\"1\":{\"442\":1}}],[\"升序\",{\"1\":{\"436\":1,\"521\":1,\"651\":1}}],[\"神的写法\",{\"1\":{\"420\":1}}],[\"仍可以从剩下的盘中的数据进行恢复\",{\"1\":{\"668\":1}}],[\"仍可复用以上方法划分子树的左右子树\",{\"1\":{\"419\":1}}],[\"仍为其初始值\",{\"1\":{\"468\":1}}],[\"仍然可能会短时\",{\"1\":{\"293\":1}}],[\"仍然处于一个动态权衡取舍的过程\",{\"1\":{\"273\":1}}],[\"仍然为前闭后开\",{\"1\":{\"243\":1}}],[\"划分根节点\",{\"1\":{\"420\":1}}],[\"划分左子树范围\",{\"1\":{\"419\":1}}],[\"划分为\",{\"1\":{\"419\":2}}],[\"划分成\",{\"1\":{\"141\":1,\"142\":1}}],[\"顺便更新最大直径\",{\"1\":{\"413\":1}}],[\"顺序链表\",{\"1\":{\"645\":1}}],[\"顺序数组列表\",{\"1\":{\"645\":1}}],[\"顺序相同\",{\"1\":{\"376\":1}}],[\"顺序不会乱\",{\"1\":{\"282\":1}}],[\"百度百科中最近公共祖先的定义为\",{\"1\":{\"406\":1}}],[\"百度评论中台的设计与探索\",{\"1\":{\"274\":1}}],[\"逆序遍历\",{\"1\":{\"378\":1}}],[\"尝试直接在原来的节点上改变指向\",{\"1\":{\"378\":1}}],[\"空形参列表\",{\"1\":{\"586\":1}}],[\"空语句表示true\",{\"1\":{\"563\":1}}],[\"空语句\",{\"1\":{\"563\":1}}],[\"空间复杂度\",{\"1\":{\"377\":1}}],[\"空表示不捕获任何变量\",{\"1\":{\"75\":1}}],[\"考虑新的右子树的根节点\",{\"1\":{\"377\":1}}],[\"考虑这样一种场景\",{\"1\":{\"33\":1}}],[\"额外空间\",{\"1\":{\"376\":1}}],[\"展开的顺序其实就是二叉树的先序遍历\",{\"1\":{\"377\":1}}],[\"展开这棵树吗\",{\"1\":{\"376\":1}}],[\"展开后的单链表应该与二叉树\",{\"1\":{\"376\":1}}],[\"展开后的单链表应该同样使用\",{\"1\":{\"376\":1}}],[\"展示\",{\"1\":{\"283\":1}}],[\"至关重要\",{\"1\":{\"560\":1}}],[\"至\",{\"1\":{\"507\":5}}],[\"至多出现一次\",{\"1\":{\"370\":1}}],[\"至少有一个不在\",{\"1\":{\"451\":1}}],[\"至少包含一个\",{\"1\":{\"370\":1}}],[\"至少选中一个集合\",{\"1\":{\"212\":1}}],[\"至少需要进行多少次操作\",{\"1\":{\"126\":1}}],[\"至少需要移动多少次\",{\"1\":{\"98\":1}}],[\"应插入的位置\",{\"1\":{\"654\":1}}],[\"应该在字段的规定范围内\",{\"1\":{\"512\":1}}],[\"应该是\",{\"1\":{\"358\":1}}],[\"应用程序编程接口\",{\"1\":{\"667\":1}}],[\"应用程序试图加载类时\",{\"1\":{\"618\":1}}],[\"应用程序没有处于请求操作所要求的适当状态下\",{\"1\":{\"618\":1}}],[\"应用程序服务器中间件\",{\"1\":{\"14\":1}}],[\"应用层补偿\",{\"1\":{\"267\":1}}],[\"应用场景\",{\"1\":{\"41\":1}}],[\"盘的\",{\"1\":{\"358\":1}}],[\"映射\",{\"0\":{\"647\":1}}],[\"映射网络驱动器\",{\"1\":{\"358\":1}}],[\"映射到1\",{\"1\":{\"161\":1}}],[\"导航栏输入\",{\"1\":{\"662\":1}}],[\"导航左侧\",{\"1\":{\"357\":1}}],[\"导致数据库压力很大甚至崩溃\",{\"1\":{\"334\":1}}],[\"导致部分数据被过滤\",{\"1\":{\"270\":1}}],[\"允许应用直接访问我们的云盘内容\",{\"1\":{\"356\":1}}],[\"允许外部访问\",{\"1\":{\"352\":1}}],[\"视频数据\",{\"1\":{\"666\":1}}],[\"视频播放器等产品都支持通过\",{\"1\":{\"356\":1}}],[\"视频游戏评论\",{\"1\":{\"254\":1}}],[\"站点信息\",{\"1\":{\"354\":1}}],[\"站的评论图\",{\"1\":{\"289\":1}}],[\"站的评论系统为样本\",{\"1\":{\"277\":1}}],[\"签发速度会比较慢\",{\"1\":{\"354\":1}}],[\"勾选\",{\"1\":{\"354\":1}}],[\"免费证书\",{\"1\":{\"354\":1}}],[\"申请免费的\",{\"1\":{\"354\":1}}],[\"域名解析dns\",{\"1\":{\"354\":1}}],[\"域名加速访问\",{\"1\":{\"352\":1}}],[\"及其回溯打印到标准错误流\",{\"1\":{\"619\":1}}],[\"及其映射关系\",{\"1\":{\"237\":1}}],[\"及免费\",{\"0\":{\"354\":1}}],[\"停止服务\",{\"1\":{\"353\":1}}],[\"停用\",{\"1\":{\"321\":2}}],[\"效率较高\",{\"1\":{\"554\":1,\"555\":1}}],[\"效率较低\",{\"1\":{\"554\":1,\"555\":1}}],[\"效率很高\",{\"1\":{\"291\":1}}],[\"效果更好\",{\"1\":{\"353\":1}}],[\"推荐\",{\"1\":{\"469\":1}}],[\"推荐搭配宝塔面板使用\",{\"1\":{\"353\":1}}],[\"推荐使用宝塔面板来操作\",{\"1\":{\"345\":1}}],[\"好处是可以提供即时的交互体验和日志查看\",{\"1\":{\"353\":1}}],[\"好友点赞等\",{\"1\":{\"255\":1}}],[\"邮件服务器\",{\"1\":{\"353\":1}}],[\"邮箱\",{\"1\":{\"321\":2}}],[\"守护进程独立于任何终端会话\",{\"1\":{\"353\":1}}],[\"守护进程\",{\"1\":{\"353\":1}}],[\"守护进程干嘛的\",{\"1\":{\"353\":1}}],[\"外连接分为两种\",{\"1\":{\"532\":1}}],[\"外连接\",{\"0\":{\"532\":1},\"1\":{\"530\":1}}],[\"外键字段名\",{\"1\":{\"524\":2}}],[\"外键名称\",{\"1\":{\"524\":2}}],[\"外键约束\",{\"0\":{\"524\":1},\"1\":{\"506\":1,\"524\":1}}],[\"外链也不用改\",{\"1\":{\"352\":1}}],[\"外露子评论\",{\"1\":{\"272\":1}}],[\"魔法变量\",{\"1\":{\"352\":1}}],[\"启动的整体流程图\",{\"1\":{\"729\":1}}],[\"启动代码\",{\"1\":{\"702\":1}}],[\"启动时序图给大家画好了\",{\"1\":{\"702\":1}}],[\"启动过程\",{\"0\":{\"701\":1},\"1\":{\"701\":1,\"729\":1}}],[\"启动服务\",{\"1\":{\"353\":2}}],[\"启动后\",{\"1\":{\"352\":1,\"717\":1}}],[\"启动后如下图所示\",{\"1\":{\"352\":1}}],[\"启动\",{\"1\":{\"352\":1,\"661\":1,\"662\":1}}],[\"启发函数减小搜索空间\",{\"1\":{\"41\":1}}],[\"启发函数会影响\",{\"1\":{\"36\":1}}],[\"启发函数\",{\"0\":{\"36\":1}}],[\"配合\",{\"1\":{\"350\":1}}],[\"配置为\",{\"1\":{\"715\":1}}],[\"配置项是在\",{\"1\":{\"707\":1}}],[\"配置项\",{\"1\":{\"706\":1}}],[\"配置等\",{\"1\":{\"624\":1}}],[\"配置站点\",{\"0\":{\"354\":1}}],[\"配置站点信息\",{\"1\":{\"352\":1}}],[\"配置进程守护\",{\"0\":{\"353\":1},\"1\":{\"353\":1}}],[\"配置存储策略\",{\"1\":{\"352\":2}}],[\"配置解释\",{\"1\":{\"346\":1}}],[\"配置好宝塔后\",{\"1\":{\"345\":1}}],[\"配置方式\",{\"1\":{\"329\":1}}],[\"配置文件中的配置项是通过\",{\"1\":{\"708\":1}}],[\"配置文件\",{\"0\":{\"673\":1,\"704\":1},\"1\":{\"328\":1,\"708\":1}}],[\"配置serialversionuid\",{\"1\":{\"311\":1}}],[\"配置\",{\"0\":{\"355\":1,\"705\":1,\"714\":1},\"1\":{\"300\":1,\"663\":1,\"705\":1,\"715\":1}}],[\"供所有人访问\",{\"1\":{\"350\":1}}],[\"毫无隐私可言\",{\"1\":{\"350\":1}}],[\"继承了\",{\"1\":{\"648\":1}}],[\"继承\",{\"1\":{\"632\":1,\"717\":1}}],[\"继自建博客之后\",{\"1\":{\"350\":1}}],[\"继续上述迭代处理即可\",{\"1\":{\"384\":1}}],[\"继续down\",{\"1\":{\"237\":1}}],[\"继续枚举\",{\"1\":{\"111\":1}}],[\"继续后移\",{\"1\":{\"82\":1}}],[\"绕过大陆\",{\"1\":{\"347\":1}}],[\"路由选择\",{\"1\":{\"347\":1}}],[\"路径总和\",{\"0\":{\"478\":1},\"1\":{\"478\":1}}],[\"路径和\",{\"1\":{\"370\":1}}],[\"路径\",{\"1\":{\"370\":1,\"479\":2}}],[\"路径中至少存在两个相同的点\",{\"1\":{\"174\":1}}],[\"路径的定义是从\",{\"1\":{\"132\":1}}],[\"路径允许重复经过点或边\",{\"1\":{\"43\":1}}],[\"菜单\",{\"1\":{\"347\":1}}],[\"毕竟这个端口的安全组会阻拦\",{\"1\":{\"346\":1}}],[\"毕竟是放在别人家里\",{\"1\":{\"350\":1}}],[\"毕竟是公家的\",{\"1\":{\"350\":1}}],[\"毕竟是\",{\"1\":{\"283\":1}}],[\"扫描\",{\"1\":{\"346\":1}}],[\"扫描并封禁\",{\"1\":{\"346\":1}}],[\"国外服务器a\",{\"1\":{\"346\":1}}],[\"国内服务器b\",{\"1\":{\"346\":1,\"347\":1}}],[\"虽然你可以更换\",{\"1\":{\"346\":1}}],[\"界面\",{\"1\":{\"345\":1}}],[\"地址\",{\"1\":{\"354\":1,\"591\":1}}],[\"地址安全\",{\"1\":{\"346\":1}}],[\"地址和端口\",{\"1\":{\"345\":1}}],[\"地图上有\",{\"1\":{\"83\":1}}],[\"永久生效\",{\"1\":{\"345\":1}}],[\"永远不会被输出\",{\"1\":{\"227\":2}}],[\"香港\",{\"1\":{\"344\":1}}],[\"硅云\",{\"1\":{\"344\":1}}],[\"阿里云数字证书管理服务\",{\"1\":{\"354\":1}}],[\"阿里云\",{\"1\":{\"344\":1}}],[\"端口只允许\",{\"1\":{\"346\":1}}],[\"端口的请求全部转发给\",{\"1\":{\"346\":1}}],[\"端口点击确定\",{\"1\":{\"345\":1}}],[\"端口一般都能连接上\",{\"1\":{\"345\":1}}],[\"端口使用情况\",{\"1\":{\"345\":1}}],[\"端口信息\",{\"1\":{\"345\":1}}],[\"端口为公开\",{\"1\":{\"345\":1}}],[\"端口\",{\"1\":{\"344\":1,\"345\":2,\"346\":2,\"352\":1}}],[\"海外服务器的采购可以使用\",{\"1\":{\"344\":1}}],[\"海外服务器\",{\"1\":{\"344\":1}}],[\"准备一台\",{\"1\":{\"344\":1}}],[\"采用二叉搜索树或者是红黑树来作为索引的结构有什么问题\",{\"1\":{\"545\":1}}],[\"采用数组模拟队列的写法\",{\"1\":{\"169\":1}}],[\"采购云服务器\",{\"1\":{\"344\":1}}],[\"喜欢动手的朋友\",{\"1\":{\"343\":1}}],[\"详情可自行百度\",{\"1\":{\"350\":1}}],[\"详情\",{\"1\":{\"346\":2}}],[\"详情请自行了解\",{\"1\":{\"343\":1}}],[\"详见\",{\"1\":{\"344\":1}}],[\"详细设计\",{\"1\":{\"298\":1}}],[\"流量被盗刷事件\",{\"1\":{\"350\":1}}],[\"流量包推荐\",{\"1\":{\"343\":1}}],[\"流量热点是因为突然热门的主题\",{\"1\":{\"294\":1}}],[\"科学上网的需求也不是很高\",{\"1\":{\"347\":1}}],[\"科学上网与本地代理\",{\"0\":{\"343\":1}}],[\"科学家预测未来几十年\",{\"1\":{\"100\":1}}],[\"教程\",{\"2\":{\"341\":1,\"349\":1,\"360\":1}}],[\"冴羽\",{\"1\":{\"340\":1}}],[\"博客搭建系列\",{\"1\":{\"340\":1}}],[\"博客\",{\"1\":{\"340\":1,\"666\":1}}],[\"博弈论\",{\"0\":{\"213\":1}}],[\"搭建自己专属的对象存储服务器\",{\"1\":{\"667\":1}}],[\"搭建过程\",{\"0\":{\"352\":1}}],[\"搭建\",{\"1\":{\"340\":1,\"663\":1}}],[\"沉浸式\",{\"1\":{\"340\":1}}],[\"书籍\",{\"2\":{\"338\":1}}],[\"书评\",{\"1\":{\"254\":1}}],[\"名企面试官精讲典型编程题\",{\"1\":{\"337\":1}}],[\"约束是作用于表中字段上的\",{\"1\":{\"506\":1}}],[\"约束\",{\"0\":{\"506\":1},\"1\":{\"346\":1,\"505\":3,\"506\":1,\"509\":2}}],[\"约为\",{\"1\":{\"334\":1}}],[\"约数之和\",{\"1\":{\"196\":2}}],[\"约数个数\",{\"1\":{\"196\":1}}],[\"约数个数和约数之和\",{\"0\":{\"196\":1}}],[\"约数\",{\"0\":{\"194\":1}}],[\"约数枚举\",{\"1\":{\"189\":1}}],[\"亿\",{\"1\":{\"334\":1}}],[\"亿个用户名\",{\"1\":{\"334\":1}}],[\"期望误判率为\",{\"1\":{\"334\":1}}],[\"期望的误判率\",{\"1\":{\"334\":1}}],[\"期望能为用户带来更好的体验\",{\"1\":{\"274\":1}}],[\"万用户\",{\"1\":{\"545\":1}}],[\"万条数据\",{\"1\":{\"545\":1}}],[\"万一服务器突然宕机或停电等\",{\"1\":{\"353\":1}}],[\"万一想存点嘿嘿的东西\",{\"1\":{\"350\":1}}],[\"万\",{\"1\":{\"334\":1}}],[\"万个用户名\",{\"1\":{\"334\":1}}],[\"万能头文件\",{\"1\":{\"55\":1}}],[\"误判是可以容忍的\",{\"1\":{\"334\":1}}],[\"误判\",{\"1\":{\"334\":2}}],[\"客户端配置\",{\"1\":{\"347\":1}}],[\"客户端配置如下\",{\"1\":{\"347\":1}}],[\"客户端通常不知道代理的存在\",{\"1\":{\"329\":1}}],[\"客户端意识到代理的存在\",{\"1\":{\"329\":1}}],[\"客户端的意识\",{\"1\":{\"329\":1}}],[\"客户端据此展示新评论\",{\"1\":{\"261\":1}}],[\"怎么构造出来的呢\",{\"1\":{\"711\":1}}],[\"怎么实现代理\",{\"1\":{\"329\":1}}],[\"怎么发请求\",{\"1\":{\"328\":1}}],[\"替服务器统一接收请求\",{\"1\":{\"329\":1}}],[\"替客户端向服务器发送请求\",{\"1\":{\"329\":1}}],[\"替换占位符\",{\"1\":{\"642\":1}}],[\"替换字符串\",{\"1\":{\"578\":1}}],[\"替换字符\",{\"1\":{\"578\":1}}],[\"替换\",{\"1\":{\"126\":1}}],[\"替换掉第一个大于或等于这个数字的那个数\",{\"1\":{\"122\":1}}],[\"追踪\",{\"1\":{\"328\":1}}],[\"追求用户价值平衡\",{\"1\":{\"272\":1,\"273\":1}}],[\"封装了\",{\"1\":{\"328\":1}}],[\"封闭岛屿\",{\"1\":{\"49\":1}}],[\"封闭岛屿数量\",{\"0\":{\"49\":1}}],[\"封闭岛屿的树木\",{\"1\":{\"47\":1}}],[\"终\",{\"0\":{\"326\":1},\"1\":{\"326\":1}}],[\"终点\",{\"1\":{\"41\":1,\"43\":1}}],[\"终点的最短距离\",{\"1\":{\"41\":1}}],[\"盐值\",{\"1\":{\"323\":1}}],[\"盐值是一种用于增加密码破解难度的技术\",{\"1\":{\"323\":1}}],[\"盐值加密\",{\"1\":{\"323\":1}}],[\"软件基金会开发的一组\",{\"1\":{\"323\":1}}],[\"断言\",{\"1\":{\"322\":1}}],[\"账号时\",{\"1\":{\"357\":1}}],[\"账号并不互通\",{\"1\":{\"357\":1}}],[\"账号状态\",{\"1\":{\"321\":1}}],[\"账户不能重复\",{\"1\":{\"323\":1}}],[\"账户不包含特殊字符\",{\"1\":{\"309\":1,\"323\":1}}],[\"账户长度\",{\"1\":{\"323\":1}}],[\"账户长度不小于\",{\"1\":{\"309\":1}}],[\"账户状态\",{\"1\":{\"321\":1}}],[\"女\",{\"1\":{\"321\":1}}],[\"男\",{\"1\":{\"321\":1}}],[\"备注\",{\"1\":{\"321\":2}}],[\"备份\",{\"1\":{\"66\":1,\"111\":1}}],[\"性价比机场\",{\"1\":{\"343\":1}}],[\"性别\",{\"1\":{\"321\":2,\"525\":1}}],[\"性别是否需要加索引\",{\"1\":{\"320\":1}}],[\"性质\",{\"1\":{\"182\":1,\"227\":1}}],[\"光标放在\",{\"1\":{\"311\":1}}],[\"格式化字符串\",{\"1\":{\"578\":1,\"642\":1}}],[\"格式化输出\",{\"1\":{\"555\":1}}],[\"格式\",{\"1\":{\"507\":1,\"683\":1,\"696\":1,\"697\":1}}],[\"格式为\",{\"1\":{\"345\":1}}],[\"格式参数的话\",{\"1\":{\"311\":1}}],[\"格式的数据响应回给浏览器\",{\"1\":{\"522\":1}}],[\"格式的数据\",{\"1\":{\"308\":1}}],[\"风格\",{\"1\":{\"311\":1}}],[\"风格的\",{\"1\":{\"311\":1}}],[\"控制台的监听地址和端口\",{\"1\":{\"660\":1}}],[\"控制数据库的访问权限\",{\"1\":{\"496\":1}}],[\"控制层\",{\"1\":{\"311\":1}}],[\"控制精度\",{\"1\":{\"205\":1}}],[\"正确\",{\"1\":{\"585\":1,\"586\":1}}],[\"正数表示大于\",{\"1\":{\"578\":1}}],[\"正数左补\",{\"1\":{\"158\":1}}],[\"正向与反向代理的区别\",{\"1\":{\"329\":1}}],[\"正向代理需要客户端进行配置\",{\"1\":{\"329\":1}}],[\"正向代理主要用于客户端的访问控制和匿名性\",{\"1\":{\"329\":1}}],[\"正向代理靠近客户端\",{\"1\":{\"329\":1}}],[\"正向代理\",{\"1\":{\"329\":1}}],[\"正常来说\",{\"1\":{\"345\":1}}],[\"正常\",{\"1\":{\"310\":1,\"321\":3}}],[\"￥\",{\"1\":{\"310\":1,\"323\":1}}],[\"`~\",{\"1\":{\"310\":1,\"323\":1}}],[\"``dist\",{\"1\":{\"174\":1}}],[\"命令注册系统服务\",{\"1\":{\"663\":1}}],[\"命令执行效果如下\",{\"1\":{\"502\":1}}],[\"命令解释\",{\"1\":{\"493\":1,\"660\":2}}],[\"命令安装的\",{\"1\":{\"354\":1}}],[\"命令启动服务可以看出\",{\"1\":{\"353\":1}}],[\"命令\",{\"1\":{\"310\":1,\"353\":1,\"660\":1}}],[\"命令来执行存在性判定\",{\"1\":{\"264\":1}}],[\"匿名会话\",{\"1\":{\"310\":1}}],[\"连接信息\",{\"1\":{\"673\":1}}],[\"连接条件\",{\"1\":{\"531\":1,\"532\":2}}],[\"连接查询\",{\"1\":{\"530\":1}}],[\"连接成功后如下所示\",{\"1\":{\"358\":1}}],[\"连接\",{\"0\":{\"493\":1},\"1\":{\"357\":1}}],[\"连接服务器端后\",{\"1\":{\"310\":1}}],[\"连通图\",{\"1\":{\"182\":1}}],[\"连通这两个顶点\",{\"1\":{\"181\":1}}],[\"被唤醒啦\",{\"1\":{\"636\":1}}],[\"被所有类的对象共享\",{\"1\":{\"600\":1}}],[\"被调函数开始执行\",{\"1\":{\"584\":1}}],[\"被4整除即可\",{\"1\":{\"557\":1}}],[\"被定义为一条节点序列\",{\"1\":{\"370\":1}}],[\"被保护的敏感数据通常会被替换成某种规则定义的非敏感数据或者格\",{\"1\":{\"309\":1}}],[\"被高频次的访问\",{\"1\":{\"294\":1}}],[\"析等环境\",{\"1\":{\"309\":1}}],[\"式\",{\"1\":{\"309\":2}}],[\"校验和\",{\"1\":{\"668\":1}}],[\"校验等常用功能实现的工具类\",{\"1\":{\"323\":1}}],[\"校验密码\",{\"1\":{\"310\":1,\"311\":1,\"323\":3}}],[\"校验密码是否输入正确\",{\"1\":{\"309\":1}}],[\"校验用户的账户\",{\"1\":{\"323\":1}}],[\"校验用户的用户名\",{\"1\":{\"310\":1,\"323\":1}}],[\"校验用户账户和密码是否合法\",{\"1\":{\"309\":1}}],[\"脱敏后用户信息\",{\"1\":{\"310\":1}}],[\"脱敏\",{\"1\":{\"308\":1,\"309\":1}}],[\"密码在\",{\"1\":{\"493\":1}}],[\"密码直接以明文形式出现在命令行\",{\"1\":{\"493\":1}}],[\"密码直接在\",{\"1\":{\"493\":1}}],[\"密码则为系统所生成的密码\",{\"1\":{\"357\":1}}],[\"密码和校验密码是否相同\",{\"1\":{\"323\":1}}],[\"密码和校验密码相同\",{\"1\":{\"323\":1}}],[\"密码千万不要直接以明文存储到数据库中\",{\"1\":{\"323\":1}}],[\"密码千万不要直接明文存到数据库中\",{\"1\":{\"310\":1,\"323\":1}}],[\"密码不小于8位\",{\"1\":{\"310\":1,\"323\":1}}],[\"密码就不小于\",{\"1\":{\"309\":1}}],[\"密码\",{\"1\":{\"308\":1,\"310\":1,\"321\":2,\"323\":3}}],[\"跟着说明文档配置\",{\"1\":{\"344\":1}}],[\"跟着官网来就可以了\",{\"1\":{\"303\":1}}],[\"跟两个儿子比较大小\",{\"1\":{\"237\":1}}],[\"搜现成的代码\",{\"1\":{\"303\":1}}],[\"搜索性能会打折扣\",{\"1\":{\"545\":1}}],[\"搜索结束\",{\"1\":{\"444\":1}}],[\"搜索并将其赋值为海水\",{\"1\":{\"49\":1}}],[\"搜索\",{\"0\":{\"31\":1,\"97\":1},\"1\":{\"3\":1,\"32\":1,\"255\":1,\"278\":1,\"311\":1,\"474\":1,\"661\":1}}],[\"搜索与图论\",{\"0\":{\"164\":1},\"1\":{\"2\":1}}],[\"帮你在火狐或谷歌自动测试\",{\"1\":{\"302\":1}}],[\"帮助创建\",{\"1\":{\"641\":1}}],[\"帮助我们更科学地上网📶\",{\"1\":{\"343\":1}}],[\"帮助你管理\",{\"1\":{\"300\":1}}],[\"帮助学习\",{\"1\":{\"18\":1}}],[\"帮助用户灵活\",{\"1\":{\"14\":1}}],[\"添加到栈层次任何先前信息中\",{\"1\":{\"619\":1}}],[\"添加关键字和其对应的值\",{\"1\":{\"613\":1}}],[\"添加元素e到队尾\",{\"1\":{\"649\":1}}],[\"添加元素\",{\"1\":{\"612\":1}}],[\"添加唯一约束时\",{\"1\":{\"546\":1}}],[\"添加外键\",{\"1\":{\"524\":1}}],[\"添加数据\",{\"1\":{\"511\":1}}],[\"添加字段\",{\"1\":{\"509\":1,\"524\":1}}],[\"添加记录\",{\"1\":{\"354\":1}}],[\"添加端口规则\",{\"1\":{\"345\":1}}],[\"添加端口\",{\"1\":{\"345\":1}}],[\"添加\",{\"1\":{\"345\":1,\"347\":1,\"673\":1}}],[\"添加一条从\",{\"1\":{\"474\":1}}],[\"添加一条边a\",{\"1\":{\"165\":1}}],[\"添加一层\",{\"1\":{\"334\":1}}],[\"添加页面\",{\"1\":{\"302\":1}}],[\"移除国际化\",{\"1\":{\"302\":1}}],[\"脚本当前运行的进程id\",{\"1\":{\"693\":1}}],[\"脚本时\",{\"1\":{\"692\":1}}],[\"脚本输出\",{\"1\":{\"680\":4}}],[\"脚本示例\",{\"1\":{\"680\":1}}],[\"脚本有很多种\",{\"1\":{\"680\":1}}],[\"脚本可以直接在命令行中执行\",{\"1\":{\"680\":1}}],[\"脚本\",{\"1\":{\"302\":1}}],[\"挂了梯子以及修改了\",{\"1\":{\"302\":1}}],[\"插件\",{\"0\":{\"340\":1},\"1\":{\"322\":1,\"334\":1}}],[\"插件的构建\",{\"1\":{\"302\":1}}],[\"插入和删除快\",{\"1\":{\"645\":1}}],[\"插入的数据大小\",{\"1\":{\"512\":1}}],[\"插入的数是一个pair\",{\"1\":{\"242\":1}}],[\"插入字符串\",{\"1\":{\"425\":1}}],[\"插入数据时\",{\"1\":{\"512\":1}}],[\"插入数据\",{\"1\":{\"323\":1}}],[\"插入一个元素\",{\"1\":{\"242\":1}}],[\"插入一个数\",{\"1\":{\"237\":1,\"242\":1}}],[\"插入一个字符串\",{\"1\":{\"232\":1}}],[\"插入\",{\"1\":{\"126\":1,\"364\":1}}],[\"安装启动\",{\"0\":{\"660\":1,\"661\":1,\"662\":1}}],[\"安装与部署\",{\"0\":{\"659\":1}}],[\"安装目录\",{\"1\":{\"354\":1}}],[\"安装路径下的相对路径\",{\"1\":{\"352\":1}}],[\"安装\",{\"1\":{\"302\":1}}],[\"安装依赖完成后\",{\"1\":{\"302\":1}}],[\"安全\",{\"1\":{\"345\":1}}],[\"安全性和高可用性\",{\"1\":{\"329\":1}}],[\"安全性设计\",{\"0\":{\"268\":1}}],[\"安全中间件\",{\"1\":{\"14\":1}}],[\"文档\",{\"1\":{\"668\":1}}],[\"文档全面\",{\"1\":{\"668\":1}}],[\"文本数据\",{\"1\":{\"666\":1}}],[\"文件名\",{\"1\":{\"692\":2}}],[\"文件参数变量\",{\"0\":{\"692\":1}}],[\"文件开头需要写\",{\"1\":{\"680\":1}}],[\"文件路径\",{\"1\":{\"676\":1}}],[\"文件的管理\",{\"1\":{\"668\":1}}],[\"文件上传至\",{\"1\":{\"354\":1}}],[\"文件上传都会被扫描一遍\",{\"1\":{\"350\":1}}],[\"文件安装即可\",{\"1\":{\"347\":2}}],[\"文件进行使用了\",{\"1\":{\"347\":1}}],[\"文件中配置之后即可使用\",{\"1\":{\"334\":1}}],[\"文件\",{\"1\":{\"302\":3,\"660\":2,\"663\":1,\"676\":3,\"680\":1}}],[\"文件夹主要是和测试相关的\",{\"1\":{\"302\":1}}],[\"文件夹里面定义了一系列后台接口程序\",{\"1\":{\"302\":1}}],[\"文件夹里面定义的是一系列测试流程\",{\"1\":{\"302\":1}}],[\"文件夹的\",{\"1\":{\"302\":1}}],[\"文件夹\",{\"1\":{\"302\":5}}],[\"文章等业务下也能接入一样的评论系统\",{\"1\":{\"278\":1}}],[\"文章\",{\"1\":{\"19\":1}}],[\"执行速度慢\",{\"1\":{\"629\":1}}],[\"执行某些语句\",{\"1\":{\"557\":1}}],[\"执行sql语句\",{\"1\":{\"541\":2}}],[\"执行时机不同\",{\"1\":{\"520\":1}}],[\"执行顺序\",{\"1\":{\"520\":1}}],[\"执行将会报错\",{\"1\":{\"510\":1}}],[\"执行操作\",{\"1\":{\"328\":1}}],[\"执行具体的业务代码\",{\"1\":{\"311\":1}}],[\"执行\",{\"1\":{\"302\":1,\"662\":1,\"663\":1}}],[\"执行后进入前端框架初始化过程\",{\"1\":{\"302\":1}}],[\"执行缓存的更新操作\",{\"1\":{\"261\":1}}],[\"打印\",{\"1\":{\"567\":1}}],[\"打印到一个\",{\"1\":{\"567\":1}}],[\"打印开头下标\",{\"1\":{\"231\":1}}],[\"打开这个文件后\",{\"1\":{\"706\":1}}],[\"打开源码\",{\"1\":{\"702\":1}}],[\"打开\",{\"1\":{\"345\":1,\"346\":1}}],[\"打开终端\",{\"1\":{\"302\":2}}],[\"持久性\",{\"1\":{\"542\":2}}],[\"持久层框架\",{\"1\":{\"300\":1}}],[\"持续探索排序策略\",{\"1\":{\"274\":1}}],[\"框架封装的服务器\",{\"1\":{\"309\":1}}],[\"框架\",{\"1\":{\"300\":1}}],[\"权限校验\",{\"1\":{\"299\":1}}],[\"权重\",{\"1\":{\"181\":1}}],[\"注定注解是否出出现在\",{\"1\":{\"626\":1}}],[\"注释内容\",{\"1\":{\"495\":2}}],[\"注释内容或\",{\"1\":{\"495\":1}}],[\"注释\",{\"0\":{\"681\":1},\"1\":{\"345\":1,\"495\":1,\"509\":2}}],[\"注解的使用目的比较简单\",{\"1\":{\"624\":1}}],[\"注解不影响程序逻辑\",{\"1\":{\"624\":1}}],[\"注解与反射\",{\"0\":{\"623\":1}}],[\"注解\",{\"0\":{\"624\":1},\"1\":{\"310\":1,\"624\":1}}],[\"注册信息获取下\",{\"1\":{\"722\":1}}],[\"注册对象\",{\"0\":{\"717\":1}}],[\"注册为\",{\"1\":{\"673\":1}}],[\"注册为一个进程\",{\"1\":{\"353\":1}}],[\"注册页面\",{\"0\":{\"331\":1}}],[\"注册逻辑设计\",{\"0\":{\"323\":1}}],[\"注册时加密后的\",{\"1\":{\"309\":1}}],[\"注册校验\",{\"1\":{\"299\":1}}],[\"注册\",{\"1\":{\"299\":1,\"717\":1}}],[\"注意不是stdout\",{\"1\":{\"693\":1}}],[\"注意不能直接用==\",{\"1\":{\"578\":1}}],[\"注意不加小括号\",{\"1\":{\"575\":1}}],[\"注意需要抛异常\",{\"1\":{\"554\":1,\"555\":1}}],[\"注意余数可能为负数\",{\"1\":{\"552\":1}}],[\"注意事项\",{\"1\":{\"513\":1,\"514\":1,\"520\":1,\"521\":1,\"522\":1,\"531\":1,\"532\":1,\"546\":1}}],[\"注意是开区间\",{\"1\":{\"486\":1}}],[\"注意区间范围\",{\"1\":{\"486\":1}}],[\"注意multimap不支持此操作\",{\"1\":{\"242\":1}}],[\"注意乘除的先后顺序\",{\"1\":{\"197\":1}}],[\"注意特征\",{\"1\":{\"111\":1}}],[\"注意\",{\"1\":{\"33\":1,\"43\":2,\"83\":1,\"158\":1,\"230\":1,\"280\":1,\"302\":1,\"308\":1,\"344\":1,\"346\":1,\"353\":1,\"419\":1,\"500\":1,\"505\":1,\"506\":1,\"519\":1,\"559\":1,\"577\":1,\"663\":1}}],[\"登录页面\",{\"0\":{\"330\":1}}],[\"登录成功\",{\"1\":{\"315\":1}}],[\"登录成功后\",{\"1\":{\"310\":1}}],[\"登录接口\",{\"0\":{\"311\":1}}],[\"登录实现代码\",{\"1\":{\"310\":1}}],[\"登录名\",{\"1\":{\"310\":1}}],[\"登录逻辑\",{\"0\":{\"309\":1}}],[\"登录功能\",{\"0\":{\"307\":1}}],[\"登录\",{\"1\":{\"299\":1,\"662\":1}}],[\"部署\",{\"1\":{\"298\":1,\"300\":1}}],[\"测试端口是否能连接上\",{\"1\":{\"345\":1}}],[\"测试账号不重复\",{\"1\":{\"323\":1}}],[\"测试账户长度小于4\",{\"1\":{\"323\":1}}],[\"测试密码和校验密码不相同\",{\"1\":{\"323\":1}}],[\"测试密码小于6位\",{\"1\":{\"323\":1}}],[\"测试特殊字符\",{\"1\":{\"323\":1}}],[\"测试非空\",{\"1\":{\"323\":1}}],[\"测试出错的情况\",{\"1\":{\"323\":1}}],[\"测试注册功能\",{\"1\":{\"323\":1}}],[\"测试类如下\",{\"1\":{\"322\":1}}],[\"测试相关的配置文件\",{\"1\":{\"302\":1}}],[\"测试\",{\"1\":{\"298\":1}}],[\"引用传递\",{\"0\":{\"591\":1}}],[\"引入依赖\",{\"0\":{\"672\":1},\"1\":{\"323\":1}}],[\"引入需要的技术\",{\"1\":{\"298\":1}}],[\"引发一场评论区的狂欢\",{\"1\":{\"266\":1}}],[\"技术选型\",{\"0\":{\"300\":1},\"1\":{\"298\":1}}],[\"附加一个短时的\",{\"1\":{\"294\":1}}],[\"秒的\",{\"1\":{\"293\":2}}],[\"投递一个\",{\"1\":{\"293\":1}}],[\"投递到消息队列\",{\"1\":{\"264\":1}}],[\"跨进程的数据回源到存储层\",{\"1\":{\"293\":1}}],[\"跨机房重试\",{\"1\":{\"267\":1}}],[\"序列中每对相邻节点之间都存在一条边\",{\"1\":{\"370\":1}}],[\"序列中的数字均不超过\",{\"1\":{\"124\":1}}],[\"序列化\",{\"1\":{\"311\":2}}],[\"序列化的方式存入\",{\"1\":{\"291\":2}}],[\"耦合\",{\"1\":{\"289\":1}}],[\"自我保护机制\",{\"1\":{\"717\":1}}],[\"自己的文件系统\",{\"1\":{\"668\":1}}],[\"自然排序\",{\"1\":{\"647\":1}}],[\"自定义变量改成环境变量\",{\"1\":{\"689\":1}}],[\"自定义变量\",{\"1\":{\"689\":1}}],[\"自定义实现最小\",{\"1\":{\"651\":1}}],[\"自定义排序算法\",{\"1\":{\"651\":1}}],[\"自定义排序时\",{\"1\":{\"647\":1}}],[\"自定义异常\",{\"1\":{\"621\":1}}],[\"自减\",{\"1\":{\"553\":1}}],[\"自减运算符\",{\"1\":{\"552\":1}}],[\"自带的系统和服务管理器\",{\"1\":{\"353\":1}}],[\"自建网盘兼图床\",{\"0\":{\"350\":1}}],[\"自增运算符\",{\"1\":{\"552\":1}}],[\"自增\",{\"1\":{\"289\":1}}],[\"自动获取文件大小\",{\"1\":{\"676\":1}}],[\"自动获得\",{\"1\":{\"127\":1}}],[\"自动提交事务\",{\"1\":{\"541\":1}}],[\"自动增长\",{\"1\":{\"506\":1}}],[\"自动配置系统代理\",{\"1\":{\"347\":1}}],[\"自动转换为驼峰\",{\"1\":{\"322\":1}}],[\"自动生成器的使用\",{\"0\":{\"322\":1}}],[\"自动化测试工具\",{\"1\":{\"302\":1}}],[\"自动化策略放出\",{\"1\":{\"269\":1}}],[\"自动安装相关依赖\",{\"1\":{\"302\":1}}],[\"自动进行热点识别\",{\"1\":{\"294\":1}}],[\"自动得到右端点\",{\"1\":{\"127\":1}}],[\"索引名\",{\"1\":{\"546\":2}}],[\"索引节点大小\",{\"1\":{\"545\":1}}],[\"索引等\",{\"1\":{\"545\":1}}],[\"索引大大提高了查询效率\",{\"1\":{\"544\":1}}],[\"索引会占用存储空间\",{\"1\":{\"544\":1}}],[\"索引即数据的组织顺序\",{\"1\":{\"291\":1}}],[\"索引内容分离\",{\"1\":{\"289\":1}}],[\"索引\",{\"0\":{\"543\":1},\"1\":{\"289\":1,\"497\":1,\"544\":1,\"545\":2}}],[\"索引越多写入速度会越慢\",{\"1\":{\"283\":1}}],[\"索道上的缆车最大承重量为\",{\"1\":{\"110\":1}}],[\"概论\",{\"0\":{\"680\":1}}],[\"概述\",{\"0\":{\"528\":1,\"666\":1}}],[\"概念\",{\"1\":{\"506\":1,\"524\":2}}],[\"概念的\",{\"1\":{\"282\":1}}],[\"概要设计\",{\"1\":{\"298\":1}}],[\"概览\",{\"0\":{\"257\":1}}],[\"透穿到存储层\",{\"1\":{\"282\":1}}],[\"里实际运行一遍\",{\"1\":{\"680\":1}}],[\"里面获取到的\",{\"1\":{\"711\":1}}],[\"里面通过\",{\"1\":{\"708\":1}}],[\"里面有很多获取配置项的方法\",{\"1\":{\"708\":1}}],[\"里面的类似这样的\",{\"1\":{\"707\":1}}],[\"里面定义了很多获取配置项的方法\",{\"1\":{\"704\":1}}],[\"里面主要的操作分为六步\",{\"1\":{\"703\":1}}],[\"里面是访问策略\",{\"1\":{\"675\":1}}],[\"里面全是对应的每一个value\",{\"1\":{\"647\":1}}],[\"里面配置站点\",{\"1\":{\"354\":1}}],[\"里面各个数字有多少个\",{\"1\":{\"129\":1}}],[\"里\",{\"1\":{\"334\":1}}],[\"里查了\",{\"1\":{\"293\":1}}],[\"里查到了数据就更新这个缓存\",{\"1\":{\"293\":1}}],[\"里查询数据写缓存\",{\"1\":{\"293\":1}}],[\"里拿出对应的数据再更新到缓存里\",{\"1\":{\"281\":1}}],[\"里消费消息\",{\"1\":{\"281\":1}}],[\"触发\",{\"1\":{\"281\":1}}],[\"惊群问题\",{\"1\":{\"281\":1}}],[\"现成的管理系统\",{\"1\":{\"300\":1}}],[\"现象\",{\"1\":{\"281\":1}}],[\"现在给定一个正整数\",{\"1\":{\"128\":1}}],[\"现在请你求出\",{\"1\":{\"126\":1}}],[\"现在要将\",{\"1\":{\"126\":1}}],[\"现在又让他们研究最长公共上升子序列了\",{\"1\":{\"124\":1}}],[\"现在又多了一个\",{\"1\":{\"81\":1}}],[\"现在有一个并查集\",{\"1\":{\"94\":1}}],[\"现在有一种新型的激光炸弹\",{\"1\":{\"83\":1}}],[\"现在有若干家族图谱关系\",{\"1\":{\"93\":1}}],[\"现在\",{\"1\":{\"44\":1,\"82\":1,\"99\":1,\"101\":1}}],[\"业务逻辑执行成功做出响应\",{\"1\":{\"311\":1}}],[\"业务耦合和功能耦合在一起\",{\"1\":{\"280\":1}}],[\"业务数据模型是最为复杂的\",{\"1\":{\"258\":1}}],[\"尽量避免\",{\"1\":{\"279\":1}}],[\"尽可能保证极端情况下用户无感\",{\"1\":{\"267\":1}}],[\"梳理清楚数据的走向和逻辑\",{\"1\":{\"279\":1}}],[\"统一\",{\"1\":{\"294\":1}}],[\"统一的平台业务逻辑在\",{\"1\":{\"279\":1}}],[\"统计数量\",{\"1\":{\"519\":1}}],[\"统计从根节点到当前节点的路径上各个前缀和出现的次数\",{\"1\":{\"480\":1}}],[\"统计新鲜橘子个数\",{\"1\":{\"469\":1}}],[\"统计新鲜橘子数\",{\"1\":{\"469\":1}}],[\"统计每个\",{\"1\":{\"294\":1}}],[\"统计叶子节点\",{\"1\":{\"129\":1}}],[\"统计大于10\",{\"1\":{\"129\":1}}],[\"统计1\",{\"1\":{\"129\":1}}],[\"统计封闭岛屿的数目\",{\"1\":{\"49\":1}}],[\"订阅\",{\"1\":{\"279\":1}}],[\"他们两者之间一对一的关系\",{\"1\":{\"525\":1}}],[\"他们使用自己研发的拉链存储来组织索引\",{\"1\":{\"291\":1}}],[\"他们会共享服务层的存储层\",{\"1\":{\"279\":1}}],[\"他的下属所能获得的最大快乐值\",{\"1\":{\"134\":2}}],[\"尤其划分运营平台\",{\"1\":{\"279\":1}}],[\"尤其是热评的头部\",{\"1\":{\"274\":1}}],[\"层序遍历\",{\"0\":{\"390\":1,\"402\":1},\"1\":{\"394\":1}}],[\"层实现业务请求\",{\"1\":{\"311\":1}}],[\"层已经写好了注册和登录的业务逻辑\",{\"1\":{\"311\":1}}],[\"层是对业务逻辑的校验\",{\"1\":{\"311\":1}}],[\"层倾向于对请求参数本身的校验\",{\"1\":{\"311\":1}}],[\"层子楼层\",{\"1\":{\"289\":1}}],[\"层收敛\",{\"1\":{\"279\":1}}],[\"层\",{\"1\":{\"279\":1}}],[\"网格\",{\"1\":{\"467\":1}}],[\"网速有点慢🤣\",{\"1\":{\"347\":1}}],[\"网关层\",{\"1\":{\"279\":1}}],[\"网络吞吐的关系等\",{\"1\":{\"266\":1}}],[\"网络抖动等异常场景下的数据错乱\",{\"1\":{\"264\":1}}],[\"网络和数据库之上\",{\"1\":{\"14\":1}}],[\"真正的配置项在哪\",{\"0\":{\"707\":1}}],[\"真正编码的时间只有5\",{\"1\":{\"278\":1}}],[\"真实值\",{\"1\":{\"43\":1}}],[\"真实值+估计值\",{\"1\":{\"43\":1}}],[\"真实\",{\"1\":{\"41\":1}}],[\"真实距离\",{\"1\":{\"41\":1}}],[\"成员变量等\",{\"1\":{\"627\":1}}],[\"成员变量\",{\"1\":{\"600\":2}}],[\"成本\",{\"1\":{\"544\":1}}],[\"成功返回队首元素\",{\"1\":{\"649\":2}}],[\"成功返回true\",{\"1\":{\"649\":1}}],[\"成功\",{\"1\":{\"541\":1}}],[\"成了一个环\",{\"1\":{\"474\":1}}],[\"成为某个业务领域的专家\",{\"1\":{\"278\":1}}],[\"成立\",{\"1\":{\"68\":1,\"203\":1}}],[\"深入理解守护进程\",{\"1\":{\"353\":1}}],[\"深入到业务里面\",{\"1\":{\"278\":1}}],[\"深度优先遍历\",{\"0\":{\"167\":1}}],[\"才需要获取注册表信息\",{\"1\":{\"715\":1}}],[\"才可以使用\",{\"1\":{\"551\":1}}],[\"才会处理之前找到的节点\",{\"1\":{\"384\":1}}],[\"才能够确保队列元素整体有序\",{\"1\":{\"651\":1}}],[\"才能\",{\"1\":{\"291\":1}}],[\"才能设计出一个全面的架构\",{\"1\":{\"278\":1}}],[\"才能做出最佳的设计和抽象\",{\"1\":{\"278\":1}}],[\"才为\",{\"1\":{\"158\":1}}],[\"才为1\",{\"1\":{\"158\":1}}],[\"搞清楚系统背后的背景\",{\"1\":{\"278\":1}}],[\"参照页面原型以及需求文档设计数据库表结构\",{\"1\":{\"497\":1}}],[\"参考\",{\"1\":{\"311\":1,\"728\":1}}],[\"参考过百度的贴吧\",{\"1\":{\"291\":1}}],[\"参考资料\",{\"1\":{\"274\":1}}],[\"参数可为字符串常量\",{\"1\":{\"642\":1}}],[\"参数可以是字符串常量\",{\"1\":{\"642\":1}}],[\"参数列表必须不同\",{\"1\":{\"625\":1}}],[\"参数传递\",{\"0\":{\"589\":1}}],[\"参数之后直接指定\",{\"1\":{\"493\":1}}],[\"参数不加\",{\"1\":{\"493\":2}}],[\"参数解释\",{\"1\":{\"345\":1}}],[\"参数\",{\"1\":{\"182\":1,\"345\":1,\"693\":1}}],[\"逗乐每一个在互联网里冲浪的有缘人\",{\"1\":{\"274\":1}}],[\"致力于为中文互联网提供一个和谐\",{\"1\":{\"274\":1}}],[\"愿景与规划\",{\"0\":{\"274\":1}}],[\"微调\",{\"1\":{\"273\":1}}],[\"支撑ai模型的快速部署快速迭代\",{\"1\":{\"273\":1}}],[\"支持多线程\",{\"1\":{\"673\":1}}],[\"支持市面主流的开发语言并且可以通过\",{\"1\":{\"668\":1}}],[\"支持全面\",{\"1\":{\"668\":1}}],[\"支持从小到大或者从大到小查找\",{\"1\":{\"545\":1}}],[\"支持\",{\"1\":{\"351\":1}}],[\"支持回复楼层\",{\"1\":{\"278\":1}}],[\"支持排序策略的叠加\",{\"1\":{\"273\":1}}],[\"支持入口层切流\",{\"1\":{\"267\":1}}],[\"支持无限盖楼回复\",{\"1\":{\"255\":1}}],[\"支持比较运算\",{\"1\":{\"242\":2}}],[\"贯穿上下文\",{\"1\":{\"273\":1}}],[\"拦截了大部分低价值重排请求\",{\"1\":{\"273\":1}}],[\"活跃程度等\",{\"1\":{\"273\":1}}],[\"活动或表演\",{\"1\":{\"254\":1}}],[\"近实时大窗口聚合计数等多种性能优化手段\",{\"1\":{\"273\":1}}],[\"受限于成本并未持久化\",{\"1\":{\"273\":1}}],[\"举例\",{\"1\":{\"329\":1,\"551\":1}}],[\"举个例子\",{\"1\":{\"273\":1}}],[\"举报等\",{\"1\":{\"255\":1}}],[\"决策豁免等\",{\"1\":{\"273\":1}}],[\"决定节点的优先级\",{\"1\":{\"36\":1}}],[\"规则机执行命中后\",{\"1\":{\"273\":1}}],[\"规则机\",{\"1\":{\"273\":1}}],[\"减一\",{\"1\":{\"468\":1}}],[\"减少冗余\",{\"1\":{\"273\":1}}],[\"减枝\",{\"1\":{\"56\":1}}],[\"召回和排序两阶段都需要查询因子\",{\"1\":{\"273\":1}}],[\"召回处理中心\",{\"1\":{\"273\":1}}],[\"召回策略的工程设计\",{\"1\":{\"273\":1}}],[\"召回一批应该沉底的不良评论或者应该进前排的优秀评论\",{\"1\":{\"273\":1}}],[\"目前\",{\"1\":{\"668\":1}}],[\"目前负数没有与之对应的字符\",{\"1\":{\"577\":1}}],[\"目前形成的系统架构总体如下图所示\",{\"1\":{\"273\":1}}],[\"目标\",{\"1\":{\"451\":1}}],[\"目录下\",{\"1\":{\"354\":1}}],[\"目录\",{\"0\":{\"8\":1}}],[\"读入下一行\",{\"1\":{\"554\":1}}],[\"读入下一个双精度浮点数\",{\"1\":{\"554\":1}}],[\"读入下一个单精度浮点数\",{\"1\":{\"554\":1}}],[\"读入下一个整数\",{\"1\":{\"554\":1}}],[\"读入下一个字符串\",{\"1\":{\"554\":1}}],[\"读数据\",{\"1\":{\"289\":1}}],[\"读的核心逻辑\",{\"0\":{\"281\":1}}],[\"读写性能都受影响\",{\"1\":{\"273\":1}}],[\"读取整个数组\",{\"0\":{\"697\":1}}],[\"读取数组中某个元素的值\",{\"0\":{\"696\":1}}],[\"读取和写入字符\",{\"1\":{\"580\":1}}],[\"读取\",{\"1\":{\"269\":1,\"279\":1}}],[\"读取评论\",{\"1\":{\"255\":1,\"278\":1}}],[\"过期和状态变更\",{\"1\":{\"717\":1}}],[\"过期时间为\",{\"1\":{\"312\":1}}],[\"过大\",{\"1\":{\"273\":1}}],[\"过程如下\",{\"1\":{\"329\":1}}],[\"过程\",{\"1\":{\"94\":1}}],[\"量级非常大\",{\"1\":{\"273\":1}}],[\"曝光的数据来源是客户端上报的展现日志\",{\"1\":{\"273\":1}}],[\"曝光数使用\",{\"1\":{\"273\":1}}],[\"曝光数\",{\"1\":{\"273\":1}}],[\"新闻报道\",{\"1\":{\"666\":1}}],[\"新表名\",{\"1\":{\"509\":1}}],[\"新字段名\",{\"1\":{\"509\":1}}],[\"新数据类型\",{\"1\":{\"509\":1}}],[\"新添加一个存储策略时采用的是\",{\"1\":{\"352\":1}}],[\"新加坡\",{\"1\":{\"344\":1}}],[\"新增的\",{\"1\":{\"622\":1}}],[\"新增用户id\",{\"1\":{\"322\":1}}],[\"新增了\",{\"1\":{\"273\":2}}],[\"新建一个\",{\"1\":{\"315\":1,\"680\":1}}],[\"新建好工程\",{\"1\":{\"303\":1}}],[\"新节点的下一节点指向\",{\"1\":{\"223\":1}}],[\"预分配空间\",{\"1\":{\"396\":1}}],[\"预加载少量数据\",{\"1\":{\"291\":1}}],[\"预读\",{\"1\":{\"281\":1}}],[\"预先计算好排序分数并写入\",{\"1\":{\"273\":1}}],[\"预处理范围内的所有质数\",{\"1\":{\"210\":1}}],[\"预处理阶乘的余数和阶乘逆元的余数\",{\"1\":{\"208\":1}}],[\"预处理出\",{\"1\":{\"201\":1}}],[\"威尔逊排序\",{\"1\":{\"273\":1}}],[\"较大时查询性能特别差\",{\"1\":{\"273\":1}}],[\"较平衡\",{\"1\":{\"94\":1}}],[\"挑战与应对\",{\"0\":{\"273\":1}}],[\"商业利益\",{\"1\":{\"272\":1}}],[\"商业软件\",{\"1\":{\"254\":1}}],[\"公开的\",{\"1\":{\"345\":1}}],[\"公司战略导向\",{\"1\":{\"272\":1}}],[\"公平组合游戏icg\",{\"0\":{\"215\":1}}],[\"短文本字符串\",{\"1\":{\"507\":1}}],[\"短时间内点赞率高\",{\"1\":{\"272\":1}}],[\"短路原则\",{\"1\":{\"431\":1}}],[\"短路不存在\",{\"1\":{\"43\":1}}],[\"短路\",{\"1\":{\"43\":1}}],[\"短路的长度\",{\"1\":{\"43\":2}}],[\"咬文嚼字来说\",{\"1\":{\"272\":1}}],[\"负责建立一套热评调控体系化能力\",{\"1\":{\"273\":1}}],[\"负反馈数\",{\"1\":{\"272\":1}}],[\"负数表示小于\",{\"1\":{\"578\":1}}],[\"负数左补\",{\"1\":{\"158\":1}}],[\"负数按补码形式参加按位与运算\",{\"1\":{\"158\":1}}],[\"回车等空白字符时停止输入\",{\"1\":{\"579\":1}}],[\"回车也是一个字符\",{\"1\":{\"555\":1}}],[\"回车之后\",{\"1\":{\"493\":1}}],[\"回滚事务\",{\"1\":{\"541\":2}}],[\"回退状态\",{\"1\":{\"474\":1}}],[\"回溯返回根节点\",{\"1\":{\"420\":1}}],[\"回复数\",{\"1\":{\"272\":1}}],[\"回推路径\",{\"1\":{\"44\":1}}],[\"突出展示的产品形态\",{\"1\":{\"272\":1}}],[\"妙评\",{\"1\":{\"272\":1}}],[\"既能节省存储成本\",{\"1\":{\"667\":1}}],[\"既实现\",{\"1\":{\"649\":1}}],[\"既要能找到对应的节点\",{\"1\":{\"425\":1}}],[\"既可以将文件存储在本地\",{\"1\":{\"351\":1}}],[\"既支持传统的静态的经验算分公式\",{\"1\":{\"273\":1}}],[\"既包括类似\",{\"1\":{\"272\":1}}],[\"既有平地也有山脉\",{\"1\":{\"33\":1}}],[\"早期\",{\"1\":{\"281\":1}}],[\"早期的热评\",{\"1\":{\"272\":1}}],[\"早年间评论显示楼层号\",{\"1\":{\"261\":1}}],[\"实参数量过多\",{\"1\":{\"585\":1}}],[\"实参数量不足\",{\"1\":{\"585\":1}}],[\"实参类型不正确\",{\"1\":{\"585\":1}}],[\"实参是形参的初始值\",{\"1\":{\"585\":1}}],[\"实例上获取配置信息\",{\"1\":{\"715\":1}}],[\"实例信息传给其他服务\",{\"1\":{\"715\":1}}],[\"实例信息\",{\"1\":{\"715\":1}}],[\"实例信息管理器\",{\"1\":{\"709\":1}}],[\"实例的配置\",{\"1\":{\"710\":1}}],[\"实例化\",{\"1\":{\"646\":1,\"647\":1,\"649\":1,\"650\":1}}],[\"实例\",{\"1\":{\"552\":1,\"598\":1}}],[\"实测这种方案最为安全和稳定\",{\"1\":{\"346\":1}}],[\"实体类\",{\"1\":{\"673\":1}}],[\"实体类的\",{\"1\":{\"310\":1}}],[\"实体对象\",{\"1\":{\"322\":1}}],[\"实时性放大存储压力\",{\"1\":{\"273\":1}}],[\"实验能力等\",{\"1\":{\"273\":1}}],[\"实际上是\",{\"1\":{\"641\":1}}],[\"实际上全都是在请求国内的服务器\",{\"1\":{\"346\":1}}],[\"实际就是按照评论点赞数降序\",{\"1\":{\"272\":1}}],[\"实际也会从计数上删除其回复\",{\"1\":{\"270\":1}}],[\"实现了\",{\"1\":{\"708\":1}}],[\"实现了这些\",{\"1\":{\"707\":1}}],[\"实现了一套声明式规则语法\",{\"1\":{\"273\":1}}],[\"实现对\",{\"1\":{\"655\":1}}],[\"实现类是\",{\"1\":{\"649\":1}}],[\"实现的\",{\"1\":{\"645\":1}}],[\"实现多线程\",{\"0\":{\"632\":1}}],[\"实现关系\",{\"1\":{\"526\":1}}],[\"实现trie\",{\"1\":{\"423\":1}}],[\"实现无差别存取\",{\"1\":{\"351\":1}}],[\"实现删除用户接口\",{\"1\":{\"314\":1}}],[\"实现查询用户接口\",{\"1\":{\"313\":1}}],[\"实现接口的调用\",{\"1\":{\"311\":1}}],[\"实现序列化接口\",{\"1\":{\"311\":1}}],[\"实现业务逻辑\",{\"1\":{\"298\":1}}],[\"实现起来太复杂而且很容易出错\",{\"1\":{\"293\":1}}],[\"实现上\",{\"1\":{\"279\":1}}],[\"实现并发提效\",{\"1\":{\"273\":1}}],[\"实现\",{\"0\":{\"423\":1},\"1\":{\"261\":1,\"395\":1,\"609\":1,\"611\":1,\"612\":1,\"613\":1,\"632\":1}}],[\"实现一些简洁的操作\",{\"1\":{\"77\":1}}],[\"串行处理\",{\"1\":{\"270\":1}}],[\"串行化\",{\"1\":{\"270\":1}}],[\"串每一个特定的下标\",{\"1\":{\"231\":1}}],[\"锁加到了\",{\"1\":{\"635\":1}}],[\"锁\",{\"0\":{\"634\":1}}],[\"锁冲突\",{\"1\":{\"270\":1}}],[\"锁放大\",{\"1\":{\"270\":1}}],[\"越少越好\",{\"1\":{\"311\":1}}],[\"越容易出现\",{\"1\":{\"270\":1}}],[\"越需要加锁的场景\",{\"1\":{\"270\":1}}],[\"越界\",{\"1\":{\"49\":1}}],[\"综合评估而言\",{\"1\":{\"270\":1}}],[\"脏数据或者非常规的展示侧控制\",{\"1\":{\"270\":1}}],[\"甚至在一些数据库开发规范中\",{\"1\":{\"524\":1}}],[\"甚至无法访问\",{\"1\":{\"343\":1}}],[\"甚至可以整合端上\",{\"1\":{\"284\":1}}],[\"甚至直接忽略\",{\"1\":{\"270\":1}}],[\"甚至新功能上线\",{\"1\":{\"270\":1}}],[\"某个数据项读取失败这一类的轻量级操作\",{\"1\":{\"270\":1}}],[\"某一个操作\",{\"1\":{\"214\":1}}],[\"严格保证时序性\",{\"1\":{\"269\":1}}],[\"提取从0开始的5个字符\",{\"1\":{\"690\":1}}],[\"提取子串\",{\"1\":{\"690\":1}}],[\"提取bfs方法\",{\"1\":{\"469\":1}}],[\"提高数据查询的效率\",{\"1\":{\"544\":1}}],[\"提交事务\",{\"1\":{\"541\":2}}],[\"提示\",{\"1\":{\"291\":1,\"354\":1,\"662\":1}}],[\"提供了一个关键字\",{\"1\":{\"506\":1}}],[\"提供了以下5种约束\",{\"1\":{\"506\":1}}],[\"提供了\",{\"1\":{\"350\":1}}],[\"提供各种常用字符串\",{\"1\":{\"323\":1}}],[\"提供接口访问\",{\"1\":{\"300\":1}}],[\"提供统一的端上\",{\"1\":{\"284\":1}}],[\"提供统一化的数据检索能力\",{\"1\":{\"259\":1}}],[\"提供数据的读写接口\",{\"1\":{\"284\":1}}],[\"提升了特征读取的稳定性与性能上限\",{\"1\":{\"273\":1}}],[\"提出了较高要求\",{\"1\":{\"269\":1}}],[\"舆论安全问题更为泛化\",{\"1\":{\"270\":1}}],[\"舆论安全\",{\"0\":{\"270\":1},\"1\":{\"268\":1}}],[\"弱依赖\",{\"1\":{\"267\":1}}],[\"均支持多副本\",{\"1\":{\"267\":1}}],[\"冗余与降级\",{\"0\":{\"267\":1}}],[\"收集系统内部以及相应依赖方的一些的热点相关统计信息\",{\"1\":{\"266\":1}}],[\"感知到热点后即读取本地缓存\",{\"1\":{\"266\":1}}],[\"难以承载评论的大流量\",{\"1\":{\"266\":1}}],[\"很像\",{\"1\":{\"710\":1}}],[\"很可能拿到\",{\"1\":{\"704\":1}}],[\"很难确定是取到了null元素还是队列为空\",{\"1\":{\"649\":1}}],[\"很难找到一个完美的优化方案\",{\"1\":{\"273\":1}}],[\"很少会使用物理外键\",{\"1\":{\"524\":1}}],[\"很少修改\",{\"1\":{\"263\":1}}],[\"很有可能访问第二页\",{\"1\":{\"281\":1}}],[\"很多依赖是体量相对小的业务单元\",{\"1\":{\"266\":1}}],[\"拆分为前置和后置两部分\",{\"1\":{\"266\":1}}],[\"痛定思痛\",{\"1\":{\"266\":1}}],[\"面试题\",{\"1\":{\"520\":1,\"542\":1}}],[\"面对如此大的流量出现了严重延迟\",{\"1\":{\"266\":1}}],[\"面向业务组合的服务\",{\"1\":{\"284\":1}}],[\"面向平台\",{\"1\":{\"284\":1}}],[\"面向线上联机事务处理的\",{\"1\":{\"283\":1}}],[\"面向服务端场景\",{\"1\":{\"258\":1}}],[\"面向移动端\",{\"1\":{\"258\":1,\"279\":1}}],[\"延迟升高\",{\"1\":{\"282\":1}}],[\"延迟导致了过程不一致\",{\"1\":{\"270\":1}}],[\"延迟\",{\"1\":{\"264\":1}}],[\"刷题过程中常用\",{\"1\":{\"639\":1}}],[\"刷缓存\",{\"1\":{\"264\":1}}],[\"刷新\",{\"1\":{\"264\":1}}],[\"程序自动退出\",{\"1\":{\"633\":1}}],[\"程序就不能编译通过\",{\"1\":{\"617\":1}}],[\"程序应该从逻辑角度尽可能避免这类异常的发生\",{\"1\":{\"617\":1}}],[\"程序中可以选择捕获处理\",{\"1\":{\"617\":1}}],[\"程序中应当尽可能去处理这些异常\",{\"1\":{\"615\":1}}],[\"程序如下所示\",{\"1\":{\"583\":1}}],[\"程序\",{\"1\":{\"568\":1}}],[\"程序代替人工\",{\"1\":{\"319\":1}}],[\"程序主动写缓存和\",{\"1\":{\"264\":1}}],[\"程序人生\",{\"0\":{\"19\":1}}],[\"消耗\",{\"1\":{\"544\":1}}],[\"消耗性能\",{\"1\":{\"524\":1}}],[\"消费能力就下降\",{\"1\":{\"282\":1}}],[\"消费者顺序执行\",{\"1\":{\"264\":1}}],[\"消息直接\",{\"1\":{\"293\":1}}],[\"消息\",{\"1\":{\"293\":1}}],[\"消息队列的最大用途是\",{\"1\":{\"279\":1}}],[\"消息中间件\",{\"1\":{\"14\":1}}],[\"判定存在后\",{\"1\":{\"264\":1}}],[\"判断该pair是否和对象元素e相等\",{\"1\":{\"655\":1}}],[\"判断字符串是否为空\",{\"1\":{\"642\":1}}],[\"判断两个字符串的字典序大小\",{\"1\":{\"578\":1}}],[\"判断两个字符串是否相等\",{\"1\":{\"578\":1}}],[\"判断两个指针当前节点值是否相等\",{\"1\":{\"431\":1}}],[\"判断一个大于\",{\"1\":{\"565\":1}}],[\"判断闰年\",{\"1\":{\"557\":1,\"558\":1}}],[\"判断语句\",{\"0\":{\"556\":1}}],[\"判断区间为\",{\"1\":{\"486\":1}}],[\"判断以\",{\"1\":{\"486\":1}}],[\"判断其是否是一个有效的二叉搜索树\",{\"1\":{\"485\":1}}],[\"判断条件不同\",{\"1\":{\"520\":1}}],[\"判断条件\",{\"1\":{\"474\":1}}],[\"判断对应的两个节点是否相等\",{\"1\":{\"432\":1}}],[\"判断分析本层递归返回值的具体值\",{\"1\":{\"366\":1}}],[\"判断当前最大值的位置\",{\"1\":{\"456\":1}}],[\"判断当前深度\",{\"1\":{\"389\":1}}],[\"判断当前元素与队尾元素是否满足单调性问题\",{\"1\":{\"230\":2}}],[\"判断当前a和c是否满足条件\",{\"1\":{\"111\":1}}],[\"判断队头是否滑出窗口\",{\"1\":{\"230\":1}}],[\"判断队头是否已经滑出窗口\",{\"1\":{\"230\":1}}],[\"判断队列是否为空\",{\"1\":{\"229\":1,\"651\":1}}],[\"判断栈是否为空\",{\"1\":{\"226\":1}}],[\"判断这条边的两个顶点是否有相同的父节点\",{\"1\":{\"181\":1}}],[\"判断\",{\"1\":{\"174\":2,\"181\":1,\"365\":1,\"431\":2,\"486\":1}}],[\"判断奇偶\",{\"1\":{\"158\":1}}],[\"判断b在这一位上有没有数\",{\"1\":{\"148\":1}}],[\"判断是否要把自己注册到其他\",{\"1\":{\"715\":1}}],[\"判断是否要获取注册表信息\",{\"1\":{\"715\":1}}],[\"判断是否为空白字符串\",{\"1\":{\"642\":1}}],[\"判断是否以某个后缀结尾\",{\"1\":{\"578\":1}}],[\"判断是否以某个前缀开头\",{\"1\":{\"578\":1}}],[\"判断是否符合预期结果\",{\"1\":{\"322\":1}}],[\"判断是否全为0\",{\"1\":{\"242\":1}}],[\"判断是否至少有一个1\",{\"1\":{\"242\":1}}],[\"判断是否有\",{\"1\":{\"148\":1}}],[\"判断是否变成了目标串\",{\"1\":{\"99\":1}}],[\"判断可能的答案更新区间\",{\"1\":{\"143\":1}}],[\"判断每一位上的数字是否用过\",{\"1\":{\"111\":1}}],[\"判断能否逃出迷宫\",{\"1\":{\"55\":1}}],[\"缓存\",{\"1\":{\"334\":2}}],[\"缓存穿透\",{\"0\":{\"293\":1},\"1\":{\"334\":2}}],[\"缓存使用增量加载\",{\"1\":{\"291\":1}}],[\"缓存更多的\",{\"1\":{\"289\":1}}],[\"缓存的一致性依赖\",{\"1\":{\"264\":1}}],[\"缓存的重建\",{\"1\":{\"261\":1}}],[\"缓存设计\",{\"0\":{\"264\":1,\"291\":1}}],[\"于是利用之前学过的\",{\"1\":{\"350\":1}}],[\"于是可以去\",{\"1\":{\"311\":1}}],[\"于是在架构设计上\",{\"1\":{\"273\":1}}],[\"于是从2020年起\",{\"1\":{\"263\":1}}],[\"于是我们发现只有一个大于\",{\"1\":{\"188\":1}}],[\"产生了循环依赖\",{\"1\":{\"474\":1}}],[\"产生效果\",{\"1\":{\"36\":1}}],[\"产品上\",{\"1\":{\"289\":1}}],[\"产品侧定义是\",{\"1\":{\"263\":1}}],[\"产品形态上\",{\"1\":{\"263\":1}}],[\"审核\",{\"1\":{\"263\":1}}],[\"审核等\",{\"1\":{\"255\":1,\"278\":1}}],[\"联合主键\",{\"1\":{\"263\":1}}],[\"主调函数的执行被暂时中断\",{\"1\":{\"584\":1}}],[\"主表列名\",{\"1\":{\"524\":2}}],[\"主表\",{\"1\":{\"524\":2}}],[\"主题\",{\"1\":{\"291\":1}}],[\"主题一张表\",{\"1\":{\"290\":1}}],[\"主评论下面有子评论\",{\"1\":{\"289\":1}}],[\"主键字段\",{\"1\":{\"546\":1}}],[\"主键自增\",{\"1\":{\"506\":1}}],[\"主键是一行数据的唯一标识\",{\"1\":{\"506\":1}}],[\"主键是评论区\",{\"1\":{\"263\":1}}],[\"主键是评论\",{\"1\":{\"263\":1}}],[\"主键约束\",{\"1\":{\"506\":1}}],[\"主键\",{\"1\":{\"289\":1,\"321\":1,\"506\":1}}],[\"主键也是评论\",{\"1\":{\"263\":1}}],[\"主要为了帮助解释器识别变量边界\",{\"1\":{\"686\":1}}],[\"主要对集合进行操作\",{\"1\":{\"654\":1}}],[\"主要包含数学内的应用方法\",{\"1\":{\"653\":1}}],[\"主要包括三个阶段\",{\"1\":{\"497\":1}}],[\"主要包括各接口qps的关系\",{\"1\":{\"266\":1}}],[\"主要用来定义类中所需包含的函数\",{\"1\":{\"603\":1}}],[\"主要用来优化某些问题\",{\"1\":{\"224\":1}}],[\"主要是为了省事\",{\"1\":{\"443\":1}}],[\"主要是账号服务\",{\"1\":{\"279\":1}}],[\"主要目的\",{\"1\":{\"329\":1}}],[\"主要区别\",{\"1\":{\"329\":1}}],[\"主要就是防止信息泄露\",{\"1\":{\"309\":1}}],[\"主要存的是评论实际内容\",{\"1\":{\"289\":1}}],[\"主要存的是评论的\",{\"1\":{\"289\":1}}],[\"主要职责是维护策略所需的全部\",{\"1\":{\"273\":1}}],[\"主要有几个关键细节\",{\"1\":{\"264\":1}}],[\"主要有3项缓存\",{\"1\":{\"264\":1}}],[\"主要有两个职责\",{\"1\":{\"261\":1}}],[\"主要服务于两种调用者\",{\"1\":{\"258\":1}}],[\"主要应用\",{\"1\":{\"223\":1}}],[\"主要步骤\",{\"1\":{\"137\":1,\"138\":1}}],[\"楼中楼\",{\"1\":{\"278\":1}}],[\"楼中楼等\",{\"1\":{\"255\":1}}],[\"楼层号实际是计数器\",{\"1\":{\"261\":1}}],[\"发音类似\",{\"1\":{\"424\":1}}],[\"发现里面有几个\",{\"1\":{\"706\":1}}],[\"发现\",{\"1\":{\"378\":1}}],[\"发布上线\",{\"1\":{\"298\":1}}],[\"发布评论\",{\"1\":{\"255\":1,\"278\":1}}],[\"发送\",{\"1\":{\"293\":1}}],[\"发生缓存\",{\"1\":{\"281\":1}}],[\"发通知等\",{\"1\":{\"261\":1}}],[\"策略考量\",{\"1\":{\"261\":1}}],[\"诸如评论发布等操作\",{\"1\":{\"261\":1}}],[\"削峰处理\",{\"1\":{\"261\":1,\"279\":1}}],[\"归纳而言\",{\"1\":{\"261\":1}}],[\"归并的一般写法如下\",{\"1\":{\"138\":1}}],[\"归并\",{\"1\":{\"138\":1}}],[\"归并每次都将中点作为分界点\",{\"1\":{\"138\":1}}],[\"归并排序\",{\"0\":{\"138\":1}}],[\"做了什么\",{\"1\":{\"706\":1}}],[\"做了一层封装\",{\"1\":{\"259\":1}}],[\"做该\",{\"1\":{\"293\":1}}],[\"做主键\",{\"1\":{\"289\":2}}],[\"做架构上的补充\",{\"1\":{\"261\":1}}],[\"协同\",{\"1\":{\"261\":2}}],[\"协议的\",{\"1\":{\"667\":1}}],[\"协议的文件传输协议\",{\"1\":{\"356\":1}}],[\"协议访问\",{\"1\":{\"356\":1}}],[\"协议链接\",{\"1\":{\"344\":1}}],[\"协议\",{\"1\":{\"14\":1,\"351\":1}}],[\"布隆过滤器中二进制\",{\"1\":{\"334\":1}}],[\"布隆过滤器解决缓存穿透\",{\"1\":{\"334\":1}}],[\"布隆过滤器提供一组\",{\"1\":{\"334\":1}}],[\"布隆过滤器在项目中的使用\",{\"0\":{\"334\":1}}],[\"布隆过滤器\",{\"1\":{\"260\":1,\"334\":3},\"2\":{\"336\":1}}],[\"集群的信息\",{\"1\":{\"722\":1}}],[\"集群节点帮助类\",{\"0\":{\"719\":1}}],[\"集群可以组成联邦\",{\"1\":{\"668\":1}}],[\"集群场景\",{\"1\":{\"524\":1}}],[\"集合和\",{\"1\":{\"529\":1}}],[\"集合\",{\"0\":{\"644\":1,\"646\":1},\"1\":{\"522\":1,\"529\":1}}],[\"集合中\",{\"1\":{\"334\":1,\"522\":1}}],[\"集合数量+1\",{\"1\":{\"212\":1}}],[\"集成了多家云存储端\",{\"1\":{\"351\":1}}],[\"集成了多级缓存\",{\"1\":{\"260\":1}}],[\"集成一些其他的内容\",{\"1\":{\"300\":1}}],[\"专家模式\",{\"1\":{\"352\":1}}],[\"专注在评论数据处理\",{\"1\":{\"280\":1}}],[\"专注在评论功能的\",{\"1\":{\"279\":1}}],[\"专注于评论功能的原子化实现\",{\"1\":{\"260\":1}}],[\"专栏等内容\",{\"1\":{\"254\":1}}],[\"几乎是不二选择\",{\"1\":{\"259\":1}}],[\"几乎退化成\",{\"1\":{\"94\":1}}],[\"写速度最高可以高达\",{\"1\":{\"668\":1}}],[\"写法2\",{\"1\":{\"632\":1,\"635\":1}}],[\"写法1\",{\"1\":{\"632\":1,\"635\":1}}],[\"写法示例\",{\"1\":{\"75\":1}}],[\"写上\",{\"1\":{\"345\":1}}],[\"写代码\",{\"1\":{\"298\":1}}],[\"写\",{\"1\":{\"298\":1}}],[\"写入时可以先写评论内容表\",{\"1\":{\"290\":1}}],[\"写数据\",{\"1\":{\"289\":1}}],[\"写可以认为是\",{\"1\":{\"282\":1}}],[\"写的核心逻辑\",{\"0\":{\"282\":1}}],[\"写倾斜\",{\"1\":{\"270\":1}}],[\"写热点与读热点\",{\"0\":{\"266\":1}}],[\"写db\",{\"1\":{\"261\":1}}],[\"写后读的可靠性与实时性要求高等特征\",{\"1\":{\"259\":1}}],[\"刚需关键词检索能力\",{\"1\":{\"259\":1}}],[\"超出范围时抛出\",{\"1\":{\"618\":1}}],[\"超出地图边界\",{\"1\":{\"50\":1}}],[\"超时控制和服务限流方案\",{\"1\":{\"258\":1}}],[\"针对于数据库设计\",{\"1\":{\"497\":1}}],[\"针对于最普通的也是最常见的迷宫问题\",{\"1\":{\"54\":1}}],[\"针对双机房架构下特有的副机房数据延迟故障\",{\"1\":{\"267\":1}}],[\"针对不同依赖服务所提供的\",{\"1\":{\"258\":1}}],[\"服务的\",{\"1\":{\"714\":1}}],[\"服务中的\",{\"1\":{\"714\":1}}],[\"服务实例\",{\"1\":{\"711\":1}}],[\"服务注册的\",{\"1\":{\"710\":1}}],[\"服务配置管理器\",{\"1\":{\"710\":1}}],[\"服务进行配置和操作\",{\"1\":{\"673\":1}}],[\"服务进行降级\",{\"1\":{\"284\":1}}],[\"服务器地址和端口\",{\"1\":{\"673\":1}}],[\"服务器地点一般选择\",{\"1\":{\"344\":1}}],[\"服务器的所有正常输出\",{\"1\":{\"660\":1}}],[\"服务器ip\",{\"1\":{\"352\":1}}],[\"服务器b\",{\"1\":{\"346\":4}}],[\"服务器a\",{\"1\":{\"344\":2,\"346\":3}}],[\"服务器\",{\"1\":{\"300\":1,\"329\":2,\"347\":2,\"353\":1,\"354\":2,\"493\":2,\"660\":1,\"662\":1,\"663\":1,\"668\":1}}],[\"服务来实现\",{\"1\":{\"284\":1}}],[\"服务去\",{\"1\":{\"281\":1}}],[\"服务内部\",{\"1\":{\"281\":1}}],[\"服务\",{\"1\":{\"279\":1,\"284\":1,\"344\":1,\"660\":1,\"662\":1,\"663\":1,\"667\":2}}],[\"服务层\",{\"1\":{\"279\":2}}],[\"服务集群总qps与节点数的关系\",{\"1\":{\"266\":1}}],[\"服务编排拆分为若干个层级\",{\"1\":{\"258\":1}}],[\"服务或公司的评估\",{\"1\":{\"254\":1}}],[\"调度一次\",{\"1\":{\"715\":2}}],[\"调用的是\",{\"1\":{\"708\":1}}],[\"调用相同的函数\",{\"1\":{\"602\":1}}],[\"调用函数\",{\"0\":{\"584\":1}}],[\"调用\",{\"1\":{\"311\":1,\"722\":1}}],[\"调用关系复杂\",{\"1\":{\"258\":1}}],[\"调和级数\",{\"1\":{\"191\":1}}],[\"承载的功能模块相当之多\",{\"1\":{\"258\":1}}],[\"利用函数定义\",{\"1\":{\"463\":1}}],[\"利用给出的函数定义\",{\"1\":{\"462\":1}}],[\"利用先序遍历的代码\",{\"1\":{\"378\":1}}],[\"利用二叉搜索树的重要性质\",{\"1\":{\"363\":1}}],[\"利用\",{\"1\":{\"291\":1,\"667\":1}}],[\"利用客户端提供的布局能力\",{\"1\":{\"258\":1}}],[\"利用迭代器\",{\"1\":{\"243\":1}}],[\"广搜需要通过队列实现\",{\"1\":{\"444\":1}}],[\"广告等\",{\"1\":{\"255\":1}}],[\"广度优先搜索以广度做为优先级进行搜索\",{\"1\":{\"32\":1}}],[\"广度优先搜索\",{\"0\":{\"32\":1}}],[\"置顶\",{\"1\":{\"255\":1}}],[\"显式内连接语法\",{\"1\":{\"531\":1}}],[\"显式内连接\",{\"1\":{\"531\":1}}],[\"显示转化\",{\"1\":{\"551\":1}}],[\"显示\",{\"1\":{\"354\":1}}],[\"显示评论数\",{\"1\":{\"255\":1}}],[\"显然\",{\"1\":{\"273\":1}}],[\"显然无解\",{\"1\":{\"203\":1}}],[\"热\",{\"1\":{\"272\":1}}],[\"热评\",{\"1\":{\"273\":1,\"274\":1}}],[\"热评列表都需要能够访问到全部评论\",{\"1\":{\"273\":1}}],[\"热评开始几乎完全依赖\",{\"1\":{\"273\":1}}],[\"热评用户流量大\",{\"1\":{\"272\":1}}],[\"热评排序最关键的计算模块\",{\"1\":{\"273\":1}}],[\"热评排序涉及的特征\",{\"1\":{\"273\":1}}],[\"热评排序是全排序\",{\"1\":{\"273\":1}}],[\"热评排序的挑战点主要在于\",{\"1\":{\"273\":1}}],[\"热评排序与\",{\"1\":{\"273\":1}}],[\"热评排序逻辑一般包括点赞数\",{\"1\":{\"272\":1}}],[\"热评排序等\",{\"1\":{\"270\":1}}],[\"热评设计\",{\"0\":{\"271\":1}}],[\"热评管理\",{\"1\":{\"255\":1}}],[\"热点\",{\"0\":{\"294\":1}}],[\"热点探测的实现基于单机的滑动窗口+lfu\",{\"1\":{\"266\":1}}],[\"热点探测等性能优化手段\",{\"1\":{\"260\":1}}],[\"热点评论区发评论的tps提升了10倍以上\",{\"1\":{\"266\":1}}],[\"热度排序\",{\"1\":{\"255\":1,\"278\":1}}],[\"热题\",{\"1\":{\"5\":1}}],[\"管理后台\",{\"1\":{\"662\":1}}],[\"管理命令\",{\"1\":{\"353\":1}}],[\"管理面板\",{\"1\":{\"352\":1,\"354\":1}}],[\"管理员\",{\"1\":{\"321\":2}}],[\"管理员权限\",{\"1\":{\"315\":1}}],[\"管理员校验\",{\"1\":{\"313\":2}}],[\"管理平台\",{\"1\":{\"279\":1}}],[\"管理评论\",{\"1\":{\"255\":1,\"278\":1}}],[\"管理不断上升的系统复杂度\",{\"1\":{\"254\":1}}],[\"管理计算资源和网络通信\",{\"1\":{\"14\":1}}],[\"平均值\",{\"1\":{\"519\":1}}],[\"平均情况下\",{\"1\":{\"175\":1}}],[\"平衡树\",{\"1\":{\"612\":1,\"613\":1}}],[\"平衡二叉树\",{\"1\":{\"436\":1,\"545\":1}}],[\"平衡\",{\"1\":{\"436\":1}}],[\"平台\",{\"1\":{\"300\":1}}],[\"平台化之后增加一个评论区\",{\"1\":{\"263\":1}}],[\"平台化\",{\"1\":{\"254\":1}}],[\"形参列表中的形参通常用逗号隔开\",{\"1\":{\"586\":1}}],[\"形参和实参的类型和个数必须匹配\",{\"1\":{\"585\":1}}],[\"形参和实参\",{\"0\":{\"585\":1}}],[\"形式都更丰富\",{\"1\":{\"254\":1}}],[\"形成的路径叫交替路\",{\"1\":{\"183\":1}}],[\"播放器中直接滚动播放的弹幕\",{\"1\":{\"254\":1}}],[\"随着后期业务的拓展\",{\"1\":{\"315\":1}}],[\"随着业务不断发展\",{\"1\":{\"254\":1}}],[\"随之而来的是弹幕和评论区的各种讨论\",{\"1\":{\"254\":1}}],[\"随机打乱\",{\"1\":{\"243\":1}}],[\"舞蹈或艺术展览\",{\"1\":{\"254\":1}}],[\"戏剧\",{\"1\":{\"254\":1}}],[\"硬件\",{\"1\":{\"254\":1}}],[\"电影\",{\"1\":{\"666\":1}}],[\"电影评论\",{\"1\":{\"254\":1}}],[\"电子书\",{\"0\":{\"337\":1},\"2\":{\"339\":1}}],[\"电子游戏\",{\"1\":{\"254\":1}}],[\"电话\",{\"1\":{\"321\":2}}],[\"评论内容可以使用\",{\"1\":{\"290\":1}}],[\"评论内容表\",{\"1\":{\"289\":1}}],[\"评论索引与评论内容分开两张表来存\",{\"1\":{\"290\":1}}],[\"评论索引表和主题表用一个事务更新\",{\"1\":{\"290\":1}}],[\"评论索引表\",{\"1\":{\"289\":1}}],[\"评论总数等\",{\"1\":{\"289\":1}}],[\"评论楼层\",{\"1\":{\"289\":1}}],[\"评论主题表\",{\"1\":{\"289\":1}}],[\"评论详情页等类似场景\",{\"1\":{\"273\":1}}],[\"评论策略层\",{\"1\":{\"273\":1}}],[\"评论计数不准\",{\"1\":{\"270\":1}}],[\"评论数据合规\",{\"1\":{\"269\":1}}],[\"评论系统分为三张表\",{\"1\":{\"289\":1}}],[\"评论系统和可用性设计\",{\"0\":{\"287\":1},\"1\":{\"287\":1}}],[\"评论系统可能有的功能\",{\"1\":{\"278\":1}}],[\"评论系统功能和架构设计\",{\"0\":{\"277\":1},\"1\":{\"277\":1}}],[\"评论系统\",{\"1\":{\"278\":1},\"2\":{\"276\":1,\"286\":1,\"296\":1}}],[\"评论系统的数据安全还包括\",{\"1\":{\"269\":1}}],[\"评论系统的安全性设计可以分为\",{\"1\":{\"268\":1}}],[\"评论系统是一个同城读双活的架构\",{\"1\":{\"267\":1}}],[\"评论系统对数据库的选型要求\",{\"1\":{\"263\":1}}],[\"评论列表的业务数据模型也包含部分个性化信息\",{\"1\":{\"266\":1}}],[\"评论表的插入\",{\"1\":{\"266\":1}}],[\"评论表和评论区表的字段主要包括4种\",{\"1\":{\"263\":1}}],[\"评论回复的树形关系\",{\"1\":{\"263\":1}}],[\"评论区作为b站社区的重要组成部分\",{\"1\":{\"274\":1}}],[\"评论区评论计数的更新\",{\"1\":{\"266\":1}}],[\"评论区维度的串行\",{\"1\":{\"266\":1}}],[\"评论区的一些关键属性\",{\"1\":{\"263\":1}}],[\"评论区属性是一个整型的\",{\"1\":{\"263\":1}}],[\"评论区属性等\",{\"1\":{\"263\":1}}],[\"评论区状态是一个枚举值\",{\"1\":{\"263\":1}}],[\"评论区状态\",{\"1\":{\"263\":1}}],[\"评论需要至少两张表\",{\"1\":{\"263\":1}}],[\"评论异步处理层\",{\"1\":{\"261\":1}}],[\"评论基础服务层集成了多级缓存\",{\"1\":{\"267\":1}}],[\"评论基础服务层\",{\"1\":{\"260\":1}}],[\"评论管理服务层\",{\"1\":{\"259\":1}}],[\"评论是主体内容的外延\",{\"1\":{\"256\":1}}],[\"评论是人们对出版物\",{\"1\":{\"254\":1}}],[\"评论装扮\",{\"1\":{\"255\":1}}],[\"评论标签\",{\"1\":{\"255\":1}}],[\"评论富文本展示\",{\"1\":{\"255\":1}}],[\"评论一般还包括一些更高阶的基础功能\",{\"1\":{\"255\":1}}],[\"评论互动\",{\"1\":{\"255\":1}}],[\"评论的读热点集中在评论列表的第一页\",{\"1\":{\"266\":1}}],[\"评论的读热点也有一些典型的特征\",{\"1\":{\"266\":1}}],[\"评论的基础功能模块是相对稳定的\",{\"1\":{\"255\":1}}],[\"评论的作者还可以对作品进行内容分级以表明其相对价值\",{\"1\":{\"254\":1}}],[\"评论\",{\"1\":{\"254\":1,\"263\":3,\"274\":1}}],[\"维基百科\",{\"1\":{\"274\":1}}],[\"维基百科对\",{\"1\":{\"254\":1}}],[\"维护值和下标\",{\"1\":{\"456\":1}}],[\"维护一个\",{\"1\":{\"294\":1}}],[\"维护一个数组集合\",{\"1\":{\"237\":1}}],[\"维护一个动态数组\",{\"0\":{\"62\":1}}],[\"维护到祖宗节点距离的并查集\",{\"0\":{\"236\":1}}],[\"维护size的并查集\",{\"0\":{\"235\":1}}],[\"维护某种次序\",{\"1\":{\"160\":1}}],[\"背景\",{\"0\":{\"254\":1}}],[\"背包容量为\",{\"1\":{\"116\":1,\"117\":1,\"118\":1}}],[\"背包\",{\"0\":{\"116\":1}}],[\"背包问题常用枚举方法\",{\"1\":{\"115\":1}}],[\"背包问题\",{\"0\":{\"115\":1}}],[\"放到集合里面\",{\"1\":{\"722\":1}}],[\"放行端口的步骤\",{\"0\":{\"345\":1},\"1\":{\"344\":1}}],[\"放进去并更新右端点\",{\"1\":{\"249\":1}}],[\"放不进去则新开一组\",{\"1\":{\"249\":1}}],[\"放入\",{\"1\":{\"651\":1}}],[\"放入高位\",{\"1\":{\"147\":1}}],[\"放入优先队列中会按照代价进行排序\",{\"1\":{\"33\":1}}],[\"唯一的区别是\",{\"1\":{\"562\":1}}],[\"唯一的区别是查找第一个大于\",{\"1\":{\"243\":1}}],[\"唯一约束\",{\"1\":{\"506\":1}}],[\"唯一标识\",{\"1\":{\"321\":1}}],[\"唯一不同的在于\",{\"1\":{\"231\":1}}],[\"唯一不同的是需要计算出每次逃出迷宫的路径\",{\"1\":{\"56\":1}}],[\"圧位\",{\"1\":{\"242\":1}}],[\"增加\",{\"0\":{\"512\":1}}],[\"增加数组长度\",{\"1\":{\"334\":1}}],[\"增量追加前可能出现缓存过期\",{\"1\":{\"264\":1}}],[\"增删改查的时间复杂度是\",{\"1\":{\"242\":1}}],[\"增广矩阵\",{\"1\":{\"205\":1}}],[\"增广路\",{\"1\":{\"183\":1}}],[\"红黑树也是一棵平衡的二叉树\",{\"1\":{\"545\":1}}],[\"红黑树\",{\"1\":{\"242\":1}}],[\"弹出栈顶元素\",{\"1\":{\"242\":1,\"610\":1}}],[\"弹出堆顶元素\",{\"1\":{\"242\":1}}],[\"弹出队头元素\",{\"1\":{\"242\":1}}],[\"弹出队尾元素\",{\"1\":{\"230\":1}}],[\"默认上下文\",{\"0\":{\"720\":1},\"1\":{\"720\":1}}],[\"默认变量\",{\"0\":{\"691\":1}}],[\"默认用户名和密码都是\",{\"1\":{\"662\":1}}],[\"默认均为\",{\"1\":{\"660\":1}}],[\"默认实现小根堆\",{\"1\":{\"651\":1}}],[\"默认是小根堆\",{\"1\":{\"611\":1}}],[\"默认是大根堆\",{\"1\":{\"242\":1}}],[\"默认为\",{\"1\":{\"604\":1}}],[\"默认保留6位小数\",{\"1\":{\"555\":2}}],[\"默认\",{\"1\":{\"541\":1,\"715\":2,\"717\":1}}],[\"默认值\",{\"1\":{\"521\":1}}],[\"默认约束\",{\"1\":{\"506\":1}}],[\"默认连接的端口号是\",{\"1\":{\"493\":1}}],[\"默认连接的是本地\",{\"1\":{\"493\":1}}],[\"默认路径在\",{\"1\":{\"354\":2}}],[\"默认启动方式是前台启动\",{\"1\":{\"353\":1}}],[\"默认的下载不限速\",{\"1\":{\"352\":1}}],[\"默认会注册\",{\"1\":{\"715\":1}}],[\"默认会获取\",{\"1\":{\"715\":1}}],[\"默认会监听\",{\"1\":{\"352\":1}}],[\"默认会帮助我们查询出来没有被删的用户\",{\"1\":{\"310\":1}}],[\"默认权限\",{\"1\":{\"315\":1}}],[\"默认按元素的排序规则排序\",{\"1\":{\"651\":1}}],[\"默认按\",{\"1\":{\"242\":1}}],[\"默认染成\",{\"1\":{\"182\":1}}],[\"起始索引可以省略\",{\"1\":{\"522\":1}}],[\"起始索引从\",{\"1\":{\"522\":1}}],[\"起始索引\",{\"1\":{\"522\":2}}],[\"起始下标\",{\"1\":{\"242\":1}}],[\"起点的入度为0\",{\"1\":{\"169\":1}}],[\"起点==终点时\",{\"1\":{\"43\":1}}],[\"起点到state的真实距离\",{\"1\":{\"41\":2}}],[\"起点\",{\"1\":{\"41\":1}}],[\"清空\",{\"1\":{\"242\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1}}],[\"清零\",{\"1\":{\"158\":1}}],[\"溢出的结果就是取模的结果\",{\"1\":{\"241\":1}}],[\"核心思想\",{\"1\":{\"241\":1}}],[\"核心思路\",{\"1\":{\"193\":1}}],[\"哈希\",{\"2\":{\"422\":1,\"483\":1}}],[\"哈希函数\",{\"1\":{\"240\":1,\"334\":1}}],[\"哈希函数离散化\",{\"1\":{\"239\":1}}],[\"哈希表\",{\"0\":{\"238\":1},\"1\":{\"242\":1,\"612\":1,\"613\":1}}],[\"长文本数据\",{\"1\":{\"507\":1}}],[\"长远来看\",{\"1\":{\"289\":1}}],[\"长得非常平衡\",{\"1\":{\"237\":1}}],[\"长度不定\",{\"1\":{\"507\":1}}],[\"长度为\",{\"1\":{\"451\":1}}],[\"长度为1的区间为0\",{\"1\":{\"127\":1}}],[\"长度是\",{\"1\":{\"450\":1}}],[\"长度+左端点\",{\"1\":{\"127\":1}}],[\"长度修改为5\",{\"1\":{\"63\":1}}],[\"长度\",{\"1\":{\"63\":2,\"412\":2,\"451\":1,\"509\":3}}],[\"我做了一款vuepress的音乐可视化播放插件\",{\"1\":{\"340\":1}}],[\"我认为\",{\"1\":{\"291\":1}}],[\"我用数组记录一下你的位置\",{\"1\":{\"231\":1}}],[\"我们来细看下\",{\"1\":{\"715\":1}}],[\"我们来编写一个求阶乘的程序\",{\"1\":{\"583\":1}}],[\"我们之前说过\",{\"1\":{\"707\":1}}],[\"我们之所以需要中序遍历前\",{\"1\":{\"365\":1}}],[\"我们都要至少执行一次循环\",{\"1\":{\"562\":1}}],[\"我们都在\",{\"1\":{\"284\":1}}],[\"我们平常所说的索引\",{\"1\":{\"545\":1}}],[\"我们只需要在任意一方来添加一个外键就可以了\",{\"1\":{\"525\":1}}],[\"我们只关心\",{\"1\":{\"231\":1}}],[\"我们要避免写出死循环\",{\"1\":{\"561\":1}}],[\"我们要操作某一个数据库下的表时\",{\"1\":{\"501\":1}}],[\"我们要操作某一个数据库\",{\"1\":{\"499\":1}}],[\"我们要记录用户的登录态\",{\"1\":{\"309\":1}}],[\"我们写的递归函数\",{\"1\":{\"486\":1}}],[\"我们在插入字符串的时候将最后一个字符对应的节点的标志位置为\",{\"1\":{\"425\":1}}],[\"我们在不同阶段对热评的理解\",{\"1\":{\"273\":1}}],[\"我们如何知道找到的这部分是一个完整的字符串还是某个字符串的前缀呢\",{\"1\":{\"425\":1}}],[\"我们新建一个\",{\"1\":{\"315\":1}}],[\"我们前面讲过使用\",{\"1\":{\"291\":1}}],[\"我们一般使用\",{\"1\":{\"294\":1}}],[\"我们一开始是\",{\"1\":{\"280\":1}}],[\"我们一方面在异常情况下坚决限流熔断\",{\"1\":{\"267\":1}}],[\"我们使用了消息队列来进行逻辑异步化\",{\"1\":{\"281\":1}}],[\"我们使用\",{\"1\":{\"279\":1}}],[\"我们往小里做就是视频评论系统\",{\"1\":{\"278\":1}}],[\"我们必须要对这个系统的功能以及定位有一个清晰的了解\",{\"1\":{\"277\":1}}],[\"我们会持续优化产品功能\",{\"1\":{\"274\":1}}],[\"我们同样应用了这套热评系统\",{\"1\":{\"273\":1}}],[\"我们仍然在持续优化\",{\"1\":{\"273\":1}}],[\"我们更多依赖\",{\"1\":{\"273\":1}}],[\"我们对\",{\"1\":{\"272\":1}}],[\"我们做了重要级别划分\",{\"1\":{\"267\":1}}],[\"我们进行系统容量设计\",{\"1\":{\"266\":1}}],[\"我们利用\",{\"1\":{\"266\":1}}],[\"我们剖析瓶颈并做了如下优化\",{\"1\":{\"266\":1}}],[\"我们逐步迁移到tidb\",{\"1\":{\"263\":1}}],[\"我们采用的是mysql分表来满足这两个需求\",{\"1\":{\"263\":1}}],[\"我们的网盘服务将变得不可用\",{\"1\":{\"353\":1}}],[\"我们的查询sql可能是\",{\"1\":{\"263\":1}}],[\"我们的目的是通过交换\",{\"1\":{\"44\":1,\"99\":1}}],[\"我们基于数据库设计进行缓存设计\",{\"1\":{\"264\":1}}],[\"我们基于\",{\"1\":{\"259\":1}}],[\"我们将整个业务数据模型组装\",{\"1\":{\"258\":1}}],[\"我们将这样的一种表示称为正整数\",{\"1\":{\"128\":1}}],[\"我们关心对于每个不同的下标\",{\"1\":{\"231\":1}}],[\"我们需要找出\",{\"1\":{\"231\":1}}],[\"我们讨论的博弈问题一般都只考虑理想情况\",{\"1\":{\"214\":1}}],[\"我们把这种游戏称为nim博弈\",{\"1\":{\"214\":1}}],[\"我们就找到了目标值\",{\"1\":{\"140\":1}}],[\"我们就称这个区间\",{\"1\":{\"81\":1}}],[\"我们其实是希望\",{\"1\":{\"94\":1}}],[\"我们先将它们的父节点设为自己\",{\"1\":{\"89\":1}}],[\"我们用一个数组\",{\"1\":{\"89\":1}}],[\"我们直接用二维数组读入数据\",{\"1\":{\"83\":1}}],[\"我们可以把题目的输入转化成一幅有向图\",{\"1\":{\"474\":1}}],[\"我们可以统计初始新鲜橘子的个数\",{\"1\":{\"468\":1}}],[\"我们可以将每一个字符串存储到树中\",{\"1\":{\"425\":1}}],[\"我们可以记录每个子树的结点数\",{\"1\":{\"365\":1}}],[\"我们可以在进程内设置一个过期时间为\",{\"1\":{\"293\":1}}],[\"我们可以通过\",{\"1\":{\"81\":1}}],[\"我们可能习惯性地认为树的高度就是\",{\"1\":{\"94\":1}}],[\"我们可能未必需要最短路径\",{\"1\":{\"36\":1}}],[\"我们通常是把它当作一个结构体使用\",{\"1\":{\"77\":1}}],[\"我们不能像\",{\"1\":{\"55\":1}}],[\"我们很难确切算出距离终点还有多远\",{\"1\":{\"36\":1}}],[\"我们总会选取综合优先级最高\",{\"1\":{\"35\":1}}],[\"我们也使用一个优先队列\",{\"1\":{\"34\":1}}],[\"非结构化数据\",{\"1\":{\"666\":1}}],[\"非结构性修改\",{\"1\":{\"645\":1}}],[\"非检查性异常\",{\"1\":{\"618\":1}}],[\"非运行时异常是\",{\"1\":{\"617\":1}}],[\"非静态成员变量\",{\"1\":{\"588\":1}}],[\"非叶子节点都是由\",{\"1\":{\"545\":1}}],[\"非叶子节点\",{\"1\":{\"545\":2}}],[\"非\",{\"1\":{\"518\":1,\"558\":1}}],[\"非空返回true\",{\"1\":{\"650\":1}}],[\"非空约束\",{\"1\":{\"506\":1}}],[\"非空校验\",{\"1\":{\"310\":1,\"323\":1}}],[\"非空\",{\"1\":{\"309\":1,\"323\":1}}],[\"非常适合存储大容量的数据\",{\"1\":{\"666\":1}}],[\"非常方便使用\",{\"1\":{\"668\":1}}],[\"非常方便\",{\"1\":{\"352\":1,\"673\":1}}],[\"非常不利于迭代\",{\"1\":{\"280\":1}}],[\"非常有意思的说法是\",{\"1\":{\"231\":1}}],[\"非数据库写操作的其他业务逻辑\",{\"1\":{\"266\":1}}],[\"非匹配边\",{\"1\":{\"183\":1}}],[\"向零整除后的余数\",{\"1\":{\"552\":1}}],[\"向指定字段添加数据\",{\"1\":{\"512\":1}}],[\"向前缀树中插入字符串\",{\"1\":{\"424\":1}}],[\"向上返回结果\",{\"1\":{\"383\":1}}],[\"向导模式编辑\",{\"1\":{\"352\":1}}],[\"向数据库插入用户数据\",{\"1\":{\"323\":1}}],[\"向栈顶插入一个元素\",{\"1\":{\"242\":1}}],[\"向栈顶插入一个数\",{\"1\":{\"226\":1}}],[\"向队尾插入一个元素\",{\"1\":{\"242\":1}}],[\"向队尾插入一个数\",{\"1\":{\"229\":1}}],[\"向哈希表中插入一个数\",{\"1\":{\"239\":1}}],[\"向中间移动\",{\"1\":{\"137\":1}}],[\"普通函数中既可以调用普通函数\",{\"1\":{\"600\":1}}],[\"普通用户\",{\"1\":{\"321\":2}}],[\"普通队列\",{\"0\":{\"229\":1},\"1\":{\"648\":1}}],[\"普通栈\",{\"0\":{\"226\":1}}],[\"普通数组\",{\"1\":{\"76\":1}}],[\"双重检测\",{\"1\":{\"702\":1}}],[\"双引号字符串\",{\"1\":{\"690\":1}}],[\"双引号中的内容可以执行\",{\"1\":{\"690\":1}}],[\"双引号定义字符串\",{\"1\":{\"685\":1}}],[\"双精度浮点数值\",{\"1\":{\"507\":1}}],[\"双端队列\",{\"0\":{\"650\":1},\"1\":{\"242\":1,\"648\":1}}],[\"双链表\",{\"0\":{\"224\":1},\"1\":{\"609\":1,\"611\":1}}],[\"双指针算法\",{\"0\":{\"160\":1}}],[\"任何一个文件都可以拥有一个外链\",{\"1\":{\"352\":1}}],[\"任何一个公平组合游戏都可以转化为有向图游戏\",{\"1\":{\"216\":1}}],[\"任何一个合数都能写成几个质数相乘的形式\",{\"1\":{\"191\":1}}],[\"胜负判定也比较复杂\",{\"1\":{\"215\":1}}],[\"整合\",{\"0\":{\"671\":1}}],[\"整合统一平台测的逻辑\",{\"1\":{\"284\":1}}],[\"整理\",{\"1\":{\"639\":1}}],[\"整型变量的自增\",{\"1\":{\"553\":1}}],[\"整棵树是二叉搜索树\",{\"1\":{\"487\":1}}],[\"整个堆并不是有序的\",{\"1\":{\"651\":1}}],[\"整个评论服务还会依赖一些外部\",{\"1\":{\"279\":1}}],[\"整个数据的展示都是通过\",{\"1\":{\"279\":1}}],[\"整个有向图游戏g的sg函数值被定义为有向图游戏起点s的sg函数值\",{\"1\":{\"218\":1}}],[\"整局游戏第一个行动的称为先手\",{\"1\":{\"214\":1}}],[\"整数的加减乘除四则运算\",{\"1\":{\"553\":1}}],[\"整数分解\",{\"1\":{\"189\":1}}],[\"整数二分\",{\"0\":{\"144\":1}}],[\"留给后手都是一个必胜状态时\",{\"1\":{\"214\":1}}],[\"留给后手是一个必败状态时\",{\"1\":{\"214\":1}}],[\"必然在\",{\"1\":{\"451\":1}}],[\"必要字段\",{\"1\":{\"321\":1}}],[\"必须同名\",{\"1\":{\"663\":1}}],[\"必须实现\",{\"1\":{\"651\":1}}],[\"必须能被400整除\",{\"1\":{\"557\":1}}],[\"必须使所有的数据都保持一致状态\",{\"1\":{\"542\":1}}],[\"必须要切换到对应的数据库中\",{\"1\":{\"499\":1}}],[\"必须要判定\",{\"1\":{\"264\":1}}],[\"必须\",{\"1\":{\"473\":1}}],[\"必须鉴权\",{\"1\":{\"312\":1}}],[\"必须容量大\",{\"1\":{\"263\":1}}],[\"必须有事务\",{\"1\":{\"263\":1}}],[\"必须首先判断两个数是否相等\",{\"1\":{\"158\":1}}],[\"必败状态\",{\"1\":{\"214\":1}}],[\"必胜状态\",{\"1\":{\"214\":1}}],[\"必胜状态和必败状态\",{\"1\":{\"214\":1}}],[\"跳转语句\",{\"0\":{\"564\":1}}],[\"跳出这轮循环\",{\"1\":{\"212\":1}}],[\"跳过\",{\"1\":{\"35\":1}}],[\"根\",{\"1\":{\"377\":1}}],[\"根评论数\",{\"1\":{\"263\":1}}],[\"根节点为\",{\"1\":{\"419\":1}}],[\"根节点\",{\"1\":{\"419\":4}}],[\"根节点root\",{\"1\":{\"388\":1}}],[\"根节点小于等于左右两个子节点\",{\"1\":{\"237\":1}}],[\"根节点相同\",{\"1\":{\"25\":1}}],[\"根据计算树的高度大概是\",{\"1\":{\"545\":1}}],[\"根据子查询结果的不同分为\",{\"1\":{\"534\":1}}],[\"根据业务功能的实现\",{\"1\":{\"497\":1}}],[\"根据题意可知中序遍历得到的序列一定是升序的\",{\"1\":{\"487\":1}}],[\"根据当前字符获取对应的子节点\",{\"1\":{\"426\":1}}],[\"根据分治思想\",{\"1\":{\"419\":1}}],[\"根据中序遍历中的左\",{\"1\":{\"419\":1}}],[\"根据以上性质\",{\"1\":{\"419\":1}}],[\"根据\",{\"1\":{\"352\":1}}],[\"根据数据库表结构自动生成代码\",{\"1\":{\"322\":1}}],[\"根据评论区的评论数\",{\"1\":{\"273\":1}}],[\"根据具体问题\",{\"1\":{\"236\":1}}],[\"根据容斥原理\",{\"1\":{\"212\":1}}],[\"卡特兰数\",{\"0\":{\"211\":1}}],[\"方式2\",{\"1\":{\"554\":1,\"555\":1}}],[\"方式1\",{\"1\":{\"554\":1,\"555\":1}}],[\"方便复用\",{\"1\":{\"680\":1}}],[\"方便使用和管理数据\",{\"1\":{\"667\":1}}],[\"方便\",{\"1\":{\"289\":1}}],[\"方便统一和准入平台\",{\"1\":{\"284\":1}}],[\"方法来初始化\",{\"1\":{\"722\":1}}],[\"方法来获取\",{\"1\":{\"721\":1}}],[\"方法来获取配置信息\",{\"1\":{\"710\":1}}],[\"方法来拼接\",{\"1\":{\"641\":1}}],[\"方法时\",{\"1\":{\"708\":1}}],[\"方法会加载\",{\"1\":{\"708\":1}}],[\"方法就可以获取到配置文件中的配置项了\",{\"1\":{\"707\":1}}],[\"方法就是将这些属性放到一个\",{\"1\":{\"706\":1}}],[\"方法创建了一个\",{\"1\":{\"704\":1}}],[\"方法创建一个类的实例\",{\"1\":{\"618\":1}}],[\"方法中\",{\"1\":{\"703\":1,\"707\":1}}],[\"方法返回null时\",{\"1\":{\"649\":1}}],[\"方法也相同\",{\"1\":{\"648\":1}}],[\"方法克隆对象\",{\"1\":{\"618\":1}}],[\"方法抛出\",{\"1\":{\"618\":1}}],[\"方法\",{\"1\":{\"210\":1,\"619\":1,\"624\":1,\"703\":1,\"705\":1,\"706\":1,\"707\":2,\"708\":3,\"715\":1,\"721\":1}}],[\"方程的两边同时乘上一个非00数不改变方程的解\",{\"1\":{\"205\":1}}],[\"方程组中的系数为实数\",{\"1\":{\"205\":1}}],[\"定制排序\",{\"1\":{\"647\":1}}],[\"定长字符串\",{\"1\":{\"507\":1}}],[\"定理\",{\"1\":{\"209\":1,\"214\":1,\"219\":1}}],[\"定理求组合数\",{\"0\":{\"209\":1}}],[\"定义的默认值\",{\"1\":{\"707\":1}}],[\"定义环境变量\",{\"1\":{\"689\":1}}],[\"定义变量\",{\"0\":{\"685\":1},\"1\":{\"685\":1,\"689\":1}}],[\"定义成类\",{\"1\":{\"598\":1}}],[\"定义成小根堆的方式\",{\"1\":{\"242\":1}}],[\"定义在类中的变量为成员变量\",{\"1\":{\"588\":1}}],[\"定义外键关联另外一张表\",{\"1\":{\"524\":1}}],[\"定义操作所有关系型数据库的统一标准\",{\"1\":{\"494\":1}}],[\"定义请求的路径\",{\"1\":{\"311\":1}}],[\"定义了一个静态的私有的\",{\"1\":{\"721\":1}}],[\"定义了配置项的名称\",{\"1\":{\"708\":1}}],[\"定义了\",{\"1\":{\"322\":1}}],[\"定义了整个项目用到的一些接口\",{\"1\":{\"302\":1}}],[\"定义了优先级\",{\"1\":{\"269\":1}}],[\"定义有向图游戏g\",{\"1\":{\"219\":1}}],[\"定义sg\",{\"1\":{\"218\":1}}],[\"定义mex\",{\"1\":{\"217\":1}}],[\"定义一个小根堆\",{\"1\":{\"173\":1}}],[\"定义一个借位的情况\",{\"1\":{\"148\":1}}],[\"定义一个二维动态数组\",{\"1\":{\"62\":1}}],[\"定义区间为闭区间\",{\"1\":{\"143\":1}}],[\"定义\",{\"0\":{\"695\":1},\"1\":{\"81\":1,\"158\":2,\"451\":1,\"463\":1}}],[\"定义时初始化\",{\"1\":{\"62\":1}}],[\"定义终点坐标\",{\"1\":{\"56\":1}}],[\"定义起点坐标\",{\"1\":{\"56\":1,\"57\":1}}],[\"定义方向数组\",{\"1\":{\"48\":1,\"49\":1,\"55\":1}}],[\"定义行\",{\"1\":{\"48\":1,\"57\":1}}],[\"定义地图范围\",{\"1\":{\"48\":1,\"55\":1}}],[\"卢卡斯\",{\"0\":{\"209\":1}}],[\"乘积大于n\",{\"1\":{\"212\":1}}],[\"乘任意一个\",{\"1\":{\"208\":1}}],[\"乘法逆元\",{\"1\":{\"208\":1}}],[\"乘法逆元的定义\",{\"1\":{\"208\":1}}],[\"≡\",{\"1\":{\"208\":1}}],[\"费马小定理\",{\"1\":{\"208\":1}}],[\"∗1​=b\",{\"1\":{\"209\":1}}],[\"∗1∗b\",{\"1\":{\"209\":1}}],[\"∗b\",{\"1\":{\"209\":1}}],[\"∗infact\",{\"1\":{\"208\":2}}],[\"∗\",{\"1\":{\"208\":1,\"209\":9}}],[\"∗y\",{\"1\":{\"203\":1}}],[\"未确定阶梯型的行\",{\"1\":{\"205\":1}}],[\"未染色的点\",{\"1\":{\"182\":1}}],[\"未染色\",{\"1\":{\"182\":1}}],[\"适用于编写\",{\"1\":{\"311\":1}}],[\"适用于求解包含\",{\"1\":{\"205\":1}}],[\"适用题型\",{\"1\":{\"207\":1}}],[\"适合存放任意类型的文件\",{\"1\":{\"667\":1}}],[\"适合稀疏图\",{\"1\":{\"171\":1}}],[\"适合稠密图\",{\"1\":{\"171\":1}}],[\"阶梯型矩阵\",{\"1\":{\"205\":1}}],[\"化为\",{\"1\":{\"205\":1}}],[\"初等行\",{\"1\":{\"205\":1}}],[\"初始的烂橘子\",{\"1\":{\"469\":1}}],[\"初始为前缀树的根节点\",{\"1\":{\"425\":2}}],[\"初始将用户名的信息都初始化在布隆过滤器中\",{\"1\":{\"334\":1}}],[\"初始时队列里只有起始点\",{\"1\":{\"175\":1}}],[\"初始值\",{\"1\":{\"127\":1}}],[\"初始最坏情况下一只猫一辆车\",{\"1\":{\"110\":1}}],[\"初始高度为1\",{\"1\":{\"94\":1}}],[\"初始根节点为它自己\",{\"1\":{\"94\":1}}],[\"初始步数为0\",{\"1\":{\"56\":1,\"57\":1}}],[\"初始化方法是一个线程安全的方法\",{\"1\":{\"721\":1}}],[\"初始化注册的队列\",{\"1\":{\"717\":1}}],[\"初始化摘除的队列\",{\"1\":{\"717\":1}}],[\"初始化调度任务\",{\"1\":{\"715\":1}}],[\"初始化配置的时候还初始化了一个\",{\"1\":{\"714\":1}}],[\"初始化服务实例的配置\",{\"0\":{\"710\":1},\"1\":{\"712\":1}}],[\"初始化上下文的时序图\",{\"1\":{\"703\":1}}],[\"初始化上下文的时序图如下\",{\"1\":{\"703\":1}}],[\"初始化上下文\",{\"0\":{\"703\":1,\"718\":1,\"722\":1}}],[\"初始化环境的方法是\",{\"1\":{\"702\":1}}],[\"初始化环境和初始化上下文\",{\"1\":{\"702\":1}}],[\"初始化环境时序图\",{\"1\":{\"702\":1}}],[\"初始化环境\",{\"0\":{\"702\":1}}],[\"初始化时不需要指明数组大小\",{\"1\":{\"694\":1}}],[\"初始化时间为\",{\"1\":{\"469\":1}}],[\"初始化时间\",{\"1\":{\"468\":1}}],[\"初始化有两种\",{\"1\":{\"642\":1}}],[\"初始化前缀树对象\",{\"1\":{\"424\":1}}],[\"初始化项目\",{\"0\":{\"301\":1}}],[\"初始化find\",{\"1\":{\"236\":1}}],[\"初始化各个顶点在不同的集合中\",{\"1\":{\"181\":1}}],[\"初始化大于1的区间为最大\",{\"1\":{\"127\":1}}],[\"初始化父亲为它自己\",{\"1\":{\"93\":1}}],[\"初始化为它自身\",{\"1\":{\"237\":1}}],[\"初始化为\",{\"1\":{\"75\":1}}],[\"初始化输入数据\",{\"1\":{\"55\":1}}],[\"初始化岛屿数量为0\",{\"1\":{\"48\":1,\"49\":1}}],[\"初始化数组元素为\",{\"1\":{\"48\":1}}],[\"初始化小根堆\",{\"1\":{\"44\":1}}],[\"初始化\",{\"0\":{\"89\":1,\"713\":1,\"714\":1,\"715\":1},\"1\":{\"35\":1,\"57\":1,\"81\":1,\"87\":1,\"94\":2,\"137\":1,\"165\":1,\"178\":1,\"223\":1,\"224\":1,\"234\":1,\"235\":1,\"236\":1,\"241\":1,\"298\":1,\"425\":1,\"445\":1,\"451\":1,\"578\":1,\"580\":1,\"714\":1,\"717\":1}}],[\"扩展欧几里得\",{\"1\":{\"204\":1}}],[\"扩展欧几里得算法\",{\"0\":{\"202\":1}}],[\"∀i∈\",{\"1\":{\"204\":1}}],[\"事情的初衷\",{\"1\":{\"278\":1}}],[\"事务的四大特性简称为\",{\"1\":{\"542\":1}}],[\"事务一旦提交或回滚\",{\"1\":{\"542\":1}}],[\"事务完成时\",{\"1\":{\"542\":1}}],[\"事务是不可分割的最小单元\",{\"1\":{\"542\":1}}],[\"事务是一组操作的集合\",{\"1\":{\"540\":1}}],[\"事务有哪些特性\",{\"1\":{\"542\":1}}],[\"事务中的操作要么全部成功\",{\"1\":{\"542\":1}}],[\"事务中间件\",{\"1\":{\"14\":1}}],[\"事务操作有关的\",{\"1\":{\"541\":1}}],[\"事务作用\",{\"1\":{\"540\":1}}],[\"事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求\",{\"1\":{\"540\":1}}],[\"事务\",{\"0\":{\"539\":1}}],[\"事务更新\",{\"1\":{\"289\":1}}],[\"事务加锁\",{\"1\":{\"270\":1}}],[\"事实上\",{\"1\":{\"203\":1}}],[\"=1\",{\"1\":{\"203\":1}}],[\"−231\",{\"1\":{\"486\":1}}],[\"−\",{\"1\":{\"203\":1,\"365\":5,\"480\":1}}],[\"−10000⩽ai​⩽10000\",{\"1\":{\"82\":1}}],[\"−1\",{\"1\":{\"43\":1,\"57\":1,\"99\":1,\"468\":2}}],[\"$$\",{\"1\":{\"693\":1}}],[\"$4\",{\"1\":{\"692\":1,\"693\":2}}],[\"$3\",{\"1\":{\"692\":1,\"693\":2}}],[\"$0\",{\"1\":{\"692\":2}}],[\"$2\",{\"1\":{\"692\":2,\"693\":2}}],[\"$1\",{\"1\":{\"692\":2,\"693\":2}}],[\"$name\",{\"1\":{\"686\":1,\"688\":1,\"690\":3}}],[\"$http\",{\"1\":{\"354\":1}}],[\"$proxy\",{\"1\":{\"354\":1}}],[\"$\",{\"1\":{\"203\":1,\"310\":1,\"323\":1,\"685\":1,\"686\":4,\"690\":2,\"693\":5,\"696\":5,\"697\":4,\"698\":4}}],[\"$gcd\",{\"1\":{\"203\":1}}],[\"​=\",{\"1\":{\"209\":1}}],[\"​=a\",{\"1\":{\"208\":1}}],[\"​\",{\"1\":{\"203\":2,\"208\":1,\"209\":1,\"558\":3}}],[\"​​\",{\"1\":{\"82\":1}}],[\"倍增的思想\",{\"1\":{\"242\":1}}],[\"倍\",{\"1\":{\"200\":2}}],[\"倍区间的数目\",{\"1\":{\"81\":1}}],[\"倍区间吗\",{\"1\":{\"81\":1}}],[\"倍区间\",{\"1\":{\"81\":1}}],[\"修饰其他注解的注解\",{\"1\":{\"626\":1}}],[\"修饰符包括\",{\"1\":{\"583\":1}}],[\"修饰符\",{\"1\":{\"582\":1,\"600\":1}}],[\"修改后\",{\"1\":{\"702\":1}}],[\"修改语句的条件可以有\",{\"1\":{\"513\":1}}],[\"修改数据\",{\"1\":{\"511\":1}}],[\"修改数据类型\",{\"1\":{\"509\":1}}],[\"修改表名\",{\"1\":{\"509\":1}}],[\"修改表的时候添加约束\",{\"1\":{\"506\":1}}],[\"修改表\",{\"1\":{\"503\":1}}],[\"修改\",{\"0\":{\"509\":1,\"513\":1},\"1\":{\"346\":1,\"509\":1}}],[\"修改任意一个元素\",{\"1\":{\"237\":1}}],[\"修改字符串的长度\",{\"1\":{\"63\":1}}],[\"修正为\",{\"1\":{\"200\":2}}],[\"互质时\",{\"1\":{\"208\":1}}],[\"互质\",{\"1\":{\"200\":1,\"208\":2}}],[\"互质的数的个数被称为欧拉函数\",{\"1\":{\"199\":1}}],[\"互质的充分必要条件是存在整数\",{\"1\":{\"68\":1,\"203\":1}}],[\"ϕ\",{\"1\":{\"199\":2}}],[\"防止数据库中的字段泄露\",{\"1\":{\"309\":1}}],[\"防止数组越界\",{\"1\":{\"62\":1}}],[\"防止缓存击穿\",{\"1\":{\"264\":1}}],[\"防止溢出\",{\"1\":{\"197\":1}}],[\"辗转相除法时间可以忽略不计\",{\"1\":{\"197\":1}}],[\"辗转相除法\",{\"1\":{\"197\":1}}],[\"欧拉函数的定义\",{\"1\":{\"199\":1}}],[\"欧拉函数\",{\"0\":{\"198\":1}}],[\"欧拉筛\",{\"0\":{\"193\":1}}],[\"欧几里得算法\",{\"1\":{\"197\":1}}],[\"欧几里得公式\",{\"1\":{\"40\":1}}],[\"欧几里得距离是指两个节点之间的直线距离\",{\"1\":{\"40\":1}}],[\"欧几里得距离\",{\"0\":{\"40\":1},\"1\":{\"36\":1}}],[\"内置异常方法\",{\"0\":{\"619\":1}}],[\"内置异常类\",{\"0\":{\"618\":1}}],[\"内置数据类型\",{\"1\":{\"551\":1}}],[\"内连接从语法上可以分为\",{\"1\":{\"531\":1}}],[\"内连接查询\",{\"1\":{\"531\":1}}],[\"内连接\",{\"0\":{\"531\":1},\"1\":{\"530\":1}}],[\"内存里设置一个过期时间很短的比如\",{\"1\":{\"293\":1}}],[\"内部运营体系基本都是基于\",{\"1\":{\"283\":1}}],[\"内容如下\",{\"1\":{\"663\":1,\"680\":1}}],[\"内容为\",{\"1\":{\"345\":1}}],[\"内容表的主键直接使用评论\",{\"1\":{\"290\":1}}],[\"内容分离\",{\"1\":{\"289\":1}}],[\"内容相关\",{\"1\":{\"272\":1}}],[\"内容的观点\",{\"1\":{\"254\":1}}],[\"内的素数了\",{\"1\":{\"192\":1}}],[\"内有多少个素数\",{\"1\":{\"192\":1}}],[\"上一条命令的退出状态\",{\"1\":{\"693\":1}}],[\"上启动\",{\"1\":{\"663\":1}}],[\"上述语法中的\",{\"1\":{\"502\":1}}],[\"上述指令\",{\"1\":{\"493\":1}}],[\"上边\",{\"1\":{\"445\":1}}],[\"上边说了布隆过滤器可能存在\",{\"1\":{\"334\":1}}],[\"上图黄色部分\",{\"1\":{\"352\":1}}],[\"上面可以看到\",{\"1\":{\"707\":1}}],[\"上面这些步骤执行后\",{\"1\":{\"345\":1}}],[\"上面查询出来的\",{\"1\":{\"289\":1}}],[\"上搭建\",{\"1\":{\"344\":1}}],[\"上次登录时间\",{\"1\":{\"321\":1}}],[\"上右键选择\",{\"1\":{\"311\":1}}],[\"上\",{\"0\":{\"297\":1},\"1\":{\"297\":1,\"715\":1}}],[\"上文提到\",{\"1\":{\"267\":1}}],[\"上浮\",{\"1\":{\"237\":1}}],[\"上了\",{\"1\":{\"192\":1}}],[\"上下左右四个相邻像素中有海洋\",{\"1\":{\"100\":1}}],[\"上下左右\",{\"1\":{\"100\":1}}],[\"解压后将\",{\"1\":{\"354\":1}}],[\"解压获取到的主程序\",{\"1\":{\"352\":1}}],[\"解压并启动\",{\"1\":{\"352\":1}}],[\"解决外键关联\",{\"1\":{\"524\":1}}],[\"解决岛屿题目最常见的就是\",{\"1\":{\"443\":1}}],[\"解决大\",{\"1\":{\"334\":1}}],[\"解决高赞永远高赞的马太效应\",{\"1\":{\"272\":1}}],[\"解决高赞高踩的负面热评问题\",{\"1\":{\"272\":1}}],[\"解决热评的有无问题\",{\"1\":{\"272\":1}}],[\"解决方案\",{\"1\":{\"727\":1}}],[\"解决方案是利用消息队列\",{\"1\":{\"261\":1}}],[\"解决方法之一是可以通过\",{\"1\":{\"334\":1}}],[\"解决方法是额外使用一个\",{\"1\":{\"94\":1}}],[\"解法\",{\"1\":{\"192\":1}}],[\"剩下的就是质数\",{\"1\":{\"191\":1}}],[\"趋于无穷大时\",{\"1\":{\"191\":1}}],[\"筛素数\",{\"1\":{\"210\":1}}],[\"筛法求出范围内的所有质数\",{\"1\":{\"210\":1}}],[\"筛法求欧拉函数\",{\"0\":{\"200\":1}}],[\"筛法求素数\",{\"0\":{\"190\":1}}],[\"筛掉它的倍数\",{\"1\":{\"191\":1}}],[\"埃氏筛\",{\"0\":{\"191\":1}}],[\"√n\",{\"1\":{\"189\":3}}],[\"素数测试\",{\"1\":{\"189\":1}}],[\"汇总所有\",{\"1\":{\"294\":1}}],[\"汇总\",{\"0\":{\"189\":1}}],[\"质数定理\",{\"1\":{\"191\":1}}],[\"质数\",{\"0\":{\"186\":1},\"1\":{\"200\":1}}],[\"称为嵌套查询\",{\"1\":{\"534\":1}}],[\"称为盐\",{\"1\":{\"323\":1}}],[\"称为这个图的最大匹配\",{\"1\":{\"183\":1}}],[\"称为正确排列\",{\"1\":{\"44\":1,\"99\":1}}],[\"匈牙利算法中只会用到从第一个集合指向第二个集合的边\",{\"1\":{\"183\":1}}],[\"匈牙利算法\",{\"0\":{\"183\":1}}],[\"区别\",{\"1\":{\"520\":1}}],[\"区分度不大的字段没必要加索引\",{\"1\":{\"320\":1}}],[\"区分\",{\"1\":{\"182\":1}}],[\"区间覆盖\",{\"0\":{\"250\":1}}],[\"区间分组\",{\"0\":{\"249\":1}}],[\"区间选点\",{\"0\":{\"247\":1}}],[\"区间问题\",{\"0\":{\"246\":1}}],[\"区间筛法\",{\"0\":{\"192\":1}}],[\"区间合并\",{\"0\":{\"162\":1,\"251\":1}}],[\"区间终点\",{\"1\":{\"127\":1}}],[\"区间长度\",{\"1\":{\"127\":1}}],[\"区间dp枚举套路\",{\"1\":{\"127\":1}}],[\"区间dp\",{\"0\":{\"127\":1}}],[\"区间\",{\"1\":{\"74\":1,\"81\":1,\"127\":1}}],[\"染色失败\",{\"1\":{\"182\":1}}],[\"染色可以使用\",{\"1\":{\"182\":1}}],[\"染色法判别二分图\",{\"0\":{\"182\":1}}],[\"值传递\",{\"0\":{\"590\":1}}],[\"值2\",{\"1\":{\"512\":6,\"513\":1}}],[\"值1\",{\"1\":{\"512\":6,\"513\":1}}],[\"值\",{\"1\":{\"467\":3}}],[\"值是0x3f3f3f3f\",{\"1\":{\"180\":1}}],[\"值最小\",{\"1\":{\"35\":2}}],[\"叫做求最小生成树\",{\"1\":{\"179\":1}}],[\"换句话说\",{\"1\":{\"618\":1}}],[\"换句话来说\",{\"1\":{\"179\":1}}],[\"换行\",{\"1\":{\"555\":2}}],[\"换成\",{\"1\":{\"142\":1}}],[\"换成a\",{\"1\":{\"142\":1}}],[\"除零错误\",{\"1\":{\"620\":1}}],[\"除\",{\"1\":{\"591\":1}}],[\"除非关闭否则无法使用其他\",{\"1\":{\"353\":1}}],[\"除了通过传统的命令行进行操作之外\",{\"1\":{\"668\":1}}],[\"除了大家点开评论区看到的\",{\"1\":{\"273\":1}}],[\"除了数据安全法所要求的以外\",{\"1\":{\"269\":1}}],[\"除了写热点\",{\"1\":{\"266\":1}}],[\"除了批判性评论之外\",{\"1\":{\"254\":1}}],[\"除了自己\",{\"1\":{\"176\":1}}],[\"除最后一层节点\",{\"1\":{\"237\":1}}],[\"除以零\",{\"1\":{\"618\":1}}],[\"除以\",{\"0\":{\"67\":1},\"1\":{\"209\":1}}],[\"原子性是指事务包装的一组\",{\"1\":{\"542\":1}}],[\"原子性\",{\"1\":{\"542\":2}}],[\"原本的右子树就丢失了\",{\"1\":{\"378\":1}}],[\"原\",{\"1\":{\"354\":1}}],[\"原来请求是\",{\"1\":{\"329\":1}}],[\"原来的mysql分表架构很快到达存储瓶颈\",{\"1\":{\"263\":1}}],[\"原始用户信息\",{\"1\":{\"310\":1}}],[\"原文链接\",{\"1\":{\"253\":1,\"277\":1,\"287\":1,\"701\":1}}],[\"原理\",{\"1\":{\"176\":1}}],[\"原因是\",{\"1\":{\"174\":1}}],[\"建完表后\",{\"1\":{\"524\":1}}],[\"建立第三张中间表\",{\"1\":{\"526\":1}}],[\"建立右子树\",{\"1\":{\"420\":1}}],[\"建立左子树\",{\"1\":{\"420\":1}}],[\"建立根节点\",{\"1\":{\"420\":1}}],[\"建立一个队列\",{\"1\":{\"175\":1}}],[\"建议使用\",{\"1\":{\"648\":1}}],[\"建议放在\",{\"1\":{\"354\":1}}],[\"建议同时指定\",{\"1\":{\"63\":1}}],[\"建表语句\",{\"1\":{\"321\":1}}],[\"建堆\",{\"1\":{\"237\":1}}],[\"松弛操作\",{\"1\":{\"174\":2}}],[\"次磁盘\",{\"1\":{\"545\":1}}],[\"次哈希值的位置上都为\",{\"1\":{\"334\":1}}],[\"次哈希计算发现这\",{\"1\":{\"334\":1}}],[\"次后变为一个式子\",{\"1\":{\"204\":1}}],[\"次之后\",{\"1\":{\"174\":1}}],[\"次\",{\"1\":{\"174\":2,\"209\":1}}],[\"次询问\",{\"1\":{\"125\":1}}],[\"迭代地寻找当前节点的左子节点\",{\"1\":{\"384\":1}}],[\"迭代隔离也是好的\",{\"1\":{\"280\":1}}],[\"迭代\",{\"0\":{\"384\":1,\"402\":1},\"1\":{\"174\":1},\"2\":{\"386\":1,\"392\":1,\"404\":1}}],[\"迭代器的++\",{\"1\":{\"242\":1}}],[\"迭代器\",{\"1\":{\"76\":3}}],[\"稀疏图改用\",{\"1\":{\"173\":1}}],[\"稀疏图用邻接表\",{\"1\":{\"172\":1}}],[\"遍历建好的图\",{\"1\":{\"474\":1}}],[\"遍历整个二维数组\",{\"1\":{\"444\":1,\"445\":1}}],[\"遍历上下左右四个方向\",{\"1\":{\"443\":1}}],[\"遍历\",{\"1\":{\"382\":1}}],[\"遍历顺序是\",{\"1\":{\"378\":1}}],[\"遍历所有左端点在l的左边的区间\",{\"1\":{\"250\":1}}],[\"遍历所有点\",{\"1\":{\"182\":1,\"183\":1}}],[\"遍历n个点\",{\"1\":{\"172\":1}}],[\"遍历节点\",{\"1\":{\"35\":1}}],[\"寻找下一个字符\",{\"1\":{\"425\":1}}],[\"寻找距离最小的点\",{\"1\":{\"172\":1}}],[\"寻找两点之间的最大距离\",{\"1\":{\"165\":1}}],[\"访问静态变量最好通过类名\",{\"1\":{\"600\":1}}],[\"访问string中的字符\",{\"1\":{\"578\":1}}],[\"访问数组元素\",{\"0\":{\"572\":1}}],[\"访问所指定相对根目录下的目录及文件\",{\"1\":{\"357\":1}}],[\"访问\",{\"1\":{\"352\":1,\"668\":1}}],[\"访问不了再用代理线路\",{\"1\":{\"347\":1}}],[\"访问国外的一些优秀网站速度会很慢\",{\"1\":{\"343\":1}}],[\"访问加入集合并标记\",{\"1\":{\"172\":1}}],[\"访问标记\",{\"1\":{\"134\":1}}],[\"稠密图用邻接矩阵\",{\"1\":{\"172\":1}}],[\"堆是一棵\",{\"1\":{\"237\":1}}],[\"堆\",{\"0\":{\"237\":1}}],[\"堆优化版的dijkstra算法\",{\"0\":{\"173\":1},\"1\":{\"171\":1}}],[\"堆排序只能保证根是最大\",{\"1\":{\"651\":1}}],[\"堆排\",{\"1\":{\"43\":1}}],[\"点进去看下这个方法做了什么\",{\"1\":{\"702\":1}}],[\"点击添加\",{\"1\":{\"358\":1}}],[\"点击\",{\"1\":{\"347\":1,\"354\":1,\"358\":1}}],[\"点踩\",{\"1\":{\"255\":1}}],[\"点赞率=点赞数\",{\"1\":{\"273\":1}}],[\"点赞数是一个频繁更新的值\",{\"1\":{\"273\":1}}],[\"点赞高\",{\"1\":{\"272\":1}}],[\"点赞\",{\"1\":{\"255\":1}}],[\"点的数量\",{\"1\":{\"173\":1}}],[\"点数和边数\",{\"1\":{\"172\":1}}],[\"点多\",{\"1\":{\"171\":1}}],[\"点少边比较多\",{\"1\":{\"171\":1}}],[\"点从\",{\"1\":{\"132\":1}}],[\"头是按指定排序方式的最小元素\",{\"1\":{\"651\":1}}],[\"头尾指针\",{\"1\":{\"169\":1}}],[\"头重脚轻\",{\"1\":{\"91\":1}}],[\"结构如下图所示\",{\"1\":{\"709\":1}}],[\"结构中如何避免这个问题\",{\"1\":{\"545\":1}}],[\"结构组织的索引\",{\"1\":{\"545\":1}}],[\"结构\",{\"0\":{\"545\":1},\"1\":{\"545\":1}}],[\"结构化查询语言\",{\"1\":{\"494\":1}}],[\"结构性提升了复杂调用场景下的接口性能下限\",{\"1\":{\"258\":1}}],[\"结构体存储\",{\"1\":{\"181\":1}}],[\"结合上面的加载配置文件的分析\",{\"1\":{\"707\":1}}],[\"结合上述分析\",{\"1\":{\"545\":1}}],[\"结合评论网关层的排序策略路由\",{\"1\":{\"273\":1}}],[\"结合评论的产品功能要求\",{\"1\":{\"263\":1}}],[\"结合各种逻辑算子构成一个规则表达式\",{\"1\":{\"273\":1}}],[\"结合ai和人工\",{\"1\":{\"255\":1}}],[\"结合b站以及其他互联网平台的评论产品特点\",{\"1\":{\"255\":1}}],[\"结束时间\",{\"1\":{\"525\":1}}],[\"结束\",{\"1\":{\"232\":1}}],[\"结尾\",{\"1\":{\"232\":1}}],[\"结论\",{\"1\":{\"169\":1,\"188\":1,\"208\":1}}],[\"结果会填充0或false值\",{\"1\":{\"640\":1}}],[\"结果就是\",{\"1\":{\"545\":1}}],[\"结果\",{\"1\":{\"314\":1}}],[\"结果为零\",{\"1\":{\"158\":1}}],[\"结果才为0\",{\"1\":{\"157\":1}}],[\"结果才为1\",{\"1\":{\"157\":1}}],[\"宽度优先遍历\",{\"0\":{\"168\":1}}],[\"无论是标准输出还是错误输出\",{\"1\":{\"660\":1}}],[\"无论如何操作\",{\"1\":{\"214\":1}}],[\"无返回值函数\",{\"0\":{\"593\":1}}],[\"无符号\",{\"1\":{\"507\":1}}],[\"无重复节点值\",{\"1\":{\"419\":1}}],[\"无需额外定义数据结构\",{\"1\":{\"366\":1}}],[\"无解\",{\"1\":{\"205\":1}}],[\"无向图\",{\"1\":{\"172\":1}}],[\"无向图是没有拓扑序列的\",{\"1\":{\"169\":1}}],[\"无向图就再写一遍\",{\"1\":{\"165\":1}}],[\"无法结束\",{\"1\":{\"561\":1}}],[\"无法完成所有课程\",{\"1\":{\"474\":1}}],[\"无法继续向下处理了\",{\"1\":{\"383\":1}}],[\"无法使用其他应用程序\",{\"1\":{\"353\":1}}],[\"无法查阅到想要的\",{\"1\":{\"343\":1}}],[\"无法删除元素\",{\"1\":{\"334\":2}}],[\"无法存储上一节点\",{\"1\":{\"223\":1}}],[\"无法移动者判负\",{\"1\":{\"216\":1}}],[\"无法形成最短路\",{\"1\":{\"172\":1}}],[\"无法通过\",{\"1\":{\"55\":1}}],[\"无法与\",{\"1\":{\"25\":1}}],[\"存放字符串池\",{\"1\":{\"642\":1}}],[\"存在\",{\"1\":{\"291\":1}}],[\"存在读放大\",{\"1\":{\"266\":1}}],[\"存在才能增量追加\",{\"1\":{\"264\":1}}],[\"存在乘法逆元的充要条件是\",{\"1\":{\"208\":1}}],[\"存在负权边\",{\"0\":{\"174\":1,\"175\":1},\"1\":{\"171\":1}}],[\"存的是当前加入的边数\",{\"1\":{\"181\":1}}],[\"存的是最小生成树的所有边的权值\",{\"1\":{\"181\":1}}],[\"存入a和b两点之间的距离\",{\"1\":{\"172\":1}}],[\"存边\",{\"1\":{\"165\":1}}],[\"存储桶\",{\"1\":{\"667\":1}}],[\"存储和检索数据\",{\"1\":{\"667\":1}}],[\"存储的元数据主要包括对象的描述信息\",{\"1\":{\"667\":1}}],[\"存储的的是\",{\"1\":{\"545\":1}}],[\"存储的变量\",{\"1\":{\"310\":1}}],[\"存储到了相同地址\",{\"1\":{\"578\":1}}],[\"存储到\",{\"1\":{\"522\":1}}],[\"存储中序遍历的节点与索引的映射关系\",{\"1\":{\"419\":1}}],[\"存储路径和文件名都可以使用\",{\"1\":{\"352\":1}}],[\"存储目录为\",{\"1\":{\"352\":1}}],[\"存储目前为止前缀和相同的个数\",{\"1\":{\"81\":1}}],[\"存储无关的方式\",{\"1\":{\"351\":1}}],[\"存储数据的目录路径\",{\"1\":{\"662\":1}}],[\"存储数据\",{\"1\":{\"319\":1}}],[\"存储内容包括同一个评论\",{\"1\":{\"264\":1}}],[\"存储设计\",{\"0\":{\"262\":1,\"288\":1}}],[\"存储字符串前k个字母的哈希值\",{\"1\":{\"241\":1}}],[\"存储堆中下标是k的点是第几个插入的\",{\"1\":{\"237\":1}}],[\"存储堆中的值\",{\"1\":{\"237\":1}}],[\"存储第k个插入的点在堆中的位置\",{\"1\":{\"237\":1}}],[\"存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\",{\"1\":{\"183\":1}}],[\"存储x到p\",{\"1\":{\"236\":1}}],[\"存储x是否被筛掉\",{\"1\":{\"191\":1,\"193\":1,\"200\":1}}],[\"存储当前用到的下标\",{\"1\":{\"232\":1}}],[\"存储以每个节点结尾的单词数量\",{\"1\":{\"232\":1}}],[\"存储树中每个节点的子节点\",{\"1\":{\"232\":1}}],[\"存储形式如下\",{\"1\":{\"232\":1}}],[\"存储节点的next指针\",{\"1\":{\"223\":1}}],[\"存储节点的值\",{\"1\":{\"223\":1}}],[\"存储图和树\",{\"1\":{\"223\":1}}],[\"存储其他点到当前最小生成树的距离\",{\"1\":{\"180\":1}}],[\"存储1到x的最短路中经过的点数\",{\"1\":{\"176\":1}}],[\"存储1到x的最短路距离\",{\"1\":{\"174\":1}}],[\"存储1号点到x的最短距离\",{\"1\":{\"176\":1}}],[\"存储1号点到每个点的最短距离\",{\"1\":{\"172\":1}}],[\"存储所有质数\",{\"1\":{\"210\":1}}],[\"存储所有素数\",{\"1\":{\"191\":1,\"193\":1,\"200\":1}}],[\"存储所有边\",{\"1\":{\"180\":1}}],[\"存储所有点到1号点的距离\",{\"1\":{\"173\":1}}],[\"存储所有待离散化的值\",{\"1\":{\"161\":1}}],[\"存储每个数是否已被筛掉\",{\"1\":{\"210\":1}}],[\"存储每个数的欧拉函数\",{\"1\":{\"200\":1}}],[\"存储每个质数的次数\",{\"1\":{\"210\":1}}],[\"存储每个点的祖宗节点\",{\"1\":{\"234\":1,\"235\":1,\"236\":1}}],[\"存储每个点的最短距离是否已确定\",{\"1\":{\"173\":1}}],[\"存储每个点的最短路是否已经确定\",{\"1\":{\"172\":1}}],[\"存储每个点是否已经在生成树中\",{\"1\":{\"180\":1}}],[\"存储每个点是否在队列中\",{\"1\":{\"175\":1,\"176\":1}}],[\"存储每个点到1号点的最短距离\",{\"1\":{\"175\":1}}],[\"存储每条边\",{\"1\":{\"172\":1}}],[\"存储点i的入度\",{\"1\":{\"169\":1}}],[\"存储这个单链表的头结点\",{\"1\":{\"165\":1}}],[\"存储k所有可以走到的点\",{\"1\":{\"165\":1}}],[\"存储边\",{\"1\":{\"165\":1}}],[\"存储\",{\"1\":{\"147\":1,\"148\":1,\"237\":1,\"241\":2,\"277\":1,\"289\":1,\"358\":1,\"668\":1}}],[\"存储变换后的字符串\",{\"1\":{\"99\":1}}],[\"存储备份该状态\",{\"1\":{\"44\":1}}],[\"存储该状态\",{\"1\":{\"44\":1}}],[\"存储距离和起点\",{\"1\":{\"43\":1}}],[\"邻接表建图\",{\"1\":{\"475\":1}}],[\"邻接表存储图\",{\"1\":{\"182\":1}}],[\"邻接表存储所有边\",{\"1\":{\"173\":1,\"175\":1,\"176\":1,\"183\":1}}],[\"邻接表\",{\"1\":{\"165\":1,\"173\":1,\"223\":1}}],[\"邻接矩阵初始化为无穷大\",{\"1\":{\"172\":1}}],[\"邻接矩阵\",{\"1\":{\"165\":1,\"180\":1}}],[\"动态扩容的数组\",{\"1\":{\"645\":1}}],[\"动态调用实例的成员函数\",{\"1\":{\"627\":1}}],[\"动态引入类\",{\"1\":{\"627\":1}}],[\"动态外露评论\",{\"1\":{\"273\":1}}],[\"动态外露评论等\",{\"1\":{\"272\":1}}],[\"动态\",{\"1\":{\"254\":1}}],[\"动态维护有序序列\",{\"1\":{\"242\":1}}],[\"动态邻接矩阵\",{\"1\":{\"165\":1}}],[\"动态规划\",{\"0\":{\"114\":1},\"1\":{\"2\":1},\"2\":{\"135\":1,\"452\":1}}],[\"去掉首尾的空白字符\",{\"1\":{\"578\":1}}],[\"去掉重复元素\",{\"1\":{\"161\":1}}],[\"去除首尾空白字符\",{\"1\":{\"642\":2}}],[\"去除重复记录\",{\"1\":{\"517\":1}}],[\"去除无效状态的优化写法\",{\"1\":{\"131\":1}}],[\"去请求\",{\"1\":{\"310\":1}}],[\"去记录\",{\"1\":{\"309\":1}}],[\"去对比\",{\"1\":{\"309\":1}}],[\"去查到这一行数据\",{\"1\":{\"289\":1}}],[\"去查必然需要先查到自己的主键\",{\"1\":{\"289\":1}}],[\"去平台业务的逻辑\",{\"1\":{\"279\":1}}],[\"去重\",{\"1\":{\"243\":2}}],[\"去筛合数时\",{\"1\":{\"193\":1}}],[\"离线数据\",{\"1\":{\"273\":1}}],[\"离散化\",{\"0\":{\"161\":1}}],[\"离终点最近\",{\"1\":{\"34\":1}}],[\"得出每个节点的直径\",{\"1\":{\"413\":1}}],[\"得以复用\",{\"1\":{\"273\":1}}],[\"得看被移数是正还是负\",{\"1\":{\"158\":1}}],[\"得到\",{\"1\":{\"334\":1,\"354\":1,\"357\":1}}],[\"得到了登录成功的\",{\"1\":{\"310\":1}}],[\"得到一个\",{\"1\":{\"310\":1}}],[\"得到排序过后的评论\",{\"1\":{\"291\":1}}],[\"得到该位的被除数\",{\"1\":{\"150\":1}}],[\"得到总区间的最小代价\",{\"1\":{\"127\":1}}],[\"得到三个非空子数组\",{\"1\":{\"82\":1}}],[\"得到正确排列\",{\"1\":{\"44\":1}}],[\"逻辑外键\",{\"1\":{\"524\":1}}],[\"逻辑运算符\",{\"1\":{\"518\":2}}],[\"逻辑运算符和其他运算符都高\",{\"1\":{\"158\":1}}],[\"逻辑删除是指在数据库中不是真正删除记录\",{\"1\":{\"310\":1}}],[\"逻辑删除\",{\"1\":{\"310\":1,\"321\":1}}],[\"逻辑\",{\"1\":{\"283\":1,\"568\":1}}],[\"逻辑右移\",{\"1\":{\"157\":1}}],[\"关闭终端后服务就会停止\",{\"1\":{\"663\":1}}],[\"关闭评论区\",{\"1\":{\"270\":1}}],[\"关联另外一方的主键\",{\"1\":{\"525\":1}}],[\"关联查询条件复杂\",{\"1\":{\"259\":1}}],[\"关键\",{\"1\":{\"542\":1}}],[\"关键字\",{\"1\":{\"506\":1}}],[\"关键索引是评论区\",{\"1\":{\"263\":1}}],[\"关注在稳定性\",{\"1\":{\"279\":1}}],[\"关注在业务平台化逻辑上\",{\"1\":{\"279\":1}}],[\"关系\",{\"1\":{\"526\":1}}],[\"关系类\",{\"1\":{\"263\":1}}],[\"关系运算符\",{\"1\":{\"158\":1}}],[\"关于表结构的操作也是包含四个部分\",{\"1\":{\"503\":1}}],[\"关于\",{\"1\":{\"302\":1}}],[\"关于为什么求\",{\"1\":{\"231\":1}}],[\"关于距离\",{\"0\":{\"37\":1}}],[\"关于中间件\",{\"1\":{\"14\":1}}],[\"翻转字符串\",{\"1\":{\"578\":1}}],[\"翻转这棵二叉树\",{\"1\":{\"461\":1}}],[\"翻转二叉树\",{\"0\":{\"460\":1},\"1\":{\"460\":1}}],[\"翻转一个数组\",{\"1\":{\"243\":1}}],[\"翻转一个\",{\"1\":{\"243\":1}}],[\"翻转\",{\"1\":{\"243\":1}}],[\"翻转指定位\",{\"1\":{\"158\":1}}],[\"翻译\",{\"1\":{\"81\":1}}],[\"令\",{\"1\":{\"158\":3}}],[\"全称\",{\"1\":{\"496\":1}}],[\"全部用大写字符\",{\"1\":{\"578\":1}}],[\"全部用小写字符\",{\"1\":{\"578\":1}}],[\"全部字段\",{\"1\":{\"512\":1}}],[\"全部字段添加数据\",{\"1\":{\"512\":1}}],[\"全部弹出后\",{\"1\":{\"384\":1}}],[\"全部加起来\",{\"1\":{\"128\":1}}],[\"全局变量\",{\"1\":{\"689\":1}}],[\"全局逻辑删除字段名\",{\"1\":{\"310\":1}}],[\"全局并行\",{\"1\":{\"282\":1}}],[\"全量更新时\",{\"1\":{\"273\":1}}],[\"全为\",{\"1\":{\"158\":2}}],[\"算术右移\",{\"1\":{\"157\":1}}],[\"算法步骤\",{\"1\":{\"205\":1}}],[\"算法描述\",{\"1\":{\"183\":1}}],[\"算法描述如下\",{\"1\":{\"35\":1}}],[\"算法思路\",{\"1\":{\"140\":1}}],[\"算法和求最近公共祖先\",{\"1\":{\"87\":1}}],[\"算法不断回溯来解决迷宫问题\",{\"1\":{\"54\":1}}],[\"算法不能保证找到最短路径\",{\"1\":{\"36\":1}}],[\"算法条件\",{\"1\":{\"41\":1}}],[\"算法比较灵活的地方\",{\"1\":{\"36\":1}}],[\"算法将找到最佳路径\",{\"1\":{\"36\":1}}],[\"算法将遍历越多的节点\",{\"1\":{\"36\":1}}],[\"算法将和广度优先算法变得一样\",{\"1\":{\"33\":1}}],[\"算法保证一定能够找到最短路径\",{\"1\":{\"36\":1}}],[\"算法的行为\",{\"1\":{\"36\":1}}],[\"算法的启发函数\",{\"1\":{\"35\":1}}],[\"算法结束后\",{\"1\":{\"178\":1}}],[\"算法结束\",{\"1\":{\"35\":1}}],[\"算法使用两个集合来表示待遍历的节点\",{\"1\":{\"35\":1}}],[\"算法在运算过程中\",{\"1\":{\"35\":1}}],[\"算法通过下面这个函数来计算每个节点的优先级\",{\"1\":{\"35\":1}}],[\"算法类似\",{\"1\":{\"34\":1}}],[\"算法中\",{\"1\":{\"33\":1}}],[\"算法用来寻找图形中节点之间的最短路径\",{\"1\":{\"33\":1}}],[\"算法是一种很常用的路径查找和图形遍历算法\",{\"1\":{\"30\":1}}],[\"算法\",{\"0\":{\"29\":1,\"33\":1,\"181\":1},\"1\":{\"34\":1,\"36\":1,\"41\":1,\"171\":2}}],[\"算法笔记\",{\"0\":{\"1\":1}}],[\"各种视频\",{\"1\":{\"666\":1}}],[\"各种图片\",{\"1\":{\"666\":1}}],[\"各种应用都可以连接到它\",{\"1\":{\"356\":1}}],[\"各类静态模型分存在4到5层冗余\",{\"1\":{\"273\":1}}],[\"各级缓存可能有功能上的略微差异\",{\"1\":{\"267\":1}}],[\"各编译器处理方法不一样\",{\"1\":{\"157\":1}}],[\"各二进位全部右移若干位\",{\"1\":{\"157\":1}}],[\"各二进位全部左移若干位\",{\"1\":{\"157\":1}}],[\"各行\",{\"1\":{\"107\":1}}],[\"异步处理\",{\"1\":{\"261\":1}}],[\"异或\",{\"1\":{\"157\":1}}],[\"异常2\",{\"0\":{\"728\":1}}],[\"异常1\",{\"0\":{\"727\":1}}],[\"异常处理可以允许我们在程序运行时进行诊断和补救\",{\"1\":{\"614\":1}}],[\"异常处理\",{\"0\":{\"614\":1}}],[\"异常\",{\"1\":{\"63\":1,\"617\":1,\"618\":2}}],[\"描述的是正常\",{\"1\":{\"263\":1}}],[\"描述\",{\"1\":{\"157\":1,\"506\":1,\"507\":3,\"536\":1,\"541\":1,\"552\":1,\"618\":2}}],[\"符号\",{\"1\":{\"157\":1,\"685\":1,\"686\":2}}],[\"位置没有节点\",{\"1\":{\"425\":2}}],[\"位整数范围内\",{\"1\":{\"204\":1}}],[\"位上的数是否为\",{\"1\":{\"201\":1}}],[\"位数字移动到最后一位\",{\"1\":{\"159\":1}}],[\"位数\",{\"1\":{\"159\":1}}],[\"位进行翻转\",{\"1\":{\"158\":1}}],[\"位设置为\",{\"1\":{\"158\":1}}],[\"位为\",{\"1\":{\"158\":3}}],[\"位\",{\"1\":{\"158\":4,\"159\":1,\"309\":2,\"323\":2}}],[\"位运算符作用于位\",{\"1\":{\"157\":1}}],[\"位运算符\",{\"0\":{\"157\":1}}],[\"位运算\",{\"0\":{\"156\":1}}],[\"位于应用与操作系统\",{\"1\":{\"14\":1}}],[\"便于数据的排序及区间范围查询\",{\"1\":{\"545\":1}}],[\"便于直接对余数进行处理\",{\"1\":{\"150\":1}}],[\"便可以从终点开始\",{\"1\":{\"32\":1}}],[\"÷\",{\"1\":{\"150\":2}}],[\"倒序输出\",{\"1\":{\"149\":1}}],[\"倒序插入\",{\"1\":{\"149\":1}}],[\"倒序存放\",{\"1\":{\"147\":1,\"148\":1}}],[\"逐层遍历\",{\"1\":{\"395\":1}}],[\"逐个遍历\",{\"1\":{\"172\":1}}],[\"逐位压入数组中\",{\"1\":{\"149\":1}}],[\"逐步的向外扩散\",{\"1\":{\"32\":1}}],[\"低精\",{\"1\":{\"149\":1,\"150\":1}}],[\"低位补0\",{\"1\":{\"157\":1}}],[\"低位变为0\",{\"1\":{\"147\":1}}],[\"低位满10向高位进位\",{\"1\":{\"147\":1}}],[\"满足匹配条件\",{\"1\":{\"231\":1}}],[\"满足任意前缀中0的个数都不少于1的个数的序列的数量为\",{\"1\":{\"211\":1}}],[\"满足\",{\"1\":{\"148\":1,\"204\":1,\"406\":1}}],[\"压入元素\",{\"1\":{\"610\":1}}],[\"压入c数组中\",{\"1\":{\"147\":1}}],[\"压缩路径\",{\"1\":{\"93\":1,\"94\":1}}],[\"进阶\",{\"0\":{\"364\":1},\"1\":{\"376\":1}}],[\"进入终端\",{\"1\":{\"662\":1}}],[\"进入到\",{\"1\":{\"662\":1}}],[\"进入到目录\",{\"1\":{\"302\":1}}],[\"进入\",{\"1\":{\"302\":2}}],[\"进制数\",{\"1\":{\"241\":1}}],[\"进制的数转化为十进制\",{\"1\":{\"65\":1}}],[\"进行通信的对象\",{\"1\":{\"715\":1}}],[\"进行通信的\",{\"1\":{\"714\":1}}],[\"进行数据读写\",{\"1\":{\"667\":1}}],[\"进行纵向计算\",{\"1\":{\"519\":1}}],[\"进行进程守护\",{\"1\":{\"353\":1}}],[\"进行更详细的配置\",{\"1\":{\"352\":1}}],[\"进行组合\",{\"1\":{\"323\":1}}],[\"进行一致性\",{\"1\":{\"294\":1}}],[\"进行缓存的异步构建\",{\"1\":{\"291\":1}}],[\"进行索引的缓存\",{\"1\":{\"291\":1}}],[\"进行运营测的\",{\"1\":{\"283\":1}}],[\"进行同步到\",{\"1\":{\"279\":1}}],[\"进行了隔离\",{\"1\":{\"279\":1}}],[\"进行控制\",{\"1\":{\"264\":1}}],[\"进行\",{\"1\":{\"182\":1}}],[\"进行异或运算\",{\"1\":{\"158\":1}}],[\"进行按位或运算\",{\"1\":{\"158\":1}}],[\"进行按位与运算\",{\"1\":{\"158\":1}}],[\"进位\",{\"1\":{\"147\":1}}],[\"加到函数上\",{\"1\":{\"635\":1}}],[\"加到代码块上\",{\"1\":{\"635\":1}}],[\"加到集合当中去\",{\"1\":{\"180\":1}}],[\"加速\",{\"1\":{\"350\":1}}],[\"加载配置文件小结\",{\"0\":{\"708\":1}}],[\"加载配置文件\",{\"0\":{\"706\":1}}],[\"加载模式\",{\"1\":{\"291\":1}}],[\"加载\",{\"0\":{\"704\":1},\"1\":{\"279\":1}}],[\"加权平均高\",{\"1\":{\"272\":1}}],[\"加1\",{\"1\":{\"231\":1}}],[\"加边法\",{\"1\":{\"181\":1}}],[\"加点法\",{\"1\":{\"180\":1}}],[\"加上\",{\"1\":{\"147\":1,\"148\":1}}],[\"加入答案\",{\"1\":{\"480\":1}}],[\"加入新的一层\",{\"1\":{\"469\":1}}],[\"加入进来\",{\"1\":{\"443\":1}}],[\"加入下一个字符\",{\"1\":{\"425\":1}}],[\"加入到集合中\",{\"1\":{\"181\":1}}],[\"加入到连通块中\",{\"1\":{\"180\":1}}],[\"加入i后更新当前a的值\",{\"1\":{\"111\":1}}],[\"加入\",{\"1\":{\"35\":1}}],[\"检索速度就会降低\",{\"1\":{\"545\":1}}],[\"检查型异常必须被捕获或者抛出\",{\"1\":{\"621\":1}}],[\"检查性异常\",{\"1\":{\"618\":1}}],[\"检查它是否轴对称\",{\"1\":{\"430\":1}}],[\"检查x是否满足某种性质\",{\"1\":{\"145\":1}}],[\"检验\",{\"1\":{\"24\":1}}],[\"需求分析\",{\"0\":{\"299\":1},\"1\":{\"298\":1}}],[\"需使用头文件\",{\"1\":{\"144\":1}}],[\"需要加上\",{\"1\":{\"686\":1}}],[\"需要将其注册为\",{\"1\":{\"663\":1}}],[\"需要将多次访问数据库的操作视为一个整体来执行\",{\"1\":{\"540\":1}}],[\"需要先定义好排序规则\",{\"1\":{\"651\":1}}],[\"需要先完成​课程\",{\"1\":{\"474\":1}}],[\"需要用到\",{\"1\":{\"647\":1}}],[\"需要用多重背包的二进制优化方法\",{\"1\":{\"118\":1}}],[\"需要手动刷新缓冲区\",{\"1\":{\"555\":1}}],[\"需要消除无效的笛卡尔积\",{\"1\":{\"529\":1}}],[\"需要检查外键关系\",{\"1\":{\"524\":1}}],[\"需要检索的数据维度比较多\",{\"1\":{\"283\":1}}],[\"需要指定存储桶名称和对象键\",{\"1\":{\"676\":1}}],[\"需要指定存储桶的名称\",{\"1\":{\"675\":1}}],[\"需要指定长度\",{\"1\":{\"507\":2}}],[\"需要指出的是\",{\"1\":{\"273\":1}}],[\"需要遍历整棵树\",{\"1\":{\"488\":1}}],[\"需要把上界\",{\"1\":{\"486\":1}}],[\"需要单独创建\",{\"1\":{\"357\":1}}],[\"需要删除同级目录下的\",{\"1\":{\"352\":1}}],[\"需要展示图片\",{\"1\":{\"350\":1}}],[\"需要开启防火墙\",{\"1\":{\"345\":1}}],[\"需要对多少个元素进行存储\",{\"1\":{\"334\":1}}],[\"需要对非核心依赖的\",{\"1\":{\"284\":1}}],[\"需要判断用户的用户名是否重复\",{\"1\":{\"334\":1}}],[\"需要在路劲为\",{\"1\":{\"302\":1}}],[\"需要回放录入到\",{\"1\":{\"283\":1}}],[\"需要处理不同决策的优先级pk\",{\"1\":{\"273\":1}}],[\"需要处理各种细分场景下的差异化需求\",{\"1\":{\"273\":1}}],[\"需要支持较丰富的数据结构\",{\"1\":{\"273\":1}}],[\"需要实现点赞率的近实时计算\",{\"1\":{\"273\":1}}],[\"需要多减去该一级评论的回复数\",{\"1\":{\"263\":1}}],[\"需要级联更新所有的父评论的回复数\",{\"1\":{\"263\":1}}],[\"需要为多个不同的查询场景建立多种索引分片\",{\"1\":{\"259\":1}}],[\"需要保证头结点存在\",{\"1\":{\"223\":1}}],[\"需要借位\",{\"1\":{\"148\":1}}],[\"需要减去序列头以转换为下标\",{\"1\":{\"76\":1}}],[\"需要考虑回溯的问题\",{\"1\":{\"55\":1}}],[\"需要计算每一个节点距离起点的总移动代价\",{\"1\":{\"33\":1}}],[\"出栈一个元素\",{\"1\":{\"648\":1}}],[\"出发的点不算\",{\"1\":{\"183\":1}}],[\"出现了多少次\",{\"1\":{\"144\":1}}],[\"出口处不一定有像\",{\"1\":{\"57\":1}}],[\"改了后\",{\"1\":{\"702\":1}}],[\"改动会影响原数组\",{\"1\":{\"645\":1}}],[\"改的效率\",{\"1\":{\"524\":1}}],[\"改操作\",{\"1\":{\"511\":1}}],[\"改造后\",{\"1\":{\"266\":1}}],[\"改成批量写入\",{\"1\":{\"266\":1}}],[\"改\",{\"1\":{\"143\":1}}],[\"改为自定义变量\",{\"1\":{\"689\":1}}],[\"改为\",{\"1\":{\"57\":1,\"486\":1}}],[\"简单来讲\",{\"1\":{\"544\":1}}],[\"简单来说\",{\"1\":{\"356\":1}}],[\"简单来说就是\",{\"1\":{\"142\":1}}],[\"简而言之\",{\"1\":{\"540\":1}}],[\"简介\",{\"0\":{\"87\":1,\"494\":1}}],[\"两种写法均可\",{\"1\":{\"687\":1}}],[\"两者相等\",{\"1\":{\"486\":1}}],[\"两节点之间路径的\",{\"1\":{\"412\":1}}],[\"两台服务的成本确实会有点点高\",{\"1\":{\"346\":1}}],[\"两名玩家交替地把这枚棋子沿有向边进行移动\",{\"1\":{\"216\":1}}],[\"两名玩家轮流行动\",{\"1\":{\"214\":1}}],[\"两人都采取最优策略\",{\"1\":{\"214\":1}}],[\"两点及其权值\",{\"1\":{\"181\":1}}],[\"两重\",{\"1\":{\"174\":1}}],[\"两个实现类\",{\"1\":{\"645\":1,\"647\":1}}],[\"两个字符串的公共子序列是这两个字符串所共同拥有的子序列\",{\"1\":{\"449\":1}}],[\"两个迭代器\",{\"1\":{\"243\":1}}],[\"两个集合\",{\"1\":{\"182\":1,\"529\":1}}],[\"两个位相同为0\",{\"1\":{\"157\":1}}],[\"两个位都为0时\",{\"1\":{\"157\":1}}],[\"两个位都为1时\",{\"1\":{\"157\":1}}],[\"两个if把两个数组相同位上的数相加\",{\"1\":{\"147\":1}}],[\"两个整数\",{\"1\":{\"109\":1}}],[\"两边递归\",{\"1\":{\"138\":1}}],[\"确定根节点再中序遍历中的位置\",{\"1\":{\"419\":1}}],[\"确定后就会自动开始代理服务了\",{\"1\":{\"347\":1}}],[\"确定中间分界点\",{\"1\":{\"138\":1}}],[\"确定分界点\",{\"1\":{\"137\":1,\"138\":1}}],[\"合规性要求\",{\"1\":{\"269\":1}}],[\"合二为一\",{\"1\":{\"138\":1}}],[\"合并岛屿\",{\"1\":{\"445\":1}}],[\"合并a和b所在的两个集合\",{\"1\":{\"235\":1,\"236\":1}}],[\"合并x和y所在的两个集合\",{\"1\":{\"234\":1}}],[\"合并两步后\",{\"1\":{\"159\":1}}],[\"合并区间\",{\"1\":{\"138\":1}}],[\"合并\",{\"0\":{\"91\":1},\"1\":{\"87\":1,\"93\":1,\"94\":1}}],[\"运用前缀和的思想\",{\"1\":{\"480\":1}}],[\"运用双指针的思想\",{\"1\":{\"138\":1}}],[\"运营后台的检索条件都是组合的\",{\"1\":{\"283\":1}}],[\"运营体系的数据大量都是检索\",{\"1\":{\"279\":1}}],[\"运营精选且带\",{\"1\":{\"272\":1}}],[\"运营人员的数据查询具有\",{\"1\":{\"259\":1}}],[\"运行方式\",{\"1\":{\"680\":1}}],[\"运行公开的读\",{\"1\":{\"675\":1}}],[\"运行结果不同\",{\"1\":{\"602\":1}}],[\"运行时异常都是\",{\"1\":{\"617\":1}}],[\"运行时异常和非运行时异常的区别\",{\"0\":{\"617\":1}}],[\"运行时异常\",{\"1\":{\"270\":1}}],[\"运行和集成的平台\",{\"1\":{\"14\":1}}],[\"运算时会将其当做整数\",{\"1\":{\"577\":1}}],[\"运算符\",{\"0\":{\"552\":1},\"1\":{\"243\":2,\"552\":1}}],[\"运算符的优先级比算术运算符\",{\"1\":{\"158\":1}}],[\"运算的结果\",{\"1\":{\"218\":1}}],[\"运算\",{\"1\":{\"158\":1}}],[\"运算规则\",{\"1\":{\"157\":1,\"158\":4}}],[\"避免重复合并操作\",{\"1\":{\"445\":1}}],[\"避免重复筛选\",{\"1\":{\"193\":1}}],[\"避免使用评论\",{\"1\":{\"290\":1}}],[\"避免每次都重新统计\",{\"1\":{\"290\":1}}],[\"避免依赖\",{\"1\":{\"283\":1}}],[\"避免频繁\",{\"1\":{\"281\":1}}],[\"避免风险数据外泄\",{\"1\":{\"269\":1}}],[\"避免高优先级操作被低优先级操作覆盖\",{\"1\":{\"269\":1}}],[\"避免并发写操作时\",{\"1\":{\"264\":1}}],[\"避免此类极端情况导致的数据缺失\",{\"1\":{\"264\":1}}],[\"避免了并行处理导致的一些数据错乱风险\",{\"1\":{\"261\":1}}],[\"避免和头文件next冲突\",{\"1\":{\"231\":1}}],[\"避免发生边界问题导致死循环\",{\"1\":{\"137\":1}}],[\"避免维护\",{\"1\":{\"48\":1,\"443\":1}}],[\"子进程可以访问的变量\",{\"1\":{\"689\":1}}],[\"子进程不能访问的变量\",{\"1\":{\"689\":1}}],[\"子类会继承父类的注解\",{\"1\":{\"626\":1}}],[\"子查询返回的结果是多行多列\",{\"1\":{\"538\":1}}],[\"子查询返回的结果是一行\",{\"1\":{\"537\":1}}],[\"子查询返回的结果是一列\",{\"1\":{\"536\":1}}],[\"子查询返回的结果是单个值\",{\"1\":{\"535\":1}}],[\"子查询可以书写的位置\",{\"1\":{\"534\":1}}],[\"子查询结果为多行多列\",{\"1\":{\"534\":1}}],[\"子查询结果为一行\",{\"1\":{\"534\":1}}],[\"子查询结果为一列\",{\"1\":{\"534\":1}}],[\"子查询结果为单个值\",{\"1\":{\"534\":1}}],[\"子查询外部的语句可以是\",{\"1\":{\"534\":1}}],[\"子查询\",{\"0\":{\"533\":1},\"1\":{\"530\":1}}],[\"子树的节点数量\",{\"1\":{\"419\":1}}],[\"子指针指向链表中下一个结点\",{\"1\":{\"376\":1}}],[\"子评论之间也可以互相评论\",{\"1\":{\"289\":1}}],[\"子评论数等\",{\"1\":{\"263\":1}}],[\"子串长度\",{\"1\":{\"242\":1}}],[\"子问题合并\",{\"1\":{\"137\":2}}],[\"子节点列表\",{\"1\":{\"426\":1}}],[\"子节点不能选\",{\"1\":{\"134\":1}}],[\"子节点依附在根节点上\",{\"1\":{\"93\":1}}],[\"快捷签发\",{\"1\":{\"354\":1}}],[\"快速集成快速集成使用\",{\"1\":{\"668\":1}}],[\"快速集成项目\",{\"1\":{\"300\":1}}],[\"快速部署\",{\"1\":{\"352\":1}}],[\"快速判断该用户名是否已经被使用了\",{\"1\":{\"334\":1}}],[\"快速判断某个元素是否在集合中出现了\",{\"1\":{\"334\":1}}],[\"快速启动\",{\"1\":{\"300\":1}}],[\"快速幂模板\",{\"1\":{\"208\":1,\"209\":1}}],[\"快速幂求逆元\",{\"1\":{\"208\":1}}],[\"快速幂\",{\"0\":{\"201\":1}}],[\"快速排序\",{\"0\":{\"137\":1}}],[\"快排这一步不需要操作\",{\"1\":{\"137\":1}}],[\"快排的一般写法如下\",{\"1\":{\"137\":1}}],[\"快排属于分治算法\",{\"1\":{\"137\":1}}],[\"取一个辨识度更高的方法名即可\",{\"1\":{\"704\":1}}],[\"取一个数的指定位\",{\"1\":{\"158\":1}}],[\"取队首元素但不删除\",{\"1\":{\"649\":1}}],[\"取队首元素并删除\",{\"1\":{\"649\":1}}],[\"取模运算符\",{\"1\":{\"552\":1}}],[\"取模的数用\",{\"1\":{\"241\":1}}],[\"取模加模再取模\",{\"1\":{\"204\":1}}],[\"取这两个值的冲突概率低\",{\"1\":{\"241\":1}}],[\"取走最后一件物品者获胜\",{\"1\":{\"214\":1}}],[\"取走任意多个物品\",{\"1\":{\"214\":1}}],[\"取出当前最外层的烂橘子\",{\"1\":{\"469\":1}}],[\"取出这一层的烂橘子开始遍历\",{\"1\":{\"469\":1}}],[\"取出遍历到的节点\",{\"1\":{\"395\":1}}],[\"取出作为\",{\"1\":{\"175\":1}}],[\"取出b的每一位\",{\"1\":{\"111\":1}}],[\"取反\",{\"1\":{\"157\":1}}],[\"取决于题目对精度的要求\",{\"1\":{\"145\":1}}],[\"取根节点两种方案的最大值\",{\"1\":{\"134\":1}}],[\"保护数据免受硬件故障和无声数据损坏\",{\"1\":{\"668\":1}}],[\"保护你的代理服务器\",{\"0\":{\"346\":1}}],[\"保存数据时\",{\"1\":{\"506\":1}}],[\"保存到浏览器内\",{\"1\":{\"310\":1}}],[\"保存节点信息\",{\"1\":{\"134\":1}}],[\"保障用户的热评浏览体验\",{\"1\":{\"273\":1}}],[\"保证可见性\",{\"1\":{\"702\":1}}],[\"保证了即使在最坏的情况\",{\"1\":{\"668\":1}}],[\"保证元素添加顺序\",{\"1\":{\"646\":1}}],[\"保证事务在不受外部并发操作影响的独立环境下运行\",{\"1\":{\"542\":1}}],[\"保证在一个事务中多次操作数据库表中数据时\",{\"1\":{\"540\":1}}],[\"保证数据的一致性和完整性\",{\"1\":{\"506\":1,\"524\":1}}],[\"保证字段的所有数据都是唯一\",{\"1\":{\"506\":1}}],[\"保证首次遍历的一定是最右边的节点\",{\"1\":{\"389\":1}}],[\"保证每往下遍历新一层时\",{\"1\":{\"389\":1}}],[\"保证对同一个\",{\"1\":{\"264\":1}}],[\"保证单个评论区和单个评论的更新操作是串行的\",{\"1\":{\"264\":1}}],[\"保证少数弱依赖抖动甚至完全不可用情况下评论服务可用\",{\"1\":{\"258\":1}}],[\"保证初始值足够大\",{\"1\":{\"56\":1,\"57\":1}}],[\"走交替路\",{\"1\":{\"183\":1}}],[\"走过的所有点的情况是\",{\"1\":{\"132\":1}}],[\"走到\",{\"1\":{\"132\":1}}],[\"到这一步之后\",{\"1\":{\"346\":2}}],[\"到这个阶段\",{\"1\":{\"273\":1}}],[\"到本地缓存\",{\"1\":{\"294\":1}}],[\"到\",{\"1\":{\"132\":1,\"191\":1,\"209\":1,\"212\":1,\"473\":1}}],[\"到终点和我说声\",{\"1\":{\"231\":1}}],[\"到终点\",{\"1\":{\"43\":1,\"132\":1}}],[\"到终点的代价要大\",{\"1\":{\"36\":1}}],[\"到终点的代价\",{\"1\":{\"36\":2}}],[\"|\",{\"1\":{\"131\":1,\"157\":1,\"158\":6,\"208\":1,\"242\":1,\"345\":1,\"354\":1,\"419\":8,\"701\":1}}],[\"||\",{\"1\":{\"25\":3,\"44\":1,\"48\":3,\"49\":4,\"50\":4,\"55\":1,\"56\":1,\"57\":6,\"111\":3,\"131\":1,\"147\":1,\"149\":1,\"172\":1,\"180\":1,\"183\":1,\"243\":1,\"249\":1,\"313\":1,\"323\":1,\"408\":2,\"432\":1,\"443\":3,\"444\":4,\"475\":1,\"487\":1,\"488\":1,\"518\":1,\"558\":2}}],[\"蒙德里安的梦想\",{\"0\":{\"131\":1}}],[\"后依然有序\",{\"0\":{\"732\":1}}],[\"后移元素\",{\"1\":{\"645\":1}}],[\"后者则会在栈中创建一个对象引用变量\",{\"1\":{\"642\":1}}],[\"后\",{\"1\":{\"559\":1}}],[\"后台服务安装\",{\"0\":{\"663\":1}}],[\"后台启动\",{\"1\":{\"660\":1}}],[\"后台给前端返回的数据包含\",{\"1\":{\"522\":1}}],[\"后台也都需要借助于数据库的分页操作\",{\"1\":{\"522\":1}}],[\"后台运营管理\",{\"1\":{\"255\":1,\"278\":1}}],[\"后组成的新字符串\",{\"1\":{\"449\":1}}],[\"后序遍历先遍历左右子树\",{\"1\":{\"488\":1}}],[\"后序遍历\",{\"0\":{\"401\":1,\"488\":1}}],[\"后并没有出现\",{\"1\":{\"311\":1}}],[\"后端需要响应什么数据给前端\",{\"1\":{\"522\":1}}],[\"后端从\",{\"1\":{\"310\":1}}],[\"后端拿到前端传来的\",{\"1\":{\"310\":1}}],[\"后端初始化\",{\"0\":{\"303\":1}}],[\"后端\",{\"1\":{\"300\":1}}],[\"后续通过注入\",{\"1\":{\"673\":1}}],[\"后续通过调用\",{\"1\":{\"673\":1}}],[\"后续可以通过\",{\"1\":{\"352\":1}}],[\"后续连续的请求\",{\"1\":{\"293\":1}}],[\"后续失败仅仅存在一条\",{\"1\":{\"289\":1}}],[\"后来衍生了更为复杂的热评\",{\"1\":{\"272\":1}}],[\"后进后出\",{\"1\":{\"228\":1}}],[\"后再减\",{\"1\":{\"148\":1}}],[\"后面几行是关键语句\",{\"1\":{\"706\":1}}],[\"后面再申请的时候就很快了\",{\"1\":{\"354\":1}}],[\"后面的配置自行设置即可\",{\"1\":{\"352\":1}}],[\"后面用户状态优化会提到\",{\"1\":{\"310\":1}}],[\"后面一位\",{\"1\":{\"144\":1}}],[\"后面例二中将会给出解决方法\",{\"1\":{\"91\":1}}],[\"后缀部分\",{\"1\":{\"129\":1}}],[\"循环体中只有一条语句时\",{\"1\":{\"563\":1}}],[\"循环不常用\",{\"1\":{\"562\":1}}],[\"循环永久执行\",{\"1\":{\"561\":1}}],[\"循环语句\",{\"0\":{\"560\":1}}],[\"循环将所有节点都作为起点调用一次\",{\"1\":{\"474\":1}}],[\"循环出口\",{\"1\":{\"250\":1}}],[\"循环\",{\"0\":{\"561\":1,\"562\":1,\"563\":1},\"1\":{\"174\":2}}],[\"循环变量i可以表示剩下的数字有多少个\",{\"1\":{\"129\":1}}],[\"循环从1开始\",{\"1\":{\"129\":1}}],[\"边\",{\"1\":{\"174\":1}}],[\"边多\",{\"1\":{\"171\":1}}],[\"边界条件\",{\"1\":{\"129\":1}}],[\"边读边加\",{\"1\":{\"83\":1}}],[\"~$\",{\"1\":{\"680\":5,\"689\":5,\"692\":2}}],[\"~x\",{\"1\":{\"159\":1}}],[\"~0\",{\"1\":{\"158\":1}}],[\"~1\",{\"1\":{\"158\":3}}],[\"~\",{\"1\":{\"129\":1,\"132\":1,\"157\":1,\"158\":2,\"188\":1,\"191\":1,\"200\":1,\"212\":2,\"241\":1,\"242\":1,\"243\":4,\"310\":1,\"323\":1,\"577\":2,\"680\":1}}],[\"~i\",{\"1\":{\"43\":2}}],[\"特点\",{\"0\":{\"668\":1}}],[\"特征\",{\"1\":{\"273\":1}}],[\"特性是先进先出\",{\"1\":{\"649\":1}}],[\"特性\",{\"1\":{\"261\":1}}],[\"特判最中间的数\",{\"1\":{\"195\":1}}],[\"特殊的\",{\"1\":{\"692\":1}}],[\"特殊\",{\"1\":{\"128\":1}}],[\"特别容易引起集群\",{\"1\":{\"281\":1}}],[\"特别是tidb\",{\"1\":{\"273\":1}}],[\"特别是存在\",{\"1\":{\"270\":1}}],[\"特别是诸如\",{\"1\":{\"264\":1}}],[\"特别是一些依赖的变更\",{\"1\":{\"258\":1}}],[\"特别是应用软件对于系统软件的集中的逻辑\",{\"1\":{\"14\":1}}],[\"特别地\",{\"1\":{\"68\":1,\"203\":1,\"218\":1}}],[\"容易引发数据库的死锁问题\",{\"1\":{\"524\":1}}],[\"容易受到干扰而崩溃停止\",{\"1\":{\"353\":1}}],[\"容易导致服务\",{\"1\":{\"281\":1}}],[\"容易造成db抖动\",{\"1\":{\"261\":1}}],[\"容易造成整个系统的腐化\",{\"1\":{\"258\":1}}],[\"容斥原理\",{\"0\":{\"212\":1}}],[\"容量为0时\",{\"1\":{\"128\":2}}],[\"容器化\",{\"1\":{\"668\":1}}],[\"容器\",{\"1\":{\"300\":1,\"661\":1}}],[\"容器的首尾地址\",{\"1\":{\"76\":2}}],[\"容器中以前的内容\",{\"1\":{\"74\":1}}],[\"容器中\",{\"1\":{\"74\":2}}],[\"容器大小\",{\"1\":{\"74\":1}}],[\"朴素并查集\",{\"0\":{\"234\":1}}],[\"朴素筛法\",{\"0\":{\"191\":1}}],[\"朴素prim算法\",{\"0\":{\"180\":1}}],[\"朴素版\",{\"0\":{\"172\":1}}],[\"朴素版的dijkstra算法\",{\"1\":{\"171\":1}}],[\"朴素做法\",{\"1\":{\"128\":1}}],[\"朴素dp写法\",{\"1\":{\"122\":1}}],[\"恰好拼成\",{\"1\":{\"128\":1}}],[\"恰好不重不漏地分布在这\",{\"1\":{\"44\":1,\"99\":1}}],[\"奶牛半懂不懂\",{\"1\":{\"124\":1}}],[\"熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目\",{\"1\":{\"124\":1}}],[\"模糊匹配\",{\"1\":{\"518\":1}}],[\"模型\",{\"1\":{\"320\":1}}],[\"模块\",{\"1\":{\"279\":1}}],[\"模式\",{\"1\":{\"261\":1,\"281\":1}}],[\"模拟堆栈\",{\"1\":{\"122\":1}}],[\"模板代码如下\",{\"1\":{\"127\":1}}],[\"模板代码\",{\"1\":{\"125\":1}}],[\"模板\",{\"0\":{\"2\":1,\"94\":1},\"1\":{\"47\":2},\"2\":{\"135\":1,\"163\":1,\"184\":1,\"220\":1,\"244\":1,\"252\":1}}],[\"单机情况下\",{\"1\":{\"715\":1}}],[\"单机\",{\"1\":{\"715\":1}}],[\"单例的时候\",{\"1\":{\"707\":1}}],[\"单例的实现方法用的是\",{\"1\":{\"702\":1}}],[\"单例中\",{\"1\":{\"706\":1,\"707\":1}}],[\"单引号字符串\",{\"1\":{\"690\":1}}],[\"单引号中的内容会原样输出\",{\"1\":{\"690\":1}}],[\"单引号与双引号的区别\",{\"1\":{\"690\":1}}],[\"单引号定义字符串\",{\"1\":{\"685\":1}}],[\"单表查询的\",{\"1\":{\"529\":1}}],[\"单精度浮点数值\",{\"1\":{\"507\":1}}],[\"单行注释\",{\"0\":{\"682\":1},\"1\":{\"495\":1}}],[\"单元测试库\",{\"1\":{\"300\":1}}],[\"单元测试\",{\"1\":{\"298\":1}}],[\"单进程自适应发现热点\",{\"1\":{\"294\":1}}],[\"单个页面只有二级列表\",{\"1\":{\"263\":1}}],[\"单个评论列表\",{\"1\":{\"261\":1}}],[\"单词查找树\",{\"1\":{\"232\":1}}],[\"单调栈\",{\"0\":{\"227\":1}}],[\"单调队列\",{\"0\":{\"230\":1,\"457\":1},\"2\":{\"459\":1}}],[\"单调队列思维\",{\"1\":{\"122\":1}}],[\"单调队列写法\",{\"1\":{\"122\":1}}],[\"单链表只能存储当前节点的值和指向下一节点的指针\",{\"1\":{\"223\":1}}],[\"单链表\",{\"0\":{\"223\":1}}],[\"单源最短路\",{\"0\":{\"171\":1}}],[\"单位字节\",{\"1\":{\"63\":3}}],[\"组件库\",{\"1\":{\"300\":1}}],[\"组合\",{\"1\":{\"259\":1}}],[\"组装到各个评论卡片之中\",{\"1\":{\"258\":1}}],[\"组询问\",{\"1\":{\"209\":1}}],[\"组成\",{\"1\":{\"545\":1}}],[\"组成的的二维网格\",{\"1\":{\"442\":1}}],[\"组成的\",{\"1\":{\"282\":1,\"545\":1}}],[\"组成的字符串中查找最长的\",{\"1\":{\"64\":1}}],[\"组成一个\",{\"1\":{\"263\":1}}],[\"组成最小生成树\",{\"1\":{\"181\":1}}],[\"组物品和一个容量是\",{\"1\":{\"119\":1}}],[\"≤100\",{\"1\":{\"118\":1}}],[\"多租户支持\",{\"1\":{\"668\":1}}],[\"多线程\",{\"0\":{\"631\":1}}],[\"多线程与锁\",{\"0\":{\"630\":1}}],[\"多态\",{\"1\":{\"602\":1}}],[\"多维数组就是数组的数组\",{\"1\":{\"573\":1}}],[\"多维数组\",{\"0\":{\"573\":1}}],[\"多层循环\",{\"0\":{\"567\":1}}],[\"多路平衡搜索树\",{\"1\":{\"545\":1}}],[\"多表查询时给表起别名\",{\"1\":{\"531\":1}}],[\"多表查询可以分为\",{\"1\":{\"530\":1}}],[\"多表查询\",{\"0\":{\"527\":1},\"1\":{\"529\":2}}],[\"多表设计\",{\"0\":{\"523\":1}}],[\"多对多的关系在开发中属于也比较常见的\",{\"1\":{\"526\":1}}],[\"多对多\",{\"0\":{\"526\":1},\"1\":{\"523\":1}}],[\"多对一\",{\"1\":{\"523\":1}}],[\"多个并发的事务之间要相互隔离\",{\"1\":{\"542\":1}}],[\"多个用户并发的访问数据库时\",{\"1\":{\"542\":1}}],[\"多个条件任意一个成立\",{\"1\":{\"518\":1}}],[\"多个条件同时成立\",{\"1\":{\"518\":1}}],[\"多个评论的操作相互影响\",{\"1\":{\"270\":1}}],[\"多选一\",{\"1\":{\"518\":1,\"536\":1}}],[\"多行注释\",{\"0\":{\"683\":1},\"1\":{\"495\":1}}],[\"多存储节点\",{\"1\":{\"351\":1}}],[\"多用户\",{\"1\":{\"351\":1}}],[\"多了一步操作\",{\"1\":{\"289\":1}}],[\"多样化的数据源\",{\"1\":{\"273\":1}}],[\"多么真实而实用的算法\",{\"1\":{\"183\":1}}],[\"多源汇最短路\",{\"0\":{\"177\":1}}],[\"多重背包\",{\"0\":{\"118\":1}}],[\"多多少少也会有点不足\",{\"1\":{\"58\":1}}],[\"件物品\",{\"1\":{\"116\":1,\"117\":1,\"118\":1}}],[\"没一开始没有k\",{\"1\":{\"647\":1}}],[\"没找到则返回\",{\"1\":{\"642\":2}}],[\"没找到则返回end\",{\"1\":{\"242\":1}}],[\"没事别叫我\",{\"1\":{\"231\":1}}],[\"没有线程安全问题\",{\"1\":{\"673\":1}}],[\"没有明确结构的数据\",{\"1\":{\"666\":1}}],[\"没有返回值的\",{\"1\":{\"593\":1}}],[\"没有此参数重启后失效\",{\"1\":{\"345\":1}}],[\"没有\",{\"1\":{\"289\":1}}],[\"没有入度\",{\"1\":{\"134\":1}}],[\"没有被访问过\",{\"1\":{\"134\":1}}],[\"没有上司的舞会\",{\"0\":{\"134\":1}}],[\"没有比d\",{\"1\":{\"41\":1}}],[\"没用过则标记\",{\"1\":{\"111\":1}}],[\"带\",{\"1\":{\"600\":1}}],[\"带入\",{\"1\":{\"334\":1}}],[\"带入上述公式即可计算出来理想情况下布隆过滤器的二进制数组的长度\",{\"1\":{\"334\":1}}],[\"带入等式中看是否成立\",{\"1\":{\"111\":1}}],[\"带分数中\",{\"1\":{\"111\":1}}],[\"枚举当前状态的每一位\",{\"1\":{\"212\":1}}],[\"枚举每一列c\",{\"1\":{\"205\":1}}],[\"枚举分割点\",{\"1\":{\"127\":1}}],[\"枚举起点\",{\"1\":{\"127\":1}}],[\"枚举从1\",{\"1\":{\"212\":1}}],[\"枚举从\",{\"1\":{\"127\":1}}],[\"枚举a\",{\"1\":{\"111\":1}}],[\"枚举c\",{\"1\":{\"111\":1}}],[\"枚举\",{\"1\":{\"111\":1,\"191\":1}}],[\"枚举位数\",{\"1\":{\"111\":1}}],[\"枚举全排列\",{\"1\":{\"111\":1}}],[\"步骤\",{\"1\":{\"111\":1,\"210\":1,\"230\":1,\"302\":1}}],[\"种表示法\",{\"1\":{\"111\":1}}],[\"类中定义的\",{\"1\":{\"707\":1}}],[\"类中\",{\"1\":{\"703\":1}}],[\"类中的\",{\"1\":{\"618\":2,\"707\":1}}],[\"类在\",{\"1\":{\"648\":1}}],[\"类却要调用一个\",{\"1\":{\"641\":1}}],[\"类使用\",{\"1\":{\"641\":1}}],[\"类用来表示内容可变的字符串\",{\"1\":{\"641\":1}}],[\"类用来表示那些创建后就不会再改变的字符串\",{\"1\":{\"641\":1}}],[\"类及其子类\",{\"1\":{\"617\":1}}],[\"类及其子类异常\",{\"1\":{\"617\":1}}],[\"类的效率更高\",{\"1\":{\"641\":1}}],[\"类的构造函数中初始化了\",{\"1\":{\"619\":1}}],[\"类的多态\",{\"0\":{\"602\":1}}],[\"类的继承\",{\"0\":{\"601\":1}}],[\"类的定义\",{\"0\":{\"600\":1}}],[\"类的类名保持一致\",{\"1\":{\"599\":1}}],[\"类的一个对象\",{\"1\":{\"598\":1}}],[\"类定义一种全新的数据类型\",{\"1\":{\"598\":1}}],[\"类与对象\",{\"0\":{\"598\":1}}],[\"类与接口\",{\"0\":{\"597\":1}}],[\"类可以将变量\",{\"1\":{\"597\":1}}],[\"类\",{\"0\":{\"578\":1},\"1\":{\"424\":1,\"599\":2,\"610\":1,\"625\":1,\"632\":1,\"648\":2,\"655\":1}}],[\"类下编写查询用户接口\",{\"1\":{\"313\":1}}],[\"类似\",{\"1\":{\"603\":1}}],[\"类似于字符串\",{\"1\":{\"698\":1}}],[\"类似于\",{\"1\":{\"655\":1}}],[\"类似于c++中的sprintf\",{\"1\":{\"578\":1}}],[\"类似于栈中的先进后出\",{\"1\":{\"384\":1}}],[\"类似的图存储思路\",{\"1\":{\"289\":1}}],[\"类似这样的带分数\",{\"1\":{\"111\":1}}],[\"类型的\",{\"1\":{\"707\":1}}],[\"类型的对象不止包含字符串\",{\"1\":{\"63\":1}}],[\"类型转换\",{\"1\":{\"642\":1}}],[\"类型转化\",{\"1\":{\"551\":1}}],[\"类型上都属于\",{\"1\":{\"617\":1}}],[\"类型等采用值传递\",{\"1\":{\"590\":1}}],[\"类型\",{\"1\":{\"63\":1,\"264\":2,\"311\":1,\"321\":2,\"486\":2,\"507\":3,\"509\":2,\"551\":1}}],[\"类型对象所能包含的最大字符数\",{\"1\":{\"63\":1}}],[\"类型对象最多包含的字符数\",{\"1\":{\"63\":1}}],[\"类型对象中的字符个数\",{\"1\":{\"63\":1}}],[\"美元\",{\"1\":{\"110\":1}}],[\"翰翰和达达就要付\",{\"1\":{\"110\":1}}],[\"翰翰和达达只好花钱让它们坐索道下山\",{\"1\":{\"110\":1}}],[\"翰翰和达达饲养了\",{\"1\":{\"110\":1}}],[\"呜咕>\",{\"1\":{\"110\":1}}],[\"经过一分钟\",{\"1\":{\"469\":1}}],[\"经过若干操作变为\",{\"1\":{\"126\":1}}],[\"经历了千辛万苦\",{\"1\":{\"110\":1}}],[\"经验\",{\"2\":{\"79\":1}}],[\"剪枝\",{\"1\":{\"109\":1}}],[\"⩽25\",{\"1\":{\"109\":1}}],[\"排列\",{\"1\":{\"436\":1}}],[\"排序在日常开发中是非常常见的一个操作\",{\"1\":{\"521\":1}}],[\"排序查询\",{\"0\":{\"521\":1},\"1\":{\"516\":1}}],[\"排序字段列表\",{\"1\":{\"516\":1}}],[\"排序方式2\",{\"1\":{\"521\":1}}],[\"排序方式1\",{\"1\":{\"521\":1}}],[\"排序方式\",{\"1\":{\"291\":1,\"521\":1}}],[\"排序等\",{\"1\":{\"279\":1}}],[\"排序策略\",{\"1\":{\"273\":1}}],[\"排序过程可解释等等\",{\"1\":{\"273\":1}}],[\"排序我们往往都希望是个性化的\",{\"1\":{\"273\":1}}],[\"排序很像\",{\"1\":{\"273\":1}}],[\"排序\",{\"1\":{\"242\":1,\"243\":2,\"419\":2,\"647\":1}}],[\"排在\",{\"1\":{\"109\":1}}],[\"排成一排\",{\"1\":{\"101\":1}}],[\"依赖于m\",{\"1\":{\"507\":2}}],[\"依赖注入框架\",{\"1\":{\"300\":1}}],[\"依赖其他\",{\"1\":{\"284\":1}}],[\"依赖服务多\",{\"1\":{\"258\":1}}],[\"依次类推\",{\"1\":{\"585\":1}}],[\"依次遍历每个区间\",{\"1\":{\"250\":1}}],[\"依次经过非匹配边\",{\"1\":{\"183\":1}}],[\"依次枚举第一个集合中的每个点能否匹配第二个集合中的点\",{\"1\":{\"183\":1}}],[\"依次枚举\",{\"1\":{\"144\":1}}],[\"依次枚举每个分支\",{\"1\":{\"108\":1}}],[\"依照科学家的预测\",{\"1\":{\"100\":1}}],[\"字节数\",{\"1\":{\"551\":1}}],[\"字节\",{\"1\":{\"545\":2}}],[\"字典树\",{\"2\":{\"428\":1}}],[\"字典序\",{\"1\":{\"242\":1}}],[\"字典序较小的排在前面\",{\"1\":{\"108\":1,\"109\":1}}],[\"字数加权\",{\"1\":{\"272\":1}}],[\"字段3\",{\"1\":{\"517\":1}}],[\"字段列表\",{\"1\":{\"516\":1,\"517\":1,\"518\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"529\":2,\"531\":2,\"532\":2}}],[\"字段更新为\",{\"1\":{\"513\":1}}],[\"字段类型\",{\"1\":{\"509\":1}}],[\"字段类型为\",{\"1\":{\"509\":1}}],[\"字段名2\",{\"1\":{\"512\":2,\"513\":1}}],[\"字段名1\",{\"1\":{\"512\":2,\"513\":1}}],[\"字段名为\",{\"1\":{\"509\":1}}],[\"字段名\",{\"1\":{\"509\":3,\"524\":1,\"546\":1}}],[\"字段n注释\",{\"1\":{\"505\":1}}],[\"字段n类型\",{\"1\":{\"505\":1}}],[\"字段n\",{\"1\":{\"505\":1}}],[\"字段2注释\",{\"1\":{\"505\":1}}],[\"字段2类型\",{\"1\":{\"505\":1}}],[\"字段2\",{\"1\":{\"505\":1,\"517\":2,\"521\":1}}],[\"字段1注释\",{\"1\":{\"505\":1}}],[\"字段1类型\",{\"1\":{\"505\":1}}],[\"字段1\",{\"1\":{\"505\":1,\"517\":2,\"521\":1}}],[\"字段均为驼峰命名\",{\"1\":{\"322\":1}}],[\"字段的类型\",{\"1\":{\"320\":1,\"508\":1}}],[\"字段上加上\",{\"1\":{\"310\":1}}],[\"字段捞出\",{\"1\":{\"289\":1}}],[\"字段大部分都是增量更新\",{\"1\":{\"270\":1}}],[\"字段\",{\"1\":{\"263\":1,\"321\":2,\"496\":1,\"506\":1}}],[\"字符可以参与运算\",{\"1\":{\"577\":1}}],[\"字符与整数的联系\",{\"0\":{\"577\":1}}],[\"字符数组的初始化\",{\"1\":{\"571\":1}}],[\"字符矩阵\",{\"1\":{\"100\":1}}],[\"字符串可以用单引号\",{\"1\":{\"690\":1}}],[\"字符串比较必须能用equals\",{\"1\":{\"642\":1}}],[\"字符串分为两类\",{\"1\":{\"641\":1}}],[\"字符串或向量的排序\",{\"1\":{\"618\":1}}],[\"字符串或者其他对象\",{\"1\":{\"587\":1}}],[\"字符串的第i个位置的字符\",{\"1\":{\"578\":1}}],[\"字符串是计算机与人类沟通的重要手段\",{\"1\":{\"576\":1}}],[\"字符串和日期型数据应该包含在引号中\",{\"1\":{\"512\":1}}],[\"字符串类型\",{\"1\":{\"507\":2}}],[\"字符串中的每个字符都有两种\",{\"1\":{\"450\":1}}],[\"字符串中只包含小写字母\",{\"1\":{\"125\":1}}],[\"字符串哈希\",{\"0\":{\"241\":1}}],[\"字符串以\",{\"1\":{\"232\":1}}],[\"字符串\",{\"0\":{\"63\":1,\"576\":1,\"641\":1,\"690\":1},\"1\":{\"242\":1,\"535\":1}}],[\"首先会拼接默认的配置文件\",{\"1\":{\"706\":1}}],[\"首先遍历左子树\",{\"1\":{\"382\":1}}],[\"首先遍历起点周围邻近的点\",{\"1\":{\"32\":1}}],[\"首先设置安全组\",{\"1\":{\"345\":1}}],[\"首先将用户名都初始化在布隆过滤器中\",{\"1\":{\"334\":1}}],[\"首先在设计一个评论系统之前\",{\"1\":{\"277\":1}}],[\"首先是引入了自适应的冷却算法\",{\"1\":{\"273\":1}}],[\"首先是评论表\",{\"1\":{\"263\":1}}],[\"首先是c端的发评接口会返回展示新评论所需的数据内容\",{\"1\":{\"261\":1}}],[\"首先预处理出所有阶乘取模的余数fact\",{\"1\":{\"208\":1}}],[\"首先\",{\"1\":{\"108\":1,\"109\":1,\"266\":1,\"706\":1}}],[\"共\",{\"1\":{\"200\":1}}],[\"共一行\",{\"1\":{\"101\":1,\"159\":1}}],[\"共有多少种不同的截断方法\",{\"1\":{\"82\":1}}],[\"照片保证第\",{\"1\":{\"100\":1}}],[\"照片中有多少岛屿会被完全淹没\",{\"1\":{\"100\":1}}],[\"构建minioclient对象\",{\"1\":{\"673\":1}}],[\"构建缓存\",{\"1\":{\"293\":1}}],[\"构建依附关系\",{\"1\":{\"93\":1}}],[\"构造函数主要做了以下事情\",{\"1\":{\"717\":1}}],[\"构造函数中调用了\",{\"1\":{\"708\":1}}],[\"构造服务实例\",{\"0\":{\"711\":1}}],[\"构造实例信息管理器\",{\"0\":{\"709\":1}}],[\"构造方法会调用\",{\"1\":{\"705\":1}}],[\"构造器模式\",{\"1\":{\"711\":1}}],[\"构造器\",{\"1\":{\"624\":1}}],[\"构造状态转移方程\",{\"1\":{\"127\":1}}],[\"构造成\",{\"1\":{\"111\":1}}],[\"构造成一个整数和一个分数\",{\"1\":{\"111\":1}}],[\"构成的\",{\"1\":{\"100\":1}}],[\"具有\",{\"1\":{\"506\":1}}],[\"具有非常多的功能\",{\"1\":{\"351\":1}}],[\"具有相同结构和节点值的子树\",{\"1\":{\"24\":1}}],[\"具备水平扩容的弹性\",{\"1\":{\"267\":1}}],[\"具体的代码在\",{\"1\":{\"707\":1}}],[\"具体地\",{\"1\":{\"668\":1}}],[\"具体解决缓存穿透的场景\",{\"1\":{\"334\":1}}],[\"具体实现\",{\"1\":{\"322\":1}}],[\"具体方法是\",{\"1\":{\"216\":1}}],[\"具体步骤\",{\"1\":{\"174\":1}}],[\"具体问题的逻辑\",{\"1\":{\"160\":1}}],[\"具体来说如果一块陆地像素与海洋相邻\",{\"1\":{\"100\":1}}],[\"座岛屿\",{\"1\":{\"100\":1}}],[\"四\",{\"0\":{\"568\":1}}],[\"四大特性\",{\"0\":{\"542\":1}}],[\"四个方向\",{\"1\":{\"469\":1}}],[\"四个方向上连在一起的一片陆地组成一座岛屿\",{\"1\":{\"100\":1}}],[\"四周环绕\",{\"1\":{\"48\":1}}],[\"像上面我们配置了请求转发\",{\"1\":{\"347\":1}}],[\"像素的照片\",{\"1\":{\"100\":1}}],[\"像这种迷宫问题\",{\"1\":{\"58\":1}}],[\"状态更新等\",{\"1\":{\"660\":1}}],[\"状态\",{\"1\":{\"310\":1,\"450\":1}}],[\"状态一致性\",{\"1\":{\"269\":1}}],[\"状态类\",{\"1\":{\"263\":1}}],[\"状态表示\",{\"1\":{\"131\":1}}],[\"状态压缩类dp\",{\"0\":{\"130\":1}}],[\"状态转移方程\",{\"1\":{\"121\":1,\"122\":1,\"123\":1,\"126\":2,\"132\":1,\"134\":1}}],[\"状态转移\",{\"1\":{\"99\":1}}],[\"状态空间\",{\"1\":{\"41\":1}}],[\"已过时\",{\"1\":{\"625\":1}}],[\"已经换成了\",{\"1\":{\"354\":1}}],[\"已简化\",{\"1\":{\"263\":1}}],[\"已访问\",{\"1\":{\"134\":1}}],[\"已知该人每次可以向上\",{\"1\":{\"98\":1}}],[\"已路径压缩\",{\"0\":{\"90\":1}}],[\"处理所有的拷贝操作到其他节点\",{\"1\":{\"717\":1}}],[\"处理注册相关的流程\",{\"0\":{\"716\":1}}],[\"处理\",{\"1\":{\"323\":1}}],[\"处理之前的回源消息也是类似的思路\",{\"1\":{\"282\":1}}],[\"处理发评论请求是无法实现这种串行的\",{\"1\":{\"261\":1}}],[\"处的数字为\",{\"1\":{\"98\":1}}],[\"处和\",{\"1\":{\"98\":1}}],[\"处\",{\"1\":{\"98\":2}}],[\"节省时间\",{\"1\":{\"147\":1,\"148\":1}}],[\"节省查找时间\",{\"1\":{\"94\":1}}],[\"节点大小\",{\"1\":{\"545\":1}}],[\"节点分为\",{\"1\":{\"545\":1}}],[\"节点的右子树只包含\",{\"1\":{\"485\":1}}],[\"节点的左子树只包含\",{\"1\":{\"485\":1}}],[\"节点及其子树节点作为路径终点且路径和为\",{\"1\":{\"480\":1}}],[\"节点按照\",{\"1\":{\"419\":2}}],[\"节点\",{\"1\":{\"35\":1,\"370\":1}}],[\"扁平化处理\",{\"1\":{\"94\":1}}],[\"更容易辨识\",{\"1\":{\"704\":1}}],[\"更偏向于左外连接\",{\"1\":{\"532\":1}}],[\"更简洁的写法\",{\"1\":{\"469\":1}}],[\"更简单的办法\",{\"1\":{\"345\":1}}],[\"更换为程序所在目录\",{\"1\":{\"353\":1}}],[\"更进一步的\",{\"1\":{\"293\":1}}],[\"更可以来一个段子\",{\"1\":{\"274\":1}}],[\"更易扩展的工程化能力\",{\"1\":{\"273\":1}}],[\"更加不容易出现评论区维度的热点\",{\"1\":{\"270\":1}}],[\"更多嵌套层次\",{\"1\":{\"263\":1}}],[\"更像是饭后甜点\",{\"1\":{\"254\":1}}],[\"更新最长路径\",{\"1\":{\"414\":1}}],[\"更新最短距离\",{\"1\":{\"132\":1}}],[\"更新当前根节点的右指针为\",{\"1\":{\"378\":1}}],[\"更新配置\",{\"1\":{\"353\":1}}],[\"更新配置并设置开机启动\",{\"1\":{\"353\":1}}],[\"更新时间\",{\"1\":{\"321\":2}}],[\"更新频率\",{\"1\":{\"273\":1}}],[\"更新区间\",{\"1\":{\"251\":1}}],[\"更新端点和遍历的区间\",{\"1\":{\"250\":1}}],[\"更新右端点\",{\"1\":{\"247\":1}}],[\"更新t\",{\"1\":{\"180\":1}}],[\"更新其他点到集合的距离\",{\"1\":{\"180\":1}}],[\"更新\",{\"1\":{\"175\":1}}],[\"更新两点之间的最短距离\",{\"1\":{\"174\":1}}],[\"更新第一个点到起点的最短距离\",{\"1\":{\"172\":1}}],[\"更新完一个子节点\",{\"1\":{\"134\":1}}],[\"更新前缀计数器\",{\"1\":{\"129\":1}}],[\"更新c\",{\"1\":{\"111\":1}}],[\"更平衡一些\",{\"1\":{\"94\":1}}],[\"更省事\",{\"1\":{\"48\":1}}],[\"树深度\",{\"1\":{\"401\":1}}],[\"树又称字典树\",{\"1\":{\"232\":1}}],[\"树与图的遍历\",{\"0\":{\"166\":1}}],[\"树与图的存储\",{\"0\":{\"165\":1}}],[\"树形dp\",{\"0\":{\"133\":1},\"2\":{\"374\":1}}],[\"树的层级比较深\",{\"1\":{\"545\":1}}],[\"树的结构\",{\"1\":{\"425\":1}}],[\"树的高度一旦高了\",{\"1\":{\"545\":1}}],[\"树的高度\",{\"1\":{\"181\":1,\"234\":1}}],[\"树的高度最坏情况下可能变成\",{\"1\":{\"94\":1}}],[\"树的根节点\",{\"1\":{\"419\":2}}],[\"树的根节点从0开始\",{\"1\":{\"75\":1}}],[\"树的根\",{\"1\":{\"134\":1}}],[\"树\",{\"1\":{\"94\":1}}],[\"洛谷\",{\"0\":{\"94\":1}}],[\"询问是否存在依附关系\",{\"1\":{\"93\":1}}],[\"查看栈顶元素\",{\"1\":{\"648\":1}}],[\"查看索引\",{\"1\":{\"546\":1}}],[\"查看指定表结构\",{\"1\":{\"508\":1}}],[\"查看状态\",{\"1\":{\"353\":1}}],[\"查看\",{\"1\":{\"345\":1,\"545\":1}}],[\"查看当前所有\",{\"1\":{\"345\":1}}],[\"查看防火墙端口\",{\"1\":{\"345\":1}}],[\"查看防火墙规则\",{\"1\":{\"345\":1}}],[\"查看防火墙状态并开启\",{\"1\":{\"345\":1}}],[\"查看端口是否放行成功\",{\"1\":{\"345\":1}}],[\"查看端口号命令\",{\"1\":{\"345\":1}}],[\"查找\",{\"1\":{\"578\":1}}],[\"查找字典树是否包含word前缀\",{\"1\":{\"426\":1}}],[\"查找前缀\",{\"1\":{\"425\":1}}],[\"查找每个键值对的元素\",{\"1\":{\"242\":1}}],[\"查找一个数\",{\"1\":{\"242\":1}}],[\"查找父节点\",{\"1\":{\"94\":1}}],[\"查找根节点\",{\"1\":{\"93\":1}}],[\"查询快\",{\"1\":{\"645\":1}}],[\"查询两表或多表中交集部分数据\",{\"1\":{\"531\":1}}],[\"查询右表所有数据\",{\"1\":{\"530\":1}}],[\"查询左表所有数据\",{\"1\":{\"530\":1}}],[\"查询时从多张表中获取所需数据\",{\"1\":{\"529\":1}}],[\"查询时间序一级评论列表\",{\"1\":{\"263\":1}}],[\"查询页码\",{\"1\":{\"522\":1}}],[\"查询记录数\",{\"1\":{\"522\":1}}],[\"查询其他字段无任何意义\",{\"1\":{\"520\":1}}],[\"查询的字段一般为聚合函数和分组字段\",{\"1\":{\"520\":1}}],[\"查询所有字段\",{\"1\":{\"517\":1}}],[\"查询所有数据库\",{\"1\":{\"499\":1}}],[\"查询多个字段\",{\"1\":{\"517\":1}}],[\"查询分为以下几种类型\",{\"1\":{\"516\":1}}],[\"查询语句\",{\"1\":{\"516\":1}}],[\"查询指定表的建表语句\",{\"1\":{\"508\":1}}],[\"查询表\",{\"1\":{\"503\":1}}],[\"查询当前数据库所有表\",{\"1\":{\"508\":1}}],[\"查询当前数据库\",{\"1\":{\"499\":1}}],[\"查询数据库\",{\"0\":{\"499\":1}}],[\"查询数据库当中是否存在相同用户名\",{\"1\":{\"323\":1}}],[\"查询用户表和部门表中的数据\",{\"1\":{\"529\":1}}],[\"查询用户\",{\"0\":{\"313\":1},\"1\":{\"313\":1}}],[\"查询用户是否存在\",{\"1\":{\"310\":1}}],[\"查询还需要回表\",{\"1\":{\"290\":1}}],[\"查询性能也天差万别\",{\"1\":{\"273\":1}}],[\"查询压力也会非常大\",{\"1\":{\"273\":1}}],[\"查询xxx评论基础信息\",{\"1\":{\"264\":1}}],[\"查询xxx评论列表\",{\"1\":{\"264\":1}}],[\"查询评论区基础信息\",{\"1\":{\"263\":1,\"264\":1}}],[\"查询字符串出现的次数\",{\"1\":{\"232\":1}}],[\"查询一定要进行路径压缩\",{\"1\":{\"90\":1}}],[\"查询\",{\"0\":{\"90\":1,\"508\":1},\"1\":{\"87\":1,\"273\":1,\"498\":1}}],[\"父评论等\",{\"1\":{\"263\":1}}],[\"父节点为它自己\",{\"1\":{\"181\":1}}],[\"父节点设置为自己\",{\"1\":{\"89\":1}}],[\"父亲数组\",{\"1\":{\"93\":1,\"94\":1}}],[\"示例配置在\",{\"1\":{\"346\":1}}],[\"示例\",{\"1\":{\"345\":1,\"507\":1,\"522\":1,\"711\":1}}],[\"示例代码\",{\"1\":{\"93\":1,\"94\":1}}],[\"示例中图形就可以通过让\",{\"1\":{\"44\":1,\"99\":1}}],[\"亲戚关系\",{\"0\":{\"93\":1}}],[\"典例分析\",{\"0\":{\"92\":1}}],[\"粗暴的把\",{\"1\":{\"91\":1}}],[\"假如修改了常量名称\",{\"1\":{\"704\":1}}],[\"假如有编号为\",{\"1\":{\"89\":1}}],[\"假定节点编号是1~n\",{\"1\":{\"234\":1,\"235\":1,\"236\":1}}],[\"假设\",{\"1\":{\"545\":1}}],[\"假设当前节点为\",{\"1\":{\"425\":2}}],[\"假设名为\",{\"1\":{\"344\":1,\"346\":1}}],[\"假设一定存在\",{\"1\":{\"243\":1}}],[\"假设输入都是正数\",{\"1\":{\"189\":1}}],[\"假设目标值在闭区间\",{\"1\":{\"140\":1}}],[\"假设终点第一次出队列时不是最优\",{\"1\":{\"41\":1}}],[\"基于接口的方式\",{\"1\":{\"704\":1}}],[\"基于前缀树结构\",{\"1\":{\"425\":1}}],[\"基于\",{\"1\":{\"289\":1,\"666\":1,\"668\":1}}],[\"基于用户正负样本投票的\",{\"1\":{\"272\":1}}],[\"基于这种冗余设计\",{\"1\":{\"270\":1}}],[\"基于安全\",{\"1\":{\"261\":1}}],[\"基于平衡二叉树\",{\"1\":{\"242\":1}}],[\"基础\",{\"0\":{\"492\":1},\"2\":{\"548\":1,\"638\":1,\"700\":1}}],[\"基础知识\",{\"0\":{\"491\":1,\"549\":1}}],[\"基础功能模块\",{\"0\":{\"255\":1}}],[\"基础算法\",{\"0\":{\"136\":1},\"1\":{\"2\":1}}],[\"基本类型的最大值和最小值\",{\"0\":{\"656\":1}}],[\"基本思想\",{\"1\":{\"563\":1}}],[\"基本思路\",{\"1\":{\"201\":1}}],[\"基本\",{\"1\":{\"557\":1}}],[\"基本信息\",{\"1\":{\"525\":1}}],[\"基本信息+身份信息\",{\"1\":{\"525\":1}}],[\"基本上分为三种\",{\"1\":{\"523\":1}}],[\"基本查询\",{\"0\":{\"517\":1},\"1\":{\"516\":1}}],[\"基本不会修改\",{\"1\":{\"263\":1}}],[\"基本步骤\",{\"1\":{\"175\":1}}],[\"基本模板\",{\"0\":{\"88\":1}}],[\"基本操作主要有\",{\"1\":{\"87\":1}}],[\"递推式\",{\"1\":{\"207\":1}}],[\"递推法求组合数\",{\"0\":{\"207\":1}}],[\"递推求出二维前缀和\",{\"1\":{\"83\":1}}],[\"递归地交换每个节点的左右子树\",{\"1\":{\"462\":1}}],[\"递归的构建左子树与右子树\",{\"1\":{\"438\":1}}],[\"递归的终止情况\",{\"1\":{\"137\":1}}],[\"递归过程\",{\"1\":{\"431\":1}}],[\"递归终止\",{\"1\":{\"420\":1}}],[\"递归终点\",{\"1\":{\"383\":1}}],[\"递归建树\",{\"1\":{\"419\":1}}],[\"递归返回即可\",{\"1\":{\"413\":1}}],[\"递归实现\",{\"1\":{\"401\":1}}],[\"递归遍历\",{\"0\":{\"389\":1},\"1\":{\"475\":1}}],[\"递归结束条件\",{\"1\":{\"431\":1}}],[\"递归结束\",{\"1\":{\"383\":1}}],[\"递归处理左右子树并接收返回值\",{\"1\":{\"366\":1}}],[\"递归处理子问题\",{\"1\":{\"137\":2}}],[\"递归边界使某数变成了0\",{\"1\":{\"197\":1}}],[\"递归排序\",{\"1\":{\"138\":1}}],[\"递归从后往前更新\",{\"1\":{\"134\":1}}],[\"递归出口\",{\"1\":{\"90\":1}}],[\"递归解题的模板\",{\"1\":{\"58\":1}}],[\"递归搜索完成后回退\",{\"1\":{\"55\":1,\"56\":1,\"57\":1}}],[\"递归继续搜索\",{\"1\":{\"55\":1}}],[\"递归后再回溯\",{\"1\":{\"55\":1}}],[\"递归\",{\"0\":{\"378\":1,\"383\":1,\"401\":1},\"1\":{\"48\":1,\"49\":1,\"75\":1,\"197\":1,\"407\":1},\"2\":{\"28\":1,\"113\":1,\"368\":1,\"374\":1,\"386\":1,\"392\":1,\"404\":1,\"410\":1,\"416\":1,\"422\":1,\"434\":1,\"465\":1,\"483\":1,\"490\":1}}],[\"递归左右子树\",{\"1\":{\"25\":1}}],[\"递归相关题型\",{\"0\":{\"106\":1},\"1\":{\"3\":1}}],[\"坐标和价值\",{\"1\":{\"83\":1}}],[\"坐标\",{\"1\":{\"83\":1}}],[\"轴平行\",{\"1\":{\"83\":1}}],[\"激光炸弹的投放是通过卫星定位的\",{\"1\":{\"83\":1}}],[\"先来看第一步\",{\"1\":{\"702\":1}}],[\"先写\",{\"1\":{\"599\":1}}],[\"先减1后取值\",{\"1\":{\"552\":1}}],[\"先取值后减1\",{\"1\":{\"552\":1}}],[\"先取值后加1\",{\"1\":{\"552\":1}}],[\"先加1后取值\",{\"1\":{\"552\":1}}],[\"先开启\",{\"1\":{\"541\":1}}],[\"先找到左右叶子节点\",{\"1\":{\"488\":1}}],[\"先遍历左节点\",{\"1\":{\"487\":1}}],[\"先学习课程\",{\"1\":{\"473\":1}}],[\"先修课程对\",{\"1\":{\"473\":1}}],[\"先修课程按数组\",{\"1\":{\"473\":1}}],[\"先修改前端代码\",{\"1\":{\"326\":1}}],[\"先翻转左右子树\",{\"1\":{\"463\":1}}],[\"先建立根节点\",{\"1\":{\"419\":1}}],[\"先递归右子树\",{\"1\":{\"389\":2}}],[\"先递归再合并\",{\"1\":{\"138\":1}}],[\"先处理这个节点的左子树\",{\"1\":{\"383\":1}}],[\"先序遍历的访问顺序是\",{\"1\":{\"377\":1}}],[\"先序遍历\",{\"0\":{\"377\":1},\"1\":{\"376\":1}}],[\"先记录左子树中的结点数\",{\"1\":{\"365\":1}}],[\"先去阿里云服务器配置\",{\"1\":{\"354\":1}}],[\"先去布隆过滤器中快速进行判断用户名是否已经被使用\",{\"1\":{\"334\":1}}],[\"先说一下各个参数的含义\",{\"1\":{\"334\":1}}],[\"先新建一个文件夹\",{\"1\":{\"302\":1}}],[\"先成功\",{\"1\":{\"289\":1}}],[\"先看一张\",{\"1\":{\"289\":1}}],[\"先读取缓存\",{\"1\":{\"281\":1}}],[\"先读缓存\",{\"1\":{\"261\":1}}],[\"先理解业务背后的本质\",{\"1\":{\"278\":1}}],[\"先做内存合并再更新\",{\"1\":{\"266\":1}}],[\"先进行管理员校验\",{\"1\":{\"313\":1}}],[\"先进先出\",{\"1\":{\"228\":1}}],[\"先进后出\",{\"1\":{\"225\":1}}],[\"先存值\",{\"1\":{\"223\":1}}],[\"先手走不到任何一个必败状态\",{\"1\":{\"214\":1}}],[\"先手\",{\"1\":{\"214\":1}}],[\"先手可以走到某一个必败状态\",{\"1\":{\"214\":1}}],[\"先手进行\",{\"1\":{\"214\":1}}],[\"先整除再乘\",{\"1\":{\"199\":1}}],[\"先累加\",{\"1\":{\"180\":1}}],[\"先把所有距离初始化为正无穷\",{\"1\":{\"180\":1}}],[\"先把第\",{\"1\":{\"159\":1}}],[\"先对数列排序\",{\"1\":{\"144\":1}}],[\"先枚举长度\",{\"1\":{\"127\":1}}],[\"先判断范围和条件\",{\"1\":{\"443\":1}}],[\"先判断第一段是否符合\",{\"1\":{\"82\":1}}],[\"先判断如果\",{\"1\":{\"82\":1}}],[\"先预处理前缀和\",{\"1\":{\"82\":1}}],[\"先后与右\",{\"1\":{\"44\":1,\"99\":1}}],[\"三件套\",{\"1\":{\"300\":1}}],[\"三张表\",{\"1\":{\"289\":1}}],[\"三重循环\",{\"1\":{\"178\":1}}],[\"三\",{\"0\":{\"560\":1,\"729\":1},\"1\":{\"122\":1}}],[\"三个实现类\",{\"1\":{\"646\":1}}],[\"三个元素\",{\"1\":{\"573\":1}}],[\"三个节点\",{\"1\":{\"419\":1}}],[\"三个数的位数可能都不一样\",{\"1\":{\"111\":1}}],[\"三个数\",{\"1\":{\"111\":1}}],[\"三个子数组内各元素之和都相等\",{\"1\":{\"82\":1}}],[\"三种常见的岛屿问题\",{\"1\":{\"51\":1}}],[\"三种岛屿问题的\",{\"1\":{\"47\":1}}],[\"前两行是设置环境名称\",{\"1\":{\"706\":1}}],[\"前台启动\",{\"1\":{\"660\":1}}],[\"前者是\",{\"1\":{\"642\":1}}],[\"前序\",{\"1\":{\"419\":1,\"420\":1}}],[\"前序遍历是最快的\",{\"1\":{\"486\":1}}],[\"前序遍历在某些数据下不需要递归到叶子节点就能返回\",{\"1\":{\"486\":1}}],[\"前序遍历\",{\"0\":{\"486\":1},\"1\":{\"419\":1}}],[\"前序遍历的首元素\",{\"1\":{\"419\":1}}],[\"前序遍历性质\",{\"1\":{\"419\":1}}],[\"前阵子出现了各大知名博主\",{\"1\":{\"350\":1}}],[\"前后端交互\",{\"0\":{\"327\":1}}],[\"前端在请求服务端时\",{\"1\":{\"522\":1}}],[\"前端查询数据库的流程\",{\"1\":{\"522\":1}}],[\"前端使用\",{\"1\":{\"328\":1}}],[\"前端需要向后端发送请求才能获取数据\",{\"1\":{\"328\":1}}],[\"前端请求\",{\"0\":{\"328\":1}}],[\"前端再次请求后端的时候\",{\"1\":{\"310\":1}}],[\"前端接收到后端的命令后\",{\"1\":{\"310\":1}}],[\"前端瘦身\",{\"1\":{\"302\":1}}],[\"前端框架\",{\"1\":{\"302\":1}}],[\"前端初始化\",{\"0\":{\"302\":1}}],[\"前端\",{\"1\":{\"300\":1}}],[\"前需要做一个异构的\",{\"1\":{\"283\":1}}],[\"前置依赖较多的可以流水线调用\",{\"1\":{\"258\":1}}],[\"前置知识\",{\"1\":{\"205\":1}}],[\"前提\",{\"1\":{\"148\":1}}],[\"前缀不存在退出查找\",{\"1\":{\"425\":1}}],[\"前缀树\",{\"0\":{\"423\":1},\"1\":{\"423\":1,\"424\":1}}],[\"前缀方便管理\",{\"1\":{\"311\":1}}],[\"前缀部分\",{\"1\":{\"129\":1}}],[\"前缀和相当于从根节点开始的路径元素和\",{\"1\":{\"480\":1}}],[\"前缀和相关题型\",{\"0\":{\"80\":1},\"1\":{\"3\":1}}],[\"前缀和与差分\",{\"0\":{\"151\":1}}],[\"前缀和的值\",{\"1\":{\"81\":1}}],[\"前缀和\",{\"1\":{\"81\":2},\"2\":{\"85\":1,\"483\":1}}],[\"前\",{\"1\":{\"128\":2}}],[\"前面在\",{\"1\":{\"311\":1}}],[\"前面\",{\"1\":{\"109\":1}}],[\"前面有几个\",{\"1\":{\"81\":1}}],[\"前六个测试点满足\",{\"1\":{\"82\":1}}],[\"说明还需要继续完成某些功能\",{\"1\":{\"593\":1}}],[\"说明目标节点是通过right返回的\",{\"1\":{\"408\":1}}],[\"说明该节点的子树是空子树\",{\"1\":{\"383\":1}}],[\"说明\",{\"1\":{\"321\":2,\"334\":1,\"496\":1,\"502\":1,\"519\":1,\"545\":1,\"619\":1,\"693\":1}}],[\"说明哪个\",{\"1\":{\"281\":1}}],[\"说明这个字符没有匹配上\",{\"1\":{\"425\":1}}],[\"说明这个数是它的一个约数\",{\"1\":{\"195\":1}}],[\"说明这就是大于\",{\"1\":{\"188\":1}}],[\"说明此时root就是最近公共节点\",{\"1\":{\"408\":1}}],[\"说明此时的\",{\"1\":{\"193\":1}}],[\"说明此时遍历到的\",{\"1\":{\"193\":1}}],[\"说明两个顶点已经连通\",{\"1\":{\"181\":1}}],[\"说明图中存在负权回路\",{\"1\":{\"174\":1}}],[\"说明不连通\",{\"1\":{\"172\":1}}],[\"说明存在拓扑序列\",{\"1\":{\"169\":1}}],[\"说明是叶子节点\",{\"1\":{\"134\":1}}],[\"说明从j出发找不到第k短路\",{\"1\":{\"43\":1}}],[\"说人话\",{\"1\":{\"81\":1}}],[\"等各种复杂工作负载以及成为\",{\"1\":{\"668\":1}}],[\"等待线程执行结束\",{\"1\":{\"633\":1}}],[\"等以及用户自定义的\",{\"1\":{\"617\":1}}],[\"等采用引用传递\",{\"1\":{\"591\":1}}],[\"等于\",{\"1\":{\"401\":1,\"518\":1,\"557\":1}}],[\"等靠近国内的延迟会比较低\",{\"1\":{\"344\":1}}],[\"等国内厂商没有问题\",{\"1\":{\"344\":1}}],[\"等数据\",{\"1\":{\"283\":1}}],[\"等数据结构来解决问题\",{\"1\":{\"54\":1}}],[\"等效替代\",{\"1\":{\"204\":1}}],[\"等\",{\"1\":{\"87\":1,\"263\":1,\"264\":1,\"272\":1,\"279\":1,\"289\":1,\"353\":1,\"583\":1,\"615\":1,\"617\":1,\"667\":2}}],[\"等价于~\",{\"1\":{\"242\":1}}],[\"等价于\",{\"1\":{\"81\":1}}],[\"来一份\",{\"1\":{\"729\":1}}],[\"来获取\",{\"1\":{\"721\":1}}],[\"来获取配置项的值\",{\"1\":{\"714\":1}}],[\"来管理集群节点的生命周期\",{\"1\":{\"719\":1}}],[\"来管理\",{\"1\":{\"706\":1,\"708\":1}}],[\"来加载配置文件\",{\"1\":{\"706\":1}}],[\"来看下怎么实现的\",{\"1\":{\"707\":1}}],[\"来看下\",{\"1\":{\"706\":1}}],[\"来关联属于一这方的主键\",{\"1\":{\"524\":1}}],[\"来避免这个问题\",{\"1\":{\"500\":1}}],[\"来连接\",{\"1\":{\"493\":1}}],[\"来存储已经注销的用户名\",{\"1\":{\"334\":1}}],[\"来存储每个元素的父节点\",{\"1\":{\"89\":1}}],[\"来降低误判率\",{\"1\":{\"334\":1}}],[\"来请求后端\",{\"1\":{\"328\":1}}],[\"来保护数据的隐私和安全\",{\"1\":{\"309\":1}}],[\"来进行分片\",{\"1\":{\"294\":1}}],[\"来做加速完全足够\",{\"1\":{\"291\":1}}],[\"来做多条件组合检索\",{\"1\":{\"283\":1}}],[\"来完成的\",{\"1\":{\"283\":1}}],[\"来介绍该系统的功能\",{\"1\":{\"277\":1}}],[\"来实现差异化评论排序的平衡\",{\"1\":{\"273\":1}}],[\"来承担这部分策略探索型业务\",{\"1\":{\"273\":1}}],[\"来支撑热评列表的读写\",{\"1\":{\"273\":1}}],[\"来执行分页查询\",{\"1\":{\"273\":1}}],[\"来验证相应的热点配置与代码实现是符合预期的\",{\"1\":{\"266\":1}}],[\"来解决\",{\"1\":{\"159\":1,\"334\":1}}],[\"来判断是否需要开始调度执行发送心跳\",{\"1\":{\"715\":1}}],[\"来判断是否需要开始调度执行刷新注册表信息\",{\"1\":{\"715\":1}}],[\"来判断\",{\"1\":{\"158\":1,\"486\":1}}],[\"来决定\",{\"1\":{\"158\":1}}],[\"来递加\",{\"1\":{\"81\":1}}],[\"来求出\",{\"1\":{\"81\":1}}],[\"来记录搜索过的元素\",{\"1\":{\"48\":1}}],[\"你的终端或\",{\"1\":{\"660\":1}}],[\"你的程序将得到一个判断错误的答案\",{\"1\":{\"69\":1}}],[\"你需要先完成课程\",{\"1\":{\"473\":1}}],[\"你需要完成合并和查询操作\",{\"1\":{\"94\":1}}],[\"你这个学期必须选修\",{\"1\":{\"473\":1}}],[\"你只可以看到在滑动窗口内的\",{\"1\":{\"455\":1}}],[\"你可以继续执行其他命令\",{\"1\":{\"660\":1}}],[\"你可以假设该网格的四条边均被水包围\",{\"1\":{\"442\":1}}],[\"你可以使用原地算法\",{\"1\":{\"376\":1}}],[\"你可能会用到的一些插件\",{\"1\":{\"340\":1}}],[\"你将如何优化算法\",{\"1\":{\"364\":1}}],[\"你将会获得一些配置参数和\",{\"1\":{\"344\":1}}],[\"你每次使用代理客户端时\",{\"1\":{\"346\":1}}],[\"你有没有备胎\",{\"1\":{\"183\":1}}],[\"你有一张某海域\",{\"1\":{\"100\":1}}],[\"你就去问问她男朋友\",{\"1\":{\"183\":1}}],[\"你能求出数列中总共有多少个\",{\"1\":{\"81\":1}}],[\"创建上下文的持有者\",{\"0\":{\"721\":1}}],[\"创建这个对象时\",{\"1\":{\"710\":1}}],[\"创建了一个支持\",{\"1\":{\"715\":1}}],[\"创建了一个支持缓存刷新的线程池\",{\"1\":{\"715\":1}}],[\"创建了一个支持心跳检测的线程池\",{\"1\":{\"715\":1}}],[\"创建了一个支持任务调度的线程池\",{\"1\":{\"715\":1}}],[\"创建了一个\",{\"1\":{\"710\":1,\"715\":1,\"717\":1,\"719\":1,\"720\":1,\"721\":1}}],[\"创建一个\",{\"1\":{\"708\":1}}],[\"创建默认的\",{\"0\":{\"705\":1}}],[\"创建文件\",{\"1\":{\"692\":1}}],[\"创建存储桶的时候\",{\"1\":{\"675\":1}}],[\"创建对象\",{\"1\":{\"643\":1}}],[\"创建索引\",{\"1\":{\"546\":1}}],[\"创建表时指定\",{\"1\":{\"524\":1}}],[\"创建表\",{\"1\":{\"503\":1}}],[\"创建数据库\",{\"0\":{\"500\":1}}],[\"创建完成后系统会为此账号自动生成密码\",{\"1\":{\"357\":1}}],[\"创建供\",{\"1\":{\"357\":1}}],[\"创建新账号\",{\"1\":{\"357\":1}}],[\"创建证书\",{\"1\":{\"354\":1}}],[\"创建配置文件\",{\"1\":{\"353\":1}}],[\"创建分享链接等等\",{\"1\":{\"352\":1}}],[\"创建时间\",{\"1\":{\"321\":2}}],[\"创建方式二\",{\"1\":{\"77\":1}}],[\"创建方式一\",{\"1\":{\"77\":1}}],[\"创建\",{\"0\":{\"504\":1},\"1\":{\"77\":1,\"357\":1,\"498\":1,\"715\":1}}],[\"接受一个集合容器\",{\"1\":{\"645\":1}}],[\"接着会访问根节点的右子树节点\",{\"1\":{\"377\":1}}],[\"接收请求并解析参数\",{\"1\":{\"311\":1}}],[\"接收参数\",{\"1\":{\"76\":2,\"308\":1}}],[\"接口里面定义很多\",{\"1\":{\"707\":1}}],[\"接口协议\",{\"1\":{\"668\":1}}],[\"接口实际上扩展自\",{\"1\":{\"650\":1}}],[\"接口或者是\",{\"1\":{\"647\":1}}],[\"接口时\",{\"1\":{\"618\":1}}],[\"接口的\",{\"1\":{\"707\":1}}],[\"接口的多态\",{\"0\":{\"607\":1}}],[\"接口的实现\",{\"0\":{\"606\":1}}],[\"接口的继承\",{\"0\":{\"605\":1}}],[\"接口的定义\",{\"0\":{\"604\":1}}],[\"接口中不添加修饰符时\",{\"1\":{\"604\":1}}],[\"接口也可以继承其他接口\",{\"1\":{\"603\":1}}],[\"接口\",{\"0\":{\"603\":1},\"1\":{\"315\":1,\"609\":1,\"611\":1,\"612\":1,\"613\":1,\"632\":1,\"647\":3,\"649\":2,\"651\":2,\"667\":1,\"708\":1}}],[\"接口设计关键\",{\"1\":{\"312\":1}}],[\"接口设计\",{\"0\":{\"308\":1}}],[\"接口错误导致用户操作失败\",{\"1\":{\"270\":1}}],[\"接口qps与cpu\",{\"1\":{\"266\":1}}],[\"接下来在\",{\"1\":{\"311\":1}}],[\"接下来\",{\"1\":{\"43\":1,\"83\":1,\"94\":1,\"98\":1,\"125\":1,\"474\":1}}],[\"捕获异常\",{\"0\":{\"620\":1}}],[\"捕获业务逻辑异常做出反馈\",{\"1\":{\"311\":1}}],[\"捕获\",{\"1\":{\"75\":1}}],[\"就更新\",{\"1\":{\"722\":1}}],[\"就通过\",{\"1\":{\"721\":2}}],[\"就调用副本的\",{\"1\":{\"715\":1}}],[\"就调用对应的\",{\"1\":{\"708\":1}}],[\"就会从缓存里面这个默认值\",{\"1\":{\"706\":1}}],[\"就会造成数的高度比较高\",{\"1\":{\"545\":1}}],[\"就需要自己自定义排序方式\",{\"1\":{\"647\":1}}],[\"就需要通过该指令\",{\"1\":{\"501\":1}}],[\"就被称为元注解\",{\"1\":{\"626\":1}}],[\"就要付出较高的公网带宽传输成本\",{\"1\":{\"667\":1}}],[\"就要立即将这个功能应用到实践中\",{\"1\":{\"556\":1}}],[\"就要加入队列并标记为\",{\"1\":{\"444\":1}}],[\"就有\",{\"1\":{\"545\":1}}],[\"就满足这种要求\",{\"1\":{\"545\":1}}],[\"就进行事务的回滚\",{\"1\":{\"540\":1}}],[\"就占用多少个字符\",{\"1\":{\"507\":1}}],[\"就意味着有橘子永远不会腐烂\",{\"1\":{\"468\":1}}],[\"就把\",{\"1\":{\"468\":1}}],[\"就把k改为l\",{\"1\":{\"224\":1}}],[\"就可以找到\",{\"1\":{\"545\":1}}],[\"就可以很方便的解决上述问题\",{\"1\":{\"524\":1}}],[\"就可以查询到当前所处的数据库\",{\"1\":{\"499\":1}}],[\"就可以起到不走回头路的作用\",{\"1\":{\"443\":1}}],[\"就可以把埃氏筛法运用在\",{\"1\":{\"192\":1}}],[\"就用\",{\"1\":{\"443\":1}}],[\"就返回right\",{\"1\":{\"408\":1}}],[\"就返回\",{\"1\":{\"408\":1}}],[\"就返回祖先\",{\"1\":{\"90\":1}}],[\"就将上一个节点的右指针更新为当前节点\",{\"1\":{\"378\":1}}],[\"就将这条边加入集合中\",{\"1\":{\"181\":1}}],[\"就像一个存储服务\",{\"1\":{\"356\":1}}],[\"就不能再使用表名来指定对应的字段了\",{\"1\":{\"531\":1}}],[\"就不用递归右子树了\",{\"1\":{\"488\":1}}],[\"就不用遍历了\",{\"1\":{\"475\":1}}],[\"就不会发现任何异常\",{\"1\":{\"346\":1}}],[\"就不是公平组合游戏\",{\"1\":{\"215\":1}}],[\"就不是用最小质因子去更新了\",{\"1\":{\"193\":1}}],[\"就表示停止\",{\"1\":{\"345\":1}}],[\"就代表热度高\",{\"1\":{\"272\":3}}],[\"就删去了所有的合数\",{\"1\":{\"191\":1}}],[\"就得到了最短路径\",{\"1\":{\"175\":1}}],[\"就说明存在一条长度是n+1的最短路径\",{\"1\":{\"174\":1}}],[\"就交换位置\",{\"1\":{\"237\":1}}],[\"就交换\",{\"1\":{\"137\":1}}],[\"就是获取配置管理类的一个单例\",{\"1\":{\"702\":1}}],[\"就是最后一层子节点\",{\"1\":{\"545\":1}}],[\"就是不再像红黑树一样每个节点只能保存一个数据\",{\"1\":{\"545\":1}}],[\"就是使用索引可以提高查询的效率\",{\"1\":{\"544\":1}}],[\"就是来保证数据库当中数据的正确性\",{\"1\":{\"506\":1}}],[\"就是根节点的左右子树的最大深度之和\",{\"1\":{\"413\":1}}],[\"就是根据各种要素排序的得分\",{\"1\":{\"291\":1}}],[\"就是根评论\",{\"1\":{\"289\":1}}],[\"就是回复的评论\",{\"1\":{\"289\":1}}],[\"就是评论\",{\"1\":{\"289\":1,\"291\":1}}],[\"就是读请求未命中缓存穿透到db\",{\"1\":{\"261\":1}}],[\"就是判断\",{\"1\":{\"201\":1}}],[\"就是一个质因数\",{\"1\":{\"191\":1}}],[\"就是\",{\"1\":{\"182\":1,\"193\":1}}],[\"就是给定一个无向图\",{\"1\":{\"179\":1}}],[\"就是奇数\",{\"1\":{\"158\":1}}],[\"就是偶数\",{\"1\":{\"158\":1}}],[\"就是其爆炸范围\",{\"1\":{\"83\":1}}],[\"就是区间\",{\"1\":{\"81\":1}}],[\"就是上下左右全部被海水包围\",{\"1\":{\"49\":1}}],[\"就默认添加此选项\",{\"1\":{\"75\":1}}],[\"让他们保持同步\",{\"1\":{\"717\":1}}],[\"让两张表的数据建立连接\",{\"1\":{\"506\":1,\"524\":1}}],[\"让\",{\"1\":{\"75\":1,\"346\":1}}],[\"让终点出队k次\",{\"1\":{\"43\":1}}],[\"指明\",{\"1\":{\"680\":1}}],[\"指示索引或者为负\",{\"1\":{\"618\":1}}],[\"指示存在安全侵犯\",{\"1\":{\"618\":1}}],[\"指示某排序索引\",{\"1\":{\"618\":1}}],[\"指向它\",{\"1\":{\"642\":2}}],[\"指向\",{\"1\":{\"474\":1}}],[\"指向的下一节点\",{\"1\":{\"223\":1}}],[\"指定文件路径\",{\"1\":{\"676\":1}}],[\"指定\",{\"1\":{\"660\":1}}],[\"指定数据存放位置\",{\"1\":{\"660\":1}}],[\"指定minio密码\",{\"1\":{\"660\":1}}],[\"指定minio的用户名\",{\"1\":{\"660\":1}}],[\"指定容量的空数组列表\",{\"1\":{\"645\":1}}],[\"指定注解可以用在哪些地方\",{\"1\":{\"626\":1}}],[\"指定注解的作用范围\",{\"1\":{\"626\":1}}],[\"指定列下相同的数据归为一类\",{\"1\":{\"520\":1}}],[\"指定字段\",{\"1\":{\"512\":1}}],[\"指定的字段顺序需要与值的顺序是一一对应的\",{\"1\":{\"512\":1}}],[\"指定的长度为最大占用长度\",{\"1\":{\"507\":1}}],[\"指定的部分应该是提前排好序的\",{\"1\":{\"243\":1}}],[\"指定的部分上执行二分查找\",{\"1\":{\"243\":1}}],[\"指定的部分进行快速排序\",{\"1\":{\"243\":1}}],[\"指定长度多长\",{\"1\":{\"507\":1}}],[\"指定驱动器号\",{\"1\":{\"358\":1}}],[\"指定域名\",{\"1\":{\"354\":1}}],[\"指定了字段映射关系\",{\"1\":{\"322\":1}}],[\"指定接口全局路径前缀\",{\"1\":{\"311\":1}}],[\"指边相对于点不多\",{\"1\":{\"171\":1}}],[\"指针域\",{\"1\":{\"545\":1}}],[\"指针\",{\"1\":{\"75\":1,\"243\":3,\"545\":1}}],[\"指的是两个斜着相邻节点之间的移动代价\",{\"1\":{\"39\":1}}],[\"变得不可使用\",{\"1\":{\"645\":1}}],[\"变长字符串\",{\"1\":{\"507\":1}}],[\"变长数组\",{\"1\":{\"242\":1,\"609\":1}}],[\"变换\",{\"1\":{\"205\":1}}],[\"变换串\",{\"1\":{\"99\":1}}],[\"变\",{\"1\":{\"158\":2}}],[\"变成b\",{\"1\":{\"126\":1}}],[\"变为\",{\"1\":{\"126\":1}}],[\"变为海水\",{\"1\":{\"50\":1}}],[\"变量定义成了\",{\"1\":{\"702\":1}}],[\"变量定义的方式\",{\"1\":{\"551\":1}}],[\"变量类型\",{\"0\":{\"689\":1}}],[\"变量的作用域\",{\"0\":{\"588\":1}}],[\"变量必须先定义\",{\"1\":{\"551\":1}}],[\"变量\",{\"0\":{\"551\":1,\"684\":1},\"1\":{\"75\":2,\"600\":3,\"704\":1,\"721\":1}}],[\"表面上拼接字符串时\",{\"1\":{\"641\":1}}],[\"表面看它就是一个平平无奇的服务器而已\",{\"1\":{\"346\":1}}],[\"表子查询\",{\"0\":{\"538\":1},\"1\":{\"534\":1}}],[\"表2\",{\"1\":{\"529\":1,\"531\":2,\"532\":2}}],[\"表1\",{\"1\":{\"529\":1,\"531\":2,\"532\":2}}],[\"表中\",{\"1\":{\"513\":1}}],[\"表中有哪些字段\",{\"1\":{\"320\":1}}],[\"表添加字段\",{\"1\":{\"509\":1}}],[\"表注释\",{\"1\":{\"505\":1}}],[\"表名列表\",{\"1\":{\"516\":1}}],[\"表名不存在\",{\"1\":{\"510\":1}}],[\"表名\",{\"1\":{\"505\":1,\"508\":2,\"509\":5,\"510\":1,\"512\":4,\"513\":1,\"514\":1,\"517\":4,\"518\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"524\":2,\"529\":1,\"546\":3}}],[\"表操作\",{\"0\":{\"503\":1}}],[\"表\",{\"1\":{\"496\":1,\"498\":1}}],[\"表与表之间的关联\",{\"1\":{\"320\":1}}],[\"表格\",{\"1\":{\"319\":1}}],[\"表里有一些统计字段\",{\"1\":{\"290\":1}}],[\"表里捞出来一堆\",{\"1\":{\"289\":1}}],[\"表找到根评论列表\",{\"1\":{\"289\":1}}],[\"表还有自己的自增主键的话\",{\"1\":{\"289\":1}}],[\"表了\",{\"1\":{\"289\":1}}],[\"表都有主键\",{\"1\":{\"289\":1}}],[\"表的\",{\"1\":{\"289\":1}}],[\"表的两部分字段\",{\"1\":{\"264\":1}}],[\"表和\",{\"1\":{\"264\":1}}],[\"表达式\",{\"0\":{\"553\":1},\"1\":{\"75\":1,\"563\":1}}],[\"表达式拥有和当前类成员函数同样的访问权限\",{\"1\":{\"75\":1}}],[\"表达式的语法形式可简单归纳如下\",{\"1\":{\"75\":1}}],[\"表达式定义了一个匿名函数\",{\"1\":{\"75\":1}}],[\"表示存储桶是否存在\",{\"1\":{\"675\":1}}],[\"表示键值对\",{\"1\":{\"655\":1}}],[\"表示两个元素需要更换位置\",{\"1\":{\"651\":1}}],[\"表示泛型\",{\"1\":{\"645\":1}}],[\"表示字符串\",{\"1\":{\"579\":1}}],[\"表示当前遍历到的节点为\",{\"1\":{\"480\":1}}],[\"表示当前摆到第\",{\"1\":{\"131\":1}}],[\"表示出现了环\",{\"1\":{\"475\":1}}],[\"表示出口\",{\"1\":{\"55\":1}}],[\"表示回到了起点\",{\"1\":{\"474\":1}}],[\"表示如果要学习课程\",{\"1\":{\"473\":1}}],[\"表示一个完整的字符串\",{\"1\":{\"426\":1}}],[\"表示一次询问中满足条件的字符串个数\",{\"1\":{\"125\":1}}],[\"表示一次询问\",{\"1\":{\"125\":1}}],[\"表示该节点是否为字符串的结尾\",{\"1\":{\"425\":1}}],[\"表示大小\",{\"1\":{\"237\":1}}],[\"表示堆\",{\"1\":{\"237\":1}}],[\"表示祖宗节点所在集合中的点的数量\",{\"1\":{\"235\":1}}],[\"表示队头\",{\"1\":{\"229\":1}}],[\"表示节点的右指针\",{\"1\":{\"224\":1}}],[\"表示节点的左指针\",{\"1\":{\"224\":1}}],[\"表示节点的值\",{\"1\":{\"224\":1}}],[\"表示每个点的颜色\",{\"1\":{\"182\":1}}],[\"表示a到b的距离\",{\"1\":{\"178\":1}}],[\"表示1号点已经被遍历过\",{\"1\":{\"168\":1}}],[\"表示边数\",{\"1\":{\"166\":1,\"169\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1}}],[\"表示补码\",{\"1\":{\"159\":1}}],[\"表示整个数列\",{\"1\":{\"159\":1}}],[\"表示精度\",{\"1\":{\"145\":1}}],[\"表示所有点都走过了\",{\"1\":{\"132\":1}}],[\"表示从a个苹果中选b个的方案数\",{\"1\":{\"207\":1}}],[\"表示从\",{\"1\":{\"132\":1}}],[\"表示从左上角移动至右下角的最少移动次数\",{\"1\":{\"98\":1}}],[\"表示前\",{\"1\":{\"128\":1}}],[\"表示给定的字符串\",{\"1\":{\"125\":1}}],[\"表示最长公共上升子序列的长度\",{\"1\":{\"124\":1}}],[\"表示最少需要多少美元\",{\"1\":{\"110\":1}}],[\"表示最少交换次数\",{\"1\":{\"99\":1}}],[\"表示数列\",{\"1\":{\"124\":3}}],[\"表示总体积是i的情况下\",{\"1\":{\"116\":1,\"117\":1}}],[\"表示海洋\",{\"1\":{\"100\":2}}],[\"表示海⽔\",{\"1\":{\"49\":1}}],[\"表示变换到某个字符串时需要的交换次数\",{\"1\":{\"99\":1}}],[\"表示完整的二维数组迷宫\",{\"1\":{\"98\":1}}],[\"表示不可通过的墙壁\",{\"1\":{\"98\":1}}],[\"表示可以走的路\",{\"1\":{\"98\":1}}],[\"表示可走的路\",{\"1\":{\"55\":1}}],[\"表示共有\",{\"1\":{\"94\":1}}],[\"表示询问\",{\"1\":{\"93\":1}}],[\"表示\",{\"1\":{\"93\":1,\"149\":1,\"150\":1,\"182\":1,\"208\":1,\"473\":1,\"555\":1,\"598\":1}}],[\"表示目标在地图上的位置\",{\"1\":{\"83\":1}}],[\"表示截断方法数量\",{\"1\":{\"82\":1}}],[\"表示这个前缀和的值\",{\"1\":{\"81\":1}}],[\"表示捕获当前类中的\",{\"1\":{\"75\":1}}],[\"表示捕获外部作用域中所有变量\",{\"1\":{\"75\":2}}],[\"表示按值捕获外部作用域中所有变量\",{\"1\":{\"75\":1}}],[\"表示size\",{\"1\":{\"72\":1}}],[\"表示墙\",{\"1\":{\"55\":1}}],[\"表示起点\",{\"1\":{\"55\":1}}],[\"表示陆地\",{\"1\":{\"49\":1,\"100\":2}}],[\"表示得到正确排列的完整行动记录\",{\"1\":{\"44\":1}}],[\"表示第二个集合中的每个点是否已经被遍历过\",{\"1\":{\"183\":1}}],[\"表示第\",{\"1\":{\"43\":1,\"81\":1}}],[\"表示点j已经被遍历过\",{\"1\":{\"168\":1}}],[\"表示点u已经被遍历过\",{\"1\":{\"167\":1}}],[\"表示点数\",{\"1\":{\"166\":1,\"169\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1}}],[\"表示点\",{\"1\":{\"43\":1}}],[\"功能模块\",{\"0\":{\"278\":1}}],[\"功能\",{\"1\":{\"74\":1,\"518\":2,\"519\":1}}],[\"该命令也会继续执行\",{\"1\":{\"660\":1}}],[\"该注解只能用于函数\",{\"1\":{\"625\":2}}],[\"该实参能自动转换成int类型\",{\"1\":{\"585\":1}}],[\"该行不会被统计在其中\",{\"1\":{\"519\":1}}],[\"该路径\",{\"1\":{\"370\":1}}],[\"该用户名可能已经被使用了\",{\"1\":{\"334\":1}}],[\"该插件是\",{\"1\":{\"334\":1}}],[\"该游戏被称为有向图游戏\",{\"1\":{\"216\":1}}],[\"该点到它本身的路径赋为0\",{\"1\":{\"175\":1}}],[\"该表格的初始值要赋为极大值\",{\"1\":{\"175\":1}}],[\"该式被称为三角不等式\",{\"1\":{\"174\":1}}],[\"该人从左上角移动至右下角\",{\"1\":{\"98\":1}}],[\"该如何想办法避免树的不平衡呢\",{\"1\":{\"94\":1}}],[\"该函数常用于离散化\",{\"1\":{\"243\":1}}],[\"该函数有唯一的返回类型\",{\"1\":{\"72\":1}}],[\"该函数返回字符串的首字符的地址\",{\"1\":{\"63\":1}}],[\"该函数返回在重新分配内存之前\",{\"1\":{\"63\":1}}],[\"该值表示\",{\"1\":{\"72\":1}}],[\"转byte\",{\"1\":{\"642\":1}}],[\"转化一下\",{\"1\":{\"413\":1}}],[\"转化为求中序遍历的第k个节点\",{\"1\":{\"363\":1}}],[\"转化为\",{\"1\":{\"111\":1}}],[\"转化为数字\",{\"1\":{\"111\":1}}],[\"转到下载的文件夹目录\",{\"1\":{\"352\":1}}],[\"转载自悟空聊架构\",{\"1\":{\"701\":1}}],[\"转载自stormspirit\",{\"1\":{\"277\":1,\"287\":1}}],[\"转载自哔哩哔哩技术\",{\"1\":{\"253\":1}}],[\"转换为string\",{\"1\":{\"642\":1}}],[\"转换\",{\"1\":{\"71\":3}}],[\"转\",{\"0\":{\"732\":1},\"1\":{\"71\":2}}],[\"zsh\",{\"1\":{\"680\":1}}],[\"zeus\",{\"1\":{\"606\":2,\"607\":1}}],[\"zxvf\",{\"1\":{\"352\":1}}],[\"zipdateformat>\",{\"1\":{\"663\":1}}],[\"zip\",{\"1\":{\"347\":2}}],[\"zi​=2\",{\"1\":{\"94\":2}}],[\"zi​=1\",{\"1\":{\"94\":1}}],[\"zi​\",{\"1\":{\"94\":1}}],[\"zone=public\",{\"1\":{\"345\":2}}],[\"zdd\",{\"1\":{\"291\":1}}],[\"zhang\",{\"1\":{\"323\":1}}],[\"zhangsan\",{\"1\":{\"323\":5}}],[\"zhihu\",{\"1\":{\"274\":1}}],[\"zhuanlan\",{\"1\":{\"274\":1}}],[\"zh\",{\"1\":{\"274\":1}}],[\"zrem\",{\"1\":{\"264\":1}}],[\"zadd\",{\"1\":{\"264\":1}}],[\"z\",{\"1\":{\"70\":1,\"94\":4,\"554\":1,\"577\":2}}],[\"9e0ebfcd82d7\",{\"1\":{\"680\":5,\"689\":5,\"692\":2}}],[\"9<\",{\"1\":{\"672\":1}}],[\"9是\",{\"1\":{\"577\":1}}],[\"9000\",{\"1\":{\"661\":2,\"662\":1,\"673\":1}}],[\"9001\",{\"1\":{\"660\":3,\"661\":3,\"662\":1}}],[\"90\",{\"1\":{\"577\":1}}],[\"98\",{\"1\":{\"484\":1}}],[\"94\",{\"1\":{\"381\":1}}],[\"967\",{\"1\":{\"507\":2}}],[\"96\",{\"1\":{\"274\":1}}],[\"95\",{\"1\":{\"274\":1}}],[\"994\",{\"1\":{\"466\":1}}],[\"999\",{\"1\":{\"274\":1}}],[\"99999999\",{\"1\":{\"57\":2}}],[\"9999\",{\"1\":{\"56\":2,\"507\":2}}],[\"99\",{\"1\":{\"129\":3}}],[\"9​\",{\"1\":{\"111\":1}}],[\"9\",{\"0\":{\"70\":1,\"162\":1,\"212\":1,\"242\":1,\"615\":1,\"616\":1,\"617\":1,\"618\":1,\"619\":1,\"620\":1,\"621\":1,\"622\":1},\"1\":{\"93\":2,\"99\":1,\"100\":1,\"111\":5,\"129\":19,\"563\":1,\"573\":1,\"574\":1}}],[\"问先手是否必胜\",{\"1\":{\"214\":1}}],[\"问区间\",{\"1\":{\"192\":1}}],[\"问完一个问题后\",{\"1\":{\"69\":1}}],[\"问题枚举时\",{\"1\":{\"127\":1}}],[\"问题的关键在于\",{\"1\":{\"94\":1}}],[\"问题\",{\"1\":{\"69\":1,\"273\":1,\"334\":4}}],[\"答案是\",{\"1\":{\"673\":1}}],[\"答案存在右子树中\",{\"1\":{\"366\":1}}],[\"答案在哪一侧\",{\"1\":{\"143\":1}}],[\"答案在右边界\",{\"1\":{\"142\":1}}],[\"答案在左边界\",{\"1\":{\"141\":1}}],[\"答案\",{\"1\":{\"69\":1,\"545\":1}}],[\"要注意到图中并不一定所有节点都相连\",{\"1\":{\"474\":1}}],[\"要么全部成功\",{\"1\":{\"542\":1}}],[\"要么全部失败\",{\"1\":{\"542\":2}}],[\"要么全都失败\",{\"1\":{\"540\":1}}],[\"要么全都成功\",{\"1\":{\"540\":1}}],[\"要么同时失败\",{\"1\":{\"540\":1}}],[\"要么所有的\",{\"1\":{\"540\":1}}],[\"要么不在\",{\"1\":{\"450\":1}}],[\"要么在\",{\"1\":{\"450\":1}}],[\"要解决这个问题的话\",{\"1\":{\"378\":1}}],[\"要先在后台管理面板为对应用户组开启\",{\"1\":{\"357\":1}}],[\"要和数据库中的密文密码\",{\"1\":{\"309\":1}}],[\"要权衡社会价值观引导\",{\"1\":{\"272\":1}}],[\"要上取整\",{\"1\":{\"142\":1}}],[\"要向下取整\",{\"1\":{\"141\":1}}],[\"要求非空且唯一\",{\"1\":{\"506\":1}}],[\"要求分成若干组\",{\"1\":{\"249\":1}}],[\"要求求解这个方程组\",{\"1\":{\"205\":1}}],[\"要求边长之和最小\",{\"1\":{\"179\":1}}],[\"要求计算\",{\"1\":{\"149\":1,\"150\":1}}],[\"要求计算出所有\",{\"1\":{\"144\":1}}],[\"要求找出一条路径\",{\"1\":{\"121\":1}}],[\"要求将\",{\"1\":{\"111\":1}}],[\"要求\",{\"1\":{\"82\":1}}],[\"要将该数组从中间截断\",{\"1\":{\"82\":1}}],[\"要输出行的末尾并刷新输出\",{\"1\":{\"69\":1}}],[\"要给出最终答案\",{\"1\":{\"69\":1}}],[\"要使用\",{\"1\":{\"63\":1,\"357\":1}}],[\"然后放到注册表里面\",{\"1\":{\"722\":1}}],[\"然后想要获取上下文的就调用\",{\"1\":{\"721\":1}}],[\"然后停止执行过期应用\",{\"1\":{\"717\":1}}],[\"然后还创建了一个实例信息的副本\",{\"1\":{\"715\":1}}],[\"然后还要在服务器上\",{\"1\":{\"345\":1}}],[\"然后交给\",{\"1\":{\"708\":1}}],[\"然后交换左右子节点\",{\"1\":{\"463\":1}}],[\"然后这些配置项统一都交给\",{\"1\":{\"706\":1}}],[\"然后获取环境的配置文件的配置项并覆盖之前的默认配置项\",{\"1\":{\"706\":1}}],[\"然后获取默认配置文件的配置项\",{\"1\":{\"706\":1}}],[\"然后执行该脚本\",{\"1\":{\"692\":1}}],[\"然后查看字符串池中是否存在\",{\"1\":{\"642\":1}}],[\"然后对地址中的值修改\",{\"1\":{\"591\":1}}],[\"然后可以对分类完的数据进行合并计算\",{\"1\":{\"520\":1}}],[\"然后返回一个结果值\",{\"1\":{\"519\":1}}],[\"然后回车\",{\"1\":{\"493\":1}}],[\"然后递归更新\",{\"1\":{\"426\":1}}],[\"然后更新\",{\"1\":{\"425\":1}}],[\"然后访问根节点\",{\"1\":{\"382\":2}}],[\"然后缩小查找第\",{\"1\":{\"365\":1}}],[\"然后修改\",{\"1\":{\"354\":1}}],[\"然后系统代理选择\",{\"1\":{\"347\":1}}],[\"然后就可以双击\",{\"1\":{\"347\":1}}],[\"然后就可以通过评论\",{\"1\":{\"291\":1}}],[\"然后国内的\",{\"1\":{\"346\":1}}],[\"然后测试代理服务是否可用\",{\"1\":{\"346\":1}}],[\"然后点击生成用户\",{\"1\":{\"347\":1}}],[\"然后点击\",{\"1\":{\"345\":1}}],[\"然后下载一个\",{\"1\":{\"344\":1}}],[\"然后在遍历左子树的时候\",{\"1\":{\"382\":1}}],[\"然后在\",{\"1\":{\"344\":1}}],[\"然后在排序分计算阶段根据召回结果实现这样的效果\",{\"1\":{\"273\":1}}],[\"然后整合\",{\"1\":{\"303\":1}}],[\"然后通过\",{\"1\":{\"302\":1}}],[\"然后通过迭代细分场景下的召回策略\",{\"1\":{\"273\":1}}],[\"然后其他的线程直接从这个缓存里拿数据即可\",{\"1\":{\"293\":1}}],[\"然后它们都会去\",{\"1\":{\"293\":1}}],[\"然后批量返回\",{\"1\":{\"293\":1}}],[\"然后导入到\",{\"1\":{\"283\":1}}],[\"然后消息堆积\",{\"1\":{\"282\":1}}],[\"然后发送一条消息给\",{\"1\":{\"281\":1}}],[\"然后\",{\"1\":{\"209\":1,\"266\":1,\"706\":1}}],[\"然后重复\",{\"1\":{\"197\":1}}],[\"然后删去它们的所有的倍数\",{\"1\":{\"191\":1}}],[\"然后将前者目录中的内容覆盖替换到后者目录中\",{\"1\":{\"347\":1}}],[\"然后将\",{\"1\":{\"158\":3}}],[\"然后判断\",{\"1\":{\"137\":1}}],[\"然后每次都\",{\"1\":{\"111\":1}}],[\"然后我们再求其前缀和\",{\"1\":{\"83\":1}}],[\"然后从\",{\"1\":{\"82\":1,\"192\":1}}],[\"然后从标准输入中输入响应\",{\"1\":{\"69\":1}}],[\"然后再拼接当前环境的配置文件\",{\"1\":{\"706\":1}}],[\"然后再调用\",{\"1\":{\"706\":1}}],[\"然后再使用如下指令\",{\"1\":{\"493\":1}}],[\"然后再判断图中是否存在环\",{\"1\":{\"474\":1}}],[\"然后再进行加密存储\",{\"1\":{\"323\":1}}],[\"然后再通过\",{\"1\":{\"289\":1}}],[\"然后再加载个性化信息\",{\"1\":{\"266\":1}}],[\"然后再加上现在的前缀和\",{\"1\":{\"81\":1}}],[\"然后再遍历已经遍历过的点邻近的点\",{\"1\":{\"32\":1}}],[\"请构造二叉树并返回其根节点\",{\"1\":{\"418\":1}}],[\"请将下一行注释符删除\",{\"1\":{\"354\":1}}],[\"请注意保管管理员密码\",{\"1\":{\"352\":1}}],[\"请求的方法不存在\",{\"1\":{\"618\":1}}],[\"请求的变量不存在\",{\"1\":{\"618\":1}}],[\"请求的数据在数据库中不存在\",{\"1\":{\"334\":1}}],[\"请求对象\",{\"1\":{\"310\":1,\"311\":1,\"313\":1,\"314\":1}}],[\"请求体很长时不建议用\",{\"1\":{\"308\":1}}],[\"请求体\",{\"1\":{\"308\":1}}],[\"请求类型\",{\"1\":{\"308\":1}}],[\"请求预过滤\",{\"1\":{\"267\":1}}],[\"请你判断是否可能完成所有课程的学习\",{\"1\":{\"473\":1}}],[\"请你将其转换为一棵\",{\"1\":{\"436\":1}}],[\"请你将它展开为一个单链表\",{\"1\":{\"376\":1}}],[\"请你实现\",{\"1\":{\"424\":1}}],[\"请你设计一个算法查找其中第\",{\"1\":{\"362\":1}}],[\"请你选择尽量少的区间\",{\"1\":{\"250\":1}}],[\"请你在数轴上选择尽量少的点\",{\"1\":{\"247\":1}}],[\"请你输出\",{\"1\":{\"209\":1}}],[\"请你求出数列中每个数的二进制表示中\",{\"1\":{\"159\":1}}],[\"请你求出\",{\"1\":{\"128\":1,\"212\":1}}],[\"请你求出给定的\",{\"1\":{\"125\":1}}],[\"请你求出得到正确排列至少需要进行多少次交换\",{\"1\":{\"99\":1}}],[\"请你按照字典序将所有的排列方法输出\",{\"1\":{\"101\":1}}],[\"请你计算网格中岛屿的数量\",{\"1\":{\"442\":1}}],[\"请你计算\",{\"1\":{\"100\":1}}],[\"请你通过最少的移动次数\",{\"1\":{\"44\":1}}],[\"请写一个程序\",{\"1\":{\"93\":1}}],[\"请问\",{\"1\":{\"82\":1,\"98\":1}}],[\"请打印\",{\"1\":{\"69\":2}}],[\"交由它来管理\",{\"1\":{\"712\":1}}],[\"交由其他的线程池并发执行\",{\"1\":{\"266\":1}}],[\"交集部分数据\",{\"1\":{\"530\":1}}],[\"交替路\",{\"1\":{\"183\":1}}],[\"交互器将立即终止\",{\"1\":{\"69\":1}}],[\"交互题\",{\"0\":{\"69\":1}}],[\"交换a\",{\"1\":{\"593\":1}}],[\"交换两个点\",{\"1\":{\"237\":1}}],[\"交换两个方程的位置\",{\"1\":{\"205\":1}}],[\"交换两个数\",{\"1\":{\"158\":1}}],[\"交换某两行\",{\"1\":{\"205\":1}}],[\"交换位置\",{\"1\":{\"99\":1}}],[\"交换\",{\"1\":{\"44\":1}}],[\"交换过程如下\",{\"1\":{\"44\":1,\"99\":1}}],[\"都有一个\",{\"1\":{\"707\":1}}],[\"都有一行输出\",{\"1\":{\"94\":1}}],[\"都改掉\",{\"1\":{\"704\":1}}],[\"都可以描述字符串\",{\"1\":{\"507\":1}}],[\"都可以是\",{\"1\":{\"242\":1}}],[\"都会被写入到同一个日志文件中\",{\"1\":{\"660\":1}}],[\"都会被写入到这个日志文件中\",{\"1\":{\"660\":1}}],[\"都会被重新标记为\",{\"1\":{\"444\":1}}],[\"都会影响到彼此对方\",{\"1\":{\"645\":1}}],[\"都会输掉游戏\",{\"1\":{\"214\":1}}],[\"都要用\",{\"1\":{\"443\":1}}],[\"都为空指针返回\",{\"1\":{\"431\":1}}],[\"都具有非常强的头部效应\",{\"1\":{\"274\":1}}],[\"都采用删除缓存而非直接更新的方式\",{\"1\":{\"264\":1}}],[\"都采取最优策略行动时游戏的结果\",{\"1\":{\"214\":1}}],[\"都是实现了一个接口\",{\"1\":{\"710\":1}}],[\"都是空的\",{\"1\":{\"707\":1}}],[\"都是指默认的\",{\"1\":{\"545\":1}}],[\"都是使用逻辑外键\",{\"1\":{\"524\":1}}],[\"都是挺不错的选择\",{\"1\":{\"343\":1}}],[\"都是由男孩子指向女孩子\",{\"1\":{\"183\":1}}],[\"都是上下左右四个方向\",{\"1\":{\"48\":1}}],[\"都加上第一段符合的个数即可\",{\"1\":{\"82\":1}}],[\"都符合条件\",{\"1\":{\"82\":1}}],[\"都一定是\",{\"1\":{\"68\":1,\"203\":1}}],[\"裴蜀定理\",{\"0\":{\"68\":1,\"203\":1}}],[\"秦九韶算法\",{\"0\":{\"65\":1}}],[\"③\",{\"1\":{\"63\":1}}],[\"②赋\",{\"1\":{\"74\":1}}],[\"②\",{\"1\":{\"63\":1,\"144\":1,\"200\":1}}],[\"①将区间\",{\"1\":{\"74\":1}}],[\"①\",{\"1\":{\"63\":1,\"144\":1,\"200\":1}}],[\"操作符\",{\"1\":{\"536\":1}}],[\"操作的注意事项\",{\"1\":{\"512\":1}}],[\"操作时\",{\"1\":{\"431\":1}}],[\"操作数据库的对象\",{\"1\":{\"322\":1}}],[\"操作数据库的框架\",{\"1\":{\"300\":1}}],[\"操作数据库\",{\"1\":{\"319\":1}}],[\"操作数每右移一位\",{\"1\":{\"158\":1}}],[\"操作不会顺序错乱\",{\"1\":{\"264\":1}}],[\"操作\",{\"0\":{\"541\":1,\"675\":1,\"676\":1},\"1\":{\"63\":1,\"237\":1,\"283\":2}}],[\"操作系统\",{\"0\":{\"12\":1},\"1\":{\"7\":1}}],[\"会报警\",{\"1\":{\"717\":1}}],[\"会报错\",{\"1\":{\"687\":1}}],[\"会创建出一个默认的\",{\"1\":{\"705\":1}}],[\"会创建初始管理员账号\",{\"1\":{\"352\":1}}],[\"会话也不会被阻塞\",{\"1\":{\"660\":1}}],[\"会优先使用局部变量\",{\"1\":{\"588\":1}}],[\"会在下一章解释\",{\"1\":{\"583\":1}}],[\"会在评论列表以外\",{\"1\":{\"270\":1}}],[\"会构造一个新的字符串\",{\"1\":{\"578\":1}}],[\"会顺次执行后面每个\",{\"1\":{\"559\":1}}],[\"会自动创建主键索引\",{\"1\":{\"546\":1}}],[\"会自动进行驼峰命令转换\",{\"1\":{\"322\":1}}],[\"会影响检索速度\",{\"1\":{\"545\":1}}],[\"会明确指出禁止使用物理外键\",{\"1\":{\"524\":1}}],[\"会根据业务需求及业务模块之间的关系\",{\"1\":{\"523\":1}}],[\"会提示询问是否确认删除所有数据\",{\"1\":{\"514\":1}}],[\"会出错\",{\"1\":{\"486\":1}}],[\"会产生一定的费用\",{\"1\":{\"346\":1}}],[\"会将主内存中的值刷回到自己的线程内存中\",{\"1\":{\"702\":1}}],[\"会将变量的值刷到主内存中\",{\"1\":{\"702\":1}}],[\"会将用户密码和一个随机生成的字符串\",{\"1\":{\"323\":1}}],[\"会将逻辑删除的用户也查找出来\",{\"1\":{\"310\":1}}],[\"会减少之后大量的返工\",{\"1\":{\"278\":1}}],[\"会向下游传递预先声明的召回决策\",{\"1\":{\"273\":1}}],[\"会通过消息队列送至\",{\"1\":{\"261\":1}}],[\"会有非常重的前置调用逻辑\",{\"1\":{\"261\":1}}],[\"会随着其他数值而受到影响\",{\"1\":{\"174\":1}}],[\"会导致边界问题\",{\"1\":{\"486\":1}}],[\"会导致如果用户注销帐号了\",{\"1\":{\"334\":1}}],[\"会导致找不到属性对应的字段\",{\"1\":{\"322\":1}}],[\"会导致大量的同进程\",{\"1\":{\"293\":1}}],[\"会导致更大的\",{\"1\":{\"289\":1}}],[\"会导致\",{\"1\":{\"158\":1}}],[\"会对应这个数列的连续一段\",{\"1\":{\"144\":1}}],[\"会覆盖掉\",{\"1\":{\"74\":1}}],[\"会爆掉\",{\"1\":{\"63\":1}}],[\"会过滤掉空字符\",{\"1\":{\"63\":1}}],[\"比方说先审后发或者先发后审\",{\"1\":{\"278\":1}}],[\"比如上面的是\",{\"1\":{\"707\":1}}],[\"比如上面评论图红框里的就是根评论\",{\"1\":{\"289\":1}}],[\"比如获取\",{\"1\":{\"704\":1}}],[\"比如社交评论\",{\"1\":{\"666\":1}}],[\"比如根节点左儿子的值大于根节点的值\",{\"1\":{\"486\":1}}],[\"比如根节点就是记录了字符串首个位置\",{\"1\":{\"425\":1}}],[\"比如我想实现一个图床\",{\"1\":{\"350\":1}}],[\"比如我们可以将多个参数整合为一个结构体传递到函数内部\",{\"1\":{\"77\":1}}],[\"比如需要存储\",{\"1\":{\"334\":1}}],[\"比如说我们要存储\",{\"1\":{\"334\":1}}],[\"比如用户信息\",{\"1\":{\"310\":1}}],[\"比如是不是根评论\",{\"1\":{\"289\":1}}],[\"比如两个服务互相调用\",{\"1\":{\"279\":1}}],[\"比如发布评论用户等级限定\",{\"1\":{\"284\":1}}],[\"比如发布\",{\"1\":{\"279\":1}}],[\"比如访问账号服务进行等级判定\",{\"1\":{\"279\":1}}],[\"比如在漫画\",{\"1\":{\"278\":1}}],[\"比如评论总数等\",{\"1\":{\"289\":1}}],[\"比如评论区所有的评论都没有赞\",{\"1\":{\"273\":1}}],[\"比如评论列表\",{\"1\":{\"261\":1}}],[\"比如围棋\",{\"1\":{\"215\":1}}],[\"比如归并排序中合并两个有序序列的操作\",{\"1\":{\"160\":1}}],[\"比如将数\",{\"1\":{\"158\":2}}],[\"比如取数\",{\"1\":{\"158\":1}}],[\"比如\",{\"1\":{\"63\":1,\"81\":1,\"158\":2,\"159\":1,\"227\":1,\"289\":3,\"334\":1,\"344\":1,\"474\":1,\"526\":1,\"615\":1}}],[\"比较运算符\",{\"1\":{\"518\":2}}],[\"比较左右两半边\",{\"1\":{\"138\":1}}],[\"比较高度\",{\"1\":{\"94\":1}}],[\"比较路径是否最短\",{\"1\":{\"56\":1,\"57\":1}}],[\"比较\",{\"1\":{\"35\":1}}],[\"时间戳\",{\"1\":{\"507\":1}}],[\"时间值或持续时间\",{\"1\":{\"507\":1}}],[\"时间衰退因子\",{\"1\":{\"272\":1}}],[\"时间复杂度的基数可以认为都是o\",{\"1\":{\"273\":1}}],[\"时间复杂度o\",{\"1\":{\"178\":1}}],[\"时间复杂度是\",{\"1\":{\"172\":1,\"173\":1,\"181\":1,\"183\":1,\"242\":1}}],[\"时间复杂度一般为\",{\"1\":{\"171\":1}}],[\"时间复杂度\",{\"1\":{\"166\":1,\"169\":1,\"174\":1,\"175\":1,\"176\":1,\"182\":1,\"242\":1,\"377\":1}}],[\"时间复杂度为\",{\"1\":{\"144\":1,\"171\":3,\"180\":1,\"181\":2,\"187\":1,\"188\":1,\"191\":1,\"193\":1,\"201\":1,\"205\":1}}],[\"时事热点容易造成发评论的瞬间峰值流量\",{\"1\":{\"261\":1}}],[\"时为偶数\",{\"1\":{\"201\":1}}],[\"时为奇数\",{\"1\":{\"201\":1}}],[\"时才能表示已经将所有点加入到集合中\",{\"1\":{\"181\":1}}],[\"时需要加\",{\"1\":{\"142\":1}}],[\"时不需要加\",{\"1\":{\"141\":1}}],[\"时用来初始化\",{\"1\":{\"127\":1}}],[\"时\",{\"1\":{\"63\":1,\"81\":1,\"94\":2,\"141\":1,\"142\":1,\"158\":1,\"193\":2,\"200\":1,\"203\":2,\"281\":1,\"363\":1,\"480\":1,\"618\":2}}],[\"获取配置文件\",{\"1\":{\"706\":1}}],[\"获取配置项\",{\"1\":{\"704\":1}}],[\"获取堆顶元素但不删除\",{\"1\":{\"651\":1}}],[\"获取堆顶元素并删除\",{\"1\":{\"651\":1}}],[\"获取队尾元素但不删除\",{\"1\":{\"650\":1}}],[\"获取队尾元素并删除\",{\"1\":{\"650\":1}}],[\"获取队首元素但不删除\",{\"1\":{\"650\":1}}],[\"获取队首元素并删除\",{\"1\":{\"650\":1}}],[\"获取锁\",{\"1\":{\"634\":1}}],[\"获取类中的单个构造函数的信息\",{\"1\":{\"628\":1}}],[\"获取类或接口中的单个字段的信息\",{\"1\":{\"628\":1}}],[\"获取类或接口中的单个方法的信息\",{\"1\":{\"628\":1}}],[\"获取类的实例对象\",{\"1\":{\"628\":1}}],[\"获取值\",{\"1\":{\"613\":1}}],[\"获取关键字\",{\"1\":{\"613\":1}}],[\"获取map中的所有对象的集合\",{\"1\":{\"613\":1}}],[\"获取第i个元素\",{\"1\":{\"609\":1}}],[\"获取不到实际的存储大小\",{\"1\":{\"358\":1}}],[\"获取到业务的原始\",{\"1\":{\"283\":1}}],[\"获取的楼层号就是重复的\",{\"1\":{\"261\":1}}],[\"获取字符串长度\",{\"1\":{\"63\":1,\"690\":1}}],[\"获取\",{\"1\":{\"63\":1}}],[\"使脚本具有可执行权限\",{\"1\":{\"680\":1}}],[\"使一个数的最低位为\",{\"1\":{\"158\":1}}],[\"使其全部二进制位为\",{\"1\":{\"158\":1}}],[\"使路径上的数字的和最大\",{\"1\":{\"121\":1}}],[\"使得这些记录在系统中看起来像已被删除\",{\"1\":{\"310\":1}}],[\"使得每组内部区间两两之间没有交集\",{\"1\":{\"249\":1}}],[\"使得每个区间内至少包含一个选出的点\",{\"1\":{\"247\":1}}],[\"使得行动后对面面临必败局面\",{\"1\":{\"214\":1}}],[\"使得ax\",{\"1\":{\"203\":1}}],[\"使得\",{\"1\":{\"94\":1,\"182\":1,\"203\":2,\"208\":1}}],[\"使得网格变为如下排列\",{\"1\":{\"44\":1,\"99\":1}}],[\"使\",{\"1\":{\"68\":2,\"158\":1,\"203\":2}}],[\"使用变量\",{\"0\":{\"686\":1},\"1\":{\"686\":1}}],[\"使用stream流读取文件\",{\"1\":{\"676\":1}}],[\"使用的存储桶\",{\"1\":{\"673\":1}}],[\"使用的账号信息\",{\"1\":{\"357\":1}}],[\"使用公有云的\",{\"1\":{\"667\":1}}],[\"使用上述命令将\",{\"1\":{\"663\":1}}],[\"使用二分查找算法在有序数组arr中查找值\",{\"1\":{\"654\":1}}],[\"使用稳定的快排队数组进行排序\",{\"1\":{\"640\":1}}],[\"使用灵活\",{\"1\":{\"629\":1}}],[\"使用arrays需要import\",{\"1\":{\"575\":1}}],[\"使用auto编译器会自动判断数据是什么类型\",{\"1\":{\"147\":1}}],[\"使用final修饰\",{\"1\":{\"551\":1}}],[\"使用聚合函数查询是纵向查询\",{\"1\":{\"519\":1}}],[\"使用数组实现求斐波那契数列的第\",{\"1\":{\"572\":1}}],[\"使用数组列表作为队列\",{\"1\":{\"469\":1}}],[\"使用数据库\",{\"0\":{\"501\":1}}],[\"使用到的变量最少\",{\"1\":{\"487\":1}}],[\"使用递归函数\",{\"1\":{\"486\":1}}],[\"使用递归前序遍历\",{\"1\":{\"486\":1}}],[\"使用邻接表建图\",{\"1\":{\"474\":1}}],[\"使用邻接矩阵存图\",{\"1\":{\"178\":1}}],[\"使用链表作为队列\",{\"1\":{\"469\":1}}],[\"使用优先队列\",{\"1\":{\"456\":1}}],[\"使用dfs将连通的陆地块淹掉\",{\"1\":{\"443\":1}}],[\"使用布尔字段\",{\"1\":{\"425\":1}}],[\"使用队列存储每一层的节点\",{\"1\":{\"395\":1}}],[\"使用一个栈\",{\"1\":{\"384\":1}}],[\"使用权限\",{\"1\":{\"357\":1}}],[\"使用了一段时间\",{\"1\":{\"350\":1}}],[\"使用正向代理时\",{\"1\":{\"329\":1}}],[\"使用正则表达式进行校验\",{\"1\":{\"310\":1,\"323\":1}}],[\"使用控制器注解\",{\"1\":{\"311\":1}}],[\"使用统一的\",{\"1\":{\"311\":1}}],[\"使用该工具可以帮助我们快速生成页面\",{\"1\":{\"302\":1}}],[\"使用归并回源的思路\",{\"1\":{\"293\":1}}],[\"使用自增\",{\"1\":{\"289\":1}}],[\"使用其他引擎来实现\",{\"1\":{\"283\":1}}],[\"使用json序列化方式存入\",{\"1\":{\"264\":1}}],[\"使用并查集\",{\"1\":{\"181\":1}}],[\"使用快排将所有边按权值从小到大排序\",{\"1\":{\"181\":1}}],[\"使用成员函数\",{\"1\":{\"63\":1}}],[\"使用\",{\"0\":{\"357\":1,\"358\":1},\"1\":{\"63\":3,\"71\":1,\"159\":1,\"283\":1,\"291\":3,\"311\":1,\"322\":1,\"334\":1,\"350\":1,\"354\":1,\"363\":1,\"425\":1,\"468\":1,\"498\":1,\"524\":1,\"647\":2,\"668\":2,\"673\":1,\"687\":1}}],[\"作者置顶\",{\"1\":{\"278\":1}}],[\"作者删除\",{\"1\":{\"278\":1}}],[\"作用与\",{\"1\":{\"566\":1}}],[\"作用域\",{\"1\":{\"345\":1}}],[\"作用\",{\"1\":{\"159\":1,\"237\":1,\"506\":1}}],[\"作用等同于\",{\"1\":{\"63\":1}}],[\"作为可执行文件\",{\"1\":{\"680\":1}}],[\"作为一个应用程序向\",{\"1\":{\"710\":1}}],[\"作为一个网盘\",{\"1\":{\"353\":1}}],[\"作为一款基于\",{\"1\":{\"668\":1}}],[\"作为主力存储\",{\"1\":{\"291\":1}}],[\"作为主力缓存\",{\"1\":{\"264\":1}}],[\"作为主键去查询\",{\"1\":{\"289\":1}}],[\"作为主键\",{\"1\":{\"289\":1}}],[\"作为\",{\"1\":{\"284\":1}}],[\"作为切割点\",{\"1\":{\"82\":1}}],[\"作为返回值它通常被用作表明没有匹配\",{\"1\":{\"72\":1}}],[\"作为估计函数f\",{\"1\":{\"43\":1}}],[\"条记录\",{\"1\":{\"545\":1}}],[\"条数据\",{\"1\":{\"545\":1}}],[\"条数\",{\"1\":{\"522\":1}}],[\"条件表达式\",{\"0\":{\"558\":1}}],[\"条件查询\",{\"0\":{\"518\":1},\"1\":{\"516\":1}}],[\"条件列表\",{\"1\":{\"516\":1,\"518\":2,\"521\":1}}],[\"条件\",{\"1\":{\"513\":1,\"514\":1,\"520\":2,\"531\":1}}],[\"条件由\",{\"1\":{\"57\":1}}],[\"条边为止\",{\"1\":{\"181\":1}}],[\"条边\",{\"1\":{\"171\":1,\"179\":1}}],[\"条边的有向图\",{\"1\":{\"43\":1}}],[\"迷宫数组\",{\"1\":{\"56\":1,\"57\":1}}],[\"迷宫地图数组\",{\"1\":{\"55\":1}}],[\"再来看下第二行代码\",{\"1\":{\"715\":1}}],[\"再也不怕被问\",{\"1\":{\"702\":1}}],[\"再写\",{\"1\":{\"599\":1}}],[\"再输入\",{\"1\":{\"572\":1}}],[\"再提交\",{\"1\":{\"541\":1}}],[\"再执行删除\",{\"1\":{\"502\":1}}],[\"再一层层向上递归判断\",{\"1\":{\"488\":1}}],[\"再遍历根节点\",{\"1\":{\"487\":1}}],[\"再划分左右子树\",{\"1\":{\"419\":1}}],[\"再深p和q中的一个就没了\",{\"1\":{\"408\":1}}],[\"再递归左子树\",{\"1\":{\"389\":1}}],[\"再处理这个节点\",{\"1\":{\"383\":1}}],[\"再填入账号和生成的密码\",{\"1\":{\"358\":1}}],[\"再填写\",{\"1\":{\"354\":1}}],[\"再前往前台\",{\"1\":{\"357\":1}}],[\"再去\",{\"1\":{\"354\":1}}],[\"再加上文件放在云存储上\",{\"1\":{\"350\":1}}],[\"再准备一台国内的服务器\",{\"1\":{\"346\":1}}],[\"再将注册成功的用户名也放入的布隆过滤器中\",{\"1\":{\"334\":1}}],[\"再进一步\",{\"1\":{\"293\":1}}],[\"再进行更新生成树\",{\"1\":{\"180\":1}}],[\"再进行比较得出最短路径\",{\"1\":{\"56\":1}}],[\"再读取存储\",{\"1\":{\"281\":1}}],[\"再读db\",{\"1\":{\"261\":1}}],[\"再通过业务主键更新业务数据层\",{\"1\":{\"279\":1}}],[\"再往大做可以是一个评论中台\",{\"1\":{\"278\":1}}],[\"再者\",{\"1\":{\"263\":1}}],[\"再次继续匹配\",{\"1\":{\"231\":1}}],[\"再更新\",{\"1\":{\"180\":1}}],[\"再把\",{\"1\":{\"180\":1}}],[\"再建立一个数组\",{\"1\":{\"175\":1}}],[\"再建立一个数组记录起始点到所有点的最短路径\",{\"1\":{\"175\":1}}],[\"再看个位是几\",{\"1\":{\"159\":1}}],[\"再按\",{\"1\":{\"158\":1}}],[\"再枚举左端点\",{\"1\":{\"127\":1}}],[\"再接下来\",{\"1\":{\"125\":1}}],[\"再让他们研究了最长公共子序列\",{\"1\":{\"124\":1}}],[\"再从地图右下角枚举边长为\",{\"1\":{\"83\":1}}],[\"再返回处理上一层找到的节点\",{\"1\":{\"384\":1}}],[\"再返回\",{\"1\":{\"55\":1}}],[\"标量子查询\",{\"0\":{\"535\":1},\"1\":{\"534\":1}}],[\"标度\",{\"1\":{\"507\":2}}],[\"标号\",{\"1\":{\"132\":1}}],[\"标准兼容\",{\"1\":{\"668\":1}}],[\"标准库函数\",{\"1\":{\"63\":1}}],[\"标准件\",{\"1\":{\"14\":1}}],[\"标记走过\",{\"1\":{\"475\":1}}],[\"标记了\",{\"1\":{\"474\":1}}],[\"标记当前节点搜索时遍历过的节点\",{\"1\":{\"474\":1}}],[\"标记当前节点对应一个完整字符串\",{\"1\":{\"425\":1}}],[\"标记所有走过的点\",{\"1\":{\"474\":1}}],[\"标记变成烂橘子\",{\"1\":{\"469\":2}}],[\"标记是否尾节点\",{\"1\":{\"426\":1}}],[\"标记是否使用过\",{\"1\":{\"108\":1}}],[\"标记最近有一个人投递了同一个\",{\"1\":{\"293\":1}}],[\"标记\",{\"1\":{\"193\":1}}],[\"标记点是否在队列中\",{\"1\":{\"175\":1}}],[\"标记入口已走过\",{\"1\":{\"56\":1,\"57\":1}}],[\"标记默认为0\",{\"1\":{\"55\":1}}],[\"标记为已加入到集合中\",{\"1\":{\"172\":1}}],[\"标记为已访问\",{\"1\":{\"55\":1,\"56\":1,\"57\":1}}],[\"标记为0\",{\"1\":{\"148\":1}}],[\"标记为1\",{\"1\":{\"55\":1,\"148\":1}}],[\"标记数组\",{\"1\":{\"55\":1,\"56\":1,\"57\":1}}],[\"计数器维护\",{\"1\":{\"273\":1}}],[\"计数冗余同步至其他系统\",{\"1\":{\"270\":1}}],[\"计数不一致的根源\",{\"1\":{\"270\":1}}],[\"计数类\",{\"1\":{\"263\":1}}],[\"计数类dp\",{\"0\":{\"128\":1}}],[\"计蒜客\",{\"1\":{\"55\":1,\"56\":1,\"57\":1}}],[\"计算公式\",{\"1\":{\"522\":1}}],[\"计算公式如下\",{\"1\":{\"212\":1}}],[\"计算指定列的平均值\",{\"1\":{\"519\":1}}],[\"计算指定列的最小值\",{\"1\":{\"519\":1}}],[\"计算指定列的最大值\",{\"1\":{\"519\":1}}],[\"计算指定列的数值和\",{\"1\":{\"519\":1}}],[\"计算出探测数据项的单机qps热点阈值\",{\"1\":{\"266\":1}}],[\"计算相应的热点条件阈值呢\",{\"1\":{\"266\":1}}],[\"计算子串\",{\"1\":{\"241\":1}}],[\"计算起始点经过队头到其他点的距离是否变短\",{\"1\":{\"175\":1}}],[\"计算结果可能为负数\",{\"1\":{\"148\":1}}],[\"计算结果时就要加上这一个\",{\"1\":{\"81\":1}}],[\"计算它们的差\",{\"1\":{\"148\":1}}],[\"计算它们的和\",{\"1\":{\"147\":1}}],[\"计算\",{\"1\":{\"141\":1,\"142\":1}}],[\"计算两个数的和\",{\"1\":{\"75\":1}}],[\"计算各个点与目标状态的曼哈顿距离之和\",{\"1\":{\"44\":1}}],[\"计算对角距离的函数如下\",{\"1\":{\"39\":1}}],[\"计算曼哈顿距离的函数如下\",{\"1\":{\"38\":1}}],[\"计算节点\",{\"1\":{\"35\":1}}],[\"计算机网络\",{\"0\":{\"10\":1},\"1\":{\"7\":1}}],[\"计算机\",{\"0\":{\"7\":1},\"1\":{\"358\":1}}],[\"重命名为\",{\"1\":{\"663\":1}}],[\"重定向到标准输出\",{\"1\":{\"660\":1}}],[\"重定向到\",{\"1\":{\"660\":1}}],[\"重启之后数据亦然存在\",{\"1\":{\"542\":1}}],[\"重启服务\",{\"1\":{\"353\":1}}],[\"重启防火墙\",{\"1\":{\"345\":1}}],[\"重新调整堆\",{\"1\":{\"651\":1}}],[\"重新启动主程序以初始化新的管理员账户\",{\"1\":{\"352\":1}}],[\"重新赋给每个元素的值\",{\"1\":{\"74\":1}}],[\"重建时会启用预加载\",{\"1\":{\"261\":1}}],[\"重在提升视频观看体验\",{\"1\":{\"254\":1}}],[\"重载小于运算符\",{\"1\":{\"249\":1}}],[\"重载小于号\",{\"1\":{\"181\":1}}],[\"重载\",{\"1\":{\"243\":1}}],[\"重复上述步骤\",{\"1\":{\"468\":1}}],[\"重复上述步骤即可\",{\"1\":{\"395\":1}}],[\"重复执行直到队列为空\",{\"1\":{\"175\":1}}],[\"重复的注释就不再赘述了\",{\"1\":{\"49\":1}}],[\"重置为未访问\",{\"1\":{\"56\":1,\"57\":1}}],[\"重置标记数组即可\",{\"1\":{\"55\":1}}],[\"二元组\",{\"1\":{\"655\":1}}],[\"二者之间可以相互转化\",{\"1\":{\"577\":1}}],[\"二进制形式的极大文本数据\",{\"1\":{\"507\":1}}],[\"二进制形式的中等长度文本数据\",{\"1\":{\"507\":1}}],[\"二进制形式的长文本数据\",{\"1\":{\"507\":1}}],[\"二进制中1的个数\",{\"1\":{\"159\":1}}],[\"二叉查找树\",{\"1\":{\"545\":3}}],[\"二叉搜索树定义如下\",{\"1\":{\"485\":1}}],[\"二叉搜索树\",{\"1\":{\"436\":1}}],[\"二叉搜索树的中序遍历为递增序列\",{\"1\":{\"363\":1}}],[\"二叉搜索树中第k小的元素\",{\"0\":{\"361\":1},\"1\":{\"361\":1}}],[\"二叉树层序遍历使用\",{\"1\":{\"395\":1}}],[\"二叉树的直径\",{\"0\":{\"411\":1},\"1\":{\"411\":1}}],[\"二叉树的最近公共祖先\",{\"0\":{\"405\":1},\"1\":{\"405\":1}}],[\"二叉树的最大深度\",{\"0\":{\"399\":1},\"1\":{\"399\":1}}],[\"二叉树的层序遍历\",{\"0\":{\"393\":1},\"1\":{\"393\":1}}],[\"二叉树的右视图\",{\"0\":{\"387\":1},\"1\":{\"387\":1}}],[\"二叉树的\",{\"1\":{\"382\":1,\"400\":1,\"412\":1}}],[\"二叉树的中序遍历\",{\"0\":{\"381\":1},\"1\":{\"381\":1}}],[\"二叉树展开为链表\",{\"0\":{\"375\":1},\"1\":{\"375\":1}}],[\"二叉树中的\",{\"1\":{\"370\":1}}],[\"二叉树中的最大路径和\",{\"0\":{\"369\":1},\"1\":{\"369\":1}}],[\"二叉树\",{\"1\":{\"24\":1,\"237\":1},\"2\":{\"28\":1,\"368\":1,\"374\":1,\"380\":1,\"386\":1,\"392\":1,\"398\":1,\"404\":1,\"410\":1,\"416\":1,\"422\":1,\"434\":1,\"440\":1,\"465\":1,\"483\":1,\"490\":1}}],[\"二级域名\",{\"1\":{\"354\":1}}],[\"二级列表\",{\"1\":{\"289\":1}}],[\"二分\",{\"1\":{\"243\":1}}],[\"二分图\",{\"1\":{\"182\":2}}],[\"二分求出x对应的离散化的值\",{\"1\":{\"161\":1}}],[\"二分答案可以用来处理\",{\"1\":{\"143\":1}}],[\"二分答案模板\",{\"0\":{\"143\":1}}],[\"二分模板一共有两个\",{\"1\":{\"140\":1}}],[\"二分查找算法模板\",{\"0\":{\"140\":1}}],[\"二分算法\",{\"0\":{\"139\":1}}],[\"二分写法\",{\"1\":{\"122\":1}}],[\"二\",{\"0\":{\"556\":1,\"703\":1},\"1\":{\"119\":1,\"122\":1}}],[\"二维差分\",{\"0\":{\"155\":1}}],[\"二维前缀和\",{\"0\":{\"153\":1}}],[\"二维会爆栈\",{\"1\":{\"83\":1}}],[\"二维\",{\"1\":{\"74\":1,\"116\":1,\"117\":1}}],[\"二是将控制权转移给被调用函数\",{\"1\":{\"584\":1}}],[\"二是数据组装\",{\"1\":{\"258\":1}}],[\"二是基于评论系统做二次开发或存在业务关联的其他业务后端\",{\"1\":{\"258\":1}}],[\"二是\",{\"1\":{\"55\":1}}],[\"找出滑动窗口中的最大值\",{\"1\":{\"230\":1}}],[\"找出每个数左边离它最近的比它大\",{\"1\":{\"227\":1}}],[\"找右端点\",{\"1\":{\"142\":1}}],[\"找左端点\",{\"1\":{\"141\":1}}],[\"找不到文件\",{\"1\":{\"621\":1}}],[\"找不到相应的类\",{\"1\":{\"618\":1}}],[\"找不到返回\",{\"1\":{\"578\":1}}],[\"找不到则返回最后一个元素的下标+1\",{\"1\":{\"243\":1}}],[\"找不到解决方案则输出\",{\"1\":{\"99\":1}}],[\"找不到为假\",{\"1\":{\"55\":1}}],[\"找到这个启动类\",{\"1\":{\"702\":1}}],[\"找到该树中两个指定节点的最近公共祖先\",{\"1\":{\"406\":1}}],[\"找到该点赋给\",{\"1\":{\"180\":1}}],[\"找到后处理并弹出\",{\"1\":{\"384\":1}}],[\"找到当前节点左子树的最右节点\",{\"1\":{\"377\":1}}],[\"找到当前列绝对值最大的一行\",{\"1\":{\"205\":1}}],[\"找到对应的\",{\"1\":{\"310\":1}}],[\"找到\",{\"1\":{\"302\":2,\"345\":1,\"347\":1,\"358\":1}}],[\"找到记录的\",{\"1\":{\"283\":1}}],[\"找到每一个数左边离他最近的比它小的数\",{\"1\":{\"227\":1}}],[\"找到绝对值最大的行\",{\"1\":{\"205\":1}}],[\"找到最小整数解\",{\"1\":{\"204\":1}}],[\"找到不在集合当中的最小的点\",{\"1\":{\"180\":1}}],[\"找到一个未加入集合且距离最近的点\",{\"1\":{\"172\":1}}],[\"找到与起点最近的且未确定最短路径的点\",{\"1\":{\"172\":1}}],[\"找到第一个大于等于x的位置\",{\"1\":{\"161\":1}}],[\"找到j的根节点\",{\"1\":{\"91\":1}}],[\"找到i的根节点\",{\"1\":{\"91\":1}}],[\"找到出口\",{\"1\":{\"56\":1}}],[\"找到入口\",{\"1\":{\"56\":1,\"57\":1}}],[\"找到了位于边界上的出口\",{\"1\":{\"57\":1}}],[\"找到了终点\",{\"1\":{\"56\":1}}],[\"找到了起点\",{\"1\":{\"55\":1}}],[\"找到则为真\",{\"1\":{\"55\":1}}],[\"用构造器模式初始化服务实例\",{\"1\":{\"712\":1}}],[\"用解释器执行\",{\"1\":{\"680\":1}}],[\"用作云原生应用程序的主要存储\",{\"1\":{\"668\":1}}],[\"用作堆栈而不是\",{\"1\":{\"648\":1}}],[\"用newvalue替换所有等于oldvalue的元素\",{\"1\":{\"654\":1}}],[\"用指定的字符串连接字符串数组\",{\"1\":{\"642\":1}}],[\"用当前的调用栈层次填充throwable\",{\"1\":{\"619\":1}}],[\"用当前行将下面所有的列消成0\",{\"1\":{\"205\":1}}],[\"用非法索引访问数组时抛出的异常\",{\"1\":{\"618\":1}}],[\"用一条\",{\"1\":{\"558\":1}}],[\"用一个小根堆来维护所有组的右端点\",{\"1\":{\"249\":1}}],[\"用一个一维数组存储树\",{\"1\":{\"237\":1}}],[\"用一个布尔变量记录下来\",{\"1\":{\"55\":1}}],[\"用法同\",{\"1\":{\"648\":1}}],[\"用法\",{\"1\":{\"499\":1}}],[\"用法与\",{\"1\":{\"243\":1}}],[\"用数组\",{\"1\":{\"474\":2}}],[\"用递归的思维\",{\"1\":{\"378\":1}}],[\"用到了单例模式\",{\"1\":{\"721\":1}}],[\"用到了设计模式中的\",{\"1\":{\"711\":1}}],[\"用到了\",{\"1\":{\"328\":1}}],[\"用于删除指定存储桶中的对象\",{\"1\":{\"676\":1}}],[\"用于删除一个已存在的存储桶\",{\"1\":{\"675\":1}}],[\"用于列出指定存储桶中的所有对象\",{\"1\":{\"676\":1}}],[\"用于列出用户有权访问的所有存储桶\",{\"1\":{\"675\":1}}],[\"用于从指定的存储桶中下载文件\",{\"1\":{\"676\":1}}],[\"用于生成一个对象\",{\"1\":{\"676\":1}}],[\"用于检查指定的对象\",{\"1\":{\"676\":1}}],[\"用于检查指定的存储桶是否存在\",{\"1\":{\"675\":1}}],[\"用于上传文件到指定的存储桶\",{\"1\":{\"676\":1}}],[\"用于创建一个新的存储桶\",{\"1\":{\"675\":1}}],[\"用于将命令放到后台执行\",{\"1\":{\"660\":1}}],[\"用于运行另一个命令在后台\",{\"1\":{\"660\":1}}],[\"用于表示某个程序元素\",{\"1\":{\"625\":1}}],[\"用于修饰包\",{\"1\":{\"624\":1}}],[\"用于处理关闭资源时可能引发的所有异常\",{\"1\":{\"622\":1}}],[\"用于声明和实例化资源\",{\"1\":{\"622\":1}}],[\"用于索引数据\",{\"1\":{\"545\":1}}],[\"用于限制存储在表中的数据\",{\"1\":{\"506\":1}}],[\"用于高效地存储和检索字符串数据集中的键\",{\"1\":{\"424\":1}}],[\"用于配置分布式存储\",{\"1\":{\"352\":1}}],[\"用于记录用户的登录状态\",{\"1\":{\"310\":1}}],[\"用于求解方程\",{\"1\":{\"203\":1}}],[\"用后端\",{\"1\":{\"309\":1}}],[\"用户的id\",{\"1\":{\"525\":1}}],[\"用户的登录信息\",{\"1\":{\"310\":1}}],[\"用户匹配系统\",{\"2\":{\"336\":1}}],[\"用户逻辑实现\",{\"1\":{\"323\":1}}],[\"用户编号不得大于15位\",{\"1\":{\"323\":1}}],[\"用户在前端输入账户和密码\",{\"1\":{\"323\":1}}],[\"用户表\",{\"1\":{\"321\":1,\"525\":1}}],[\"用户表设计\",{\"0\":{\"321\":1}}],[\"用户角色\",{\"1\":{\"321\":1}}],[\"用户权限\",{\"1\":{\"321\":1}}],[\"用户头像\",{\"1\":{\"321\":2}}],[\"用户昵称\",{\"1\":{\"321\":2}}],[\"用户常量\",{\"1\":{\"315\":1}}],[\"用户状态优化\",{\"0\":{\"315\":1}}],[\"用户列表\",{\"1\":{\"313\":1}}],[\"用户id\",{\"1\":{\"311\":1,\"314\":1,\"321\":1,\"323\":1}}],[\"用户注册的时候通过\",{\"1\":{\"334\":1}}],[\"用户注册时可以通过布隆过滤器快速判断用户名是否重复\",{\"1\":{\"334\":1}}],[\"用户注册用户名重复的话\",{\"1\":{\"334\":1}}],[\"用户注册场景\",{\"1\":{\"334\":1}}],[\"用户注册实现\",{\"1\":{\"323\":1}}],[\"用户注册请求\",{\"1\":{\"311\":1}}],[\"用户注册请求体\",{\"1\":{\"311\":1}}],[\"用户注册\",{\"1\":{\"311\":1}}],[\"用户控制器\",{\"1\":{\"311\":1}}],[\"用户脱敏\",{\"1\":{\"310\":1}}],[\"用户登录态键\",{\"1\":{\"315\":1}}],[\"用户登录请求\",{\"1\":{\"311\":1}}],[\"用户登录请求体\",{\"1\":{\"311\":1}}],[\"用户登录\",{\"1\":{\"311\":1}}],[\"用户登录成功\",{\"1\":{\"310\":1}}],[\"用户登录实现\",{\"1\":{\"310\":1}}],[\"用户密码\",{\"1\":{\"310\":1,\"311\":2,\"323\":1}}],[\"用户已经有了会话\",{\"1\":{\"310\":1}}],[\"用户信息脱敏\",{\"1\":{\"309\":1,\"310\":1}}],[\"用户信息\",{\"1\":{\"308\":1,\"310\":1,\"311\":1}}],[\"用户名和密码都可以省略\",{\"1\":{\"660\":1}}],[\"用户名不能重复\",{\"1\":{\"323\":1}}],[\"用户名不包含特殊字符\",{\"1\":{\"310\":1,\"323\":1}}],[\"用户名长度不小于4位\",{\"1\":{\"310\":1,\"323\":1}}],[\"用户名\",{\"1\":{\"308\":1,\"310\":1,\"311\":2,\"313\":1,\"321\":2,\"323\":1,\"507\":1}}],[\"用户中心笔记第四期\",{\"1\":{\"326\":1}}],[\"用户中心笔记第二期\",{\"1\":{\"318\":1}}],[\"用户中心笔记第三期\",{\"1\":{\"306\":1}}],[\"用户中心笔记第一期\",{\"1\":{\"297\":1}}],[\"用户中心\",{\"2\":{\"305\":1,\"317\":1,\"325\":1,\"333\":1}}],[\"用户校验\",{\"1\":{\"299\":1}}],[\"用户管理\",{\"0\":{\"312\":1},\"1\":{\"299\":1}}],[\"用户访问了第一页\",{\"1\":{\"281\":1}}],[\"用户可以在这里看到自己喜欢的评论内容\",{\"1\":{\"274\":1}}],[\"用户等级加权等等\",{\"1\":{\"272\":1}}],[\"用户不满意的评论被顶到热评前排等问题均可能引发舆情问题\",{\"1\":{\"270\":1}}],[\"用户删除\",{\"1\":{\"255\":1,\"278\":1}}],[\"用单例工厂\",{\"1\":{\"706\":1}}],[\"用单线程解决分布式无状态服务的共性问题\",{\"1\":{\"261\":1}}],[\"用单调队列来优化\",{\"1\":{\"230\":1}}],[\"用高精度乘法将所有质因子相乘\",{\"1\":{\"210\":2}}],[\"用高精度乘法把所有质因子乘上\",{\"1\":{\"210\":1}}],[\"用高精度相乘即可\",{\"1\":{\"210\":1}}],[\"用初等行变换\",{\"1\":{\"205\":3}}],[\"用扩展欧几里得算法找出一组解\",{\"1\":{\"204\":1}}],[\"用上面的公式定义求\",{\"1\":{\"199\":1}}],[\"用两个指针\",{\"1\":{\"450\":1}}],[\"用两个指针维护一段区间\",{\"1\":{\"160\":1}}],[\"用两数之积除以他们的最大公约数可得最小公倍数\",{\"1\":{\"197\":1}}],[\"用最小质因子去筛合数\",{\"1\":{\"193\":1}}],[\"用质数把其所有的倍数都筛掉\",{\"1\":{\"191\":1}}],[\"用队列来存储\",{\"1\":{\"175\":1}}],[\"用t更新其他点的距离\",{\"1\":{\"172\":1}}],[\"用途\",{\"0\":{\"158\":1}}],[\"用的数字个数+1\",{\"1\":{\"111\":1}}],[\"用了几个数\",{\"1\":{\"111\":2}}],[\"用过则不合法\",{\"1\":{\"111\":1}}],[\"用这种写法不过是略微优化了一下\",{\"1\":{\"94\":1}}],[\"用整数\",{\"1\":{\"83\":1}}],[\"用\",{\"1\":{\"81\":1,\"111\":1,\"149\":1,\"150\":1,\"159\":1,\"180\":1,\"182\":1,\"201\":1,\"208\":1,\"242\":1,\"350\":1,\"555\":1,\"579\":1}}],[\"用来持有上下文\",{\"1\":{\"721\":1}}],[\"用来将自己本地的\",{\"1\":{\"715\":1}}],[\"用来将之后多余的步数去掉\",{\"1\":{\"56\":1}}],[\"用来跟其他\",{\"1\":{\"714\":1}}],[\"用来处理\",{\"1\":{\"668\":1}}],[\"用来对数据库中表的数据记录进行增\",{\"1\":{\"511\":1}}],[\"用来对数据库表中的数据进行增删改\",{\"1\":{\"496\":1}}],[\"用来创建数据库用户\",{\"1\":{\"496\":1}}],[\"用来查询数据库中表的记录\",{\"1\":{\"496\":1}}],[\"用来查找小于等于\",{\"1\":{\"142\":1}}],[\"用来查找大于等于\",{\"1\":{\"142\":1}}],[\"用来定义数据库对象\",{\"1\":{\"496\":1,\"498\":1}}],[\"用来存储各种常量\",{\"1\":{\"315\":1}}],[\"用来表示哪一行的小方块是横着放的\",{\"1\":{\"131\":1}}],[\"用来表示一个迷宫\",{\"1\":{\"98\":1}}],[\"用来判断\",{\"1\":{\"73\":1}}],[\"用来遍历上下左右四个方向\",{\"1\":{\"48\":1,\"49\":1}}],[\"用define定义的话后面不用加分号\",{\"1\":{\"55\":1}}],[\"逃出这种迷宫\",{\"1\":{\"55\":1}}],[\"逃出迷宫的最短路径\",{\"0\":{\"56\":1},\"1\":{\"54\":1}}],[\"能被100整除时\",{\"1\":{\"557\":1}}],[\"能走多远\",{\"1\":{\"231\":1}}],[\"能更快一点点\",{\"1\":{\"111\":1}}],[\"能逃出迷宫输出\",{\"1\":{\"55\":1}}],[\"能否逃出迷宫\",{\"0\":{\"55\":1},\"1\":{\"54\":1}}],[\"×a2xt​=a2x1​+2x2​+\",{\"1\":{\"201\":1}}],[\"×pm​pm​−1​\",{\"1\":{\"199\":1}}],[\"×\",{\"1\":{\"55\":1,\"149\":3}}],[\"游刃有余\",{\"1\":{\"54\":1}}],[\"游戏中的一幅图\",{\"1\":{\"33\":1}}],[\"理解函数\",{\"1\":{\"581\":1}}],[\"理解为\",{\"1\":{\"319\":1}}],[\"理解整个产品体系在系统中的定位\",{\"1\":{\"278\":1}}],[\"理解之后方才能从容不迫\",{\"1\":{\"54\":1}}],[\"理解了本质就可以傻瓜式地套用模板\",{\"1\":{\"51\":1}}],[\"队头的值\",{\"1\":{\"229\":1}}],[\"队头不断出队\",{\"1\":{\"175\":1}}],[\"队头终点\",{\"1\":{\"41\":2}}],[\"队列长度为\",{\"1\":{\"717\":1}}],[\"队列中元素数量\",{\"1\":{\"651\":1}}],[\"队列中元素个数\",{\"1\":{\"650\":1}}],[\"队列实现\",{\"1\":{\"402\":1}}],[\"队列里面存的是下标\",{\"1\":{\"230\":1}}],[\"队列\",{\"0\":{\"228\":1,\"611\":1,\"649\":1},\"1\":{\"54\":1,\"242\":1}}],[\"栈是否为空\",{\"1\":{\"610\":1}}],[\"栈顶的值\",{\"1\":{\"226\":1}}],[\"栈数组从0开始\",{\"1\":{\"226\":1}}],[\"栈\",{\"0\":{\"225\":1,\"610\":1,\"648\":1},\"1\":{\"54\":1,\"242\":1}}],[\"之前\",{\"1\":{\"474\":2}}],[\"之外的类调用\",{\"1\":{\"311\":1}}],[\"之后的内容均是注释\",{\"1\":{\"682\":1}}],[\"之后的尾迭代器\",{\"1\":{\"243\":1}}],[\"之后\",{\"1\":{\"534\":3,\"622\":1}}],[\"之后还是不行\",{\"1\":{\"302\":1}}],[\"之后使用小顶堆计算\",{\"1\":{\"294\":1}}],[\"之后统计所有未过期的\",{\"1\":{\"294\":1}}],[\"之后根据\",{\"1\":{\"289\":1}}],[\"之后事务更新其他表\",{\"1\":{\"289\":1}}],[\"之后再在\",{\"1\":{\"281\":1}}],[\"之后用户注册成功之后\",{\"1\":{\"334\":1}}],[\"之后用\",{\"1\":{\"193\":1}}],[\"之和是\",{\"1\":{\"81\":1}}],[\"之间\",{\"1\":{\"486\":1}}],[\"之间的数据是相互隔离的\",{\"1\":{\"673\":1}}],[\"之间的所有数字中\",{\"1\":{\"129\":1}}],[\"之间的顺序任意\",{\"1\":{\"107\":1}}],[\"之间的转化\",{\"0\":{\"71\":1}}],[\"之间存在有向边\",{\"1\":{\"43\":1}}],[\"之迷宫问题\",{\"1\":{\"54\":1}}],[\"记\",{\"1\":{\"212\":1}}],[\"记为\",{\"1\":{\"199\":1,\"208\":1,\"473\":1}}],[\"记得加上它本身\",{\"1\":{\"50\":1}}],[\"记录图中是否有环\",{\"1\":{\"475\":1}}],[\"记录遍历过的节点\",{\"1\":{\"475\":1}}],[\"记录一次dfs经过的节点\",{\"1\":{\"475\":1}}],[\"记录下一层被扩散的烂橘子\",{\"1\":{\"469\":1}}],[\"记录每层烂橘子的数量\",{\"1\":{\"468\":1}}],[\"记录每棵树包含的节点数\",{\"1\":{\"94\":1}}],[\"记录初始岛屿数\",{\"1\":{\"445\":1}}],[\"记录当前层的深度\",{\"1\":{\"389\":1}}],[\"记录并更新遍历到的节点\",{\"1\":{\"363\":1}}],[\"记录用户的状态\",{\"1\":{\"315\":1}}],[\"记录素数个数\",{\"1\":{\"193\":1}}],[\"记录前缀中各个数字个数\",{\"1\":{\"129\":1}}],[\"记录答案\",{\"1\":{\"129\":1}}],[\"记录个数\",{\"1\":{\"82\":1}}],[\"记录最短路径\",{\"1\":{\"56\":1}}],[\"记录岛屿的最大面积\",{\"1\":{\"50\":1}}],[\"记录逆序对的对数\",{\"1\":{\"44\":1}}],[\"记录原来到达该状态的距离\",{\"1\":{\"44\":1}}],[\"记录到达此状态的操作和上一步状态\",{\"1\":{\"44\":1}}],[\"相对来说\",{\"1\":{\"507\":1}}],[\"相对而言评论文本更长\",{\"1\":{\"254\":1}}],[\"相关信息\",{\"1\":{\"344\":1,\"353\":1}}],[\"相关概念\",{\"1\":{\"183\":1}}],[\"相当于文件\",{\"1\":{\"673\":1}}],[\"相当于存放文件的顶层文件夹\",{\"1\":{\"673\":1}}],[\"相当于存在两个相邻的点染成了相同的颜色\",{\"1\":{\"182\":1}}],[\"相当于给了key在map中的一个初试值\",{\"1\":{\"647\":1}}],[\"相当于返回原数组的一个片段\",{\"1\":{\"645\":1}}],[\"相当于子查询结果是一张表\",{\"1\":{\"534\":1}}],[\"相当于查询\",{\"1\":{\"530\":1}}],[\"相当于是一个文件服务器\",{\"1\":{\"353\":1}}],[\"相当于是每次考虑合并两个式子\",{\"1\":{\"204\":1}}],[\"相当于该数除以\",{\"1\":{\"158\":1}}],[\"相当于该数乘以\",{\"1\":{\"158\":1}}],[\"相当于结构体\",{\"1\":{\"77\":1}}],[\"相异或值不变\",{\"1\":{\"158\":1}}],[\"相同返回true\",{\"1\":{\"642\":1}}],[\"相同的域名\",{\"1\":{\"310\":1}}],[\"相同的个数\",{\"1\":{\"81\":1}}],[\"相同\",{\"1\":{\"243\":1}}],[\"相同数量级的数即可\",{\"1\":{\"174\":1}}],[\"相同为\",{\"1\":{\"158\":1}}],[\"相邻两个数用一个空格隔开\",{\"1\":{\"109\":1}}],[\"相邻两个数用恰好\",{\"1\":{\"107\":1}}],[\"相邻的陆地\",{\"1\":{\"50\":1}}],[\"相等\",{\"1\":{\"81\":1}}],[\"相较于\",{\"1\":{\"36\":1}}],[\"开源的\",{\"1\":{\"667\":1}}],[\"开源协议\",{\"1\":{\"666\":1}}],[\"开源项目\",{\"0\":{\"18\":1}}],[\"开立方\",{\"1\":{\"653\":1}}],[\"开平方\",{\"1\":{\"653\":1}}],[\"开头\",{\"1\":{\"353\":1}}],[\"开启一个线程\",{\"1\":{\"633\":1}}],[\"开启事务\",{\"1\":{\"541\":2}}],[\"开启手动控制事务\",{\"1\":{\"541\":1}}],[\"开启右子树递归\",{\"1\":{\"420\":1}}],[\"开启左子树递归\",{\"1\":{\"420\":1}}],[\"开启直链后的效果如下\",{\"1\":{\"352\":1}}],[\"开启后每个文件都会生成一个链接\",{\"1\":{\"352\":1}}],[\"开启防火墙并开放指定端口\",{\"1\":{\"345\":1}}],[\"开放指定端口\",{\"1\":{\"345\":1}}],[\"开放端口很重要\",{\"1\":{\"344\":1}}],[\"开放寻址法\",{\"0\":{\"240\":1}}],[\"开发\",{\"1\":{\"309\":1}}],[\"开发工具中生成\",{\"1\":{\"303\":1}}],[\"开发框架ant\",{\"1\":{\"300\":1}}],[\"开发框架\",{\"1\":{\"300\":2}}],[\"开一个单链表\",{\"1\":{\"165\":1}}],[\"开递递归枚举\",{\"1\":{\"111\":1}}],[\"开栈空间代码\",{\"0\":{\"66\":1}}],[\"开始指定大小capacity\",{\"1\":{\"651\":1}}],[\"开始时间\",{\"1\":{\"525\":1}}],[\"开始自增\",{\"1\":{\"506\":1}}],[\"开始扩散\",{\"1\":{\"469\":2}}],[\"开始进行广度优先搜索\",{\"1\":{\"444\":1}}],[\"开始左右子树递归\",{\"1\":{\"419\":1}}],[\"开始计数\",{\"1\":{\"362\":1}}],[\"开始枚举前缀和数组\",{\"1\":{\"82\":1}}],[\"开始搜索\",{\"1\":{\"55\":1,\"56\":1,\"57\":1}}],[\"开始\",{\"1\":{\"49\":1,\"93\":2,\"127\":1,\"237\":1,\"451\":1,\"522\":1}}],[\"⽤\",{\"1\":{\"49\":1}}],[\"靠边的陆地不算作封闭岛屿\",{\"1\":{\"49\":1}}],[\"同上\",{\"1\":{\"642\":3}}],[\"同步的过程会消耗时间\",{\"1\":{\"648\":1}}],[\"同步\",{\"0\":{\"635\":1}}],[\"同步失败则直接导致最终不一致\",{\"1\":{\"270\":1}}],[\"同样的\",{\"1\":{\"715\":1}}],[\"同样表示字符串\",{\"1\":{\"685\":1}}],[\"同样我们也可以通过外键来体现一对一之间的关系\",{\"1\":{\"525\":1}}],[\"同样首先遍历左子节点的左子树\",{\"1\":{\"382\":1}}],[\"同样减少了对\",{\"1\":{\"293\":1}}],[\"同进程只交给一个人去获取\",{\"1\":{\"293\":1}}],[\"同加法一样处理进位\",{\"1\":{\"149\":1}}],[\"同理再处理该节点和该节点的右子节点\",{\"1\":{\"384\":1}}],[\"同理队尾\",{\"1\":{\"229\":1}}],[\"同理\",{\"1\":{\"147\":1,\"148\":1,\"486\":1}}],[\"同理输入一个二维数组\",{\"1\":{\"49\":1}}],[\"同一个类的实例\",{\"1\":{\"602\":1}}],[\"同一个包或者子类中可以访问\",{\"1\":{\"600\":1}}],[\"同一个节点在一条路径序列中\",{\"1\":{\"370\":1}}],[\"同一层级的可以并发调用\",{\"1\":{\"258\":1}}],[\"同一组内的物品最多只能选一个\",{\"1\":{\"119\":1}}],[\"同一行内的数升序排列\",{\"1\":{\"109\":1}}],[\"同一行内的数必须升序排列\",{\"1\":{\"107\":1}}],[\"同一行相邻两个数用一个空格隔开\",{\"1\":{\"108\":1}}],[\"同\",{\"1\":{\"77\":1}}],[\"同时却也降低了\",{\"1\":{\"544\":1}}],[\"同时用哈希表\",{\"1\":{\"480\":1}}],[\"同时节点的标志位还必须为\",{\"1\":{\"425\":1}}],[\"同时也很危险\",{\"1\":{\"344\":1}}],[\"同时如果注销的用户名较多的话\",{\"1\":{\"334\":1}}],[\"同时这个租约\",{\"1\":{\"293\":1}}],[\"同时需要在\",{\"1\":{\"279\":1}}],[\"同时支持配置并行度\",{\"1\":{\"266\":1}}],[\"同时做好安全校验和流量控制\",{\"1\":{\"258\":1}}],[\"同时不捕获其他变量\",{\"1\":{\"75\":1}}],[\"同时\",{\"1\":{\"33\":1,\"214\":1,\"261\":2,\"283\":1,\"289\":1}}],[\"同时还能够为该应用程序提供相关的服务的软件\",{\"1\":{\"14\":1}}],[\"若成功入堆返回值true\",{\"1\":{\"651\":1}}],[\"若成功添加则返回true\",{\"1\":{\"646\":1}}],[\"若队空返回true\",{\"1\":{\"649\":1}}],[\"若栈空返回true\",{\"1\":{\"648\":1}}],[\"若map为空返回true\",{\"1\":{\"647\":1}}],[\"若map中没有该key\",{\"1\":{\"647\":2}}],[\"若集合为空返回true\",{\"1\":{\"646\":1}}],[\"若集合中没有元素e\",{\"1\":{\"646\":1}}],[\"若集合中有元素e则返回false\",{\"1\":{\"646\":1}}],[\"若存在元素e\",{\"1\":{\"646\":1}}],[\"若删除成功返回true\",{\"1\":{\"646\":1}}],[\"若它的右子树不空\",{\"1\":{\"486\":1}}],[\"若已滑出窗口\",{\"1\":{\"456\":1}}],[\"若已经是海水了\",{\"1\":{\"48\":1}}],[\"若前面有使用\",{\"1\":{\"302\":1}}],[\"若直接删除\",{\"1\":{\"263\":1}}],[\"若一级评论被删除\",{\"1\":{\"263\":1}}],[\"若一个游戏满足\",{\"1\":{\"215\":1}}],[\"若回复数也要无限套娃\",{\"1\":{\"263\":1}}],[\"若用户重新刷新页面\",{\"1\":{\"261\":1}}],[\"若两区间部分存在交集\",{\"1\":{\"251\":1}}],[\"若右儿子小于它\",{\"1\":{\"237\":1}}],[\"若左二子小于它\",{\"1\":{\"237\":1}}],[\"若左移时舍弃的高位不包含\",{\"1\":{\"158\":1}}],[\"若从1开始\",{\"1\":{\"231\":1}}],[\"若在某一局面下存在某种行动\",{\"1\":{\"214\":1}}],[\"若在某一局面下无论采取何种行动\",{\"1\":{\"214\":1}}],[\"若在算数基本定理中\",{\"1\":{\"199\":1}}],[\"若p是质数\",{\"1\":{\"209\":1}}],[\"若整数\",{\"1\":{\"208\":1}}],[\"若为\",{\"1\":{\"201\":1}}],[\"若为0\",{\"1\":{\"55\":1}}],[\"若不进行备份会因此发生串联效应\",{\"1\":{\"174\":1}}],[\"若不超过最大载重\",{\"1\":{\"110\":1}}],[\"若t\",{\"1\":{\"148\":1}}],[\"若a大于b\",{\"1\":{\"148\":1}}],[\"若ans为1\",{\"1\":{\"55\":1}}],[\"若满足则答案+1\",{\"1\":{\"111\":1}}],[\"若满足则答案\",{\"1\":{\"111\":1}}],[\"若满足条件\",{\"1\":{\"81\":1,\"230\":1}}],[\"若剩下可选的数字不能填满剩下的空位则回退\",{\"1\":{\"109\":1}}],[\"若要提问\",{\"1\":{\"69\":1}}],[\"若\",{\"1\":{\"68\":1,\"93\":1,\"203\":2}}],[\"若可走且未访问\",{\"1\":{\"56\":1,\"57\":1}}],[\"若无法逃出\",{\"1\":{\"56\":1,\"57\":1}}],[\"若超出地图边界\",{\"1\":{\"48\":1}}],[\"所查询到的数据列表\",{\"1\":{\"522\":1}}],[\"所使用的账号与\",{\"1\":{\"357\":1}}],[\"所具备的商业化价值也是需要持续探索的\",{\"1\":{\"274\":1}}],[\"所含匹配边数最多的匹配\",{\"1\":{\"183\":1}}],[\"所得即为商在这一位的数字\",{\"1\":{\"150\":1}}],[\"所在的目录\",{\"1\":{\"662\":1}}],[\"所在的集合合并\",{\"1\":{\"94\":1}}],[\"所在目录下启动\",{\"1\":{\"660\":1}}],[\"所在树的根节点下面\",{\"1\":{\"91\":1}}],[\"所在树的根节点接到\",{\"1\":{\"91\":1}}],[\"所有普通成员变量\",{\"1\":{\"600\":1}}],[\"所有\",{\"1\":{\"600\":1}}],[\"所有对象均可以访问\",{\"1\":{\"600\":1}}],[\"所有左子树和右子树自身必须也是二叉搜索树\",{\"1\":{\"485\":1}}],[\"所有节点均不为空\",{\"1\":{\"237\":1}}],[\"所有数的个数为各个集合的并集\",{\"1\":{\"212\":1}}],[\"所有边\",{\"1\":{\"174\":1,\"182\":1}}],[\"所有边权都是正数\",{\"1\":{\"171\":1}}],[\"所有的数据都存储在叶子节点上\",{\"1\":{\"545\":2}}],[\"所有的\",{\"1\":{\"540\":1}}],[\"所有的因子可以构成一个有向无环图\",{\"1\":{\"273\":1}}],[\"所有的顶点都是匹配点\",{\"1\":{\"183\":1}}],[\"所有的区间\",{\"1\":{\"127\":1}}],[\"所有的邻近节点\",{\"1\":{\"35\":1}}],[\"所有将a\",{\"1\":{\"126\":1}}],[\"所有测试点满足\",{\"1\":{\"82\":1}}],[\"所以接下来讲解\",{\"1\":{\"680\":1}}],[\"所以基于对象的形式\",{\"1\":{\"667\":1}}],[\"所以此时对形参的修改会影响实参的初始值\",{\"1\":{\"591\":1}}],[\"所以此时应该退出循环\",{\"1\":{\"193\":1}}],[\"所以该操作等价于fact\",{\"1\":{\"585\":1}}],[\"所以一个第三层一个节点大概可以存储\",{\"1\":{\"545\":1}}],[\"所以一直更新根就行了\",{\"1\":{\"134\":1}}],[\"所以为了减少红黑树的高度\",{\"1\":{\"545\":1}}],[\"所以各个表结构之间也存在着各种联系\",{\"1\":{\"523\":1}}],[\"所以我们可以知道\",{\"1\":{\"707\":1}}],[\"所以我们可以先将地图边界的陆地\",{\"1\":{\"49\":1}}],[\"所以我们在遍历的时候实时检查当前节点的值是否大于前一个遍历到的节点的值即可\",{\"1\":{\"487\":1}}],[\"所以初始化范围还要更大些\",{\"1\":{\"486\":1}}],[\"所以初始化为无穷大\",{\"1\":{\"132\":1}}],[\"所以不可能完成所有课程\",{\"1\":{\"474\":1}}],[\"所以最后要返回\",{\"1\":{\"468\":1}}],[\"所以每次扩散需要考虑每一层\",{\"1\":{\"468\":1}}],[\"所以可以缩小比较范围\",{\"1\":{\"486\":1}}],[\"所以可以优化为每次只搜\",{\"1\":{\"445\":1}}],[\"所以可以用str\",{\"1\":{\"232\":1}}],[\"所以只要把经过的位置都设置为\",{\"1\":{\"443\":1}}],[\"所以选择序列的中间值作为根节点\",{\"1\":{\"437\":1}}],[\"所以本题等同于根据中序遍历的序列建立二叉搜索树\",{\"1\":{\"437\":1}}],[\"所以使用\",{\"1\":{\"419\":1}}],[\"所以用的国外服务器配置很一般\",{\"1\":{\"347\":1}}],[\"所以实在不行可以跳过\",{\"1\":{\"302\":1}}],[\"所以直接每次新增评论的时候就把相应字段\",{\"1\":{\"289\":1}}],[\"所以平台扩展的能力\",{\"1\":{\"284\":1}}],[\"所以在回源的逻辑里\",{\"1\":{\"281\":1}}],[\"所以缓存会超前加载\",{\"1\":{\"281\":1}}],[\"所以idx从2开始\",{\"1\":{\"224\":1}}],[\"所以是乘\",{\"1\":{\"209\":1}}],[\"所以有\",{\"1\":{\"203\":1}}],[\"所以先预处理好\",{\"1\":{\"192\":1}}],[\"所以这里只用存一个方向的边\",{\"1\":{\"183\":1}}],[\"所以存边的时候\",{\"1\":{\"183\":1}}],[\"所以存在环\",{\"1\":{\"176\":1}}],[\"所以需要在配置文件中关闭\",{\"1\":{\"322\":1}}],[\"所以需要将\",{\"1\":{\"353\":1}}],[\"所以需要将用户的各种状态抽出来封装为常量\",{\"1\":{\"315\":1}}],[\"所以需要将其翻转\",{\"1\":{\"150\":1}}],[\"所以需要使用标记数组\",{\"1\":{\"55\":1}}],[\"所以从后遍历\",{\"1\":{\"148\":1}}],[\"所以f\",{\"1\":{\"132\":1}}],[\"所以他们想知道\",{\"1\":{\"110\":1}}],[\"所以要用一个\",{\"1\":{\"474\":1}}],[\"所以要减一\",{\"1\":{\"451\":1}}],[\"所以要\",{\"1\":{\"81\":1}}],[\"所以\",{\"1\":{\"63\":1,\"193\":1,\"203\":1,\"282\":1,\"474\":1}}],[\"所以常常定义字符数组\",{\"1\":{\"48\":1}}],[\"所谓约束就是作用在表中字段上的规则\",{\"1\":{\"506\":1}}],[\"所谓二叉树的直径\",{\"1\":{\"413\":1}}],[\"所谓架构上的补充\",{\"1\":{\"261\":1}}],[\"所谓采取最优策略是指\",{\"1\":{\"214\":1}}],[\"所谓缺口迷宫\",{\"1\":{\"57\":1}}],[\"所谓\",{\"1\":{\"49\":1}}],[\"题目意思是说\",{\"1\":{\"111\":1}}],[\"题目描述\",{\"1\":{\"81\":1,\"82\":1,\"83\":1,\"94\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"144\":1}}],[\"题是比较简单的一道模板题\",{\"1\":{\"94\":1}}],[\"题中\",{\"1\":{\"56\":1,\"57\":1}}],[\"题中所给数据大多都是字符\",{\"1\":{\"48\":1}}],[\"题意\",{\"0\":{\"24\":1,\"362\":1,\"370\":1,\"376\":1,\"382\":1,\"388\":1,\"394\":1,\"400\":1,\"406\":1,\"412\":1,\"418\":1,\"424\":1,\"430\":1,\"436\":1,\"442\":1,\"449\":1,\"455\":1,\"461\":1,\"467\":1,\"473\":1,\"479\":1,\"485\":1}}],[\"列子查询\",{\"0\":{\"536\":1},\"1\":{\"534\":1}}],[\"列表去批量查询评论内容了\",{\"1\":{\"291\":1}}],[\"列表\",{\"0\":{\"645\":1},\"1\":{\"291\":1}}],[\"列表后\",{\"1\":{\"269\":1}}],[\"列出容量计算的数学公式\",{\"1\":{\"266\":1}}],[\"列col\",{\"1\":{\"205\":1}}],[\"列的状态是\",{\"1\":{\"131\":1}}],[\"列的像素都是海洋\",{\"1\":{\"100\":1}}],[\"列\",{\"1\":{\"48\":1,\"57\":1,\"100\":2,\"205\":1}}],[\"了解业务本身的本质\",{\"1\":{\"278\":1}}],[\"了\",{\"1\":{\"48\":1,\"49\":1,\"55\":1,\"281\":1,\"443\":1}}],[\"淹了\",{\"1\":{\"443\":1}}],[\"淹了变成海水\",{\"1\":{\"48\":1}}],[\"淹掉\",{\"1\":{\"443\":1}}],[\"淹没\",{\"1\":{\"444\":1}}],[\"淹没岛屿\",{\"1\":{\"50\":1}}],[\"淹没与\",{\"1\":{\"50\":1}}],[\"淹\",{\"1\":{\"48\":1,\"49\":1,\"55\":1}}],[\"大根堆\",{\"1\":{\"651\":1}}],[\"大根堆写法\",{\"1\":{\"611\":1}}],[\"大括号可以省略\",{\"1\":{\"557\":1}}],[\"大整数值\",{\"1\":{\"507\":3}}],[\"大小为10的数组\",{\"1\":{\"573\":1}}],[\"大小为3的数组\",{\"1\":{\"573\":1}}],[\"大小\",{\"1\":{\"507\":3}}],[\"大于等于\",{\"1\":{\"518\":1,\"557\":1}}],[\"大于\",{\"1\":{\"485\":1,\"518\":1,\"557\":1}}],[\"大于某个与inf`\",{\"1\":{\"174\":1}}],[\"大概\",{\"1\":{\"354\":1}}],[\"大不了就换一个用户名就好了\",{\"1\":{\"334\":1}}],[\"大量的请求会在\",{\"1\":{\"281\":1}}],[\"大\",{\"1\":{\"273\":1,\"334\":1}}],[\"大致分为几个阶段\",{\"1\":{\"272\":1}}],[\"大致相同\",{\"1\":{\"243\":1}}],[\"大体的思路都是一样的\",{\"1\":{\"51\":1}}],[\"大多数类型都能用作函数的返回类型\",{\"1\":{\"587\":1}}],[\"大多数服务都是用守护进程实现的\",{\"1\":{\"353\":1}}],[\"大多数\",{\"1\":{\"48\":1}}],[\"大很多\",{\"1\":{\"36\":1}}],[\"垂直\",{\"1\":{\"48\":1}}],[\"或从小到大\",{\"1\":{\"545\":1}}],[\"或竖直方向上相邻的陆地连接形成\",{\"1\":{\"442\":1}}],[\"或指针\",{\"1\":{\"243\":3}}],[\"或者是字符串\",{\"1\":{\"647\":1}}],[\"或者超出字符串的大小\",{\"1\":{\"618\":1}}],[\"或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程\",{\"1\":{\"618\":1}}],[\"或者能隐式地转换函数的返回类型\",{\"1\":{\"594\":1}}],[\"或者说\",{\"1\":{\"424\":1}}],[\"或者直接回车\",{\"1\":{\"345\":1}}],[\"或者有状态层\",{\"1\":{\"282\":1}}],[\"或者高于多少等级的用户才能发表评论\",{\"1\":{\"278\":1}}],[\"或者用更复杂的锁实现\",{\"1\":{\"261\":1}}],[\"或者重载\",{\"1\":{\"243\":1}}],[\"或者\",{\"1\":{\"75\":1,\"94\":1,\"141\":1,\"142\":1,\"158\":1,\"281\":1,\"334\":1,\"345\":1,\"518\":1,\"686\":1,\"687\":1}}],[\"或者c++中的\",{\"1\":{\"69\":1}}],[\"或者问题用完了\",{\"1\":{\"69\":1}}],[\"或已经是海水了\",{\"1\":{\"50\":1}}],[\"或已经是海水了则返回\",{\"1\":{\"49\":1}}],[\"或\",{\"1\":{\"48\":1,\"98\":2,\"143\":1,\"157\":1,\"182\":1,\"241\":1,\"350\":1,\"518\":4,\"558\":1,\"667\":1,\"680\":1}}],[\"纵轴y方向\",{\"1\":{\"48\":1}}],[\"横轴x方向\",{\"1\":{\"48\":1}}],[\"如上例中值为\",{\"1\":{\"693\":2}}],[\"如上例中值为4\",{\"1\":{\"693\":1}}],[\"如上图所示\",{\"1\":{\"289\":1}}],[\"如上图\",{\"1\":{\"279\":1,\"289\":1}}],[\"如用户\",{\"1\":{\"667\":1}}],[\"如启动信息\",{\"1\":{\"660\":1}}],[\"如今有许多第三方文件管理器\",{\"1\":{\"356\":1}}],[\"如何实现\",{\"0\":{\"732\":1}}],[\"如何把头脑中的想法变成简洁的代码\",{\"1\":{\"560\":1}}],[\"如何翻转二叉树\",{\"1\":{\"462\":1}}],[\"如何自建代理服务\",{\"0\":{\"344\":1}}],[\"如何知道是哪个用户登录了\",{\"0\":{\"310\":1}}],[\"如何只交给同进程内\",{\"1\":{\"293\":1}}],[\"如何对文章下面的评论做排序\",{\"1\":{\"274\":1}}],[\"如何在b站评论区脱颖而出\",{\"1\":{\"272\":1,\"274\":1}}],[\"如粉丝勋章\",{\"1\":{\"267\":1}}],[\"如审核\",{\"1\":{\"267\":1}}],[\"如下\",{\"1\":{\"315\":1}}],[\"如下操作\",{\"1\":{\"311\":1}}],[\"如下图\",{\"1\":{\"294\":1,\"419\":1}}],[\"如下图所示\",{\"1\":{\"263\":1}}],[\"如下所示\",{\"1\":{\"48\":1,\"94\":1,\"100\":1,\"707\":1}}],[\"如同调味剂\",{\"1\":{\"254\":1}}],[\"如汽车\",{\"1\":{\"254\":1}}],[\"如点\",{\"1\":{\"174\":1}}],[\"如题\",{\"1\":{\"94\":1,\"377\":1}}],[\"如\",{\"1\":{\"93\":1,\"175\":1,\"231\":1,\"264\":1,\"502\":2,\"529\":1,\"545\":1,\"617\":2}}],[\"如有必要\",{\"1\":{\"74\":1}}],[\"如需输出string对象中的字符串\",{\"1\":{\"63\":1}}],[\"如果应用丢失续约的占比在一定时间内超过了设定的百分比\",{\"1\":{\"717\":1}}],[\"如果应用程序试图创建大小为负的数组\",{\"1\":{\"618\":1}}],[\"如果获取失败了\",{\"1\":{\"717\":1}}],[\"如果配置文件没有配置\",{\"1\":{\"708\":1}}],[\"如果配置文件中没有配置\",{\"1\":{\"707\":1}}],[\"如果发现k\",{\"1\":{\"647\":1}}],[\"如果发现不是二叉搜索树\",{\"1\":{\"488\":1}}],[\"如果map中有key\",{\"1\":{\"647\":1}}],[\"如果修改了原list的大小\",{\"1\":{\"645\":1}}],[\"如果end大于arr\",{\"1\":{\"640\":1}}],[\"如果锁已经被其他线程获取\",{\"1\":{\"634\":1}}],[\"如果索引为负或大于等于数组大小\",{\"1\":{\"618\":1}}],[\"如果程序执行到了这里\",{\"1\":{\"593\":1}}],[\"如果打算修改字符串\",{\"1\":{\"580\":1}}],[\"如果打不开或安装失败就多换几个安装包试试\",{\"1\":{\"347\":2}}],[\"如果成立\",{\"1\":{\"561\":1}}],[\"如果条件成立\",{\"1\":{\"561\":1}}],[\"如果条件成立则记下答案\",{\"1\":{\"143\":1}}],[\"如果小于60\",{\"1\":{\"557\":1}}],[\"如果大于等于60并且小于70\",{\"1\":{\"557\":1}}],[\"如果大于等于70并且小于85\",{\"1\":{\"557\":1}}],[\"如果大于等于85\",{\"1\":{\"557\":1}}],[\"如果数据结构是红黑树\",{\"1\":{\"545\":1}}],[\"如果数据库存在\",{\"1\":{\"502\":1}}],[\"如果事务执行出现错误\",{\"1\":{\"542\":1}}],[\"如果事务成功的完成\",{\"1\":{\"542\":1}}],[\"如果其中有一条\",{\"1\":{\"540\":1}}],[\"如果其中一段连续的子序列\",{\"1\":{\"81\":1}}],[\"如果在配置文件中定义了\",{\"1\":{\"715\":1}}],[\"如果在业务系统当中\",{\"1\":{\"525\":1}}],[\"如果在这一轮的匹配中\",{\"1\":{\"183\":1}}],[\"如果查询的是第一页数据\",{\"1\":{\"522\":1}}],[\"如果查找失败\",{\"1\":{\"72\":1}}],[\"如果查找成功\",{\"1\":{\"72\":1}}],[\"如果未指定该字段值\",{\"1\":{\"506\":1}}],[\"如果未越界\",{\"1\":{\"55\":1}}],[\"如果删除一个不存在的数据库\",{\"1\":{\"502\":1}}],[\"如果均大于说明这个序列是升序的\",{\"1\":{\"487\":1}}],[\"如果可以\",{\"1\":{\"473\":1}}],[\"如果一个位置为\",{\"1\":{\"444\":1,\"445\":1}}],[\"如果一个图的某个匹配中\",{\"1\":{\"183\":1}}],[\"如果前面的值返回\",{\"1\":{\"431\":1}}],[\"如果之前已经插入的字符串\",{\"1\":{\"424\":1}}],[\"如果字符串\",{\"1\":{\"424\":1}}],[\"如果字符串长度很大\",{\"1\":{\"63\":1}}],[\"如果题目中给定的节点值存在重复的解法\",{\"1\":{\"419\":1}}],[\"如果left为空\",{\"1\":{\"408\":1}}],[\"如果left\",{\"1\":{\"408\":1}}],[\"如果二叉搜索树经常被修改\",{\"1\":{\"364\":1}}],[\"如果忘记了初始管理员密码\",{\"1\":{\"352\":1}}],[\"如果显示\",{\"1\":{\"345\":2}}],[\"如果是用接口的方式\",{\"1\":{\"704\":1}}],[\"如果是闰年输出yes\",{\"1\":{\"557\":1}}],[\"如果是升序\",{\"1\":{\"521\":1}}],[\"如果是\",{\"1\":{\"345\":1,\"668\":1}}],[\"如果是相同的树\",{\"1\":{\"25\":1}}],[\"如果步骤没问题\",{\"1\":{\"344\":1}}],[\"如果比较感兴趣\",{\"1\":{\"343\":1}}],[\"如果比父节点大\",{\"1\":{\"237\":1}}],[\"如果经过\",{\"1\":{\"334\":1}}],[\"如果系统用户量很大\",{\"1\":{\"334\":1}}],[\"如果这一列中有\",{\"1\":{\"519\":1}}],[\"如果这层是首次遍历\",{\"1\":{\"389\":1}}],[\"如果这样做\",{\"1\":{\"378\":1}}],[\"如果这\",{\"1\":{\"334\":1}}],[\"如果这个接口不进行校验\",{\"1\":{\"313\":1}}],[\"如果这个点未被匹配\",{\"1\":{\"183\":1}}],[\"如果已经有\",{\"1\":{\"642\":1}}],[\"如果已经使用了\",{\"1\":{\"75\":1}}],[\"如果已有则插入失败\",{\"1\":{\"323\":1}}],[\"如果将状态直接写在登录逻辑里面\",{\"1\":{\"315\":1}}],[\"如果使用上述地址测试后仍然无法连接\",{\"1\":{\"345\":1}}],[\"如果使用\",{\"1\":{\"311\":1}}],[\"如果要使用\",{\"1\":{\"663\":1}}],[\"如果要使用本地存储策略\",{\"1\":{\"354\":1}}],[\"如果要查找一个完整的字符串\",{\"1\":{\"425\":1}}],[\"如果要引入\",{\"1\":{\"303\":1}}],[\"如果要插在k的左边\",{\"1\":{\"224\":1}}],[\"如果和\",{\"1\":{\"289\":1}}],[\"如果为\",{\"1\":{\"289\":1}}],[\"如果为无穷大\",{\"1\":{\"172\":1}}],[\"如果短时间内多个服务节点的大量请求缓存未命中\",{\"1\":{\"261\":1}}],[\"如果两个数组长度相同\",{\"1\":{\"640\":1}}],[\"如果两个值相等\",{\"1\":{\"593\":1}}],[\"如果两个连通块不连通\",{\"1\":{\"181\":1}}],[\"如果两区间无法合并\",{\"1\":{\"251\":1}}],[\"如果到了末尾\",{\"1\":{\"240\":1}}],[\"如果x不在哈希表中\",{\"1\":{\"240\":1}}],[\"如果x在哈希表中\",{\"1\":{\"240\":1}}],[\"如果它本身不是最小的数\",{\"1\":{\"237\":1}}],[\"如果它们都包含一段位置不一定连续的数\",{\"1\":{\"124\":1}}],[\"如果窗口满足条件\",{\"1\":{\"230\":1}}],[\"如果取模的数是质数\",{\"1\":{\"208\":1}}],[\"如果满足条件再输出结果\",{\"1\":{\"230\":1}}],[\"如果满足\",{\"1\":{\"208\":1}}],[\"如果当前数能整除目标数\",{\"1\":{\"195\":1}}],[\"如果当前节点走过了\",{\"1\":{\"475\":1}}],[\"如果当前节点\",{\"1\":{\"425\":2}}],[\"如果当前节点与\",{\"1\":{\"25\":1}}],[\"如果当前节点是空节点\",{\"1\":{\"25\":1}}],[\"如果最后\",{\"1\":{\"188\":1}}],[\"如果最高位有数\",{\"1\":{\"147\":1}}],[\"如果你在调用了sublist返回了子list之后\",{\"1\":{\"645\":1}}],[\"如果你已经自建代理服务并用起来了\",{\"1\":{\"346\":1}}],[\"如果你想找的妹子已经有了男朋友\",{\"1\":{\"183\":1}}],[\"如果你的程序问了一个无效的问题\",{\"1\":{\"69\":1}}],[\"如果途径另一个未匹配点\",{\"1\":{\"183\":1}}],[\"如果该二叉树的左子树不为空\",{\"1\":{\"486\":1}}],[\"如果该数没有被筛掉\",{\"1\":{\"191\":1}}],[\"如果该条边上的两个顶点在一个集合中\",{\"1\":{\"181\":1}}],[\"如果该元素大于栈顶元素\",{\"1\":{\"122\":1}}],[\"如果没有\",{\"1\":{\"642\":1}}],[\"如果没有特别指明\",{\"1\":{\"545\":1}}],[\"如果没有条件\",{\"1\":{\"513\":1,\"514\":1}}],[\"如果没有在树中\",{\"1\":{\"180\":1}}],[\"如果没有重置\",{\"1\":{\"55\":1}}],[\"如果从1号点到x的最短路中包含至少n个点\",{\"1\":{\"176\":1}}],[\"如果从1号点无法走到n号点则返回\",{\"1\":{\"175\":1}}],[\"如果某条最短路径上有n个点\",{\"1\":{\"176\":1}}],[\"如果队列中已存在j\",{\"1\":{\"175\":1}}],[\"如果变短且该点不在队列中\",{\"1\":{\"175\":1}}],[\"如果无法从1走到n\",{\"1\":{\"174\":1}}],[\"如果图不连通\",{\"1\":{\"180\":1}}],[\"如果图中存在负权回路\",{\"1\":{\"174\":1}}],[\"如果图形中允许斜着朝邻近的节点移动\",{\"1\":{\"39\":1}}],[\"如果图形中允许朝任意方向移动\",{\"1\":{\"40\":1}}],[\"如果图形中允许朝任何方向移动\",{\"1\":{\"36\":1}}],[\"如果图形中允许朝八个方向移动\",{\"1\":{\"36\":1}}],[\"如果图形中只允许朝上下左右四个方向移动\",{\"1\":{\"36\":1,\"38\":1}}],[\"如果所有右端点都小于l\",{\"1\":{\"250\":1}}],[\"如果所有点都入队了\",{\"1\":{\"169\":1}}],[\"如果所有节点都正方形\",{\"1\":{\"39\":1}}],[\"如果不处理\",{\"1\":{\"617\":1}}],[\"如果不加该参数项\",{\"1\":{\"510\":1}}],[\"如果不在则直接返回\",{\"1\":{\"486\":1}}],[\"如果不在一个集合中\",{\"1\":{\"181\":1}}],[\"如果不可能\",{\"1\":{\"467\":1}}],[\"如果不是数值类型\",{\"1\":{\"519\":1}}],[\"如果不是首次遍历\",{\"1\":{\"389\":1}}],[\"如果不是起点\",{\"1\":{\"169\":1}}],[\"如果不将它注册为一个进程\",{\"1\":{\"353\":1}}],[\"如果不想用默认创建的管理员账号密码\",{\"1\":{\"352\":1}}],[\"如果不这么做那么会有很多的进程向\",{\"1\":{\"293\":1}}],[\"如果不能覆盖掉右端点\",{\"1\":{\"247\":1}}],[\"如果不存在公共子序列\",{\"1\":{\"449\":1}}],[\"如果不存在\",{\"1\":{\"173\":1}}],[\"如果不存在则返回\",{\"1\":{\"172\":1}}],[\"如果不存在解决方案\",{\"1\":{\"44\":1,\"99\":1}}],[\"如果想将一个单元清零\",{\"1\":{\"158\":1}}],[\"如果t\",{\"1\":{\"148\":1}}],[\"如果有这个\",{\"1\":{\"293\":1}}],[\"如果有两个大于\",{\"1\":{\"188\":1}}],[\"如果有那就使在同一个集合中\",{\"1\":{\"181\":1}}],[\"如果有\",{\"1\":{\"148\":1,\"192\":1}}],[\"如果有一部分遍历完了\",{\"1\":{\"138\":1}}],[\"如果有一位没用上\",{\"1\":{\"111\":1}}],[\"如果a\",{\"1\":{\"148\":2}}],[\"如果i从0开始那么i\",{\"1\":{\"83\":1}}],[\"如果找到\",{\"1\":{\"654\":1}}],[\"如果找到了环\",{\"1\":{\"475\":1}}],[\"如果找到了出口\",{\"1\":{\"55\":1}}],[\"如果找到则返回\",{\"1\":{\"25\":1}}],[\"如果逆序对的数量是偶数\",{\"1\":{\"44\":1}}],[\"如果答案不唯一\",{\"1\":{\"44\":1}}],[\"如果初始网格如下所示\",{\"1\":{\"44\":1,\"99\":1}}],[\"如果走到一个中间点都cnt\",{\"1\":{\"43\":1}}],[\"如果终点已经被访问过k次了\",{\"1\":{\"43\":1}}],[\"如果第n次迭代仍然会松弛三角不等式\",{\"1\":{\"174\":1}}],[\"如果第三段不符合\",{\"1\":{\"82\":1}}],[\"如果第\",{\"1\":{\"43\":1}}],[\"如果更小则更新\",{\"1\":{\"35\":1}}],[\"如果邻近节点\",{\"1\":{\"35\":3}}],[\"如果节点\",{\"1\":{\"35\":2}}],[\"如果起点和终点之间存在障碍物\",{\"1\":{\"34\":1}}],[\"如果我们可以预先计算出每个节点到终点的距离\",{\"1\":{\"34\":1}}],[\"如果\",{\"1\":{\"25\":1,\"35\":1,\"36\":4,\"81\":1,\"82\":1,\"137\":1,\"148\":1,\"181\":1,\"193\":1,\"196\":1,\"203\":1,\"204\":1,\"208\":1,\"227\":1,\"289\":1,\"365\":3}}],[\"如果存在则不创建\",{\"1\":{\"500\":1}}],[\"如果存在缓存穿透的情况\",{\"1\":{\"293\":1}}],[\"如果存在负环\",{\"1\":{\"176\":1}}],[\"如果存在\",{\"1\":{\"24\":1,\"44\":1,\"99\":1,\"204\":1}}],[\"代理服务修改为\",{\"1\":{\"346\":1}}],[\"代理客户端\",{\"1\":{\"344\":1,\"346\":1}}],[\"代理的位置\",{\"0\":{\"329\":1},\"1\":{\"329\":1}}],[\"代替\",{\"1\":{\"158\":1,\"270\":1,\"624\":1}}],[\"代表文件传入的参数个数\",{\"1\":{\"693\":1}}],[\"代表腐烂的橘子\",{\"1\":{\"467\":1}}],[\"代表新鲜橘子\",{\"1\":{\"467\":1}}],[\"代表空单元格\",{\"1\":{\"467\":1}}],[\"代表一张海域照片\",{\"1\":{\"100\":1}}],[\"代表一颗炸弹最多能炸掉地图上目标的总价值数目\",{\"1\":{\"83\":1}}],[\"代表\",{\"1\":{\"81\":1}}],[\"代表陆地\",{\"1\":{\"48\":1,\"49\":2}}],[\"代表海水\",{\"1\":{\"48\":1,\"49\":2}}],[\"代码执行顺序\",{\"1\":{\"560\":1}}],[\"代码评审\",{\"1\":{\"298\":1}}],[\"代码提交\",{\"1\":{\"298\":1}}],[\"代码段\",{\"1\":{\"148\":1}}],[\"代码如下\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"147\":1,\"149\":1,\"150\":1,\"159\":2}}],[\"代码\",{\"0\":{\"366\":1,\"372\":1,\"396\":1,\"408\":1,\"414\":1,\"420\":1,\"426\":1,\"432\":1,\"438\":1,\"451\":1,\"463\":1,\"469\":1,\"475\":1,\"481\":1},\"1\":{\"25\":1,\"43\":1,\"44\":1,\"81\":1,\"82\":1,\"83\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"124\":1,\"126\":1,\"127\":1,\"363\":1,\"377\":1,\"378\":1,\"383\":1,\"384\":1,\"389\":1,\"390\":1,\"401\":1,\"402\":1,\"443\":1,\"445\":1,\"456\":1,\"486\":1,\"487\":1,\"488\":1,\"714\":1}}],[\"只支持一维数组\",{\"1\":{\"694\":1}}],[\"只读变量\",{\"0\":{\"687\":1},\"1\":{\"578\":1}}],[\"只保留表关联部分的数据\",{\"1\":{\"529\":1}}],[\"只与文件名有关\",{\"1\":{\"352\":1}}],[\"只会被抓到它在请求国内服务器\",{\"1\":{\"346\":1}}],[\"只能在函数内部使用\",{\"1\":{\"588\":1}}],[\"只能读取\",{\"1\":{\"578\":1}}],[\"只能从父节点到子节点\",{\"1\":{\"479\":1}}],[\"只能自己偷偷用哦\",{\"1\":{\"343\":1}}],[\"只能输出c语言的内置数据类型\",{\"1\":{\"63\":1}}],[\"只重建一次缓存\",{\"1\":{\"261\":1}}],[\"只去掉相邻的相同元素\",{\"1\":{\"243\":1}}],[\"只是\",{\"1\":{\"200\":1}}],[\"只需将基数\",{\"1\":{\"200\":1}}],[\"只需要创建\",{\"1\":{\"673\":1}}],[\"只需要在最后面加上\",{\"1\":{\"660\":1}}],[\"只需要调整连接查询时\",{\"1\":{\"532\":1}}],[\"只需要使用逗号分隔多张表即可\",{\"1\":{\"529\":1}}],[\"只需要设置不同的评论策略\",{\"1\":{\"278\":1}}],[\"只需要跟一个父亲比较大小就行\",{\"1\":{\"237\":1}}],[\"只需要判断\",{\"1\":{\"191\":1}}],[\"只需要另找一个数\",{\"1\":{\"158\":3}}],[\"只需要枚举\",{\"1\":{\"111\":1}}],[\"只需要将\",{\"1\":{\"57\":1}}],[\"只需要稍加修改即可\",{\"1\":{\"47\":1}}],[\"只可能是此时\",{\"1\":{\"193\":1}}],[\"只判断能否被小于\",{\"1\":{\"187\":1}}],[\"只出现在集合之间\",{\"1\":{\"182\":1}}],[\"只有本类内部可以访问\",{\"1\":{\"600\":1}}],[\"只有表名存在时才会删除该表\",{\"1\":{\"510\":1}}],[\"只有一个为空返回\",{\"1\":{\"431\":1}}],[\"只有管理员才能管理用户\",{\"1\":{\"313\":1}}],[\"只有重算排序的时候才会读取曝光数\",{\"1\":{\"273\":1}}],[\"只有祖宗节点的有意义\",{\"1\":{\"235\":1}}],[\"只有先手必胜和先手必败两种情况\",{\"1\":{\"214\":1}}],[\"只有当\",{\"1\":{\"181\":1}}],[\"只有a\",{\"1\":{\"122\":1}}],[\"只考虑正数的情况\",{\"1\":{\"148\":1}}],[\"只要函数的返回类型不是\",{\"1\":{\"594\":1}}],[\"只要发现该节点已经被\",{\"1\":{\"474\":1}}],[\"只要当前节点为空\",{\"1\":{\"426\":1}}],[\"只要当前根节点是p和q中的任意一个\",{\"1\":{\"408\":1}}],[\"只要文件名不变\",{\"1\":{\"352\":1}}],[\"只要不删除就能一直保留\",{\"1\":{\"352\":1}}],[\"只要它不是\",{\"1\":{\"191\":1}}],[\"只要根据最未位是\",{\"1\":{\"158\":1}}],[\"只要\",{\"1\":{\"158\":1}}],[\"只要找到这个连续段的左端点和右端点即可\",{\"1\":{\"144\":1}}],[\"只要告诉奶牛它的长度就可以了\",{\"1\":{\"124\":1}}],[\"只小猫的重量\",{\"1\":{\"110\":1}}],[\"只小猫的重量分别是\",{\"1\":{\"110\":1}}],[\"只小猫都运送下山\",{\"1\":{\"110\":1}}],[\"只小猫\",{\"1\":{\"110\":1}}],[\"只不过\",{\"1\":{\"50\":1}}],[\"只在高度相同时匹配\",{\"1\":{\"26\":1}}],[\"本章中我们只使用静态成员变量和静态成员函数\",{\"1\":{\"588\":1}}],[\"本来看都是\",{\"1\":{\"486\":1}}],[\"本身的\",{\"1\":{\"358\":1}}],[\"本身就在国内\",{\"1\":{\"346\":1}}],[\"本身就是有序的\",{\"1\":{\"242\":1}}],[\"本机存储\",{\"1\":{\"352\":1}}],[\"本地访问端口\",{\"1\":{\"354\":1}}],[\"本地保存图片后\",{\"1\":{\"352\":1}}],[\"本地已自动配置\",{\"1\":{\"347\":1}}],[\"本地代理客户端\",{\"0\":{\"347\":1},\"1\":{\"346\":1}}],[\"本周会以\",{\"1\":{\"277\":1}}],[\"本题可被转化为求中序遍历的第\",{\"1\":{\"363\":1}}],[\"本题有自定义校验器\",{\"1\":{\"107\":1}}],[\"本题估价函数使用\",{\"1\":{\"43\":1}}],[\"本文方法只适用于\",{\"1\":{\"419\":1}}],[\"本文仅使用\",{\"1\":{\"54\":1}}],[\"本文主要针对常见的岛屿问题\",{\"1\":{\"47\":1}}],[\"岛屿总是被水包围\",{\"1\":{\"442\":1}}],[\"岛屿边缘一个像素的范围会被海水淹没\",{\"1\":{\"100\":1}}],[\"岛屿问题\",{\"1\":{\"55\":1}}],[\"岛屿的最大面积\",{\"0\":{\"50\":1},\"1\":{\"47\":1,\"50\":1}}],[\"岛屿数量\",{\"0\":{\"48\":1,\"441\":1},\"1\":{\"47\":1,\"48\":3,\"441\":1}}],[\"图像数据\",{\"1\":{\"666\":1}}],[\"图中共有\",{\"1\":{\"474\":1}}],[\"图中有一个唯一的起点\",{\"1\":{\"216\":1}}],[\"图\",{\"1\":{\"443\":2}}],[\"图示的\",{\"1\":{\"273\":1}}],[\"图片\",{\"1\":{\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"263\":1,\"266\":3,\"273\":2,\"279\":1,\"280\":1,\"289\":2,\"291\":3,\"293\":1,\"294\":1,\"704\":1}}],[\"图书\",{\"1\":{\"254\":1}}],[\"图的拓扑序列是针对于有向图而言的\",{\"1\":{\"169\":1}}],[\"图论\",{\"2\":{\"46\":1,\"52\":1,\"59\":1,\"184\":1,\"427\":1,\"446\":1,\"470\":1,\"476\":1}}],[\"图形中相邻节点之间的移动代价并不相等\",{\"1\":{\"33\":1}}],[\"那配置项都配置在哪呢\",{\"1\":{\"707\":1}}],[\"那怎么办呢\",{\"1\":{\"350\":1}}],[\"那这里就填\",{\"1\":{\"347\":1}}],[\"那这个评论就是根评论\",{\"1\":{\"289\":1}}],[\"那为什么不能按照评论维度进行拆分\",{\"1\":{\"270\":1}}],[\"那大量写操作后读操作缓存命中率低的问题如何解决呢\",{\"1\":{\"264\":1}}],[\"那它就是一个质数\",{\"1\":{\"191\":1}}],[\"那就是无法连接上端口\",{\"1\":{\"345\":1}}],[\"那就可以直接通过这些\",{\"1\":{\"289\":1}}],[\"那就匹配并标记\",{\"1\":{\"183\":1}}],[\"那就一定有解\",{\"1\":{\"44\":1}}],[\"那等于说走过一次就不能走了\",{\"1\":{\"55\":1}}],[\"那么有没有线程安全问题呢\",{\"1\":{\"673\":1}}],[\"那么之前产生的子list将会失效\",{\"1\":{\"645\":1}}],[\"那么每个同学就是\",{\"1\":{\"598\":1}}],[\"那么第三层总元素大小就是\",{\"1\":{\"545\":1}}],[\"那么第二层即第二次\",{\"1\":{\"545\":1}}],[\"那么结合第二层每个元素通过指针域找到第三层的节点\",{\"1\":{\"545\":1}}],[\"那么会找到第三层\",{\"1\":{\"545\":1}}],[\"那么会造成效率极其低下\",{\"1\":{\"545\":1}}],[\"那么根据每个元素的地址值又会找到下面的子节点\",{\"1\":{\"545\":1}}],[\"那么可以计算出一个节点可以存储的元素个数\",{\"1\":{\"545\":1}}],[\"那么一个用户有可能需要\",{\"1\":{\"545\":1}}],[\"那么查询\",{\"1\":{\"545\":1}}],[\"那么数据库的所有变化将会被回滚\",{\"1\":{\"542\":1}}],[\"那么数据库的所有变化将生效\",{\"1\":{\"542\":1}}],[\"那么要执行多表查询\",{\"1\":{\"529\":1}}],[\"那么在数据库层面怎么去体现上述两者之间是一对一的关系呢\",{\"1\":{\"525\":1}}],[\"那么在用户注册时\",{\"1\":{\"334\":1}}],[\"那么计算结果为0\",{\"1\":{\"519\":1}}],[\"那么答案就是\",{\"1\":{\"480\":1}}],[\"那么该用户名是无法从布隆过滤器中删除的\",{\"1\":{\"334\":1}}],[\"那么缓存穿透的话\",{\"1\":{\"334\":1}}],[\"那么人人都可以调用\",{\"1\":{\"313\":1}}],[\"那么校验写在哪里\",{\"1\":{\"311\":1}}],[\"那么相同的\",{\"1\":{\"293\":1}}],[\"那么相乘会大于\",{\"1\":{\"188\":1}}],[\"那么通过\",{\"1\":{\"289\":1}}],[\"那么如何定义\",{\"1\":{\"266\":1}}],[\"那么异步处理后用户体验是如何保证的呢\",{\"1\":{\"261\":1}}],[\"那么再从头开始查找\",{\"1\":{\"240\":1}}],[\"那么它就是一个完美匹配\",{\"1\":{\"183\":1}}],[\"那么加上自己之后一共有n+1个点\",{\"1\":{\"176\":1}}],[\"那么最短路可能为负无穷\",{\"1\":{\"174\":1}}],[\"那么子节点随意\",{\"1\":{\"134\":1}}],[\"那么称这一段数是两个数列的公共上升子序列\",{\"1\":{\"124\":1}}],[\"那么这个前缀和就能和前面每一个组成一个组合\",{\"1\":{\"81\":1}}],[\"那么题目就是要我们求\",{\"1\":{\"81\":1}}],[\"那么对于任意的整数\",{\"1\":{\"68\":1,\"203\":1}}],[\"那么对应的方向数组也需要做出改变\",{\"1\":{\"48\":1}}],[\"那么就按照数值大小以及字典序排序即可\",{\"1\":{\"647\":1}}],[\"那么就得增加树的宽度\",{\"1\":{\"545\":1}}],[\"那么就找到了\",{\"1\":{\"480\":1}}],[\"那么就不满足条件\",{\"1\":{\"474\":1}}],[\"那么就是对每个节点计算左右子树的最大高度\",{\"1\":{\"413\":1}}],[\"那么就需要搜索八个方向\",{\"1\":{\"48\":1}}],[\"那么就没必要让j继续入队了\",{\"1\":{\"43\":1}}],[\"那么\",{\"1\":{\"33\":1,\"81\":2,\"93\":1,\"144\":1,\"191\":1,\"227\":2,\"334\":1,\"545\":1}}],[\"那么游戏中的角色在平地和山脉中移动的速度通常是不相等的\",{\"1\":{\"33\":1}}],[\"恢复现场\",{\"1\":{\"99\":1,\"108\":1,\"109\":1,\"475\":1}}],[\"恢复\",{\"1\":{\"44\":1}}],[\"求斐波那切数列第n项\",{\"1\":{\"596\":1}}],[\"求斐波那契数列的第\",{\"1\":{\"561\":1,\"563\":1}}],[\"求和\",{\"1\":{\"519\":1}}],[\"求该二叉树里节点值之和等于\",{\"1\":{\"479\":1}}],[\"求分成的最小组数\",{\"1\":{\"249\":1}}],[\"求集合当中的最小值\",{\"1\":{\"237\":1}}],[\"求滑动窗口里的最大值和最小值\",{\"1\":{\"230\":1}}],[\"求每个质因数的次数\",{\"1\":{\"210\":1}}],[\"求每个质数的次数\",{\"1\":{\"210\":1}}],[\"求next\",{\"1\":{\"231\":1}}],[\"求n\",{\"1\":{\"210\":1}}],[\"求组合数\",{\"0\":{\"206\":1}}],[\"求x\",{\"1\":{\"203\":1}}],[\"求x的欧拉函数\",{\"1\":{\"199\":1}}],[\"求整数\",{\"1\":{\"203\":1}}],[\"求欧拉函数\",{\"0\":{\"199\":1}}],[\"求1到n的最短路距离\",{\"1\":{\"174\":1}}],[\"求1号点到n号点的最短距离\",{\"1\":{\"173\":1}}],[\"求1号点到n号点的最短路距离\",{\"1\":{\"175\":1}}],[\"求1号点到n号点的最短路\",{\"1\":{\"172\":1}}],[\"求从一个点到其他所有点的最短距离\",{\"1\":{\"171\":1}}],[\"求从起点\",{\"1\":{\"43\":1}}],[\"求最大匹配数\",{\"1\":{\"183\":1}}],[\"求最大权值和\",{\"1\":{\"134\":1}}],[\"求最小生成树的\",{\"1\":{\"87\":1}}],[\"求起点\",{\"1\":{\"132\":1}}],[\"求方案数\",{\"1\":{\"128\":1}}],[\"求既是\",{\"1\":{\"123\":1}}],[\"求一个最小的非负整数\",{\"1\":{\"204\":1}}],[\"求一个序列中严格递增的子序列的最大长度\",{\"1\":{\"122\":1}}],[\"求一颗炸弹最多能炸掉地图上总价值为多少的目标\",{\"1\":{\"83\":1}}],[\"求解将哪些物品装入背包\",{\"1\":{\"119\":1}}],[\"求所选物品的总体积不超过背包容量的条件下\",{\"1\":{\"116\":1}}],[\"求区间和\",{\"1\":{\"81\":1}}],[\"求区间\",{\"1\":{\"81\":1}}],[\"求\",{\"0\":{\"67\":1},\"1\":{\"44\":1,\"129\":1,\"201\":1,\"207\":1,\"210\":1,\"231\":2,\"561\":1,\"563\":1,\"566\":1}}],[\"第四个参数\",{\"1\":{\"692\":2}}],[\"第四期\",{\"0\":{\"326\":1}}],[\"第3行的初始值\",{\"1\":{\"573\":1}}],[\"第1行的初始值\",{\"1\":{\"573\":1}}],[\"第1种情况\",{\"1\":{\"541\":1}}],[\"第2行的初始值\",{\"1\":{\"573\":1}}],[\"第2种情况\",{\"1\":{\"541\":1}}],[\"第2版\",{\"1\":{\"337\":1}}],[\"第i堆物品有ai个\",{\"1\":{\"214\":1}}],[\"第i行j列格子左上部分所有元素的和\",{\"1\":{\"153\":1}}],[\"第三个参数\",{\"1\":{\"692\":2}}],[\"第三行注释\",{\"1\":{\"683\":3}}],[\"第三行包含\",{\"1\":{\"124\":1}}],[\"第三层由\",{\"1\":{\"545\":1}}],[\"第三方平台对文件的读取保存都和本地一模一样\",{\"1\":{\"358\":1}}],[\"第三期\",{\"0\":{\"306\":1}}],[\"第三步\",{\"1\":{\"137\":1}}],[\"第三维枚举决策\",{\"1\":{\"115\":1}}],[\"第三段\",{\"1\":{\"82\":1}}],[\"第\",{\"1\":{\"100\":3,\"110\":2,\"204\":2}}],[\"第二层一共是\",{\"1\":{\"545\":1}}],[\"第二层节点就是记录了字符串索引\",{\"1\":{\"425\":1}}],[\"第二期\",{\"0\":{\"318\":1}}],[\"第二个参数\",{\"1\":{\"692\":2}}],[\"第二个实参初始化第二个形参\",{\"1\":{\"585\":1}}],[\"第二个元素\",{\"1\":{\"242\":1}}],[\"第二个行动的称为后手\",{\"1\":{\"214\":1}}],[\"第二行注释\",{\"1\":{\"683\":3}}],[\"第二行输出所求余数\",{\"1\":{\"150\":1}}],[\"第二行包含\",{\"1\":{\"82\":1,\"124\":1,\"159\":1}}],[\"第二步调用了\",{\"1\":{\"703\":1}}],[\"第二步\",{\"1\":{\"137\":1,\"322\":1}}],[\"第二维枚举起点\",{\"1\":{\"127\":1}}],[\"第二维枚举体积\",{\"1\":{\"115\":1}}],[\"第二种方法\",{\"1\":{\"689\":1}}],[\"第二种写法\",{\"1\":{\"118\":1,\"119\":1,\"697\":2,\"698\":2}}],[\"第二种用法\",{\"1\":{\"74\":1}}],[\"第二部分是以\",{\"1\":{\"93\":1}}],[\"第二元素\",{\"1\":{\"44\":1}}],[\"第一张表存放的是用户的基本信息\",{\"1\":{\"525\":1}}],[\"第一个参数\",{\"1\":{\"692\":2}}],[\"第一个实参初始化第一个形参\",{\"1\":{\"585\":1}}],[\"第一个对第二个数取余数\",{\"1\":{\"552\":1}}],[\"第一个数除以第二个数\",{\"1\":{\"552\":1}}],[\"第一个数乘以第二个数\",{\"1\":{\"552\":1}}],[\"第一个数减去第二个数\",{\"1\":{\"552\":1}}],[\"第一个数加上第二个数\",{\"1\":{\"552\":1}}],[\"第一个访问的一定是最右边的节点\",{\"1\":{\"389\":1}}],[\"第一个元素\",{\"1\":{\"242\":1}}],[\"第一期\",{\"0\":{\"297\":1}}],[\"第一次申请的时候要填个人信息\",{\"1\":{\"354\":1}}],[\"第一次出现的位置\",{\"1\":{\"144\":1}}],[\"第一次循环不能有0\",{\"1\":{\"129\":1}}],[\"第一步就是加载配置文件\",{\"1\":{\"703\":1}}],[\"第一步\",{\"1\":{\"137\":1,\"322\":1}}],[\"第一维通常是枚举区间长度\",{\"1\":{\"127\":1}}],[\"第一维枚举物品\",{\"1\":{\"115\":1}}],[\"第一种方法\",{\"1\":{\"689\":1}}],[\"第一种写法\",{\"1\":{\"118\":1,\"119\":1,\"697\":2,\"698\":2}}],[\"第一种用法\",{\"1\":{\"74\":1}}],[\"第一部分是以\",{\"1\":{\"93\":1}}],[\"第一行又是初始化了一个配置\",{\"1\":{\"714\":1}}],[\"第一行注释\",{\"1\":{\"683\":3}}],[\"第一行输出所求的商\",{\"1\":{\"150\":1}}],[\"第一行输入正整数\",{\"1\":{\"83\":1}}],[\"第一行包含一个整数\",{\"1\":{\"100\":1,\"124\":1}}],[\"第一行包含整数\",{\"1\":{\"82\":1,\"159\":1}}],[\"第一行包含两个整数\",{\"1\":{\"43\":1,\"81\":1,\"94\":1,\"98\":1,\"125\":1}}],[\"第一段\",{\"1\":{\"82\":1}}],[\"第一元素\",{\"1\":{\"44\":1}}],[\"高性能\",{\"1\":{\"667\":1,\"668\":1}}],[\"高并发的热点处理实践\",{\"1\":{\"266\":1,\"274\":1}}],[\"高吞吐的调用做异步化\",{\"1\":{\"261\":1}}],[\"高斯消元适用解法\",{\"1\":{\"205\":1}}],[\"高斯消元\",{\"0\":{\"205\":1}}],[\"高位补0\",{\"1\":{\"157\":1}}],[\"高位丢弃\",{\"1\":{\"157\":1}}],[\"高位在后面\",{\"1\":{\"148\":1}}],[\"高精\",{\"1\":{\"149\":1,\"150\":1}}],[\"高精度乘低精度模板\",{\"1\":{\"210\":1}}],[\"高精度整数除法\",{\"0\":{\"150\":1}}],[\"高精度整数乘法\",{\"0\":{\"149\":1}}],[\"高精度减法\",{\"0\":{\"148\":1}}],[\"高精度加法\",{\"0\":{\"147\":1}}],[\"高精度算法\",{\"0\":{\"146\":1}}],[\"高度小的接在高的下面\",{\"1\":{\"94\":1}}],[\"高度小一些的树接到大一些的树下面\",{\"1\":{\"94\":1}}],[\"高度数组\",{\"1\":{\"94\":1}}],[\"高度\",{\"1\":{\"94\":1}}],[\"高级解法\",{\"1\":{\"44\":1}}],[\"高效地开发和集成复杂的应用软件\",{\"1\":{\"14\":1}}],[\"把里面的配置项都放到一个\",{\"1\":{\"708\":1}}],[\"把控制循环次数的变量从循环体中剥离\",{\"1\":{\"563\":1}}],[\"把两个数相乘\",{\"1\":{\"552\":1}}],[\"把两个数相加\",{\"1\":{\"552\":1}}],[\"把岛屿\",{\"1\":{\"443\":1}}],[\"把二维数组中的每个格子看做\",{\"1\":{\"443\":1}}],[\"把单表变宽预处理好\",{\"1\":{\"283\":1}}],[\"把对存储的直接冲击\",{\"1\":{\"282\":1}}],[\"把数据拿出来返回\",{\"1\":{\"281\":1}}],[\"把相同的数据进行合并输出\",{\"1\":{\"520\":1}}],[\"把相应的依赖划分为强依赖\",{\"1\":{\"267\":1}}],[\"把相加后的结果除以10求余\",{\"1\":{\"147\":1}}],[\"把一个数组去重\",{\"1\":{\"243\":1}}],[\"把一个\",{\"1\":{\"243\":2}}],[\"把一个方程的若干倍加到另一个方程上去\",{\"1\":{\"205\":1}}],[\"把第k位取反\",{\"1\":{\"242\":1}}],[\"把所有位变成0\",{\"1\":{\"242\":1}}],[\"把所有位置成1\",{\"1\":{\"242\":1}}],[\"把每个局面看成图中的一个节点\",{\"1\":{\"216\":1}}],[\"把游戏过程中面临的状态称为局面\",{\"1\":{\"214\":1}}],[\"把这个岛屿\",{\"1\":{\"443\":1}}],[\"把这个让给我好吧\",{\"1\":{\"183\":1}}],[\"把这一行换到最上面\",{\"1\":{\"205\":1}}],[\"把某行的若干倍加到另一行上去\",{\"1\":{\"205\":1}}],[\"把某一行乘一个非00的数\",{\"1\":{\"205\":1}}],[\"把找到的符合条件的点的长度加上\",{\"1\":{\"180\":1}}],[\"把b加入\",{\"1\":{\"175\":1}}],[\"把集合选\",{\"1\":{\"128\":1}}],[\"把下边的岛屿淹掉\",{\"1\":{\"49\":1}}],[\"把上边的岛屿淹掉\",{\"1\":{\"49\":1}}],[\"把靠右边的岛屿淹掉\",{\"1\":{\"49\":1}}],[\"把靠左边的岛屿淹掉\",{\"1\":{\"49\":1}}],[\"把\",{\"1\":{\"44\":1,\"108\":1,\"294\":1}}],[\"右表\",{\"1\":{\"532\":1}}],[\"右外连接相当于查询表2\",{\"1\":{\"532\":1}}],[\"右外连接语法结构\",{\"1\":{\"532\":1}}],[\"右外连接\",{\"1\":{\"530\":1,\"532\":1}}],[\"右对左\",{\"1\":{\"432\":1}}],[\"右子节点索引为\",{\"1\":{\"419\":1}}],[\"右子树下界\",{\"1\":{\"486\":1}}],[\"右子树范围\",{\"1\":{\"419\":1}}],[\"右子树根节点\",{\"1\":{\"419\":1}}],[\"右子树的深度\",{\"1\":{\"401\":1}}],[\"右子树\",{\"1\":{\"377\":1,\"378\":1,\"419\":5,\"420\":1}}],[\"右\",{\"1\":{\"419\":1}}],[\"右上角\",{\"1\":{\"352\":1}}],[\"右儿子相比最小的元素\",{\"1\":{\"237\":1}}],[\"右儿子是2x\",{\"1\":{\"237\":1}}],[\"右边的子节点比父节点大\",{\"1\":{\"545\":1}}],[\"右边\",{\"1\":{\"445\":1}}],[\"右边丢弃\",{\"1\":{\"158\":1}}],[\"右边补0\",{\"1\":{\"158\":1}}],[\"右补0\",{\"1\":{\"158\":1}}],[\"右移\",{\"1\":{\"157\":1,\"158\":2,\"159\":1}}],[\"右移和\",{\"1\":{\"137\":1}}],[\"右半边剩下的\",{\"1\":{\"138\":1}}],[\"右端点\",{\"1\":{\"127\":1}}],[\"右任意一个方向移动一个位置\",{\"1\":{\"98\":1}}],[\"右三个方向的数字交换成功得到正确排列\",{\"1\":{\"44\":1,\"99\":1}}],[\"右四个方向之一的数字交换\",{\"1\":{\"44\":1,\"99\":1}}],[\"左右\",{\"1\":{\"545\":1}}],[\"左右子树返回信息只需要节点数\",{\"1\":{\"366\":1}}],[\"左表\",{\"1\":{\"532\":1}}],[\"左外连接和右外连接是可以相互替换的\",{\"1\":{\"532\":1}}],[\"左外连接相当于查询表1\",{\"1\":{\"532\":1}}],[\"左外连接语法结构\",{\"1\":{\"532\":1}}],[\"左外连接\",{\"1\":{\"530\":1,\"532\":1}}],[\"左儿子就不会继续往下递归了\",{\"1\":{\"486\":1}}],[\"左边的子节点比父节点小\",{\"1\":{\"545\":1}}],[\"左边的二进制位丢弃\",{\"1\":{\"158\":1}}],[\"左边\",{\"1\":{\"445\":1}}],[\"左对右\",{\"1\":{\"432\":1}}],[\"左指针为\",{\"1\":{\"378\":1}}],[\"左子树根节点\",{\"1\":{\"419\":1}}],[\"左子树的深度\",{\"1\":{\"401\":1}}],[\"左子树最后一个节点访问完后\",{\"1\":{\"377\":1}}],[\"左子树\",{\"1\":{\"377\":1,\"419\":4,\"420\":1}}],[\"左补\",{\"1\":{\"158\":2}}],[\"左半边剩下的\",{\"1\":{\"138\":1}}],[\"左半边的子集\",{\"1\":{\"116\":1}}],[\"左移2位\",{\"1\":{\"158\":1}}],[\"左移\",{\"1\":{\"137\":1,\"157\":1,\"158\":2}}],[\"左闭右开\",{\"1\":{\"74\":1}}],[\"左\",{\"1\":{\"44\":1,\"98\":1,\"99\":1}}],[\"下标为0的元素代表栈顶\",{\"1\":{\"619\":1}}],[\"下标从0开始\",{\"1\":{\"694\":1}}],[\"下标从\",{\"1\":{\"237\":1}}],[\"下标从1开始\",{\"1\":{\"231\":1}}],[\"下标从1开始存\",{\"1\":{\"125\":1}}],[\"下边\",{\"1\":{\"445\":1}}],[\"下载安装包\",{\"1\":{\"660\":1}}],[\"下载证书\",{\"1\":{\"354\":1}}],[\"下载速度只和机器自身的性能相关\",{\"1\":{\"352\":1}}],[\"下载对应的\",{\"1\":{\"347\":2}}],[\"下载之后在\",{\"1\":{\"334\":1}}],[\"下载\",{\"1\":{\"334\":1,\"347\":1,\"662\":1,\"663\":1}}],[\"下的值\",{\"1\":{\"506\":1}}],[\"下的\",{\"1\":{\"302\":1}}],[\"下有很多脚本\",{\"1\":{\"302\":1}}],[\"下放到消息队列\",{\"1\":{\"282\":1}}],[\"下家\",{\"1\":{\"183\":1}}],[\"下面是一些个人配置\",{\"1\":{\"352\":1}}],[\"下面看题中完整的写法\",{\"1\":{\"94\":1}}],[\"下面有\",{\"1\":{\"93\":1}}],[\"下面以\",{\"1\":{\"55\":1}}],[\"下面这幅图对比了这种情况\",{\"1\":{\"32\":1}}],[\"下\",{\"0\":{\"306\":1},\"1\":{\"44\":2,\"98\":1,\"99\":2,\"306\":1}}],[\"8转换\",{\"1\":{\"642\":1}}],[\"8编码转换\",{\"1\":{\"642\":2}}],[\"85\",{\"1\":{\"557\":1}}],[\"8+6\",{\"1\":{\"545\":1}}],[\"838\",{\"1\":{\"507\":2}}],[\"8388607\",{\"1\":{\"507\":1}}],[\"8388608\",{\"1\":{\"507\":1}}],[\"8bytes\",{\"1\":{\"507\":2}}],[\"80\",{\"1\":{\"642\":1}}],[\"8080\",{\"1\":{\"329\":1}}],[\"8000\",{\"1\":{\"329\":1}}],[\"86400\",{\"1\":{\"312\":1}}],[\"8\",{\"0\":{\"69\":1,\"161\":1,\"206\":1,\"207\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"543\":1,\"544\":1,\"545\":1,\"546\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1,\"622\":1},\"1\":{\"44\":10,\"48\":2,\"93\":2,\"98\":1,\"99\":10,\"109\":1,\"121\":2,\"274\":1,\"309\":1,\"310\":1,\"323\":3,\"352\":2,\"507\":1,\"545\":1,\"551\":2,\"563\":1,\"573\":1,\"574\":1,\"642\":3,\"655\":1,\"715\":1}}],[\"总大小是\",{\"1\":{\"545\":1}}],[\"总记录数\",{\"1\":{\"522\":3}}],[\"总结\",{\"0\":{\"290\":1,\"729\":1}}],[\"总结出相应的模板\",{\"1\":{\"54\":1}}],[\"总结出相应的\",{\"1\":{\"47\":1}}],[\"总点数\",{\"1\":{\"176\":1}}],[\"总点数和总边数\",{\"1\":{\"175\":1}}],[\"总共第k大变为总共第k+1大\",{\"1\":{\"43\":1}}],[\"总的作用是为处于自己上层的应用软件提供运行与开发的环境\",{\"1\":{\"14\":1}}],[\"按gbk转换\",{\"1\":{\"642\":1}}],[\"按gbk编码转换\",{\"1\":{\"642\":1}}],[\"按utf\",{\"1\":{\"642\":3}}],[\"按系统默认编码转换\",{\"1\":{\"642\":1}}],[\"按顺序遍历\",{\"1\":{\"445\":1}}],[\"按下快捷键\",{\"1\":{\"311\":1}}],[\"按照某一列或者某几列\",{\"1\":{\"520\":1}}],[\"按照列去统计有多少行数据\",{\"1\":{\"519\":1}}],[\"按照从顶部到底部的顺序\",{\"1\":{\"388\":1}}],[\"按照从小到大的顺序输出所有方案\",{\"1\":{\"108\":1,\"109\":1}}],[\"按照中序遍历的过程\",{\"1\":{\"383\":1}}],[\"按照文档在\",{\"1\":{\"310\":1}}],[\"按照\",{\"1\":{\"302\":1}}],[\"按照消息反压的思路\",{\"1\":{\"282\":1}}],[\"按照安全等级划分服务\",{\"1\":{\"279\":1}}],[\"按照分层设计的原则拆分为3个部分\",{\"1\":{\"273\":1}}],[\"按照点赞率排序\",{\"1\":{\"273\":1}}],[\"按照点赞绝对值排序\",{\"1\":{\"273\":1}}],[\"按照正负样本加权平均的\",{\"1\":{\"273\":1}}],[\"按照时间\",{\"1\":{\"255\":1,\"278\":1}}],[\"按左端点排序\",{\"1\":{\"251\":1}}],[\"按左端点从小到大排序\",{\"1\":{\"249\":1}}],[\"按右端点从小到大排序\",{\"1\":{\"247\":1}}],[\"按字典序\",{\"1\":{\"242\":1}}],[\"按字典序输出所有排列方案\",{\"1\":{\"101\":1}}],[\"按快排的从小到大的顺序遍历每条边\",{\"1\":{\"181\":1}}],[\"按位取反\",{\"1\":{\"158\":1}}],[\"按位异或\",{\"1\":{\"158\":1}}],[\"按位或\",{\"1\":{\"158\":1}}],[\"按位与\",{\"1\":{\"158\":1}}],[\"按值捕获\",{\"1\":{\"75\":2}}],[\"按引用捕获\",{\"1\":{\"75\":1}}],[\"按\",{\"1\":{\"43\":1}}],[\"且每条\",{\"1\":{\"594\":1}}],[\"且每座岛屿只能由上下左右四个方向相连的陆地组成\",{\"1\":{\"48\":1,\"49\":1}}],[\"且不一定经过根节点\",{\"1\":{\"370\":1}}],[\"且不随文件位置的改变而变化\",{\"1\":{\"352\":1}}],[\"且运行不稳定\",{\"1\":{\"353\":1}}],[\"且图片如果有修改\",{\"1\":{\"352\":1}}],[\"且后面配合\",{\"1\":{\"352\":1}}],[\"且只能管理员使用\",{\"1\":{\"312\":1}}],[\"且基本维持相同的热评排序逻辑\",{\"1\":{\"273\":1}}],[\"且热评排序算法应用场景也不仅局限于评论主列表的热度序\",{\"1\":{\"272\":1}}],[\"且多是批量查询\",{\"1\":{\"266\":1}}],[\"且评论计数也只有两级\",{\"1\":{\"263\":1}}],[\"且相对独立\",{\"1\":{\"263\":1}}],[\"且在一个评论区范围内不能出现重复\",{\"1\":{\"261\":1}}],[\"且数据更新实时性不高\",{\"1\":{\"259\":1}}],[\"且数值是严格递增的\",{\"1\":{\"124\":1}}],[\"且x不属于s\",{\"1\":{\"217\":1}}],[\"且原来匹配的点能找到另一个点\",{\"1\":{\"183\":1}}],[\"且到树的距离最短\",{\"1\":{\"180\":1}}],[\"且使权值最小的一种结构\",{\"1\":{\"179\":1}}],[\"且终点是n\",{\"1\":{\"132\":1}}],[\"且保证右端点不会超范围\",{\"1\":{\"127\":1}}],[\"且长度均不超过\",{\"1\":{\"125\":1}}],[\"且总价值最大\",{\"1\":{\"119\":1}}],[\"且一定至少存在一条通路\",{\"1\":{\"98\":1}}],[\"且\",{\"1\":{\"68\":1,\"137\":1,\"203\":1}}],[\"且它们的执行效果相同\",{\"1\":{\"63\":1}}],[\"且astar\",{\"1\":{\"43\":1}}],[\"且边长为\",{\"1\":{\"43\":1}}],[\"volatile\",{\"1\":{\"702\":4}}],[\"void\",{\"1\":{\"43\":2,\"48\":1,\"49\":1,\"55\":1,\"56\":1,\"57\":1,\"75\":1,\"89\":1,\"91\":1,\"93\":2,\"94\":2,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":2,\"129\":2,\"134\":1,\"137\":1,\"138\":1,\"158\":1,\"162\":1,\"165\":2,\"173\":1,\"181\":2,\"188\":1,\"191\":1,\"192\":1,\"193\":1,\"200\":1,\"210\":1,\"223\":5,\"224\":3,\"232\":1,\"234\":2,\"237\":3,\"239\":1,\"251\":1,\"322\":1,\"323\":1,\"363\":1,\"377\":1,\"378\":1,\"389\":1,\"424\":1,\"426\":1,\"443\":1,\"444\":1,\"445\":1,\"469\":1,\"475\":1,\"551\":1,\"553\":3,\"554\":2,\"555\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":4,\"562\":1,\"563\":4,\"565\":1,\"566\":1,\"567\":2,\"570\":1,\"571\":1,\"572\":4,\"573\":2,\"574\":1,\"577\":2,\"579\":1,\"584\":1,\"586\":1,\"587\":2,\"588\":4,\"590\":2,\"591\":3,\"593\":5,\"594\":2,\"595\":1,\"596\":1,\"600\":2,\"601\":1,\"602\":1,\"604\":2,\"605\":1,\"606\":3,\"607\":4,\"619\":1,\"620\":2,\"621\":2,\"622\":1,\"628\":1,\"632\":5,\"634\":2,\"635\":5,\"636\":2,\"675\":4,\"676\":6,\"702\":1,\"706\":1,\"721\":1,\"722\":1}}],[\"v4\",{\"1\":{\"668\":1}}],[\"v>的个数\",{\"1\":{\"647\":1}}],[\"v>>\",{\"1\":{\"647\":1}}],[\"v>多的函数\",{\"1\":{\"613\":1}}],[\"v>\",{\"0\":{\"655\":1},\"1\":{\"613\":4,\"655\":1}}],[\"vhost\",{\"1\":{\"354\":1}}],[\"vipaddressresolver\",{\"1\":{\"711\":1}}],[\"vim\",{\"1\":{\"353\":1}}],[\"visited\",{\"1\":{\"443\":2}}],[\"vis\",{\"1\":{\"48\":2,\"55\":5,\"56\":6,\"57\":5,\"108\":4,\"134\":3}}],[\"vmess\",{\"1\":{\"347\":1}}],[\"vuepress\",{\"1\":{\"340\":3}}],[\"varchar\",{\"1\":{\"321\":14,\"507\":4,\"509\":4}}],[\"validpattern\",{\"1\":{\"310\":2,\"323\":2}}],[\"valid\",{\"1\":{\"131\":4,\"559\":1}}],[\"value>\",{\"1\":{\"647\":1}}],[\"valueof\",{\"1\":{\"642\":2}}],[\"values\",{\"1\":{\"512\":4,\"647\":4,\"654\":1}}],[\"value\",{\"1\":{\"72\":1,\"264\":1,\"291\":1,\"310\":2,\"486\":5,\"487\":1,\"488\":5,\"613\":1,\"647\":4,\"654\":1,\"656\":16,\"707\":1}}],[\"val\",{\"1\":{\"25\":2,\"74\":2,\"144\":4,\"363\":1,\"366\":1,\"389\":1,\"390\":1,\"396\":1,\"432\":2,\"481\":1,\"486\":4,\"487\":2,\"488\":1,\"575\":1,\"583\":2,\"584\":2,\"609\":1,\"651\":2}}],[\"v2rayng\",{\"1\":{\"347\":1}}],[\"v2rayn\",{\"1\":{\"347\":4}}],[\"v2rayu\",{\"1\":{\"347\":3}}],[\"v2ray\",{\"1\":{\"344\":2,\"346\":2}}],[\"v2\",{\"1\":{\"74\":2,\"75\":2,\"586\":2,\"666\":1,\"668\":1}}],[\"v1\",{\"1\":{\"74\":3,\"75\":2,\"586\":2}}],[\"v\",{\"1\":{\"70\":1,\"75\":4,\"76\":11,\"116\":6,\"117\":6,\"118\":19,\"119\":8,\"242\":1,\"647\":3,\"654\":9}}],[\"vector<node>\",{\"1\":{\"243\":1}}],[\"vector<edge>\",{\"1\":{\"165\":1}}],[\"vector<good>\",{\"1\":{\"118\":1}}],[\"vector<vector<int>>\",{\"1\":{\"62\":1,\"74\":1}}],[\"vector<int>\",{\"1\":{\"62\":2,\"70\":1,\"74\":3,\"75\":1,\"76\":1,\"122\":2,\"129\":8,\"131\":1,\"147\":5,\"148\":7,\"149\":4,\"150\":4,\"161\":1,\"189\":2,\"195\":2,\"210\":4,\"242\":1,\"243\":1,\"249\":1,\"456\":3}}],[\"vector<pis>\",{\"1\":{\"44\":1}}],[\"vector<piii>\",{\"1\":{\"43\":1}}],[\"vector<pii>\",{\"1\":{\"43\":1,\"162\":2,\"173\":1,\"251\":1}}],[\"vector\",{\"0\":{\"62\":1},\"1\":{\"74\":4,\"242\":1,\"243\":3,\"251\":1,\"648\":1}}],[\"version\",{\"1\":{\"675\":1,\"727\":2}}],[\"version>\",{\"1\":{\"323\":1,\"672\":1}}],[\"ver\",{\"1\":{\"43\":9,\"173\":4}}],[\"cbrt\",{\"1\":{\"653\":1}}],[\"cba​=\",{\"1\":{\"209\":1}}],[\"csh\",{\"1\":{\"680\":1}}],[\"cs\",{\"1\":{\"642\":2}}],[\"csdn\",{\"1\":{\"311\":1,\"728\":1}}],[\"cpu\",{\"1\":{\"544\":1}}],[\"ceil\",{\"1\":{\"653\":1}}],[\"ceilingentry\",{\"1\":{\"613\":1}}],[\"ceiling\",{\"1\":{\"612\":1}}],[\"certificate\",{\"1\":{\"354\":2}}],[\"centos\",{\"1\":{\"345\":1}}],[\"center\",{\"0\":{\"741\":1},\"1\":{\"302\":3}}],[\"cdn\",{\"1\":{\"350\":2,\"352\":1}}],[\"current\",{\"1\":{\"321\":3}}],[\"crazy\",{\"1\":{\"728\":1}}],[\"creationdate\",{\"1\":{\"675\":1}}],[\"createtime\",{\"1\":{\"321\":2}}],[\"create\",{\"1\":{\"302\":1,\"321\":1,\"500\":2,\"502\":1,\"505\":1,\"508\":1,\"524\":1,\"546\":1}}],[\"credentials\",{\"1\":{\"673\":1}}],[\"crud\",{\"1\":{\"283\":2}}],[\"cmin\",{\"1\":{\"656\":1}}],[\"cmax\",{\"1\":{\"656\":1}}],[\"cmd\",{\"1\":{\"302\":1,\"345\":4,\"662\":1,\"663\":1}}],[\"cmp\",{\"1\":{\"148\":2,\"243\":2}}],[\"cv15278397\",{\"1\":{\"274\":1}}],[\"calculator\",{\"1\":{\"628\":6}}],[\"case\",{\"1\":{\"322\":1,\"559\":9}}],[\"camel\",{\"1\":{\"322\":1}}],[\"canfinish\",{\"1\":{\"475\":1}}],[\"cannot\",{\"1\":{\"310\":1,\"706\":1}}],[\"canal\",{\"1\":{\"279\":1,\"283\":1}}],[\"cacherefreshthread\",{\"1\":{\"715\":1}}],[\"cacherefreshexecutor\",{\"1\":{\"715\":2}}],[\"cache\",{\"1\":{\"261\":1,\"281\":5,\"291\":4,\"293\":5,\"294\":5,\"354\":1}}],[\"catch\",{\"1\":{\"620\":2,\"621\":2,\"622\":2,\"632\":3,\"636\":1,\"676\":1,\"706\":1}}],[\"cat\",{\"1\":{\"211\":1}}],[\"cab​\",{\"1\":{\"210\":1}}],[\"cab​≡ca\",{\"1\":{\"209\":1}}],[\"cab​=b\",{\"1\":{\"208\":1}}],[\"cab​=ca−1b−1​+ca−1b​\",{\"1\":{\"207\":1}}],[\"cab​modp\",{\"1\":{\"209\":1}}],[\"cab​mod\",{\"1\":{\"207\":1}}],[\"capture\",{\"1\":{\"75\":2}}],[\"capacity\",{\"1\":{\"63\":1}}],[\"ck\",{\"1\":{\"196\":1}}],[\"c2\",{\"1\":{\"196\":1}}],[\"c2​\",{\"1\":{\"110\":1}}],[\"c1\",{\"1\":{\"196\":1}}],[\"c1​\",{\"1\":{\"110\":1}}],[\"c表示当前点的颜色\",{\"1\":{\"182\":1}}],[\"change\",{\"1\":{\"509\":2}}],[\"character\",{\"1\":{\"647\":1,\"656\":2}}],[\"charat\",{\"1\":{\"426\":2,\"451\":2,\"578\":2,\"580\":1,\"642\":1,\"643\":1}}],[\"char>>\",{\"1\":{\"44\":1}}],[\"char\",{\"1\":{\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"63\":2,\"66\":1,\"71\":2,\"99\":1,\"123\":1,\"125\":4,\"126\":1,\"231\":1,\"232\":2,\"443\":2,\"444\":2,\"445\":1,\"507\":5,\"551\":1,\"555\":1,\"570\":2,\"571\":1,\"577\":3,\"578\":5,\"580\":1,\"642\":5}}],[\"ch\",{\"1\":{\"425\":4}}],[\"children\",{\"1\":{\"425\":1,\"426\":6}}],[\"chmod\",{\"1\":{\"352\":1,\"660\":1,\"680\":1,\"692\":1}}],[\"checksum\",{\"1\":{\"668\":1}}],[\"checkpassword\",{\"1\":{\"311\":4,\"323\":16}}],[\"check\",{\"1\":{\"111\":3,\"129\":1,\"142\":2,\"143\":1,\"145\":2,\"160\":1,\"182\":1,\"227\":1,\"230\":2}}],[\"circularqueue<pair<long\",{\"1\":{\"717\":2}}],[\"ciphers\",{\"1\":{\"354\":2}}],[\"ci​\",{\"1\":{\"110\":1}}],[\"cin>>n\",{\"1\":{\"132\":1}}],[\"cin\",{\"1\":{\"43\":3,\"44\":1,\"48\":2,\"49\":2,\"50\":2,\"55\":2,\"56\":2,\"57\":2,\"81\":2,\"82\":2,\"83\":2,\"93\":3,\"94\":2,\"98\":2,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":2,\"111\":1,\"116\":2,\"117\":2,\"118\":6,\"119\":6,\"121\":2,\"122\":6,\"123\":1,\"124\":3,\"125\":3,\"126\":2,\"127\":2,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"144\":2,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"165\":1,\"172\":2,\"180\":2,\"196\":2,\"209\":2,\"212\":2,\"214\":2,\"231\":2,\"247\":2,\"248\":2,\"249\":2,\"250\":3,\"251\":2}}],[\"cn\",{\"1\":{\"274\":1,\"322\":1,\"354\":4,\"659\":1,\"660\":1,\"666\":1,\"668\":1}}],[\"cn=ca+b\",{\"1\":{\"111\":1}}],[\"cn​\",{\"1\":{\"110\":1}}],[\"cnt记录素数个数\",{\"1\":{\"191\":1}}],[\"cnt++\",{\"1\":{\"44\":1,\"48\":1,\"49\":1,\"82\":1,\"118\":2,\"131\":1,\"181\":1,\"191\":1,\"193\":1}}],[\"cnt\",{\"1\":{\"43\":4,\"44\":2,\"48\":3,\"49\":3,\"75\":5,\"81\":9,\"82\":2,\"118\":6,\"129\":3,\"131\":4,\"176\":5,\"181\":3,\"191\":1,\"193\":1,\"200\":2,\"210\":4,\"232\":4,\"480\":2,\"481\":5,\"634\":3,\"635\":6}}],[\"c中的\",{\"1\":{\"69\":1}}],[\"c++代码模板\",{\"1\":{\"141\":1,\"142\":1}}],[\"c++\",{\"0\":{\"242\":1},\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"74\":1,\"655\":1}}],[\"cos\",{\"1\":{\"667\":1}}],[\"copyofrange\",{\"1\":{\"640\":1}}],[\"copyof\",{\"1\":{\"640\":1}}],[\"copy\",{\"1\":{\"622\":1}}],[\"core\",{\"1\":{\"347\":1,\"702\":1}}],[\"column1\",{\"1\":{\"534\":2}}],[\"collection<e>\",{\"1\":{\"654\":5}}],[\"collection<v>\",{\"1\":{\"647\":1}}],[\"collections\",{\"0\":{\"654\":1},\"1\":{\"611\":1,\"640\":1,\"651\":1}}],[\"collectors\",{\"1\":{\"313\":1}}],[\"collect\",{\"1\":{\"313\":1}}],[\"colorpoint\",{\"1\":{\"601\":2,\"602\":3}}],[\"color\",{\"1\":{\"182\":7,\"601\":8}}],[\"cookie\",{\"1\":{\"309\":1,\"310\":5}}],[\"component\",{\"1\":{\"673\":1}}],[\"compare\",{\"1\":{\"651\":1}}],[\"compareto\",{\"1\":{\"578\":1}}],[\"comparator<e>\",{\"1\":{\"651\":1}}],[\"comparator\",{\"1\":{\"647\":2,\"651\":1}}],[\"comparable\",{\"1\":{\"647\":2,\"651\":2}}],[\"compile\",{\"1\":{\"310\":1,\"323\":1}}],[\"commonconstants\",{\"1\":{\"714\":1}}],[\"commons<\",{\"1\":{\"323\":1}}],[\"commons\",{\"1\":{\"323\":4}}],[\"command这条命令的stdout\",{\"1\":{\"693\":1}}],[\"command\",{\"1\":{\"693\":3}}],[\"commit\",{\"1\":{\"541\":1}}],[\"comment\",{\"0\":{\"280\":1,\"283\":1,\"284\":1},\"1\":{\"279\":5,\"280\":3,\"281\":2,\"282\":1,\"283\":1,\"284\":2,\"289\":20,\"291\":3,\"293\":1,\"321\":16,\"505\":4,\"509\":4}}],[\"com\",{\"1\":{\"274\":4,\"303\":1,\"310\":1,\"322\":1,\"323\":1,\"343\":1,\"347\":4,\"659\":2,\"663\":1,\"668\":3,\"702\":1}}],[\"code\",{\"1\":{\"66\":1,\"668\":1,\"693\":1,\"708\":1}}],[\"countnodes\",{\"1\":{\"366\":4}}],[\"count\",{\"1\":{\"44\":1,\"99\":1,\"242\":2,\"263\":1,\"264\":1,\"270\":3,\"273\":2,\"289\":1,\"323\":2,\"519\":2,\"635\":15}}],[\"cout\",{\"1\":{\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":2,\"56\":2,\"57\":2,\"63\":1,\"69\":1,\"71\":3,\"81\":1,\"82\":2,\"83\":1,\"94\":2,\"98\":1,\"99\":1,\"107\":2,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":2,\"117\":2,\"118\":4,\"119\":2,\"121\":2,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":2,\"131\":1,\"132\":1,\"144\":1,\"150\":2,\"159\":2,\"172\":1,\"188\":3,\"196\":1,\"209\":1,\"212\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"concurrent\",{\"1\":{\"634\":1}}],[\"concerns\",{\"1\":{\"280\":1}}],[\"condition\",{\"1\":{\"563\":2}}],[\"console\",{\"1\":{\"660\":3,\"661\":1,\"662\":1}}],[\"consistency\",{\"1\":{\"542\":2}}],[\"constructor<\",{\"1\":{\"628\":1}}],[\"constructor\",{\"1\":{\"628\":4}}],[\"constraint\",{\"1\":{\"321\":1,\"524\":2}}],[\"constants\",{\"1\":{\"704\":1}}],[\"constant\",{\"1\":{\"315\":1}}],[\"const\",{\"1\":{\"43\":1,\"55\":1,\"56\":1,\"57\":1,\"63\":3,\"71\":1,\"72\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"131\":1,\"132\":1,\"144\":1,\"145\":1,\"147\":1,\"159\":1,\"172\":1,\"180\":1,\"181\":3,\"196\":1,\"205\":1,\"212\":1,\"231\":1,\"243\":2,\"247\":3,\"248\":3,\"249\":3,\"250\":3,\"251\":1}}],[\"conf\",{\"1\":{\"334\":1,\"354\":2}}],[\"configinstance\",{\"1\":{\"707\":3}}],[\"configname\",{\"1\":{\"706\":2}}],[\"configurationmanager\",{\"1\":{\"702\":2,\"706\":5,\"707\":1,\"708\":2}}],[\"configurationproperties\",{\"1\":{\"673\":1}}],[\"configuration\",{\"1\":{\"322\":1,\"673\":1,\"706\":1}}],[\"config\",{\"1\":{\"302\":6,\"310\":2,\"673\":1,\"675\":1,\"704\":1,\"706\":1,\"714\":3,\"715\":4,\"717\":2}}],[\"containsvalue\",{\"1\":{\"647\":1}}],[\"containskey\",{\"1\":{\"613\":1,\"647\":1}}],[\"contains\",{\"1\":{\"612\":1,\"642\":1,\"646\":1}}],[\"control\",{\"1\":{\"496\":1}}],[\"controller\",{\"1\":{\"311\":4}}],[\"contextinitialized\",{\"1\":{\"702\":1,\"703\":1}}],[\"context\",{\"1\":{\"311\":1}}],[\"content\",{\"1\":{\"263\":2,\"264\":2,\"289\":11,\"291\":1}}],[\"continue\",{\"0\":{\"566\":1},\"1\":{\"43\":1,\"127\":1,\"173\":1,\"191\":1,\"205\":1,\"444\":1,\"566\":1}}],[\"c\",{\"1\":{\"43\":6,\"44\":5,\"63\":2,\"65\":2,\"71\":2,\"77\":1,\"93\":5,\"99\":3,\"110\":8,\"111\":16,\"144\":8,\"147\":9,\"148\":14,\"149\":11,\"150\":12,\"154\":2,\"155\":4,\"165\":4,\"172\":5,\"173\":2,\"175\":2,\"180\":3,\"181\":1,\"182\":4,\"191\":1,\"205\":13,\"207\":5,\"209\":6,\"210\":5,\"211\":1,\"242\":1,\"358\":1,\"551\":1,\"553\":2,\"555\":1,\"557\":6,\"558\":4,\"561\":2,\"563\":2,\"570\":1,\"571\":1,\"577\":4,\"578\":5,\"642\":4,\"654\":3,\"680\":1}}],[\"cls\",{\"1\":{\"628\":5}}],[\"cloneable\",{\"1\":{\"618\":1}}],[\"clone\",{\"1\":{\"618\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"618\":1}}],[\"cloud\",{\"0\":{\"755\":1},\"1\":{\"354\":4}}],[\"cloudreve\",{\"0\":{\"351\":1,\"357\":1},\"1\":{\"350\":1,\"351\":2,\"352\":12,\"353\":16,\"354\":1,\"356\":1,\"357\":2,\"358\":1}}],[\"close\",{\"1\":{\"35\":4}}],[\"clash\",{\"1\":{\"343\":1}}],[\"class<\",{\"1\":{\"628\":1}}],[\"classnotfoundexception\",{\"1\":{\"618\":1,\"628\":1}}],[\"classcastexception\",{\"1\":{\"618\":1}}],[\"class\",{\"1\":{\"25\":1,\"311\":3,\"323\":1,\"363\":1,\"366\":1,\"377\":1,\"378\":1,\"389\":1,\"390\":1,\"396\":1,\"401\":1,\"402\":1,\"408\":1,\"414\":1,\"420\":2,\"426\":1,\"432\":1,\"438\":1,\"443\":1,\"444\":1,\"445\":1,\"451\":1,\"456\":1,\"463\":1,\"469\":2,\"475\":1,\"481\":1,\"486\":1,\"487\":1,\"488\":1,\"522\":1,\"551\":1,\"553\":3,\"554\":2,\"555\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":4,\"562\":1,\"563\":4,\"565\":1,\"566\":1,\"567\":2,\"570\":1,\"571\":1,\"572\":4,\"573\":2,\"574\":1,\"577\":2,\"579\":1,\"584\":1,\"587\":1,\"588\":1,\"590\":1,\"591\":1,\"593\":1,\"594\":1,\"595\":1,\"596\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"606\":1,\"607\":2,\"618\":1,\"620\":1,\"621\":1,\"622\":1,\"628\":7,\"632\":5,\"634\":2,\"635\":5,\"636\":2,\"673\":2,\"702\":1,\"707\":1}}],[\"clientconfig\",{\"1\":{\"715\":2,\"717\":2}}],[\"client\",{\"0\":{\"713\":1,\"714\":1},\"1\":{\"354\":1,\"668\":1,\"710\":1,\"714\":3,\"715\":2,\"717\":1}}],[\"cli\",{\"1\":{\"302\":1,\"668\":1}}],[\"cluster\",{\"1\":{\"289\":1}}],[\"clear\",{\"1\":{\"131\":1,\"242\":4,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1}}],[\"反制面试官\",{\"1\":{\"702\":1}}],[\"反射\",{\"0\":{\"627\":1},\"1\":{\"627\":1}}],[\"反复思考\",{\"1\":{\"278\":1}}],[\"反之亦然\",{\"1\":{\"408\":1}}],[\"反之则为\",{\"1\":{\"212\":1}}],[\"反之\",{\"1\":{\"203\":1}}],[\"反之为\",{\"1\":{\"201\":1}}],[\"反证法证明\",{\"1\":{\"188\":1}}],[\"反向代理通常由服务器管理员配置\",{\"1\":{\"329\":1}}],[\"反向代理主要用于服务器端的负载均衡\",{\"1\":{\"329\":1}}],[\"反向代理靠近服务器端\",{\"1\":{\"329\":1}}],[\"反向代理\",{\"1\":{\"329\":1}}],[\"反向搜索\",{\"1\":{\"43\":1}}],[\"反向建边求终点到各点的距离作为估计值\",{\"1\":{\"43\":1}}],[\"反过来顺着父节点的顺序找到起点\",{\"1\":{\"32\":1}}],[\"包\",{\"1\":{\"315\":1}}],[\"包下新建两个对象\",{\"1\":{\"311\":1}}],[\"包含路径\",{\"1\":{\"692\":1}}],[\"包含一组变量和函数\",{\"1\":{\"598\":1}}],[\"包含一个由字符\",{\"1\":{\"100\":1}}],[\"包含一个字符串\",{\"1\":{\"44\":1}}],[\"包含一个整数\",{\"1\":{\"43\":1,\"99\":1,\"101\":1}}],[\"包含常用的增删改查\",{\"1\":{\"322\":1}}],[\"包含\",{\"1\":{\"159\":1}}],[\"包含前导零\",{\"1\":{\"129\":1}}],[\"包含两个用空格隔开的整数\",{\"1\":{\"110\":1}}],[\"包括但不限于\",{\"1\":{\"666\":1}}],[\"包括但不限于书籍\",{\"1\":{\"19\":1}}],[\"包括两张表交集部分数据\",{\"1\":{\"530\":2}}],[\"包括文件的读取\",{\"1\":{\"358\":1}}],[\"包括一些已有的在线\",{\"1\":{\"273\":1}}],[\"包括算法和策略的快速迭代\",{\"1\":{\"273\":1}}],[\"包括算法题\",{\"1\":{\"1\":1}}],[\"包括缓存\",{\"1\":{\"269\":1}}],[\"包括\",{\"1\":{\"263\":1,\"642\":1}}],[\"包括评论\",{\"1\":{\"263\":1}}],[\"包括总评论数\",{\"1\":{\"263\":1}}],[\"包括发布人\",{\"1\":{\"263\":1}}],[\"包括送审\",{\"1\":{\"261\":1}}],[\"包括负权边\",{\"1\":{\"174\":1}}],[\"包括编程语言\",{\"1\":{\"7\":1}}],[\"输入一整行字符串\",{\"1\":{\"579\":1}}],[\"输入一个\",{\"1\":{\"572\":1}}],[\"输入一个年份\",{\"1\":{\"557\":1}}],[\"输入一个0到100之间的分数\",{\"1\":{\"557\":1}}],[\"输入一个迭代器\",{\"1\":{\"242\":1}}],[\"输入一个整数\",{\"1\":{\"107\":1,\"557\":1}}],[\"输入一个二维数组\",{\"1\":{\"48\":1}}],[\"输入字符串\",{\"1\":{\"579\":1}}],[\"输入与输出\",{\"0\":{\"579\":1}}],[\"输入三个数\",{\"1\":{\"558\":1}}],[\"输入三个整数\",{\"1\":{\"557\":1}}],[\"输入两个整数\",{\"1\":{\"557\":1}}],[\"输入规模较大时使用\",{\"1\":{\"554\":1}}],[\"输入规模较小时使用\",{\"1\":{\"554\":1}}],[\"输入想要配置的域名\",{\"1\":{\"354\":1}}],[\"输入管理员账号密码进入\",{\"1\":{\"352\":1}}],[\"输入代理的\",{\"1\":{\"347\":1}}],[\"输入以下命令初始化前端\",{\"1\":{\"302\":1}}],[\"输入的参数是pair或者迭代器\",{\"1\":{\"242\":1}}],[\"输入是一个数x\",{\"1\":{\"242\":1}}],[\"输入\",{\"0\":{\"554\":1},\"1\":{\"210\":1,\"302\":1,\"345\":1,\"572\":1}}],[\"输入占一行\",{\"1\":{\"44\":1,\"99\":1}}],[\"输入样例3\",{\"1\":{\"82\":1}}],[\"输入样例2\",{\"1\":{\"82\":1,\"100\":1,\"111\":1}}],[\"输入样例1\",{\"1\":{\"82\":1,\"100\":1,\"111\":1}}],[\"输入样例\",{\"1\":{\"43\":1,\"44\":1,\"81\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"124\":1}}],[\"输入格式\",{\"1\":{\"43\":1,\"44\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"124\":1,\"125\":1,\"159\":1,\"204\":1}}],[\"输出3\",{\"1\":{\"690\":1}}],[\"输出yxcacwing\",{\"1\":{\"686\":1}}],[\"输出yxc\",{\"1\":{\"686\":2}}],[\"输出yes\",{\"1\":{\"55\":1}}],[\"输出二维数组\",{\"1\":{\"573\":1}}],[\"输出三个数中的最大值\",{\"1\":{\"558\":1}}],[\"输出三个数中最大的那个\",{\"1\":{\"557\":1}}],[\"输出c\",{\"1\":{\"557\":1}}],[\"输出b\",{\"1\":{\"557\":1}}],[\"输出a\",{\"1\":{\"557\":1}}],[\"输出两个数中较大的那个\",{\"1\":{\"557\":1}}],[\"输出这个数的绝对值\",{\"1\":{\"557\":1}}],[\"输出规模较大时使用\",{\"1\":{\"555\":1}}],[\"输出规模较小时使用\",{\"1\":{\"555\":1}}],[\"输出字符串\",{\"1\":{\"555\":2}}],[\"输出整数\",{\"1\":{\"555\":2}}],[\"输出选择的点的最小数量\",{\"1\":{\"247\":1}}],[\"输出以0开始的匹配子串的首字母下标\",{\"1\":{\"231\":1}}],[\"输出最小非负整数\",{\"1\":{\"204\":1}}],[\"输出i的s次幂\",{\"1\":{\"188\":1}}],[\"输出即可\",{\"1\":{\"188\":1}}],[\"输出如下\",{\"1\":{\"159\":1}}],[\"输出共\",{\"1\":{\"125\":1}}],[\"输出输入数字用数码\",{\"1\":{\"111\":1}}],[\"输出方案\",{\"1\":{\"108\":1}}],[\"输出所有可能的次序\",{\"1\":{\"108\":1}}],[\"输出所有可能的选择方案\",{\"1\":{\"107\":1,\"109\":1}}],[\"输出空行\",{\"1\":{\"107\":1,\"688\":1}}],[\"输出一行\",{\"1\":{\"93\":1}}],[\"输出一个正整数\",{\"1\":{\"83\":1}}],[\"输出一个整数\",{\"1\":{\"81\":1,\"82\":1,\"98\":1,\"110\":1,\"124\":1}}],[\"输出\",{\"0\":{\"555\":1},\"1\":{\"63\":2,\"82\":1,\"94\":1,\"557\":1,\"690\":2}}],[\"输出不会被截断\",{\"1\":{\"63\":1}}],[\"输出时\",{\"1\":{\"63\":1}}],[\"输出结果\",{\"1\":{\"56\":1,\"57\":1}}],[\"输出no\",{\"1\":{\"55\":1}}],[\"输出任意一种合法方案即可\",{\"1\":{\"44\":1}}],[\"输出样例3\",{\"1\":{\"82\":1}}],[\"输出样例2\",{\"1\":{\"82\":1,\"100\":1,\"111\":1}}],[\"输出样例1\",{\"1\":{\"82\":1,\"100\":1,\"111\":1}}],[\"输出样例\",{\"1\":{\"43\":1,\"44\":1,\"81\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"124\":1}}],[\"输出占一行\",{\"1\":{\"43\":1,\"44\":1,\"99\":1}}],[\"输出格式\",{\"1\":{\"43\":1,\"44\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"124\":1,\"125\":1,\"159\":1,\"204\":1}}],[\"分割字符串\",{\"1\":{\"578\":1}}],[\"分子除以分母\",{\"1\":{\"552\":1}}],[\"分析并设计表结构\",{\"1\":{\"523\":1}}],[\"分组之后\",{\"1\":{\"520\":1}}],[\"分组后过滤条件\",{\"1\":{\"520\":1}}],[\"分组后条件列表\",{\"1\":{\"516\":1}}],[\"分组字段\",{\"1\":{\"521\":1}}],[\"分组字段名\",{\"1\":{\"520\":1}}],[\"分组字段列表\",{\"1\":{\"516\":1}}],[\"分组其实就是按列进行分类\",{\"1\":{\"520\":1}}],[\"分组\",{\"1\":{\"520\":1}}],[\"分组查询通常会使用聚合函数进行计算\",{\"1\":{\"520\":1}}],[\"分组查询\",{\"0\":{\"520\":1},\"1\":{\"516\":1}}],[\"分组背包\",{\"0\":{\"119\":1}}],[\"分库分表等\",{\"1\":{\"497\":1}}],[\"分类\",{\"0\":{\"496\":1,\"530\":1},\"1\":{\"496\":1}}],[\"分类讨论\",{\"1\":{\"407\":2}}],[\"分钟\",{\"1\":{\"717\":1}}],[\"分钟开始\",{\"1\":{\"468\":1}}],[\"分钟左右就能批下来\",{\"1\":{\"354\":1}}],[\"分\",{\"1\":{\"309\":1}}],[\"分成了\",{\"1\":{\"289\":3}}],[\"分成子问题\",{\"1\":{\"137\":2}}],[\"分页操作在业务系统开发时\",{\"1\":{\"522\":1}}],[\"分页查询是数据库的方言\",{\"1\":{\"522\":1}}],[\"分页查询语法\",{\"1\":{\"522\":1}}],[\"分页查询\",{\"0\":{\"522\":1},\"1\":{\"516\":1}}],[\"分页参数\",{\"1\":{\"516\":1}}],[\"分页\",{\"1\":{\"279\":1}}],[\"分片存储\",{\"1\":{\"334\":1}}],[\"分片\",{\"1\":{\"264\":1}}],[\"分享链接\",{\"1\":{\"255\":1}}],[\"分为两步\",{\"1\":{\"702\":1}}],[\"分为两个步骤\",{\"1\":{\"258\":1}}],[\"分为两种情况\",{\"1\":{\"200\":1}}],[\"分为两大类\",{\"1\":{\"171\":1}}],[\"分解质因数的方式比较好用\",{\"1\":{\"210\":1}}],[\"分解质因数法求组合数\",{\"0\":{\"210\":1}}],[\"分解质因数\",{\"1\":{\"199\":1}}],[\"分治算法都有三步\",{\"1\":{\"137\":1}}],[\"分数不考虑约分的情况\",{\"1\":{\"111\":1}}],[\"分别保存了对应基本类型的最大值与最小值\",{\"1\":{\"656\":1}}],[\"分别关联两方主键\",{\"1\":{\"526\":1}}],[\"分别是\",{\"1\":{\"353\":1}}],[\"分别记录注册和登录的请求参数\",{\"1\":{\"311\":1}}],[\"分别到达节点y1\",{\"1\":{\"218\":1}}],[\"分别适用于不同情况\",{\"1\":{\"140\":1}}],[\"分别出现且只出现一次\",{\"1\":{\"111\":1}}],[\"分别代表目标的\",{\"1\":{\"83\":1}}],[\"分别代表地图上的目标数目和正方形包含的横纵位置数量\",{\"1\":{\"83\":1}}],[\"分别用来求最大元素和最小元素的值\",{\"1\":{\"76\":1}}],[\"分别用来求最大元素和最小元素的位置\",{\"1\":{\"76\":1}}],[\"分别表示起点\",{\"1\":{\"43\":1}}],[\"分布式计算中间件等\",{\"1\":{\"14\":1}}],[\"分布式应用软件借助这种软件在不同的技术之间共享资源\",{\"1\":{\"14\":1}}],[\"行子查询\",{\"0\":{\"537\":1},\"1\":{\"534\":1}}],[\"行row\",{\"1\":{\"205\":1}}],[\"行包含两个整数\",{\"1\":{\"204\":1}}],[\"行包含整数\",{\"1\":{\"204\":1}}],[\"行的整数表示第\",{\"1\":{\"110\":1}}],[\"行询问\",{\"1\":{\"93\":1}}],[\"行有\",{\"1\":{\"93\":1}}],[\"行每行包含一个整数\",{\"1\":{\"81\":1}}],[\"行\",{\"1\":{\"43\":1,\"83\":1,\"94\":1,\"98\":1,\"100\":3,\"110\":2,\"125\":3,\"204\":1}}],[\"ksh\",{\"1\":{\"680\":1}}],[\"k8s\",{\"1\":{\"668\":1}}],[\"kthsmallest\",{\"1\":{\"363\":1,\"366\":3}}],[\"killmode=mixed\",{\"1\":{\"353\":1}}],[\"kv\",{\"1\":{\"289\":1,\"290\":1}}],[\"kafka\",{\"1\":{\"281\":1,\"282\":3,\"291\":2,\"293\":4}}],[\"kong\",{\"1\":{\"279\":1}}],[\"keys\",{\"1\":{\"647\":1}}],[\"keyset\",{\"1\":{\"647\":2}}],[\"key存放路径\",{\"1\":{\"354\":1}}],[\"key\",{\"1\":{\"242\":1,\"264\":2,\"273\":1,\"281\":1,\"283\":2,\"291\":2,\"293\":2,\"294\":5,\"321\":1,\"334\":3,\"354\":3,\"506\":2,\"524\":5,\"545\":7,\"612\":2,\"613\":6,\"647\":7}}],[\"kmp\",{\"0\":{\"231\":1}}],[\"k指向的下一节点指向新节点\",{\"1\":{\"223\":1}}],[\"k2\",{\"1\":{\"204\":2}}],[\"k1\",{\"1\":{\"204\":7}}],[\"k表示走到j这个点之前\",{\"1\":{\"132\":1}}],[\"k辆车\",{\"1\":{\"110\":1}}],[\"kruskal\",{\"0\":{\"181\":1},\"1\":{\"87\":1,\"181\":1}}],[\"k==0\",{\"1\":{\"81\":1}}],[\"k⩽1000001⩽ai​⩽100000\",{\"1\":{\"81\":1}}],[\"k++\",{\"1\":{\"43\":1,\"118\":2,\"119\":2,\"127\":2,\"129\":3,\"132\":1,\"138\":4,\"178\":1,\"240\":1,\"444\":1,\"469\":1}}],[\"k\",{\"1\":{\"43\":9,\"81\":16,\"99\":5,\"110\":8,\"118\":22,\"119\":10,\"127\":8,\"129\":12,\"131\":2,\"132\":7,\"138\":1,\"142\":1,\"158\":2,\"159\":9,\"165\":1,\"178\":4,\"193\":1,\"201\":9,\"208\":4,\"209\":4,\"223\":6,\"224\":11,\"237\":8,\"239\":5,\"240\":6,\"241\":2,\"242\":3,\"334\":5,\"362\":2,\"363\":8,\"364\":1,\"365\":10,\"366\":5,\"420\":1,\"444\":4,\"455\":2,\"456\":4,\"469\":4,\"567\":3,\"620\":2,\"647\":5,\"680\":1}}],[\"编译报错的解决方案\",{\"0\":{\"726\":1}}],[\"编译器会根据实参的类型选择最匹配的函数来执行\",{\"1\":{\"595\":1}}],[\"编译器会拋出\",{\"1\":{\"63\":1}}],[\"编写函数\",{\"0\":{\"583\":1}}],[\"编写sql语句对数据表中的数据进行增删改查操作\",{\"1\":{\"497\":1}}],[\"编写测试类\",{\"1\":{\"322\":1}}],[\"编排后下发给客户端\",{\"1\":{\"258\":1}}],[\"编辑距离\",{\"0\":{\"125\":1}}],[\"编号\",{\"1\":{\"43\":1}}],[\"编程语言\",{\"0\":{\"9\":1}}],[\"个奇偶校验块\",{\"1\":{\"668\":1}}],[\"个指针\",{\"1\":{\"545\":1}}],[\"个符合要求的路径\",{\"1\":{\"480\":1}}],[\"个方向上相邻\",{\"1\":{\"467\":1}}],[\"个方程\",{\"1\":{\"205\":2}}],[\"个子节点\",{\"1\":{\"425\":1}}],[\"个节点\",{\"1\":{\"363\":1,\"474\":1}}],[\"个小时\",{\"1\":{\"354\":1}}],[\"个哈希值\",{\"1\":{\"334\":1}}],[\"个闭区间\",{\"1\":{\"250\":1}}],[\"个链表\",{\"1\":{\"223\":1}}],[\"个不同的质数\",{\"1\":{\"212\":1}}],[\"个未知数的多元线性方程组\",{\"1\":{\"205\":1}}],[\"个未知数的线性方程组\",{\"1\":{\"205\":1}}],[\"个式子合并\",{\"1\":{\"204\":1}}],[\"个质数\",{\"1\":{\"191\":1}}],[\"个顶点的连通块筛选出来\",{\"1\":{\"181\":1}}],[\"个顶点\",{\"1\":{\"179\":1}}],[\"个位置都是\",{\"1\":{\"334\":1}}],[\"个位置都设置为\",{\"1\":{\"334\":1}}],[\"个位置的正方形内的所有目标\",{\"1\":{\"83\":1}}],[\"个位\",{\"1\":{\"147\":1,\"148\":1}}],[\"个人测试证书\",{\"1\":{\"354\":1}}],[\"个人\",{\"1\":{\"352\":1}}],[\"个人来\",{\"1\":{\"134\":1}}],[\"个人不来\",{\"1\":{\"134\":1}}],[\"个人介绍和档案放置在此\",{\"1\":{\"0\":1}}],[\"个物品全不选也是一种方案\",{\"1\":{\"128\":2}}],[\"个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串\",{\"1\":{\"125\":1}}],[\"个长度不超过\",{\"1\":{\"125\":1}}],[\"个数据块\",{\"1\":{\"668\":1}}],[\"个数按从小到大的顺序输出\",{\"1\":{\"572\":1}}],[\"个数字\",{\"1\":{\"455\":1}}],[\"个数字和一个\",{\"1\":{\"44\":1,\"99\":1}}],[\"个数来组合\",{\"1\":{\"201\":1}}],[\"个数的二进制表示中\",{\"1\":{\"159\":1}}],[\"个数表示数列中的第\",{\"1\":{\"159\":1}}],[\"个数必须不重不漏\",{\"1\":{\"111\":1}}],[\"个数划分给\",{\"1\":{\"111\":1}}],[\"个数\",{\"1\":{\"111\":1,\"201\":1,\"572\":1}}],[\"个\",{\"1\":{\"108\":1,\"109\":2,\"128\":3,\"545\":1}}],[\"个空格隔开\",{\"1\":{\"107\":1}}],[\"个操作\",{\"1\":{\"94\":1}}],[\"个目标\",{\"1\":{\"83\":1}}],[\"个整数逆序输出\",{\"1\":{\"572\":1}}],[\"个整数中随机选出\",{\"1\":{\"109\":1}}],[\"个整数中随机选取任意多个\",{\"1\":{\"107\":1}}],[\"个整数排成一行后随机打乱顺序\",{\"1\":{\"108\":1}}],[\"个整数\",{\"1\":{\"82\":1,\"98\":1,\"124\":2,\"128\":1,\"159\":2,\"204\":1,\"572\":1}}],[\"个元素和\",{\"1\":{\"94\":1}}],[\"个元素\",{\"1\":{\"89\":1,\"365\":1,\"545\":5}}],[\"个元素的和\",{\"1\":{\"81\":1}}],[\"个元素到第\",{\"1\":{\"81\":1}}],[\"个值为\",{\"1\":{\"74\":1}}],[\"个点的带权无向图\",{\"1\":{\"132\":1}}],[\"个点\",{\"1\":{\"43\":1,\"171\":1}}],[\"给这个列表记录一个长度\",{\"1\":{\"270\":1}}],[\"给以\",{\"1\":{\"155\":1}}],[\"给区间\",{\"1\":{\"154\":1}}],[\"给出\",{\"1\":{\"473\":1}}],[\"给出一串数以及一个数字\",{\"1\":{\"144\":1}}],[\"给出了一些亲戚关系\",{\"1\":{\"93\":1}}],[\"给父亲更新\",{\"1\":{\"134\":1}}],[\"给定n堆物品\",{\"1\":{\"214\":1}}],[\"给定n个0和n个1\",{\"1\":{\"211\":1}}],[\"给定整数\",{\"1\":{\"192\":1}}],[\"给定两个非负整数\",{\"1\":{\"149\":1,\"150\":1}}],[\"给定两个正整数\",{\"1\":{\"147\":1,\"148\":1,\"207\":1}}],[\"给定两个整数数组\",{\"1\":{\"418\":1}}],[\"给定两个整数\",{\"1\":{\"129\":1}}],[\"给定两个字符串\",{\"1\":{\"126\":1,\"449\":1}}],[\"给定两个长度分别为\",{\"1\":{\"123\":1}}],[\"给定\",{\"1\":{\"125\":1,\"204\":1,\"209\":1,\"247\":1,\"249\":1,\"250\":1}}],[\"给定一个二叉树\",{\"1\":{\"400\":1,\"406\":1}}],[\"给定一个二叉树的\",{\"1\":{\"388\":1}}],[\"给定一个二叉树的根节点\",{\"1\":{\"382\":1,\"479\":1}}],[\"给定一个二叉搜索树的根节点\",{\"1\":{\"362\":1}}],[\"给定一个序列\",{\"1\":{\"227\":1}}],[\"给定一个有向无环图\",{\"1\":{\"216\":1}}],[\"给定一个包含\",{\"1\":{\"205\":1}}],[\"给定一个如下图所示的数字三角形\",{\"1\":{\"121\":1}}],[\"给定一个整数\",{\"1\":{\"101\":1,\"212\":1}}],[\"给定一个\",{\"1\":{\"98\":1}}],[\"给定一个长度为\",{\"1\":{\"81\":1,\"82\":1,\"159\":1}}],[\"给定一张\",{\"1\":{\"43\":1,\"132\":1}}],[\"给你一棵二叉树的根节点\",{\"1\":{\"412\":1,\"461\":1}}],[\"给你一个由\",{\"1\":{\"442\":1}}],[\"给你一个整数数组\",{\"1\":{\"436\":1,\"455\":1}}],[\"给你一个二叉树的根节点\",{\"1\":{\"370\":1,\"430\":1,\"485\":1}}],[\"给你一个初始网格\",{\"1\":{\"44\":1,\"99\":1}}],[\"给你二叉树的根节点\",{\"1\":{\"394\":1}}],[\"给你二叉树的根结点\",{\"1\":{\"376\":1}}],[\"给你两棵二叉树\",{\"1\":{\"24\":1}}],[\"例二\",{\"0\":{\"94\":1},\"1\":{\"144\":1}}],[\"例一\",{\"0\":{\"93\":1}}],[\"例题二\",{\"1\":{\"159\":1}}],[\"例题一\",{\"1\":{\"159\":1}}],[\"例题\",{\"0\":{\"42\":1,\"159\":1},\"1\":{\"558\":1,\"565\":1,\"566\":1}}],[\"例如用来配置应用程序的任何切面\",{\"1\":{\"624\":1}}],[\"例如标记过时的功能\",{\"1\":{\"624\":1}}],[\"例如对数组\",{\"1\":{\"618\":1}}],[\"例如在一间教室中\",{\"1\":{\"598\":1}}],[\"例如在批量查询评论发布人的粉丝勋章数据之后\",{\"1\":{\"258\":1}}],[\"例如自动补完和拼写检查\",{\"1\":{\"424\":1}}],[\"例如常见的常见的守护进程包括系统日志进程\",{\"1\":{\"353\":1}}],[\"例如测试\",{\"1\":{\"309\":1}}],[\"例如排序提权\",{\"1\":{\"273\":1}}],[\"例如单个\",{\"1\":{\"273\":1}}],[\"例如视频表的评论数\",{\"1\":{\"270\":1}}],[\"例如依据评论的状态来做评论区的计数更新\",{\"1\":{\"270\":1}}],[\"例如评论计数\",{\"1\":{\"270\":1}}],[\"例如评论点赞点踩\",{\"1\":{\"270\":1}}],[\"例如评论列表的露出\",{\"1\":{\"269\":1}}],[\"例如审核删除的有害评论\",{\"1\":{\"269\":1}}],[\"例如查询评论列表\",{\"1\":{\"260\":1}}],[\"例如up主点赞等\",{\"1\":{\"263\":1}}],[\"例如up主点赞\",{\"1\":{\"255\":1}}],[\"例如表情\",{\"1\":{\"255\":1}}],[\"例如音乐会\",{\"1\":{\"254\":1}}],[\"例如电影\",{\"1\":{\"254\":1}}],[\"例如求长度\",{\"1\":{\"160\":1}}],[\"例如求\",{\"1\":{\"159\":1,\"563\":1}}],[\"例如上图中的海域未来会变成如下样子\",{\"1\":{\"100\":1}}],[\"例如上图就有\",{\"1\":{\"100\":1}}],[\"例如超过\",{\"1\":{\"63\":1}}],[\"例如\",{\"1\":{\"33\":1,\"44\":3,\"99\":3,\"109\":1,\"147\":1,\"148\":1,\"158\":2,\"242\":1,\"269\":1,\"449\":1,\"473\":1,\"578\":1,\"591\":1,\"618\":1,\"683\":1,\"685\":1,\"692\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":1}}],[\"79300058\",{\"1\":{\"728\":1}}],[\"7976931348623157\",{\"1\":{\"507\":3}}],[\"70\",{\"1\":{\"557\":1}}],[\"78\",{\"1\":{\"553\":1}}],[\"783469249310599\",{\"1\":{\"274\":1}}],[\"777\",{\"1\":{\"507\":2}}],[\"7108973163333025805\",{\"1\":{\"274\":1}}],[\"7\",{\"0\":{\"42\":1,\"68\":1,\"133\":1,\"134\":1,\"160\":1,\"183\":1,\"205\":1,\"237\":1,\"272\":1,\"273\":1,\"274\":1,\"522\":1,\"539\":1,\"540\":1,\"541\":1,\"542\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"606\":1,\"607\":1,\"621\":1,\"726\":1},\"1\":{\"41\":1,\"44\":9,\"81\":4,\"93\":3,\"94\":1,\"99\":9,\"100\":1,\"109\":1,\"121\":2,\"128\":2,\"196\":1,\"272\":1,\"274\":1,\"345\":1,\"559\":1,\"563\":1,\"573\":1,\"574\":1,\"715\":1}}],[\"↓\",{\"1\":{\"41\":1}}],[\"↑\",{\"1\":{\"41\":1}}],[\"以此类推\",{\"1\":{\"692\":1}}],[\"以此来提高数据的操作效率\",{\"1\":{\"525\":1}}],[\"以m为底取n的对数\",{\"1\":{\"653\":1}}],[\"以10为底取对数\",{\"1\":{\"653\":1}}],[\"以e为底取对数\",{\"1\":{\"653\":1}}],[\"以外的异常\",{\"1\":{\"617\":1}}],[\"以外的数据类型的对象\",{\"1\":{\"591\":1}}],[\"以分号结尾\",{\"1\":{\"495\":1}}],[\"以便可以通过http访问\",{\"1\":{\"676\":1}}],[\"以便给其他节点搜索\",{\"1\":{\"474\":1}}],[\"以便于软件各部件之间的沟通\",{\"1\":{\"14\":1}}],[\"以升序数组的中间元素作为根节点\",{\"1\":{\"438\":1}}],[\"以跨平台\",{\"1\":{\"351\":1}}],[\"以阿里云服务器为例\",{\"1\":{\"345\":1}}],[\"以验证密码是否正确\",{\"1\":{\"323\":1}}],[\"以避免敏感数据泄露和数据窃取的风险\",{\"1\":{\"309\":1}}],[\"以上\",{\"1\":{\"302\":1}}],[\"以上就是本文的内容\",{\"1\":{\"51\":1}}],[\"以统一的接口形式提供平台化的能力\",{\"1\":{\"284\":1}}],[\"以评论列表的访问为例\",{\"1\":{\"263\":1}}],[\"以及对数据安全的保障服务\",{\"1\":{\"667\":1}}],[\"以及存储桶索引\",{\"1\":{\"667\":1}}],[\"以及下载限速\",{\"1\":{\"352\":1}}],[\"以及校验码\",{\"1\":{\"323\":1}}],[\"以及再加上两个权限常量\",{\"1\":{\"315\":1}}],[\"以及大量透穿导致的密集写\",{\"1\":{\"293\":1}}],[\"以及该评论的一些相关信息\",{\"1\":{\"289\":1}}],[\"以及通过缓存来保护下游\",{\"1\":{\"273\":1}}],[\"以及热评的热评\",{\"1\":{\"266\":1}}],[\"以及一个线段区间\",{\"1\":{\"250\":1}}],[\"以及所有阶乘取模的逆元infact\",{\"1\":{\"208\":1}}],[\"以second为第二关键字\",{\"1\":{\"242\":1}}],[\"以first为第一关键字\",{\"1\":{\"242\":1}}],[\"以内的素数表的话\",{\"1\":{\"192\":1}}],[\"以内的合数的最小质因数一定不超过\",{\"1\":{\"192\":1}}],[\"以k为终点的最短距离\",{\"1\":{\"132\":1}}],[\"以最快的速度给出答案\",{\"1\":{\"93\":1}}],[\"以下方案需要准备两台服务器\",{\"1\":{\"344\":1}}],[\"以下\",{\"1\":{\"81\":1,\"93\":1,\"100\":1}}],[\"以防爆栈风险\",{\"1\":{\"66\":1}}],[\"以\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"56\":1,\"57\":1,\"82\":1,\"153\":1,\"463\":1}}],[\"以边权都为1为例\",{\"1\":{\"41\":1}}],[\"证书后\",{\"1\":{\"354\":1}}],[\"证书\",{\"1\":{\"354\":1}}],[\"证明端口能连接\",{\"1\":{\"345\":1}}],[\"证明终点第一次出队列即最优解\",{\"1\":{\"41\":1}}],[\"证毕\",{\"1\":{\"41\":1}}],[\"矛盾\",{\"1\":{\"41\":1}}],[\"小数\",{\"1\":{\"553\":1}}],[\"小数值\",{\"1\":{\"507\":1}}],[\"小整数值\",{\"1\":{\"507\":1}}],[\"小时\",{\"1\":{\"312\":1}}],[\"小于等于\",{\"1\":{\"518\":1,\"557\":1}}],[\"小于\",{\"1\":{\"485\":1,\"518\":1,\"557\":1}}],[\"小于号\",{\"1\":{\"243\":2}}],[\"小于eps视为0\",{\"1\":{\"205\":1}}],[\"小技巧\",{\"1\":{\"241\":1}}],[\"小方格的种类数\",{\"1\":{\"131\":1}}],[\"小沐沐要你来告诉奶牛什么是最长公共上升子序列\",{\"1\":{\"124\":1}}],[\"小沐沐说\",{\"1\":{\"124\":1}}],[\"小沐沐先让奶牛研究了最长上升子序列\",{\"1\":{\"124\":1}}],[\"小猫们终于爬上了山顶\",{\"1\":{\"110\":1}}],[\"小猫们要去爬山\",{\"1\":{\"110\":1}}],[\"小树接在大树下面\",{\"1\":{\"94\":1}}],[\"小结\",{\"0\":{\"51\":1,\"58\":1,\"712\":1}}],[\"小的元素一定在右子树中\",{\"1\":{\"365\":1}}],[\"小的元素一定在左子树中\",{\"1\":{\"365\":1}}],[\"小的元素的范围\",{\"1\":{\"365\":1}}],[\"小的元素\",{\"1\":{\"362\":1,\"365\":3}}],[\"小的合并到大的中\",{\"1\":{\"251\":1}}],[\"小的数\",{\"1\":{\"227\":1}}],[\"小的d\",{\"1\":{\"41\":1}}],[\"小的值\",{\"1\":{\"41\":1,\"364\":1}}],[\"小根堆\",{\"1\":{\"41\":1,\"43\":1}}],[\"<br>\",{\"1\":{\"706\":1}}],[\"<bit\",{\"1\":{\"134\":1}}],[\"<bits\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"129\":1,\"180\":1,\"181\":1}}],[\"<groupid>io\",{\"1\":{\"672\":1}}],[\"<groupid>org\",{\"1\":{\"323\":1}}],[\"<zipdateformat>yyyymmdd<\",{\"1\":{\"663\":1}}],[\"<zipolderthannumdays>5<zipolderthannumdays>\",{\"1\":{\"663\":1}}],[\"<pattern>yyyymmdd<\",{\"1\":{\"663\":1}}],[\"<pii>\",{\"1\":{\"251\":1}}],[\"<sizethreshold>10240<\",{\"1\":{\"663\":1}}],[\"<service>\",{\"1\":{\"663\":1}}],[\"<log\",{\"1\":{\"663\":1}}],[\"<logpath>\",{\"1\":{\"663\":1}}],[\"<executable>\",{\"1\":{\"663\":1}}],[\"<description>minio文件存储服务<\",{\"1\":{\"663\":1}}],[\"<dependency>\",{\"1\":{\"323\":1,\"672\":1}}],[\"<name>minio\",{\"1\":{\"663\":1}}],[\"<id>minio\",{\"1\":{\"663\":1}}],[\"<iostream>\",{\"1\":{\"43\":1,\"44\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"131\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"172\":1,\"196\":1,\"204\":1,\"214\":1,\"231\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"<version>8\",{\"1\":{\"672\":1}}],[\"<version>3\",{\"1\":{\"323\":1}}],[\"<vector>\",{\"1\":{\"118\":1,\"122\":1,\"131\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"196\":1,\"251\":1}}],[\"<autorollattime>00\",{\"1\":{\"663\":1}}],[\"<artifactid>minio<\",{\"1\":{\"672\":1}}],[\"<artifactid>commons\",{\"1\":{\"323\":1}}],[\"<arguments>server\",{\"1\":{\"663\":1}}],[\"<algortihm>\",{\"1\":{\"172\":1}}],[\"<algorithm>\",{\"1\":{\"43\":1,\"44\":1,\"81\":1,\"82\":1,\"83\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"131\":1,\"144\":1,\"150\":1,\"196\":1,\"204\":1,\"214\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"<>\",{\"1\":{\"310\":1,\"323\":1,\"518\":1,\"537\":1}}],[\"<cstdlib>\",{\"1\":{\"93\":1}}],[\"<cstdio>\",{\"1\":{\"93\":1,\"94\":1,\"116\":1,\"117\":1,\"118\":1,\"122\":2,\"251\":1}}],[\"<cstring>\",{\"1\":{\"43\":1,\"44\":1,\"81\":1,\"82\":1,\"83\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"118\":2,\"119\":2,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"131\":1,\"172\":1}}],[\"<unordered\",{\"1\":{\"44\":1,\"99\":1,\"196\":1}}],[\"<<abc\",{\"1\":{\"683\":1}}],[\"<<eof\",{\"1\":{\"683\":1}}],[\"<<\",{\"1\":{\"43\":2,\"44\":2,\"48\":2,\"49\":2,\"50\":2,\"55\":4,\"56\":4,\"57\":4,\"71\":5,\"81\":2,\"82\":4,\"83\":2,\"94\":4,\"98\":2,\"99\":2,\"107\":3,\"108\":2,\"109\":2,\"110\":2,\"111\":2,\"116\":4,\"117\":4,\"118\":8,\"119\":4,\"121\":4,\"122\":6,\"123\":2,\"124\":2,\"125\":2,\"126\":2,\"127\":2,\"128\":4,\"131\":7,\"132\":4,\"144\":2,\"150\":4,\"157\":1,\"158\":2,\"159\":3,\"172\":2,\"188\":9,\"196\":2,\"209\":2,\"212\":3,\"242\":1,\"247\":2,\"248\":2,\"249\":2,\"250\":2,\"251\":2,\"683\":1}}],[\"<queue>\",{\"1\":{\"43\":1,\"44\":1,\"98\":1,\"99\":1,\"249\":1}}],[\"<\",{\"1\":{\"41\":1,\"43\":2,\"44\":7,\"48\":7,\"49\":9,\"50\":6,\"55\":7,\"56\":6,\"57\":6,\"64\":1,\"98\":1,\"99\":4,\"101\":1,\"107\":1,\"109\":1,\"110\":3,\"118\":2,\"119\":5,\"122\":8,\"125\":2,\"127\":1,\"129\":1,\"131\":5,\"132\":5,\"134\":1,\"137\":4,\"138\":1,\"141\":1,\"142\":1,\"144\":2,\"147\":4,\"148\":5,\"149\":2,\"160\":2,\"161\":1,\"162\":1,\"165\":2,\"172\":1,\"174\":2,\"180\":3,\"181\":4,\"187\":1,\"192\":5,\"204\":1,\"205\":7,\"207\":1,\"208\":1,\"209\":3,\"210\":4,\"212\":3,\"230\":1,\"234\":1,\"237\":3,\"243\":3,\"247\":2,\"248\":2,\"249\":4,\"250\":6,\"251\":2,\"310\":2,\"314\":1,\"323\":6,\"365\":1,\"366\":1,\"420\":5,\"426\":2,\"443\":4,\"444\":5,\"445\":6,\"456\":2,\"469\":9,\"474\":1,\"475\":2,\"486\":3,\"518\":1,\"557\":3,\"561\":2,\"562\":2,\"563\":3,\"565\":1,\"567\":3,\"572\":5,\"573\":3,\"578\":1,\"580\":1,\"591\":1,\"620\":2,\"632\":3,\"634\":1,\"635\":2,\"636\":1,\"642\":1,\"663\":3,\"672\":1}}],[\"<=\",{\"1\":{\"41\":2,\"65\":1,\"81\":1,\"82\":2,\"83\":5,\"89\":1,\"93\":3,\"94\":2,\"98\":4,\"101\":1,\"108\":2,\"109\":2,\"110\":1,\"111\":3,\"116\":5,\"117\":5,\"118\":11,\"119\":3,\"121\":7,\"122\":4,\"123\":2,\"124\":5,\"125\":5,\"126\":4,\"127\":6,\"128\":5,\"129\":13,\"131\":1,\"134\":2,\"138\":5,\"142\":2,\"143\":1,\"165\":2,\"169\":2,\"172\":2,\"174\":1,\"176\":1,\"178\":5,\"180\":3,\"181\":1,\"182\":1,\"183\":1,\"187\":1,\"188\":1,\"189\":3,\"191\":2,\"193\":2,\"195\":1,\"196\":1,\"199\":1,\"200\":2,\"205\":1,\"207\":1,\"209\":3,\"210\":2,\"227\":1,\"229\":1,\"230\":2,\"231\":2,\"234\":1,\"235\":1,\"236\":1,\"237\":2,\"241\":1,\"247\":2,\"248\":3,\"250\":1,\"289\":1,\"451\":2,\"456\":1,\"469\":2,\"487\":1,\"488\":2,\"518\":1,\"557\":3,\"561\":1,\"563\":1,\"566\":1,\"567\":1,\"572\":1,\"583\":1,\"584\":1,\"596\":1}}],[\"估计\",{\"1\":{\"41\":1}}],[\"估计距离\",{\"1\":{\"41\":1}}],[\"有十分完善的官方文档\",{\"1\":{\"668\":1}}],[\"有返回值的函数\",{\"0\":{\"594\":1}}],[\"有如下优点\",{\"1\":{\"545\":1}}],[\"有些业务操作要多次访问数据库\",{\"1\":{\"540\":1}}],[\"有些题则在判断的同时需要计算出最短路径\",{\"1\":{\"57\":1}}],[\"有些题只需要判断能不能逃出迷宫\",{\"1\":{\"57\":1}}],[\"有升序排序\",{\"1\":{\"521\":1}}],[\"有符号\",{\"1\":{\"507\":1}}],[\"有符号数\",{\"1\":{\"157\":1}}],[\"有效性和完整性\",{\"1\":{\"506\":1}}],[\"有效\",{\"1\":{\"485\":1}}],[\"有需要的话也可以配置\",{\"1\":{\"352\":1}}],[\"有一定的熟练度\",{\"1\":{\"344\":1}}],[\"有一个大小为\",{\"1\":{\"455\":1}}],[\"有一个逻辑删除\",{\"1\":{\"310\":1}}],[\"有一个线程去\",{\"1\":{\"293\":1}}],[\"有一个1\",{\"1\":{\"212\":1}}],[\"有一个人位于左上角\",{\"1\":{\"98\":1}}],[\"有哪些表\",{\"1\":{\"320\":1}}],[\"有必要在用户登录后记录用户状态\",{\"1\":{\"315\":1}}],[\"有可能被\",{\"1\":{\"311\":1}}],[\"有温度\",{\"1\":{\"274\":1}}],[\"有知识\",{\"1\":{\"274\":1}}],[\"有趣的交流环境\",{\"1\":{\"274\":1}}],[\"有害评论被删除后\",{\"1\":{\"269\":1}}],[\"有序\",{\"1\":{\"261\":1,\"654\":1}}],[\"有唯一解\",{\"1\":{\"205\":1}}],[\"有无穷多组解\",{\"1\":{\"205\":1}}],[\"有向图游戏的某个局面必败\",{\"1\":{\"219\":1}}],[\"有向图游戏的某个局面必胜\",{\"1\":{\"219\":1}}],[\"有向图游戏的和的sg函数值等于它包含的各个子游戏sg函数值的异或和\",{\"1\":{\"219\":1}}],[\"有向图游戏的和\",{\"0\":{\"219\":1}}],[\"有向图游戏\",{\"0\":{\"216\":1}}],[\"有向图\",{\"1\":{\"172\":1}}],[\"有向无环图被称为拓扑图\",{\"1\":{\"169\":1}}],[\"有的补0\",{\"1\":{\"157\":1}}],[\"有的补符号位\",{\"1\":{\"157\":1}}],[\"有两个基本且重要的特征\",{\"1\":{\"263\":1}}],[\"有两个指针\",{\"1\":{\"224\":1}}],[\"有两个参数\",{\"1\":{\"74\":1}}],[\"有两个关键点\",{\"1\":{\"55\":1}}],[\"有很多种解法\",{\"1\":{\"58\":1}}],[\"有\",{\"1\":{\"41\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"209\":1,\"545\":1}}],[\"有以下这些启发函数可以使用\",{\"1\":{\"36\":1}}],[\"utf\",{\"1\":{\"642\":3}}],[\"util\",{\"0\":{\"653\":1,\"654\":1,\"655\":1},\"1\":{\"554\":1,\"557\":9,\"558\":2,\"559\":1,\"561\":1,\"563\":1,\"565\":1,\"572\":3,\"574\":1,\"575\":1,\"577\":2,\"579\":1,\"587\":1,\"591\":1,\"594\":1,\"595\":1,\"596\":1,\"609\":3,\"610\":1,\"611\":3,\"612\":4,\"613\":4,\"620\":1,\"621\":1,\"634\":1}}],[\"u3000\",{\"1\":{\"642\":1}}],[\"u用户名\",{\"1\":{\"493\":1}}],[\"url\",{\"0\":{\"354\":1},\"1\":{\"354\":1,\"706\":1,\"722\":2}}],[\"urdl\",{\"1\":{\"44\":1}}],[\"uindex\",{\"1\":{\"321\":1}}],[\"uid\",{\"1\":{\"311\":1}}],[\"ui\",{\"1\":{\"302\":7}}],[\"use\",{\"1\":{\"501\":1,\"715\":2}}],[\"user=admin\",{\"1\":{\"660\":2}}],[\"usernname\",{\"1\":{\"323\":14}}],[\"username\",{\"1\":{\"310\":6,\"311\":8,\"313\":5,\"321\":2,\"323\":8,\"507\":2}}],[\"user>\",{\"1\":{\"323\":1}}],[\"userrole\",{\"1\":{\"321\":2}}],[\"userregister\",{\"1\":{\"311\":2,\"323\":8}}],[\"userregisterrequest\",{\"1\":{\"311\":9}}],[\"userconstant\",{\"1\":{\"315\":2}}],[\"usercontroller\",{\"1\":{\"311\":1,\"313\":1}}],[\"userid\",{\"1\":{\"314\":4,\"321\":3}}],[\"userlist\",{\"1\":{\"313\":2}}],[\"userloginrequest\",{\"1\":{\"311\":7}}],[\"userlogin\",{\"1\":{\"310\":1,\"311\":2}}],[\"userserviceimpl\",{\"1\":{\"323\":1}}],[\"userservice\",{\"1\":{\"311\":4,\"313\":2,\"314\":1,\"322\":1,\"323\":8}}],[\"usermapper\",{\"1\":{\"310\":1,\"323\":4}}],[\"userpassword\",{\"1\":{\"310\":2}}],[\"useraccount\",{\"1\":{\"310\":2,\"321\":1}}],[\"user\",{\"0\":{\"741\":1,\"742\":1},\"1\":{\"302\":3,\"310\":14,\"311\":3,\"313\":6,\"315\":1,\"321\":2,\"322\":13,\"323\":7,\"329\":2,\"353\":1,\"673\":1}}],[\"usr\",{\"1\":{\"353\":1,\"354\":2,\"680\":3}}],[\"using\",{\"1\":{\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"172\":1,\"180\":1,\"181\":1,\"196\":1,\"204\":1,\"212\":1,\"214\":1,\"231\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"umijs\",{\"1\":{\"302\":1}}],[\"umi\",{\"1\":{\"300\":2,\"302\":6,\"328\":1}}],[\"ull\",{\"1\":{\"241\":4}}],[\"ullddrurdllurdruldr\",{\"1\":{\"44\":1}}],[\"uploadobjectargs\",{\"1\":{\"676\":1}}],[\"uploadobject\",{\"1\":{\"676\":1}}],[\"update\",{\"0\":{\"513\":1},\"1\":{\"511\":1,\"513\":5,\"514\":1,\"534\":1,\"544\":1}}],[\"updatetime\",{\"1\":{\"321\":2}}],[\"upstream\",{\"1\":{\"346\":1}}],[\"up主与用户的\",{\"1\":{\"272\":1}}],[\"up主回复\",{\"1\":{\"255\":1}}],[\"up主删除等\",{\"1\":{\"255\":1}}],[\"up主每天都会发布海量的视频\",{\"1\":{\"254\":1}}],[\"up\",{\"1\":{\"237\":4}}],[\"upper\",{\"1\":{\"144\":3,\"242\":4,\"243\":3}}],[\"u表示当前节点\",{\"1\":{\"182\":1}}],[\"u表示第几位\",{\"1\":{\"109\":1}}],[\"u只猫\",{\"1\":{\"110\":1}}],[\"unlock\",{\"1\":{\"634\":2}}],[\"underscore\",{\"1\":{\"322\":1}}],[\"unset\",{\"1\":{\"688\":2}}],[\"unsupportedoperationexception\",{\"1\":{\"618\":1}}],[\"unsigned\",{\"1\":{\"241\":2,\"507\":1}}],[\"unsolvable\",{\"1\":{\"44\":2}}],[\"uninstall\",{\"1\":{\"663\":1}}],[\"unix\",{\"1\":{\"660\":1}}],[\"unit\",{\"1\":{\"353\":1}}],[\"unique\",{\"1\":{\"161\":1,\"242\":1,\"243\":3,\"321\":1,\"506\":1,\"525\":1,\"546\":1}}],[\"union\",{\"1\":{\"87\":1,\"91\":1,\"93\":2,\"94\":4,\"181\":2,\"234\":1,\"445\":3}}],[\"unordered\",{\"1\":{\"44\":2,\"99\":1,\"196\":1,\"242\":4}}],[\"u\",{\"1\":{\"41\":8,\"43\":2,\"44\":1,\"75\":6,\"101\":4,\"107\":8,\"108\":5,\"109\":6,\"110\":8,\"111\":7,\"134\":16,\"165\":11,\"167\":4,\"182\":3,\"232\":7,\"236\":2,\"237\":17}}],[\"最重要的是理解代码的执行顺序\",{\"1\":{\"581\":1}}],[\"最重要的是配置直链\",{\"1\":{\"352\":1}}],[\"最简单的\",{\"1\":{\"660\":1}}],[\"最简单的形式\",{\"1\":{\"535\":1}}],[\"最简单的合并就是像下面这样\",{\"1\":{\"91\":1}}],[\"最常见的是\",{\"1\":{\"534\":1}}],[\"最终岛屿的数量就是并查集中连通分量的数目\",{\"1\":{\"445\":1}}],[\"最终岛屿的数量就是进行广度优先搜索的次数\",{\"1\":{\"444\":1}}],[\"最终岛屿的数量就是每次发现新岛屿的次数\",{\"1\":{\"443\":1}}],[\"最终结果为\",{\"1\":{\"200\":1}}],[\"最近公共祖先表示为一个节点\",{\"1\":{\"406\":1}}],[\"最好封装一个对象来记录所有的请求参数\",{\"1\":{\"311\":1}}],[\"最典型的案例就是缓存的更新\",{\"1\":{\"261\":1}}],[\"最多有26个\",{\"1\":{\"232\":1}}],[\"最坏情况下的时间复杂度为\",{\"1\":{\"197\":1}}],[\"最坏情况下\",{\"1\":{\"175\":1}}],[\"最坏情况为\",{\"1\":{\"171\":1}}],[\"最低位一定为\",{\"1\":{\"158\":1}}],[\"最小\",{\"1\":{\"651\":1}}],[\"最小可用原则对外提供数据\",{\"1\":{\"258\":1}}],[\"最小生成树所有边的长度之和\",{\"1\":{\"180\":1}}],[\"最小生成树就是将\",{\"1\":{\"179\":1}}],[\"最小生成树问题\",{\"0\":{\"179\":1}}],[\"最小的最大\",{\"1\":{\"143\":1}}],[\"最小值\",{\"1\":{\"76\":2,\"230\":1,\"519\":1}}],[\"最小值下标\",{\"1\":{\"76\":2}}],[\"最短路问题\",{\"0\":{\"170\":1}}],[\"最短路径\",{\"1\":{\"57\":1}}],[\"最短hamilton路径\",{\"0\":{\"132\":1}}],[\"最短编辑距离\",{\"0\":{\"126\":1}}],[\"最长不会超过50\",{\"1\":{\"507\":1}}],[\"最长公共上升子序列\",{\"0\":{\"124\":1}}],[\"最长公共子序列\",{\"0\":{\"123\":1,\"448\":1},\"1\":{\"448\":1}}],[\"最长上升子序列\",{\"0\":{\"122\":1}}],[\"最大\",{\"1\":{\"651\":1}}],[\"最大深度\",{\"1\":{\"400\":1}}],[\"最大路径和\",{\"1\":{\"370\":1}}],[\"最大不相交区间数量\",{\"0\":{\"248\":1}}],[\"最大公约数与最小公倍数\",{\"0\":{\"197\":1}}],[\"最大匹配\",{\"1\":{\"183\":1}}],[\"最大的问题就是在数据量大的情况下\",{\"1\":{\"545\":1}}],[\"最大的最小\",{\"1\":{\"143\":1}}],[\"最大的总价值\",{\"1\":{\"116\":1}}],[\"最大价值是多少\",{\"1\":{\"116\":1,\"117\":1}}],[\"最大值\",{\"1\":{\"76\":2,\"401\":1,\"518\":1,\"519\":1}}],[\"最大值下标\",{\"1\":{\"76\":2}}],[\"最少需要付多少美元才能把这\",{\"1\":{\"110\":1}}],[\"最初最小生成树的边数为\",{\"1\":{\"181\":1}}],[\"最初\",{\"1\":{\"98\":1}}],[\"最值元素的值\",{\"1\":{\"76\":1}}],[\"最值元素的地址\",{\"1\":{\"76\":1}}],[\"最朴素的迷宫问题\",{\"1\":{\"55\":1}}],[\"最后定义类\",{\"1\":{\"599\":1}}],[\"最后遍历根节点\",{\"1\":{\"488\":1}}],[\"最后遍历右子树\",{\"1\":{\"487\":1}}],[\"最后遍历左子节点的右子树\",{\"1\":{\"382\":1}}],[\"最后构建左右子树\",{\"1\":{\"419\":1}}],[\"最后返回即可\",{\"1\":{\"390\":1}}],[\"最后返回上一层\",{\"1\":{\"384\":1}}],[\"最后返回c数组\",{\"1\":{\"147\":1,\"148\":1}}],[\"最后找到的节点处理完后\",{\"1\":{\"384\":1}}],[\"最后处理这个节点的右子树\",{\"1\":{\"383\":1}}],[\"最后访问右子树\",{\"1\":{\"382\":1}}],[\"最后在\",{\"1\":{\"354\":1}}],[\"最后点击确定\",{\"1\":{\"347\":1}}],[\"最后再说一下布隆过滤器中容量的计算\",{\"1\":{\"334\":1}}],[\"最后登录时间\",{\"1\":{\"321\":1}}],[\"最后写一下校验\",{\"1\":{\"311\":1}}],[\"最后交由\",{\"1\":{\"283\":1}}],[\"最后通过热点压测\",{\"1\":{\"266\":1}}],[\"最后剩下的式子就满足我们的答案\",{\"1\":{\"204\":1}}],[\"最后剩下的就是区间\",{\"1\":{\"192\":1}}],[\"最后将整个图连通起来\",{\"1\":{\"180\":1}}],[\"最后根据分界点分别递归左右两部分\",{\"1\":{\"137\":1}}],[\"最后一个元素\",{\"1\":{\"646\":1}}],[\"最后一个元素代表方法调用堆栈的栈底\",{\"1\":{\"619\":1}}],[\"最后一个字段后面没有逗号\",{\"1\":{\"505\":1}}],[\"最后一个节点的isend置为true\",{\"1\":{\"426\":1}}],[\"最后一个访问到的一定是根\",{\"1\":{\"134\":1}}],[\"最后一层节点从左向右排列\",{\"1\":{\"237\":1}}],[\"最后一次出现的位置的\",{\"1\":{\"144\":1}}],[\"最后一行包含三个整数\",{\"1\":{\"43\":1}}],[\"最后判断\",{\"1\":{\"111\":1}}],[\"最后输出岛屿的最大面积\",{\"1\":{\"50\":1}}],[\"最后输出岛屿的数目\",{\"1\":{\"49\":1}}],[\"最后输出岛屿的数量\",{\"1\":{\"48\":1}}],[\"最优\",{\"1\":{\"41\":1}}],[\"最佳优先搜索\",{\"0\":{\"34\":1}}],[\">根节点\",{\"1\":{\"378\":1}}],[\">左子树\",{\"1\":{\"378\":1}}],[\">1\",{\"1\":{\"188\":1}}],[\">b\",{\"1\":{\"165\":1,\"174\":1}}],[\">j\",{\"1\":{\"43\":1}}],[\">t\",{\"1\":{\"43\":3}}],[\">\",{\"1\":{\"43\":1,\"44\":2,\"75\":3,\"108\":1,\"109\":1,\"118\":1,\"122\":1,\"124\":1,\"137\":2,\"145\":1,\"148\":5,\"149\":1,\"150\":2,\"165\":3,\"172\":1,\"173\":1,\"174\":3,\"175\":2,\"176\":1,\"180\":1,\"188\":1,\"196\":1,\"199\":1,\"205\":3,\"212\":1,\"226\":1,\"243\":1,\"247\":1,\"302\":1,\"311\":3,\"323\":2,\"365\":1,\"390\":1,\"396\":1,\"420\":4,\"438\":1,\"468\":1,\"469\":5,\"475\":1,\"518\":1,\"520\":2,\"557\":11,\"572\":1,\"594\":1,\"595\":2,\"628\":2,\"642\":2,\"660\":2,\"663\":1,\"675\":1,\"676\":1}}],[\">=0\",{\"1\":{\"129\":1}}],[\">=k\",{\"1\":{\"43\":1}}],[\">=\",{\"1\":{\"41\":2,\"44\":2,\"48\":2,\"49\":2,\"50\":2,\"55\":2,\"56\":3,\"57\":2,\"94\":2,\"98\":2,\"99\":2,\"110\":1,\"111\":2,\"116\":1,\"117\":1,\"118\":3,\"119\":3,\"121\":2,\"128\":1,\"137\":1,\"138\":1,\"141\":1,\"142\":1,\"147\":5,\"148\":12,\"149\":4,\"150\":4,\"159\":1,\"161\":1,\"176\":1,\"205\":3,\"249\":1,\"250\":1,\"443\":2,\"444\":2,\"469\":2,\"518\":1,\"557\":6,\"558\":4,\"572\":1}}],[\">>=\",{\"1\":{\"201\":1,\"208\":1,\"209\":1,\"237\":1}}],[\">>\",{\"0\":{\"73\":1},\"1\":{\"41\":1,\"43\":8,\"44\":1,\"48\":3,\"49\":3,\"50\":3,\"55\":3,\"56\":3,\"57\":3,\"73\":1,\"81\":3,\"82\":2,\"83\":5,\"93\":6,\"94\":5,\"98\":3,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":2,\"110\":3,\"111\":1,\"116\":4,\"117\":4,\"118\":15,\"119\":10,\"121\":2,\"122\":7,\"123\":4,\"124\":3,\"125\":5,\"126\":4,\"127\":2,\"128\":1,\"129\":2,\"131\":3,\"132\":3,\"134\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":3,\"147\":2,\"148\":2,\"149\":2,\"150\":2,\"157\":1,\"158\":2,\"159\":5,\"161\":1,\"165\":2,\"172\":5,\"180\":5,\"196\":2,\"209\":4,\"212\":4,\"214\":2,\"231\":4,\"242\":1,\"247\":3,\"248\":3,\"249\":3,\"250\":5,\"251\":3}}],[\"^=\",{\"1\":{\"158\":3,\"214\":1}}],[\"^\",{\"1\":{\"41\":1,\"157\":1,\"158\":7,\"214\":3,\"219\":3,\"242\":1,\"310\":1,\"323\":1}}],[\"jetty\",{\"1\":{\"728\":1}}],[\"jest\",{\"1\":{\"302\":2}}],[\"jbods\",{\"1\":{\"668\":1}}],[\"jdk7\",{\"1\":{\"622\":1}}],[\"jdbc\",{\"1\":{\"300\":1}}],[\"jvm\",{\"1\":{\"615\":1,\"641\":1}}],[\"jpg\",{\"1\":{\"322\":1,\"676\":9}}],[\"js\",{\"1\":{\"302\":2,\"329\":1}}],[\"json串\",{\"1\":{\"675\":1}}],[\"json\",{\"1\":{\"302\":4,\"308\":1,\"311\":2,\"522\":1,\"655\":1}}],[\"junit\",{\"1\":{\"300\":1}}],[\"juejin\",{\"1\":{\"274\":1}}],[\"join\",{\"1\":{\"283\":1,\"531\":1,\"532\":2,\"633\":1,\"634\":2,\"635\":4,\"642\":2}}],[\"joiner\",{\"1\":{\"283\":1}}],[\"job\",{\"0\":{\"261\":1},\"1\":{\"261\":2,\"273\":2,\"279\":2,\"281\":1,\"293\":1}}],[\"j表示第几个区间\",{\"1\":{\"250\":1}}],[\"j表示走到哪一个点\",{\"1\":{\"132\":1}}],[\"j走到哪了呀\",{\"1\":{\"231\":1}}],[\"j+1\",{\"1\":{\"231\":1}}],[\"j++\",{\"1\":{\"44\":1,\"48\":2,\"49\":3,\"50\":2,\"55\":2,\"56\":1,\"57\":1,\"83\":2,\"98\":1,\"116\":1,\"117\":2,\"118\":1,\"119\":2,\"121\":3,\"122\":1,\"123\":1,\"124\":1,\"125\":2,\"126\":2,\"129\":3,\"132\":2,\"138\":3,\"160\":1,\"178\":2,\"180\":2,\"193\":1,\"207\":1,\"212\":1,\"231\":2,\"250\":1,\"443\":1,\"444\":1,\"445\":2,\"451\":1,\"469\":2}}],[\"j−i\",{\"1\":{\"128\":1}}],[\"j\",{\"1\":{\"41\":1,\"43\":13,\"44\":3,\"48\":7,\"49\":12,\"50\":9,\"55\":7,\"56\":8,\"57\":5,\"81\":1,\"83\":16,\"91\":3,\"93\":2,\"94\":4,\"98\":3,\"116\":14,\"117\":13,\"118\":25,\"119\":22,\"121\":19,\"122\":6,\"123\":16,\"124\":9,\"125\":16,\"126\":27,\"127\":16,\"128\":28,\"129\":12,\"131\":18,\"132\":14,\"137\":14,\"138\":8,\"153\":1,\"160\":4,\"167\":3,\"168\":4,\"169\":3,\"172\":12,\"173\":5,\"174\":6,\"175\":6,\"176\":8,\"178\":10,\"180\":10,\"182\":4,\"183\":6,\"191\":4,\"192\":9,\"193\":15,\"200\":20,\"205\":10,\"207\":7,\"209\":4,\"210\":8,\"212\":5,\"231\":20,\"250\":5,\"443\":13,\"444\":7,\"445\":16,\"450\":4,\"451\":14,\"469\":16,\"563\":4,\"567\":7,\"572\":6,\"573\":4,\"591\":5}}],[\"javafx\",{\"0\":{\"655\":1}}],[\"javadoc\",{\"1\":{\"626\":1}}],[\"javaee\",{\"1\":{\"624\":2}}],[\"javase\",{\"1\":{\"624\":1}}],[\"java中的\",{\"1\":{\"69\":1}}],[\"java\",{\"0\":{\"303\":1,\"549\":1,\"653\":1,\"654\":1,\"748\":1},\"1\":{\"6\":1,\"300\":3,\"303\":1,\"319\":1,\"323\":2,\"554\":3,\"555\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":1,\"563\":1,\"565\":1,\"572\":3,\"574\":1,\"575\":1,\"577\":2,\"579\":1,\"587\":1,\"591\":1,\"594\":1,\"595\":1,\"596\":1,\"609\":3,\"610\":1,\"611\":3,\"612\":4,\"613\":4,\"615\":1,\"618\":2,\"620\":1,\"621\":2,\"622\":2,\"628\":8,\"634\":1,\"639\":1,\"642\":1,\"648\":2,\"655\":1,\"668\":2,\"702\":3,\"703\":1},\"2\":{\"637\":1,\"657\":1}}],[\"选择服务器类型为\",{\"1\":{\"354\":1}}],[\"选择使用\",{\"1\":{\"350\":1}}],[\"选择\",{\"1\":{\"311\":1,\"352\":1,\"450\":1}}],[\"选择的是评论区\",{\"1\":{\"264\":1}}],[\"选择一个估计距离最小的点\",{\"1\":{\"41\":1}}],[\"选用\",{\"1\":{\"264\":1}}],[\"选出右端点最大的\",{\"1\":{\"250\":1}}],[\"选中奇数个集合\",{\"1\":{\"212\":1}}],[\"选中一个集合\",{\"1\":{\"212\":1}}],[\"选中的集合数量\",{\"1\":{\"212\":1}}],[\"选中集合对应质数的乘积\",{\"1\":{\"212\":1}}],[\"选了某个节点就不能选父节点和子节点\",{\"1\":{\"134\":1}}],[\"选取下一个邻近节点\",{\"1\":{\"35\":1}}],[\"eof\",{\"1\":{\"683\":2}}],[\"echo\",{\"1\":{\"680\":1,\"682\":1,\"686\":3,\"688\":1,\"690\":4,\"692\":5,\"696\":4,\"697\":2,\"698\":2}}],[\"effect\",{\"1\":{\"675\":1}}],[\"e2\",{\"1\":{\"651\":4}}],[\"e2e\",{\"1\":{\"302\":2}}],[\"e1\",{\"1\":{\"651\":4}}],[\"each\",{\"1\":{\"647\":2}}],[\"e+308\",{\"1\":{\"507\":3}}],[\"e+38\",{\"1\":{\"507\":3}}],[\"etc\",{\"1\":{\"354\":2}}],[\"emp\",{\"1\":{\"509\":3,\"513\":2,\"529\":3}}],[\"empty\",{\"1\":{\"99\":1,\"226\":2,\"229\":2,\"242\":7,\"249\":1,\"610\":1}}],[\"email\",{\"1\":{\"321\":2}}],[\"equalsignorecase\",{\"1\":{\"642\":1}}],[\"equals\",{\"1\":{\"323\":1,\"578\":1,\"640\":1,\"642\":1,\"655\":1}}],[\"eq\",{\"1\":{\"310\":2,\"323\":1}}],[\"envprops\",{\"1\":{\"706\":1}}],[\"envconfigfilename\",{\"1\":{\"706\":1}}],[\"environment\",{\"1\":{\"706\":4}}],[\"env\",{\"1\":{\"706\":2}}],[\"entry对象的一个集视图\",{\"1\":{\"647\":1}}],[\"entry<k\",{\"1\":{\"613\":1,\"647\":1}}],[\"entryset\",{\"1\":{\"613\":1,\"647\":1}}],[\"enable\",{\"1\":{\"353\":1}}],[\"encryptpassword\",{\"1\":{\"310\":2,\"323\":2}}],[\"endpoint\",{\"1\":{\"673\":3}}],[\"endindex\",{\"1\":{\"578\":2}}],[\"endswith\",{\"1\":{\"578\":1}}],[\"end\",{\"1\":{\"44\":7,\"70\":1,\"74\":1,\"76\":4,\"122\":1,\"144\":4,\"150\":1,\"161\":3,\"162\":1,\"195\":1,\"242\":5,\"243\":5,\"251\":1,\"640\":4,\"642\":2,\"645\":1,\"654\":1}}],[\"endl\",{\"1\":{\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":2,\"56\":2,\"57\":2,\"71\":2,\"81\":1,\"82\":2,\"83\":1,\"94\":2,\"98\":1,\"99\":1,\"107\":1,\"110\":1,\"111\":1,\"116\":2,\"117\":2,\"118\":4,\"119\":2,\"121\":2,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":2,\"131\":1,\"132\":1,\"144\":1,\"150\":2,\"172\":1,\"188\":3,\"196\":1,\"209\":1,\"212\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"event\",{\"1\":{\"702\":1}}],[\"events\",{\"1\":{\"270\":1}}],[\"evanmiller\",{\"1\":{\"274\":1}}],[\"evan\",{\"1\":{\"274\":1}}],[\"e8\",{\"1\":{\"274\":2}}],[\"es\",{\"1\":{\"259\":2,\"279\":2,\"283\":7}}],[\"estimate\",{\"1\":{\"41\":2}}],[\"example\",{\"1\":{\"647\":3}}],[\"export\",{\"1\":{\"689\":2}}],[\"expiry\",{\"1\":{\"676\":1}}],[\"expire\",{\"1\":{\"264\":1}}],[\"expression\",{\"1\":{\"563\":3,\"592\":1}}],[\"exception类的继承关系\",{\"0\":{\"616\":1}}],[\"exception\",{\"0\":{\"615\":1},\"1\":{\"554\":2,\"555\":2,\"615\":1,\"616\":1,\"617\":2,\"675\":4,\"676\":7,\"722\":1,\"727\":1}}],[\"excel\",{\"1\":{\"319\":1}}],[\"extists\",{\"1\":{\"500\":1}}],[\"extends\",{\"1\":{\"323\":1,\"601\":1,\"605\":1,\"632\":1,\"634\":1,\"635\":1,\"636\":1}}],[\"exists\",{\"1\":{\"500\":2,\"502\":3,\"510\":2}}],[\"exit\",{\"1\":{\"66\":1}}],[\"exe<\",{\"1\":{\"663\":1}}],[\"executors\",{\"1\":{\"715\":1}}],[\"executable>\",{\"1\":{\"663\":1}}],[\"execute\",{\"1\":{\"514\":1}}],[\"execstart=\",{\"1\":{\"353\":1}}],[\"exe\",{\"1\":{\"347\":1,\"662\":3,\"663\":6}}],[\"exgcd\",{\"1\":{\"203\":2,\"204\":3}}],[\"eurekamonitors\",{\"1\":{\"725\":1}}],[\"eurekaservercontext\",{\"1\":{\"721\":2}}],[\"eurekaservercontextholder\",{\"1\":{\"721\":4}}],[\"eurekaserverconfig\",{\"1\":{\"704\":4,\"707\":3,\"708\":1,\"710\":1,\"717\":1,\"719\":1,\"720\":1}}],[\"eurekatransport\",{\"1\":{\"715\":2}}],[\"eurekaclientconfig\",{\"1\":{\"714\":3}}],[\"eurekaclient\",{\"0\":{\"715\":1},\"1\":{\"714\":2,\"715\":1,\"717\":2,\"719\":1}}],[\"eurekaconfigbasedinstanceinfoprovider\",{\"1\":{\"710\":1,\"711\":1}}],[\"eurekainstanceconfig\",{\"1\":{\"711\":1}}],[\"eurekapropsfile\",{\"1\":{\"706\":3}}],[\"eurekabootstrap\",{\"1\":{\"702\":2,\"703\":1}}],[\"eureka\",{\"0\":{\"701\":1,\"704\":1,\"705\":1,\"713\":1,\"714\":1,\"725\":1},\"1\":{\"701\":1,\"702\":4,\"706\":10,\"707\":1,\"708\":1,\"710\":3,\"714\":7,\"715\":8,\"717\":3,\"722\":1,\"728\":1,\"729\":2}}],[\"eulers\",{\"1\":{\"200\":1}}],[\"euler\",{\"1\":{\"200\":7}}],[\"euclideandistance\",{\"1\":{\"36\":1}}],[\"edges为先修课程关系\",{\"1\":{\"475\":1}}],[\"edges\",{\"1\":{\"174\":4,\"181\":6,\"474\":2,\"475\":2}}],[\"edge\",{\"1\":{\"165\":1,\"174\":1,\"181\":2,\"474\":3,\"475\":3}}],[\"editor\",{\"1\":{\"311\":1}}],[\"edit\",{\"1\":{\"125\":2}}],[\"erasure\",{\"1\":{\"668\":1}}],[\"erase\",{\"1\":{\"161\":1,\"242\":3}}],[\"error\",{\"0\":{\"615\":1},\"1\":{\"63\":1,\"354\":2,\"615\":1}}],[\"eps\",{\"1\":{\"145\":3,\"205\":4}}],[\"elements\",{\"1\":{\"654\":2}}],[\"element\",{\"0\":{\"76\":2},\"1\":{\"76\":12,\"649\":1}}],[\"else连写\",{\"1\":{\"557\":1}}],[\"else\",{\"1\":{\"44\":1,\"55\":1,\"56\":1,\"57\":1,\"90\":1,\"93\":2,\"94\":4,\"122\":2,\"125\":1,\"126\":2,\"131\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"145\":1,\"148\":2,\"161\":1,\"162\":1,\"178\":1,\"180\":1,\"181\":1,\"182\":1,\"207\":1,\"212\":1,\"214\":1,\"226\":1,\"229\":1,\"234\":1,\"248\":1,\"249\":1,\"251\":1,\"366\":2,\"420\":2,\"469\":2,\"557\":17,\"558\":3,\"565\":1,\"621\":1,\"636\":1,\"675\":1}}],[\"e\",{\"1\":{\"43\":4,\"165\":2,\"167\":1,\"168\":1,\"169\":1,\"173\":3,\"175\":3,\"176\":2,\"182\":2,\"183\":2,\"223\":4,\"224\":3,\"239\":3,\"507\":2,\"620\":4,\"621\":4,\"622\":2,\"632\":6,\"636\":2,\"645\":7,\"646\":6,\"648\":2,\"649\":4,\"650\":4,\"651\":4,\"655\":2,\"676\":2,\"706\":1}}],[\"←\",{\"1\":{\"41\":1}}],[\"t2\",{\"1\":{\"534\":1}}],[\"t1\",{\"1\":{\"534\":1}}],[\"t1597\",{\"1\":{\"57\":1}}],[\"t1596\",{\"1\":{\"56\":1}}],[\"t1595\",{\"1\":{\"55\":1}}],[\"tb\",{\"1\":{\"509\":3,\"513\":2,\"529\":6}}],[\"tmp\",{\"1\":{\"402\":4,\"469\":2,\"593\":2}}],[\"targetsum\",{\"1\":{\"479\":2,\"480\":2,\"481\":5}}],[\"target\",{\"1\":{\"353\":3,\"626\":1}}],[\"tar\",{\"1\":{\"352\":4}}],[\"tableb\",{\"1\":{\"531\":2}}],[\"tablea\",{\"1\":{\"531\":2}}],[\"tables\",{\"1\":{\"508\":1}}],[\"tablefiled\",{\"1\":{\"322\":1}}],[\"table\",{\"1\":{\"321\":1,\"505\":1,\"508\":1,\"509\":7,\"510\":1,\"524\":2}}],[\"tablelogic\",{\"1\":{\"310\":1}}],[\"tcp\",{\"1\":{\"345\":4}}],[\"tinytext\",{\"1\":{\"507\":1}}],[\"tinyblob\",{\"1\":{\"507\":1}}],[\"tinyint\",{\"1\":{\"321\":4,\"507\":1}}],[\"timeunit\",{\"1\":{\"676\":1,\"715\":2}}],[\"time=now\",{\"1\":{\"513\":1}}],[\"time++\",{\"1\":{\"468\":1,\"469\":2}}],[\"time\",{\"1\":{\"468\":3,\"469\":4,\"507\":1,\"513\":1,\"663\":1}}],[\"timestamp\",{\"1\":{\"321\":6,\"507\":1}}],[\"timeout\",{\"1\":{\"312\":1,\"354\":1}}],[\"tips\",{\"1\":{\"183\":1}}],[\"ts\",{\"1\":{\"302\":3}}],[\"tensorflow\",{\"1\":{\"668\":1}}],[\"text\",{\"1\":{\"507\":1,\"545\":1}}],[\"test10\",{\"1\":{\"676\":1}}],[\"test2\",{\"1\":{\"676\":1}}],[\"test09\",{\"1\":{\"676\":1}}],[\"test08\",{\"1\":{\"676\":1}}],[\"test07\",{\"1\":{\"676\":1}}],[\"test06\",{\"1\":{\"676\":1}}],[\"test05\",{\"1\":{\"676\":1}}],[\"test04\",{\"1\":{\"675\":1}}],[\"test03\",{\"1\":{\"675\":1}}],[\"test02\",{\"1\":{\"675\":1}}],[\"test01\",{\"1\":{\"675\":1}}],[\"testuserregister\",{\"1\":{\"323\":1}}],[\"testinsertuser\",{\"1\":{\"322\":1}}],[\"test\",{\"1\":{\"322\":1,\"323\":1,\"676\":5,\"680\":6,\"692\":4,\"706\":1}}],[\"tests\",{\"1\":{\"302\":2}}],[\"terminal\",{\"1\":{\"302\":1,\"680\":2}}],[\"template\",{\"0\":{\"739\":1}}],[\"temp\",{\"1\":{\"138\":6}}],[\"there\",{\"1\":{\"706\":1}}],[\"the\",{\"1\":{\"706\":2}}],[\"threadpoolexecutor\",{\"1\":{\"715\":2}}],[\"threadfactorybuilder\",{\"1\":{\"715\":3}}],[\"thread\",{\"1\":{\"632\":11,\"633\":1,\"634\":1,\"635\":5,\"636\":4}}],[\"threaddeath\",{\"1\":{\"615\":1}}],[\"throw\",{\"1\":{\"621\":3,\"632\":3,\"636\":1,\"676\":1}}],[\"throwable\",{\"1\":{\"619\":5}}],[\"throws\",{\"1\":{\"554\":2,\"555\":2,\"621\":2,\"628\":1,\"634\":1,\"635\":2,\"636\":1,\"675\":4,\"676\":6,\"722\":1}}],[\"thursday\",{\"1\":{\"559\":1}}],[\"thundering\",{\"1\":{\"281\":1}}],[\"this\",{\"1\":{\"75\":3,\"363\":1,\"420\":1,\"426\":2,\"444\":1,\"469\":1,\"481\":1,\"600\":4,\"601\":3,\"628\":1,\"632\":1,\"635\":2,\"636\":3,\"706\":1,\"717\":4,\"721\":1}}],[\"t表示该元素与它的左\",{\"1\":{\"237\":1}}],[\"t为当前这种状态的集合数量\",{\"1\":{\"212\":1}}],[\"t为余数\",{\"1\":{\"150\":1}}],[\"ttl\",{\"1\":{\"294\":1}}],[\"tt表示队尾\",{\"1\":{\"229\":1}}],[\"tt表示栈顶\",{\"1\":{\"226\":1}}],[\"tt\",{\"1\":{\"169\":3,\"226\":4,\"227\":4,\"229\":3,\"230\":5}}],[\"t再除以10\",{\"1\":{\"147\":1}}],[\"tuesday\",{\"1\":{\"559\":1}}],[\"ture\",{\"1\":{\"180\":1}}],[\"tu\",{\"1\":{\"77\":3}}],[\"tuple<int\",{\"1\":{\"77\":2}}],[\"tuple\",{\"0\":{\"77\":1},\"1\":{\"77\":2}}],[\"t的最大值\",{\"1\":{\"72\":1}}],[\"tool\",{\"0\":{\"744\":1}}],[\"tochararray\",{\"1\":{\"578\":2,\"642\":2}}],[\"touppercase\",{\"1\":{\"578\":1,\"642\":1}}],[\"tolowercase\",{\"1\":{\"578\":1,\"642\":1}}],[\"tolist\",{\"1\":{\"313\":1}}],[\"tostring\",{\"1\":{\"575\":1,\"587\":1,\"591\":1,\"600\":1,\"601\":1,\"602\":2,\"619\":1,\"640\":1,\"643\":1,\"655\":1}}],[\"todo\",{\"1\":{\"310\":1}}],[\"tomcat\",{\"1\":{\"309\":1}}],[\"total\",{\"1\":{\"522\":2}}],[\"tot\",{\"1\":{\"144\":3}}],[\"to\",{\"1\":{\"71\":2,\"274\":2,\"322\":1,\"353\":3,\"474\":3,\"475\":2,\"509\":1,\"647\":2}}],[\"topk\",{\"1\":{\"294\":2}}],[\"topic\",{\"1\":{\"281\":1,\"282\":1}}],[\"topsort\",{\"1\":{\"169\":1}}],[\"top\",{\"1\":{\"43\":2,\"44\":1,\"173\":1,\"242\":2,\"249\":1,\"456\":3}}],[\"t这样的出口符号\",{\"1\":{\"57\":1}}],[\"typora\",{\"1\":{\"350\":1}}],[\"type=\",{\"1\":{\"263\":3}}],[\"typedef\",{\"1\":{\"131\":1,\"196\":1,\"241\":1}}],[\"type\",{\"1\":{\"72\":2,\"263\":1,\"289\":3,\"291\":1}}],[\"ty\",{\"1\":{\"56\":3}}],[\"txt\",{\"1\":{\"622\":2}}],[\"tx\",{\"1\":{\"56\":3}}],[\"t≤n≤1000\",{\"1\":{\"43\":1}}],[\"t\",{\"1\":{\"41\":3,\"43\":15,\"44\":5,\"55\":3,\"56\":2,\"57\":1,\"63\":3,\"72\":1,\"98\":5,\"99\":11,\"129\":4,\"147\":7,\"148\":11,\"149\":5,\"150\":9,\"168\":2,\"169\":2,\"172\":7,\"173\":3,\"175\":9,\"176\":6,\"180\":16,\"196\":4,\"200\":4,\"205\":5,\"210\":7,\"212\":8,\"237\":8,\"249\":4,\"274\":1,\"406\":1,\"444\":3,\"469\":3,\"475\":2,\"572\":2,\"591\":2,\"642\":1}}],[\"transport\",{\"1\":{\"715\":1}}],[\"transferto\",{\"1\":{\"676\":1}}],[\"transaction\",{\"1\":{\"541\":1}}],[\"trimtosize\",{\"1\":{\"645\":1}}],[\"trim\",{\"1\":{\"578\":1,\"642\":1}}],[\"trie\",{\"0\":{\"423\":1},\"1\":{\"232\":1,\"424\":2,\"426\":9}}],[\"trie树存储形式\",{\"1\":{\"232\":1}}],[\"trie树\",{\"0\":{\"232\":1}}],[\"try\",{\"0\":{\"622\":1},\"1\":{\"424\":1,\"620\":1,\"621\":1,\"622\":4,\"632\":3,\"634\":1,\"636\":1,\"676\":1,\"706\":1}}],[\"treemap\",{\"1\":{\"647\":3}}],[\"treemap<k\",{\"1\":{\"613\":2}}],[\"treeset\",{\"1\":{\"646\":2,\"647\":1}}],[\"treeset多的函数\",{\"1\":{\"612\":1}}],[\"treeset<k>\",{\"1\":{\"612\":1}}],[\"treenode\",{\"1\":{\"25\":4,\"363\":2,\"366\":2,\"376\":1,\"377\":2,\"378\":2,\"389\":2,\"390\":2,\"396\":2,\"401\":1,\"402\":2,\"408\":6,\"414\":2,\"420\":9,\"432\":3,\"438\":4,\"463\":4,\"481\":2,\"486\":2,\"487\":1,\"488\":2}}],[\"tree\",{\"1\":{\"24\":3}}],[\"true\",{\"1\":{\"24\":1,\"25\":4,\"43\":1,\"101\":1,\"108\":1,\"111\":4,\"129\":1,\"131\":1,\"148\":1,\"167\":1,\"168\":2,\"172\":1,\"173\":1,\"175\":2,\"176\":3,\"180\":1,\"182\":2,\"183\":2,\"187\":1,\"191\":1,\"192\":4,\"193\":2,\"200\":1,\"201\":2,\"210\":1,\"239\":1,\"250\":1,\"313\":1,\"424\":2,\"425\":2,\"426\":1,\"431\":1,\"473\":1,\"474\":1,\"475\":3,\"486\":1,\"487\":1,\"551\":1,\"565\":1,\"567\":1,\"636\":1,\"640\":1,\"715\":3}}],[\"wget\",{\"1\":{\"660\":1}}],[\"we\",{\"1\":{\"647\":2}}],[\"wednesday\",{\"1\":{\"559\":1}}],[\"webdav\",{\"0\":{\"355\":1,\"356\":1,\"357\":1,\"358\":1},\"1\":{\"351\":1,\"352\":1,\"356\":3,\"357\":7,\"358\":1}}],[\"webstorm\",{\"1\":{\"302\":1}}],[\"web\",{\"1\":{\"300\":1,\"353\":1,\"662\":1}}],[\"web场景来设计\",{\"1\":{\"279\":1}}],[\"web场景\",{\"1\":{\"258\":1}}],[\"web中间件\",{\"1\":{\"14\":1}}],[\"work\",{\"0\":{\"756\":1},\"1\":{\"635\":2}}],[\"worker2\",{\"1\":{\"632\":5,\"634\":3,\"635\":6}}],[\"worker1\",{\"1\":{\"632\":5,\"634\":3,\"635\":6}}],[\"worker\",{\"1\":{\"632\":5,\"634\":6,\"635\":13,\"636\":12}}],[\"workingdirectory=\",{\"1\":{\"353\":1}}],[\"world\",{\"1\":{\"555\":2,\"578\":4,\"580\":1,\"587\":1,\"591\":1,\"680\":5,\"682\":1}}],[\"word\",{\"1\":{\"424\":5,\"426\":8}}],[\"warn\",{\"1\":{\"706\":1}}],[\"waittimeinmswhensyncempty\",{\"1\":{\"707\":1}}],[\"wait\",{\"0\":{\"636\":1},\"1\":{\"636\":1}}],[\"want\",{\"1\":{\"647\":2}}],[\"wantedby=multi\",{\"1\":{\"353\":1}}],[\"wants=network\",{\"1\":{\"353\":1}}],[\"way\",{\"1\":{\"109\":4}}],[\"www\",{\"1\":{\"274\":2,\"354\":1,\"659\":1,\"668\":1}}],[\"winsw\",{\"1\":{\"663\":4}}],[\"windows\",{\"0\":{\"358\":1,\"662\":1,\"663\":1},\"1\":{\"347\":2,\"358\":1,\"662\":2,\"663\":3}}],[\"with\",{\"0\":{\"622\":1},\"1\":{\"347\":1,\"622\":1,\"647\":2,\"706\":1,\"715\":2,\"728\":1}}],[\"wiki\",{\"1\":{\"274\":1}}],[\"wikipedia\",{\"1\":{\"274\":1}}],[\"wi​\",{\"1\":{\"83\":2}}],[\"write\",{\"1\":{\"270\":1,\"555\":1,\"622\":1}}],[\"where\",{\"1\":{\"263\":5,\"289\":2,\"513\":2,\"514\":1,\"516\":2,\"518\":1,\"520\":6,\"521\":1,\"529\":1,\"531\":1,\"534\":2}}],[\"while语句与\",{\"1\":{\"562\":1}}],[\"while\",{\"0\":{\"561\":1,\"562\":1},\"1\":{\"41\":1,\"43\":2,\"44\":3,\"98\":1,\"99\":1,\"111\":1,\"118\":1,\"122\":1,\"125\":1,\"129\":3,\"131\":1,\"137\":3,\"138\":3,\"141\":1,\"142\":1,\"143\":1,\"145\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"160\":1,\"161\":1,\"168\":1,\"169\":1,\"172\":1,\"173\":1,\"175\":2,\"176\":1,\"188\":1,\"189\":1,\"196\":3,\"199\":1,\"201\":1,\"208\":1,\"209\":2,\"210\":2,\"214\":1,\"227\":1,\"230\":1,\"231\":2,\"237\":1,\"240\":1,\"250\":1,\"377\":2,\"390\":2,\"396\":2,\"402\":1,\"444\":1,\"456\":1,\"469\":3,\"561\":5,\"562\":5,\"563\":1,\"622\":1}}],[\"w表示边的权重\",{\"1\":{\"174\":1}}],[\"w表示的是无权图\",{\"1\":{\"132\":1}}],[\"w\",{\"1\":{\"43\":7,\"70\":4,\"83\":3,\"110\":3,\"116\":4,\"117\":4,\"118\":14,\"119\":6,\"127\":1,\"132\":4,\"165\":2,\"173\":4,\"174\":8,\"175\":4,\"176\":3,\"181\":8,\"247\":2,\"248\":2,\"249\":2,\"250\":2}}],[\"→\",{\"1\":{\"41\":1,\"272\":4}}],[\"补充\",{\"0\":{\"41\":1}}],[\"66\",{\"1\":{\"577\":1}}],[\"60\",{\"1\":{\"557\":1,\"707\":1}}],[\"6010\",{\"1\":{\"134\":4}}],[\"65\",{\"1\":{\"507\":2}}],[\"65535\",{\"1\":{\"507\":2}}],[\"67gb\",{\"1\":{\"334\":2}}],[\"64\",{\"1\":{\"204\":1}}],[\"695\",{\"1\":{\"50\":1}}],[\"6\",{\"0\":{\"41\":1,\"67\":1,\"126\":1,\"130\":1,\"131\":1,\"132\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"182\":1,\"204\":1,\"219\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"269\":1,\"270\":1,\"521\":1,\"527\":1,\"528\":1,\"529\":1,\"530\":1,\"531\":1,\"532\":1,\"533\":1,\"534\":1,\"535\":1,\"536\":1,\"537\":1,\"538\":1,\"582\":1,\"583\":1,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":2,\"589\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"594\":1,\"595\":1,\"596\":1,\"620\":1,\"690\":1,\"723\":1,\"724\":1,\"725\":1},\"1\":{\"44\":9,\"81\":1,\"93\":1,\"99\":9,\"109\":1,\"111\":1,\"121\":1,\"145\":1,\"147\":1,\"148\":1,\"158\":1,\"174\":1,\"205\":1,\"273\":1,\"274\":1,\"323\":1,\"545\":1,\"553\":1,\"557\":1,\"559\":1,\"563\":1,\"573\":1,\"574\":1,\"668\":3,\"715\":1,\"727\":1}}],[\"因子\",{\"1\":{\"273\":1}}],[\"因子机的重难点是需要管理各种数据获取的拓扑关系\",{\"1\":{\"273\":1}}],[\"因子机\",{\"1\":{\"273\":2}}],[\"因此我们对每个节点引入一个标志\",{\"1\":{\"425\":1}}],[\"因此我们针对数据源的特点做了多级缓存\",{\"1\":{\"273\":1}}],[\"因此每个节点最多有\",{\"1\":{\"425\":1}}],[\"因此利用迭代的思想\",{\"1\":{\"384\":1}}],[\"因此这个布隆过滤器大约占用\",{\"1\":{\"334\":1}}],[\"因此要考虑\",{\"1\":{\"334\":1}}],[\"因此会导致其他用户也无法注册这个用户名\",{\"1\":{\"334\":1}}],[\"因此数据也不会在缓存中\",{\"1\":{\"334\":1}}],[\"因此布隆过滤器会出现\",{\"1\":{\"334\":1}}],[\"因此做\",{\"1\":{\"294\":1}}],[\"因此必须判定\",{\"1\":{\"291\":1}}],[\"因此只需要迭代查询两次即可\",{\"1\":{\"289\":1}}],[\"因此只有某个点染色失败才能立刻\",{\"1\":{\"182\":1}}],[\"因此系统设计层面需要提供更多元\",{\"1\":{\"273\":1}}],[\"因此在右子树中寻找第\",{\"1\":{\"365\":1}}],[\"因此在左子树中寻找第\",{\"1\":{\"365\":1}}],[\"因此在\",{\"1\":{\"273\":1}}],[\"因此按照评论维度进行拆分仍然存在并发事务问题\",{\"1\":{\"270\":1}}],[\"因此该操作是最先感知到读热点存在的\",{\"1\":{\"266\":1}}],[\"因此选用\",{\"1\":{\"264\":1}}],[\"因此结合查询逻辑\",{\"1\":{\"263\":1}}],[\"因此独立设计第3张表\",{\"1\":{\"263\":1}}],[\"因此需要放到消息队列中处理\",{\"1\":{\"261\":1}}],[\"因此需要对\",{\"1\":{\"174\":1}}],[\"因此一般会作为一个独立系统拆分设计\",{\"1\":{\"256\":1}}],[\"因此可以递推的每次乘\",{\"1\":{\"209\":1}}],[\"因此可以用\",{\"1\":{\"158\":1}}],[\"因此最终结果\",{\"1\":{\"200\":1}}],[\"因此不仅需要将基数\",{\"1\":{\"200\":1}}],[\"因此前导0在数组前面\",{\"1\":{\"150\":1}}],[\"因此\",{\"1\":{\"128\":1,\"193\":1,\"200\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":2,\"266\":1,\"274\":1,\"651\":1}}],[\"因此其计算方法也是我们比较熟悉的\",{\"1\":{\"40\":1}}],[\"因为自己就包含了注册表信息\",{\"1\":{\"715\":1}}],[\"因为常量的定义都是大写\",{\"1\":{\"704\":1}}],[\"因为此时name只读\",{\"1\":{\"687\":1}}],[\"因为不管是二叉搜索数还是红黑数\",{\"1\":{\"545\":1}}],[\"因为不能比这个更深了\",{\"1\":{\"408\":1}}],[\"因为左子树的所有节点都要小于根节点的值\",{\"1\":{\"486\":1}}],[\"因为它们是本来就有的\",{\"1\":{\"468\":1}}],[\"因为烂橘子不止一个\",{\"1\":{\"468\":1}}],[\"因为是从\",{\"1\":{\"445\":1}}],[\"因为是倒序数组\",{\"1\":{\"148\":1}}],[\"因为遍历图是需要\",{\"1\":{\"443\":1}}],[\"因为本题要求高度平衡\",{\"1\":{\"437\":1}}],[\"因为本质是一样的\",{\"1\":{\"231\":1}}],[\"因为字符串中只存在小写字母\",{\"1\":{\"425\":1}}],[\"因为更新当前的右指针的时候\",{\"1\":{\"378\":1}}],[\"因为我自己有加速器\",{\"1\":{\"347\":1}}],[\"因为我们的\",{\"1\":{\"353\":1}}],[\"因为我们之前已经选择的是\",{\"1\":{\"302\":1}}],[\"因为我们是从小到大遍历的\",{\"1\":{\"193\":1}}],[\"因为底层的\",{\"1\":{\"294\":1}}],[\"因为产品形态上只存在\",{\"1\":{\"289\":1}}],[\"因为上文提到\",{\"1\":{\"270\":1}}],[\"因为发评的异步处理端到端延迟基本在2s以内\",{\"1\":{\"261\":1}}],[\"因为存的都是英文字母\",{\"1\":{\"232\":1}}],[\"因为围棋交战双方分别只能落黑子和白子\",{\"1\":{\"215\":1}}],[\"因为从\",{\"1\":{\"209\":1}}],[\"因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化\",{\"1\":{\"183\":1}}],[\"因为你要去问的都是男孩子\",{\"1\":{\"183\":1}}],[\"因为再给边排序的时候是按照边的权重进行排序的\",{\"1\":{\"181\":1}}],[\"因为\",{\"1\":{\"158\":1,\"192\":1,\"203\":1,\"291\":1,\"346\":1,\"445\":1,\"451\":1,\"486\":1,\"648\":1}}],[\"因为剩下的这部分一定是大于前面的\",{\"1\":{\"138\":1}}],[\"因为零是起点\",{\"1\":{\"132\":1}}],[\"因为要求最小值\",{\"1\":{\"132\":1}}],[\"因为数据范围是从0开始的\",{\"1\":{\"83\":1}}],[\"因为r最大可取到10^9\",{\"1\":{\"83\":1}}],[\"因为题目的内存限制\",{\"1\":{\"83\":1}}],[\"因为当\",{\"1\":{\"81\":1}}],[\"因为在集群环境中\",{\"1\":{\"714\":1}}],[\"因为在这类函数的最后一句后面会隐式地执行\",{\"1\":{\"593\":1}}],[\"因为在一些情况\",{\"1\":{\"36\":1}}],[\"因为在没有达到终点之前\",{\"1\":{\"36\":1}}],[\"+x\",{\"1\":{\"352\":1,\"660\":1,\"680\":1,\"689\":1,\"692\":1}}],[\"+|\",{\"1\":{\"310\":1,\"323\":1}}],[\"+2xt​​\",{\"1\":{\"201\":1}}],[\"+inf\",{\"1\":{\"180\":1}}],[\"+happy\",{\"1\":{\"134\":1}}],[\"+size\",{\"1\":{\"66\":1}}],[\"+=|\",{\"1\":{\"310\":1,\"323\":1}}],[\"+=\",{\"1\":{\"44\":4,\"75\":1,\"81\":2,\"82\":2,\"83\":2,\"94\":4,\"99\":1,\"110\":1,\"118\":4,\"129\":4,\"131\":1,\"134\":2,\"144\":1,\"147\":2,\"149\":1,\"154\":1,\"155\":2,\"180\":1,\"181\":1,\"191\":1,\"192\":2,\"210\":2,\"212\":1,\"234\":2,\"235\":1,\"236\":1,\"481\":3,\"552\":2,\"561\":1,\"563\":2,\"566\":1,\"578\":1}}],[\"++a\",{\"1\":{\"552\":1}}],[\"++size\",{\"1\":{\"237\":1}}],[\"++res\",{\"1\":{\"189\":1}}],[\"++tt\",{\"1\":{\"169\":2,\"226\":1,\"227\":1,\"229\":1,\"230\":1}}],[\"++y\",{\"1\":{\"83\":1}}],[\"++x\",{\"1\":{\"83\":1}}],[\"++mx\",{\"1\":{\"70\":1}}],[\"++\",{\"1\":{\"43\":1,\"81\":2,\"128\":5,\"129\":2,\"131\":6,\"134\":1,\"165\":4,\"172\":3,\"174\":2,\"176\":1,\"181\":1,\"182\":1,\"183\":1,\"196\":3,\"200\":3,\"205\":7,\"208\":1,\"209\":1,\"210\":7,\"223\":1,\"232\":4,\"235\":1,\"236\":1,\"239\":1,\"241\":1,\"242\":1,\"552\":1,\"553\":2,\"561\":3,\"563\":4,\"565\":1,\"566\":1,\"567\":5,\"572\":6,\"573\":3,\"578\":1,\"580\":1,\"583\":1,\"584\":1,\"591\":1,\"620\":2,\"632\":3,\"634\":2,\"635\":4,\"636\":1}}],[\"+1\",{\"1\":{\"41\":2,\"62\":1,\"111\":1,\"289\":1,\"401\":1,\"402\":1}}],[\"+f\",{\"1\":{\"41\":1,\"43\":1,\"128\":1,\"561\":1,\"563\":1}}],[\"+\",{\"1\":{\"38\":1,\"39\":2,\"40\":1,\"41\":8,\"43\":8,\"44\":11,\"48\":2,\"49\":2,\"50\":6,\"55\":2,\"56\":3,\"57\":3,\"62\":3,\"65\":2,\"67\":1,\"68\":2,\"69\":2,\"74\":4,\"75\":1,\"76\":4,\"81\":2,\"82\":1,\"83\":5,\"98\":3,\"99\":5,\"101\":1,\"107\":3,\"108\":1,\"109\":3,\"110\":5,\"111\":4,\"116\":2,\"117\":2,\"118\":4,\"119\":2,\"121\":6,\"122\":6,\"123\":4,\"124\":1,\"125\":7,\"126\":8,\"127\":12,\"128\":10,\"129\":4,\"132\":2,\"134\":2,\"137\":5,\"138\":4,\"141\":4,\"142\":2,\"143\":2,\"144\":8,\"145\":1,\"147\":3,\"148\":2,\"150\":1,\"152\":4,\"153\":1,\"154\":1,\"155\":4,\"159\":1,\"160\":1,\"161\":3,\"165\":3,\"166\":1,\"171\":1,\"172\":2,\"173\":2,\"174\":4,\"175\":2,\"176\":3,\"178\":1,\"180\":2,\"181\":2,\"182\":1,\"191\":5,\"192\":1,\"193\":1,\"196\":11,\"203\":3,\"204\":2,\"205\":2,\"207\":1,\"209\":1,\"210\":3,\"211\":1,\"231\":4,\"237\":4,\"239\":2,\"240\":1,\"241\":2,\"242\":1,\"243\":13,\"247\":4,\"248\":4,\"249\":2,\"250\":2,\"251\":1,\"289\":1,\"291\":4,\"310\":1,\"322\":1,\"323\":1,\"350\":1,\"365\":1,\"366\":2,\"389\":2,\"401\":1,\"407\":1,\"414\":2,\"419\":5,\"420\":13,\"438\":2,\"443\":2,\"444\":2,\"445\":10,\"451\":3,\"469\":4,\"545\":4,\"552\":3,\"553\":7,\"555\":2,\"557\":4,\"561\":1,\"563\":5,\"568\":1,\"572\":3,\"577\":1,\"578\":2,\"580\":1,\"588\":1,\"596\":1,\"606\":3,\"607\":3,\"622\":4,\"628\":1,\"632\":3,\"636\":3,\"641\":1,\"647\":1,\"675\":5,\"702\":1,\"706\":5,\"707\":1}}],[\"yxc\",{\"1\":{\"555\":1,\"578\":1,\"628\":3,\"636\":1,\"685\":2,\"690\":3,\"695\":1,\"696\":1,\"697\":1,\"698\":1}}],[\"year\",{\"1\":{\"507\":1,\"557\":4,\"558\":4}}],[\"yes\",{\"1\":{\"55\":2,\"93\":4,\"214\":1,\"557\":2,\"558\":1,\"565\":1}}],[\"y方向数组\",{\"1\":{\"469\":1}}],[\"yanue\",{\"1\":{\"347\":1}}],[\"yarn\",{\"1\":{\"302\":2}}],[\"yml\",{\"1\":{\"310\":2,\"311\":1,\"673\":1}}],[\"yk\",{\"1\":{\"218\":3}}],[\"y是分母\",{\"1\":{\"209\":1}}],[\"y=x\",{\"1\":{\"203\":1}}],[\"y=0\",{\"1\":{\"203\":1}}],[\"y2\",{\"1\":{\"153\":3,\"155\":3,\"218\":3}}],[\"y1\",{\"1\":{\"153\":3,\"155\":3,\"218\":1}}],[\"yi​⩽50000⩽wi​⩽1000\",{\"1\":{\"83\":1}}],[\"yi​\",{\"1\":{\"83\":2,\"94\":3}}],[\"your\",{\"1\":{\"66\":1,\"642\":2}}],[\"yyyy\",{\"1\":{\"507\":4}}],[\"yy\",{\"1\":{\"44\":5,\"48\":2,\"49\":2,\"55\":9,\"56\":9,\"57\":8,\"99\":5,\"444\":6,\"469\":6}}],[\"y\",{\"1\":{\"38\":2,\"39\":2,\"40\":2,\"43\":5,\"44\":5,\"48\":7,\"49\":6,\"50\":9,\"55\":3,\"56\":3,\"57\":9,\"68\":3,\"83\":4,\"91\":2,\"93\":7,\"94\":23,\"98\":7,\"99\":2,\"129\":2,\"158\":17,\"181\":2,\"197\":1,\"203\":10,\"204\":4,\"209\":4,\"234\":2,\"243\":4,\"289\":1,\"444\":2,\"469\":2,\"551\":1,\"553\":5,\"554\":1,\"562\":3,\"594\":2,\"600\":9,\"601\":2}}],[\"xy\",{\"1\":{\"704\":1}}],[\"x64\",{\"1\":{\"663\":1}}],[\"x方向数组\",{\"1\":{\"469\":1}}],[\"xml\",{\"1\":{\"322\":1,\"624\":1,\"663\":3}}],[\"x的左儿子是2x\",{\"1\":{\"237\":1}}],[\"x<y\",{\"1\":{\"227\":1}}],[\"x属于自然数\",{\"1\":{\"217\":1}}],[\"x是分子\",{\"1\":{\"209\":1}}],[\"x≡mi​\",{\"1\":{\"204\":1}}],[\"x2\",{\"1\":{\"153\":3,\"155\":3}}],[\"x1\",{\"1\":{\"153\":3,\"155\":3}}],[\"x=y\",{\"1\":{\"203\":1}}],[\"x=1\",{\"1\":{\"203\":1}}],[\"x=\",{\"1\":{\"93\":1}}],[\"xi​\",{\"1\":{\"83\":2,\"94\":3}}],[\"xxx\",{\"1\":{\"642\":5}}],[\"xx\",{\"1\":{\"44\":5,\"48\":2,\"49\":2,\"55\":9,\"56\":9,\"57\":8,\"99\":5,\"444\":6,\"469\":6,\"704\":3}}],[\"x\",{\"0\":{\"73\":1},\"1\":{\"38\":2,\"39\":2,\"40\":2,\"43\":2,\"44\":22,\"48\":7,\"49\":6,\"50\":9,\"55\":3,\"56\":3,\"57\":9,\"68\":3,\"70\":2,\"73\":2,\"74\":1,\"83\":4,\"90\":12,\"91\":2,\"93\":13,\"94\":25,\"98\":7,\"99\":17,\"111\":4,\"129\":13,\"137\":3,\"141\":1,\"142\":4,\"145\":1,\"158\":14,\"159\":18,\"161\":2,\"174\":1,\"176\":2,\"181\":8,\"183\":3,\"187\":5,\"188\":7,\"191\":1,\"193\":1,\"195\":5,\"196\":7,\"197\":1,\"199\":9,\"200\":1,\"203\":9,\"204\":9,\"208\":4,\"209\":4,\"214\":3,\"217\":1,\"218\":2,\"223\":3,\"224\":2,\"226\":1,\"229\":1,\"234\":8,\"235\":6,\"236\":10,\"237\":5,\"239\":6,\"240\":3,\"242\":2,\"243\":12,\"289\":1,\"345\":1,\"354\":2,\"406\":3,\"444\":2,\"467\":1,\"469\":2,\"475\":7,\"486\":6,\"488\":5,\"551\":2,\"553\":5,\"554\":1,\"557\":4,\"561\":2,\"562\":3,\"574\":2,\"578\":1,\"588\":5,\"590\":5,\"594\":2,\"600\":9,\"601\":2,\"620\":2,\"621\":2,\"689\":1}}],[\"=yxc\",{\"1\":{\"695\":1}}],[\"=abc\",{\"1\":{\"695\":1}}],[\"=2\",{\"1\":{\"561\":1,\"563\":1}}],[\"=<>>>=<<=\",{\"1\":{\"535\":1}}],[\"=p\",{\"1\":{\"231\":1}}],[\"=1\",{\"1\":{\"203\":1,\"561\":2,\"563\":2,\"695\":1}}],[\"=10\",{\"1\":{\"129\":2}}],[\"=n×p1​p1​−1​×p2​p2​−1​×\",{\"1\":{\"199\":1}}],[\"=>\",{\"1\":{\"192\":1,\"310\":1,\"541\":6,\"622\":2}}],[\"=∑u=sons​dp\",{\"1\":{\"134\":1}}],[\"=∑u=sons​max\",{\"1\":{\"134\":1}}],[\"=0\",{\"1\":{\"132\":1}}],[\"=f\",{\"1\":{\"128\":1,\"561\":1,\"563\":1}}],[\"=\",{\"1\":{\"38\":3,\"39\":3,\"40\":3,\"41\":8,\"43\":25,\"44\":27,\"48\":15,\"49\":13,\"50\":7,\"55\":14,\"56\":18,\"57\":15,\"63\":1,\"64\":3,\"65\":5,\"68\":3,\"70\":3,\"71\":8,\"72\":1,\"75\":8,\"76\":9,\"77\":1,\"81\":6,\"82\":9,\"83\":9,\"89\":2,\"90\":1,\"91\":3,\"93\":8,\"94\":14,\"98\":11,\"99\":14,\"101\":6,\"107\":6,\"108\":7,\"109\":5,\"110\":8,\"111\":12,\"116\":9,\"117\":9,\"118\":28,\"119\":13,\"121\":17,\"122\":26,\"123\":7,\"124\":12,\"125\":16,\"126\":13,\"127\":18,\"128\":16,\"129\":29,\"131\":15,\"132\":10,\"134\":6,\"137\":5,\"138\":12,\"140\":1,\"141\":5,\"142\":5,\"143\":4,\"144\":5,\"145\":4,\"147\":12,\"148\":20,\"149\":8,\"150\":8,\"152\":2,\"153\":1,\"154\":1,\"155\":2,\"158\":31,\"159\":10,\"160\":3,\"161\":5,\"162\":8,\"165\":14,\"167\":5,\"168\":7,\"169\":10,\"172\":12,\"173\":14,\"174\":8,\"175\":15,\"176\":11,\"178\":8,\"180\":17,\"181\":19,\"182\":8,\"183\":8,\"187\":1,\"188\":3,\"189\":8,\"191\":5,\"192\":10,\"193\":6,\"195\":2,\"196\":11,\"199\":5,\"200\":11,\"201\":5,\"203\":9,\"204\":10,\"205\":16,\"207\":4,\"208\":8,\"209\":10,\"210\":17,\"211\":1,\"212\":12,\"214\":2,\"217\":1,\"218\":2,\"219\":1,\"223\":10,\"224\":10,\"226\":2,\"227\":3,\"229\":3,\"230\":4,\"231\":12,\"232\":9,\"234\":9,\"235\":6,\"236\":8,\"237\":10,\"239\":8,\"240\":4,\"241\":4,\"242\":1,\"243\":4,\"247\":6,\"248\":7,\"249\":4,\"250\":13,\"251\":9,\"289\":3,\"310\":7,\"311\":7,\"313\":4,\"315\":3,\"322\":2,\"323\":30,\"354\":2,\"363\":3,\"365\":1,\"366\":3,\"377\":9,\"378\":4,\"389\":1,\"390\":7,\"396\":7,\"401\":2,\"402\":6,\"408\":2,\"414\":4,\"420\":19,\"426\":17,\"438\":4,\"443\":8,\"444\":17,\"445\":12,\"451\":9,\"456\":4,\"463\":4,\"468\":1,\"469\":31,\"473\":1,\"474\":6,\"475\":13,\"481\":3,\"486\":3,\"487\":2,\"488\":4,\"513\":2,\"518\":2,\"522\":1,\"529\":1,\"534\":1,\"537\":1,\"545\":1,\"551\":7,\"552\":15,\"553\":7,\"554\":8,\"555\":1,\"557\":28,\"558\":7,\"559\":10,\"561\":12,\"562\":2,\"563\":14,\"565\":5,\"566\":2,\"567\":7,\"568\":1,\"570\":4,\"571\":3,\"572\":26,\"573\":7,\"574\":1,\"577\":5,\"578\":13,\"579\":3,\"580\":2,\"583\":3,\"584\":4,\"587\":1,\"588\":2,\"590\":2,\"591\":7,\"593\":4,\"594\":3,\"596\":2,\"600\":4,\"601\":2,\"602\":2,\"606\":1,\"607\":2,\"620\":8,\"621\":2,\"622\":4,\"628\":8,\"632\":5,\"634\":5,\"635\":11,\"636\":6,\"642\":16,\"643\":1,\"645\":4,\"646\":3,\"647\":4,\"648\":2,\"649\":1,\"650\":1,\"651\":4,\"656\":14,\"673\":1,\"675\":5,\"676\":8,\"695\":1,\"702\":3,\"704\":1,\"706\":6,\"710\":1,\"711\":2,\"714\":2,\"715\":4,\"717\":5,\"719\":1,\"720\":1,\"721\":1,\"724\":1}}],[\"==\",{\"1\":{\"25\":6,\"43\":2,\"44\":2,\"48\":2,\"49\":2,\"50\":2,\"55\":4,\"56\":8,\"57\":15,\"64\":2,\"70\":1,\"75\":1,\"81\":5,\"82\":2,\"90\":2,\"93\":2,\"94\":6,\"98\":2,\"99\":1,\"101\":1,\"107\":2,\"110\":1,\"123\":2,\"124\":1,\"125\":1,\"126\":2,\"127\":1,\"131\":1,\"148\":1,\"149\":1,\"150\":1,\"158\":3,\"169\":2,\"172\":2,\"173\":1,\"174\":1,\"175\":1,\"178\":1,\"180\":3,\"181\":3,\"182\":3,\"183\":1,\"187\":1,\"188\":2,\"189\":3,\"193\":2,\"195\":1,\"196\":1,\"199\":2,\"200\":2,\"210\":1,\"231\":3,\"239\":1,\"240\":1,\"242\":1,\"243\":1,\"310\":2,\"311\":2,\"313\":1,\"363\":3,\"366\":2,\"378\":1,\"389\":2,\"390\":2,\"396\":1,\"401\":1,\"402\":1,\"408\":5,\"414\":1,\"420\":1,\"426\":2,\"432\":4,\"443\":2,\"444\":2,\"445\":6,\"451\":1,\"463\":1,\"469\":6,\"481\":1,\"486\":1,\"487\":1,\"488\":1,\"557\":6,\"558\":2,\"561\":1,\"565\":1,\"566\":1,\"567\":1,\"593\":1,\"621\":1,\"702\":2}}],[\"通配符\",{\"1\":{\"517\":1}}],[\"通用语法\",{\"0\":{\"495\":1}}],[\"通讯协议\",{\"1\":{\"345\":1}}],[\"通过官方注释可以知道这个类的作用\",{\"1\":{\"717\":1}}],[\"通过名字可以知道是\",{\"1\":{\"717\":1}}],[\"通过接口的\",{\"1\":{\"710\":1}}],[\"通过数学算法将数据分割成多个数据块和校验块\",{\"1\":{\"668\":1}}],[\"通过数据库的优化来提高数据库的访问性能\",{\"1\":{\"497\":1}}],[\"通过传入其他参数\",{\"1\":{\"642\":1}}],[\"通过引用找到变量的真正地址\",{\"1\":{\"591\":1}}],[\"通过下标访问数组\",{\"1\":{\"572\":1}}],[\"通过下式\",{\"1\":{\"83\":1}}],[\"通过索引列对数据进行排序\",{\"1\":{\"544\":1}}],[\"通过逻辑外键\",{\"1\":{\"524\":1}}],[\"通过指令\",{\"1\":{\"499\":1}}],[\"通过以上三步\",{\"1\":{\"419\":1}}],[\"通过多种存储策略的支持\",{\"1\":{\"351\":1}}],[\"通过多级冗余与跨级合并\",{\"1\":{\"273\":1}}],[\"通过反向代理到请求\",{\"1\":{\"329\":1}}],[\"通过对敏感数据进行修改或者替换的方\",{\"1\":{\"309\":1}}],[\"通过增量加载的方式逐渐预热填充缓存\",{\"1\":{\"291\":1}}],[\"通过冗余数据的方式\",{\"1\":{\"283\":1}}],[\"通过冗余校验\",{\"1\":{\"269\":1}}],[\"通过组合与继承\",{\"1\":{\"273\":1}}],[\"通过梳理依赖关系和推导计算\",{\"1\":{\"273\":1}}],[\"通过召回机制来实现想要的\",{\"1\":{\"273\":1}}],[\"通过前面列出的公式\",{\"1\":{\"266\":1}}],[\"通过持续演进架构设计\",{\"1\":{\"254\":1}}],[\"通过定理求组合数c\",{\"1\":{\"209\":1}}],[\"通过预处理逆元的方式求组和数\",{\"0\":{\"208\":1}}],[\"通过初等行变换把\",{\"1\":{\"205\":1}}],[\"通过一个连接起来\",{\"1\":{\"179\":1}}],[\"通过替换旧值为向量元素分配新值\",{\"1\":{\"74\":1}}],[\"通过\",{\"1\":{\"71\":3,\"210\":1,\"352\":1}}],[\"通过调节启发函数我们可以控制算法的速度和精确度\",{\"1\":{\"36\":1}}],[\"通常通过基于\",{\"1\":{\"667\":1}}],[\"通常情况下\",{\"1\":{\"593\":1}}],[\"通常是用来做单表的拆分\",{\"1\":{\"525\":1}}],[\"通常是一个固定的常数\",{\"1\":{\"38\":1}}],[\"通常封装到\",{\"1\":{\"522\":1}}],[\"通常不接受用户输入\",{\"1\":{\"353\":1}}],[\"通常给定一个\",{\"1\":{\"55\":1}}],[\"通常比所给数据范围大一点\",{\"1\":{\"48\":1}}],[\"通常来说\",{\"1\":{\"48\":1}}],[\"它尝试着从集群节点去获取所有的注册信息\",{\"1\":{\"717\":1}}],[\"它以对象为单位来处理\",{\"1\":{\"667\":1}}],[\"它表示函数不返回任何值\",{\"1\":{\"587\":1}}],[\"它作用于一个整型参数\",{\"1\":{\"583\":1}}],[\"它对数据库中的数据的改变就是永久的\",{\"1\":{\"542\":1}}],[\"它对数据库的改变将是永久性的\",{\"1\":{\"542\":1}}],[\"它是一个帮助类\",{\"1\":{\"719\":1}}],[\"它是一个不可分割的工作单位\",{\"1\":{\"540\":1}}],[\"它是对一列的值进行计算\",{\"1\":{\"519\":1}}],[\"它是由原字符串在不改变字符的相对顺序的情况下删除某些字符\",{\"1\":{\"449\":1}}],[\"它们属于类相关的概念\",{\"1\":{\"583\":1}}],[\"它们的\",{\"1\":{\"450\":1}}],[\"它们通常在系统启动时启动\",{\"1\":{\"353\":1}}],[\"它们按照某种顺序排成长度为2n的序列\",{\"1\":{\"211\":1}}],[\"它真的太方便了\",{\"1\":{\"352\":1}}],[\"它仅仅只能用来存储\",{\"1\":{\"350\":1}}],[\"它直接使用\",{\"1\":{\"289\":1}}],[\"它就会被淹没\",{\"1\":{\"100\":1}}],[\"它主要用于处理一些不相交集合的合并问题\",{\"1\":{\"87\":1}}],[\"它会修改矢量的大小\",{\"1\":{\"74\":1}}],[\"它的每个元素是含有20个数组的数组\",{\"1\":{\"573\":1}}],[\"它的左右子树也为二叉搜索树\",{\"1\":{\"486\":1}}],[\"它的\",{\"1\":{\"382\":1}}],[\"它的行动规则是任选某个有向图游戏gi\",{\"1\":{\"219\":1}}],[\"它的一个重要推论是\",{\"1\":{\"68\":1,\"203\":1}}],[\"它的计算方法如下\",{\"1\":{\"39\":1}}],[\"它的计算方法如下图所示\",{\"1\":{\"38\":1}}],[\"它有较好的性能和准确度\",{\"1\":{\"30\":1}}],[\"56\",{\"1\":{\"553\":1}}],[\"56098191\",{\"1\":{\"311\":1}}],[\"59\",{\"1\":{\"507\":6,\"642\":1}}],[\"535\",{\"1\":{\"507\":2}}],[\"543\",{\"1\":{\"411\":1}}],[\"5212\",{\"1\":{\"352\":2,\"354\":1}}],[\"50x\",{\"1\":{\"354\":2}}],[\"504\",{\"1\":{\"354\":1}}],[\"503\",{\"1\":{\"354\":1}}],[\"502\",{\"1\":{\"354\":1}}],[\"500\",{\"1\":{\"354\":1}}],[\"5001\",{\"1\":{\"83\":5}}],[\"50\",{\"1\":{\"289\":1,\"507\":1}}],[\"57\",{\"1\":{\"577\":1}}],[\"57021517\",{\"1\":{\"274\":1}}],[\"572\",{\"1\":{\"23\":1}}],[\"5个基本操作\",{\"1\":{\"237\":1}}],[\"510\",{\"1\":{\"121\":1,\"172\":1}}],[\"512\",{\"1\":{\"321\":1}}],[\"512m\",{\"1\":{\"66\":1}}],[\"512<<20\",{\"1\":{\"66\":1}}],[\"5e3\",{\"1\":{\"83\":1}}],[\"5\",{\"0\":{\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"66\":1,\"103\":1,\"125\":1,\"129\":1,\"151\":1,\"152\":1,\"153\":1,\"154\":1,\"155\":1,\"176\":1,\"179\":1,\"180\":1,\"181\":1,\"202\":1,\"211\":1,\"218\":1,\"232\":1,\"251\":1,\"261\":1,\"266\":1,\"267\":1,\"520\":1,\"523\":1,\"524\":1,\"525\":1,\"526\":1,\"538\":1,\"555\":1,\"567\":1,\"577\":1,\"578\":1,\"579\":1,\"580\":1,\"587\":1,\"596\":1,\"613\":1,\"619\":1,\"689\":1,\"718\":1,\"719\":1,\"720\":1,\"721\":1,\"722\":1},\"1\":{\"41\":2,\"43\":1,\"44\":10,\"63\":1,\"81\":2,\"82\":2,\"93\":2,\"98\":2,\"99\":9,\"109\":8,\"110\":1,\"121\":2,\"147\":1,\"148\":1,\"158\":1,\"174\":1,\"237\":1,\"243\":1,\"251\":1,\"255\":1,\"263\":1,\"266\":1,\"274\":1,\"293\":2,\"323\":1,\"551\":1,\"553\":2,\"555\":1,\"557\":4,\"559\":1,\"563\":1,\"572\":1,\"573\":1,\"574\":1,\"584\":2,\"590\":1,\"591\":1,\"620\":3,\"636\":2,\"642\":1,\"672\":1,\"690\":1,\"707\":1,\"708\":1,\"715\":1,\"717\":1,\"727\":1}}],[\"对用户而言\",{\"1\":{\"673\":2}}],[\"对用户的基本信息查询频率特别的高\",{\"1\":{\"525\":1}}],[\"对用户的查询或者修改\",{\"1\":{\"299\":1}}],[\"对浮点数四舍五入\",{\"1\":{\"653\":1}}],[\"对浮点数向下取整\",{\"1\":{\"653\":1}}],[\"对浮点数向上取整\",{\"1\":{\"653\":1}}],[\"对元素采用的是堆排序\",{\"1\":{\"651\":1}}],[\"对原来的list和返回的list做的\",{\"1\":{\"645\":1}}],[\"对形参的改动不会影响实参的初始值\",{\"1\":{\"590\":1}}],[\"对null值不作为统计\",{\"1\":{\"519\":1}}],[\"对二叉树进行递归遍历\",{\"1\":{\"480\":1}}],[\"对二叉树进行层序遍历\",{\"1\":{\"390\":1}}],[\"对称二叉树\",{\"0\":{\"429\":1},\"1\":{\"429\":1}}],[\"对每个节点的进行相同的递归处理\",{\"1\":{\"383\":1}}],[\"对每辆车进行枚举\",{\"1\":{\"110\":1}}],[\"对其进行读写操作\",{\"1\":{\"356\":1}}],[\"对需要存储的数据使用哈希函数计算得到\",{\"1\":{\"334\":1}}],[\"对密码进行加密\",{\"1\":{\"323\":1}}],[\"对密码进行md5盐值加密\",{\"1\":{\"310\":1,\"323\":1}}],[\"对象的过程非常复杂\",{\"1\":{\"715\":1}}],[\"对象里面有很多\",{\"1\":{\"708\":1}}],[\"对象是单例的\",{\"1\":{\"673\":1}}],[\"对象是类这种类型对应的实例\",{\"1\":{\"598\":1}}],[\"对象即可实现对\",{\"1\":{\"673\":1}}],[\"对象存储可以作为主存储层\",{\"1\":{\"668\":1}}],[\"对象存储的读\",{\"1\":{\"668\":1}}],[\"对象存储\",{\"1\":{\"667\":1}}],[\"对象来拼接\",{\"1\":{\"641\":1}}],[\"对象上\",{\"1\":{\"635\":1}}],[\"对象栈层次\",{\"1\":{\"619\":1}}],[\"对象代表异常原因\",{\"1\":{\"619\":1}}],[\"对象中\",{\"1\":{\"522\":1}}],[\"对象和数据库的关联\",{\"1\":{\"322\":1}}],[\"对象\",{\"1\":{\"300\":1,\"673\":2,\"704\":1,\"708\":1,\"710\":1,\"715\":1,\"717\":1}}],[\"对这个业务的系统有比较深的理解\",{\"1\":{\"278\":1}}],[\"对重算排序的收益进行预估\",{\"1\":{\"273\":1}}],[\"对特征的导入与更新都提出了挑战\",{\"1\":{\"273\":1}}],[\"对性能的影响较大\",{\"1\":{\"270\":1}}],[\"对各类数据写操作\",{\"1\":{\"269\":1}}],[\"对下游来说也是读放大\",{\"1\":{\"266\":1}}],[\"对应评论内容数据\",{\"1\":{\"291\":1}}],[\"对应主题的缓存\",{\"1\":{\"291\":1}}],[\"对应的关键字\",{\"1\":{\"524\":1}}],[\"对应的节点就在右视图中\",{\"1\":{\"389\":1}}],[\"对应的就是\",{\"1\":{\"289\":1}}],[\"对应的\",{\"1\":{\"264\":1}}],[\"对应于\",{\"1\":{\"264\":4}}],[\"对应嵌套多次点击\",{\"1\":{\"263\":1}}],[\"对应下标的数一一比较\",{\"1\":{\"108\":1,\"109\":1}}],[\"对评论业务来说\",{\"1\":{\"258\":1}}],[\"对作品录音作品的音乐评论\",{\"1\":{\"254\":1}}],[\"对自定义的结构体\",{\"1\":{\"243\":1}}],[\"对两个迭代器\",{\"1\":{\"243\":1}}],[\"对两个子序列分别设置个指针\",{\"1\":{\"138\":1}}],[\"对字符串也适用\",{\"1\":{\"242\":1}}],[\"对阶乘分解质因数之后\",{\"1\":{\"210\":1}}],[\"对朴素筛法的优化\",{\"1\":{\"191\":1}}],[\"对无符号数\",{\"1\":{\"157\":1}}],[\"对a提前判断一下\",{\"1\":{\"111\":1}}],[\"对\",{\"1\":{\"63\":1,\"300\":2,\"673\":1}}],[\"对角线上相邻\",{\"1\":{\"48\":1}}],[\"对角公式\",{\"1\":{\"39\":1}}],[\"对角距离\",{\"0\":{\"39\":1},\"1\":{\"36\":1,\"39\":1}}],[\"对于调用接口方法的地方是透明的\",{\"1\":{\"704\":1}}],[\"对于相似的变量\",{\"1\":{\"704\":1}}],[\"对于个人来说\",{\"1\":{\"667\":1}}],[\"对于企业来说\",{\"1\":{\"667\":1}}],[\"对于第二层每个元素有指针\",{\"1\":{\"545\":1}}],[\"对于树的左\",{\"1\":{\"419\":1}}],[\"对于有根树\",{\"1\":{\"406\":1}}],[\"对于有明确终点的问题来说\",{\"1\":{\"32\":1}}],[\"对于布隆过滤器无法删除元素这个缺点\",{\"1\":{\"334\":1}}],[\"对于热门的主题\",{\"1\":{\"293\":1}}],[\"对于嵌套层次多的\",{\"1\":{\"289\":1}}],[\"对于二级的子楼层\",{\"1\":{\"289\":1}}],[\"对于入队的消息\",{\"1\":{\"282\":1}}],[\"对于写的设计上\",{\"1\":{\"282\":1}}],[\"对于重建逻辑\",{\"1\":{\"281\":1}}],[\"对于弱依赖\",{\"1\":{\"267\":1}}],[\"对于用户来说\",{\"1\":{\"261\":1}}],[\"对于\",{\"1\":{\"231\":1,\"450\":1}}],[\"对于先手来说是一个必败状态\",{\"1\":{\"214\":1}}],[\"对于先手来说是一个必胜状态\",{\"1\":{\"214\":1}}],[\"对于大多数情况\",{\"1\":{\"197\":1}}],[\"对于所有的点都\",{\"1\":{\"174\":1}}],[\"对于所有待遍历的节点\",{\"1\":{\"33\":1}}],[\"对于一个序列\",{\"1\":{\"160\":1}}],[\"对于一般的树可能出现极端不平衡的情况\",{\"1\":{\"94\":1}}],[\"对于每个加入的字符串我们一定能在树中找到一条路径还原它\",{\"1\":{\"425\":1}}],[\"对于每个结点\",{\"1\":{\"365\":1}}],[\"对于每个\",{\"1\":{\"231\":2}}],[\"对于每个节点x\",{\"1\":{\"218\":1}}],[\"对于每个点k\",{\"1\":{\"165\":1}}],[\"对于每两个式子\",{\"1\":{\"204\":1}}],[\"对于每次询问\",{\"1\":{\"125\":1}}],[\"对于每一个\",{\"1\":{\"94\":1}}],[\"对于两个序列\",{\"1\":{\"160\":1}}],[\"对于两个数列\",{\"1\":{\"124\":1}}],[\"对于两个不同的行\",{\"1\":{\"108\":1,\"109\":1}}],[\"对于没有选任何数的方案\",{\"1\":{\"107\":1}}],[\"对于询问\",{\"1\":{\"93\":1}}],[\"对于我们的关于亲戚关系的提问\",{\"1\":{\"93\":1}}],[\"对于网格形式的图\",{\"1\":{\"36\":1}}],[\"曼哈顿距离\",{\"0\":{\"38\":1},\"1\":{\"36\":1,\"38\":1}}],[\"而服务之间是需要相互通信的\",{\"1\":{\"714\":1}}],[\"而用到的配置信息就是从\",{\"1\":{\"711\":1}}],[\"而在创建\",{\"1\":{\"707\":1}}],[\"而接口的方法是驼峰命名的\",{\"1\":{\"704\":1}}],[\"而指定的类对象因为是一个接口或是一个抽象类而无法实例化时\",{\"1\":{\"618\":1}}],[\"而每个节点一共能存储\",{\"1\":{\"545\":1}}],[\"而一个节点总共容量是\",{\"1\":{\"545\":1}}],[\"而一个身份证也只能关联一个用户\",{\"1\":{\"525\":1}}],[\"而我们在日常开发使用时\",{\"1\":{\"532\":1}}],[\"而第二张表存放的就是用户的身份信息\",{\"1\":{\"525\":1}}],[\"而中序遍历和后序遍历至少要递归到一个叶子节点\",{\"1\":{\"486\":1}}],[\"而节点的值范围在\",{\"1\":{\"486\":1}}],[\"而这道题有多个起点\",{\"1\":{\"468\":1}}],[\"而左子指针始终为\",{\"1\":{\"376\":1}}],[\"而使用宝塔面板安装的\",{\"1\":{\"354\":1}}],[\"而使用反向代理时\",{\"1\":{\"329\":1}}],[\"而不是在交互式用户界面下运行的进程\",{\"1\":{\"353\":1}}],[\"而不会再去查\",{\"1\":{\"293\":1}}],[\"而不会一下发到\",{\"1\":{\"282\":1}}],[\"而且也不需要从其他`\",{\"1\":{\"715\":1}}],[\"而且长度很短\",{\"1\":{\"352\":1}}],[\"而且公有云存储的存储有限\",{\"1\":{\"350\":1}}],[\"而且更换\",{\"1\":{\"346\":1}}],[\"而且并不安全\",{\"1\":{\"346\":1}}],[\"而分布式部署+负载均衡的网关\",{\"1\":{\"261\":1}}],[\"而点进评论区\",{\"1\":{\"254\":1}}],[\"而非数据内容\",{\"1\":{\"291\":1}}],[\"而非对某个数的余数时\",{\"1\":{\"210\":1}}],[\"而非一种软件\",{\"1\":{\"14\":1}}],[\"而整数\",{\"1\":{\"208\":1}}],[\"而此时另一个数即为所求答案\",{\"1\":{\"197\":1}}],[\"而并非是\",{\"1\":{\"174\":1}}],[\"而另一部分还有剩余\",{\"1\":{\"138\":1}}],[\"而所有的公共上升子序列中最长的就是最长公共上升子序列了\",{\"1\":{\"124\":1}}],[\"而\",{\"1\":{\"63\":1,\"110\":1,\"291\":1,\"322\":1,\"507\":1,\"520\":2,\"545\":1,\"641\":1,\"707\":1}}],[\"而是exit\",{\"1\":{\"693\":1}}],[\"而是记录这一层节点对应字符串的位置是否出现了某个字符\",{\"1\":{\"425\":1}}],[\"而是利用一个全局变量\",{\"1\":{\"378\":1}}],[\"而是通过系统的事件驱动或定时器来执行任务\",{\"1\":{\"353\":1}}],[\"而是打到数据库上\",{\"1\":{\"334\":1}}],[\"而是标记为已删除\",{\"1\":{\"310\":1}}],[\"而是只有像\",{\"1\":{\"57\":1}}],[\"而是希望能够尽快找到一个路径即可\",{\"1\":{\"36\":1}}],[\"由所有参数构成的用空格隔开的字符串\",{\"1\":{\"693\":1}}],[\"由安全管理器抛出的异常\",{\"1\":{\"618\":1}}],[\"由0个或多个形参组成的列表以及函数体\",{\"1\":{\"582\":1}}],[\"由题意可知\",{\"1\":{\"486\":1}}],[\"由它们之间边数表示\",{\"1\":{\"412\":1}}],[\"由两名玩家交替行动\",{\"1\":{\"215\":1}}],[\"由抽屉原理一定有两个点相同\",{\"1\":{\"176\":1}}],[\"由抽屉原理\",{\"1\":{\"174\":1}}],[\"由于业务之间相互关联\",{\"1\":{\"523\":1}}],[\"由于是根据前序遍历的节点来确定中序遍历中节点的位置\",{\"1\":{\"419\":1}}],[\"由于是每个点同时向外出发\",{\"1\":{\"174\":1}}],[\"由于以当前结点为根结点的子树中的大于右子结点值的结点数等于\",{\"1\":{\"365\":1}}],[\"由于在建表时\",{\"1\":{\"322\":1}}],[\"由于在除法运算中\",{\"1\":{\"150\":1}}],[\"由于一般只查询\",{\"1\":{\"289\":1}}],[\"由于排序问题的解决方案是探索型的\",{\"1\":{\"273\":1}}],[\"由于\",{\"1\":{\"273\":1,\"437\":1,\"443\":1}}],[\"由于扫描行数约等于\",{\"1\":{\"273\":1}}],[\"由于评论业务的下游依赖较多\",{\"1\":{\"266\":1}}],[\"由于评论内容是大字段\",{\"1\":{\"263\":1}}],[\"由于大量接口都需要读取评论区基础信息\",{\"1\":{\"266\":1}}],[\"由于上文所述各类\",{\"1\":{\"266\":1}}],[\"由于存在性判定和增量追加不是原子化的\",{\"1\":{\"264\":1}}],[\"由于列表是分页的\",{\"1\":{\"261\":1}}],[\"由于某个点染色成功并不代表整个图就是二分图\",{\"1\":{\"182\":1}}],[\"由于全球变暖导致了海面上升\",{\"1\":{\"100\":1}}],[\"由上面这些信息我们可以知道\",{\"1\":{\"36\":1}}],[\"由此就构成了一条路径\",{\"1\":{\"32\":1}}],[\"可嵌套\",{\"1\":{\"693\":1}}],[\"可选\",{\"1\":{\"673\":1}}],[\"可选字段\",{\"1\":{\"321\":1}}],[\"可视化管理界面\",{\"1\":{\"668\":1}}],[\"可视化辅助工具\",{\"1\":{\"302\":1}}],[\"可拓展\",{\"1\":{\"668\":1}}],[\"可拓展性的特点\",{\"1\":{\"667\":1}}],[\"可修改\",{\"1\":{\"660\":1}}],[\"可为string\",{\"1\":{\"642\":1}}],[\"可是在这种情况下\",{\"1\":{\"468\":1}}],[\"可确定\",{\"1\":{\"419\":1}}],[\"可将\",{\"1\":{\"419\":2}}],[\"可得出以下推论\",{\"1\":{\"419\":1}}],[\"可助你即刻构建出兼备自用或公用的网盘服务\",{\"1\":{\"351\":1}}],[\"可靠\",{\"1\":{\"310\":1}}],[\"可把该页面删除\",{\"1\":{\"302\":1}}],[\"可把一堆取光\",{\"1\":{\"214\":1}}],[\"可实现各类定制化排序\",{\"1\":{\"273\":1}}],[\"可用性上\",{\"1\":{\"279\":1}}],[\"可用性\",{\"1\":{\"273\":1}}],[\"可用性设计等\",{\"1\":{\"277\":1}}],[\"可用性设计\",{\"0\":{\"265\":1,\"292\":1}}],[\"可用于存储一些关键的附属信息\",{\"1\":{\"263\":1}}],[\"可用于描述评论\",{\"1\":{\"263\":1}}],[\"可计算出去重后的元素个数\",{\"1\":{\"243\":1}}],[\"可理解为\",{\"1\":{\"180\":1,\"181\":1}}],[\"可能过几天就会被\",{\"1\":{\"346\":1}}],[\"可能还存在外部防火墙没关或者端口放行方向不正确等问题\",{\"1\":{\"345\":1}}],[\"可能存在\",{\"1\":{\"334\":1}}],[\"可能将不在集合中的元素判断为在集合中\",{\"1\":{\"334\":1}}],[\"可能\",{\"1\":{\"334\":1}}],[\"可能包含参数校验\",{\"1\":{\"311\":1}}],[\"可能包含长度为偶数的环\",{\"1\":{\"182\":1}}],[\"可能会存在大\",{\"1\":{\"334\":1}}],[\"可能会变为瓶颈\",{\"1\":{\"294\":1}}],[\"可能会引起存储过载的情况\",{\"1\":{\"293\":1}}],[\"可能更好\",{\"1\":{\"289\":1}}],[\"可能是\",{\"1\":{\"279\":1}}],[\"可能是整数\",{\"1\":{\"72\":1}}],[\"可能在b事务中被修改\",{\"1\":{\"270\":1}}],[\"可能为负数\",{\"1\":{\"204\":1}}],[\"可能的报错\",{\"1\":{\"322\":1}}],[\"可能的\",{\"1\":{\"143\":1}}],[\"可进行的操作有\",{\"1\":{\"126\":1}}],[\"可使物品总体积不超过背包容量\",{\"1\":{\"119\":1}}],[\"可走且未访问\",{\"1\":{\"55\":1}}],[\"可定义方向数组来进行遍历\",{\"1\":{\"48\":1}}],[\"可惜的是\",{\"1\":{\"36\":1}}],[\"可以感知集群实例注册表的实现类\",{\"1\":{\"717\":1}}],[\"可以得出结论\",{\"1\":{\"707\":1}}],[\"可以参考之前我写的文章\",{\"1\":{\"702\":1}}],[\"可以看到改了后的值\",{\"1\":{\"702\":1}}],[\"可以向脚本传递参数\",{\"1\":{\"692\":1}}],[\"可以取变量\",{\"1\":{\"690\":1}}],[\"可以换成其它任意字符串\",{\"1\":{\"683\":1}}],[\"可以多个线程共同使用一个\",{\"1\":{\"673\":1}}],[\"可以丢失任意\",{\"1\":{\"668\":1}}],[\"可以自定义修改\",{\"1\":{\"660\":1}}],[\"可以删除变量\",{\"1\":{\"688\":1}}],[\"可以删除元素\",{\"1\":{\"647\":1}}],[\"可以删掉\",{\"1\":{\"227\":1}}],[\"可以动态创建和使用对象\",{\"1\":{\"629\":1}}],[\"可以直接通过浏览器登录系统\",{\"1\":{\"668\":1}}],[\"可以直接输出\",{\"1\":{\"579\":1}}],[\"可以直接跳到当前循环体的结尾\",{\"1\":{\"566\":1}}],[\"可以直接引用因子机预定义的因子\",{\"1\":{\"273\":1}}],[\"可以提前从循环中退出\",{\"1\":{\"565\":1}}],[\"可以定义多个变量\",{\"1\":{\"563\":1}}],[\"可以为空\",{\"1\":{\"563\":2}}],[\"可以为此账号指定相对根目录\",{\"1\":{\"357\":1}}],[\"可以简单理解为循环版的\",{\"1\":{\"561\":1}}],[\"可以简写为\",{\"1\":{\"552\":5}}],[\"可以控制在小于等于\",{\"1\":{\"545\":1}}],[\"可以存储多个\",{\"1\":{\"545\":1}}],[\"可以引入另外一种数据结构\",{\"1\":{\"545\":1}}],[\"可以选择平衡二叉树或者是红黑树来解决上述问题\",{\"1\":{\"545\":1}}],[\"可以是声明语句\",{\"1\":{\"563\":1}}],[\"可以是多列\",{\"1\":{\"537\":1}}],[\"可以是多行\",{\"1\":{\"536\":1}}],[\"可以是一个区间\",{\"1\":{\"76\":2}}],[\"可以\",{\"1\":{\"520\":1}}],[\"可以查看指定表的字段\",{\"1\":{\"508\":1}}],[\"可以加上参数\",{\"1\":{\"502\":1}}],[\"可以有两种形式\",{\"1\":{\"493\":1}}],[\"可以逆过来进行\",{\"1\":{\"378\":1}}],[\"可以像操作本地磁盘一样操作网盘了\",{\"1\":{\"358\":1}}],[\"可以借此实现跨平台的文件共享与同步\",{\"1\":{\"356\":1}}],[\"可以通过查看\",{\"1\":{\"354\":1}}],[\"可以通过二次点击支持\",{\"1\":{\"289\":1}}],[\"可以进行修改\",{\"1\":{\"352\":1}}],[\"可以指定用户使用的存储策略和可用的最大容量\",{\"1\":{\"352\":1}}],[\"可以将变量变为只读\",{\"1\":{\"687\":1}}],[\"可以将\",{\"1\":{\"598\":1}}],[\"可以将这张大表拆分成两张小表\",{\"1\":{\"525\":1}}],[\"可以将文件存储在第三方\",{\"1\":{\"352\":1}}],[\"可以将模板\",{\"1\":{\"142\":1}}],[\"可以说\",{\"1\":{\"351\":1}}],[\"可以说是一个写多读少的场景\",{\"1\":{\"273\":1}}],[\"可以从多种设备和应用上访问等等\",{\"1\":{\"351\":1}}],[\"可以创建外链分享文件以及目录\",{\"1\":{\"351\":1}}],[\"可以分布式部署\",{\"1\":{\"351\":1}}],[\"可以给第三方调用\",{\"1\":{\"350\":1}}],[\"可以搜索在线布隆过滤器容量计算\",{\"1\":{\"334\":1}}],[\"可以设置\",{\"1\":{\"334\":1}}],[\"可以考虑分片存储来解决\",{\"1\":{\"334\":1}}],[\"可以考虑再添加一层\",{\"1\":{\"334\":1}}],[\"可以解决跨域问题\",{\"1\":{\"329\":1}}],[\"可以去\",{\"1\":{\"303\":1}}],[\"可以做到\",{\"1\":{\"291\":1}}],[\"可以先写入\",{\"1\":{\"289\":1}}],[\"可以按照\",{\"1\":{\"282\":1}}],[\"可以认为是物理上的一个小队列\",{\"1\":{\"282\":1}}],[\"可以接入各种业务形态\",{\"1\":{\"278\":1}}],[\"可以倾诉自己的故事\",{\"1\":{\"274\":1}}],[\"可以炫一下自己的装扮\",{\"1\":{\"274\":1}}],[\"可以保留一套通用的底层排序算法\",{\"1\":{\"273\":1}}],[\"可以视具体场景要求降级至下一级缓存\",{\"1\":{\"267\":1}}],[\"可以减少热点场景下的sql执行条数\",{\"1\":{\"266\":1}}],[\"可以不加大括号\",{\"1\":{\"563\":1}}],[\"可以不指定排序方式asc\",{\"1\":{\"521\":1}}],[\"可以不对回复做更新操作\",{\"1\":{\"263\":1}}],[\"可以不需要考虑重边\",{\"1\":{\"173\":1}}],[\"可以在类的所有成员函数中调用\",{\"1\":{\"588\":1}}],[\"可以在创建表\",{\"1\":{\"506\":1}}],[\"可以在网页端上传和下载文件\",{\"1\":{\"350\":1}}],[\"可以在里面自己写\",{\"1\":{\"322\":1}}],[\"可以在进程内吞掉大量的读请求\",{\"1\":{\"294\":1}}],[\"可以在\",{\"1\":{\"293\":1,\"680\":1}}],[\"可以在第三个参数传入定义大小比较的函数\",{\"1\":{\"243\":1}}],[\"可以在区间\",{\"1\":{\"144\":2}}],[\"可以执行的合法行动与轮到哪名玩家无关\",{\"1\":{\"215\":1}}],[\"可以用于解决\",{\"1\":{\"334\":1}}],[\"可以用费马小定理求逆元\",{\"1\":{\"208\":1}}],[\"可以用结构体存储点和边\",{\"1\":{\"174\":1}}],[\"可以缩小问题规模而保持最大公约数不变\",{\"1\":{\"197\":1}}],[\"可以对其进行优化\",{\"1\":{\"188\":1}}],[\"可以生成最小生成树\",{\"1\":{\"181\":1}}],[\"可以任选\",{\"1\":{\"137\":1}}],[\"可以表示为\",{\"1\":{\"158\":1}}],[\"可以表示为带分数的形式\",{\"1\":{\"111\":1}}],[\"可以表示成若干个正整数之和\",{\"1\":{\"128\":1}}],[\"可以摧毁一个包含\",{\"1\":{\"83\":1}}],[\"可以使用各种公有云提供的\",{\"1\":{\"667\":1}}],[\"可以使用stringbuilder和stringbuffer\",{\"1\":{\"580\":1}}],[\"可以使用\",{\"1\":{\"63\":1,\"291\":1,\"334\":1,\"500\":1,\"514\":1,\"593\":1,\"668\":1}}],[\"可以返回\",{\"1\":{\"63\":1}}],[\"可以把\",{\"1\":{\"44\":1,\"99\":1}}],[\"可以大大加快路径的搜索速度\",{\"1\":{\"34\":1}}],[\"可以称之为父节点\",{\"1\":{\"32\":1}}],[\"可以理解为传输的配置\",{\"1\":{\"714\":1}}],[\"可以理解为一个\",{\"1\":{\"710\":1}}],[\"可以理解为\",{\"1\":{\"14\":1,\"111\":1}}],[\"完美满足了我所需要的功能\",{\"1\":{\"351\":1}}],[\"完美匹配\",{\"1\":{\"183\":1}}],[\"完成文件夹\",{\"1\":{\"668\":1}}],[\"完成\",{\"1\":{\"358\":1}}],[\"完成热评排序系统的平台化\",{\"1\":{\"273\":1}}],[\"完成各个特征的差异化实现与维护\",{\"1\":{\"273\":1}}],[\"完成一次用户交互\",{\"1\":{\"261\":1}}],[\"完全\",{\"1\":{\"237\":1}}],[\"完全背包\",{\"0\":{\"117\":1}}],[\"完全等于节点\",{\"1\":{\"36\":1}}],[\"完整代码如下\",{\"1\":{\"323\":1}}],[\"完整\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1}}],[\"完整的\",{\"1\":{\"35\":1,\"57\":1}}],[\"始终小于等于节点\",{\"1\":{\"36\":1}}],[\"始终为0\",{\"1\":{\"36\":1}}],[\"此异常由\",{\"1\":{\"618\":1}}],[\"此类异常是程序的致命异常\",{\"1\":{\"615\":1}}],[\"此类查询需求\",{\"1\":{\"259\":1}}],[\"此账号只能通过\",{\"1\":{\"357\":1}}],[\"此密码只会在首次启动时出现\",{\"1\":{\"352\":1}}],[\"此处无须显示的return语句\",{\"1\":{\"593\":1}}],[\"此处有bug\",{\"1\":{\"310\":1}}],[\"此处存放自己写和一些优秀的开源项目\",{\"1\":{\"18\":1}}],[\"此处存放前后端常用框架的笔记\",{\"1\":{\"17\":1}}],[\"此处存放一些程序员相关的资源文件\",{\"1\":{\"19\":1}}],[\"此处存放一些计算机大类的笔记\",{\"1\":{\"7\":1}}],[\"此处存放一些关于\",{\"1\":{\"6\":1}}],[\"此处存放刷题时的思路和笔记\",{\"1\":{\"1\":1}}],[\"此外\",{\"1\":{\"264\":1,\"266\":1,\"267\":1,\"273\":3,\"442\":1}}],[\"此时\",{\"1\":{\"584\":1,\"590\":1}}],[\"此时在数据量大的情况下\",{\"1\":{\"545\":1}}],[\"此时就会形成一个单向链表\",{\"1\":{\"545\":1}}],[\"此时只能够使用别名来指定字段\",{\"1\":{\"531\":1}}],[\"此时出于提高查询效率的考虑\",{\"1\":{\"525\":1}}],[\"此时父节点相当于当前节点\",{\"1\":{\"384\":1}}],[\"此时可以在浏览器中访问\",{\"1\":{\"352\":1}}],[\"此时可以利用\",{\"1\":{\"264\":1}}],[\"此时需要读取全部评论的全部特征\",{\"1\":{\"273\":1}}],[\"此时计数可能偏大\",{\"1\":{\"270\":1}}],[\"此时计数可能偏大或偏小\",{\"1\":{\"270\":1}}],[\"此时a事务计数更新的前提被破坏\",{\"1\":{\"270\":1}}],[\"此时告知用户操作失败也没有意义\",{\"1\":{\"270\":1}}],[\"此时也可能出现写放大\",{\"1\":{\"263\":1}}],[\"此时所有数据已准备好\",{\"1\":{\"261\":1}}],[\"此时为了防止死循环\",{\"1\":{\"142\":1}}],[\"此时算法就退化成了\",{\"1\":{\"36\":1}}],[\"42\",{\"1\":{\"585\":1}}],[\"4294967295\",{\"1\":{\"507\":1}}],[\"45\",{\"1\":{\"578\":1}}],[\"456d\",{\"1\":{\"555\":1}}],[\"456\",{\"1\":{\"346\":12}}],[\"48\",{\"1\":{\"577\":1}}],[\"4bytes\",{\"1\":{\"507\":2}}],[\"437\",{\"1\":{\"478\":1}}],[\"400\",{\"1\":{\"557\":1,\"558\":1}}],[\"402823466351\",{\"1\":{\"507\":1}}],[\"402823466\",{\"1\":{\"507\":2}}],[\"40x\",{\"1\":{\"354\":1}}],[\"404\",{\"1\":{\"354\":2,\"735\":1}}],[\"406920470238773354\",{\"1\":{\"274\":1}}],[\"443\",{\"1\":{\"354\":2}}],[\"4\",{\"0\":{\"36\":1,\"65\":1,\"102\":1,\"119\":1,\"124\":1,\"128\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":2,\"155\":1,\"170\":1,\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":2,\"176\":1,\"177\":1,\"178\":1,\"201\":1,\"210\":1,\"217\":1,\"231\":1,\"250\":1,\"260\":1,\"263\":1,\"264\":1,\"301\":1,\"302\":1,\"303\":1,\"311\":1,\"502\":1,\"510\":1,\"515\":1,\"516\":1,\"517\":1,\"518\":1,\"519\":2,\"520\":1,\"521\":1,\"522\":1,\"533\":1,\"534\":1,\"535\":1,\"536\":1,\"537\":2,\"538\":1,\"554\":1,\"564\":1,\"565\":1,\"566\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":1,\"574\":1,\"575\":1,\"580\":1,\"586\":1,\"595\":1,\"602\":1,\"607\":1,\"612\":1,\"618\":1,\"688\":1,\"694\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":2,\"708\":1,\"716\":1,\"717\":1,\"722\":1},\"1\":{\"41\":1,\"43\":1,\"44\":12,\"48\":5,\"49\":3,\"55\":3,\"56\":3,\"57\":3,\"76\":1,\"77\":2,\"81\":1,\"82\":2,\"93\":2,\"94\":4,\"98\":3,\"99\":12,\"109\":6,\"121\":3,\"124\":1,\"147\":1,\"148\":1,\"158\":7,\"174\":1,\"175\":1,\"191\":1,\"223\":1,\"237\":2,\"243\":1,\"255\":2,\"263\":2,\"266\":1,\"272\":1,\"273\":1,\"274\":1,\"309\":1,\"310\":3,\"323\":3,\"444\":1,\"467\":1,\"469\":1,\"495\":1,\"507\":3,\"551\":3,\"553\":1,\"555\":2,\"557\":2,\"558\":1,\"559\":1,\"563\":1,\"573\":4,\"574\":1,\"588\":1,\"591\":1,\"593\":1,\"595\":2,\"602\":1,\"625\":1,\"626\":1,\"628\":2,\"692\":2,\"708\":1,\"715\":1}}],[\"设从根到\",{\"1\":{\"480\":1}}],[\"设从x出发共有k条有向边\",{\"1\":{\"218\":1}}],[\"设前序遍历中根节点的索引为\",{\"1\":{\"419\":1}}],[\"设计递归函数\",{\"1\":{\"480\":1}}],[\"设计\",{\"1\":{\"294\":1,\"298\":1}}],[\"设计的api需要体现清晰的系统边界\",{\"1\":{\"258\":1}}],[\"设计一套基于视图模型的api\",{\"1\":{\"258\":1}}],[\"设计模式\",{\"0\":{\"13\":1}}],[\"设g1\",{\"1\":{\"219\":1}}],[\"设s表示一个非负整数集合\",{\"1\":{\"217\":1}}],[\"设\",{\"1\":{\"158\":1}}],[\"设置了默认值\",{\"1\":{\"706\":1}}],[\"设置该存储桶里面的文件的访问策略\",{\"1\":{\"675\":1}}],[\"设置别名\",{\"1\":{\"517\":1}}],[\"设置开机启动\",{\"1\":{\"353\":1}}],[\"设置开机自动启动\",{\"1\":{\"353\":1}}],[\"设置\",{\"1\":{\"310\":1,\"312\":1}}],[\"设置一些值\",{\"1\":{\"310\":1}}],[\"设置不同的降级处理\",{\"1\":{\"258\":1}}],[\"设置两个头尾指针\",{\"1\":{\"137\":1}}],[\"设置节点\",{\"1\":{\"35\":1}}],[\"mnt\",{\"1\":{\"660\":3,\"661\":1}}],[\"mn​\",{\"1\":{\"204\":1}}],[\"m为原串长度\",{\"1\":{\"642\":2}}],[\"mm\",{\"1\":{\"507\":6}}],[\"m=\",{\"1\":{\"334\":1}}],[\"m==0\",{\"1\":{\"208\":1}}],[\"md5digestashex\",{\"1\":{\"310\":1,\"323\":1}}],[\"mvnrepository\",{\"1\":{\"303\":1,\"323\":1}}],[\"myfile2\",{\"1\":{\"675\":2}}],[\"myfile目录是否存在\",{\"1\":{\"675\":1}}],[\"myfile\",{\"1\":{\"675\":1,\"676\":7}}],[\"my\",{\"1\":{\"500\":1,\"578\":3,\"628\":1}}],[\"myapp\",{\"1\":{\"302\":1}}],[\"mybatisx\",{\"1\":{\"322\":1}}],[\"mybatis\",{\"1\":{\"300\":3,\"303\":1,\"310\":2,\"322\":2}}],[\"mysql中有两种方式进行事务的操作\",{\"1\":{\"541\":1}}],[\"mysql中的数据类型主要分为三类\",{\"1\":{\"507\":1}}],[\"mysql数据库为解决id问题\",{\"1\":{\"506\":1}}],[\"mysql特有\",{\"1\":{\"495\":1}}],[\"mysql服务器启动完毕后\",{\"1\":{\"493\":1}}],[\"mysqld\",{\"1\":{\"353\":1}}],[\"mysql\",{\"0\":{\"491\":1,\"746\":1},\"1\":{\"273\":1,\"279\":2,\"282\":2,\"283\":3,\"289\":1,\"291\":1,\"293\":8,\"300\":1,\"493\":3,\"495\":1,\"522\":1,\"541\":1,\"545\":3},\"2\":{\"547\":1}}],[\"m匹配串长度\",{\"1\":{\"231\":1}}],[\"m个1\",{\"1\":{\"212\":1}}],[\"m2\",{\"1\":{\"204\":4}}],[\"m2​\",{\"1\":{\"204\":1}}],[\"m1\",{\"1\":{\"204\":7}}],[\"m1​\",{\"1\":{\"204\":1}}],[\"m是边数\",{\"1\":{\"181\":1}}],[\"mlogm\",{\"1\":{\"181\":1}}],[\"mlogn\",{\"1\":{\"171\":1,\"173\":1}}],[\"m表示边数\",{\"1\":{\"174\":1,\"180\":1,\"182\":1}}],[\"m代表边数\",{\"1\":{\"165\":1}}],[\"multimap\",{\"1\":{\"242\":3}}],[\"multiset\",{\"1\":{\"242\":3}}],[\"mul\",{\"1\":{\"149\":2,\"210\":2}}],[\"m​\",{\"1\":{\"125\":1}}],[\"m⩽100\",{\"1\":{\"98\":1}}],[\"m行\",{\"1\":{\"93\":1}}],[\"mx\",{\"1\":{\"70\":3,\"124\":4}}],[\"mechanism\",{\"1\":{\"706\":1}}],[\"method\",{\"1\":{\"628\":5,\"676\":2}}],[\"metadata\",{\"1\":{\"624\":1}}],[\"meta\",{\"1\":{\"263\":1}}],[\"mediumtext\",{\"1\":{\"507\":1}}],[\"mediumblob\",{\"1\":{\"507\":1}}],[\"mediumint\",{\"1\":{\"507\":1}}],[\"merge\",{\"1\":{\"138\":3,\"162\":1,\"251\":2,\"481\":2}}],[\"member\",{\"1\":{\"264\":2,\"291\":1}}],[\"memcpy\",{\"1\":{\"111\":1}}],[\"memset\",{\"1\":{\"43\":3,\"98\":1,\"131\":1,\"132\":1,\"165\":1,\"172\":2,\"173\":1,\"174\":1,\"175\":1,\"180\":2,\"182\":1,\"183\":1}}],[\"mex运算\",{\"0\":{\"217\":1}}],[\"mex\",{\"1\":{\"70\":2,\"217\":1,\"218\":1}}],[\"mex函数\",{\"0\":{\"70\":1}}],[\"move\",{\"1\":{\"604\":1,\"606\":2,\"607\":2}}],[\"movq\",{\"1\":{\"66\":1}}],[\"money\",{\"1\":{\"578\":3}}],[\"monday\",{\"1\":{\"559\":1}}],[\"mode=\",{\"1\":{\"663\":1}}],[\"model\",{\"1\":{\"311\":1}}],[\"modify\",{\"1\":{\"509\":1}}],[\"modm\",{\"1\":{\"208\":1}}],[\"modp\",{\"1\":{\"208\":1,\"209\":1}}],[\"modai​\",{\"1\":{\"204\":1}}],[\"mod\",{\"1\":{\"67\":5,\"81\":2,\"128\":4,\"196\":3,\"201\":1,\"204\":2,\"207\":1,\"208\":5,\"209\":1,\"241\":1}}],[\"mp\",{\"1\":{\"48\":5,\"49\":5,\"50\":5,\"55\":6,\"56\":6,\"57\":7,\"420\":3}}],[\"may\",{\"1\":{\"706\":1}}],[\"manipulation\",{\"1\":{\"496\":1,\"511\":1}}],[\"manhattandistance\",{\"1\":{\"36\":1}}],[\"math\",{\"0\":{\"653\":1},\"1\":{\"401\":1,\"414\":2,\"451\":2,\"469\":2,\"488\":2,\"653\":14}}],[\"matcher\",{\"1\":{\"310\":4,\"323\":4}}],[\"match\",{\"0\":{\"742\":1},\"1\":{\"183\":4,\"310\":1}}],[\"macos\",{\"1\":{\"347\":1}}],[\"markdown\",{\"1\":{\"340\":1}}],[\"masking\",{\"1\":{\"309\":1}}],[\"maven\",{\"1\":{\"303\":1}}],[\"makebucketargs\",{\"1\":{\"675\":1}}],[\"makebucket\",{\"1\":{\"675\":2}}],[\"make\",{\"1\":{\"77\":1}}],[\"malloc\",{\"1\":{\"66\":1}}],[\"maxheap\",{\"1\":{\"651\":1}}],[\"maxslidingwindow\",{\"1\":{\"456\":1}}],[\"maxdepth\",{\"1\":{\"401\":3,\"402\":1}}],[\"maxvalue\",{\"1\":{\"76\":2}}],[\"maxpos\",{\"1\":{\"76\":2}}],[\"maximum\",{\"1\":{\"72\":1}}],[\"max\",{\"0\":{\"76\":1},\"1\":{\"50\":1,\"63\":2,\"64\":1,\"76\":6,\"83\":1,\"116\":2,\"117\":2,\"118\":4,\"119\":2,\"121\":3,\"122\":4,\"123\":4,\"124\":3,\"134\":2,\"160\":1,\"162\":1,\"192\":1,\"197\":1,\"243\":1,\"250\":1,\"251\":1,\"354\":1,\"401\":1,\"414\":2,\"451\":2,\"468\":1,\"469\":2,\"486\":3,\"488\":4,\"519\":2,\"594\":2,\"595\":6,\"653\":1,\"654\":1,\"656\":8}}],[\"map中的对象类型\",{\"1\":{\"613\":1}}],[\"map存节点和对应的下标\",{\"1\":{\"420\":1}}],[\"mapper\",{\"1\":{\"322\":3}}],[\"map\",{\"0\":{\"613\":1,\"647\":1,\"732\":1},\"1\":{\"242\":3,\"313\":1,\"322\":1,\"419\":1,\"613\":1,\"647\":10,\"706\":1,\"708\":1}}],[\"map<character\",{\"1\":{\"647\":3}}],[\"map<characters\",{\"1\":{\"647\":1}}],[\"map<k\",{\"1\":{\"613\":1}}],[\"map<long\",{\"1\":{\"481\":1}}],[\"map<integer\",{\"1\":{\"420\":2}}],[\"map<int\",{\"1\":{\"189\":2,\"196\":1}}],[\"map<string\",{\"1\":{\"44\":2,\"99\":1}}],[\"map>\",{\"1\":{\"44\":1,\"99\":1,\"196\":1}}],[\"main\",{\"1\":{\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"66\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"165\":1,\"172\":1,\"180\":1,\"196\":1,\"204\":1,\"209\":1,\"212\":1,\"214\":1,\"231\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"551\":2,\"553\":6,\"554\":4,\"555\":4,\"557\":18,\"558\":4,\"559\":2,\"561\":8,\"562\":2,\"563\":8,\"565\":2,\"566\":2,\"567\":4,\"570\":2,\"571\":2,\"572\":8,\"573\":4,\"574\":2,\"577\":4,\"579\":2,\"584\":2,\"587\":2,\"588\":2,\"590\":2,\"591\":2,\"593\":2,\"594\":2,\"595\":2,\"596\":2,\"602\":2,\"607\":2,\"620\":2,\"621\":2,\"622\":2,\"628\":2,\"632\":4,\"634\":2,\"635\":4,\"636\":2,\"702\":1}}],[\"mirrors\",{\"1\":{\"659\":1}}],[\"miss\",{\"1\":{\"281\":3,\"291\":1,\"293\":1}}],[\"miller\",{\"1\":{\"274\":1}}],[\"mi​\",{\"1\":{\"204\":1}}],[\"mid\",{\"1\":{\"122\":4,\"138\":7,\"141\":9,\"142\":13,\"143\":5,\"145\":4,\"161\":4,\"438\":4}}],[\"middleware\",{\"0\":{\"751\":1},\"1\":{\"14\":1}}],[\"minutes\",{\"1\":{\"676\":1}}],[\"minheap\",{\"1\":{\"651\":1}}],[\"minioinfo\",{\"1\":{\"673\":6}}],[\"minio密码\",{\"1\":{\"673\":1}}],[\"minio用户名\",{\"1\":{\"673\":1}}],[\"minioclient\",{\"0\":{\"674\":1},\"1\":{\"673\":8,\"675\":6,\"676\":9}}],[\"minio<\",{\"1\":{\"672\":1}}],[\"minio官网\",{\"1\":{\"666\":1}}],[\"minioadmin\",{\"1\":{\"660\":1,\"662\":1,\"673\":2}}],[\"minio\",{\"0\":{\"659\":1,\"666\":1,\"671\":1},\"1\":{\"350\":2,\"659\":3,\"660\":24,\"661\":8,\"662\":10,\"663\":8,\"666\":2,\"667\":4,\"668\":22,\"673\":10,\"676\":3},\"2\":{\"665\":1,\"670\":1,\"678\":1}}],[\"minvalue\",{\"1\":{\"76\":2}}],[\"minpos\",{\"1\":{\"76\":2}}],[\"minx\",{\"1\":{\"56\":7,\"57\":6}}],[\"min\",{\"0\":{\"76\":1,\"750\":1},\"1\":{\"39\":1,\"41\":1,\"76\":5,\"83\":1,\"125\":3,\"126\":6,\"127\":2,\"132\":2,\"172\":4,\"174\":1,\"178\":1,\"180\":2,\"217\":1,\"248\":1,\"486\":2,\"487\":1,\"488\":3,\"519\":2,\"653\":1,\"654\":1,\"656\":8,\"662\":1,\"666\":1}}],[\"m\",{\"1\":{\"35\":6,\"43\":9,\"48\":5,\"49\":7,\"50\":5,\"55\":6,\"56\":4,\"57\":6,\"93\":4,\"94\":6,\"98\":9,\"109\":7,\"110\":3,\"116\":7,\"117\":7,\"118\":17,\"119\":9,\"123\":5,\"125\":8,\"126\":5,\"131\":9,\"132\":2,\"165\":1,\"166\":2,\"169\":1,\"171\":4,\"172\":5,\"173\":1,\"174\":4,\"175\":6,\"176\":1,\"180\":6,\"181\":5,\"182\":5,\"183\":3,\"208\":8,\"209\":4,\"212\":6,\"231\":8,\"243\":2,\"291\":1,\"334\":2,\"443\":4,\"444\":4,\"445\":10,\"451\":6,\"467\":1,\"469\":7,\"642\":4,\"653\":1}}],[\"将集群中的\",{\"1\":{\"722\":1}}],[\"将集群节点的\",{\"1\":{\"722\":1}}],[\"将集合的所有元素设置为\",{\"1\":{\"654\":1}}],[\"将配置文件中的配置项放到\",{\"1\":{\"707\":1}}],[\"将业务数据存储在云上\",{\"1\":{\"667\":1}}],[\"将元素添加到队尾\",{\"1\":{\"650\":1}}],[\"将元素添加到队首\",{\"1\":{\"650\":1}}],[\"将元素e放在index位置\",{\"1\":{\"645\":1}}],[\"将关联映射中的值改为新值\",{\"1\":{\"647\":1}}],[\"将char\",{\"1\":{\"642\":1}}],[\"将任意基本类型或引用类型转换为字符串\",{\"1\":{\"642\":1}}],[\"将线程设置为守护线程\",{\"1\":{\"633\":1}}],[\"将此\",{\"1\":{\"619\":1}}],[\"将实参的引用\",{\"1\":{\"591\":1}}],[\"将实参的初始值拷贝给形参\",{\"1\":{\"590\":1}}],[\"将多维数组转化为字符串\",{\"1\":{\"575\":1}}],[\"将数组列表的存储容量削减到其当前大小\",{\"1\":{\"645\":1}}],[\"将数组转化为字符串\",{\"1\":{\"575\":1}}],[\"将数字\",{\"1\":{\"101\":1}}],[\"将第i个元素设置为val\",{\"1\":{\"609\":1}}],[\"将第一行全部变成0\",{\"1\":{\"573\":1}}],[\"将第k位变成v\",{\"1\":{\"242\":1}}],[\"将得到\",{\"1\":{\"552\":5}}],[\"将大表中的一些基础字段放在一张表当中\",{\"1\":{\"525\":1}}],[\"将一列数据作为一个整体\",{\"1\":{\"519\":1}}],[\"将一个对象拆分成\",{\"1\":{\"668\":1}}],[\"将一个容器中重复的元素删除\",{\"1\":{\"242\":1}}],[\"将一个新的节点x插入下标是k的后面\",{\"1\":{\"223\":1}}],[\"将一个数的各二进制位全部右移若干位\",{\"1\":{\"158\":1}}],[\"将一个运算对象的各二进制位全部左移若干位\",{\"1\":{\"158\":1}}],[\"将一个\",{\"1\":{\"65\":1}}],[\"将该字符串对应的系统变量转换为integer\",{\"1\":{\"642\":1}}],[\"将该字段值置为\",{\"1\":{\"514\":1}}],[\"将该行的第一个数变成\",{\"1\":{\"205\":1}}],[\"将会报错\",{\"1\":{\"502\":1}}],[\"将会有很多种排列方法\",{\"1\":{\"101\":1}}],[\"将初始的烂橘子入队\",{\"1\":{\"469\":1}}],[\"将bfs过程提取为单独的一个方法\",{\"1\":{\"469\":1}}],[\"将以\",{\"1\":{\"463\":1}}],[\"将每层的扩散情况都加入队列\",{\"1\":{\"468\":1}}],[\"将每层最后一个加入到结果中\",{\"1\":{\"390\":1}}],[\"将每次移动的最大值保存在\",{\"1\":{\"456\":1}}],[\"将遍历过的陆地淹没\",{\"1\":{\"443\":1}}],[\"将有序数组转换为二叉搜索树\",{\"0\":{\"435\":1},\"1\":{\"435\":1}}],[\"将最后访问到的节点加入到右视图中\",{\"1\":{\"390\":1}}],[\"将左子树的最右节点指向原来的右子树\",{\"1\":{\"377\":1}}],[\"将左子树插入到右子树的地方\",{\"1\":{\"377\":1}}],[\"将原来的右子树接到左子树的最右边节点\",{\"1\":{\"377\":1}}],[\"将原本的\",{\"1\":{\"346\":1}}],[\"将已知编码的byte\",{\"1\":{\"642\":1}}],[\"将已经注销的用户名放在这个\",{\"1\":{\"334\":1}}],[\"将已访问状态重置为未访问\",{\"1\":{\"55\":1}}],[\"将已访问标记为\",{\"1\":{\"55\":1}}],[\"将框架预生成的样式自己想要的样式\",{\"1\":{\"326\":1}}],[\"将用户数据插入到数据库\",{\"1\":{\"323\":1}}],[\"将密码进行混淆\",{\"1\":{\"323\":1}}],[\"将生成的代码拖到对应的包路径下之后\",{\"1\":{\"322\":1}}],[\"将评论区的所有操作\",{\"1\":{\"270\":1}}],[\"将单个评论区内的发评串行处理\",{\"1\":{\"261\":1}}],[\"将新的区间放入ans数组中\",{\"1\":{\"251\":1}}],[\"将指定线段区间完全覆盖\",{\"1\":{\"250\":1}}],[\"将当前字符添加到当前节点对应的子节点位置\",{\"1\":{\"426\":1}}],[\"将当前节点指向左子树\",{\"1\":{\"377\":1}}],[\"将当前元素加入到队尾\",{\"1\":{\"230\":1}}],[\"将当前元素加入队尾\",{\"1\":{\"230\":1}}],[\"将当前行的首位变成1\",{\"1\":{\"205\":1}}],[\"将下面代码粘贴到配置文件中\",{\"1\":{\"353\":1}}],[\"将下面所有行的当且列的值变成\",{\"1\":{\"205\":1}}],[\"将下标是k的点后面的点删掉\",{\"1\":{\"223\":1}}],[\"将头结点删除\",{\"1\":{\"223\":1}}],[\"将绝对值最大的行换到最顶端\",{\"1\":{\"205\":1}}],[\"将这\",{\"1\":{\"204\":1,\"572\":2}}],[\"将这一位相减后的结果压入c中\",{\"1\":{\"148\":1}}],[\"将其他的字段放在另外一张表当中\",{\"1\":{\"525\":1}}],[\"将其修改为当前操作时间\",{\"1\":{\"513\":1}}],[\"将其存到服务器上\",{\"1\":{\"309\":1}}],[\"将其转换\",{\"1\":{\"258\":1}}],[\"将其等价转换\",{\"1\":{\"204\":1}}],[\"将其赋值为海水\",{\"1\":{\"48\":1}}],[\"将连通块逐渐扩大\",{\"1\":{\"180\":1}}],[\"将所有的值添加到给定的集合中\",{\"1\":{\"654\":1}}],[\"将所有元素的初值为0\",{\"1\":{\"573\":1}}],[\"将所有点分成\",{\"1\":{\"182\":1}}],[\"将所有存在交集的区间合并\",{\"1\":{\"162\":1}}],[\"将所有值排序\",{\"1\":{\"161\":1}}],[\"将前导0置于尾部\",{\"1\":{\"150\":1}}],[\"将上次的余数×10再加上当前位的数字\",{\"1\":{\"150\":1}}],[\"将问题转变成统计数列中\",{\"1\":{\"144\":1}}],[\"将模板\",{\"1\":{\"142\":1}}],[\"将临时序列放入原序列中\",{\"1\":{\"138\":1}}],[\"将小的放入一个临时序列\",{\"1\":{\"138\":1}}],[\"将整个序列均分为两部分\",{\"1\":{\"138\":1}}],[\"将字符串转换为char\",{\"1\":{\"642\":1}}],[\"将字符串转换为boolean类型\",{\"1\":{\"642\":1}}],[\"将字符串转换为int类型\",{\"1\":{\"642\":1}}],[\"将字符串转化成字符数组\",{\"1\":{\"578\":1}}],[\"将字符串看成\",{\"1\":{\"241\":1}}],[\"将字符串\",{\"1\":{\"126\":2}}],[\"将a串变为b串\",{\"1\":{\"99\":1}}],[\"将标记数组重置为\",{\"1\":{\"55\":1}}],[\"将与之相邻的陆地都变成海水\",{\"1\":{\"49\":1}}],[\"将搜索过的mp\",{\"1\":{\"48\":1}}],[\"将走过的元素标记为\",{\"1\":{\"48\":1}}],[\"将\",{\"1\":{\"44\":1,\"50\":1,\"94\":1,\"99\":1,\"111\":2,\"126\":1,\"158\":2,\"201\":1,\"334\":2,\"346\":2,\"358\":1,\"513\":1,\"567\":1,\"635\":2,\"663\":1,\"673\":1,\"712\":1,\"715\":1}}],[\"将邻边入队\",{\"1\":{\"41\":1}}],[\"将节点加入到右视图中\",{\"1\":{\"389\":1}}],[\"将节点\",{\"1\":{\"35\":2}}],[\"将起点加入\",{\"1\":{\"35\":1}}],[\"不可嵌套\",{\"1\":{\"693\":1}}],[\"不可变字符串\",{\"1\":{\"641\":1}}],[\"不会取变量\",{\"1\":{\"690\":1}}],[\"不会执行\",{\"1\":{\"690\":1}}],[\"不会影响用户体验\",{\"1\":{\"261\":1}}],[\"不要死记硬背\",{\"1\":{\"680\":1}}],[\"不要做需求的翻译机\",{\"1\":{\"278\":1}}],[\"不建议把null添加到队列中\",{\"1\":{\"649\":1}}],[\"不仅有队列\",{\"1\":{\"648\":1}}],[\"不推荐\",{\"1\":{\"642\":1}}],[\"不添加修饰符\",{\"1\":{\"600\":1}}],[\"不在指定的集合范围之内\",{\"1\":{\"536\":1}}],[\"不适用与分布式\",{\"1\":{\"524\":1}}],[\"不参与分组\",{\"1\":{\"520\":1}}],[\"不满足\",{\"1\":{\"520\":1}}],[\"不满足条件\",{\"1\":{\"215\":1}}],[\"不等于\",{\"1\":{\"518\":1,\"557\":1}}],[\"不带任何的查询条件\",{\"1\":{\"517\":1}}],[\"不带任何条件\",{\"1\":{\"516\":1}}],[\"不超过255个字符的二进制数据\",{\"1\":{\"507\":1}}],[\"不得不通过遍历子树的方式来获知\",{\"1\":{\"365\":1}}],[\"不禁有点害怕\",{\"1\":{\"350\":1}}],[\"不受\",{\"1\":{\"346\":1}}],[\"不然要被请去喝茶了\",{\"1\":{\"343\":1}}],[\"不然大概率会超时\",{\"1\":{\"90\":1}}],[\"不小于\",{\"1\":{\"323\":2}}],[\"不利于后续维护和拓展\",{\"1\":{\"315\":1}}],[\"不涉及业务逻辑本身\",{\"1\":{\"311\":1}}],[\"不涉及利用\",{\"1\":{\"54\":1}}],[\"不影响后续开发\",{\"1\":{\"302\":1}}],[\"不为\",{\"1\":{\"289\":1}}],[\"不为空\",{\"1\":{\"35\":1,\"175\":1}}],[\"不管其是存放的数据块还是奇偶校验块\",{\"1\":{\"668\":1}}],[\"不管条件的值如何\",{\"1\":{\"562\":1}}],[\"不管是氛围还是商业\",{\"1\":{\"274\":1}}],[\"不管热评的算法如何变化\",{\"1\":{\"273\":1}}],[\"不容易出错\",{\"1\":{\"270\":1}}],[\"不值得用户重试\",{\"1\":{\"270\":1}}],[\"不对用户暴露用户无法处理和不值得处理的错误\",{\"1\":{\"270\":1}}],[\"不支持\",{\"1\":{\"242\":1,\"358\":1}}],[\"不能中断任何线程\",{\"1\":{\"633\":1}}],[\"不能写入\",{\"1\":{\"578\":1}}],[\"不能修改\",{\"1\":{\"578\":1}}],[\"不能被100整除时\",{\"1\":{\"557\":1}}],[\"不能被其他普通运营人员\",{\"1\":{\"269\":1}}],[\"不能重名\",{\"1\":{\"551\":1}}],[\"不能对聚合函数进行判断\",{\"1\":{\"520\":1}}],[\"不能创建两个名称相同的数据库\",{\"1\":{\"500\":1}}],[\"不能实现外部的访问\",{\"1\":{\"350\":1}}],[\"不能行动的玩家判负\",{\"1\":{\"215\":1}}],[\"不能开到\",{\"1\":{\"83\":1}}],[\"不存在则返回null\",{\"1\":{\"612\":2,\"613\":2}}],[\"不存在\",{\"1\":{\"204\":1}}],[\"不一定是\",{\"1\":{\"182\":1}}],[\"不包括自己\",{\"1\":{\"176\":1}}],[\"不包含前导零\",{\"1\":{\"129\":1}}],[\"不包含\",{\"1\":{\"111\":1}}],[\"不需要加\",{\"1\":{\"685\":1}}],[\"不需要创建\",{\"1\":{\"675\":1}}],[\"不需要从根节点开始\",{\"1\":{\"479\":1}}],[\"不需要再搜了\",{\"1\":{\"445\":1}}],[\"不需要再跟别的前缀和组合\",{\"1\":{\"81\":1}}],[\"不需要\",{\"1\":{\"320\":1}}],[\"不需要初始化dist数组\",{\"1\":{\"176\":1}}],[\"不需要借位\",{\"1\":{\"148\":1}}],[\"不用引号\",{\"1\":{\"690\":1}}],[\"不用真实地打开浏览器就能测试\",{\"1\":{\"302\":1}}],[\"不用自己整合各种框架\",{\"1\":{\"300\":1}}],[\"不用自己管理\",{\"1\":{\"300\":1}}],[\"不用写\",{\"1\":{\"300\":1}}],[\"不用全部遍历\",{\"1\":{\"147\":1,\"148\":1}}],[\"不用判重\",{\"1\":{\"41\":1}}],[\"不含前导0\",{\"1\":{\"147\":1,\"148\":1,\"149\":1,\"150\":1}}],[\"不重复的\",{\"1\":{\"506\":1}}],[\"不重复不遗漏地组成带分数表示的全部种数\",{\"1\":{\"111\":1}}],[\"不重不漏地经过每个点恰好一次\",{\"1\":{\"132\":1}}],[\"不连续\",{\"0\":{\"123\":1}}],[\"不妨称为\",{\"1\":{\"94\":1}}],[\"不断二分递归建立左子树和右子树\",{\"1\":{\"437\":1}}],[\"不断向上寻找最初的根节点\",{\"1\":{\"93\":1}}],[\"不断往上查找祖先\",{\"1\":{\"90\":1}}],[\"不同的数据库有不同的实现\",{\"1\":{\"522\":1}}],[\"不同的是它是⽤\",{\"1\":{\"49\":1}}],[\"不同规则的决策叠加作用\",{\"1\":{\"273\":1}}],[\"不同\",{\"1\":{\"258\":1,\"668\":1}}],[\"不同颜色\",{\"1\":{\"182\":1}}],[\"不同为\",{\"1\":{\"158\":1}}],[\"不同为1\",{\"1\":{\"157\":1}}],[\"不同位置的数字一样的数对算不同的数对\",{\"1\":{\"144\":1}}],[\"不同方案\",{\"1\":{\"107\":1}}],[\"不同目标可能在同一位置\",{\"1\":{\"83\":1}}],[\"不是树结构最下面的节点\",{\"1\":{\"545\":1}}],[\"不是\",{\"1\":{\"193\":1,\"200\":1,\"208\":1,\"449\":1,\"518\":1}}],[\"不是起点\",{\"1\":{\"180\":1}}],[\"不是一定\",{\"1\":{\"174\":1}}],[\"不是c语言的内置数据类型\",{\"1\":{\"63\":1}}],[\"不是终点\",{\"1\":{\"35\":1}}],[\"不过都被注释了\",{\"1\":{\"706\":1}}],[\"不过存储空间是映射的本地\",{\"1\":{\"358\":1}}],[\"不过如果注销用户名多了\",{\"1\":{\"334\":1}}],[\"不过要先进行管理员校验\",{\"1\":{\"313\":1}}],[\"不过有可能点击\",{\"1\":{\"311\":1}}],[\"不过\",{\"1\":{\"124\":1}}],[\"不过具体问题还得具体分析\",{\"1\":{\"54\":1}}],[\"不过此时会很快\",{\"1\":{\"36\":1}}],[\"从相邻节点拷贝注册信息\",{\"0\":{\"724\":1}}],[\"从堆栈的顶部返回元素的位置\",{\"1\":{\"648\":1}}],[\"从休眠中中断线程\",{\"1\":{\"633\":1}}],[\"从程序语法角度讲是必须进行处理的异常\",{\"1\":{\"617\":1}}],[\"从第一个数中减去第二个数\",{\"1\":{\"552\":1}}],[\"从这个角度上来说\",{\"1\":{\"486\":1}}],[\"从初始的\",{\"1\":{\"468\":1}}],[\"从根节点到当前节点的路径上的前缀和为\",{\"1\":{\"480\":1}}],[\"从根节点依次开始匹配每个字符\",{\"1\":{\"426\":1}}],[\"从根节点出发到任一个节点都是一个前缀\",{\"1\":{\"425\":1}}],[\"从根节点开始构造这个word对应的路径节点\",{\"1\":{\"426\":1}}],[\"从根节点开始\",{\"1\":{\"382\":1}}],[\"从前序遍历数组的第一个元素开始\",{\"1\":{\"419\":1}}],[\"从前序与中序遍历序列构造二叉树\",{\"0\":{\"417\":1},\"1\":{\"417\":1}}],[\"从前面使用\",{\"1\":{\"353\":1}}],[\"从左到右访问所有节点\",{\"1\":{\"394\":1}}],[\"从机存储\",{\"1\":{\"352\":1}}],[\"从数据写入主线程中剥离\",{\"1\":{\"266\":1}}],[\"从db读取到内容之后反写缓存\",{\"1\":{\"261\":1}}],[\"从而提高系统的可靠性和容错能力\",{\"1\":{\"668\":1}}],[\"从而不断扩散直到没有新鲜橘子或者无法扩散\",{\"1\":{\"468\":1}}],[\"从而把基础能力和业务能力剥离\",{\"1\":{\"279\":1}}],[\"从而具备了水平扩容能力\",{\"1\":{\"263\":1}}],[\"从而更好地满足各类用户的需求\",{\"1\":{\"254\":1}}],[\"从而便于删除前导0\",{\"1\":{\"150\":1}}],[\"从大到小排序需要加入第三个参数\",{\"1\":{\"243\":1}}],[\"从大到小排序\",{\"1\":{\"243\":1}}],[\"从0开始\",{\"1\":{\"231\":1}}],[\"从00\",{\"1\":{\"129\":1}}],[\"从队头弹出一个数\",{\"1\":{\"229\":1}}],[\"从栈顶弹出一个数\",{\"1\":{\"226\":1}}],[\"从一个未匹配路出发\",{\"1\":{\"183\":1}}],[\"从一个未匹配点出发\",{\"1\":{\"183\":1}}],[\"从高位到低位运算\",{\"1\":{\"150\":1}}],[\"从小到大枚举n的所有约数对里面比较小的那一个\",{\"1\":{\"195\":1}}],[\"从小到大枚举所有的质数\",{\"1\":{\"191\":1}}],[\"从小到大判断\",{\"1\":{\"195\":1}}],[\"从小到大尝试\",{\"1\":{\"188\":1}}],[\"从小到大遍历\",{\"1\":{\"187\":1,\"193\":1}}],[\"从小到大依次枚举每组边\",{\"1\":{\"181\":1}}],[\"从小到大\",{\"1\":{\"147\":1,\"148\":1}}],[\"从头开始遍历\",{\"1\":{\"138\":1}}],[\"从1\",{\"1\":{\"129\":1}}],[\"从下往上遍历\",{\"1\":{\"121\":1}}],[\"从上往下遍历\",{\"1\":{\"121\":1}}],[\"从顶部出发\",{\"1\":{\"121\":1}}],[\"从start开始枚举剩下的可选数字\",{\"1\":{\"109\":1}}],[\"从该状态到达目标状态的估价函数\",{\"1\":{\"44\":1}}],[\"从各点到终点的最短路距离\",{\"1\":{\"43\":1}}],[\"从终点开始\",{\"1\":{\"43\":1}}],[\"从终点开始逐步追踪\",{\"1\":{\"35\":1}}],[\"从当前点到终点的估计距离\",{\"1\":{\"41\":1}}],[\"从起点到该状态的真实距离+该状态到目标状态的估价距离\",{\"1\":{\"44\":1}}],[\"从起点到当前点的真实距离\",{\"1\":{\"41\":1}}],[\"从起点开始\",{\"1\":{\"32\":1}}],[\"从\",{\"1\":{\"35\":1,\"49\":1,\"107\":1,\"109\":1,\"111\":1,\"191\":1,\"281\":1,\"362\":1,\"451\":1,\"506\":1}}],[\"0l\",{\"1\":{\"481\":1}}],[\"00<\",{\"1\":{\"663\":1}}],[\"00\",{\"1\":{\"507\":5,\"663\":1}}],[\"001\",{\"1\":{\"334\":3}}],[\"0001\",{\"1\":{\"158\":1,\"334\":1}}],[\"0000\",{\"1\":{\"158\":6}}],[\"0<\",{\"1\":{\"323\":1}}],[\"07\",{\"0\":{\"271\":1},\"1\":{\"507\":1}}],[\"06\",{\"0\":{\"268\":1}}],[\"05\",{\"0\":{\"265\":1}}],[\"04d\",{\"1\":{\"555\":1}}],[\"04\",{\"0\":{\"262\":1}}],[\"03\",{\"0\":{\"256\":1},\"1\":{\"507\":1}}],[\"02\",{\"0\":{\"255\":1}}],[\"0号点既是根节点\",{\"1\":{\"232\":1}}],[\"0和1都被占用了\",{\"1\":{\"224\":1}}],[\"0是左端点\",{\"1\":{\"224\":1}}],[\"0表示正常退出\",{\"1\":{\"693\":1}}],[\"0表示相等\",{\"1\":{\"578\":1}}],[\"0表示白色\",{\"1\":{\"182\":1}}],[\"0表示还没放数\",{\"1\":{\"108\":1}}],[\"0表示还没考虑\",{\"1\":{\"107\":1}}],[\"0变1\",{\"1\":{\"157\":1}}],[\"01\",{\"0\":{\"116\":1,\"254\":1},\"1\":{\"334\":1,\"507\":8}}],[\"0辆车\",{\"1\":{\"110\":1}}],[\"0只猫\",{\"1\":{\"110\":1}}],[\"0⩽m⩽n\",{\"1\":{\"109\":1}}],[\"0⩽r⩽1090<n⩽100000⩽xi​\",{\"1\":{\"83\":1}}],[\"0这种情况就要舍去\",{\"1\":{\"43\":1}}],[\"0x3f3f3f3f\",{\"1\":{\"172\":1,\"173\":1,\"174\":1,\"175\":1}}],[\"0x3f\",{\"1\":{\"43\":1,\"132\":1,\"172\":2,\"173\":1,\"174\":1,\"175\":1,\"180\":2}}],[\"0≤m≤104\",{\"1\":{\"43\":1}}],[\"0\",{\"1\":{\"35\":1,\"41\":1,\"43\":5,\"44\":14,\"48\":25,\"49\":22,\"50\":11,\"55\":15,\"56\":14,\"57\":17,\"62\":1,\"63\":1,\"64\":4,\"65\":3,\"66\":3,\"70\":1,\"71\":1,\"74\":1,\"75\":2,\"81\":7,\"82\":11,\"83\":4,\"93\":1,\"94\":1,\"98\":30,\"99\":10,\"101\":3,\"107\":5,\"108\":2,\"109\":2,\"110\":6,\"111\":5,\"116\":2,\"117\":2,\"118\":8,\"119\":9,\"121\":4,\"122\":11,\"123\":1,\"124\":2,\"125\":8,\"126\":5,\"127\":1,\"128\":7,\"129\":19,\"131\":13,\"132\":13,\"134\":16,\"138\":2,\"144\":4,\"147\":10,\"148\":19,\"149\":9,\"150\":9,\"158\":39,\"159\":4,\"160\":2,\"161\":1,\"165\":6,\"169\":3,\"172\":3,\"173\":2,\"174\":3,\"175\":1,\"178\":1,\"180\":3,\"181\":5,\"182\":2,\"183\":2,\"187\":1,\"188\":3,\"189\":3,\"192\":2,\"193\":4,\"195\":1,\"196\":2,\"199\":2,\"200\":4,\"201\":1,\"203\":1,\"204\":3,\"205\":5,\"207\":2,\"208\":3,\"209\":2,\"210\":8,\"212\":6,\"214\":3,\"223\":1,\"224\":2,\"226\":2,\"227\":1,\"229\":1,\"230\":2,\"231\":4,\"232\":6,\"234\":1,\"236\":1,\"240\":1,\"241\":1,\"247\":2,\"248\":1,\"249\":3,\"250\":4,\"251\":2,\"263\":2,\"274\":4,\"289\":4,\"310\":2,\"314\":1,\"315\":1,\"321\":9,\"322\":1,\"323\":2,\"334\":3,\"354\":2,\"363\":3,\"366\":1,\"389\":1,\"390\":2,\"396\":1,\"401\":1,\"402\":2,\"414\":2,\"419\":1,\"420\":9,\"426\":2,\"438\":1,\"442\":1,\"443\":11,\"444\":15,\"445\":8,\"449\":1,\"451\":7,\"456\":1,\"467\":1,\"468\":5,\"469\":28,\"473\":3,\"474\":6,\"475\":3,\"480\":1,\"481\":3,\"488\":2,\"493\":2,\"507\":17,\"522\":1,\"552\":1,\"557\":4,\"558\":3,\"561\":2,\"563\":3,\"565\":1,\"566\":1,\"567\":3,\"571\":1,\"572\":11,\"573\":6,\"574\":1,\"577\":1,\"578\":1,\"580\":1,\"585\":1,\"591\":1,\"593\":5,\"595\":2,\"620\":2,\"632\":3,\"634\":2,\"635\":4,\"636\":1,\"642\":1,\"647\":1,\"653\":1,\"666\":1,\"690\":1,\"695\":1,\"696\":1,\"715\":2,\"727\":1}}],[\"occurred\",{\"1\":{\"727\":1}}],[\"other\",{\"1\":{\"706\":1}}],[\"okay\",{\"1\":{\"706\":1}}],[\"oss\",{\"1\":{\"667\":3}}],[\"overload\",{\"1\":{\"625\":1}}],[\"override\",{\"1\":{\"310\":2,\"323\":1,\"625\":1,\"632\":3,\"634\":1,\"635\":2,\"636\":1,\"651\":1,\"702\":1,\"707\":1}}],[\"oldvalue\",{\"1\":{\"654\":1}}],[\"oldregex\",{\"1\":{\"578\":1}}],[\"oldchar\",{\"1\":{\"578\":1,\"642\":1}}],[\"oltp\",{\"1\":{\"283\":1}}],[\"ondemandupdate\",{\"1\":{\"715\":1}}],[\"onpath\",{\"1\":{\"474\":2,\"475\":5}}],[\"on\",{\"1\":{\"346\":1,\"354\":1,\"531\":1,\"532\":2,\"546\":2}}],[\"oneapi\",{\"1\":{\"302\":2}}],[\"owner\",{\"1\":{\"293\":1}}],[\"oom\",{\"1\":{\"281\":1}}],[\"of\",{\"1\":{\"280\":1,\"390\":1,\"396\":1}}],[\"off\",{\"1\":{\"354\":1}}],[\"offset\",{\"1\":{\"273\":2}}],[\"offerlast\",{\"1\":{\"650\":1}}],[\"offerfirst\",{\"1\":{\"650\":1}}],[\"offer\",{\"0\":{\"4\":1,\"736\":1},\"1\":{\"337\":1,\"390\":3,\"396\":3,\"444\":2,\"469\":2,\"649\":1,\"651\":1},\"2\":{\"22\":1}}],[\"or\",{\"1\":{\"518\":1,\"706\":1}}],[\"orangesrotting\",{\"1\":{\"469\":2}}],[\"originuser\",{\"1\":{\"310\":14}}],[\"org\",{\"1\":{\"274\":2,\"323\":1,\"353\":1,\"628\":3,\"636\":1,\"659\":1,\"660\":1,\"666\":1,\"668\":1}}],[\"order\",{\"1\":{\"263\":2,\"264\":1,\"273\":2,\"289\":2,\"516\":2,\"521\":1}}],[\"objectname\",{\"1\":{\"676\":1}}],[\"objectwriteresponse2\",{\"1\":{\"676\":1}}],[\"objectwriteresponse\",{\"1\":{\"676\":5}}],[\"object\",{\"0\":{\"676\":1},\"1\":{\"618\":1,\"628\":2,\"636\":14,\"667\":1,\"673\":3,\"676\":6}}],[\"obj\",{\"1\":{\"263\":6,\"289\":6}}],[\"o\",{\"1\":{\"144\":1,\"166\":1,\"169\":1,\"171\":5,\"172\":1,\"173\":1,\"174\":1,\"175\":2,\"176\":1,\"180\":1,\"181\":3,\"182\":1,\"183\":1,\"187\":1,\"188\":2,\"189\":3,\"191\":1,\"193\":1,\"197\":1,\"201\":1,\"205\":1,\"237\":1,\"242\":4,\"291\":2,\"376\":1,\"377\":2,\"628\":6,\"640\":1,\"642\":14,\"643\":4,\"645\":6,\"646\":4,\"647\":9,\"648\":6,\"649\":5,\"650\":6,\"651\":3,\"654\":1}}],[\"outofmemoryerror\",{\"1\":{\"615\":1}}],[\"outer\",{\"1\":{\"532\":2}}],[\"outputstreamwriter\",{\"1\":{\"555\":2}}],[\"output\",{\"1\":{\"69\":1,\"622\":1}}],[\"out\",{\"1\":{\"69\":1,\"230\":1,\"322\":1,\"553\":9,\"554\":1,\"555\":7,\"557\":30,\"558\":5,\"559\":1,\"561\":4,\"562\":2,\"563\":4,\"565\":2,\"566\":1,\"567\":3,\"572\":5,\"573\":2,\"574\":2,\"577\":5,\"578\":2,\"579\":2,\"580\":2,\"584\":1,\"587\":2,\"588\":3,\"590\":1,\"591\":2,\"593\":1,\"594\":1,\"595\":4,\"596\":1,\"602\":2,\"606\":3,\"607\":3,\"620\":3,\"621\":2,\"622\":2,\"628\":3,\"632\":3,\"634\":1,\"635\":2,\"636\":1,\"642\":2,\"675\":3,\"676\":6}}],[\"operating\",{\"0\":{\"753\":1}}],[\"operation\",{\"1\":{\"158\":1}}],[\"operate\",{\"1\":{\"647\":2}}],[\"operator\",{\"1\":{\"243\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1}}],[\"operator<\",{\"1\":{\"181\":1}}],[\"open\",{\"1\":{\"35\":9}}],[\"opt\",{\"1\":{\"75\":2,\"660\":4}}],[\"op\",{\"1\":{\"44\":2}}],[\"o→o→o→o→o→o→o\",{\"1\":{\"41\":1}}],[\"o→o→o\",{\"1\":{\"41\":1}}],[\"另一方面对工程侧的要求主要是\",{\"1\":{\"269\":1}}],[\"另一方面也通过超时控制\",{\"1\":{\"267\":1}}],[\"另一方面\",{\"1\":{\"261\":1,\"274\":1}}],[\"另一棵树的子树\",{\"0\":{\"23\":1},\"1\":{\"23\":1}}],[\"另外一个参数是\",{\"1\":{\"711\":1}}],[\"另外一种\",{\"1\":{\"420\":1}}],[\"另外也提供了常见的云存储供应商选项\",{\"1\":{\"352\":1}}],[\"另外还保存了一些计数字段\",{\"1\":{\"289\":1}}],[\"另外\",{\"1\":{\"35\":1,\"468\":1,\"648\":1}}],[\"优缺点\",{\"0\":{\"629\":1}}],[\"优点\",{\"1\":{\"544\":1,\"629\":1}}],[\"优先队列在添加元素的时候对元素的大小排序后再保存\",{\"1\":{\"651\":1}}],[\"优先队列\",{\"0\":{\"456\":1,\"651\":1},\"1\":{\"242\":1,\"611\":1},\"2\":{\"459\":1}}],[\"优先队列的队头\",{\"1\":{\"41\":1}}],[\"优先级最高\",{\"1\":{\"35\":2}}],[\"优化手段\",{\"1\":{\"497\":1}}],[\"优化产品功能及其技术实现\",{\"1\":{\"270\":1}}],[\"优化调用编排甚至技术方案重构等方式持续优化提升非核心功能的可用性\",{\"1\":{\"267\":1}}],[\"优化\",{\"0\":{\"26\":1}}],[\"即丢失一半数量的硬盘的情况下仍能保证数据的安全性\",{\"1\":{\"668\":1}}],[\"即输出到\",{\"1\":{\"660\":1}}],[\"即使你退出了终端或关闭了会话\",{\"1\":{\"660\":1}}],[\"即使两个形参的类型一样\",{\"1\":{\"586\":1}}],[\"即使用变形后的后序遍历\",{\"1\":{\"378\":1}}],[\"即执行一条\",{\"1\":{\"541\":1}}],[\"即这些操作要么同时成功\",{\"1\":{\"540\":1}}],[\"即这个迭代器是去重之后末尾元素的下一个位置\",{\"1\":{\"243\":1}}],[\"即自底向上计算子问题的过程\",{\"1\":{\"488\":1}}],[\"即路径节点\",{\"1\":{\"474\":1}}],[\"即最外层\",{\"1\":{\"468\":1}}],[\"即左子树最深节点和右子树最深节点的距离\",{\"1\":{\"413\":1}}],[\"即逐层地\",{\"1\":{\"394\":1}}],[\"即当前节点的父节点\",{\"1\":{\"384\":1}}],[\"即当前位置能填哪些数\",{\"1\":{\"108\":1}}],[\"即存储在安装\",{\"1\":{\"352\":1}}],[\"即每个窗口中\",{\"1\":{\"294\":1}}],[\"即便\",{\"1\":{\"289\":1}}],[\"即某个评论主题的数据都在一个分区里\",{\"1\":{\"282\":1}}],[\"即如果存储\",{\"1\":{\"282\":1}}],[\"即先通过策略工程\",{\"1\":{\"273\":1}}],[\"即reddit\",{\"1\":{\"273\":1}}],[\"即要实现\",{\"1\":{\"273\":1}}],[\"即+1\",{\"1\":{\"270\":1}}],[\"即是\",{\"1\":{\"261\":1}}],[\"即小根堆\",{\"1\":{\"237\":1}}],[\"即sg\",{\"1\":{\"218\":1}}],[\"即两人均无失误\",{\"1\":{\"214\":1}}],[\"即为\",{\"1\":{\"208\":1}}],[\"即用二进制来表示\",{\"1\":{\"201\":1}}],[\"即组合成\",{\"1\":{\"201\":1}}],[\"即找到了\",{\"1\":{\"193\":1}}],[\"即源码取反加\",{\"1\":{\"159\":1}}],[\"即除以\",{\"1\":{\"158\":1}}],[\"即乘上\",{\"1\":{\"158\":1}}],[\"即得\",{\"1\":{\"158\":1}}],[\"即t\",{\"1\":{\"148\":1}}],[\"即可启动\",{\"1\":{\"302\":1}}],[\"即可得到最终的花费时间\",{\"1\":{\"468\":1}}],[\"即可得到\",{\"1\":{\"158\":3}}],[\"即可\",{\"1\":{\"111\":1,\"143\":1,\"289\":1,\"311\":1,\"354\":2,\"514\":2,\"660\":1,\"673\":1}}],[\"即可计算出该正方形内所有目标的价值之和\",{\"1\":{\"83\":1}}],[\"即那个正方形的边必须和\",{\"1\":{\"83\":1}}],[\"即一个无符号整型类型\",{\"1\":{\"72\":1}}],[\"即将\",{\"1\":{\"57\":1}}],[\"即继续让j入队的话依然无解\",{\"1\":{\"43\":1}}],[\"即队列中存在比d\",{\"1\":{\"41\":1}}],[\"即\",{\"1\":{\"35\":1,\"63\":1,\"72\":2,\"81\":2,\"158\":3,\"159\":2,\"214\":2,\"217\":1,\"218\":1,\"219\":1,\"281\":1,\"289\":1,\"424\":1,\"451\":1,\"486\":1,\"545\":1,\"618\":1}}],[\"距离最近的点\",{\"1\":{\"180\":1}}],[\"距离都初始化为无穷大\",{\"1\":{\"172\":1}}],[\"距离终点的预计代价\",{\"1\":{\"35\":1}}],[\"距离起点的代价\",{\"1\":{\"35\":1}}],[\"hdfs\",{\"1\":{\"668\":1}}],[\"hup\",{\"1\":{\"660\":1}}],[\"hugegraph\",{\"1\":{\"289\":1}}],[\"hi\",{\"1\":{\"606\":1,\"607\":1,\"642\":2}}],[\"h数据库服务器的ip地址\",{\"1\":{\"493\":1}}],[\"hk\",{\"1\":{\"334\":1}}],[\"h2\",{\"1\":{\"334\":1}}],[\"h1\",{\"1\":{\"334\":1}}],[\"holder\",{\"1\":{\"721\":10}}],[\"home\",{\"1\":{\"680\":1}}],[\"hot100\",{\"0\":{\"745\":1},\"2\":{\"367\":1,\"373\":1,\"379\":1,\"385\":1,\"391\":1,\"397\":1,\"403\":1,\"409\":1,\"415\":1,\"421\":1,\"427\":1,\"433\":1,\"439\":1,\"446\":1,\"452\":1,\"458\":1,\"464\":1,\"470\":1,\"476\":1,\"482\":1,\"489\":1}}],[\"host\",{\"1\":{\"354\":2}}],[\"hosts\",{\"1\":{\"302\":1}}],[\"how\",{\"1\":{\"274\":2}}],[\"handoff\",{\"1\":{\"715\":2}}],[\"hard\",{\"1\":{\"708\":1}}],[\"hadoop\",{\"1\":{\"668\":1}}],[\"hao\",{\"1\":{\"668\":1}}],[\"having\",{\"1\":{\"516\":1,\"520\":5}}],[\"hascycle\",{\"1\":{\"475\":4}}],[\"hashcode\",{\"1\":{\"655\":1}}],[\"hashset\",{\"1\":{\"646\":2}}],[\"hashset<>\",{\"1\":{\"646\":2}}],[\"hashset<integer>\",{\"1\":{\"645\":1}}],[\"hashset<k>\",{\"1\":{\"612\":1}}],[\"hashmap<k\",{\"1\":{\"613\":1}}],[\"hashmap<>\",{\"1\":{\"420\":3,\"481\":1,\"647\":4}}],[\"hashmap<integer\",{\"1\":{\"420\":1}}],[\"hashmap\",{\"1\":{\"294\":2,\"647\":2}}],[\"hash\",{\"1\":{\"282\":1,\"294\":1,\"545\":1}}],[\"hamilton\",{\"1\":{\"132\":1}}],[\"http2\",{\"1\":{\"354\":2}}],[\"httpd\",{\"1\":{\"353\":1}}],[\"http\",{\"1\":{\"303\":1,\"329\":2,\"352\":1,\"354\":2,\"356\":1,\"662\":1,\"666\":1,\"667\":1,\"673\":1}}],[\"httpservletrequest\",{\"1\":{\"310\":1,\"311\":1,\"313\":2,\"314\":1}}],[\"https\",{\"0\":{\"354\":1},\"1\":{\"274\":7,\"303\":1,\"310\":1,\"311\":1,\"322\":1,\"323\":1,\"345\":1,\"347\":4,\"354\":1,\"419\":1,\"659\":3,\"660\":1,\"662\":1,\"663\":1,\"666\":1,\"667\":1,\"668\":4,\"728\":1}}],[\"html+css+javascript\",{\"1\":{\"300\":1}}],[\"html\",{\"1\":{\"274\":1,\"354\":5}}],[\"hp\",{\"1\":{\"237\":6}}],[\"hh++\",{\"1\":{\"169\":1,\"229\":1,\"230\":1}}],[\"hh\",{\"1\":{\"169\":2,\"229\":4,\"230\":4,\"507\":3,\"690\":4}}],[\"h>\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"129\":1,\"134\":1,\"180\":1,\"181\":1}}],[\"heros\",{\"1\":{\"607\":2}}],[\"hero\",{\"1\":{\"605\":1,\"606\":1,\"607\":5}}],[\"herd\",{\"1\":{\"281\":1}}],[\"heartbeatthread\",{\"1\":{\"715\":1}}],[\"heartbeatexecutor\",{\"1\":{\"715\":2}}],[\"header\",{\"1\":{\"354\":2}}],[\"head\",{\"1\":{\"223\":6}}],[\"head存储链表头\",{\"1\":{\"223\":1}}],[\"heap\",{\"1\":{\"43\":12,\"44\":6,\"173\":6,\"237\":11,\"249\":7}}],[\"hello\",{\"1\":{\"63\":2,\"555\":2,\"578\":4,\"580\":1,\"585\":1,\"587\":1,\"591\":1,\"632\":3,\"642\":5,\"680\":5,\"682\":1,\"690\":5}}],[\"heuristic\",{\"1\":{\"38\":1,\"39\":1,\"40\":1}}],[\"h\",{\"1\":{\"35\":1,\"36\":7,\"43\":8,\"71\":1,\"165\":10,\"167\":1,\"168\":1,\"169\":1,\"173\":4,\"175\":4,\"176\":2,\"182\":2,\"183\":2,\"237\":11,\"239\":4,\"240\":3,\"241\":6,\"493\":1}}],[\"gbk\",{\"1\":{\"642\":2}}],[\"gz\",{\"1\":{\"352\":3}}],[\"gfw\",{\"1\":{\"346\":5}}],[\"gender\",{\"1\":{\"321\":2}}],[\"generate\",{\"1\":{\"311\":2}}],[\"getheartbeatexecutorthreadpoolsize\",{\"1\":{\"715\":1}}],[\"getwaittimeinmswhensyncempty\",{\"1\":{\"707\":1}}],[\"getintproperty\",{\"1\":{\"707\":1}}],[\"getinteger\",{\"1\":{\"642\":1}}],[\"getinstance\",{\"1\":{\"706\":1,\"721\":2}}],[\"getobjectargs\",{\"1\":{\"676\":1}}],[\"getobjectresponse\",{\"1\":{\"676\":3}}],[\"getobject\",{\"1\":{\"675\":1,\"676\":2}}],[\"getordefault\",{\"1\":{\"481\":1,\"647\":2}}],[\"geteurekaclientconfig\",{\"1\":{\"717\":1,\"719\":1}}],[\"getendpoint\",{\"1\":{\"673\":1}}],[\"getemail\",{\"1\":{\"310\":1}}],[\"getname\",{\"1\":{\"632\":1,\"636\":1}}],[\"getnickname\",{\"1\":{\"310\":1}}],[\"getfield\",{\"1\":{\"628\":1}}],[\"getcacherefreshexecutorthreadpoolsize\",{\"1\":{\"715\":1}}],[\"getcause\",{\"1\":{\"619\":1}}],[\"getconfiginstance\",{\"1\":{\"702\":3,\"706\":2}}],[\"getconstructor\",{\"1\":{\"628\":1}}],[\"getcheckpassword\",{\"1\":{\"311\":1}}],[\"getmethod\",{\"1\":{\"628\":1}}],[\"getmessage\",{\"1\":{\"619\":1,\"622\":1}}],[\"getmapping\",{\"1\":{\"313\":1}}],[\"gety\",{\"1\":{\"600\":1,\"601\":1}}],[\"getxx\",{\"1\":{\"707\":1,\"710\":1}}],[\"getx\",{\"1\":{\"600\":1,\"601\":1}}],[\"getvalue\",{\"1\":{\"444\":1,\"469\":1,\"613\":1,\"647\":1,\"655\":1}}],[\"getkey\",{\"1\":{\"444\":1,\"469\":1,\"613\":1,\"647\":1,\"655\":1}}],[\"getawssecretkey\",{\"1\":{\"704\":1}}],[\"getawsaccessid\",{\"1\":{\"704\":1}}],[\"getaccesskey\",{\"1\":{\"673\":1}}],[\"getattribute\",{\"1\":{\"313\":1}}],[\"getavatar\",{\"1\":{\"310\":1}}],[\"getpeereurekanodes\",{\"1\":{\"719\":1}}],[\"getpropertiesfromfile\",{\"1\":{\"706\":1}}],[\"getpresignedobjecturlargs\",{\"1\":{\"676\":1}}],[\"getpresignedobjecturl\",{\"1\":{\"676\":2}}],[\"getpassword\",{\"1\":{\"311\":2}}],[\"getphone\",{\"1\":{\"310\":1}}],[\"getremark\",{\"1\":{\"310\":1}}],[\"getlasttime\",{\"1\":{\"310\":1}}],[\"getgender\",{\"1\":{\"310\":1}}],[\"getuserrole\",{\"1\":{\"310\":1,\"313\":1}}],[\"getusername\",{\"1\":{\"310\":1,\"311\":2}}],[\"getuserid\",{\"1\":{\"310\":1,\"322\":1,\"323\":1}}],[\"getstringproperty\",{\"1\":{\"706\":1}}],[\"getstring\",{\"1\":{\"702\":1,\"706\":1}}],[\"getstacktrace\",{\"1\":{\"619\":1}}],[\"getstatus\",{\"1\":{\"310\":1}}],[\"getservercontext\",{\"1\":{\"721\":2}}],[\"getsecretkey\",{\"1\":{\"673\":1}}],[\"getsession\",{\"1\":{\"310\":1,\"313\":1}}],[\"getspeed\",{\"1\":{\"604\":1,\"606\":1,\"607\":1}}],[\"getsafetyuser\",{\"1\":{\"310\":2,\"313\":1}}],[\"getbytes\",{\"1\":{\"310\":1,\"323\":1,\"642\":4}}],[\"get\",{\"1\":{\"65\":1,\"67\":1,\"191\":1,\"192\":1,\"193\":1,\"195\":1,\"200\":1,\"210\":6,\"241\":1,\"308\":1,\"420\":3,\"609\":1,\"613\":1,\"628\":1,\"645\":1,\"647\":3,\"676\":2,\"704\":1,\"706\":3,\"707\":4,\"708\":3,\"710\":1}}],[\"global\",{\"1\":{\"310\":1,\"545\":1}}],[\"guides\",{\"1\":{\"310\":1}}],[\"ghost\",{\"1\":{\"289\":1}}],[\"group\",{\"1\":{\"516\":2,\"520\":1,\"521\":1}}],[\"groupid>\",{\"1\":{\"323\":1,\"672\":1}}],[\"graph\",{\"1\":{\"474\":1}}],[\"grid\",{\"1\":{\"467\":1}}],[\"greet\",{\"1\":{\"604\":1,\"606\":1,\"607\":2}}],[\"grep\",{\"1\":{\"345\":1,\"354\":1}}],[\"greater<int>\",{\"1\":{\"243\":1}}],[\"greater<int>>\",{\"1\":{\"242\":1,\"249\":1}}],[\"greater<pis>>\",{\"1\":{\"44\":1}}],[\"greater<piii>>\",{\"1\":{\"43\":1}}],[\"greater<pii>>\",{\"1\":{\"43\":1,\"173\":1}}],[\"greater\",{\"1\":{\"110\":1}}],[\"grpc\",{\"1\":{\"279\":1,\"284\":2}}],[\"gateway\",{\"1\":{\"279\":1}}],[\"gauss\",{\"1\":{\"205\":1}}],[\"g1\",{\"1\":{\"219\":1}}],[\"g被称为有向图游戏g1\",{\"1\":{\"219\":1}}],[\"gm的和\",{\"1\":{\"219\":1}}],[\"gm\",{\"1\":{\"219\":2}}],[\"g2\",{\"1\":{\"219\":3}}],[\"governator\",{\"1\":{\"728\":1}}],[\"google\",{\"1\":{\"668\":1}}],[\"goods\",{\"1\":{\"118\":4}}],[\"good\",{\"1\":{\"118\":5}}],[\"golang\",{\"1\":{\"668\":1}}],[\"go\",{\"1\":{\"345\":1,\"668\":2}}],[\"go并发编程\",{\"1\":{\"293\":1}}],[\"goal\",{\"1\":{\"38\":2,\"39\":2,\"40\":2}}],[\"gcd\",{\"1\":{\"68\":1,\"197\":3,\"203\":5}}],[\"gcost\",{\"1\":{\"35\":1}}],[\"g\",{\"1\":{\"35\":1,\"36\":2,\"41\":2,\"44\":3,\"62\":1,\"74\":2,\"98\":3,\"129\":7,\"165\":1,\"172\":9,\"180\":7,\"218\":1,\"219\":1,\"302\":1,\"443\":14,\"444\":10,\"445\":7,\"469\":17,\"474\":4,\"475\":8}}],[\"gitee\",{\"1\":{\"659\":1}}],[\"gitee镜像\",{\"1\":{\"659\":1}}],[\"github\",{\"1\":{\"303\":1,\"340\":1,\"347\":4,\"352\":1,\"419\":1,\"659\":2,\"663\":1,\"668\":3}}],[\"git\",{\"0\":{\"15\":1},\"1\":{\"7\":1}}],[\"当在集群环境下\",{\"1\":{\"715\":1}}],[\"当要获取配置项时\",{\"1\":{\"708\":1}}],[\"当元素超过容量后会扩容\",{\"1\":{\"651\":1}}],[\"当只剩下守护线程时\",{\"1\":{\"633\":1}}],[\"当只有一条语句时\",{\"1\":{\"557\":1}}],[\"当试图使用\",{\"1\":{\"618\":1}}],[\"当试图将对象强制转换为不是实例的子类时\",{\"1\":{\"618\":1}}],[\"当调用\",{\"1\":{\"618\":1,\"708\":1}}],[\"当不支持请求的操作时\",{\"1\":{\"618\":1}}],[\"当应用程序试图将字符串转换成一种数值类型\",{\"1\":{\"618\":1}}],[\"当应用程序试图在需要对象的地方使用\",{\"1\":{\"618\":1}}],[\"当出现异常的运算条件时\",{\"1\":{\"618\":1}}],[\"当局部变量与全局变量重名时\",{\"1\":{\"588\":1}}],[\"当条件成立时\",{\"1\":{\"557\":1}}],[\"当根节点中可以存储\",{\"1\":{\"545\":1}}],[\"当数据量较大时\",{\"1\":{\"522\":1}}],[\"当进行删除全部数据操作时\",{\"1\":{\"514\":1}}],[\"当存在循环依赖的时候\",{\"1\":{\"474\":1}}],[\"当left\",{\"1\":{\"420\":1}}],[\"当处理的节点是空节点时\",{\"1\":{\"383\":1}}],[\"当服务器宕机后恢复也能够重启服务\",{\"1\":{\"353\":1}}],[\"当这些服务不稳定时\",{\"1\":{\"284\":1}}],[\"当缓存抖动时候\",{\"1\":{\"281\":1}}],[\"当时评论发布的吞吐较低\",{\"1\":{\"266\":1}}],[\"当且仅当该局面对应节点的sg函数值等于0\",{\"1\":{\"219\":1}}],[\"当且仅当该局面对应节点的sg函数值大于0\",{\"1\":{\"219\":1}}],[\"当且仅当\",{\"1\":{\"214\":1}}],[\"当模数\",{\"1\":{\"208\":1}}],[\"当有\",{\"1\":{\"193\":1}}],[\"当中有\",{\"1\":{\"191\":1}}],[\"当我们向二叉查找树保存数据时\",{\"1\":{\"545\":1}}],[\"当我们递归到节点\",{\"1\":{\"480\":1}}],[\"当我们查找一个完整字符串时\",{\"1\":{\"425\":1}}],[\"当我们找到时\",{\"1\":{\"425\":1}}],[\"当我们操作编辑的时候\",{\"1\":{\"283\":1}}],[\"当我们需要求出组合数的真实值\",{\"1\":{\"210\":1}}],[\"当我们将区间\",{\"1\":{\"141\":1,\"142\":1}}],[\"当我们选择下一个要遍历的节点时\",{\"1\":{\"35\":1}}],[\"当达到了祖先位置\",{\"1\":{\"90\":1}}],[\"当\",{\"1\":{\"63\":1,\"94\":2,\"140\":1,\"158\":1,\"191\":1,\"193\":1,\"203\":2,\"208\":2,\"363\":1,\"717\":1}}],[\"当然也包含表1和表2交集部分的数据\",{\"1\":{\"532\":2}}],[\"当然不建议这么做\",{\"1\":{\"352\":1}}],[\"当然在设计层面可以考虑目录结构进行拆分\",{\"1\":{\"280\":1}}],[\"当然\",{\"1\":{\"58\":1,\"110\":1,\"243\":1,\"273\":1,\"343\":1,\"346\":1,\"667\":1}}],[\"当然还会有很多相关的岛屿变型题\",{\"1\":{\"51\":1}}],[\"当前\",{\"1\":{\"717\":1}}],[\"当前路径下执行\",{\"1\":{\"680\":1}}],[\"当前页数据列表\",{\"1\":{\"522\":1}}],[\"当前页码\",{\"1\":{\"522\":1}}],[\"当前分钟的烂橘子都使其相邻位置的橘子也腐烂\",{\"1\":{\"468\":1}}],[\"当前要查找的字符为\",{\"1\":{\"425\":1}}],[\"当前要加入的字符为\",{\"1\":{\"425\":1}}],[\"当前的数据库设计不能满足该需求\",{\"1\":{\"263\":1}}],[\"当前的值\",{\"1\":{\"111\":1}}],[\"当前位置部分\",{\"1\":{\"129\":1}}],[\"当前加入的数字是几\",{\"1\":{\"111\":1}}],[\"当前前缀和\",{\"1\":{\"81\":1}}],[\"当前节点的数\",{\"1\":{\"485\":2}}],[\"当前节点的右子树已经访问过了\",{\"1\":{\"378\":1}}],[\"当前节点相当于左节点\",{\"1\":{\"384\":1}}],[\"当前节点选\",{\"1\":{\"134\":1}}],[\"当前节点不选\",{\"1\":{\"134\":1}}],[\"当前节点\",{\"1\":{\"43\":1}}],[\"当前距离\",{\"1\":{\"43\":1}}],[\"当前距离+估计到终点的距离\",{\"1\":{\"43\":1}}],[\"当终点第一次出队时\",{\"1\":{\"41\":1}}],[\"当启发函数\",{\"1\":{\"36\":1}}],[\"当图形为网格图\",{\"1\":{\"33\":1}}],[\"是会有多个\",{\"1\":{\"714\":1}}],[\"是包含在\",{\"1\":{\"714\":1}}],[\"是用来构造\",{\"1\":{\"711\":1}}],[\"是实现了\",{\"1\":{\"707\":1}}],[\"是这样定义的\",{\"1\":{\"706\":1}}],[\"是这个评论的父评论\",{\"1\":{\"289\":1}}],[\"是文件名\",{\"1\":{\"692\":1}}],[\"是第二个参数\",{\"1\":{\"692\":1}}],[\"是第一个参数\",{\"1\":{\"692\":1}}],[\"是第一个支持\",{\"1\":{\"668\":1}}],[\"是我们通过命令行与操作系统沟通的语言\",{\"1\":{\"680\":1}}],[\"是存储到\",{\"1\":{\"673\":1}}],[\"是存储\",{\"1\":{\"673\":1}}],[\"是存在\",{\"1\":{\"282\":1}}],[\"是全世界内大家都认可的标准\",{\"1\":{\"668\":1}}],[\"是在全球范围内达到共识的对象存储的协议\",{\"1\":{\"668\":1}}],[\"是程序本身可以处理的异常\",{\"1\":{\"615\":1}}],[\"是程序无法处理的错误\",{\"1\":{\"615\":1}}],[\"是无法捕获处理的\",{\"1\":{\"615\":1}}],[\"是97\",{\"1\":{\"577\":1}}],[\"是65\",{\"1\":{\"577\":1}}],[\"是条件表达式\",{\"1\":{\"563\":1}}],[\"是每次判断\",{\"1\":{\"561\":1}}],[\"是按照从大到小\",{\"1\":{\"545\":1}}],[\"是帮助数据库高效获取数据的数据结构\",{\"1\":{\"544\":1}}],[\"是不是在多的一方添加外键\",{\"1\":{\"525\":1}}],[\"是不是偶数\",{\"1\":{\"158\":1}}],[\"是分组之后对结果进行过滤\",{\"1\":{\"520\":1}}],[\"是分组之前进行过滤\",{\"1\":{\"520\":1}}],[\"是null\",{\"1\":{\"518\":1}}],[\"是变长字符串\",{\"1\":{\"507\":1}}],[\"是定长字符串\",{\"1\":{\"507\":1}}],[\"是同一棵树的中序遍历\",{\"1\":{\"418\":1}}],[\"是同一个级别的类型\",{\"1\":{\"171\":1}}],[\"是二叉树的先序遍历\",{\"1\":{\"418\":1}}],[\"是指\",{\"1\":{\"595\":1}}],[\"是指该树所有节点的左右子树的深度相差不超过\",{\"1\":{\"436\":1}}],[\"是指树中任意两个节点之间最长路径的\",{\"1\":{\"412\":1}}],[\"是指从根节点到最远叶子节点的最长路径上的节点数\",{\"1\":{\"400\":1}}],[\"是指迷宫的出口在地图的边界\",{\"1\":{\"57\":1}}],[\"是树中节点的个数\",{\"1\":{\"377\":1}}],[\"是路径中各节点值的总和\",{\"1\":{\"370\":1}}],[\"是因为我们不知道子树的结点数量\",{\"1\":{\"365\":1}}],[\"是linux\",{\"1\":{\"353\":1}}],[\"是有必要的\",{\"1\":{\"294\":1}}],[\"是要增量追加的\",{\"1\":{\"291\":1}}],[\"是为了减少一次二级索引查找\",{\"1\":{\"289\":1}}],[\"是物理组织形式存放的\",{\"1\":{\"289\":1}}],[\"是该评论的根评论\",{\"1\":{\"289\":1}}],[\"是主题类型\",{\"1\":{\"289\":1}}],[\"是主题\",{\"1\":{\"289\":1,\"291\":1}}],[\"是面向端\",{\"1\":{\"284\":1}}],[\"是由一组\",{\"1\":{\"282\":1}}],[\"是做到服务里的\",{\"1\":{\"281\":1}}],[\"是敏感词过滤服务\",{\"1\":{\"279\":1}}],[\"是多数据源的\",{\"1\":{\"273\":1}}],[\"是容易出现误差累积的\",{\"1\":{\"270\":1}}],[\"是数据冗余造成的\",{\"1\":{\"270\":1}}],[\"是可见态才允许下发\",{\"1\":{\"269\":1}}],[\"是评论\",{\"1\":{\"264\":1}}],[\"是评论系统的接入层\",{\"1\":{\"258\":1}}],[\"是越界的\",{\"1\":{\"243\":1}}],[\"是堆顶\",{\"1\":{\"237\":1}}],[\"是m个有向图游戏\",{\"1\":{\"219\":1}}],[\"是质数\",{\"1\":{\"209\":1}}],[\"是增广矩阵\",{\"1\":{\"205\":1}}],[\"是满足条件的第一个数\",{\"1\":{\"193\":1}}],[\"是bellman\",{\"1\":{\"171\":1}}],[\"是的输出\",{\"1\":{\"94\":1}}],[\"是否包含子串str\",{\"1\":{\"642\":1}}],[\"是否包含关键字\",{\"1\":{\"613\":1}}],[\"是否包含某个元素\",{\"1\":{\"612\":1}}],[\"是否为空\",{\"1\":{\"609\":1,\"611\":1,\"612\":1,\"613\":1}}],[\"是否为亲戚\",{\"1\":{\"93\":1}}],[\"是否存在默认值等信息\",{\"1\":{\"508\":1}}],[\"是否可以为null\",{\"1\":{\"508\":1}}],[\"是否返回为true\",{\"1\":{\"322\":1}}],[\"是否删除\",{\"1\":{\"321\":2}}],[\"是否符合要求\",{\"1\":{\"310\":1,\"323\":2}}],[\"是否走到末尾\",{\"1\":{\"231\":1}}],[\"是否能到达\",{\"1\":{\"174\":1}}],[\"是否记下ans\",{\"1\":{\"143\":1}}],[\"是否满足条件\",{\"1\":{\"111\":1}}],[\"是否成立\",{\"1\":{\"111\":1}}],[\"是否在同一集合内\",{\"1\":{\"94\":1}}],[\"是否比原来更小\",{\"1\":{\"35\":1}}],[\"是亲戚\",{\"1\":{\"93\":3}}],[\"是\",{\"1\":{\"81\":1,\"200\":1,\"323\":1,\"328\":1,\"406\":1,\"449\":1,\"654\":1,\"662\":1,\"667\":1}}],[\"是泛化的\",{\"1\":{\"77\":1}}],[\"是返回值类型\",{\"1\":{\"75\":1}}],[\"是函数选项\",{\"1\":{\"75\":1}}],[\"是参数表\",{\"1\":{\"75\":1}}],[\"是捕获列表\",{\"1\":{\"75\":1}}],[\"是整数\",{\"1\":{\"68\":1,\"203\":1}}],[\"是c语言标准库中的函数\",{\"1\":{\"63\":1}}],[\"是节点\",{\"1\":{\"35\":3}}],[\"是一类在后台运行的系统服务进程\",{\"1\":{\"353\":1}}],[\"是一类能够为一种或多种应用程序合作互通\",{\"1\":{\"14\":1}}],[\"是一层\",{\"1\":{\"280\":1}}],[\"是一个接口\",{\"1\":{\"704\":1}}],[\"是一个高性能的分布式对象存储系统\",{\"1\":{\"666\":1}}],[\"是一个不可分割的工作单元\",{\"1\":{\"542\":1}}],[\"是一个轻量级的进程管理工具\",{\"1\":{\"353\":1}}],[\"是一个支持多家云存储驱动的公有云文件系统\",{\"1\":{\"351\":1}}],[\"是一个\",{\"1\":{\"264\":1,\"302\":1}}],[\"是一个质数\",{\"1\":{\"208\":1}}],[\"是一个边的集合\",{\"1\":{\"183\":1}}],[\"是一个确定的值\",{\"1\":{\"174\":1}}],[\"是一个二进制数\",{\"1\":{\"131\":1}}],[\"是一种恢复丢失和损坏数据的数学算法\",{\"1\":{\"668\":1}}],[\"是一种数据存储架构\",{\"1\":{\"667\":1}}],[\"是一种没有重复元素的集合\",{\"1\":{\"646\":1}}],[\"是一种树形数据结构\",{\"1\":{\"424\":1}}],[\"是一种基于\",{\"1\":{\"356\":1}}],[\"是一种隐私保护技术\",{\"1\":{\"309\":1}}],[\"是一种能够高效存储和查找字符串集合的数据结构\",{\"1\":{\"232\":1}}],[\"是一种应用于分布式系统的基础软件\",{\"1\":{\"14\":1}}],[\"是一种独立的系统软件或服务程序\",{\"1\":{\"14\":1}}],[\"是一种在系统软件和用户应用软件之间连接的软件\",{\"1\":{\"14\":1}}],[\"nas\",{\"1\":{\"668\":1}}],[\"name3=yxc\",{\"1\":{\"685\":1}}],[\"name2=\",{\"1\":{\"685\":1}}],[\"name1=\",{\"1\":{\"685\":1}}],[\"name>\",{\"1\":{\"663\":1}}],[\"name=abc\",{\"1\":{\"687\":1}}],[\"name=yxc\",{\"1\":{\"686\":1,\"687\":1,\"688\":1,\"689\":2,\"690\":1}}],[\"name=\",{\"1\":{\"513\":1,\"690\":2}}],[\"name\",{\"1\":{\"354\":1,\"513\":1,\"559\":10,\"578\":1,\"606\":4,\"607\":4,\"628\":5,\"675\":1,\"686\":2,\"687\":2,\"688\":1,\"689\":3,\"690\":2,\"714\":1}}],[\"namespace\",{\"1\":{\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"172\":1,\"180\":1,\"181\":1,\"196\":1,\"204\":1,\"212\":1,\"214\":1,\"231\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"707\":1}}],[\"n为str长度\",{\"1\":{\"642\":2}}],[\"n为选修课程数\",{\"1\":{\"475\":1}}],[\"n为模式串长度\",{\"1\":{\"231\":1}}],[\"ntulp\",{\"1\":{\"345\":1}}],[\"ntlp\",{\"1\":{\"345\":1}}],[\"nickname\",{\"1\":{\"321\":1}}],[\"nim博弈属于公平组合游戏\",{\"1\":{\"215\":1}}],[\"nim博弈先手必胜\",{\"1\":{\"214\":1}}],[\"nim博弈不存在平局\",{\"1\":{\"214\":1}}],[\"nim游戏\",{\"0\":{\"214\":1}}],[\"npm\",{\"1\":{\"302\":1}}],[\"npos是这样定义的\",{\"1\":{\"72\":1}}],[\"npos是一个静态成员常量\",{\"1\":{\"72\":1}}],[\"npos\",{\"0\":{\"72\":1},\"1\":{\"72\":2}}],[\"nginx\",{\"1\":{\"279\":1,\"329\":1,\"346\":1,\"354\":15}}],[\"n个闭区间\",{\"1\":{\"247\":1,\"249\":1}}],[\"n=10\",{\"1\":{\"334\":1}}],[\"n=1000\",{\"1\":{\"334\":1}}],[\"n=p1a1​​p2a2​​\",{\"1\":{\"199\":1}}],[\"n=a+cb​\",{\"1\":{\"111\":2}}],[\"n1表示第一个集合中的点数\",{\"1\":{\"183\":1}}],[\"n1\",{\"1\":{\"183\":2}}],[\"n是点数\",{\"1\":{\"181\":1}}],[\"n次迭代\",{\"1\":{\"180\":1}}],[\"n^3\",{\"1\":{\"178\":1,\"205\":1}}],[\"n表示点数\",{\"1\":{\"174\":1,\"180\":1,\"182\":1}}],[\"nm\",{\"1\":{\"171\":2,\"174\":1,\"175\":1,\"176\":1,\"183\":1}}],[\"n2表示第二个集合中的点数\",{\"1\":{\"183\":1}}],[\"n2\",{\"1\":{\"171\":1,\"172\":1,\"180\":1,\"183\":1}}],[\"n代表点数\",{\"1\":{\"165\":1}}],[\"nlogn\",{\"1\":{\"144\":1}}],[\"n−2\",{\"1\":{\"561\":1,\"563\":1}}],[\"n−1\",{\"1\":{\"132\":3,\"561\":1,\"563\":1}}],[\"n−m\",{\"1\":{\"109\":1}}],[\"n<=0\",{\"1\":{\"129\":1}}],[\"n共有多少种不同的划分方法\",{\"1\":{\"128\":1}}],[\"n+1\",{\"1\":{\"204\":1}}],[\"n+m\",{\"1\":{\"169\":1}}],[\"n+\",{\"1\":{\"109\":1}}],[\"n>0\",{\"1\":{\"109\":1}}],[\"n×n\",{\"1\":{\"100\":2}}],[\"n×m\",{\"1\":{\"98\":1,\"131\":1}}],[\"nu\",{\"1\":{\"474\":1}}],[\"numberformatexception\",{\"1\":{\"618\":1}}],[\"numcourses\",{\"1\":{\"473\":2}}],[\"numislands\",{\"1\":{\"443\":1,\"444\":1,\"445\":1}}],[\"nums\",{\"1\":{\"129\":5,\"251\":7,\"436\":1,\"438\":7,\"455\":1,\"456\":4}}],[\"num\",{\"1\":{\"71\":8,\"251\":5,\"509\":2}}],[\"nullpointerexception\",{\"1\":{\"617\":1,\"618\":1}}],[\"null\",{\"1\":{\"25\":4,\"240\":1,\"310\":8,\"311\":6,\"313\":1,\"321\":14,\"363\":1,\"366\":1,\"376\":1,\"377\":5,\"378\":4,\"389\":1,\"390\":3,\"396\":3,\"401\":1,\"402\":3,\"408\":3,\"414\":1,\"420\":4,\"426\":5,\"432\":2,\"438\":1,\"463\":2,\"481\":1,\"486\":1,\"487\":1,\"488\":1,\"506\":1,\"514\":1,\"518\":1,\"519\":1,\"618\":1,\"622\":1,\"702\":3}}],[\"nohup\",{\"1\":{\"660\":1}}],[\"nohub\",{\"1\":{\"660\":1}}],[\"nosuchmethodexception\",{\"1\":{\"618\":1,\"628\":1}}],[\"nosuchfieldexception\",{\"1\":{\"618\":1,\"621\":4,\"628\":1}}],[\"noargsconstructor\",{\"1\":{\"522\":1}}],[\"none\",{\"1\":{\"242\":1}}],[\"note\",{\"0\":{\"738\":1,\"756\":1}}],[\"notifyall\",{\"1\":{\"636\":1}}],[\"notify\",{\"0\":{\"636\":1}}],[\"not\",{\"1\":{\"226\":1,\"229\":1,\"274\":2,\"310\":1,\"321\":4,\"500\":3,\"506\":1,\"518\":1,\"536\":1,\"537\":1,\"559\":1,\"728\":1,\"735\":1}}],[\"noexcept\",{\"1\":{\"63\":2}}],[\"no\",{\"1\":{\"55\":2,\"93\":3,\"214\":1,\"557\":2,\"558\":1,\"565\":1}}],[\"nodejs\",{\"1\":{\"302\":1}}],[\"node\",{\"1\":{\"38\":3,\"39\":3,\"40\":3,\"165\":4,\"243\":3,\"247\":2,\"248\":2,\"329\":1,\"390\":6,\"396\":6,\"402\":5,\"419\":2,\"420\":4,\"425\":8,\"426\":14,\"480\":5,\"486\":9,\"488\":5}}],[\"nebula\",{\"1\":{\"727\":2}}],[\"needwait\",{\"1\":{\"636\":5}}],[\"negativearraysizeexception\",{\"1\":{\"618\":1}}],[\"netflixoss\",{\"1\":{\"727\":2}}],[\"netflix\",{\"1\":{\"702\":1}}],[\"netstat\",{\"1\":{\"345\":2}}],[\"net\",{\"1\":{\"311\":1,\"728\":1}}],[\"newscheduledthreadpool\",{\"1\":{\"715\":1}}],[\"newstring\",{\"1\":{\"587\":2}}],[\"newbuilder\",{\"1\":{\"711\":1}}],[\"newvalue\",{\"1\":{\"647\":1,\"654\":1}}],[\"newinstance\",{\"1\":{\"618\":1,\"628\":2}}],[\"newarray\",{\"1\":{\"587\":2}}],[\"newregex\",{\"1\":{\"578\":1}}],[\"newchar\",{\"1\":{\"578\":1,\"642\":1}}],[\"new\",{\"1\":{\"310\":2,\"313\":2,\"322\":1,\"323\":2,\"389\":1,\"390\":3,\"396\":3,\"402\":2,\"420\":6,\"426\":2,\"438\":1,\"444\":3,\"445\":1,\"451\":1,\"469\":7,\"474\":2,\"475\":4,\"481\":1,\"488\":3,\"554\":3,\"555\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":1,\"563\":1,\"565\":1,\"570\":4,\"571\":1,\"572\":6,\"573\":2,\"579\":1,\"580\":1,\"591\":1,\"594\":1,\"596\":1,\"602\":2,\"607\":2,\"611\":1,\"620\":2,\"621\":3,\"622\":4,\"628\":3,\"632\":9,\"634\":3,\"635\":6,\"636\":4,\"642\":4,\"643\":1,\"645\":4,\"646\":3,\"647\":4,\"648\":2,\"649\":1,\"650\":1,\"651\":4,\"676\":4,\"704\":1,\"705\":1,\"710\":2,\"714\":2,\"715\":8,\"717\":3,\"720\":1,\"721\":1}}],[\"nextline\",{\"1\":{\"554\":1,\"578\":1,\"579\":1}}],[\"nextdouble\",{\"1\":{\"554\":1}}],[\"nextfloat\",{\"1\":{\"554\":1}}],[\"nextint\",{\"1\":{\"554\":1,\"557\":13,\"558\":4,\"559\":1,\"561\":1,\"563\":1,\"565\":1,\"572\":5,\"594\":2,\"596\":1,\"620\":2,\"621\":1}}],[\"next\",{\"1\":{\"231\":4,\"554\":1,\"579\":1}}],[\"ne\",{\"1\":{\"41\":1,\"43\":4,\"165\":2,\"167\":1,\"168\":1,\"169\":1,\"173\":3,\"175\":3,\"176\":2,\"182\":2,\"183\":2,\"223\":10,\"231\":5,\"239\":3}}],[\"n\",{\"1\":{\"35\":13,\"36\":12,\"43\":12,\"48\":8,\"49\":10,\"50\":8,\"55\":12,\"56\":9,\"57\":11,\"62\":3,\"64\":1,\"65\":1,\"66\":1,\"74\":7,\"75\":1,\"81\":9,\"82\":16,\"83\":9,\"89\":6,\"93\":10,\"94\":16,\"98\":14,\"100\":5,\"101\":10,\"107\":8,\"108\":10,\"109\":8,\"110\":13,\"111\":8,\"116\":11,\"117\":11,\"118\":26,\"119\":19,\"121\":14,\"122\":21,\"123\":10,\"124\":16,\"125\":13,\"126\":10,\"127\":13,\"128\":16,\"129\":6,\"131\":11,\"132\":13,\"134\":6,\"144\":9,\"147\":1,\"159\":14,\"160\":1,\"161\":1,\"165\":13,\"166\":2,\"169\":3,\"171\":2,\"172\":13,\"173\":10,\"174\":13,\"175\":7,\"176\":11,\"178\":5,\"179\":2,\"180\":14,\"181\":14,\"182\":6,\"183\":4,\"187\":1,\"188\":10,\"189\":15,\"191\":16,\"192\":2,\"193\":5,\"196\":5,\"199\":3,\"200\":8,\"204\":8,\"205\":21,\"207\":1,\"208\":3,\"209\":8,\"210\":14,\"211\":3,\"212\":11,\"214\":3,\"223\":3,\"224\":3,\"226\":1,\"227\":1,\"229\":1,\"230\":1,\"231\":5,\"232\":2,\"234\":4,\"235\":3,\"236\":3,\"237\":6,\"239\":9,\"240\":5,\"241\":3,\"243\":8,\"247\":7,\"248\":7,\"249\":7,\"250\":9,\"251\":4,\"282\":1,\"334\":2,\"377\":2,\"390\":4,\"396\":3,\"426\":4,\"443\":4,\"444\":4,\"445\":6,\"451\":6,\"456\":2,\"467\":1,\"469\":7,\"474\":3,\"475\":6,\"545\":2,\"551\":1,\"555\":4,\"557\":14,\"561\":4,\"563\":4,\"565\":3,\"572\":21,\"579\":1,\"584\":1,\"593\":1,\"596\":6,\"622\":1,\"640\":1,\"642\":12,\"643\":2,\"645\":3,\"653\":1,\"668\":2}}],[\"其它参数相关变量\",{\"0\":{\"693\":1}}],[\"其全部oldchar都替换成newchar\",{\"1\":{\"642\":1}}],[\"其创建的对象将直接放置到堆中\",{\"1\":{\"642\":1}}],[\"其长度为end或end\",{\"1\":{\"640\":1}}],[\"其所有的节点是否都在\",{\"1\":{\"486\":1}}],[\"其要求一定是能稳定运行\",{\"1\":{\"353\":1}}],[\"其实一对一我们可以看成一种特殊的一对多\",{\"1\":{\"525\":1}}],[\"其实就是加载这个文件\",{\"1\":{\"706\":1}}],[\"其实就是把二叉树上的每个节点的左右子节点都交换一下\",{\"1\":{\"462\":1}}],[\"其实就是找每一层最右边的节点\",{\"1\":{\"389\":1}}],[\"其实隐式地维护了一个栈结构\",{\"1\":{\"384\":1}}],[\"其实\",{\"1\":{\"353\":1}}],[\"其实到这一步\",{\"1\":{\"352\":1}}],[\"其实解决方法也有\",{\"1\":{\"350\":1}}],[\"其实关键在于\",{\"1\":{\"94\":1}}],[\"其自身并不能提供一个外部链接\",{\"1\":{\"350\":1}}],[\"其回复也等价于全部删除\",{\"1\":{\"263\":1}}],[\"其他地方想获取\",{\"1\":{\"721\":1}}],[\"其他地方想要获取上下文\",{\"1\":{\"721\":1}}],[\"其他地方也要调用用户状态\",{\"1\":{\"315\":1}}],[\"其他值表示错误\",{\"1\":{\"693\":1}}],[\"其他保持默认即可\",{\"1\":{\"345\":1}}],[\"其他的都是一些统计信息等等\",{\"1\":{\"289\":1}}],[\"其他\",{\"0\":{\"723\":1},\"1\":{\"263\":1}}],[\"其余为o\",{\"1\":{\"645\":1}}],[\"其余所有的数字依次跟着变化\",{\"1\":{\"205\":1}}],[\"其余位为\",{\"1\":{\"158\":3}}],[\"其表达式为\",{\"1\":{\"159\":1}}],[\"其更新操作是\",{\"1\":{\"141\":1,\"142\":1}}],[\"其位数和棋盘的行数一致\",{\"1\":{\"131\":1}}],[\"其次安全性和稳定性也不能一直保证\",{\"1\":{\"350\":1}}],[\"其次在全量打分排序阶段\",{\"1\":{\"273\":1}}],[\"其次是评论区表\",{\"1\":{\"263\":1}}],[\"其次\",{\"1\":{\"108\":1,\"109\":1}}],[\"其时间复杂度就是树的高度\",{\"1\":{\"94\":1}}],[\"其函数表示如下\",{\"1\":{\"40\":1}}],[\"其中每个形参都是含有一个声明符的声明\",{\"1\":{\"586\":1}}],[\"其中的数据实时性\",{\"1\":{\"273\":1}}],[\"其中的第\",{\"1\":{\"159\":1}}],[\"其中最核心的是发布类接口以及列表类接口\",{\"1\":{\"258\":1}}],[\"其中元素已经按\",{\"1\":{\"436\":1}}],[\"其中元素\",{\"1\":{\"237\":1}}],[\"其中任意两条边都不依附于同一个顶点\",{\"1\":{\"183\":1}}],[\"其中一个作为分界点\",{\"1\":{\"137\":1}}],[\"其中i为数字个数\",{\"1\":{\"129\":2}}],[\"其中第\",{\"1\":{\"110\":1}}],[\"其中\",{\"1\":{\"35\":1,\"48\":1,\"49\":1,\"55\":1,\"75\":1,\"98\":1,\"100\":1,\"131\":1,\"159\":1,\"209\":1,\"289\":1,\"376\":1,\"377\":1,\"418\":1,\"473\":1,\"662\":1,\"683\":1}}],[\"其原理也很简单\",{\"1\":{\"34\":1}}],[\"函数在类的每个对象中都有独立的一份\",{\"1\":{\"600\":1}}],[\"函数在类中只有一份\",{\"1\":{\"600\":1}}],[\"函数与普通成员变量\",{\"1\":{\"600\":1}}],[\"函数完美地打包在一起\",{\"1\":{\"597\":1}}],[\"函数递归\",{\"0\":{\"596\":1}}],[\"函数名必须相同\",{\"1\":{\"625\":1}}],[\"函数名和参数列表必须相同\",{\"1\":{\"625\":1}}],[\"函数名称相同但参数列表不同\",{\"1\":{\"595\":1}}],[\"函数名字是\",{\"1\":{\"583\":1}}],[\"函数名字\",{\"1\":{\"582\":1}}],[\"函数重载\",{\"0\":{\"595\":1},\"1\":{\"595\":1}}],[\"函数如果想在它的中间位置提前退出\",{\"1\":{\"593\":1}}],[\"函数内定义的变量为局部变量\",{\"1\":{\"588\":1}}],[\"函数及其区别会在下一章中介绍\",{\"1\":{\"588\":1}}],[\"函数返回类型\",{\"0\":{\"587\":1}}],[\"函数基础\",{\"0\":{\"582\":1}}],[\"函数遍历到值为\",{\"1\":{\"443\":1}}],[\"函数使用\",{\"1\":{\"72\":1}}],[\"函数的区别\",{\"1\":{\"600\":1}}],[\"函数的返回类型也可以是数组\",{\"1\":{\"587\":1}}],[\"函数的返回值是统计以\",{\"1\":{\"480\":1}}],[\"函数的形参列表可以为空\",{\"1\":{\"586\":1}}],[\"函数的形参列表\",{\"0\":{\"586\":1}}],[\"函数的调用完成两项工作\",{\"1\":{\"584\":1}}],[\"函数的头文件是\",{\"1\":{\"71\":1}}],[\"函数的第一个参数类型是\",{\"1\":{\"71\":1}}],[\"函数转换\",{\"1\":{\"71\":1}}],[\"函数输出字符串是针对\",{\"1\":{\"63\":1}}],[\"函数中迷宫出口的判断条件稍加修改即可\",{\"1\":{\"57\":1}}],[\"函数中判断能否找到出口\",{\"1\":{\"55\":1}}],[\"函数淹没岛屿的同时\",{\"1\":{\"50\":1}}],[\"函数\",{\"0\":{\"581\":1},\"1\":{\"35\":1,\"71\":1,\"74\":1,\"519\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1,\"625\":1}}],[\"但关闭会话服务会停止\",{\"1\":{\"660\":1}}],[\"但最好使用\",{\"1\":{\"648\":1}}],[\"但不建议这么做\",{\"1\":{\"650\":1}}],[\"但不能添加任何元素\",{\"1\":{\"647\":1}}],[\"但不能不取\",{\"1\":{\"214\":1}}],[\"但不要对其进行改动\",{\"1\":{\"645\":1}}],[\"但从index开始从后往前找\",{\"1\":{\"642\":1}}],[\"但从index开始找\",{\"1\":{\"642\":1}}],[\"但其实\",{\"1\":{\"641\":1}}],[\"但其有一个缺点\",{\"1\":{\"83\":1}}],[\"但注解可以被编译或运行\",{\"1\":{\"624\":1}}],[\"但该对象的类无法实现\",{\"1\":{\"618\":1}}],[\"但该字符串不能转换为适当格式时\",{\"1\":{\"618\":1}}],[\"但可以是多列\",{\"1\":{\"534\":1}}],[\"但可以是多行\",{\"1\":{\"534\":1}}],[\"但要注意\",{\"1\":{\"468\":1}}],[\"但\",{\"1\":{\"449\":1}}],[\"但坏处是它会占用大量的系统资源\",{\"1\":{\"353\":1}}],[\"但很快发现\",{\"1\":{\"350\":1}}],[\"但依然推荐一些国外厂商的云主机\",{\"1\":{\"344\":1}}],[\"但评论往往不会如此激进\",{\"1\":{\"273\":1}}],[\"但也有一点根本性差异\",{\"1\":{\"273\":1}}],[\"但都能保障用户的基础体验\",{\"1\":{\"267\":1}}],[\"但都是大同小异\",{\"1\":{\"51\":1}}],[\"但随着b站社区破圈起量\",{\"1\":{\"263\":1}}],[\"但由于部分缓存数据项的重建代价较高\",{\"1\":{\"261\":1}}],[\"但城建的棋类游戏\",{\"1\":{\"215\":1}}],[\"但归并排序的核心在这一步骤\",{\"1\":{\"137\":1}}],[\"但地图没有这么大\",{\"1\":{\"83\":1}}],[\"但实际上后面的搜索中可能还是要走这条路的\",{\"1\":{\"55\":1}}],[\"但对于数据传输的安全性和及时性有较高要求的业务来说\",{\"1\":{\"667\":1}}],[\"但对于\",{\"1\":{\"48\":1}}],[\"但某些题目会描述为\",{\"1\":{\"48\":1}}],[\"但我们维护的是一个小根堆\",{\"1\":{\"41\":1}}],[\"但是不能省略\",{\"1\":{\"586\":1}}],[\"但是不一定\",{\"1\":{\"94\":1}}],[\"但是在\",{\"1\":{\"545\":1}}],[\"但是对于用户的身份信息查询频率很低\",{\"1\":{\"525\":1}}],[\"但是如果是自定义的实体类对象\",{\"1\":{\"647\":1}}],[\"但是如果高并发访问\",{\"1\":{\"545\":1}}],[\"但是如果数据给的\",{\"1\":{\"486\":1}}],[\"但是如果都不是\",{\"1\":{\"334\":1}}],[\"但是路径方向必须是向下的\",{\"1\":{\"479\":1}}],[\"但是这毕竟很麻烦\",{\"1\":{\"346\":1}}],[\"但是这个会\",{\"1\":{\"310\":1}}],[\"但是别开心的太早\",{\"1\":{\"346\":1}}],[\"但是布隆过滤器解决缓存穿透还存在另外一个缺点\",{\"1\":{\"334\":1}}],[\"但是区块一直无法显示\",{\"1\":{\"302\":1}}],[\"但是热点\",{\"1\":{\"294\":1}}],[\"但是\",{\"1\":{\"283\":1}}],[\"但是架构层次来说\",{\"1\":{\"280\":1}}],[\"但是评论区的计数更新操作\",{\"1\":{\"263\":1}}],[\"但是需要提供极高的可用性与性能吞吐\",{\"1\":{\"260\":1}}],[\"但是由于业务数据量较大\",{\"1\":{\"259\":1}}],[\"但是疲倦的它们再也不想徒步走下山了\",{\"1\":{\"110\":1}}],[\"但是有可能出现\",{\"1\":{\"91\":1}}],[\"但是当\",{\"1\":{\"36\":1}}],[\"但是算法也有缺点\",{\"1\":{\"34\":1}}],[\"但此时以每个节点到达终点的距离作为优先级\",{\"1\":{\"34\":1}}],[\"bmin\",{\"1\":{\"656\":1}}],[\"bmax\",{\"1\":{\"656\":1}}],[\"bm−2\",{\"1\":{\"208\":2}}],[\"b3\",{\"1\":{\"642\":1}}],[\"b2\",{\"1\":{\"642\":2}}],[\"b1\",{\"1\":{\"642\":1}}],[\"bw\",{\"1\":{\"555\":3,\"622\":3}}],[\"b+tree\",{\"1\":{\"545\":8}}],[\"bst\",{\"1\":{\"437\":1}}],[\"bsearch\",{\"1\":{\"141\":1,\"142\":1,\"145\":1}}],[\"br\",{\"1\":{\"554\":2,\"622\":2}}],[\"braumace\",{\"1\":{\"311\":3,\"315\":1,\"322\":3,\"323\":2,\"354\":4}}],[\"break\",{\"0\":{\"565\":1},\"1\":{\"41\":1,\"44\":2,\"131\":1,\"182\":2,\"193\":1,\"200\":1,\"210\":1,\"212\":1,\"250\":2,\"559\":8,\"565\":1,\"567\":1,\"593\":1}}],[\"block\",{\"1\":{\"622\":1}}],[\"blob\",{\"1\":{\"507\":1,\"668\":1}}],[\"blog\",{\"1\":{\"311\":1,\"322\":1,\"728\":1},\"2\":{\"342\":1}}],[\"bloom\",{\"1\":{\"273\":1}}],[\"bufferedwriter\",{\"1\":{\"555\":3,\"622\":2}}],[\"bufferedreader\",{\"1\":{\"554\":3,\"622\":2}}],[\"bucketlist\",{\"1\":{\"675\":2}}],[\"bucket已经存在\",{\"1\":{\"675\":1}}],[\"bucketname\",{\"1\":{\"675\":5}}],[\"bucketexistsargs\",{\"1\":{\"675\":2}}],[\"bucketexists\",{\"1\":{\"675\":3}}],[\"bucket\",{\"0\":{\"675\":1},\"1\":{\"294\":1,\"667\":2,\"673\":6,\"675\":10,\"676\":7}}],[\"builder\",{\"1\":{\"673\":1,\"675\":5,\"676\":7,\"711\":5}}],[\"buildgraph\",{\"1\":{\"474\":1}}],[\"buildtree\",{\"1\":{\"420\":2}}],[\"build\",{\"0\":{\"744\":1},\"1\":{\"293\":1,\"420\":8,\"673\":1,\"675\":5,\"676\":7,\"711\":1,\"715\":3}}],[\"bin\",{\"1\":{\"680\":7,\"692\":1}}],[\"binarysearch\",{\"1\":{\"654\":1}}],[\"binlog\",{\"1\":{\"261\":1,\"264\":4,\"279\":1,\"283\":1}}],[\"big\",{\"1\":{\"557\":3}}],[\"bigint\",{\"1\":{\"321\":2,\"507\":1}}],[\"bi​\",{\"1\":{\"473\":2}}],[\"bilibili\",{\"1\":{\"274\":2}}],[\"bitmap\",{\"1\":{\"263\":1,\"334\":1}}],[\"bitset<10000>\",{\"1\":{\"242\":1}}],[\"bitset\",{\"1\":{\"242\":1}}],[\"bit\",{\"1\":{\"158\":1,\"334\":1}}],[\"bff\",{\"0\":{\"284\":1},\"1\":{\"279\":3,\"284\":1}}],[\"bff层实现了页面请求级的热点本地缓存\",{\"1\":{\"266\":1}}],[\"bff层负责组织业务数据模型\",{\"1\":{\"258\":1}}],[\"bfs\",{\"0\":{\"98\":1,\"99\":1,\"444\":1},\"1\":{\"44\":2,\"98\":2,\"99\":2,\"395\":1,\"444\":2,\"468\":1,\"469\":2},\"2\":{\"105\":1,\"398\":1,\"447\":1,\"471\":1}}],[\"b站竟成为最大赢家\",{\"1\":{\"274\":1}}],[\"b站评论区流量巨大\",{\"1\":{\"274\":1}}],[\"b站评论系统历史悠久\",{\"1\":{\"258\":1}}],[\"b站评论系统架构设计\",{\"0\":{\"253\":1},\"1\":{\"253\":1}}],[\"b站的评论系统逐渐组件化\",{\"1\":{\"254\":1}}],[\"b∗x\",{\"1\":{\"208\":1}}],[\"b−1\",{\"1\":{\"208\":1}}],[\"b=0\",{\"1\":{\"203\":1}}],[\"b=0\",{\"1\":{\"203\":1}}],[\"b=cn−ca\",{\"1\":{\"111\":1}}],[\"b是否连通的方法为\",{\"1\":{\"181\":1}}],[\"b不连通\",{\"1\":{\"181\":1}}],[\"b表示入点\",{\"1\":{\"174\":1}}],[\"b​\",{\"1\":{\"126\":1,\"192\":4}}],[\"bash\",{\"1\":{\"680\":7,\"692\":1}}],[\"base\",{\"1\":{\"129\":8,\"663\":3}}],[\"baomidou\",{\"1\":{\"310\":1}}],[\"balance\",{\"1\":{\"273\":1}}],[\"back\",{\"1\":{\"118\":2,\"122\":3,\"129\":2,\"131\":1,\"147\":4,\"148\":5,\"149\":4,\"150\":4,\"162\":2,\"165\":2,\"189\":2,\"195\":2,\"210\":3,\"242\":7,\"251\":3,\"456\":1}}],[\"backup\",{\"1\":{\"111\":5,\"174\":2}}],[\"bar\",{\"1\":{\"75\":2}}],[\"book\",{\"0\":{\"743\":1}}],[\"bool\",{\"1\":{\"43\":1,\"101\":1,\"108\":1,\"111\":2,\"129\":1,\"131\":2,\"145\":1,\"148\":1,\"169\":1,\"172\":1,\"173\":1,\"175\":1,\"176\":2,\"180\":1,\"181\":1,\"182\":3,\"183\":2,\"187\":1,\"189\":1,\"191\":1,\"192\":2,\"193\":1,\"200\":1,\"210\":1,\"239\":1,\"243\":2,\"247\":1,\"248\":1,\"249\":1,\"250\":2}}],[\"boolean\",{\"1\":{\"25\":2,\"313\":1,\"314\":1,\"322\":1,\"424\":2,\"426\":3,\"432\":2,\"475\":6,\"486\":2,\"487\":1,\"488\":1,\"551\":1,\"565\":1,\"567\":1,\"636\":2,\"675\":2}}],[\"bourne\",{\"1\":{\"680\":2}}],[\"bound\",{\"1\":{\"122\":1,\"144\":6,\"242\":8,\"243\":7}}],[\"bob\",{\"1\":{\"642\":1}}],[\"body是函数体\",{\"1\":{\"75\":1}}],[\"body\",{\"1\":{\"75\":1,\"354\":1}}],[\"byte\",{\"1\":{\"551\":1,\"642\":5,\"656\":2}}],[\"bytes\",{\"1\":{\"507\":10}}],[\"bytelighting\",{\"1\":{\"322\":1}}],[\"bywave\",{\"1\":{\"343\":1}}],[\"by\",{\"1\":{\"68\":2,\"203\":3,\"263\":2,\"264\":1,\"273\":2,\"274\":2,\"289\":2,\"516\":4,\"520\":1,\"521\":2,\"663\":1}}],[\"b代表进制位数\",{\"1\":{\"65\":1}}],[\"be\",{\"1\":{\"706\":1}}],[\"bean\",{\"1\":{\"673\":2}}],[\"between\",{\"1\":{\"518\":1}}],[\"bellman\",{\"0\":{\"174\":1},\"1\":{\"171\":1,\"174\":2}}],[\"beginindex\",{\"1\":{\"578\":2}}],[\"begin\",{\"1\":{\"44\":1,\"70\":1,\"74\":1,\"76\":6,\"122\":1,\"144\":4,\"150\":1,\"161\":2,\"162\":1,\"195\":1,\"242\":4,\"243\":6,\"251\":1,\"541\":1,\"640\":5,\"642\":3}}],[\"bestfirst\",{\"1\":{\"34\":1}}],[\"b走到t后再从a这条路走到t\",{\"1\":{\"41\":1}}],[\"b\",{\"0\":{\"67\":1},\"1\":{\"41\":3,\"43\":8,\"65\":1,\"68\":3,\"77\":1,\"93\":5,\"99\":2,\"111\":8,\"118\":4,\"123\":6,\"124\":8,\"125\":3,\"126\":6,\"129\":8,\"134\":4,\"144\":4,\"147\":14,\"148\":28,\"149\":11,\"150\":11,\"154\":2,\"158\":5,\"165\":12,\"172\":8,\"173\":2,\"174\":9,\"175\":3,\"178\":1,\"180\":5,\"181\":6,\"192\":13,\"196\":2,\"197\":7,\"201\":2,\"203\":17,\"204\":9,\"207\":2,\"208\":13,\"209\":16,\"210\":8,\"235\":2,\"236\":1,\"237\":4,\"243\":6,\"277\":1,\"289\":1,\"431\":2,\"475\":1,\"529\":1,\"530\":1,\"551\":1,\"552\":16,\"553\":4,\"557\":21,\"558\":5,\"561\":4,\"563\":4,\"570\":1,\"571\":2,\"573\":1,\"577\":4,\"578\":3,\"594\":3,\"595\":6,\"628\":2,\"642\":7,\"645\":1,\"653\":4,\"702\":2}}],[\"与评论主题的对应关系\",{\"1\":{\"289\":1}}],[\"与评论区\",{\"1\":{\"263\":1}}],[\"与推荐排序不同\",{\"1\":{\"273\":1}}],[\"与模数\",{\"1\":{\"208\":1}}],[\"与一个各位都为零的数值相与\",{\"1\":{\"158\":1}}],[\"与快排不同\",{\"1\":{\"138\":1}}],[\"与min\",{\"1\":{\"76\":1}}],[\"与第二种迷宫差不多\",{\"1\":{\"57\":1}}],[\"与上题一样\",{\"1\":{\"56\":1}}],[\"与上题类似\",{\"1\":{\"49\":1}}],[\"与上下左右方向数字交换的行动记录为\",{\"1\":{\"44\":1}}],[\"与其上\",{\"1\":{\"44\":1,\"99\":1}}],[\"与点\",{\"1\":{\"43\":1}}],[\"与已经遍历过的节点\",{\"1\":{\"35\":1}}],[\"与\",{\"0\":{\"71\":1,\"76\":1,\"615\":1,\"636\":1},\"1\":{\"34\":1,\"76\":1,\"94\":2,\"157\":1,\"158\":5,\"207\":1,\"208\":1,\"261\":2,\"268\":1,\"401\":1,\"431\":1,\"507\":1,\"520\":1,\"558\":1,\"603\":1}}],[\"32\",{\"1\":{\"585\":1}}],[\"32767\",{\"1\":{\"507\":1}}],[\"32768\",{\"1\":{\"507\":1}}],[\"31\",{\"1\":{\"507\":2}}],[\"310\",{\"1\":{\"127\":1}}],[\"38\",{\"1\":{\"507\":1}}],[\"3bytes\",{\"1\":{\"507\":1}}],[\"33\",{\"1\":{\"570\":1}}],[\"3306\",{\"1\":{\"493\":1}}],[\"337\",{\"1\":{\"274\":1}}],[\"3553317334228624372l\",{\"1\":{\"311\":2}}],[\"3种初始化\",{\"0\":{\"303\":1}}],[\"36kr\",{\"1\":{\"274\":1}}],[\"308\",{\"1\":{\"507\":1}}],[\"3010\",{\"1\":{\"124\":1}}],[\"3000\",{\"1\":{\"124\":1}}],[\"30\",{\"1\":{\"109\":1,\"552\":1,\"573\":1,\"715\":2}}],[\"3s\",{\"1\":{\"82\":1}}],[\"3×3\",{\"1\":{\"44\":3,\"99\":3}}],[\"3\",{\"0\":{\"34\":1,\"35\":1,\"40\":1,\"64\":1,\"91\":1,\"118\":1,\"123\":1,\"127\":1,\"139\":1,\"140\":1,\"143\":1,\"144\":2,\"145\":1,\"149\":1,\"154\":1,\"159\":1,\"169\":1,\"174\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":2,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"209\":1,\"216\":1,\"228\":1,\"229\":1,\"230\":1,\"236\":1,\"241\":1,\"249\":1,\"257\":1,\"258\":1,\"259\":2,\"260\":1,\"261\":1,\"274\":1,\"300\":1,\"310\":1,\"315\":1,\"322\":1,\"331\":1,\"501\":1,\"507\":1,\"509\":1,\"511\":1,\"512\":1,\"513\":1,\"514\":2,\"518\":1,\"526\":1,\"531\":1,\"532\":1,\"536\":1,\"542\":1,\"546\":1,\"553\":1,\"559\":1,\"561\":1,\"562\":1,\"563\":2,\"564\":1,\"565\":1,\"566\":1,\"567\":1,\"572\":1,\"574\":1,\"575\":1,\"579\":1,\"585\":1,\"592\":1,\"593\":1,\"594\":1,\"601\":1,\"606\":1,\"611\":1,\"617\":1,\"635\":1,\"636\":1,\"687\":1,\"691\":1,\"692\":1,\"693\":1,\"697\":1,\"707\":1,\"712\":1,\"713\":1,\"714\":1,\"715\":1,\"721\":1},\"1\":{\"41\":1,\"44\":21,\"47\":1,\"54\":1,\"63\":1,\"76\":1,\"77\":2,\"81\":1,\"82\":9,\"87\":1,\"89\":1,\"93\":5,\"94\":2,\"99\":15,\"101\":7,\"107\":5,\"108\":7,\"109\":9,\"121\":1,\"124\":2,\"145\":1,\"147\":1,\"148\":1,\"158\":3,\"159\":1,\"165\":1,\"174\":1,\"175\":1,\"181\":1,\"191\":2,\"205\":1,\"210\":1,\"215\":1,\"223\":1,\"237\":2,\"242\":1,\"243\":1,\"255\":2,\"259\":1,\"263\":3,\"264\":1,\"266\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":2,\"274\":1,\"289\":2,\"302\":2,\"310\":2,\"323\":2,\"352\":4,\"419\":2,\"495\":1,\"507\":5,\"545\":1,\"551\":2,\"553\":3,\"555\":1,\"557\":1,\"558\":1,\"559\":1,\"561\":1,\"563\":2,\"571\":1,\"573\":3,\"574\":1,\"587\":1,\"588\":1,\"591\":1,\"593\":1,\"595\":2,\"602\":1,\"624\":1,\"625\":1,\"626\":1,\"628\":2,\"676\":1,\"692\":2,\"695\":1,\"696\":1,\"708\":1,\"712\":1,\"715\":1,\"727\":1}}],[\"每隔一定时间\",{\"1\":{\"722\":1}}],[\"每调用一次就会创建一个新的对象\",{\"1\":{\"642\":1}}],[\"每当掌握一个新功能时\",{\"1\":{\"556\":1}}],[\"每一个节点\",{\"1\":{\"545\":1}}],[\"每一层的节点并不是直接存储了某个字符\",{\"1\":{\"425\":1}}],[\"每一层都从左到右遍历\",{\"1\":{\"390\":1}}],[\"每页显示条数\",{\"1\":{\"522\":1}}],[\"每页显示记录数\",{\"1\":{\"522\":1}}],[\"每有一个新鲜橘子被腐烂\",{\"1\":{\"468\":1}}],[\"每分钟\",{\"1\":{\"467\":1}}],[\"每走过一个节点\",{\"1\":{\"444\":1}}],[\"每发现一个新岛屿\",{\"1\":{\"443\":1}}],[\"每遍历一层时间+1\",{\"1\":{\"469\":1}}],[\"每遍历一层\",{\"1\":{\"402\":1}}],[\"每遍历一个节点就将当前节点的右指针更新为上一个节点\",{\"1\":{\"378\":1}}],[\"每遍历一个节点\",{\"1\":{\"378\":1}}],[\"每\",{\"1\":{\"204\":1}}],[\"每组询问给定三个整数\",{\"1\":{\"209\":1}}],[\"每组物品有若干个\",{\"1\":{\"119\":1}}],[\"每组数据包括三个整数\",{\"1\":{\"83\":1}}],[\"每件物品有有限个\",{\"1\":{\"118\":1}}],[\"每件物品只能使用无限次\",{\"1\":{\"117\":1}}],[\"每件物品只能使用一次\",{\"1\":{\"116\":1}}],[\"每辆车所搭载的重量\",{\"1\":{\"110\":1}}],[\"每辆缆车上的小猫的重量之和不能超过\",{\"1\":{\"110\":1}}],[\"每只猫的重量\",{\"1\":{\"110\":1}}],[\"每租用一辆缆车\",{\"1\":{\"110\":1}}],[\"每行中\",{\"1\":{\"682\":1}}],[\"每行一个整数\",{\"1\":{\"110\":1}}],[\"每行\",{\"1\":{\"108\":1,\"109\":1}}],[\"每行输出一个整数作为结果\",{\"1\":{\"125\":1}}],[\"每行输出一种方案\",{\"1\":{\"107\":1}}],[\"每行输入一组数据\",{\"1\":{\"83\":1}}],[\"每行包含一个字符串和一个整数\",{\"1\":{\"125\":1}}],[\"每行包含一个字符串\",{\"1\":{\"125\":1}}],[\"每行包含一个大写字母\",{\"1\":{\"94\":1}}],[\"每行包含\",{\"1\":{\"98\":1}}],[\"每行包含三个整数\",{\"1\":{\"43\":1,\"94\":1}}],[\"每行为\",{\"1\":{\"93\":1}}],[\"每行有两个数\",{\"1\":{\"93\":1}}],[\"每个参数分别用双引号括起来的字符串\",{\"1\":{\"693\":1}}],[\"每个\",{\"1\":{\"673\":1}}],[\"每个对象都包含了数据本身以及元数据\",{\"1\":{\"667\":1}}],[\"每个对字符串进行的单个字符的插入\",{\"1\":{\"125\":1}}],[\"每个类可以实现多个接口\",{\"1\":{\"606\":1}}],[\"每个类只能继承一个类\",{\"1\":{\"601\":1}}],[\"每个接口可以继承多个接口\",{\"1\":{\"605\":1}}],[\"每个源文件中\",{\"1\":{\"599\":1}}],[\"每个常用字符都对应一个\",{\"1\":{\"577\":1}}],[\"每个元素都是大小为4的数组\",{\"1\":{\"573\":1}}],[\"每个元素是含有4个整数的数组\",{\"1\":{\"573\":1}}],[\"每个子节点也会存储\",{\"1\":{\"545\":1}}],[\"每个烂橘子都会去扩散腐烂周边的新鲜橘子\",{\"1\":{\"468\":1}}],[\"每个单元格可以有以下三个值之一\",{\"1\":{\"467\":1}}],[\"每个搜索到的\",{\"1\":{\"444\":1}}],[\"每个用户的盐值都是随机生成的\",{\"1\":{\"323\":1}}],[\"每个人看到的都不相同\",{\"1\":{\"273\":1}}],[\"每个人只有两种状态\",{\"1\":{\"134\":1}}],[\"每个正整数都能够以唯一的方式表示成它的质因数的乘积\",{\"1\":{\"188\":1}}],[\"每个数都要用到且只出现一次\",{\"1\":{\"111\":1}}],[\"每个方案占一行\",{\"1\":{\"101\":1}}],[\"每个目标都有一个价值\",{\"1\":{\"83\":1}}],[\"每个点需要记录达到该点的前一个点的位置\",{\"1\":{\"32\":1}}],[\"每找到一个数量加一\",{\"1\":{\"49\":1}}],[\"每条最短路中至少要包含一条边\",{\"1\":{\"43\":1}}],[\"每次插入新的行记录时\",{\"1\":{\"506\":1}}],[\"每次遇到一个岛屿中的陆地\",{\"1\":{\"443\":1}}],[\"每次请求都不会命中缓存\",{\"1\":{\"334\":1}}],[\"每次可以移动一步\",{\"1\":{\"216\":1}}],[\"每次可以任选一堆\",{\"1\":{\"214\":1}}],[\"每次异或操作\",{\"1\":{\"214\":1}}],[\"每次将\",{\"1\":{\"182\":1}}],[\"每次将区间长度缩小一半\",{\"1\":{\"140\":1}}],[\"每次迭代选择一条不在集合内的权值最短的边\",{\"1\":{\"181\":1}}],[\"每次迭代找到不在连通块中的距离最近的点\",{\"1\":{\"180\":1}}],[\"每次循环遍历所有边\",{\"1\":{\"174\":1}}],[\"每次循环都先将\",{\"1\":{\"137\":1}}],[\"每次备份一下\",{\"1\":{\"174\":1}}],[\"每次只需判断答案是否需要更新\",{\"1\":{\"143\":1}}],[\"每次只能向上下左右四个方向移动\",{\"1\":{\"55\":1}}],[\"每次比较\",{\"1\":{\"138\":1}}],[\"每次询问给出一个字符串和一个操作次数上限\",{\"1\":{\"125\":1}}],[\"每次递归的同时也对\",{\"1\":{\"111\":1}}],[\"每次递归之后都要回溯\",{\"1\":{\"55\":1}}],[\"每次当第三段符合时\",{\"1\":{\"82\":1}}],[\"每次前缀和都取模\",{\"1\":{\"81\":1}}],[\"每次用\",{\"1\":{\"81\":1}}],[\"每次都让较大的数对较小数取模\",{\"1\":{\"197\":1}}],[\"每次都将面积加一\",{\"1\":{\"50\":1}}],[\"每次都从优先队列中选出代价最小的作为下一个遍历的节点\",{\"1\":{\"33\":1}}],[\"每次从优先队列中选取\",{\"1\":{\"35\":1}}],[\"每次始终选取到终点移动代价最小\",{\"1\":{\"34\":1}}],[\"还做了一些事情\",{\"1\":{\"707\":1}}],[\"还有另外一种获取配置项的方式\",{\"1\":{\"704\":1}}],[\"还提供可视化的操作管理界面\",{\"1\":{\"668\":1}}],[\"还支持\",{\"1\":{\"668\":1}}],[\"还应先完成课程\",{\"1\":{\"474\":1}}],[\"还应用了内部稀疏数据的\",{\"1\":{\"273\":1}}],[\"还应该想办法记录这个岛屿的⾯积\",{\"1\":{\"50\":1}}],[\"还可以支持范围查询\",{\"1\":{\"545\":1}}],[\"还可以表示为\",{\"1\":{\"111\":1}}],[\"还可能遇到\",{\"1\":{\"273\":1}}],[\"还包括中文的空格字符\",{\"1\":{\"642\":1}}],[\"还包括楼中楼\",{\"1\":{\"272\":1}}],[\"还包含了许多用于操作的函数\",{\"1\":{\"63\":1}}],[\"还作为数据库\",{\"1\":{\"261\":1}}],[\"还需要校验对应评论的状态\",{\"1\":{\"269\":1}}],[\"还需要补上\",{\"1\":{\"200\":1}}],[\"还需要一个优先队列结构\",{\"1\":{\"33\":1}}],[\"还是在\",{\"1\":{\"703\":1}}],[\"还是\",{\"1\":{\"143\":1,\"158\":1,\"188\":1}}],[\"还原\",{\"1\":{\"99\":1}}],[\"还要实现应用之间的互操作\",{\"1\":{\"14\":1}}],[\"在这个路径下\",{\"1\":{\"702\":1}}],[\"在这种情况下\",{\"1\":{\"667\":1}}],[\"在这种时候就可能需要一些代理手段\",{\"1\":{\"343\":1}}],[\"在执行\",{\"1\":{\"692\":1}}],[\"在执行算法的过程中\",{\"1\":{\"32\":1}}],[\"在服务安装后\",{\"1\":{\"668\":1}}],[\"在服务器上搭建了一个对象存储服务\",{\"1\":{\"350\":1}}],[\"在很早的时候就采用了\",{\"1\":{\"668\":1}}],[\"在标准硬件上\",{\"1\":{\"668\":1}}],[\"在同目录下创建\",{\"1\":{\"663\":1}}],[\"在同一个包中可以访问\",{\"1\":{\"600\":1}}],[\"在同一个类中存在多个函数\",{\"1\":{\"595\":1}}],[\"在同一个数据库服务器中\",{\"1\":{\"500\":1}}],[\"在同一行用空格隔开\",{\"1\":{\"109\":1}}],[\"在浏览器输入\",{\"1\":{\"662\":1}}],[\"在堆中加入元素\",{\"1\":{\"651\":1}}],[\"在map中若存在value\",{\"1\":{\"647\":1}}],[\"在map中若存在key\",{\"1\":{\"647\":1}}],[\"在map中加入键值对<key\",{\"1\":{\"647\":1}}],[\"在mysql数据库当中\",{\"1\":{\"506\":1}}],[\"在treeset类中\",{\"1\":{\"646\":1}}],[\"在index位置插一个元素e\",{\"1\":{\"645\":1}}],[\"在in之后的列表中的值\",{\"1\":{\"518\":1}}],[\"在尾部添加一个元素e\",{\"1\":{\"645\":1}}],[\"在函数定义时抛出一些可能的异常\",{\"1\":{\"621\":1}}],[\"在函数内抛出一个异常\",{\"1\":{\"621\":1}}],[\"在非法或不适当的时间调用方法时产生的信号\",{\"1\":{\"618\":1}}],[\"在队尾添加元素\",{\"1\":{\"611\":1}}],[\"在末尾添加一个元素\",{\"1\":{\"609\":1}}],[\"在建表时\",{\"1\":{\"546\":1}}],[\"在实际的业务开发中\",{\"1\":{\"540\":1}}],[\"在指定的集合范围之内\",{\"1\":{\"536\":1}}],[\"在查询时给多表查询加上连接查询的条件\",{\"1\":{\"529\":1}}],[\"在多表查询时\",{\"1\":{\"529\":1}}],[\"在比如\",{\"1\":{\"526\":1}}],[\"在任意一方加入外键\",{\"1\":{\"525\":1}}],[\"在现在的企业开发中\",{\"1\":{\"524\":1}}],[\"在业务层逻辑中\",{\"1\":{\"524\":1}}],[\"在数据库表中多的一方\",{\"1\":{\"524\":1}}],[\"在进行数据库表结构设计时\",{\"1\":{\"523\":1}}],[\"在根据指定的列统计的时候\",{\"1\":{\"519\":1}}],[\"在某个范围之内\",{\"1\":{\"518\":1}}],[\"在sql语句当中构造条件的运算符分为两类\",{\"1\":{\"518\":1}}],[\"在基本查询的\",{\"1\":{\"517\":1}}],[\"在修改数据时\",{\"1\":{\"513\":1}}],[\"在命令行中输入密码\",{\"1\":{\"493\":1}}],[\"在搜索完当前所能走到的所有节点后\",{\"1\":{\"474\":1}}],[\"在学习课程\",{\"1\":{\"474\":1}}],[\"在选修某些课程之前需要一些先修课程\",{\"1\":{\"473\":1}}],[\"在全为烂橘子的情况下要返回\",{\"1\":{\"468\":1}}],[\"在每层遍历的时候\",{\"1\":{\"468\":1}}],[\"在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点\",{\"1\":{\"121\":1}}],[\"在给定的\",{\"1\":{\"467\":1}}],[\"在两个字符串上游走\",{\"1\":{\"450\":1}}],[\"在两个迭代器\",{\"1\":{\"243\":1}}],[\"在之前的搜索中已经加入到集合了\",{\"1\":{\"445\":1}}],[\"在并查集中进行合并\",{\"1\":{\"445\":1}}],[\"在广度优先搜索的过程中\",{\"1\":{\"444\":1}}],[\"在递归调用左子树时\",{\"1\":{\"486\":1}}],[\"在递归判断过程中存在短路现象\",{\"1\":{\"431\":1}}],[\"在递归的方法中\",{\"1\":{\"384\":1}}],[\"在检索之前已经插入\",{\"1\":{\"424\":1}}],[\"在中序遍历中搜索根节点\",{\"1\":{\"419\":1}}],[\"在前缀树中\",{\"1\":{\"424\":1}}],[\"在前面的方法中\",{\"1\":{\"365\":1}}],[\"在前期花足够时间去反复思考设计\",{\"1\":{\"278\":1}}],[\"在上方菜单中\",{\"1\":{\"358\":1}}],[\"在上一级缓存未命中或者出现网络错误后\",{\"1\":{\"267\":1}}],[\"在首次启动时\",{\"1\":{\"352\":1}}],[\"在宝塔上配置\",{\"1\":{\"346\":1}}],[\"在其它设置不变的情况下\",{\"1\":{\"346\":1}}],[\"在用户组里面\",{\"1\":{\"352\":1}}],[\"在用户注册的时候\",{\"1\":{\"334\":1}}],[\"在用户登录成功之后才会保存到\",{\"1\":{\"310\":1}}],[\"在集合中删除元素e\",{\"1\":{\"646\":1}}],[\"在集合中添加元素e\",{\"1\":{\"646\":1}}],[\"在集合中\",{\"1\":{\"334\":1}}],[\"在验证用户登录时\",{\"1\":{\"323\":1}}],[\"在存储用户密码时\",{\"1\":{\"323\":1}}],[\"在生成实体类时用\",{\"1\":{\"322\":1}}],[\"在请求头中带上\",{\"1\":{\"310\":1}}],[\"在信息脱敏技术中\",{\"1\":{\"309\":1}}],[\"在地址栏输入\",{\"1\":{\"302\":1}}],[\"在内存中使用\",{\"1\":{\"294\":1}}],[\"在写入要尽可能的顺序自增\",{\"1\":{\"289\":1}}],[\"在入\",{\"1\":{\"283\":1}}],[\"在动手设计前\",{\"1\":{\"278\":1}}],[\"在工程上实现了架构的统一\",{\"1\":{\"273\":1}}],[\"在工程落地层面尽可能还原理想的排序算法设计\",{\"1\":{\"273\":1}}],[\"在楼中楼\",{\"1\":{\"273\":1}}],[\"在评论数过百万甚至千万的评论区\",{\"1\":{\"273\":1}}],[\"在架构上\",{\"1\":{\"273\":1}}],[\"在系统设计上也提出了不同层面的要求\",{\"1\":{\"273\":1}}],[\"在a事务中读取的评论状态\",{\"1\":{\"270\":1}}],[\"在设计层面主要有两方面实践\",{\"1\":{\"269\":1}}],[\"在客户端不能展现\",{\"1\":{\"269\":1}}],[\"在功能层面\",{\"1\":{\"267\":1}}],[\"在读取评论区基础信息阶段探测热点\",{\"1\":{\"266\":1}}],[\"在吞吐方面具备更大的弹性\",{\"1\":{\"266\":1}}],[\"在处理完一些必要校验逻辑之后\",{\"1\":{\"261\":1}}],[\"在b站\",{\"1\":{\"254\":1}}],[\"在有序\",{\"1\":{\"243\":2}}],[\"在有向图游戏中\",{\"1\":{\"218\":1}}],[\"在哈希表中查询某个数是否存在\",{\"1\":{\"239\":1}}],[\"在满足\",{\"1\":{\"231\":1}}],[\"在节点k的右边插入一个数x\",{\"1\":{\"224\":1}}],[\"在算法竞赛中一般不需要考虑删除的那个节点该如何处理\",{\"1\":{\"223\":1}}],[\"在算法运行的过程中\",{\"1\":{\"33\":1}}],[\"在链表头插入一个数a\",{\"1\":{\"223\":1}}],[\"在起点上放有一枚棋子\",{\"1\":{\"216\":1}}],[\"在游戏进程的任意时刻\",{\"1\":{\"215\":1}}],[\"在游戏过程中\",{\"1\":{\"44\":1,\"99\":1}}],[\"在图论中\",{\"1\":{\"179\":1,\"183\":1}}],[\"在图中选择若干条边把图中的所有节点连接起来\",{\"1\":{\"179\":1}}],[\"在保存最短路径的数组中\",{\"1\":{\"175\":1}}],[\"在还未确定最短路的点中\",{\"1\":{\"172\":1}}],[\"在所有子节点更新后再更新\",{\"1\":{\"134\":1}}],[\"在字符串\",{\"1\":{\"126\":1}}],[\"在字符串中的位置\",{\"1\":{\"99\":1}}],[\"在网格中的位置\",{\"1\":{\"99\":1}}],[\"在由\",{\"1\":{\"64\":1}}],[\"在构造或者拼接\",{\"1\":{\"63\":1}}],[\"在面对具体题目时\",{\"1\":{\"47\":1}}],[\"在一段时间内不会让其他应用获取注册信息\",{\"1\":{\"717\":1}}],[\"在一次搜索中\",{\"1\":{\"474\":1}}],[\"在一个函数内部\",{\"1\":{\"596\":1}}],[\"在一个数组中查找最长的相同连续子序列\",{\"0\":{\"64\":1}}],[\"在一个\",{\"1\":{\"44\":1,\"99\":1}}],[\"在一些情况下\",{\"1\":{\"33\":1,\"34\":1}}],[\"在另外一个极端情况下\",{\"1\":{\"36\":1}}],[\"在极端情况下\",{\"1\":{\"36\":1}}],[\"在\",{\"1\":{\"33\":1,\"35\":2,\"55\":1,\"289\":1,\"310\":1,\"311\":1,\"313\":1,\"346\":1,\"352\":1,\"354\":1,\"468\":1,\"624\":2,\"660\":1,\"663\":1,\"673\":1,\"707\":1}}],[\"dl\",{\"1\":{\"660\":1,\"662\":1}}],[\"durability\",{\"1\":{\"542\":2}}],[\"dcl\",{\"1\":{\"496\":2}}],[\"dql\",{\"0\":{\"515\":1},\"1\":{\"496\":2,\"516\":1,\"517\":1}}],[\"dmin\",{\"1\":{\"656\":1}}],[\"dmax\",{\"1\":{\"656\":1}}],[\"dml英文全称是\",{\"1\":{\"511\":1}}],[\"dml\",{\"0\":{\"511\":1},\"1\":{\"496\":2}}],[\"dmg\",{\"1\":{\"347\":1}}],[\"ddl\",{\"0\":{\"497\":1},\"1\":{\"496\":2,\"498\":2}}],[\"dd\",{\"1\":{\"469\":2,\"507\":3}}],[\"das\",{\"1\":{\"668\":1}}],[\"day\",{\"1\":{\"559\":2}}],[\"daemon\",{\"1\":{\"353\":2}}],[\"date\",{\"1\":{\"507\":1}}],[\"datetime\",{\"1\":{\"321\":3,\"507\":1}}],[\"datacenter\",{\"1\":{\"702\":2}}],[\"database\",{\"0\":{\"747\":1},\"1\":{\"499\":2,\"500\":3,\"502\":3}}],[\"databases\",{\"1\":{\"499\":1}}],[\"data\",{\"1\":{\"309\":1,\"311\":2,\"496\":4,\"498\":1,\"511\":1,\"522\":1,\"660\":7,\"661\":1,\"662\":2,\"663\":1,\"673\":1}}],[\"datapage\",{\"1\":{\"289\":1}}],[\"drop\",{\"1\":{\"293\":1,\"502\":2,\"509\":1,\"510\":1,\"546\":1}}],[\"dgraph\",{\"1\":{\"289\":1}}],[\"db01\",{\"1\":{\"502\":1}}],[\"db\",{\"1\":{\"281\":2,\"289\":1,\"310\":1,\"352\":1}}],[\"declare\",{\"1\":{\"687\":2,\"689\":2}}],[\"decimal\",{\"1\":{\"507\":1}}],[\"dev\",{\"1\":{\"662\":2}}],[\"deeptostring\",{\"1\":{\"575\":1}}],[\"deployment\",{\"1\":{\"706\":1}}],[\"deprecated\",{\"1\":{\"625\":1}}],[\"dept\",{\"1\":{\"529\":4}}],[\"depth\",{\"1\":{\"389\":4}}],[\"dependency>\",{\"1\":{\"323\":1,\"672\":1}}],[\"dependency\",{\"1\":{\"279\":1}}],[\"description>\",{\"1\":{\"663\":1}}],[\"description=cloudreve\",{\"1\":{\"353\":1}}],[\"desc\",{\"1\":{\"508\":1,\"521\":1}}],[\"design\",{\"0\":{\"740\":1},\"1\":{\"300\":2,\"302\":3,\"328\":1}}],[\"dead\",{\"1\":{\"345\":1}}],[\"def\",{\"1\":{\"695\":2,\"696\":1,\"697\":1,\"698\":1}}],[\"definition\",{\"1\":{\"496\":1,\"498\":1}}],[\"define\",{\"1\":{\"43\":4,\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"81\":1,\"82\":1,\"83\":1,\"98\":1,\"144\":1,\"173\":1,\"180\":1,\"192\":1,\"204\":1,\"212\":1,\"251\":1}}],[\"defaulteurekaservercontext\",{\"1\":{\"720\":2}}],[\"defaulteurekaserverconfig\",{\"1\":{\"704\":1,\"705\":2,\"707\":6,\"708\":3}}],[\"defaulteurekatransportconfig\",{\"1\":{\"714\":1}}],[\"defaulteurekaclientconfig\",{\"1\":{\"714\":1}}],[\"defaultconfigfilename\",{\"1\":{\"706\":1}}],[\"defaultvalue\",{\"1\":{\"647\":1}}],[\"default\",{\"1\":{\"315\":1,\"321\":6,\"506\":1,\"559\":1,\"707\":1}}],[\"details\",{\"1\":{\"311\":1,\"728\":1}}],[\"deleteuser\",{\"1\":{\"314\":1}}],[\"deletemapping\",{\"1\":{\"314\":1}}],[\"delete\",{\"0\":{\"514\":1},\"1\":{\"310\":4,\"314\":1,\"511\":1,\"514\":4,\"534\":1,\"544\":1}}],[\"demo\",{\"1\":{\"298\":1,\"706\":1}}],[\"deque接口\",{\"1\":{\"648\":1}}],[\"deque<e>\",{\"1\":{\"648\":1,\"650\":1}}],[\"deque\",{\"0\":{\"650\":1},\"1\":{\"242\":1,\"648\":3,\"650\":2}}],[\"doocs\",{\"1\":{\"419\":1}}],[\"document\",{\"1\":{\"626\":1}}],[\"documentation=https\",{\"1\":{\"353\":1}}],[\"docs\",{\"1\":{\"353\":1,\"668\":1}}],[\"docker\",{\"0\":{\"16\":1,\"661\":1},\"1\":{\"661\":4}}],[\"docker等等\",{\"1\":{\"7\":1}}],[\"domain\",{\"1\":{\"270\":1,\"311\":1,\"322\":1}}],[\"download\",{\"1\":{\"659\":1}}],[\"down和up只会执行其中一个\",{\"1\":{\"237\":1}}],[\"down\",{\"1\":{\"237\":6}}],[\"double\",{\"1\":{\"145\":6,\"507\":1,\"551\":2,\"553\":1,\"554\":1,\"555\":1,\"570\":2,\"578\":2,\"595\":4,\"656\":2}}],[\"do\",{\"0\":{\"562\":1},\"1\":{\"137\":2,\"562\":4}}],[\"dp\",{\"1\":{\"127\":7,\"129\":3,\"134\":14}}],[\"dfs思路\",{\"1\":{\"182\":1}}],[\"dfs之迷宫问题\",{\"0\":{\"54\":1}}],[\"dfs之岛屿问题\",{\"0\":{\"47\":1}}],[\"dfs\",{\"0\":{\"101\":1,\"443\":1},\"1\":{\"47\":2,\"48\":4,\"49\":7,\"50\":7,\"54\":2,\"55\":4,\"56\":3,\"57\":4,\"58\":1,\"75\":3,\"101\":3,\"107\":4,\"108\":3,\"109\":3,\"110\":4,\"111\":6,\"134\":3,\"165\":4,\"167\":2,\"182\":4,\"363\":4,\"389\":4,\"414\":4,\"438\":4,\"443\":10,\"474\":1,\"475\":3,\"480\":2,\"481\":4,\"488\":4},\"2\":{\"53\":1,\"60\":1,\"105\":1,\"447\":1,\"477\":1}}],[\"direct\",{\"1\":{\"715\":2}}],[\"discoveryclient\",{\"1\":{\"714\":1,\"715\":5}}],[\"distinct\",{\"1\":{\"517\":1}}],[\"distance+w\",{\"1\":{\"43\":1}}],[\"distance\",{\"1\":{\"43\":5,\"125\":2,\"165\":3,\"173\":3,\"236\":1}}],[\"dist\",{\"1\":{\"41\":4,\"43\":14,\"44\":7,\"99\":3,\"165\":7,\"172\":11,\"173\":9,\"174\":19,\"175\":10,\"176\":6,\"180\":10}}],[\"different\",{\"1\":{\"706\":1}}],[\"diameterofbinarytree\",{\"1\":{\"414\":1}}],[\"digestutils\",{\"1\":{\"310\":1,\"323\":1}}],[\"divisors\",{\"1\":{\"195\":1}}],[\"divisor\",{\"1\":{\"189\":1}}],[\"divide\",{\"1\":{\"188\":1}}],[\"div\",{\"1\":{\"150\":2}}],[\"dijkstra算法\",{\"0\":{\"172\":1}}],[\"dijkstra\",{\"0\":{\"33\":1},\"1\":{\"33\":3,\"34\":1,\"36\":1,\"43\":3,\"172\":2,\"173\":1}}],[\"d2\",{\"1\":{\"39\":2}}],[\"d\",{\"1\":{\"38\":1,\"39\":2,\"40\":1,\"41\":13,\"43\":1,\"44\":1,\"68\":3,\"71\":2,\"75\":1,\"77\":1,\"93\":5,\"98\":8,\"99\":5,\"101\":1,\"129\":1,\"134\":4,\"147\":1,\"148\":2,\"149\":1,\"165\":4,\"169\":3,\"178\":7,\"180\":1,\"203\":5,\"204\":7,\"231\":1,\"236\":6,\"242\":1,\"302\":1,\"469\":3,\"551\":1,\"555\":1,\"557\":25,\"567\":1,\"570\":1,\"571\":1,\"572\":5,\"573\":1,\"574\":1,\"578\":2,\"584\":1,\"593\":2,\"600\":2,\"601\":2,\"642\":3,\"662\":2,\"676\":3,\"715\":3}}],[\"dynamicpropertyfactory\",{\"1\":{\"706\":2,\"707\":3,\"708\":2,\"714\":1}}],[\"dynamicstringproperty\",{\"1\":{\"706\":1}}],[\"dy\",{\"1\":{\"38\":2,\"39\":3,\"40\":3,\"44\":2,\"48\":4,\"49\":2,\"55\":2,\"56\":2,\"57\":2,\"98\":2,\"99\":2,\"444\":2,\"469\":2}}],[\"dx\",{\"1\":{\"38\":2,\"39\":3,\"40\":3,\"44\":2,\"48\":4,\"49\":2,\"55\":2,\"56\":2,\"57\":2,\"98\":2,\"99\":2,\"444\":2,\"469\":2}}],[\"这部分是将标准错误输出\",{\"1\":{\"660\":1}}],[\"这部分是将标准输出\",{\"1\":{\"660\":1}}],[\"这意味着\",{\"1\":{\"660\":1}}],[\"这条命令的stdout\",{\"1\":{\"693\":1}}],[\"这条路径可能经过也可能不经过根节点\",{\"1\":{\"412\":1}}],[\"这条边不要\",{\"1\":{\"181\":1}}],[\"这时\",{\"1\":{\"346\":1}}],[\"这时候\",{\"1\":{\"294\":1}}],[\"这是一行注释\",{\"1\":{\"682\":1}}],[\"这是一个\",{\"1\":{\"660\":1}}],[\"这是一种c语言中的转换方式\",{\"1\":{\"71\":1}}],[\"这是非常不安全的\",{\"1\":{\"313\":1}}],[\"这比物理删除更加安全\",{\"1\":{\"310\":1}}],[\"这就意味着个人也可以基于\",{\"1\":{\"667\":1}}],[\"这就是\",{\"1\":{\"450\":1}}],[\"这就是缓存穿透\",{\"1\":{\"334\":1}}],[\"这就是做一个削峰的处理\",{\"1\":{\"282\":1}}],[\"这就要求缓存命中率要非常高\",{\"1\":{\"273\":1}}],[\"这就对数据一致性\",{\"1\":{\"269\":1}}],[\"这些配置项如果在配置文件中有\",{\"1\":{\"708\":1}}],[\"这些是检查型异常\",{\"1\":{\"617\":1}}],[\"这些异常一般是由程序逻辑错误引起的\",{\"1\":{\"617\":1}}],[\"这些异常是非检查型异常\",{\"1\":{\"617\":1}}],[\"这些异常发生时\",{\"1\":{\"615\":1}}],[\"这些数组的元素是含有30个整数的数组\",{\"1\":{\"573\":1}}],[\"这些关系型数据是发布时已经确定的\",{\"1\":{\"263\":1}}],[\"这些人的编号为\",{\"1\":{\"93\":1}}],[\"这一数据结构有相当多的应用情景\",{\"1\":{\"424\":1}}],[\"这一步的意思是\",{\"1\":{\"346\":2}}],[\"这一步类似完全背包的推导\",{\"1\":{\"128\":1}}],[\"这一层抽象把评论的本身的内容列表处理\",{\"1\":{\"279\":1}}],[\"这一层的职责就是接收规则机返回的各种决策并执行\",{\"1\":{\"273\":1}}],[\"这一层是较少做业务逻辑变更的\",{\"1\":{\"260\":1}}],[\"这一阶段\",{\"1\":{\"273\":1}}],[\"这一套流程对外提供了一个原子化的数据读取功能\",{\"1\":{\"261\":1}}],[\"这一项\",{\"1\":{\"200\":1}}],[\"这一项在\",{\"1\":{\"200\":1}}],[\"这个里面会初始化注册表\",{\"1\":{\"722\":1}}],[\"这个里面就是启动了一个定时任务\",{\"1\":{\"722\":1}}],[\"这个里面就会根据\",{\"1\":{\"715\":1}}],[\"这个集合不包含本地节点的\",{\"1\":{\"722\":1}}],[\"这个集合指当前已经在连通块中的所有点\",{\"1\":{\"180\":1}}],[\"这个监听器监听到状态改变时\",{\"1\":{\"715\":1}}],[\"这个发送心跳的操作由一个\",{\"1\":{\"715\":1}}],[\"这个刷新的操作是由一个\",{\"1\":{\"715\":1}}],[\"这个文件就是\",{\"1\":{\"714\":1}}],[\"这个\",{\"1\":{\"710\":1,\"711\":1}}],[\"这个就是\",{\"1\":{\"710\":1}}],[\"这个单例又是\",{\"1\":{\"707\":1}}],[\"这个符号是在命令的末尾\",{\"1\":{\"660\":1}}],[\"这个set中包含map中所有的key\",{\"1\":{\"647\":1}}],[\"这个消息在throwable\",{\"1\":{\"619\":1}}],[\"这个抽象的概念\",{\"1\":{\"598\":1}}],[\"这个过程与广度优先搜索的过程一致\",{\"1\":{\"468\":1}}],[\"这个节点和周围的四个节点连通\",{\"1\":{\"443\":1}}],[\"这个网盘就已经搭建完成可以使用了\",{\"1\":{\"352\":1}}],[\"这个时候你需要采用如下做法来保护你的海外服务器以及\",{\"1\":{\"346\":1}}],[\"这个楼层发号操作必须是在一个评论区范围内串行的\",{\"1\":{\"261\":1}}],[\"这个长耗时几乎是不可接受的\",{\"1\":{\"261\":1}}],[\"这个公式求出每个质因子的次数\",{\"1\":{\"210\":1}}],[\"这个步骤\",{\"1\":{\"197\":1}}],[\"这个点还未被匹配\",{\"1\":{\"183\":1}}],[\"这个数本身\",{\"1\":{\"129\":1}}],[\"这个前缀和本身就是\",{\"1\":{\"81\":1}}],[\"这天\",{\"1\":{\"110\":1}}],[\"这两个函数会返回\",{\"1\":{\"63\":1}}],[\"这样宽度就会增加从而降低树的高度\",{\"1\":{\"545\":1}}],[\"这样确实比之前的方式快了很多\",{\"1\":{\"545\":1}}],[\"这样初始的烂橘子时间为\",{\"1\":{\"468\":1}}],[\"这样最后如果发现\",{\"1\":{\"468\":1}}],[\"这样二维矩阵就被抽象成了一幅网状的\",{\"1\":{\"443\":1}}],[\"这样我们才能随时随地使用它\",{\"1\":{\"353\":1}}],[\"这样如果国内能访问就优先用国内线路\",{\"1\":{\"347\":1}}],[\"这样在\",{\"1\":{\"334\":1}}],[\"这样可以防止攻击者使用相同的方式对一组用户的密码执行攻击\",{\"1\":{\"323\":1}}],[\"这样可以大大减少查询\",{\"1\":{\"293\":1}}],[\"这样\",{\"1\":{\"293\":1,\"660\":1}}],[\"这样就不会有丢失子树的问题了\",{\"1\":{\"378\":1}}],[\"这样就不用到设置里面配置代理了\",{\"1\":{\"347\":1}}],[\"这样就不用重复去\",{\"1\":{\"293\":1}}],[\"这样就实现了无感知地调用\",{\"1\":{\"358\":1}}],[\"这样就实现了一个图床的效果\",{\"1\":{\"352\":1}}],[\"这样就可以解决布隆过滤器无法删除元素的缺点了\",{\"1\":{\"334\":1}}],[\"这样就可以根据某个主题查询\",{\"1\":{\"291\":1}}],[\"这样就能避免头重脚轻\",{\"1\":{\"94\":1}}],[\"这样效率很低\",{\"1\":{\"289\":1}}],[\"这样方便我们串行消费\",{\"1\":{\"282\":1}}],[\"这样运营端的查询压力就下方给了独立的\",{\"1\":{\"279\":1}}],[\"这样让上游可以灵活组织逻辑\",{\"1\":{\"279\":1}}],[\"这样不同的业务只需要设计自己的策略接入评论系统即可\",{\"1\":{\"278\":1}}],[\"这样做是为了避免每次需要统计总数时都要做一次\",{\"1\":{\"289\":1}}],[\"这样做的好处是\",{\"1\":{\"273\":1}}],[\"这样做之后\",{\"1\":{\"32\":1}}],[\"这样直接用\",{\"1\":{\"241\":1}}],[\"这样的话\",{\"1\":{\"707\":1}}],[\"这样的设计\",{\"1\":{\"668\":1}}],[\"这样的好处是\",{\"1\":{\"289\":1}}],[\"这样的数据结构\",{\"1\":{\"273\":1}}],[\"这样的局面被称为必胜\",{\"1\":{\"214\":1}}],[\"这样的路\",{\"1\":{\"57\":1}}],[\"这样当两个边进行比较的时候就会使用他们的权重进行比较了\",{\"1\":{\"181\":1}}],[\"这里我使用\",{\"1\":{\"353\":1}}],[\"这里我结合日常使用习惯和需要\",{\"1\":{\"350\":1}}],[\"这里我们不再打印根节点\",{\"1\":{\"378\":1}}],[\"这里我们在\",{\"1\":{\"311\":1}}],[\"这里我们计算下最短路径\",{\"1\":{\"57\":1}}],[\"这里我们仍然用\",{\"1\":{\"49\":1}}],[\"这里总结一下如何通过\",{\"1\":{\"334\":1}}],[\"这里设置为\",{\"1\":{\"311\":1}}],[\"这里选择使用\",{\"1\":{\"302\":1}}],[\"这里可以使用滑动窗口统计\",{\"1\":{\"294\":1}}],[\"这里\",{\"1\":{\"279\":1}}],[\"这里也利用了消息队列的\",{\"1\":{\"261\":1}}],[\"这里使用库函数二分的写法\",{\"1\":{\"144\":1}}],[\"这里展示的只是我个人总结下来的一些使用\",{\"1\":{\"58\":1}}],[\"这里的\",{\"1\":{\"39\":1}}],[\"这里的d是指两个相邻节点之间的移动代价\",{\"1\":{\"38\":1}}],[\"这种方式和上面的接口的方式相比\",{\"1\":{\"704\":1}}],[\"这种方式不安全\",{\"1\":{\"493\":1}}],[\"这种机制使得即使部分磁盘发生故障\",{\"1\":{\"668\":1}}],[\"这种形式拼接字符串\",{\"1\":{\"641\":1}}],[\"这种异常分两大类运行时异常和非运行时异常\",{\"1\":{\"615\":1}}],[\"这种子查询称为表子查询\",{\"1\":{\"538\":1}}],[\"这种子查询称为行子查询\",{\"1\":{\"537\":1}}],[\"这种子查询称为列子查询\",{\"1\":{\"536\":1}}],[\"这种子查询称为标量子查询\",{\"1\":{\"535\":1}}],[\"这种情况是可以容忍的\",{\"1\":{\"334\":1}}],[\"这种迭代查询的方式也可以直接用图数据库来实现\",{\"1\":{\"289\":1}}],[\"这种用户推荐\",{\"1\":{\"272\":1}}],[\"这种写法包含了两种情况\",{\"1\":{\"148\":1}}],[\"这种题对于已访问的元素\",{\"1\":{\"55\":1}}],[\"这种题的⼤体思路和之前完全⼀样\",{\"1\":{\"50\":1}}],[\"这种单纯的题型\",{\"1\":{\"48\":1}}],[\"这种算法称之为最佳优先\",{\"1\":{\"34\":1}}],[\"这种算法就像洪水\",{\"1\":{\"32\":1}}],[\"这\",{\"1\":{\"44\":1,\"99\":1,\"107\":1,\"108\":1,\"109\":1,\"201\":2}}],[\"这也就意味着\",{\"1\":{\"81\":1}}],[\"这也就变成了最佳优先搜索\",{\"1\":{\"36\":1}}],[\"这也是注释\",{\"1\":{\"682\":1}}],[\"这也是一种\",{\"1\":{\"289\":1}}],[\"这也是\",{\"1\":{\"36\":1}}],[\"这通常称之为\",{\"1\":{\"35\":1}}],[\"一种特殊的返回类型是\",{\"1\":{\"587\":1}}],[\"一种更简洁的写法是将走过的陆地都给\",{\"1\":{\"48\":1}}],[\"一行一列\",{\"1\":{\"534\":1}}],[\"一门课程也可以供多个学生选择\",{\"1\":{\"526\":1}}],[\"一门操作关系型数据库的编程语言\",{\"1\":{\"494\":1}}],[\"一对一的应用场景\",{\"1\":{\"525\":1}}],[\"一对一关系表在实际开发中应用起来比较简单\",{\"1\":{\"525\":1}}],[\"一对一\",{\"0\":{\"525\":1},\"1\":{\"523\":1,\"525\":1}}],[\"一对多我们是怎么设计表关系的\",{\"1\":{\"525\":1}}],[\"一对多关系实现\",{\"1\":{\"524\":1}}],[\"一对多\",{\"0\":{\"524\":1},\"1\":{\"523\":1}}],[\"一台国外\",{\"1\":{\"344\":1}}],[\"一台国内\",{\"1\":{\"344\":1}}],[\"一篇文章等\",{\"1\":{\"289\":1}}],[\"一共有以下模块\",{\"1\":{\"279\":1}}],[\"一致性\",{\"1\":{\"273\":1,\"542\":2}}],[\"一文从内容运营层面\",{\"1\":{\"272\":1}}],[\"一文所使用的sdk\",{\"1\":{\"266\":1}}],[\"一方面是审核和风控\",{\"1\":{\"269\":1}}],[\"一写一读\",{\"1\":{\"258\":1}}],[\"一\",{\"0\":{\"550\":1,\"702\":1},\"1\":{\"119\":1,\"122\":1}}],[\"一个对象会被分成\",{\"1\":{\"668\":1}}],[\"一个线程被另一个线程中断\",{\"1\":{\"618\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"603\":1}}],[\"一个源文件可以有多个非\",{\"1\":{\"599\":1}}],[\"一个源文件中只能有一个\",{\"1\":{\"599\":1}}],[\"一个典型的函数定义包括以下部分\",{\"1\":{\"582\":1}}],[\"一个指针占\",{\"1\":{\"545\":1}}],[\"一个指向后\",{\"1\":{\"224\":1}}],[\"一个指向前\",{\"1\":{\"224\":1}}],[\"一个节点可以保存多个数据\",{\"1\":{\"545\":1}}],[\"一个节点下面只能有两个子节点\",{\"1\":{\"545\":1}}],[\"一个节点也可以是它自己的祖先\",{\"1\":{\"406\":1}}],[\"一个事务一旦被提交或回滚\",{\"1\":{\"542\":1}}],[\"一个事务的成功或者失败对于其他的事务是没有影响\",{\"1\":{\"542\":1}}],[\"一个事务完成之后数据都必须处于一致性状态\",{\"1\":{\"542\":1}}],[\"一个用户的事务不能被其他用户的事务干扰\",{\"1\":{\"542\":1}}],[\"一个用户只能对应一个身份证\",{\"1\":{\"525\":1}}],[\"一个业务要发送多条\",{\"1\":{\"540\":1}}],[\"一个课程也可以供多个学生选修\",{\"1\":{\"526\":1}}],[\"一个学生可以选修多门课程\",{\"1\":{\"526\":2}}],[\"一个学生可以有多个授课老师\",{\"1\":{\"526\":1}}],[\"一个授课老师也可以有多个学生\",{\"1\":{\"526\":1}}],[\"一个字符串的子序列是指这样一个新的字符串\",{\"1\":{\"449\":1}}],[\"一个设置\",{\"1\":{\"310\":1}}],[\"一个简单模式的脚手架\",{\"1\":{\"302\":1}}],[\"一个人去做加载存储\",{\"1\":{\"293\":1}}],[\"一个主题可能是一个视频稿件\",{\"1\":{\"289\":1}}],[\"一个有趣的问题是\",{\"1\":{\"261\":1}}],[\"一个有向无环图\",{\"1\":{\"169\":1}}],[\"一个图所有匹配中\",{\"1\":{\"183\":1}}],[\"一个\",{\"1\":{\"183\":1,\"282\":1,\"545\":1}}],[\"一个数的倍数一定是合数\",{\"1\":{\"191\":1}}],[\"一个数\",{\"1\":{\"122\":1}}],[\"一个正整数\",{\"1\":{\"111\":1,\"128\":1}}],[\"一个整数\",{\"1\":{\"108\":1,\"618\":1}}],[\"一个整数表示答案\",{\"1\":{\"100\":1}}],[\"一直递归寻找最下层的左节点\",{\"1\":{\"384\":1}}],[\"一直重复上边的过程\",{\"1\":{\"377\":1}}],[\"一直走到底层\",{\"1\":{\"121\":1}}],[\"一直找到祖先的祖先\",{\"1\":{\"90\":1}}],[\"一直达到起点\",{\"1\":{\"35\":1}}],[\"一开始\",{\"1\":{\"89\":1,\"263\":1}}],[\"一开始都是独立的\",{\"1\":{\"89\":1}}],[\"一些常见的用途有求连通子图\",{\"1\":{\"87\":1}}],[\"一些经验和技巧\",{\"0\":{\"61\":1},\"1\":{\"3\":1}}],[\"一维数组\",{\"0\":{\"569\":1}}],[\"一维差分\",{\"0\":{\"154\":1}}],[\"一维前缀和\",{\"0\":{\"152\":1}}],[\"一维优化\",{\"1\":{\"128\":1}}],[\"一维优化写法\",{\"1\":{\"118\":1}}],[\"一维\",{\"1\":{\"74\":1,\"116\":1,\"117\":1}}],[\"一定不在\",{\"1\":{\"334\":1}}],[\"一定不含有奇数环\",{\"1\":{\"182\":1}}],[\"一定命中某一个节点\",{\"1\":{\"294\":1}}],[\"一定等于\",{\"1\":{\"208\":1}}],[\"一定在\",{\"1\":{\"204\":1}}],[\"一定要先累加\",{\"1\":{\"180\":1}}],[\"一定满足\",{\"1\":{\"174\":1}}],[\"一定至少存在一个入度为\",{\"1\":{\"169\":1}}],[\"一定存在整数对\",{\"1\":{\"203\":1}}],[\"一定存在整数\",{\"1\":{\"68\":1,\"203\":1}}],[\"一定是有解才有\",{\"1\":{\"41\":1}}],[\"一旦为表起了别名\",{\"1\":{\"531\":1}}],[\"一旦程序使用长度超过\",{\"1\":{\"63\":1}}],[\"一旦到达终点\",{\"1\":{\"32\":1}}],[\"一旦到达终点便可以提前终止算法\",{\"1\":{\"32\":1}}],[\"一般情况下不自定义检查型异常\",{\"1\":{\"617\":1}}],[\"一般与\",{\"1\":{\"565\":1}}],[\"一般负责修改循环变量\",{\"1\":{\"563\":1}}],[\"一般用来初始化循环变量\",{\"1\":{\"563\":1}}],[\"一般用于凸显发评人的身份等\",{\"1\":{\"255\":1}}],[\"一般需要同时修改公共字段\",{\"1\":{\"513\":1}}],[\"一般都是自己创建工程\",{\"1\":{\"303\":1}}],[\"一般不需要使用分布式锁\",{\"1\":{\"293\":1}}],[\"一般会选择线程终止\",{\"1\":{\"615\":1}}],[\"一般会存储检索\",{\"1\":{\"283\":1}}],[\"一般会使用\",{\"1\":{\"281\":1}}],[\"一般会在有评论发布或者删除时修改\",{\"1\":{\"263\":1}}],[\"一般出于性能考虑\",{\"1\":{\"270\":1}}],[\"一般采用\",{\"1\":{\"261\":1}}],[\"一般是按照主题\",{\"1\":{\"294\":1}}],[\"一般是\",{\"1\":{\"149\":1,\"150\":1}}],[\"一般来说会希望大家看到的评论排序都大致相同\",{\"1\":{\"273\":1}}],[\"一般来说\",{\"1\":{\"143\":1,\"260\":1,\"273\":1,\"283\":1}}],[\"一般\",{\"1\":{\"62\":1}}],[\"一样\",{\"1\":{\"77\":1}}],[\"一样简单的把它给\",{\"1\":{\"55\":1}}],[\"一样向外扩张\",{\"1\":{\"32\":1}}],[\"一是用实参初始化函数对应的形参\",{\"1\":{\"584\":1}}],[\"一是服务编排\",{\"1\":{\"258\":1}}],[\"一是客户端的评论组件\",{\"1\":{\"258\":1}}],[\"一是\",{\"1\":{\"55\":1}}],[\"fetch\",{\"1\":{\"715\":2}}],[\"feed\",{\"1\":{\"273\":4}}],[\"fmin\",{\"1\":{\"656\":1}}],[\"fmax\",{\"1\":{\"656\":1}}],[\"f2\",{\"1\":{\"588\":2,\"591\":2}}],[\"f4\",{\"1\":{\"586\":1}}],[\"f3\",{\"1\":{\"586\":1,\"588\":2}}],[\"f1\",{\"1\":{\"586\":1,\"588\":2,\"591\":2}}],[\"f输出\",{\"1\":{\"555\":1}}],[\"friday\",{\"1\":{\"559\":1}}],[\"fresh++\",{\"1\":{\"469\":2}}],[\"fresh\",{\"1\":{\"468\":3,\"469\":6}}],[\"from=search\",{\"1\":{\"274\":1}}],[\"from=333\",{\"1\":{\"274\":2}}],[\"from\",{\"1\":{\"263\":5,\"270\":2,\"289\":2,\"474\":3,\"475\":2,\"514\":1,\"516\":1,\"517\":4,\"518\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"529\":4,\"531\":2,\"532\":2,\"534\":3,\"546\":1}}],[\"front\",{\"1\":{\"98\":1,\"99\":1,\"168\":1,\"175\":2,\"176\":1,\"242\":5}}],[\"full\",{\"1\":{\"545\":1}}],[\"fulltext\",{\"1\":{\"279\":1}}],[\"function\",{\"1\":{\"38\":1,\"39\":1,\"40\":1}}],[\"failed\",{\"1\":{\"310\":1,\"345\":1}}],[\"fact\",{\"1\":{\"208\":3,\"583\":3,\"584\":2,\"585\":4}}],[\"factor\",{\"1\":{\"189\":1}}],[\"fabs\",{\"1\":{\"205\":2}}],[\"father\",{\"1\":{\"165\":2}}],[\"fa\",{\"1\":{\"89\":3,\"90\":6,\"91\":1,\"93\":7,\"94\":10}}],[\"false\",{\"1\":{\"24\":1,\"25\":2,\"101\":1,\"108\":1,\"111\":5,\"129\":1,\"131\":2,\"175\":1,\"176\":2,\"182\":3,\"183\":2,\"187\":2,\"189\":1,\"192\":1,\"201\":2,\"239\":1,\"250\":1,\"313\":1,\"314\":2,\"322\":1,\"424\":2,\"426\":1,\"431\":2,\"473\":1,\"474\":1,\"475\":2,\"487\":1,\"551\":1,\"565\":1,\"567\":1,\"636\":1,\"702\":1,\"715\":3}}],[\"found\",{\"1\":{\"728\":1,\"735\":1}}],[\"fond\",{\"1\":{\"90\":1}}],[\"foo\",{\"1\":{\"75\":2,\"620\":2,\"621\":2}}],[\"foreach\",{\"1\":{\"675\":1,\"676\":1}}],[\"foreign\",{\"1\":{\"506\":1,\"524\":5}}],[\"forname\",{\"1\":{\"628\":1}}],[\"formatted\",{\"1\":{\"642\":2}}],[\"format\",{\"1\":{\"578\":1,\"600\":1,\"601\":1,\"642\":2}}],[\"forwarded\",{\"1\":{\"354\":2}}],[\"ford算法擅长解决有边数限制的最短路问题\",{\"1\":{\"174\":1}}],[\"ford算法\",{\"0\":{\"174\":1}}],[\"ford算法的优化\",{\"1\":{\"171\":1}}],[\"ford\",{\"1\":{\"171\":1,\"174\":1}}],[\"for\",{\"0\":{\"563\":1,\"736\":1},\"1\":{\"41\":1,\"43\":3,\"44\":5,\"48\":5,\"49\":7,\"50\":4,\"55\":5,\"56\":3,\"57\":3,\"64\":1,\"65\":2,\"70\":1,\"72\":1,\"75\":1,\"81\":1,\"82\":2,\"83\":5,\"89\":1,\"93\":3,\"94\":2,\"98\":3,\"99\":2,\"101\":2,\"107\":1,\"108\":2,\"109\":2,\"110\":2,\"111\":3,\"116\":5,\"117\":5,\"118\":14,\"119\":9,\"121\":9,\"122\":8,\"123\":2,\"124\":5,\"125\":6,\"126\":4,\"127\":7,\"128\":5,\"129\":16,\"131\":7,\"132\":5,\"134\":3,\"138\":1,\"144\":2,\"147\":4,\"148\":6,\"149\":3,\"150\":3,\"159\":1,\"160\":1,\"162\":1,\"165\":5,\"167\":1,\"168\":1,\"169\":2,\"172\":3,\"173\":1,\"174\":5,\"175\":1,\"176\":2,\"178\":5,\"180\":5,\"181\":2,\"182\":2,\"183\":2,\"187\":1,\"188\":1,\"189\":3,\"191\":2,\"192\":5,\"193\":2,\"195\":1,\"196\":2,\"199\":1,\"200\":2,\"204\":1,\"205\":9,\"207\":2,\"208\":1,\"209\":1,\"210\":6,\"212\":3,\"227\":1,\"230\":1,\"231\":2,\"232\":2,\"234\":1,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"247\":2,\"248\":2,\"249\":2,\"250\":2,\"251\":2,\"354\":2,\"402\":1,\"420\":3,\"426\":2,\"443\":2,\"444\":3,\"445\":4,\"451\":2,\"456\":2,\"469\":7,\"474\":3,\"475\":4,\"563\":5,\"565\":1,\"566\":1,\"567\":4,\"572\":7,\"573\":3,\"574\":2,\"578\":2,\"580\":1,\"583\":1,\"584\":1,\"591\":1,\"607\":1,\"620\":2,\"632\":3,\"634\":1,\"635\":2,\"636\":1,\"647\":5}}],[\"fib\",{\"1\":{\"596\":4}}],[\"firewall\",{\"1\":{\"345\":4}}],[\"firewalld\",{\"1\":{\"345\":2}}],[\"first存储距离\",{\"1\":{\"173\":1}}],[\"first\",{\"1\":{\"43\":1,\"44\":1,\"74\":2,\"98\":2,\"162\":2,\"173\":1,\"196\":1,\"242\":2,\"251\":2,\"456\":2,\"646\":1,\"655\":1}}],[\"fileoutputstream\",{\"1\":{\"676\":1}}],[\"filename\",{\"1\":{\"676\":1}}],[\"fileinputstream\",{\"1\":{\"676\":1}}],[\"file\",{\"1\":{\"676\":5,\"706\":5,\"714\":1}}],[\"filewriter\",{\"1\":{\"622\":1}}],[\"filereader\",{\"1\":{\"622\":1}}],[\"fileld\",{\"1\":{\"311\":1}}],[\"fillinstacktrace\",{\"1\":{\"619\":1}}],[\"fill\",{\"1\":{\"575\":1,\"654\":1}}],[\"filter\",{\"1\":{\"273\":1,\"279\":2}}],[\"finally\",{\"1\":{\"620\":1,\"634\":1}}],[\"final\",{\"1\":{\"311\":2,\"323\":1,\"551\":1,\"606\":1,\"607\":1,\"634\":1,\"635\":1,\"636\":2,\"706\":1}}],[\"find\",{\"1\":{\"72\":1,\"87\":1,\"90\":3,\"91\":2,\"93\":6,\"94\":9,\"99\":1,\"143\":1,\"161\":1,\"181\":6,\"183\":3,\"234\":4,\"235\":6,\"236\":5,\"239\":1,\"240\":1,\"242\":2,\"310\":1,\"323\":1,\"445\":6,\"706\":1}}],[\"field\",{\"1\":{\"310\":1,\"628\":6}}],[\"flatten\",{\"1\":{\"377\":1,\"378\":3}}],[\"flag\",{\"1\":{\"182\":3,\"293\":2}}],[\"flip\",{\"1\":{\"242\":2}}],[\"floorentry\",{\"1\":{\"613\":1}}],[\"floor\",{\"1\":{\"264\":1,\"289\":3,\"612\":1,\"653\":1}}],[\"floor=\",{\"1\":{\"263\":1}}],[\"floodfill\",{\"1\":{\"32\":1}}],[\"floyd算法\",{\"0\":{\"178\":1}}],[\"float与double都用\",{\"1\":{\"555\":1}}],[\"float>\",{\"1\":{\"77\":2}}],[\"float\",{\"1\":{\"77\":4,\"507\":1,\"551\":1,\"554\":1,\"555\":1,\"570\":2,\"656\":2}}],[\"flush\",{\"1\":{\"69\":4,\"555\":1,\"622\":1}}],[\"fflush\",{\"1\":{\"69\":1}}],[\"f\",{\"1\":{\"35\":2,\"41\":5,\"43\":1,\"44\":3,\"77\":4,\"116\":12,\"117\":11,\"118\":19,\"119\":10,\"121\":11,\"122\":9,\"123\":14,\"124\":7,\"125\":13,\"126\":22,\"127\":7,\"128\":25,\"129\":7,\"131\":8,\"132\":12,\"134\":12,\"250\":3,\"450\":2,\"451\":12,\"555\":2,\"561\":4,\"563\":4,\"570\":1,\"572\":7,\"590\":2}}],[\"直径\",{\"1\":{\"412\":2}}],[\"直播场景下\",{\"1\":{\"266\":1,\"274\":1}}],[\"直接退出\",{\"1\":{\"593\":1}}],[\"直接简写为\",{\"1\":{\"522\":1}}],[\"直接点击\",{\"1\":{\"514\":1}}],[\"直接返回空指针\",{\"1\":{\"426\":1}}],[\"直接放上压缩包\",{\"1\":{\"352\":1}}],[\"直接在\",{\"1\":{\"303\":1}}],[\"直接基于主键检索\",{\"1\":{\"289\":1}}],[\"直接向端上提供接口\",{\"1\":{\"284\":1}}],[\"直接将其指向下下个节点\",{\"1\":{\"223\":1}}],[\"直接异或运算进行整数交换后\",{\"1\":{\"158\":1}}],[\"直接搜索数组a和b\",{\"1\":{\"147\":1,\"148\":1}}],[\"直接递归判断\",{\"1\":{\"25\":1}}],[\"直到单元格中没有新鲜橘子为止所必须经过的最小分钟数\",{\"1\":{\"467\":1}}],[\"直到队列为空\",{\"1\":{\"444\":1}}],[\"直到遍历完成\",{\"1\":{\"402\":1}}],[\"直到找到并处理完后\",{\"1\":{\"384\":1}}],[\"直到找到终点\",{\"1\":{\"32\":1}}],[\"直到新的右子树为\",{\"1\":{\"377\":1}}],[\"直到具有\",{\"1\":{\"181\":1}}],[\"直到第n个点\",{\"1\":{\"172\":1}}],[\"直到字符串结尾\",{\"1\":{\"72\":1}}],[\"直到到达终点为止\",{\"1\":{\"33\":1}}],[\"2>\",{\"1\":{\"660\":2}}],[\"2d\",{\"1\":{\"551\":1}}],[\"2dust\",{\"1\":{\"347\":2}}],[\"2f\",{\"1\":{\"551\":1,\"555\":1,\"642\":1}}],[\"21\",{\"1\":{\"570\":1}}],[\"2155\",{\"1\":{\"507\":1}}],[\"215\",{\"1\":{\"507\":2}}],[\"2147483648\",{\"1\":{\"507\":1}}],[\"2147483647\",{\"1\":{\"486\":1,\"507\":1}}],[\"2250738585072014\",{\"1\":{\"507\":1}}],[\"226\",{\"1\":{\"460\":1}}],[\"2bytes\",{\"1\":{\"507\":1}}],[\"255\",{\"1\":{\"507\":4}}],[\"256\",{\"1\":{\"71\":1,\"321\":4}}],[\"23\",{\"1\":{\"507\":1,\"545\":2,\"553\":1}}],[\"239\",{\"1\":{\"454\":1}}],[\"236\",{\"1\":{\"405\":1}}],[\"230\",{\"1\":{\"361\":1}}],[\"231−1\",{\"1\":{\"124\":1,\"486\":3}}],[\"24\",{\"1\":{\"312\":1}}],[\"2^64\",{\"1\":{\"241\":2,\"507\":1}}],[\"2x+1\",{\"1\":{\"237\":1}}],[\"2x\",{\"1\":{\"237\":1}}],[\"263\",{\"1\":{\"507\":2}}],[\"26\",{\"1\":{\"232\":1,\"425\":2,\"426\":1}}],[\"2n×lnp​\",{\"1\":{\"334\":1}}],[\"2n\",{\"1\":{\"204\":1,\"211\":1}}],[\"2ll\",{\"1\":{\"192\":1}}],[\"2k\",{\"1\":{\"158\":2}}],[\"2e9\",{\"1\":{\"122\":1,\"162\":4,\"247\":1,\"250\":1,\"251\":4}}],[\"2e5+5\",{\"1\":{\"94\":1}}],[\"2e5\",{\"1\":{\"43\":1,\"144\":1,\"181\":1}}],[\"295\",{\"1\":{\"507\":2}}],[\"294\",{\"1\":{\"507\":2}}],[\"29\",{\"1\":{\"110\":1}}],[\"2∼n+1\",{\"1\":{\"110\":1}}],[\"2表示未选\",{\"1\":{\"107\":1}}],[\"2038\",{\"1\":{\"507\":1}}],[\"207\",{\"1\":{\"472\":1}}],[\"208\",{\"1\":{\"423\":1}}],[\"20456\",{\"1\":{\"346\":4}}],[\"2012\",{\"1\":{\"675\":1}}],[\"2019年版\",{\"1\":{\"274\":1}}],[\"2010\",{\"1\":{\"118\":2}}],[\"2020年的腾讯的辣椒酱不香了\",{\"1\":{\"266\":1}}],[\"20\",{\"1\":{\"81\":2,\"107\":1,\"110\":1,\"111\":1,\"132\":1,\"212\":1,\"263\":1,\"552\":1,\"573\":1}}],[\"2000w+\",{\"1\":{\"545\":1}}],[\"20000m\",{\"1\":{\"354\":1}}],[\"20005\",{\"1\":{\"93\":1}}],[\"200\",{\"1\":{\"48\":1,\"289\":2,\"441\":1,\"552\":1}}],[\"2\",{\"0\":{\"31\":1,\"32\":1,\"33\":2,\"34\":1,\"39\":1,\"63\":1,\"90\":1,\"117\":1,\"120\":1,\"121\":1,\"122\":2,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"132\":1,\"138\":1,\"143\":1,\"148\":1,\"153\":1,\"158\":1,\"166\":1,\"173\":1,\"177\":1,\"178\":1,\"181\":1,\"188\":1,\"192\":1,\"194\":1,\"195\":1,\"196\":2,\"197\":1,\"200\":1,\"208\":1,\"215\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"230\":1,\"235\":1,\"240\":1,\"248\":1,\"258\":1,\"264\":1,\"267\":1,\"270\":1,\"273\":1,\"299\":1,\"303\":1,\"309\":1,\"312\":1,\"313\":1,\"314\":2,\"315\":1,\"321\":1,\"323\":1,\"329\":1,\"330\":1,\"494\":1,\"495\":1,\"496\":2,\"497\":1,\"498\":1,\"499\":1,\"500\":2,\"501\":1,\"502\":1,\"503\":2,\"504\":2,\"505\":2,\"506\":3,\"507\":2,\"508\":3,\"509\":2,\"510\":2,\"513\":1,\"517\":1,\"525\":1,\"530\":1,\"535\":1,\"541\":1,\"545\":1,\"552\":1,\"557\":1,\"558\":2,\"559\":1,\"562\":1,\"566\":1,\"571\":1,\"573\":1,\"578\":1,\"584\":1,\"589\":1,\"590\":1,\"591\":2,\"594\":1,\"600\":1,\"603\":1,\"604\":1,\"605\":2,\"606\":1,\"607\":1,\"610\":1,\"616\":1,\"626\":1,\"627\":1,\"628\":1,\"629\":2,\"633\":1,\"634\":1,\"683\":1,\"684\":1,\"685\":1,\"686\":2,\"687\":1,\"688\":1,\"689\":1,\"690\":1,\"693\":1,\"696\":1,\"704\":1,\"705\":1,\"706\":3,\"707\":1,\"708\":1,\"709\":2,\"710\":2,\"711\":3,\"712\":2,\"713\":1,\"714\":1,\"715\":2,\"716\":1,\"717\":1,\"718\":1,\"719\":1,\"720\":2,\"721\":1,\"722\":1,\"723\":1,\"724\":1,\"725\":2,\"726\":1,\"728\":1},\"1\":{\"39\":1,\"41\":2,\"43\":7,\"44\":10,\"47\":1,\"54\":1,\"63\":1,\"71\":1,\"74\":1,\"75\":1,\"76\":6,\"77\":2,\"81\":2,\"82\":5,\"83\":1,\"87\":2,\"89\":1,\"93\":4,\"94\":9,\"99\":9,\"100\":1,\"101\":6,\"107\":5,\"108\":6,\"109\":6,\"110\":2,\"118\":2,\"121\":3,\"124\":5,\"127\":2,\"128\":4,\"129\":2,\"134\":2,\"137\":2,\"138\":1,\"142\":2,\"145\":1,\"147\":1,\"148\":2,\"152\":1,\"158\":9,\"160\":1,\"161\":1,\"165\":2,\"169\":1,\"171\":1,\"172\":1,\"174\":3,\"175\":1,\"178\":1,\"180\":2,\"181\":1,\"182\":2,\"187\":2,\"188\":1,\"189\":2,\"191\":5,\"192\":2,\"193\":1,\"196\":1,\"199\":1,\"200\":1,\"204\":1,\"205\":2,\"208\":1,\"209\":1,\"210\":2,\"212\":1,\"215\":1,\"223\":1,\"224\":1,\"231\":1,\"237\":13,\"242\":1,\"243\":1,\"248\":1,\"255\":2,\"259\":1,\"261\":1,\"263\":3,\"264\":2,\"266\":2,\"269\":1,\"270\":3,\"272\":1,\"273\":3,\"274\":1,\"310\":2,\"323\":2,\"419\":1,\"438\":1,\"467\":1,\"469\":4,\"495\":1,\"507\":1,\"551\":4,\"552\":1,\"553\":4,\"555\":1,\"557\":2,\"558\":1,\"559\":1,\"561\":1,\"563\":2,\"565\":1,\"566\":1,\"567\":2,\"571\":2,\"572\":4,\"573\":1,\"574\":1,\"577\":1,\"587\":1,\"591\":1,\"596\":2,\"602\":1,\"624\":1,\"625\":1,\"626\":1,\"628\":1,\"632\":2,\"668\":2,\"692\":2,\"695\":1,\"696\":1,\"708\":1,\"712\":1,\"715\":2}}],[\"念做\",{\"1\":{\"30\":1}}],[\"介绍了什么样的评论更容易上热评前排\",{\"1\":{\"272\":1}}],[\"介绍\",{\"0\":{\"30\":1,\"529\":1,\"534\":1,\"540\":1,\"544\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}],[\"17\",{\"1\":{\"675\":1}}],[\"171gb\",{\"1\":{\"668\":1}}],[\"175494351\",{\"1\":{\"507\":1}}],[\"183gb\",{\"1\":{\"668\":1}}],[\"18\",{\"1\":{\"578\":3}}],[\"1~100\",{\"1\":{\"561\":1,\"563\":1,\"566\":1,\"567\":2}}],[\"1~n\",{\"1\":{\"191\":1}}],[\"1~n表示放的哪些数\",{\"1\":{\"108\":1}}],[\"1kb\",{\"1\":{\"545\":1}}],[\"1byte\",{\"1\":{\"507\":1}}],[\"1m\",{\"1\":{\"354\":1}}],[\"1是右端点\",{\"1\":{\"224\":1}}],[\"1表示不存在\",{\"1\":{\"223\":1}}],[\"1表示黑色\",{\"1\":{\"182\":1}}],[\"1表示未染色\",{\"1\":{\"182\":1}}],[\"1表示已选\",{\"1\":{\"107\":1}}],[\"1ll\",{\"1\":{\"165\":1}}],[\"1变0\",{\"1\":{\"157\":1}}],[\"1<<n\",{\"1\":{\"132\":1}}],[\"1<<j\",{\"1\":{\"132\":2}}],[\"1的最短距离\",{\"1\":{\"132\":1}}],[\"1×2\",{\"1\":{\"131\":1}}],[\"1个0\",{\"1\":{\"129\":1}}],[\"1个9\",{\"1\":{\"129\":1}}],[\"1∼9\",{\"1\":{\"111\":3}}],[\"1∼n\",{\"1\":{\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"199\":1}}],[\"1∼8\",{\"1\":{\"44\":1,\"99\":1}}],[\"1970\",{\"1\":{\"507\":1}}],[\"1901\",{\"1\":{\"507\":1}}],[\"199\",{\"1\":{\"387\":1}}],[\"1994\",{\"1\":{\"110\":1}}],[\"1996\",{\"1\":{\"110\":1}}],[\"19\",{\"1\":{\"99\":1,\"507\":1}}],[\"1⩽ci​⩽w⩽108\",{\"1\":{\"110\":1}}],[\"1⩽q⩽1000000\",{\"1\":{\"93\":1}}],[\"1⩽m⩽1000000\",{\"1\":{\"93\":1}}],[\"1⩽n<106\",{\"1\":{\"111\":1}}],[\"1⩽n⩽9\",{\"1\":{\"108\":1}}],[\"1⩽n⩽18\",{\"1\":{\"110\":1}}],[\"1⩽n⩽15\",{\"1\":{\"107\":1}}],[\"1⩽n⩽1000\",{\"1\":{\"100\":1}}],[\"1⩽n⩽105\",{\"1\":{\"82\":1}}],[\"1⩽n⩽10\",{\"1\":{\"82\":1}}],[\"1⩽n⩽7\",{\"1\":{\"101\":1}}],[\"1⩽n⩽20000\",{\"1\":{\"93\":1}}],[\"1⩽n\",{\"1\":{\"81\":1,\"98\":1}}],[\"1会导致数组越界\",{\"1\":{\"83\":1}}],[\"16384\",{\"1\":{\"545\":1}}],[\"16kb\",{\"1\":{\"545\":2}}],[\"16777215\",{\"1\":{\"507\":1}}],[\"1693717911\",{\"1\":{\"322\":1}}],[\"16937\",{\"1\":{\"322\":1,\"323\":1}}],[\"16\",{\"0\":{\"77\":1},\"1\":{\"302\":1,\"507\":2,\"545\":3}}],[\"15\",{\"0\":{\"76\":1},\"1\":{\"125\":1}}],[\"135w∗16\",{\"1\":{\"545\":1}}],[\"135w\",{\"1\":{\"545\":2}}],[\"13331\",{\"1\":{\"241\":1}}],[\"131\",{\"1\":{\"241\":1}}],[\"13\",{\"0\":{\"74\":1},\"1\":{\"81\":1,\"509\":2}}],[\"1170∗1170=135w\",{\"1\":{\"545\":1}}],[\"1170\",{\"1\":{\"545\":3}}],[\"1143\",{\"1\":{\"448\":1}}],[\"114\",{\"1\":{\"375\":1}}],[\"1111\",{\"1\":{\"158\":7,\"212\":1}}],[\"1110\",{\"1\":{\"158\":8}}],[\"11\",{\"0\":{\"72\":1,\"631\":1,\"632\":1,\"633\":1,\"634\":1,\"635\":1,\"636\":1},\"1\":{\"111\":2,\"205\":1,\"507\":1,\"509\":2,\"573\":1,\"574\":1}}],[\"1100\",{\"1\":{\"117\":1}}],[\"110\",{\"1\":{\"55\":1,\"56\":1,\"57\":1,\"98\":1,\"118\":1,\"119\":2,\"196\":1,\"551\":1}}],[\"1e6\",{\"1\":{\"147\":1}}],[\"1e\",{\"1\":{\"145\":1,\"205\":1}}],[\"1e3\",{\"1\":{\"128\":1}}],[\"1e5\",{\"1\":{\"81\":1,\"82\":1,\"83\":1,\"180\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"1e9+7\",{\"1\":{\"207\":1}}],[\"1e9\",{\"1\":{\"63\":1,\"121\":1,\"127\":1,\"128\":1,\"196\":1}}],[\"1e10\",{\"1\":{\"41\":1}}],[\"122\",{\"1\":{\"577\":1}}],[\"124\",{\"1\":{\"369\":1}}],[\"127\",{\"1\":{\"354\":1,\"493\":1,\"507\":1,\"577\":1}}],[\"128\",{\"1\":{\"321\":1,\"507\":1,\"577\":1}}],[\"129343870\",{\"1\":{\"311\":1}}],[\"12010\",{\"1\":{\"118\":1}}],[\"12\",{\"0\":{\"73\":1},\"1\":{\"110\":1,\"131\":1,\"323\":1,\"507\":2,\"551\":1,\"668\":1}}],[\"12345\",{\"1\":{\"551\":1}}],[\"123457899\",{\"1\":{\"323\":1}}],[\"1234567891011l\",{\"1\":{\"551\":1}}],[\"123456789\",{\"1\":{\"551\":1}}],[\"12345678900\",{\"1\":{\"322\":1}}],[\"12345678\",{\"1\":{\"322\":1,\"323\":5}}],[\"12345678x\",{\"1\":{\"44\":1,\"99\":1}}],[\"123456\",{\"1\":{\"147\":1,\"148\":1}}],[\"1234\",{\"1\":{\"323\":1}}],[\"123\",{\"1\":{\"71\":7,\"344\":8,\"345\":4,\"346\":12,\"551\":1,\"555\":3,\"570\":1,\"578\":1,\"676\":1}}],[\"1254\",{\"1\":{\"49\":1}}],[\"10×10\",{\"1\":{\"567\":1}}],[\"108\",{\"1\":{\"435\":1}}],[\"104\",{\"1\":{\"399\":1}}],[\"102\",{\"1\":{\"393\":1}}],[\"1024字节\",{\"1\":{\"545\":1}}],[\"1024\",{\"1\":{\"321\":1}}],[\"10m\",{\"1\":{\"354\":1}}],[\"10的二进制表示为4位数\",{\"1\":{\"159\":1}}],[\"101\",{\"1\":{\"429\":1}}],[\"10123\",{\"1\":{\"344\":3,\"345\":5,\"346\":4}}],[\"1011\",{\"1\":{\"158\":1}}],[\"101000\",{\"1\":{\"159\":1}}],[\"1010\",{\"1\":{\"43\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"116\":1,\"122\":1,\"123\":1,\"125\":1,\"126\":1,\"158\":8,\"159\":2}}],[\"105\",{\"1\":{\"111\":1,\"417\":1,\"419\":1}}],[\"10\",{\"0\":{\"71\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1,\"243\":1,\"624\":1,\"625\":1,\"626\":1,\"627\":1,\"628\":1,\"629\":1},\"1\":{\"43\":1,\"81\":1,\"82\":1,\"83\":2,\"93\":2,\"101\":1,\"108\":1,\"111\":4,\"125\":2,\"129\":12,\"144\":1,\"147\":3,\"148\":3,\"149\":2,\"150\":1,\"159\":3,\"165\":1,\"180\":1,\"181\":1,\"210\":4,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"334\":1,\"354\":1,\"551\":1,\"552\":2,\"553\":1,\"561\":1,\"563\":3,\"567\":2,\"570\":1,\"573\":2,\"574\":1,\"585\":1,\"590\":1,\"606\":1,\"607\":1,\"632\":3,\"675\":1}}],[\"10010\",{\"1\":{\"231\":1}}],[\"1000∗60∗5\",{\"1\":{\"707\":1}}],[\"100000\",{\"1\":{\"634\":1,\"635\":2}}],[\"1000\",{\"1\":{\"158\":1,\"159\":1,\"334\":1,\"507\":2,\"545\":1,\"632\":3,\"636\":1,\"707\":1,\"717\":3}}],[\"100010\",{\"1\":{\"122\":2,\"159\":1,\"231\":1}}],[\"100=82+1973546​\",{\"1\":{\"111\":1}}],[\"100=3+71469258​\",{\"1\":{\"111\":1}}],[\"100\",{\"1\":{\"5\":1,\"111\":3,\"545\":1,\"557\":1,\"558\":1,\"561\":1,\"563\":1,\"566\":1,\"567\":1,\"651\":2,\"667\":1}}],[\"14\",{\"0\":{\"75\":1},\"1\":{\"43\":1,\"302\":1,\"507\":1,\"702\":1}}],[\"1≤n≤3000\",{\"1\":{\"124\":1}}],[\"1≤l≤100\",{\"1\":{\"43\":1}}],[\"1≤k≤1000\",{\"1\":{\"43\":1}}],[\"1≤s\",{\"1\":{\"43\":1}}],[\"1\",{\"0\":{\"30\":1,\"32\":1,\"38\":1,\"62\":1,\"73\":1,\"89\":1,\"115\":1,\"116\":2,\"117\":1,\"118\":1,\"119\":1,\"121\":1,\"131\":1,\"134\":1,\"137\":1,\"140\":1,\"147\":1,\"152\":1,\"157\":1,\"165\":1,\"171\":1,\"172\":2,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"178\":1,\"180\":1,\"186\":1,\"187\":2,\"188\":1,\"190\":1,\"191\":2,\"192\":1,\"193\":1,\"195\":1,\"199\":1,\"207\":1,\"214\":1,\"222\":1,\"223\":2,\"224\":1,\"226\":1,\"227\":1,\"229\":1,\"234\":1,\"239\":1,\"246\":1,\"247\":2,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"257\":1,\"263\":1,\"266\":1,\"269\":1,\"272\":1,\"298\":1,\"302\":1,\"307\":1,\"308\":2,\"309\":1,\"310\":1,\"311\":1,\"313\":1,\"319\":1,\"320\":2,\"321\":1,\"322\":1,\"327\":1,\"328\":2,\"329\":1,\"492\":1,\"493\":2,\"494\":1,\"495\":2,\"496\":1,\"498\":1,\"499\":2,\"500\":1,\"501\":1,\"502\":1,\"504\":1,\"505\":2,\"506\":1,\"507\":1,\"512\":1,\"516\":1,\"524\":1,\"528\":1,\"529\":2,\"530\":1,\"534\":1,\"540\":1,\"544\":1,\"551\":2,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"557\":1,\"561\":1,\"565\":1,\"569\":1,\"570\":2,\"571\":1,\"572\":1,\"577\":1,\"582\":1,\"583\":2,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"590\":1,\"593\":1,\"598\":1,\"599\":2,\"600\":1,\"601\":1,\"602\":1,\"604\":1,\"609\":1,\"615\":1,\"624\":1,\"625\":2,\"626\":1,\"628\":1,\"631\":1,\"632\":2,\"633\":1,\"636\":1,\"681\":1,\"682\":2,\"683\":1,\"685\":1,\"692\":1,\"695\":1,\"701\":1,\"704\":1,\"705\":2,\"707\":1,\"708\":1,\"710\":1,\"714\":1,\"717\":1,\"719\":1,\"724\":1,\"727\":1},\"1\":{\"41\":2,\"43\":7,\"44\":17,\"47\":1,\"48\":23,\"49\":10,\"50\":6,\"54\":1,\"55\":7,\"56\":9,\"57\":12,\"62\":3,\"63\":1,\"64\":3,\"65\":1,\"68\":1,\"71\":1,\"72\":2,\"73\":2,\"74\":5,\"75\":4,\"76\":1,\"77\":2,\"81\":11,\"82\":7,\"83\":13,\"87\":2,\"89\":2,\"93\":6,\"94\":12,\"98\":29,\"99\":16,\"100\":4,\"101\":8,\"107\":10,\"108\":11,\"109\":14,\"110\":6,\"111\":5,\"116\":5,\"117\":4,\"118\":9,\"119\":2,\"121\":20,\"122\":14,\"123\":14,\"124\":11,\"125\":15,\"126\":22,\"127\":17,\"128\":15,\"129\":20,\"131\":11,\"132\":8,\"134\":14,\"137\":5,\"138\":3,\"141\":6,\"142\":7,\"143\":3,\"147\":4,\"148\":7,\"149\":3,\"150\":4,\"152\":2,\"153\":4,\"154\":1,\"155\":4,\"158\":38,\"159\":9,\"160\":2,\"161\":4,\"165\":9,\"167\":1,\"168\":3,\"169\":5,\"171\":1,\"172\":9,\"173\":5,\"174\":6,\"175\":7,\"176\":3,\"178\":6,\"179\":1,\"180\":6,\"181\":5,\"182\":7,\"183\":2,\"188\":2,\"189\":4,\"191\":6,\"192\":1,\"193\":1,\"195\":1,\"196\":7,\"199\":3,\"200\":11,\"201\":9,\"203\":2,\"204\":7,\"205\":5,\"207\":4,\"208\":7,\"209\":8,\"210\":2,\"211\":1,\"212\":9,\"223\":2,\"224\":2,\"227\":1,\"229\":1,\"230\":1,\"231\":5,\"234\":1,\"235\":2,\"236\":1,\"237\":12,\"239\":1,\"241\":6,\"242\":2,\"243\":14,\"247\":4,\"248\":5,\"250\":2,\"255\":2,\"259\":1,\"261\":1,\"263\":3,\"264\":2,\"266\":3,\"269\":1,\"270\":4,\"272\":1,\"273\":3,\"274\":1,\"310\":8,\"315\":1,\"321\":6,\"322\":1,\"323\":23,\"334\":7,\"354\":2,\"362\":1,\"365\":5,\"366\":4,\"376\":1,\"377\":1,\"389\":2,\"401\":1,\"414\":1,\"419\":5,\"420\":13,\"425\":1,\"436\":1,\"438\":3,\"442\":1,\"443\":5,\"444\":7,\"445\":13,\"450\":2,\"451\":20,\"467\":2,\"468\":1,\"469\":19,\"473\":3,\"474\":5,\"475\":1,\"481\":3,\"488\":3,\"493\":1,\"495\":1,\"506\":1,\"507\":7,\"513\":1,\"522\":1,\"551\":5,\"553\":2,\"555\":1,\"557\":9,\"558\":1,\"559\":1,\"561\":7,\"562\":4,\"563\":7,\"565\":1,\"566\":2,\"567\":1,\"571\":2,\"572\":8,\"573\":1,\"574\":1,\"578\":1,\"580\":1,\"583\":2,\"584\":2,\"587\":1,\"588\":1,\"591\":2,\"593\":5,\"596\":2,\"602\":1,\"621\":1,\"624\":1,\"625\":1,\"626\":1,\"628\":1,\"632\":2,\"642\":5,\"643\":2,\"645\":6,\"646\":4,\"647\":10,\"648\":6,\"649\":5,\"650\":6,\"651\":1,\"653\":1,\"654\":1,\"660\":2,\"676\":1,\"692\":2,\"695\":2,\"696\":2,\"697\":1,\"698\":1,\"708\":1,\"712\":1,\"715\":3,\"727\":2}}],[\"again\",{\"1\":{\"680\":1}}],[\"age\",{\"1\":{\"578\":2}}],[\"aws\",{\"1\":{\"668\":2,\"675\":2}}],[\"amazon\",{\"1\":{\"668\":2}}],[\"amd64\",{\"1\":{\"352\":3,\"660\":1,\"662\":1}}],[\"azure\",{\"1\":{\"668\":1}}],[\"athena\",{\"1\":{\"607\":3}}],[\"attack\",{\"1\":{\"605\":1,\"606\":2,\"607\":2}}],[\"atomicity\",{\"1\":{\"542\":2}}],[\"atoi\",{\"1\":{\"71\":3}}],[\"a++\",{\"1\":{\"552\":1}}],[\"aec\",{\"1\":{\"449\":1}}],[\"aux\",{\"1\":{\"354\":1}}],[\"author\",{\"1\":{\"311\":3,\"315\":1,\"323\":1}}],[\"autorollattime>\",{\"1\":{\"663\":1}}],[\"auto\",{\"1\":{\"43\":2,\"44\":1,\"65\":1,\"70\":1,\"75\":4,\"98\":1,\"99\":1,\"118\":1,\"129\":5,\"131\":1,\"147\":1,\"148\":2,\"149\":1,\"150\":1,\"162\":1,\"165\":1,\"173\":1,\"175\":1,\"176\":1,\"196\":1,\"249\":1,\"251\":1,\"321\":1,\"506\":3}}],[\"after=mysqld\",{\"1\":{\"353\":1}}],[\"after=network\",{\"1\":{\"353\":1}}],[\"acwing\",{\"1\":{\"686\":1}}],[\"acs\",{\"1\":{\"680\":6,\"689\":5,\"692\":2}}],[\"ac\",{\"1\":{\"680\":2}}],[\"action\",{\"1\":{\"675\":1}}],[\"active\",{\"1\":{\"345\":1}}],[\"accessid\",{\"1\":{\"704\":1}}],[\"accesskey\",{\"1\":{\"673\":2}}],[\"account\",{\"1\":{\"279\":2,\"667\":1}}],[\"acid\",{\"1\":{\"542\":1}}],[\"ace\",{\"1\":{\"449\":1}}],[\"ajax\",{\"1\":{\"328\":2}}],[\"aj​\",{\"1\":{\"81\":1}}],[\"avg\",{\"1\":{\"519\":2}}],[\"avatar\",{\"1\":{\"321\":2}}],[\"average\",{\"1\":{\"274\":2}}],[\"are\",{\"1\":{\"706\":1}}],[\"archaius1utils\",{\"1\":{\"714\":1}}],[\"archaius\",{\"1\":{\"706\":1}}],[\"arn\",{\"1\":{\"675\":1}}],[\"arguments>\",{\"1\":{\"663\":1}}],[\"args\",{\"1\":{\"551\":1,\"553\":3,\"554\":2,\"555\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":4,\"562\":1,\"563\":4,\"565\":1,\"566\":1,\"567\":2,\"570\":1,\"571\":1,\"572\":4,\"573\":2,\"574\":1,\"577\":2,\"579\":1,\"584\":1,\"587\":1,\"588\":1,\"590\":1,\"591\":1,\"593\":1,\"594\":1,\"595\":1,\"596\":1,\"602\":1,\"607\":1,\"620\":1,\"621\":1,\"622\":1,\"628\":1,\"632\":2,\"634\":1,\"635\":2,\"636\":1}}],[\"arithmeticexception\",{\"1\":{\"618\":1,\"620\":1}}],[\"artifactid>\",{\"1\":{\"323\":1,\"672\":1}}],[\"artifact\",{\"1\":{\"323\":1}}],[\"article\",{\"1\":{\"311\":1,\"728\":1}}],[\"arr2\",{\"1\":{\"640\":1}}],[\"arr1\",{\"1\":{\"640\":1}}],[\"array=\",{\"1\":{\"695\":1,\"696\":1,\"697\":1,\"698\":1}}],[\"arraydeque是deque的一个实现类\",{\"1\":{\"648\":1}}],[\"arraydeque<>\",{\"1\":{\"648\":1}}],[\"arraydeque\",{\"1\":{\"648\":2}}],[\"arraylist<e>\",{\"1\":{\"645\":1}}],[\"arraylist<>\",{\"1\":{\"313\":1,\"389\":1,\"390\":2,\"396\":2,\"469\":2,\"609\":1,\"645\":2,\"646\":1}}],[\"arraylist\",{\"1\":{\"645\":2}}],[\"array\",{\"1\":{\"620\":4,\"645\":2,\"695\":4,\"696\":5,\"697\":4,\"698\":4}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"618\":1,\"620\":1}}],[\"arraystoreexception\",{\"1\":{\"618\":1}}],[\"arrays\",{\"1\":{\"575\":5,\"577\":2,\"587\":2,\"591\":2}}],[\"arr\",{\"1\":{\"122\":7,\"247\":7,\"248\":9,\"640\":5,\"642\":2,\"654\":1}}],[\"ahead\",{\"1\":{\"281\":1}}],[\"applying\",{\"1\":{\"727\":1}}],[\"applicationinfomanager\",{\"1\":{\"710\":3,\"712\":1,\"714\":1,\"719\":1,\"720\":1}}],[\"application\",{\"1\":{\"310\":2,\"311\":1,\"673\":1,\"710\":1}}],[\"append\",{\"1\":{\"580\":1,\"591\":1,\"641\":1,\"643\":1}}],[\"apk\",{\"1\":{\"347\":1}}],[\"apache\",{\"1\":{\"323\":4,\"666\":1}}],[\"api\",{\"0\":{\"674\":1},\"1\":{\"279\":3,\"311\":3,\"329\":2,\"350\":1,\"639\":1,\"667\":2,\"668\":2,\"673\":1},\"2\":{\"658\":1}}],[\"ap−1≡1\",{\"1\":{\"208\":1}}],[\"a9\",{\"1\":{\"274\":1}}],[\"a3​\",{\"1\":{\"227\":1}}],[\"a3​≥a5​\",{\"1\":{\"227\":1}}],[\"a−2\",{\"1\":{\"209\":2}}],[\"a−1\",{\"1\":{\"209\":2}}],[\"a−b+1\",{\"1\":{\"209\":2}}],[\"a−b−1\",{\"1\":{\"209\":1}}],[\"a−b\",{\"1\":{\"208\":2,\"209\":3}}],[\"a1\",{\"1\":{\"204\":6,\"214\":1}}],[\"a1​\",{\"1\":{\"81\":1,\"82\":2,\"204\":1}}],[\"ak\",{\"1\":{\"201\":1}}],[\"abc\",{\"1\":{\"683\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":1}}],[\"abcde\",{\"1\":{\"449\":2}}],[\"abnormal\",{\"1\":{\"353\":1}}],[\"ab=a2x1​×a2x2​×\",{\"1\":{\"201\":1}}],[\"ab\",{\"1\":{\"201\":1,\"274\":1}}],[\"abstractinstanceregistry\",{\"1\":{\"717\":1}}],[\"abstractconfiguration\",{\"1\":{\"702\":2}}],[\"abs\",{\"1\":{\"38\":2,\"39\":2,\"40\":2,\"44\":2,\"204\":2,\"205\":3,\"653\":1}}],[\"a2\",{\"1\":{\"204\":5,\"214\":1}}],[\"a2logk\",{\"1\":{\"201\":2}}],[\"a22\",{\"1\":{\"201\":2}}],[\"a21\",{\"1\":{\"201\":2}}],[\"a20\",{\"1\":{\"201\":2}}],[\"a2​\",{\"1\":{\"81\":1,\"82\":2,\"204\":1}}],[\"a表示出点\",{\"1\":{\"174\":1}}],[\"alice\",{\"1\":{\"642\":1}}],[\"alter\",{\"1\":{\"509\":6,\"524\":1}}],[\"alt+enter\",{\"1\":{\"311\":1}}],[\"allow\",{\"1\":{\"675\":1}}],[\"allargsconstructor\",{\"1\":{\"522\":1}}],[\"all\",{\"1\":{\"345\":1,\"647\":2}}],[\"alls\",{\"1\":{\"161\":9}}],[\"algorithm\",{\"1\":{\"144\":1},\"2\":{\"21\":1}}],[\"a的这一位数\",{\"1\":{\"148\":1}}],[\"a长度不等于b\",{\"1\":{\"148\":1}}],[\"a>b\",{\"1\":{\"129\":1}}],[\"a||b\",{\"1\":{\"129\":1}}],[\"a是几\",{\"1\":{\"111\":1}}],[\"a不变\",{\"1\":{\"111\":1}}],[\"a和\",{\"1\":{\"93\":1}}],[\"ai\",{\"1\":{\"668\":1}}],[\"ai+1​\",{\"1\":{\"81\":1}}],[\"ai​\",{\"1\":{\"81\":2,\"204\":1,\"473\":2}}],[\"annotation\",{\"1\":{\"624\":1}}],[\"ant\",{\"1\":{\"300\":1,\"302\":3,\"328\":1}}],[\"android\",{\"1\":{\"347\":1}}],[\"and\",{\"1\":{\"263\":6,\"289\":3,\"518\":2}}],[\"any\",{\"1\":{\"242\":1}}],[\"an\",{\"1\":{\"214\":1,\"727\":1}}],[\"an​\",{\"1\":{\"81\":1,\"82\":2,\"204\":1}}],[\"ans++\",{\"1\":{\"111\":1,\"247\":1}}],[\"ans用来标记是否找到出口\",{\"1\":{\"55\":1}}],[\"ans\",{\"1\":{\"55\":4,\"111\":2,\"121\":4,\"122\":4,\"129\":13,\"143\":3,\"247\":2,\"251\":4,\"363\":4,\"389\":8,\"396\":3,\"414\":4,\"456\":4,\"481\":4}}],[\"admin\",{\"0\":{\"259\":1,\"283\":1},\"1\":{\"279\":2,\"283\":1,\"313\":1,\"315\":1}}],[\"adj\",{\"1\":{\"75\":1}}],[\"address\",{\"1\":{\"660\":3,\"661\":1,\"662\":1}}],[\"addall\",{\"1\":{\"654\":1}}],[\"add\",{\"1\":{\"43\":3,\"147\":2,\"165\":3,\"173\":1,\"175\":1,\"223\":1,\"302\":1,\"311\":1,\"345\":2,\"354\":1,\"389\":1,\"390\":1,\"396\":2,\"402\":3,\"469\":2,\"474\":1,\"475\":1,\"509\":2,\"524\":1,\"609\":1,\"611\":1,\"612\":1,\"628\":2,\"645\":2,\"646\":1,\"649\":1}}],[\"axios\",{\"1\":{\"328\":1}}],[\"ax​\",{\"1\":{\"227\":1}}],[\"ax​≥ay​\",{\"1\":{\"227\":1}}],[\"ax\",{\"1\":{\"68\":2,\"203\":2}}],[\"ax+by=1\",{\"1\":{\"203\":1}}],[\"ax+by=a\",{\"1\":{\"203\":1}}],[\"ax+by=gcd\",{\"1\":{\"203\":2}}],[\"ax+by\",{\"1\":{\"68\":1,\"203\":1}}],[\"ascii码\",{\"0\":{\"577\":1}}],[\"asc\",{\"1\":{\"521\":1}}],[\"as\",{\"1\":{\"517\":2,\"531\":2}}],[\"assertequals\",{\"1\":{\"323\":7}}],[\"assertions\",{\"1\":{\"322\":1,\"323\":7}}],[\"asserttrue\",{\"1\":{\"322\":2}}],[\"assign\",{\"0\":{\"74\":1},\"1\":{\"74\":6}}],[\"aside\",{\"1\":{\"261\":1,\"281\":1}}],[\"ask\",{\"1\":{\"129\":3}}],[\"asm\",{\"1\":{\"66\":1}}],[\"astar\",{\"1\":{\"43\":2}}],[\"a∗\",{\"1\":{\"30\":1,\"35\":5,\"36\":5,\"209\":2}}],[\"a\",{\"0\":{\"29\":1,\"35\":1,\"67\":1},\"1\":{\"30\":1,\"35\":1,\"41\":7,\"43\":9,\"44\":1,\"62\":1,\"65\":1,\"67\":2,\"68\":3,\"74\":2,\"76\":11,\"77\":1,\"93\":3,\"99\":6,\"111\":19,\"118\":4,\"121\":5,\"122\":10,\"123\":6,\"124\":8,\"125\":3,\"126\":10,\"127\":3,\"129\":8,\"134\":3,\"137\":7,\"138\":12,\"141\":1,\"142\":2,\"144\":13,\"147\":15,\"148\":27,\"149\":17,\"150\":15,\"152\":5,\"158\":17,\"165\":13,\"172\":9,\"173\":3,\"174\":9,\"175\":3,\"178\":1,\"180\":5,\"181\":8,\"192\":13,\"196\":2,\"197\":6,\"201\":5,\"203\":15,\"204\":6,\"205\":17,\"207\":2,\"208\":13,\"209\":22,\"210\":10,\"223\":2,\"232\":2,\"235\":2,\"236\":3,\"237\":4,\"243\":29,\"426\":2,\"431\":2,\"475\":1,\"529\":1,\"530\":1,\"551\":4,\"552\":23,\"553\":8,\"557\":38,\"558\":5,\"561\":4,\"563\":4,\"570\":1,\"571\":2,\"572\":18,\"573\":4,\"574\":2,\"575\":1,\"577\":10,\"578\":3,\"587\":2,\"591\":9,\"593\":11,\"594\":3,\"595\":6,\"628\":2,\"642\":4,\"645\":2,\"653\":10,\"654\":1,\"702\":2,\"706\":1}}],[\"runnable\",{\"1\":{\"632\":3,\"635\":1}}],[\"run\",{\"1\":{\"632\":3,\"634\":1,\"635\":2,\"636\":1,\"661\":1}}],[\"runtimeexception\",{\"1\":{\"617\":2,\"632\":3,\"636\":1,\"676\":1}}],[\"round\",{\"1\":{\"653\":1}}],[\"routes\",{\"1\":{\"302\":1}}],[\"roll\",{\"1\":{\"663\":1}}],[\"rollback\",{\"1\":{\"541\":1}}],[\"role\",{\"1\":{\"313\":1,\"315\":2,\"604\":1,\"605\":1}}],[\"rocks\",{\"1\":{\"289\":1}}],[\"rows\",{\"1\":{\"522\":1}}],[\"row\",{\"1\":{\"289\":1,\"574\":2}}],[\"rootinindex\",{\"1\":{\"420\":6}}],[\"rootindex\",{\"1\":{\"420\":4}}],[\"rootpreindex\",{\"1\":{\"420\":7}}],[\"root=\",{\"1\":{\"263\":1}}],[\"root=0\",{\"1\":{\"263\":1}}],[\"root\",{\"1\":{\"24\":2,\"25\":5,\"134\":5,\"289\":3,\"354\":1,\"362\":1,\"363\":7,\"366\":9,\"370\":1,\"376\":1,\"377\":10,\"378\":7,\"382\":1,\"389\":7,\"390\":3,\"394\":1,\"396\":3,\"400\":1,\"401\":4,\"402\":3,\"408\":8,\"412\":1,\"414\":6,\"419\":3,\"420\":11,\"425\":2,\"430\":1,\"432\":3,\"438\":4,\"461\":1,\"463\":10,\"479\":1,\"480\":1,\"481\":7,\"485\":1,\"486\":3,\"487\":6,\"488\":2,\"660\":4}}],[\"rayshinehub\",{\"1\":{\"340\":1}}],[\"rating\",{\"1\":{\"274\":2}}],[\"range\",{\"1\":{\"249\":8,\"250\":9}}],[\"random\",{\"1\":{\"243\":1,\"653\":1}}],[\"rank\",{\"1\":{\"181\":7,\"234\":8}}],[\"rpid\",{\"1\":{\"263\":2}}],[\"r代表区间右端点\",{\"1\":{\"251\":1}}],[\"r表示上一连续区间的最右端的点\",{\"1\":{\"247\":1}}],[\"r时\",{\"1\":{\"140\":1}}],[\"r​\",{\"1\":{\"83\":1}}],[\"r×r\",{\"1\":{\"83\":1}}],[\"rsp\",{\"1\":{\"66\":1}}],[\"r\",{\"1\":{\"44\":1,\"66\":1,\"81\":8,\"83\":15,\"122\":6,\"137\":8,\"138\":8,\"140\":1,\"141\":7,\"142\":7,\"143\":6,\"145\":4,\"150\":1,\"152\":2,\"154\":2,\"161\":5,\"162\":7,\"205\":12,\"224\":10,\"241\":4,\"247\":8,\"248\":10,\"249\":4,\"250\":12,\"251\":10,\"401\":2,\"414\":3,\"438\":4,\"463\":2,\"486\":4,\"642\":1,\"654\":2,\"687\":1}}],[\"rh\",{\"1\":{\"43\":5}}],[\"recentregisteredqueue\",{\"1\":{\"717\":1}}],[\"recentcanceledqueue\",{\"1\":{\"717\":1}}],[\"reed\",{\"1\":{\"668\":1}}],[\"reentrantlock\",{\"1\":{\"634\":3}}],[\"reflect\",{\"1\":{\"628\":7}}],[\"references\",{\"1\":{\"524\":2}}],[\"red\",{\"1\":{\"602\":1}}],[\"redirect\",{\"1\":{\"354\":1}}],[\"redisbloom\",{\"1\":{\"334\":1}}],[\"redis\",{\"1\":{\"264\":4,\"273\":3,\"279\":1,\"291\":3,\"334\":6}}],[\"replaceall\",{\"1\":{\"654\":1}}],[\"replace\",{\"1\":{\"578\":2,\"642\":1}}],[\"reply\",{\"0\":{\"258\":1,\"259\":1,\"260\":1,\"261\":1},\"1\":{\"258\":1,\"260\":1,\"261\":5,\"263\":6,\"264\":5,\"270\":1}}],[\"registrycount\",{\"1\":{\"724\":1}}],[\"registry\",{\"1\":{\"715\":2,\"717\":1,\"719\":1,\"720\":1,\"722\":2,\"724\":1}}],[\"registerallstats\",{\"1\":{\"725\":1}}],[\"register\",{\"1\":{\"311\":1,\"715\":2}}],[\"regex\",{\"1\":{\"578\":1,\"642\":1}}],[\"rename\",{\"1\":{\"509\":1}}],[\"release\",{\"1\":{\"352\":1,\"660\":1,\"662\":1}}],[\"releases\",{\"1\":{\"347\":3,\"663\":1}}],[\"reload\",{\"1\":{\"345\":1,\"353\":1}}],[\"remark\",{\"1\":{\"321\":2}}],[\"remote\",{\"1\":{\"294\":1}}],[\"removeobjectargs\",{\"1\":{\"676\":1}}],[\"removeobject\",{\"1\":{\"676\":2}}],[\"removebucketargs\",{\"1\":{\"675\":1}}],[\"removebucket\",{\"1\":{\"675\":2}}],[\"removebyid\",{\"1\":{\"314\":1}}],[\"remove\",{\"1\":{\"223\":2,\"224\":1,\"302\":1,\"611\":1,\"612\":1,\"613\":1,\"645\":2,\"646\":1,\"649\":1}}],[\"requestconfig\",{\"1\":{\"328\":1}}],[\"requestbody\",{\"1\":{\"311\":2,\"314\":1}}],[\"requestmapping\",{\"1\":{\"311\":2}}],[\"request\",{\"1\":{\"300\":1,\"310\":3,\"311\":4,\"313\":5,\"314\":3,\"328\":2,\"727\":1}}],[\"rebuild\",{\"1\":{\"281\":2,\"293\":2}}],[\"react\",{\"1\":{\"300\":1}}],[\"readonly\",{\"1\":{\"687\":2}}],[\"readline\",{\"1\":{\"554\":1,\"622\":1}}],[\"read\",{\"1\":{\"274\":1,\"281\":1}}],[\"real\",{\"1\":{\"41\":1}}],[\"retention\",{\"1\":{\"626\":1}}],[\"ret\",{\"1\":{\"75\":2}}],[\"return\",{\"0\":{\"592\":1},\"1\":{\"25\":5,\"38\":1,\"39\":1,\"40\":1,\"43\":3,\"44\":3,\"48\":3,\"49\":2,\"50\":3,\"55\":2,\"56\":3,\"57\":3,\"65\":1,\"66\":1,\"67\":1,\"70\":1,\"75\":1,\"81\":1,\"82\":2,\"83\":1,\"90\":3,\"93\":3,\"94\":6,\"98\":2,\"99\":3,\"101\":2,\"107\":2,\"108\":2,\"109\":3,\"110\":3,\"111\":7,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":2,\"126\":1,\"127\":1,\"129\":6,\"131\":1,\"132\":1,\"134\":2,\"137\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":2,\"148\":5,\"149\":2,\"150\":2,\"159\":3,\"161\":1,\"165\":1,\"169\":1,\"172\":3,\"173\":2,\"174\":2,\"175\":2,\"176\":2,\"180\":2,\"181\":5,\"182\":5,\"183\":2,\"187\":3,\"189\":4,\"195\":1,\"196\":1,\"197\":2,\"199\":1,\"201\":1,\"203\":2,\"204\":5,\"205\":3,\"208\":1,\"209\":6,\"210\":2,\"212\":1,\"214\":1,\"231\":1,\"232\":2,\"234\":1,\"235\":1,\"236\":1,\"239\":2,\"240\":1,\"241\":1,\"243\":2,\"247\":2,\"248\":2,\"249\":2,\"250\":2,\"251\":1,\"310\":10,\"311\":8,\"313\":5,\"314\":4,\"323\":9,\"363\":3,\"366\":5,\"378\":1,\"389\":2,\"390\":2,\"396\":2,\"401\":2,\"402\":2,\"408\":4,\"414\":3,\"420\":7,\"426\":4,\"432\":3,\"438\":3,\"443\":3,\"444\":1,\"445\":3,\"451\":1,\"456\":1,\"463\":2,\"469\":2,\"474\":1,\"475\":2,\"481\":3,\"486\":3,\"487\":3,\"488\":4,\"583\":2,\"584\":1,\"587\":2,\"592\":4,\"593\":6,\"594\":5,\"595\":4,\"596\":2,\"600\":3,\"601\":1,\"606\":1,\"607\":1,\"628\":1,\"651\":1,\"673\":1,\"702\":1,\"707\":1,\"721\":2}}],[\"reverseorder\",{\"1\":{\"611\":1,\"640\":1,\"651\":1}}],[\"reverse\",{\"1\":{\"44\":1,\"150\":1,\"243\":4,\"578\":1}}],[\"result\",{\"1\":{\"322\":2,\"323\":16}}],[\"resources\",{\"0\":{\"622\":1}}],[\"resource\",{\"1\":{\"311\":1,\"323\":1,\"622\":1,\"673\":1,\"675\":1}}],[\"restart\",{\"1\":{\"353\":1}}],[\"restartsec=5s\",{\"1\":{\"353\":1}}],[\"restart=on\",{\"1\":{\"353\":1}}],[\"restcontroller\",{\"1\":{\"311\":2}}],[\"restful\",{\"1\":{\"311\":2}}],[\"restful接口等能力\",{\"1\":{\"300\":1}}],[\"reset\",{\"1\":{\"242\":1}}],[\"res++\",{\"1\":{\"125\":1,\"159\":1,\"183\":1,\"248\":1,\"250\":1,\"402\":1,\"443\":1,\"444\":1,\"445\":1}}],[\"resize\",{\"1\":{\"63\":2}}],[\"res\",{\"1\":{\"44\":8,\"50\":4,\"64\":2,\"65\":7,\"81\":5,\"82\":3,\"83\":4,\"110\":4,\"124\":4,\"125\":2,\"159\":2,\"160\":2,\"162\":4,\"180\":3,\"181\":3,\"183\":1,\"189\":7,\"195\":6,\"196\":4,\"199\":6,\"201\":4,\"208\":4,\"209\":4,\"210\":7,\"212\":4,\"214\":3,\"248\":2,\"250\":4,\"390\":3,\"402\":2,\"443\":2,\"444\":2,\"445\":4,\"583\":4,\"584\":5,\"628\":2}}],[\"right时返回\",{\"1\":{\"420\":1}}],[\"right不为空\",{\"1\":{\"408\":1}}],[\"right都不为空\",{\"1\":{\"408\":1}}],[\"rightsideview\",{\"1\":{\"389\":1,\"390\":1}}],[\"rightnodes\",{\"1\":{\"366\":2}}],[\"right\",{\"1\":{\"25\":3,\"363\":1,\"366\":2,\"376\":1,\"377\":6,\"378\":2,\"389\":1,\"390\":2,\"396\":2,\"401\":1,\"402\":2,\"408\":4,\"414\":1,\"419\":1,\"420\":10,\"432\":3,\"438\":1,\"463\":2,\"481\":1,\"486\":5,\"487\":1,\"488\":4,\"532\":1}}],[\"item\",{\"1\":{\"676\":3}}],[\"itemresult\",{\"1\":{\"676\":2}}],[\"iterable<result<item>>\",{\"1\":{\"676\":1}}],[\"itcast数据库存在时删除\",{\"1\":{\"502\":1}}],[\"itcast\",{\"1\":{\"502\":2}}],[\"imin\",{\"1\":{\"656\":1}}],[\"imax\",{\"1\":{\"656\":1}}],[\"import\",{\"1\":{\"554\":3,\"555\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":1,\"563\":1,\"565\":1,\"572\":3,\"574\":1,\"577\":2,\"579\":1,\"587\":1,\"591\":1,\"594\":1,\"595\":1,\"596\":1,\"599\":1,\"620\":1,\"621\":2,\"622\":1,\"628\":4,\"634\":1}}],[\"impossible\",{\"1\":{\"180\":1}}],[\"implements\",{\"1\":{\"311\":3,\"323\":1,\"606\":1,\"607\":1,\"632\":2,\"635\":1,\"707\":1}}],[\"illegalaccessexception\",{\"1\":{\"618\":1,\"628\":1}}],[\"illegalargumentexception\",{\"1\":{\"618\":1}}],[\"illegalthreadstateexception\",{\"1\":{\"618\":1}}],[\"illegalstateexception\",{\"1\":{\"618\":1}}],[\"illegalmonitorstateexception\",{\"1\":{\"618\":1}}],[\"iii\",{\"0\":{\"478\":1},\"1\":{\"478\":1}}],[\"ip为\",{\"1\":{\"346\":1}}],[\"ip\",{\"1\":{\"344\":1,\"345\":2,\"346\":7,\"347\":1,\"354\":1}}],[\"i18n\",{\"1\":{\"302\":1}}],[\"ioexception\",{\"1\":{\"617\":1,\"621\":5,\"622\":2,\"706\":1}}],[\"io\",{\"0\":{\"750\":1},\"1\":{\"289\":1,\"303\":1,\"340\":1,\"419\":1,\"544\":1,\"545\":3,\"554\":2,\"555\":2,\"621\":1,\"622\":1,\"662\":1,\"666\":1}}],[\"i的最小质因子\",{\"1\":{\"193\":1}}],[\"i的根节点指向j的根节点\",{\"1\":{\"91\":1}}],[\"i是素数\",{\"1\":{\"192\":1}}],[\"id>\",{\"1\":{\"663\":1}}],[\"idea\",{\"1\":{\"303\":1}}],[\"id=1\",{\"1\":{\"513\":1}}],[\"id=\",{\"1\":{\"263\":3}}],[\"id\",{\"1\":{\"165\":3,\"243\":1,\"263\":7,\"264\":2,\"269\":1,\"274\":2,\"289\":23,\"290\":2,\"291\":4,\"311\":1,\"321\":1,\"347\":1,\"506\":1,\"513\":1,\"529\":2,\"727\":2,\"728\":1}}],[\"idx表示当前用到了哪个节点\",{\"1\":{\"223\":1,\"224\":1}}],[\"idx++\",{\"1\":{\"43\":1,\"173\":1,\"175\":1,\"223\":1,\"224\":1}}],[\"idx\",{\"1\":{\"43\":4,\"165\":5,\"173\":4,\"175\":4,\"176\":1,\"182\":1,\"183\":1,\"223\":8,\"224\":6,\"232\":2,\"239\":4,\"426\":6,\"445\":6}}],[\"i表示所有的情况\",{\"1\":{\"132\":1}}],[\"i表示从哪个数开始\",{\"1\":{\"109\":1}}],[\"isbucketexists\",{\"1\":{\"675\":4}}],[\"isblank\",{\"1\":{\"642\":1}}],[\"isprime\",{\"1\":{\"565\":3,\"567\":3}}],[\"isolation\",{\"1\":{\"542\":2}}],[\"isvalidbst\",{\"1\":{\"486\":6,\"487\":3,\"488\":1}}],[\"isend\",{\"1\":{\"425\":3,\"426\":4}}],[\"isempty\",{\"1\":{\"390\":1,\"396\":1,\"402\":1,\"444\":1,\"469\":2,\"609\":1,\"611\":1,\"612\":1,\"613\":1,\"642\":1,\"646\":1,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"651\":1}}],[\"isnotblank\",{\"1\":{\"313\":1}}],[\"isadmin\",{\"1\":{\"313\":2,\"314\":1}}],[\"isanyblank\",{\"1\":{\"310\":1,\"311\":2,\"323\":1}}],[\"isdelete\",{\"1\":{\"310\":2,\"321\":2}}],[\"is\",{\"1\":{\"131\":4,\"187\":1,\"189\":1,\"192\":8,\"518\":1,\"557\":5,\"578\":3,\"584\":1,\"642\":2,\"706\":1}}],[\"issymmetric\",{\"1\":{\"432\":1}}],[\"issubtree\",{\"1\":{\"25\":3}}],[\"issametree\",{\"1\":{\"25\":4,\"432\":4}}],[\"i==nums\",{\"1\":{\"129\":1}}],[\"i−1个\",{\"1\":{\"200\":1}}],[\"i−1均与\",{\"1\":{\"200\":1}}],[\"i−1\",{\"1\":{\"128\":1}}],[\"i+1\",{\"1\":{\"110\":1,\"204\":1}}],[\"i++\",{\"1\":{\"43\":1,\"44\":4,\"48\":3,\"49\":4,\"50\":2,\"55\":3,\"56\":2,\"57\":2,\"64\":1,\"65\":1,\"81\":1,\"82\":2,\"83\":3,\"89\":1,\"93\":3,\"94\":2,\"98\":2,\"99\":2,\"101\":2,\"107\":1,\"108\":2,\"109\":2,\"110\":2,\"111\":3,\"116\":3,\"117\":3,\"118\":6,\"119\":3,\"121\":4,\"122\":7,\"123\":1,\"124\":4,\"125\":4,\"126\":2,\"127\":3,\"129\":8,\"132\":2,\"134\":3,\"137\":1,\"138\":3,\"144\":2,\"147\":1,\"148\":1,\"149\":1,\"160\":1,\"165\":1,\"169\":1,\"178\":2,\"180\":3,\"181\":2,\"187\":1,\"188\":1,\"189\":3,\"191\":1,\"192\":3,\"193\":1,\"195\":1,\"199\":1,\"204\":1,\"207\":1,\"212\":2,\"227\":1,\"230\":1,\"231\":2,\"234\":1,\"247\":2,\"248\":2,\"249\":2,\"250\":1,\"251\":1,\"420\":3,\"426\":2,\"443\":1,\"444\":1,\"445\":2,\"451\":1,\"456\":2,\"469\":2,\"474\":1,\"475\":2}}],[\"i\",{\"0\":{\"73\":1},\"1\":{\"41\":1,\"43\":15,\"44\":20,\"48\":11,\"49\":16,\"50\":9,\"55\":11,\"56\":12,\"57\":9,\"64\":4,\"65\":6,\"73\":1,\"81\":17,\"82\":13,\"83\":18,\"89\":4,\"91\":3,\"93\":10,\"94\":11,\"98\":7,\"99\":6,\"101\":9,\"107\":4,\"108\":9,\"109\":7,\"110\":9,\"111\":15,\"116\":20,\"117\":19,\"118\":30,\"119\":14,\"121\":25,\"122\":32,\"123\":16,\"124\":18,\"125\":22,\"126\":27,\"127\":26,\"128\":44,\"129\":44,\"131\":19,\"132\":15,\"134\":17,\"137\":11,\"138\":9,\"144\":7,\"147\":19,\"148\":29,\"149\":12,\"150\":12,\"152\":2,\"153\":1,\"159\":2,\"160\":5,\"165\":15,\"167\":5,\"168\":5,\"169\":10,\"172\":3,\"173\":7,\"174\":3,\"175\":7,\"176\":12,\"178\":10,\"180\":9,\"181\":10,\"182\":10,\"183\":9,\"187\":4,\"188\":7,\"189\":18,\"191\":6,\"192\":17,\"193\":15,\"195\":8,\"196\":7,\"199\":8,\"200\":26,\"204\":2,\"205\":30,\"207\":7,\"208\":9,\"209\":3,\"210\":22,\"212\":6,\"227\":4,\"230\":4,\"231\":16,\"232\":9,\"234\":5,\"235\":6,\"236\":6,\"237\":4,\"239\":5,\"241\":8,\"243\":1,\"247\":8,\"248\":9,\"249\":7,\"250\":8,\"251\":2,\"302\":1,\"419\":4,\"420\":16,\"426\":6,\"443\":13,\"444\":7,\"445\":21,\"450\":4,\"451\":14,\"456\":9,\"469\":16,\"473\":1,\"474\":3,\"475\":6,\"561\":13,\"563\":17,\"565\":4,\"566\":5,\"567\":9,\"572\":29,\"573\":8,\"578\":5,\"580\":5,\"583\":4,\"584\":4,\"591\":5,\"609\":2,\"620\":9,\"632\":9,\"634\":3,\"635\":6,\"636\":4}}],[\"invoke\",{\"1\":{\"628\":1}}],[\"invocationtargetexception\",{\"1\":{\"628\":2}}],[\"inverttree\",{\"1\":{\"463\":3}}],[\"inherited\",{\"1\":{\"626\":1}}],[\"input\",{\"1\":{\"622\":1}}],[\"inputstreamreader\",{\"1\":{\"554\":2}}],[\"innodb\",{\"1\":{\"545\":1}}],[\"inner\",{\"1\":{\"531\":1}}],[\"ingeger\",{\"1\":{\"486\":1}}],[\"inmap\",{\"1\":{\"420\":3}}],[\"inorder\",{\"1\":{\"418\":2,\"420\":12}}],[\"increment\",{\"1\":{\"321\":1,\"506\":3}}],[\"include<algorithm>\",{\"1\":{\"132\":1}}],[\"include<cstring>\",{\"1\":{\"132\":1}}],[\"include<iostream>\",{\"1\":{\"132\":1,\"212\":1}}],[\"include\",{\"1\":{\"43\":4,\"44\":5,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"81\":3,\"82\":3,\"83\":3,\"93\":3,\"94\":2,\"98\":4,\"99\":5,\"101\":3,\"107\":3,\"108\":3,\"109\":3,\"110\":3,\"111\":3,\"116\":3,\"117\":3,\"118\":10,\"119\":6,\"121\":2,\"122\":9,\"123\":3,\"124\":3,\"125\":3,\"126\":3,\"127\":3,\"128\":1,\"129\":1,\"131\":4,\"134\":1,\"144\":2,\"147\":2,\"148\":2,\"149\":2,\"150\":3,\"159\":2,\"172\":3,\"180\":1,\"181\":1,\"196\":4,\"204\":2,\"214\":2,\"231\":1,\"247\":2,\"248\":2,\"249\":3,\"250\":2,\"251\":4}}],[\"instanceinfo\",{\"0\":{\"711\":1},\"1\":{\"711\":4,\"712\":2,\"715\":2}}],[\"instanceconfig\",{\"0\":{\"710\":1},\"1\":{\"710\":4,\"712\":2}}],[\"instance\",{\"1\":{\"702\":6,\"714\":1,\"715\":1}}],[\"instantiationexception\",{\"1\":{\"618\":1,\"628\":1}}],[\"installed\",{\"1\":{\"706\":1}}],[\"install\",{\"1\":{\"353\":1,\"663\":1}}],[\"inspections\",{\"1\":{\"311\":1}}],[\"insert\",{\"0\":{\"512\":1},\"1\":{\"223\":1,\"224\":1,\"232\":1,\"239\":1,\"242\":2,\"323\":1,\"424\":1,\"426\":1,\"511\":1,\"512\":6,\"534\":1,\"544\":1}}],[\"inline\",{\"1\":{\"204\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"617\":1,\"618\":1}}],[\"indexofsublist\",{\"1\":{\"654\":1}}],[\"indexof\",{\"1\":{\"578\":2,\"642\":2}}],[\"index\",{\"1\":{\"263\":4,\"264\":3,\"270\":1,\"289\":9,\"291\":1,\"544\":1,\"546\":3,\"642\":4,\"643\":1,\"645\":4,\"667\":1,\"696\":1}}],[\"index指向下一个指针\",{\"1\":{\"223\":1}}],[\"ind\",{\"1\":{\"134\":5}}],[\"info\",{\"1\":{\"310\":1,\"722\":2}}],[\"infact\",{\"1\":{\"208\":4}}],[\"inf\",{\"1\":{\"121\":3,\"174\":3,\"178\":1,\"180\":3,\"181\":1}}],[\"initializing\",{\"1\":{\"722\":1}}],[\"initialized\",{\"1\":{\"722\":1}}],[\"initialize\",{\"1\":{\"721\":3,\"722\":2}}],[\"initialcapacity\",{\"1\":{\"645\":1}}],[\"initscheduledtasks\",{\"1\":{\"715\":1}}],[\"initconfig\",{\"1\":{\"714\":1}}],[\"initwithconfigurationsource\",{\"1\":{\"707\":1}}],[\"initeurekaservercontext\",{\"1\":{\"702\":1,\"703\":2,\"704\":1}}],[\"initeurekaenvironment\",{\"1\":{\"702\":2}}],[\"init\",{\"1\":{\"87\":1,\"89\":1,\"93\":2,\"94\":2,\"129\":2,\"181\":2,\"223\":1,\"224\":1,\"234\":1,\"563\":3,\"705\":2,\"706\":1,\"708\":2,\"722\":2}}],[\"int会被隐式转化成字符串\",{\"1\":{\"578\":1}}],[\"into\",{\"1\":{\"512\":4}}],[\"interrupt\",{\"1\":{\"633\":1}}],[\"interruptedexception\",{\"1\":{\"618\":1,\"632\":3,\"634\":1,\"635\":2,\"636\":2}}],[\"interface\",{\"0\":{\"258\":1},\"1\":{\"258\":1,\"261\":2,\"315\":1,\"603\":1,\"604\":1,\"605\":1}}],[\"integer\",{\"1\":{\"481\":2,\"486\":2,\"507\":1,\"647\":1,\"656\":2}}],[\"integer>>\",{\"1\":{\"444\":1,\"469\":1}}],[\"integer>\",{\"1\":{\"420\":3,\"444\":1,\"469\":1,\"481\":1,\"647\":4}}],[\"int\",{\"0\":{\"71\":1},\"1\":{\"43\":18,\"44\":15,\"48\":15,\"49\":13,\"50\":10,\"55\":13,\"56\":15,\"57\":14,\"64\":1,\"65\":5,\"66\":2,\"67\":3,\"70\":3,\"71\":5,\"75\":6,\"76\":9,\"77\":4,\"81\":4,\"82\":5,\"83\":11,\"89\":3,\"90\":4,\"91\":4,\"93\":14,\"94\":16,\"98\":11,\"99\":10,\"101\":7,\"107\":6,\"108\":7,\"109\":8,\"110\":10,\"111\":16,\"116\":10,\"117\":10,\"118\":32,\"119\":19,\"121\":15,\"122\":25,\"123\":6,\"124\":12,\"125\":14,\"126\":8,\"127\":14,\"128\":9,\"129\":25,\"131\":10,\"132\":9,\"134\":12,\"137\":4,\"138\":6,\"141\":4,\"142\":4,\"143\":5,\"144\":5,\"147\":7,\"148\":8,\"149\":7,\"150\":8,\"158\":2,\"159\":10,\"160\":1,\"161\":4,\"162\":1,\"165\":19,\"167\":4,\"168\":3,\"169\":5,\"172\":11,\"173\":10,\"174\":7,\"175\":10,\"176\":7,\"178\":5,\"180\":15,\"181\":17,\"182\":8,\"183\":8,\"187\":2,\"188\":3,\"189\":6,\"191\":4,\"192\":4,\"193\":5,\"195\":2,\"196\":5,\"197\":6,\"199\":4,\"200\":6,\"201\":5,\"203\":6,\"204\":1,\"205\":13,\"207\":2,\"208\":6,\"209\":14,\"210\":16,\"212\":9,\"214\":4,\"223\":5,\"224\":4,\"226\":2,\"227\":2,\"229\":1,\"230\":2,\"231\":6,\"232\":10,\"234\":9,\"235\":4,\"236\":5,\"237\":7,\"239\":6,\"240\":4,\"241\":3,\"243\":10,\"247\":8,\"248\":7,\"249\":6,\"250\":9,\"251\":6,\"315\":2,\"321\":4,\"323\":1,\"363\":4,\"366\":6,\"389\":1,\"390\":1,\"396\":1,\"401\":3,\"402\":2,\"414\":5,\"420\":19,\"426\":6,\"438\":5,\"443\":8,\"444\":13,\"445\":15,\"451\":6,\"456\":4,\"469\":30,\"474\":5,\"475\":9,\"481\":5,\"486\":2,\"507\":1,\"551\":6,\"553\":5,\"554\":1,\"555\":1,\"557\":9,\"558\":2,\"559\":1,\"561\":6,\"562\":2,\"563\":9,\"565\":2,\"566\":2,\"567\":4,\"570\":2,\"571\":3,\"572\":18,\"573\":8,\"574\":3,\"575\":2,\"577\":4,\"578\":3,\"580\":1,\"583\":4,\"584\":5,\"586\":5,\"587\":2,\"588\":2,\"590\":2,\"591\":4,\"593\":3,\"594\":4,\"595\":4,\"596\":3,\"600\":8,\"601\":2,\"604\":1,\"606\":1,\"607\":1,\"620\":6,\"621\":1,\"628\":7,\"632\":3,\"634\":2,\"635\":4,\"636\":1,\"642\":6,\"643\":1,\"645\":7,\"651\":1,\"707\":1,\"724\":1}}],[\"int>>\",{\"1\":{\"456\":1}}],[\"int>\",{\"1\":{\"43\":1,\"44\":1,\"98\":1,\"99\":1,\"173\":1,\"189\":2,\"196\":1,\"242\":1,\"251\":1}}],[\"in\",{\"1\":{\"41\":1,\"263\":2,\"289\":1,\"518\":1,\"536\":2,\"537\":2,\"554\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":1,\"563\":1,\"565\":1,\"572\":3,\"579\":1,\"594\":1,\"596\":1,\"620\":1,\"621\":1,\"622\":1,\"647\":2}}],[\"if\",{\"0\":{\"557\":1},\"1\":{\"25\":3,\"43\":5,\"44\":8,\"48\":3,\"49\":2,\"50\":2,\"55\":4,\"56\":7,\"57\":5,\"64\":2,\"70\":1,\"75\":2,\"82\":3,\"90\":1,\"93\":2,\"94\":8,\"98\":1,\"99\":3,\"101\":2,\"107\":2,\"108\":2,\"109\":2,\"110\":3,\"111\":9,\"116\":1,\"117\":1,\"118\":2,\"119\":2,\"122\":4,\"123\":2,\"124\":2,\"125\":2,\"126\":2,\"127\":1,\"128\":1,\"129\":4,\"131\":4,\"132\":2,\"134\":3,\"137\":2,\"138\":2,\"141\":1,\"142\":1,\"143\":1,\"145\":1,\"147\":3,\"148\":5,\"149\":1,\"158\":3,\"161\":1,\"162\":3,\"165\":3,\"167\":1,\"168\":1,\"169\":2,\"172\":2,\"173\":3,\"174\":4,\"175\":3,\"176\":3,\"178\":1,\"180\":4,\"181\":6,\"182\":5,\"183\":3,\"187\":2,\"188\":2,\"189\":4,\"191\":1,\"192\":1,\"193\":2,\"195\":2,\"196\":1,\"199\":2,\"200\":2,\"201\":1,\"203\":1,\"204\":2,\"205\":5,\"207\":1,\"208\":1,\"209\":3,\"210\":2,\"212\":4,\"214\":1,\"226\":1,\"229\":1,\"230\":2,\"231\":3,\"232\":2,\"234\":2,\"235\":1,\"236\":1,\"237\":3,\"239\":1,\"240\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":3,\"251\":3,\"310\":6,\"311\":4,\"313\":3,\"314\":2,\"323\":7,\"363\":3,\"366\":3,\"377\":1,\"378\":1,\"389\":2,\"390\":4,\"396\":3,\"401\":1,\"402\":3,\"408\":3,\"414\":1,\"420\":5,\"426\":2,\"432\":1,\"438\":1,\"443\":3,\"444\":2,\"445\":5,\"451\":1,\"463\":1,\"469\":6,\"475\":2,\"481\":1,\"486\":1,\"487\":2,\"488\":2,\"500\":3,\"502\":3,\"510\":2,\"557\":24,\"558\":4,\"561\":2,\"565\":3,\"566\":2,\"567\":2,\"572\":1,\"593\":1,\"594\":1,\"595\":2,\"596\":1,\"621\":1,\"636\":1,\"647\":1,\"675\":1,\"702\":2,\"706\":1,\"715\":2}}],[\"qq号码\",{\"1\":{\"509\":2}}],[\"qq\",{\"1\":{\"311\":1,\"322\":1,\"509\":6}}],[\"qmi\",{\"1\":{\"201\":1,\"208\":2,\"209\":2}}],[\"querywrapper<>\",{\"1\":{\"310\":1,\"313\":1,\"323\":1}}],[\"querywrapper<user>\",{\"1\":{\"310\":1,\"313\":1,\"323\":1}}],[\"querywrapper\",{\"1\":{\"310\":4,\"313\":3,\"323\":3}}],[\"query\",{\"1\":{\"232\":1,\"496\":1}}],[\"queue\",{\"0\":{\"649\":1},\"1\":{\"175\":2,\"242\":2,\"649\":2,\"650\":2}}],[\"queue<e>\",{\"1\":{\"649\":1}}],[\"queue<>\",{\"1\":{\"611\":1}}],[\"queue<pair<int\",{\"1\":{\"456\":1}}],[\"queue<pair<integer\",{\"1\":{\"444\":1,\"469\":1}}],[\"queue<pis\",{\"1\":{\"44\":1}}],[\"queue<pii>\",{\"1\":{\"98\":1}}],[\"queue<piii\",{\"1\":{\"43\":1}}],[\"queue<pii\",{\"1\":{\"43\":1,\"173\":1}}],[\"queue<treenode>\",{\"1\":{\"390\":1,\"396\":1}}],[\"queue<int\",{\"1\":{\"242\":1,\"249\":1}}],[\"queue<int>\",{\"1\":{\"168\":1,\"175\":1,\"176\":1}}],[\"queue<string>\",{\"1\":{\"99\":1}}],[\"quick\",{\"1\":{\"137\":3}}],[\"q\",{\"1\":{\"25\":6,\"41\":1,\"93\":6,\"98\":6,\"99\":6,\"122\":4,\"137\":8,\"168\":6,\"169\":3,\"175\":8,\"176\":6,\"229\":4,\"230\":3,\"242\":1,\"390\":7,\"396\":7,\"402\":5,\"406\":2,\"408\":4,\"432\":6,\"444\":5,\"456\":7,\"469\":12,\"649\":1,\"650\":1}}],[\"png\",{\"1\":{\"616\":1}}],[\"p端口号\",{\"1\":{\"493\":1}}],[\"p密码\",{\"1\":{\"493\":1}}],[\"pki\",{\"1\":{\"354\":2}}],[\"pk^1\",{\"1\":{\"196\":1}}],[\"pk^0\",{\"1\":{\"196\":1}}],[\"pk^ck\",{\"1\":{\"196\":2}}],[\"ps\",{\"1\":{\"354\":1}}],[\"peereurekanodes\",{\"1\":{\"719\":3,\"720\":1,\"722\":4}}],[\"peerawareinstanceregistryimpl\",{\"1\":{\"717\":3}}],[\"peeklast\",{\"1\":{\"650\":1}}],[\"peekfirst\",{\"1\":{\"650\":1}}],[\"peek\",{\"1\":{\"610\":1,\"611\":1,\"648\":1,\"649\":1,\"651\":1}}],[\"pem存放路径\",{\"1\":{\"354\":1}}],[\"pem\",{\"1\":{\"354\":2}}],[\"pe\",{\"1\":{\"345\":1}}],[\"permanent\",{\"1\":{\"345\":2}}],[\"p=0\",{\"1\":{\"334\":3}}],[\"player\",{\"1\":{\"340\":1}}],[\"playwright\",{\"1\":{\"302\":2}}],[\"plugins\",{\"1\":{\"727\":1}}],[\"plugin\",{\"1\":{\"340\":1,\"727\":1,\"728\":1}}],[\"plus\",{\"1\":{\"75\":2,\"300\":1,\"303\":1,\"310\":2,\"322\":2}}],[\"policyjsonstring\",{\"1\":{\"675\":2}}],[\"polllast\",{\"1\":{\"650\":1}}],[\"pollfirst\",{\"1\":{\"650\":1}}],[\"poll\",{\"1\":{\"390\":1,\"396\":1,\"444\":1,\"469\":1,\"649\":1,\"651\":1}}],[\"pow\",{\"1\":{\"653\":1}}],[\"point\",{\"1\":{\"600\":2,\"601\":1,\"602\":5}}],[\"pos\",{\"1\":{\"469\":3}}],[\"postmapping\",{\"1\":{\"311\":2}}],[\"post\",{\"1\":{\"274\":1,\"308\":1}}],[\"ports\",{\"1\":{\"345\":1}}],[\"port=10123\",{\"1\":{\"345\":2}}],[\"pop\",{\"1\":{\"43\":2,\"44\":1,\"98\":1,\"99\":1,\"148\":1,\"149\":1,\"150\":1,\"168\":1,\"173\":1,\"175\":2,\"176\":1,\"242\":6,\"249\":1,\"456\":1,\"610\":1,\"648\":1}}],[\"phone\",{\"1\":{\"321\":2,\"507\":2}}],[\"ph\",{\"1\":{\"237\":4}}],[\"phi\",{\"1\":{\"199\":1,\"200\":5}}],[\"p+1\",{\"1\":{\"231\":1}}],[\"p为匹配串\",{\"1\":{\"231\":1}}],[\"pm​​\",{\"1\":{\"212\":1}}],[\"pm​\",{\"1\":{\"212\":1}}],[\"pmam​​\",{\"1\":{\"199\":1}}],[\"p2​\",{\"1\":{\"212\":2}}],[\"p2^c2\",{\"1\":{\"196\":1}}],[\"p1​\",{\"1\":{\"212\":2}}],[\"p1^1\",{\"1\":{\"196\":1}}],[\"p1^0\",{\"1\":{\"196\":1}}],[\"p1^c1\",{\"1\":{\"196\":2}}],[\"p^k\",{\"1\":{\"241\":1}}],[\"p^3\",{\"1\":{\"210\":1}}],[\"p^2\",{\"1\":{\"210\":1}}],[\"p​∗cpa​pb​​\",{\"1\":{\"209\":1}}],[\"pj=0\",{\"1\":{\"193\":1}}],[\"pj一定是pj\",{\"1\":{\"193\":1}}],[\"pb\",{\"1\":{\"181\":2,\"209\":1}}],[\"python\",{\"1\":{\"668\":1}}],[\"python中的\",{\"1\":{\"69\":1}}],[\"py\",{\"1\":{\"181\":6,\"234\":6,\"668\":1}}],[\"px\",{\"1\":{\"181\":7,\"234\":6}}],[\"p3367\",{\"0\":{\"94\":1}}],[\"presignedobjecturl\",{\"1\":{\"676\":2}}],[\"presto\",{\"1\":{\"668\":1}}],[\"preset\",{\"1\":{\"302\":1}}],[\"prerequisites\",{\"1\":{\"473\":2,\"474\":1}}],[\"preread\",{\"1\":{\"346\":1}}],[\"prefix\",{\"1\":{\"424\":2,\"426\":2,\"673\":1}}],[\"prefer\",{\"1\":{\"354\":1}}],[\"premap\",{\"1\":{\"420\":3}}],[\"preorder\",{\"1\":{\"418\":2,\"419\":1,\"420\":19}}],[\"pre\",{\"1\":{\"377\":5,\"378\":5,\"487\":3}}],[\"prev\",{\"1\":{\"44\":4}}],[\"provider\",{\"1\":{\"711\":1}}],[\"prop\",{\"1\":{\"706\":1}}],[\"properties\",{\"1\":{\"706\":6,\"707\":1,\"708\":1,\"714\":1}}],[\"props\",{\"1\":{\"706\":8}}],[\"protected\",{\"1\":{\"600\":1}}],[\"protobuf\",{\"1\":{\"291\":2}}],[\"profile=system\",{\"1\":{\"354\":1}}],[\"proxy\",{\"1\":{\"346\":1,\"354\":4}}],[\"pro\",{\"1\":{\"300\":1,\"302\":4}}],[\"principal\",{\"1\":{\"675\":1}}],[\"printstacktrace\",{\"1\":{\"619\":1,\"620\":2,\"621\":2}}],[\"println\",{\"1\":{\"322\":1,\"553\":9,\"554\":1,\"555\":2,\"557\":16,\"558\":5,\"559\":1,\"561\":4,\"562\":2,\"563\":4,\"565\":2,\"566\":1,\"567\":2,\"572\":2,\"573\":1,\"574\":1,\"577\":5,\"579\":1,\"580\":2,\"587\":2,\"588\":3,\"590\":1,\"591\":2,\"594\":1,\"595\":4,\"596\":1,\"602\":2,\"606\":3,\"607\":3,\"620\":3,\"621\":2,\"622\":2,\"628\":3,\"632\":3,\"634\":1,\"635\":2,\"636\":1,\"642\":2,\"675\":3,\"676\":6}}],[\"print\",{\"1\":{\"129\":2,\"555\":2,\"578\":2}}],[\"printf\",{\"1\":{\"63\":4,\"71\":1,\"101\":1,\"129\":1,\"134\":1,\"147\":1,\"148\":3,\"149\":1,\"165\":1,\"180\":1,\"204\":1,\"231\":1,\"555\":2,\"557\":14,\"567\":1,\"572\":3,\"573\":1,\"574\":1,\"579\":1,\"584\":1,\"593\":1}}],[\"private\",{\"1\":{\"311\":8,\"313\":1,\"323\":2,\"426\":3,\"522\":2,\"583\":2,\"584\":1,\"587\":2,\"588\":4,\"590\":1,\"591\":2,\"593\":1,\"594\":1,\"595\":2,\"596\":1,\"600\":3,\"601\":1,\"606\":1,\"607\":1,\"620\":1,\"621\":1,\"634\":1,\"635\":1,\"636\":2,\"673\":5,\"706\":2,\"721\":1}}],[\"primary\",{\"1\":{\"283\":2,\"321\":1,\"506\":1}}],[\"primes2\",{\"1\":{\"192\":4}}],[\"primes\",{\"1\":{\"191\":4,\"192\":3,\"193\":17,\"196\":4,\"200\":21,\"210\":9}}],[\"prime\",{\"1\":{\"187\":1,\"189\":2,\"192\":2,\"193\":1}}],[\"prim\",{\"1\":{\"180\":2}}],[\"priorityqueue<e>\",{\"1\":{\"651\":4}}],[\"priorityqueue<>\",{\"1\":{\"611\":2,\"651\":2}}],[\"priorityqueue\",{\"0\":{\"651\":1},\"1\":{\"651\":4}}],[\"priority\",{\"1\":{\"43\":2,\"44\":1,\"173\":1,\"242\":2,\"249\":1,\"456\":1}}],[\"picgo\",{\"1\":{\"350\":1}}],[\"ping\",{\"1\":{\"345\":1}}],[\"pipeline\",{\"1\":{\"273\":1}}],[\"pi​​\",{\"1\":{\"212\":1}}],[\"pis\",{\"1\":{\"44\":1}}],[\"pii>\",{\"1\":{\"43\":1}}],[\"piii\",{\"1\":{\"43\":1}}],[\"pii\",{\"1\":{\"43\":1,\"98\":1,\"173\":1,\"251\":1}}],[\"pull\",{\"1\":{\"661\":1}}],[\"putall\",{\"1\":{\"706\":2}}],[\"putobjectargs\",{\"1\":{\"676\":1}}],[\"putobject\",{\"1\":{\"676\":2}}],[\"put\",{\"1\":{\"93\":2,\"420\":3,\"481\":1,\"613\":1,\"647\":2}}],[\"puts\",{\"1\":{\"44\":1,\"101\":1,\"108\":1,\"109\":1,\"129\":1,\"180\":1,\"204\":1,\"214\":2}}],[\"push\",{\"1\":{\"43\":4,\"44\":2,\"98\":2,\"99\":2,\"118\":2,\"122\":2,\"129\":2,\"131\":1,\"147\":4,\"148\":3,\"149\":2,\"150\":2,\"162\":2,\"165\":2,\"168\":2,\"173\":2,\"175\":2,\"176\":2,\"189\":2,\"195\":2,\"210\":3,\"242\":6,\"249\":2,\"251\":3,\"456\":3,\"610\":1,\"648\":1}}],[\"publicread\",{\"1\":{\"675\":1}}],[\"public\",{\"1\":{\"25\":1,\"310\":2,\"311\":5,\"313\":1,\"314\":1,\"315\":1,\"323\":2,\"363\":1,\"366\":2,\"377\":1,\"378\":1,\"389\":1,\"390\":1,\"396\":1,\"401\":1,\"402\":1,\"408\":1,\"414\":1,\"420\":2,\"426\":4,\"432\":1,\"438\":1,\"443\":1,\"444\":1,\"445\":1,\"451\":1,\"456\":1,\"463\":1,\"469\":2,\"475\":1,\"481\":1,\"486\":1,\"487\":1,\"488\":1,\"522\":1,\"551\":2,\"553\":6,\"554\":4,\"555\":4,\"557\":18,\"558\":4,\"559\":2,\"561\":8,\"562\":2,\"563\":8,\"565\":2,\"566\":2,\"567\":4,\"570\":2,\"571\":2,\"572\":8,\"573\":4,\"574\":2,\"577\":4,\"579\":2,\"584\":2,\"587\":2,\"588\":2,\"590\":2,\"591\":2,\"593\":2,\"594\":2,\"595\":2,\"596\":2,\"599\":3,\"600\":7,\"601\":3,\"602\":2,\"604\":4,\"605\":1,\"606\":4,\"607\":6,\"619\":6,\"620\":2,\"621\":2,\"622\":2,\"628\":7,\"632\":7,\"634\":4,\"635\":10,\"636\":4,\"651\":1,\"673\":3,\"702\":2,\"705\":1,\"707\":2,\"721\":3,\"722\":1}}],[\"pagebean\",{\"1\":{\"522\":2}}],[\"pagesize\",{\"1\":{\"522\":1}}],[\"page\",{\"1\":{\"354\":2,\"522\":1,\"545\":1}}],[\"panel\",{\"1\":{\"354\":1}}],[\"pattern>\",{\"1\":{\"663\":1}}],[\"pattern\",{\"1\":{\"310\":1,\"323\":1}}],[\"pathsum\",{\"1\":{\"481\":1}}],[\"path\",{\"1\":{\"101\":3,\"311\":1,\"353\":3}}],[\"pass\",{\"1\":{\"346\":1,\"354\":1}}],[\"passward\",{\"1\":{\"323\":11}}],[\"password=password\",{\"1\":{\"660\":2}}],[\"password\",{\"1\":{\"310\":5,\"311\":8,\"321\":2,\"323\":6}}],[\"pascal中的\",{\"1\":{\"69\":1}}],[\"package\",{\"1\":{\"302\":2,\"599\":1,\"628\":2,\"636\":1,\"655\":1}}],[\"pa\",{\"1\":{\"181\":2}}],[\"pair\",{\"1\":{\"77\":1,\"655\":1}}],[\"pair<k\",{\"0\":{\"655\":1},\"1\":{\"655\":1}}],[\"pair<>\",{\"1\":{\"444\":2,\"469\":2}}],[\"pair<first\",{\"1\":{\"77\":1}}],[\"pair<string\",{\"1\":{\"44\":1}}],[\"pair<integer\",{\"1\":{\"444\":1,\"469\":1}}],[\"pair<int\",{\"1\":{\"43\":2,\"44\":1,\"98\":1,\"173\":1,\"242\":1,\"251\":1}}],[\"parseboolean\",{\"1\":{\"642\":1}}],[\"parseint\",{\"1\":{\"642\":1}}],[\"parsedouble\",{\"1\":{\"578\":1}}],[\"param\",{\"1\":{\"310\":4,\"311\":3,\"313\":2,\"314\":2,\"323\":3}}],[\"params\",{\"1\":{\"75\":2}}],[\"partitions\",{\"1\":{\"282\":1}}],[\"partition\",{\"1\":{\"282\":2}}],[\"parent\",{\"1\":{\"35\":3,\"289\":2,\"445\":1}}],[\"p\",{\"1\":{\"25\":6,\"75\":2,\"181\":8,\"196\":3,\"201\":5,\"208\":5,\"209\":31,\"210\":8,\"212\":4,\"231\":7,\"232\":11,\"234\":8,\"235\":8,\"236\":9,\"241\":10,\"274\":2,\"334\":2,\"406\":2,\"408\":4,\"432\":6,\"445\":8,\"493\":3,\"661\":2}}],[\"snail\",{\"1\":{\"728\":1}}],[\"snprintf\",{\"1\":{\"71\":1}}],[\"s3\",{\"1\":{\"666\":1,\"668\":5,\"675\":2}}],[\"sb\",{\"1\":{\"580\":7,\"591\":5,\"643\":1}}],[\"swtich\",{\"1\":{\"559\":1}}],[\"switch\",{\"0\":{\"559\":1},\"1\":{\"559\":1}}],[\"swagger\",{\"1\":{\"302\":2}}],[\"swap\",{\"1\":{\"44\":2,\"99\":2,\"129\":1,\"137\":1,\"158\":1,\"205\":1,\"237\":6,\"593\":2}}],[\"small\",{\"1\":{\"557\":2}}],[\"smallint\",{\"1\":{\"507\":1}}],[\"s2\",{\"1\":{\"449\":1,\"450\":1,\"451\":7,\"642\":1}}],[\"s1\",{\"1\":{\"449\":1,\"450\":1,\"451\":7,\"642\":1}}],[\"ss\",{\"1\":{\"507\":3,\"642\":1}}],[\"ssl\",{\"1\":{\"346\":1,\"354\":11}}],[\"sscanf\",{\"1\":{\"71\":2}}],[\"sscnaf\",{\"1\":{\"71\":1}}],[\"sleep\",{\"1\":{\"632\":3,\"633\":1,\"636\":1}}],[\"slf4j\",{\"1\":{\"323\":1}}],[\"sla\",{\"1\":{\"258\":1}}],[\"satrt\",{\"1\":{\"645\":1}}],[\"saturday\",{\"1\":{\"559\":1}}],[\"save\",{\"1\":{\"322\":1}}],[\"safetyuser\",{\"1\":{\"310\":16}}],[\"salt\",{\"1\":{\"310\":1,\"323\":2}}],[\"src\",{\"1\":{\"302\":3,\"702\":1}}],[\"sqlexception\",{\"1\":{\"617\":1}}],[\"sql语句\",{\"1\":{\"541\":1}}],[\"sql优化\",{\"1\":{\"497\":1}}],[\"sql\",{\"0\":{\"494\":1,\"495\":1},\"1\":{\"300\":1,\"322\":1,\"494\":1,\"495\":3,\"496\":1,\"529\":1,\"532\":1,\"534\":1,\"540\":4,\"541\":2,\"542\":1}}],[\"sqrt\",{\"1\":{\"40\":1,\"187\":2,\"188\":5,\"653\":1}}],[\"sh\",{\"1\":{\"680\":8,\"692\":4}}],[\"shell脚本在逐行执行\",{\"1\":{\"680\":1}}],[\"shell\",{\"0\":{\"679\":1},\"1\":{\"660\":1,\"680\":7,\"692\":1}}],[\"shtml\",{\"1\":{\"659\":1}}],[\"shmin\",{\"1\":{\"656\":1}}],[\"shmax\",{\"1\":{\"656\":1}}],[\"shouldregisterwitheureka\",{\"1\":{\"715\":1}}],[\"shouldfetchregistry\",{\"1\":{\"715\":1}}],[\"show\",{\"1\":{\"499\":1,\"502\":1,\"508\":2,\"545\":1,\"546\":1}}],[\"short\",{\"1\":{\"293\":1,\"551\":1,\"656\":2}}],[\"shared\",{\"1\":{\"354\":1}}],[\"share\",{\"1\":{\"354\":1}}],[\"shuffle\",{\"1\":{\"243\":1}}],[\"skiplist\",{\"1\":{\"291\":1}}],[\"skew\",{\"1\":{\"270\":1}}],[\"sdk\",{\"1\":{\"284\":1,\"350\":1,\"668\":7}}],[\"scheduler\",{\"1\":{\"715\":1}}],[\"schemas\",{\"1\":{\"502\":1}}],[\"schema\",{\"1\":{\"502\":2}}],[\"sc\",{\"1\":{\"554\":6,\"557\":22,\"558\":6,\"559\":2,\"561\":2,\"563\":2,\"565\":2,\"572\":8,\"578\":1,\"579\":3,\"594\":3,\"596\":2,\"620\":3,\"621\":2}}],[\"scanner\",{\"1\":{\"554\":3,\"557\":27,\"558\":6,\"559\":3,\"561\":3,\"563\":3,\"565\":3,\"572\":9,\"574\":1,\"579\":3,\"594\":3,\"595\":1,\"596\":3,\"620\":3,\"621\":3}}],[\"scanf\",{\"1\":{\"93\":1,\"134\":2,\"165\":2,\"204\":3}}],[\"scripts\",{\"1\":{\"302\":2}}],[\"score\",{\"1\":{\"264\":1,\"291\":1,\"642\":2}}],[\"s+1\",{\"1\":{\"231\":1}}],[\"s++\",{\"1\":{\"188\":1,\"212\":1}}],[\"s为模式串\",{\"1\":{\"231\":1}}],[\"sg\",{\"1\":{\"218\":5,\"219\":4}}],[\"sg游戏\",{\"0\":{\"218\":1}}],[\"sino\",{\"1\":{\"728\":1}}],[\"singleflight\",{\"1\":{\"264\":1,\"293\":4}}],[\"sid\",{\"1\":{\"675\":1}}],[\"signed\",{\"1\":{\"507\":1}}],[\"simple\",{\"1\":{\"302\":1}}],[\"si​\",{\"1\":{\"212\":1}}],[\"sizethreshold>\",{\"1\":{\"663\":1}}],[\"sizeof\",{\"1\":{\"43\":3,\"98\":1,\"111\":1,\"131\":1,\"132\":1,\"165\":1,\"172\":2,\"173\":1,\"174\":1,\"175\":1,\"180\":2,\"182\":1,\"183\":1}}],[\"size\",{\"1\":{\"41\":1,\"43\":2,\"44\":5,\"63\":9,\"66\":2,\"72\":3,\"94\":15,\"98\":1,\"122\":1,\"129\":3,\"147\":7,\"148\":12,\"149\":5,\"150\":4,\"161\":1,\"168\":1,\"173\":1,\"175\":1,\"176\":1,\"210\":1,\"235\":5,\"237\":9,\"242\":7,\"243\":1,\"249\":1,\"251\":1,\"354\":1,\"389\":2,\"390\":1,\"396\":1,\"456\":1,\"468\":1,\"469\":3,\"545\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"613\":1,\"645\":2,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"651\":1,\"663\":1}}],[\"s表示次幂\",{\"1\":{\"188\":1}}],[\"specific\",{\"1\":{\"706\":1}}],[\"specified\",{\"1\":{\"706\":1}}],[\"spark\",{\"1\":{\"668\":1}}],[\"split\",{\"1\":{\"578\":2,\"642\":2}}],[\"springcloud\",{\"2\":{\"731\":1}}],[\"springboot\",{\"0\":{\"671\":1},\"1\":{\"300\":1,\"303\":1,\"309\":1,\"673\":1}}],[\"springmvc\",{\"1\":{\"300\":1}}],[\"spring\",{\"0\":{\"755\":1},\"1\":{\"300\":2,\"303\":1,\"312\":1}}],[\"sprintf\",{\"1\":{\"71\":3}}],[\"spm\",{\"1\":{\"274\":2}}],[\"spfa求最短路\",{\"1\":{\"175\":1}}],[\"spfa算法判断图中是否存在负环\",{\"0\":{\"176\":1}}],[\"spfa算法\",{\"0\":{\"175\":1}}],[\"spfa\",{\"1\":{\"171\":1,\"175\":1,\"176\":1}}],[\"spj\",{\"1\":{\"107\":1}}],[\"syncup\",{\"1\":{\"724\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"715\":2}}],[\"synchronized\",{\"0\":{\"635\":1},\"1\":{\"635\":4,\"636\":1,\"702\":1,\"721\":1}}],[\"syslogd\",{\"1\":{\"353\":1}}],[\"systemd\",{\"1\":{\"353\":4}}],[\"systemctl\",{\"1\":{\"345\":2,\"353\":8}}],[\"system\",{\"0\":{\"740\":1,\"753\":1},\"1\":{\"69\":1,\"322\":1,\"353\":1,\"553\":9,\"554\":3,\"555\":7,\"557\":39,\"558\":7,\"559\":2,\"561\":5,\"562\":2,\"563\":5,\"565\":3,\"566\":1,\"567\":3,\"572\":8,\"573\":2,\"574\":2,\"577\":5,\"578\":2,\"579\":3,\"580\":2,\"584\":1,\"587\":2,\"588\":3,\"590\":1,\"591\":2,\"593\":1,\"594\":2,\"595\":4,\"596\":2,\"602\":2,\"606\":3,\"607\":3,\"620\":4,\"621\":3,\"622\":2,\"628\":3,\"632\":3,\"634\":1,\"635\":2,\"636\":1,\"642\":2,\"675\":3,\"676\":6}}],[\"sy\",{\"1\":{\"56\":4,\"57\":4}}],[\"sx\",{\"1\":{\"56\":4,\"57\":4}}],[\"sundry\",{\"0\":{\"757\":1}}],[\"sunday\",{\"1\":{\"559\":1}}],[\"suppresswarnings\",{\"1\":{\"625\":1}}],[\"super\",{\"1\":{\"601\":3}}],[\"supervisor\",{\"1\":{\"353\":2}}],[\"successful\",{\"1\":{\"345\":1}}],[\"sublist\",{\"1\":{\"645\":1}}],[\"subject\",{\"1\":{\"263\":1,\"264\":1,\"270\":1,\"282\":1,\"289\":2,\"291\":1}}],[\"substring\",{\"1\":{\"578\":1,\"642\":2}}],[\"substr\",{\"1\":{\"242\":1}}],[\"sub\",{\"1\":{\"148\":3}}],[\"subroot\",{\"1\":{\"24\":2,\"25\":8}}],[\"sum\",{\"1\":{\"75\":1,\"81\":1,\"210\":3,\"481\":2,\"519\":2,\"561\":3,\"563\":6,\"566\":3}}],[\"sum++\",{\"1\":{\"50\":1}}],[\"solomon\",{\"1\":{\"668\":1}}],[\"solution\",{\"1\":{\"25\":1,\"363\":1,\"366\":1,\"377\":1,\"378\":1,\"389\":1,\"390\":1,\"396\":1,\"401\":1,\"402\":1,\"408\":1,\"414\":1,\"420\":2,\"432\":1,\"438\":1,\"443\":1,\"444\":1,\"445\":1,\"451\":1,\"456\":1,\"463\":1,\"469\":2,\"475\":1,\"481\":1,\"486\":1,\"487\":1,\"488\":1}}],[\"son\",{\"1\":{\"232\":7}}],[\"sortedarraytobst\",{\"1\":{\"438\":1}}],[\"sortedset\",{\"1\":{\"291\":2}}],[\"sorted\",{\"1\":{\"264\":2,\"269\":1,\"273\":3,\"291\":1}}],[\"sort\",{\"1\":{\"70\":1,\"110\":1,\"137\":3,\"138\":3,\"144\":1,\"161\":1,\"162\":1,\"181\":1,\"195\":1,\"243\":4,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"274\":2,\"575\":1,\"640\":2}}],[\"source\",{\"1\":{\"44\":2}}],[\"s→s\",{\"1\":{\"43\":1}}],[\"student\",{\"1\":{\"598\":2}}],[\"stop\",{\"1\":{\"353\":1}}],[\"storage\",{\"1\":{\"289\":1,\"667\":1}}],[\"stl简介\",{\"0\":{\"242\":1}}],[\"stk\",{\"1\":{\"122\":7,\"226\":3,\"227\":2}}],[\"strip\",{\"1\":{\"642\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"618\":1}}],[\"string不能被修改\",{\"1\":{\"580\":1}}],[\"stringbuffer线程安全\",{\"1\":{\"580\":1}}],[\"stringbuffer\",{\"0\":{\"580\":1}}],[\"stringbuilder线程不安全\",{\"1\":{\"580\":1}}],[\"stringbuilder\",{\"0\":{\"580\":1,\"643\":1},\"1\":{\"580\":2,\"591\":4,\"641\":5,\"643\":2}}],[\"string转double\",{\"1\":{\"578\":1}}],[\"string可以通过加号拼接\",{\"1\":{\"578\":1}}],[\"stringutils\",{\"1\":{\"310\":1,\"311\":2,\"313\":1,\"323\":1}}],[\"string类型的参数需要转换一下\",{\"1\":{\"71\":1}}],[\"string\",{\"0\":{\"71\":1,\"72\":1,\"578\":1,\"642\":1},\"1\":{\"44\":8,\"63\":17,\"65\":1,\"71\":7,\"72\":4,\"99\":3,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"242\":1,\"264\":1,\"310\":4,\"311\":10,\"313\":1,\"315\":1,\"323\":9,\"424\":3,\"426\":4,\"451\":2,\"551\":1,\"553\":3,\"554\":5,\"555\":3,\"557\":9,\"558\":2,\"559\":2,\"561\":4,\"562\":1,\"563\":4,\"565\":1,\"566\":1,\"567\":2,\"570\":1,\"571\":1,\"572\":4,\"573\":2,\"574\":1,\"577\":2,\"578\":17,\"579\":3,\"584\":1,\"587\":2,\"588\":1,\"590\":2,\"591\":2,\"593\":1,\"594\":1,\"595\":1,\"596\":1,\"600\":2,\"601\":5,\"602\":1,\"606\":1,\"607\":2,\"618\":1,\"619\":2,\"620\":1,\"621\":1,\"622\":2,\"628\":4,\"632\":2,\"634\":1,\"635\":2,\"636\":1,\"641\":3,\"642\":24,\"643\":1,\"673\":4,\"675\":2,\"676\":1,\"702\":1,\"704\":2,\"706\":4}}],[\"string>>\",{\"1\":{\"717\":2}}],[\"string>\",{\"1\":{\"44\":1}}],[\"str2\",{\"1\":{\"579\":2,\"641\":1}}],[\"str1\",{\"1\":{\"579\":2,\"641\":1}}],[\"strs\",{\"1\":{\"578\":1}}],[\"stream\",{\"1\":{\"313\":1,\"346\":1,\"676\":1}}],[\"strategy\",{\"1\":{\"273\":2}}],[\"struct\",{\"1\":{\"77\":1,\"118\":1,\"165\":1,\"174\":1,\"181\":1,\"243\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1}}],[\"str\",{\"1\":{\"63\":5,\"71\":9,\"125\":3,\"232\":6,\"241\":2,\"242\":1,\"554\":3,\"578\":10,\"642\":10,\"643\":1}}],[\"strlen\",{\"1\":{\"63\":3,\"125\":2}}],[\"step\",{\"1\":{\"44\":3,\"56\":5,\"57\":4}}],[\"st\",{\"1\":{\"43\":3,\"101\":4,\"107\":6,\"108\":4,\"111\":9,\"131\":3,\"162\":1,\"167\":3,\"168\":3,\"172\":3,\"173\":3,\"175\":5,\"176\":5,\"180\":3,\"183\":5,\"191\":4,\"193\":5,\"200\":4,\"210\":3,\"474\":1,\"475\":4}}],[\"stderr\",{\"1\":{\"660\":1}}],[\"stdlib\",{\"1\":{\"71\":1}}],[\"stdout\",{\"1\":{\"69\":2,\"660\":2}}],[\"stdc++\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"129\":1,\"134\":1,\"180\":1,\"181\":1}}],[\"std\",{\"1\":{\"43\":1,\"44\":1,\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1,\"74\":1,\"77\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"94\":1,\"98\":1,\"99\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":3,\"119\":2,\"121\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"144\":1,\"147\":1,\"148\":1,\"149\":1,\"150\":1,\"159\":2,\"172\":1,\"180\":1,\"181\":1,\"196\":1,\"204\":1,\"212\":1,\"214\":1,\"231\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"standardcharsets\",{\"1\":{\"642\":2}}],[\"standarderror=syslog\",{\"1\":{\"353\":1}}],[\"standardoutput=null\",{\"1\":{\"353\":1}}],[\"stack类\",{\"1\":{\"648\":1}}],[\"stack<e>\",{\"1\":{\"648\":1}}],[\"stack<>\",{\"1\":{\"610\":1,\"648\":1}}],[\"stacktraceelement\",{\"1\":{\"619\":1}}],[\"stack\",{\"1\":{\"242\":1,\"648\":6}}],[\"statobjectargs\",{\"1\":{\"676\":1}}],[\"statobjectresponse\",{\"1\":{\"676\":3}}],[\"statobject\",{\"1\":{\"676\":2}}],[\"statuschangelistener\",{\"1\":{\"715\":1}}],[\"status\",{\"1\":{\"321\":2,\"345\":1,\"353\":1,\"545\":1}}],[\"static\",{\"1\":{\"72\":1,\"311\":2,\"323\":1,\"551\":1,\"553\":3,\"554\":2,\"555\":2,\"557\":9,\"558\":2,\"559\":1,\"561\":4,\"562\":1,\"563\":4,\"565\":1,\"566\":1,\"567\":2,\"570\":1,\"571\":1,\"572\":4,\"573\":2,\"574\":1,\"577\":2,\"579\":1,\"583\":2,\"584\":2,\"587\":3,\"588\":5,\"590\":2,\"591\":3,\"593\":2,\"594\":2,\"595\":3,\"596\":2,\"600\":2,\"602\":1,\"607\":1,\"620\":2,\"621\":2,\"622\":1,\"628\":1,\"632\":2,\"634\":3,\"635\":3,\"636\":1,\"702\":2,\"706\":1,\"721\":3}}],[\"statement\",{\"1\":{\"563\":4,\"675\":1}}],[\"state=0\",{\"1\":{\"263\":1}}],[\"state到终点的真实距离=真实距离\",{\"1\":{\"41\":1}}],[\"state到终点的估计距离=估计距离\",{\"1\":{\"41\":1}}],[\"state\",{\"1\":{\"41\":4,\"44\":21,\"131\":4,\"310\":2,\"313\":1,\"315\":1}}],[\"startswith\",{\"1\":{\"424\":1,\"426\":1,\"578\":1}}],[\"start\",{\"1\":{\"44\":5,\"109\":3,\"302\":1,\"303\":1,\"345\":1,\"353\":2,\"541\":1,\"632\":4,\"633\":1,\"634\":2,\"635\":4,\"636\":2,\"654\":1,\"722\":2}}],[\"star\",{\"1\":{\"30\":1}}],[\"secretkey\",{\"1\":{\"673\":2,\"704\":1}}],[\"securityexception\",{\"1\":{\"618\":1}}],[\"seconds\",{\"1\":{\"715\":2}}],[\"second存储节点编号\",{\"1\":{\"173\":1}}],[\"second>\",{\"1\":{\"77\":1}}],[\"second\",{\"1\":{\"43\":1,\"44\":2,\"98\":2,\"162\":2,\"173\":1,\"196\":1,\"242\":2,\"251\":2,\"456\":1,\"655\":1}}],[\"sendmail\",{\"1\":{\"353\":1}}],[\"serialversionuld\",{\"1\":{\"311\":1}}],[\"serialversionuid\",{\"1\":{\"311\":4}}],[\"serializable\",{\"1\":{\"311\":3}}],[\"servletcontextevent\",{\"1\":{\"702\":1}}],[\"servlet\",{\"1\":{\"311\":1}}],[\"servercontext\",{\"1\":{\"720\":1,\"721\":4,\"722\":1}}],[\"serverconfig\",{\"1\":{\"717\":2}}],[\"servercodecs\",{\"1\":{\"717\":1,\"719\":1,\"720\":1}}],[\"server<\",{\"1\":{\"663\":2}}],[\"server\",{\"0\":{\"704\":1,\"705\":1},\"1\":{\"311\":1,\"346\":2,\"354\":4,\"660\":4,\"661\":1,\"662\":2,\"663\":5,\"705\":1,\"706\":4,\"707\":1,\"708\":1,\"714\":4,\"715\":1,\"717\":3,\"722\":1,\"728\":1}}],[\"service>\",{\"1\":{\"663\":1}}],[\"serviceimpl<usermapper\",{\"1\":{\"323\":1}}],[\"serviceimpl\",{\"1\":{\"322\":1}}],[\"services\",{\"1\":{\"302\":1}}],[\"service\",{\"0\":{\"260\":1,\"280\":1},\"1\":{\"260\":1,\"261\":1,\"273\":2,\"279\":5,\"280\":2,\"311\":3,\"322\":2,\"323\":1,\"353\":3}}],[\"session\",{\"1\":{\"309\":1,\"310\":8,\"312\":2,\"354\":2}}],[\"separation\",{\"1\":{\"280\":1}}],[\"searchprefix\",{\"1\":{\"426\":3}}],[\"searchusers\",{\"1\":{\"313\":1}}],[\"search\",{\"1\":{\"279\":1,\"313\":1,\"424\":1,\"426\":1,\"648\":1,\"661\":1}}],[\"selectcount\",{\"1\":{\"323\":1}}],[\"selectone\",{\"1\":{\"310\":1}}],[\"select\",{\"1\":{\"263\":5,\"270\":2,\"289\":3,\"499\":2,\"516\":1,\"517\":4,\"518\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"529\":4,\"531\":2,\"532\":2,\"534\":6,\"668\":1}}],[\"self\",{\"1\":{\"75\":3}}],[\"seg\",{\"1\":{\"162\":5}}],[\"segs\",{\"1\":{\"162\":5}}],[\"seq\",{\"1\":{\"44\":6}}],[\"setbucketpolicyargs\",{\"1\":{\"675\":1}}],[\"setbucketpolicy\",{\"1\":{\"675\":1}}],[\"setvalue\",{\"1\":{\"647\":1}}],[\"set<map\",{\"1\":{\"647\":1}}],[\"set<e>\",{\"1\":{\"646\":2}}],[\"set<integer>\",{\"1\":{\"645\":1}}],[\"set<k>\",{\"1\":{\"612\":1,\"647\":1}}],[\"setdaemon\",{\"1\":{\"633\":1,\"715\":3}}],[\"setnameformat\",{\"1\":{\"715\":3}}],[\"setname\",{\"1\":{\"632\":2,\"636\":2}}],[\"setnickname\",{\"1\":{\"310\":1,\"322\":1}}],[\"setcolor\",{\"1\":{\"601\":1}}],[\"setcharat\",{\"1\":{\"580\":1}}],[\"sety\",{\"1\":{\"600\":1}}],[\"setxx\",{\"1\":{\"711\":3}}],[\"setx\",{\"1\":{\"600\":1}}],[\"setproperty\",{\"1\":{\"706\":1}}],[\"setpassword\",{\"1\":{\"322\":1,\"323\":1}}],[\"setphone\",{\"1\":{\"310\":1,\"322\":1}}],[\"settings\",{\"1\":{\"311\":1}}],[\"setremark\",{\"1\":{\"310\":1}}],[\"setlasttime\",{\"1\":{\"310\":1}}],[\"setstatus\",{\"1\":{\"310\":1}}],[\"setemail\",{\"1\":{\"310\":1,\"322\":1}}],[\"setgender\",{\"1\":{\"310\":1,\"322\":1}}],[\"setavatar\",{\"1\":{\"310\":1,\"322\":1}}],[\"setattribute\",{\"1\":{\"310\":1}}],[\"setuserrole\",{\"1\":{\"310\":1,\"322\":1}}],[\"setusername\",{\"1\":{\"310\":1,\"322\":1,\"323\":1}}],[\"setuserid\",{\"1\":{\"310\":1}}],[\"set\",{\"0\":{\"612\":1,\"646\":1},\"1\":{\"35\":13,\"242\":5,\"264\":2,\"269\":1,\"273\":3,\"291\":1,\"334\":1,\"354\":2,\"513\":2,\"609\":1,\"628\":1,\"645\":1,\"646\":3}}],[\"s\",{\"1\":{\"41\":3,\"43\":10,\"55\":2,\"56\":1,\"63\":5,\"64\":2,\"65\":2,\"71\":4,\"81\":20,\"82\":14,\"83\":14,\"110\":6,\"118\":18,\"119\":8,\"125\":3,\"127\":5,\"152\":3,\"153\":5,\"155\":4,\"165\":4,\"188\":2,\"212\":2,\"217\":2,\"218\":2,\"231\":5,\"242\":4,\"480\":4,\"481\":7,\"555\":1,\"557\":4,\"579\":2,\"601\":1,\"642\":8,\"668\":2,\"715\":2}}],[\"看是否能找到匹配的\",{\"1\":{\"25\":1}}],[\"则用默认值\",{\"1\":{\"708\":1}}],[\"则用配置项的\",{\"1\":{\"708\":1}}],[\"则用\",{\"1\":{\"707\":1}}],[\"则只需要修改接口方法中引用常量的地方即可\",{\"1\":{\"704\":1}}],[\"则需要全局搜索用到的地方\",{\"1\":{\"704\":1}}],[\"则k在map中的值加1\",{\"1\":{\"647\":1}}],[\"则replace旧的value\",{\"1\":{\"647\":1}}],[\"则直接令\",{\"1\":{\"642\":1}}],[\"则直接减\",{\"1\":{\"148\":1}}],[\"则阻塞\",{\"1\":{\"634\":1}}],[\"则抛出该异常\",{\"1\":{\"618\":1}}],[\"则该索引为非法索引\",{\"1\":{\"618\":1}}],[\"则该函数内的每个分支都必须有\",{\"1\":{\"594\":1}}],[\"则执行循环体中的语句\",{\"1\":{\"561\":1}}],[\"则执行后面的语句\",{\"1\":{\"561\":1}}],[\"则会删除整张表的所有数据\",{\"1\":{\"514\":1}}],[\"则会修改整张表的所有数据\",{\"1\":{\"513\":1}}],[\"则会优先从b这条路走到t\",{\"1\":{\"41\":1}}],[\"则采用默认值\",{\"1\":{\"506\":1}}],[\"则创建该数据库\",{\"1\":{\"500\":1}}],[\"则右子树上所有节点的值均大于它的根节点的值\",{\"1\":{\"486\":1}}],[\"则左子树上所有节点的值均小于它的根节点的值\",{\"1\":{\"486\":1}}],[\"则左子节点索引为\",{\"1\":{\"419\":1}}],[\"则更新最大值\",{\"1\":{\"456\":1}}],[\"则后面的不再进行计算\",{\"1\":{\"431\":1}}],[\"则包含了prefix前缀\",{\"1\":{\"426\":1}}],[\"则包含word这个完整的字符串\",{\"1\":{\"426\":1}}],[\"则新建一个节点\",{\"1\":{\"425\":1}}],[\"则可得到树的深度\",{\"1\":{\"402\":1}}],[\"则可以通过扩展欧几里得来求解\",{\"1\":{\"203\":1}}],[\"则可以使用欧几里得距离\",{\"1\":{\"40\":1}}],[\"则可以使用\",{\"1\":{\"36\":3}}],[\"则计数器\",{\"1\":{\"402\":1}}],[\"则第\",{\"1\":{\"365\":2}}],[\"则第二段也一定相等\",{\"1\":{\"82\":1}}],[\"则当前结点值即为第\",{\"1\":{\"365\":1}}],[\"则一条子评论的发布\",{\"1\":{\"263\":1}}],[\"则无解\",{\"1\":{\"250\":1}}],[\"则点数+1\",{\"1\":{\"247\":1}}],[\"则往下沉\",{\"1\":{\"237\":1}}],[\"则最小的数为右儿子\",{\"1\":{\"237\":1}}],[\"则最小的数为左二子\",{\"1\":{\"237\":1}}],[\"则最佳优先算法找到的很可能不是最短路径\",{\"1\":{\"34\":1}}],[\"则优先采取该行动\",{\"1\":{\"214\":1}}],[\"则系数应该是1\",{\"1\":{\"212\":1}}],[\"则n\",{\"1\":{\"212\":1}}],[\"则对于任意整数\",{\"1\":{\"209\":1}}],[\"则称该游戏为一个公平组合游戏\",{\"1\":{\"215\":1}}],[\"则称该局面必败\",{\"1\":{\"214\":1}}],[\"则称\",{\"1\":{\"208\":1}}],[\"则存在一个整数\",{\"1\":{\"208\":1}}],[\"则有\",{\"1\":{\"208\":1}}],[\"则数据保证\",{\"1\":{\"204\":1}}],[\"则pj一定是i的最小公因子\",{\"1\":{\"193\":1}}],[\"则匹配成功\",{\"1\":{\"183\":1}}],[\"则这条交替路称为增广路\",{\"1\":{\"183\":1}}],[\"则这个数出现的次数就可以表示为\",{\"1\":{\"144\":1}}],[\"则加入这条边到集合中\",{\"1\":{\"181\":1}}],[\"则选择该点\",{\"1\":{\"180\":1}}],[\"则把该点加入到队尾\",{\"1\":{\"175\":1}}],[\"则每左移一位\",{\"1\":{\"158\":1}}],[\"则向高位借位\",{\"1\":{\"148\":1}}],[\"则减去b\",{\"1\":{\"148\":1}}],[\"则压入c数组中\",{\"1\":{\"147\":1}}],[\"则设\",{\"1\":{\"134\":1}}],[\"则将\",{\"1\":{\"642\":1}}],[\"则将其与相邻四个方向上的\",{\"1\":{\"445\":1}}],[\"则将其加入队列\",{\"1\":{\"444\":1}}],[\"则将其转化为\",{\"1\":{\"148\":1}}],[\"则将这两个连通块合并\",{\"1\":{\"181\":1}}],[\"则将剩余那一部分直接接在临时序列的后面\",{\"1\":{\"138\":1}}],[\"则将该元素入栈\",{\"1\":{\"122\":1}}],[\"则将由\",{\"1\":{\"36\":1}}],[\"则不会获取\",{\"1\":{\"715\":1}}],[\"则不需要交换\",{\"1\":{\"593\":1}}],[\"则不需要将j重复插入\",{\"1\":{\"175\":1}}],[\"则不执行删除操作\",{\"1\":{\"510\":1}}],[\"则不包含这个字符串\",{\"1\":{\"426\":1}}],[\"则不合法\",{\"1\":{\"111\":1}}],[\"则不能被均分为三份\",{\"1\":{\"82\":1}}],[\"则表示该切割点不行\",{\"1\":{\"82\":1}}],[\"则为\",{\"1\":{\"201\":1}}],[\"则为假\",{\"1\":{\"55\":1}}],[\"则为真\",{\"1\":{\"55\":1}}],[\"则也返回\",{\"1\":{\"48\":1}}],[\"则返回相应的索引\",{\"1\":{\"654\":1}}],[\"则返回defaultvalue\",{\"1\":{\"647\":1}}],[\"则返回null\",{\"1\":{\"647\":1}}],[\"则返回inf\",{\"1\":{\"180\":1}}],[\"则返回true\",{\"1\":{\"176\":1,\"646\":1,\"647\":2}}],[\"则返回\",{\"1\":{\"48\":1,\"173\":1,\"174\":1,\"640\":1}}],[\"则输入为\",{\"1\":{\"44\":1,\"99\":1}}],[\"则输出结果\",{\"1\":{\"230\":1}}],[\"则输出\",{\"1\":{\"43\":1,\"44\":1,\"56\":1,\"57\":1,\"93\":1,\"99\":1,\"204\":1}}],[\"则depth一定小于ans\",{\"1\":{\"389\":1}}],[\"则d\",{\"1\":{\"43\":1}}],[\"则说明存在环\",{\"1\":{\"176\":1}}],[\"则说明j已经出队k次了\",{\"1\":{\"43\":1}}],[\"则说明当前队列中存在点u\",{\"1\":{\"41\":1}}],[\"则此时的ver就是终点t\",{\"1\":{\"43\":1}}],[\"则此时只有\",{\"1\":{\"36\":1}}],[\"则其值就是\",{\"1\":{\"39\":1}}],[\"则启发函数可以使用对角距离\",{\"1\":{\"39\":1}}],[\"则启发函数可以使用曼哈顿距离\",{\"1\":{\"38\":1}}],[\"则\",{\"1\":{\"35\":5,\"36\":3,\"81\":1,\"159\":2,\"199\":1,\"334\":2,\"346\":1,\"473\":1,\"717\":1}}],[\"则从0开始加1\",{\"1\":{\"647\":1}}],[\"则从上到下匹配到第一个\",{\"1\":{\"559\":1}}],[\"则从\",{\"1\":{\"35\":1}}],[\"则我们可以利用这个信息更快的到达终点\",{\"1\":{\"34\":1}}],[\"则递归往下判断\",{\"1\":{\"25\":1}}],[\"则和叶节点的空子节点匹配\",{\"1\":{\"25\":1}}],[\"匹配任意个字符\",{\"1\":{\"518\":1}}],[\"匹配单个字符\",{\"1\":{\"518\":1}}],[\"匹配完成后的具体操作\",{\"1\":{\"231\":1}}],[\"匹配完我输出一下\",{\"1\":{\"231\":1}}],[\"匹配操作\",{\"1\":{\"231\":1}}],[\"匹配时\",{\"1\":{\"231\":2}}],[\"匹配边\",{\"1\":{\"183\":1}}],[\"匹配\",{\"1\":{\"25\":1,\"183\":3}}],[\"也会根据\",{\"1\":{\"715\":1}}],[\"也会被移除\",{\"1\":{\"642\":1}}],[\"也会更新其根评论的计数\",{\"1\":{\"270\":1}}],[\"也被称为元数据\",{\"1\":{\"624\":1}}],[\"也必须把两个类型都写出来\",{\"1\":{\"586\":1}}],[\"也有一个加载配置文件的方法\",{\"1\":{\"714\":1}}],[\"也有降序排序\",{\"1\":{\"521\":1}}],[\"也有很不错的效果\",{\"1\":{\"350\":1}}],[\"也改为\",{\"1\":{\"486\":1}}],[\"也无法封禁国内\",{\"1\":{\"346\":1}}],[\"也能通过剩余的数据块和校验块恢复原始数据\",{\"1\":{\"668\":1}}],[\"也能使用云存储服务提供的\",{\"1\":{\"667\":1}}],[\"也能够满足许多场景下的需求\",{\"1\":{\"310\":1}}],[\"也能实现增删改查\",{\"1\":{\"300\":1}}],[\"也支持动态的模型打分\",{\"1\":{\"273\":1}}],[\"也包括为了策略迭代而需要新开发的流式的窗口聚合数据\",{\"1\":{\"273\":1}}],[\"也包括各类热评排序算法\",{\"1\":{\"272\":1}}],[\"也对系统的吞吐能力提出了更高要求\",{\"1\":{\"273\":1}}],[\"也不需要在叶子节点结束\",{\"1\":{\"479\":1}}],[\"也不能通过api等对外暴露\",{\"1\":{\"269\":1}}],[\"也不在\",{\"1\":{\"35\":1}}],[\"也称静态链表\",{\"1\":{\"223\":1}}],[\"也是通过接口方法里面的\",{\"1\":{\"714\":1}}],[\"也是非常常见的一个功能\",{\"1\":{\"522\":1}}],[\"也是\",{\"1\":{\"200\":1}}],[\"也是亲戚\",{\"1\":{\"93\":1}}],[\"也将其倍数从\",{\"1\":{\"192\":1}}],[\"也可为字符数组\",{\"1\":{\"642\":1}}],[\"也可能是长整数\",{\"1\":{\"72\":1}}],[\"也可以直接定义数组中某个元素的值\",{\"1\":{\"695\":1}}],[\"也可以用双引号\",{\"1\":{\"690\":1}}],[\"也可以用来判断奇数和偶数\",{\"1\":{\"201\":1}}],[\"也可以将一套逻辑组织成一个文件\",{\"1\":{\"680\":1}}],[\"也可以通过\",{\"1\":{\"651\":1}}],[\"也可以作为栈\",{\"1\":{\"648\":1}}],[\"也可以不用引号\",{\"1\":{\"690\":1}}],[\"也可以不加引号\",{\"1\":{\"685\":1}}],[\"也可以不处理\",{\"1\":{\"617\":1}}],[\"也可以不删除任何字符\",{\"1\":{\"449\":1}}],[\"也可以调用静态函数\",{\"1\":{\"600\":1}}],[\"也可以调用函数本身\",{\"1\":{\"596\":1}}],[\"也可以格式化输出\",{\"1\":{\"579\":1}}],[\"也可以修改多个变量\",{\"1\":{\"563\":1}}],[\"也可以没有\",{\"1\":{\"513\":1,\"514\":1}}],[\"也可以替换成\",{\"1\":{\"502\":1}}],[\"也可以在递归完左子树之后立刻判断\",{\"1\":{\"488\":1}}],[\"也可以是机器的绝对路径\",{\"1\":{\"352\":1}}],[\"也可以存储在外部\",{\"1\":{\"351\":1}}],[\"也可以去找一些小众更便宜的云服务器提供商\",{\"1\":{\"344\":1}}],[\"也可以自己搭建一个代理服务\",{\"1\":{\"343\":1}}],[\"也可以根据此公式算出来存储这么多元素大概需要占用多少内存空间\",{\"1\":{\"334\":1}}],[\"也可以从业务角度上\",{\"1\":{\"334\":1}}],[\"也可以发一条友善的评论\",{\"1\":{\"274\":1}}],[\"也可以守护新人up主成长\",{\"1\":{\"274\":1}}],[\"也可以看到一些多元化的观点\",{\"1\":{\"274\":1}}],[\"也可以看做它自身的一棵子树\",{\"1\":{\"24\":1}}],[\"也可以简写成这样\",{\"1\":{\"90\":1}}],[\"也可以换成更安全的\",{\"1\":{\"71\":1}}],[\"也就造成了错误的增量更新\",{\"1\":{\"270\":1}}],[\"也就是即使你启动了\",{\"1\":{\"660\":1}}],[\"也就是\",{\"1\":{\"445\":1}}],[\"也就是做\",{\"1\":{\"431\":1}}],[\"也就是将一张大表拆分成两张小表\",{\"1\":{\"525\":1}}],[\"也就是将\",{\"1\":{\"334\":1}}],[\"也就是直接穿过缓存打到数据库中\",{\"1\":{\"334\":1}}],[\"也就是在查询第一页的时候会将后两页评论数据也一起加载进缓存\",{\"1\":{\"291\":1}}],[\"也就是它是回复哪条评论的\",{\"1\":{\"289\":1}}],[\"也就是用\",{\"1\":{\"270\":1}}],[\"也就是最少需要多少辆缆车\",{\"1\":{\"110\":1}}],[\"也就是说线程\",{\"1\":{\"702\":1}}],[\"也就是说\",{\"1\":{\"14\":1,\"363\":1,\"545\":1}}],[\"也就导致算法越慢\",{\"1\":{\"36\":1}}],[\"的话\",{\"1\":{\"721\":1}}],[\"的地方很相似\",{\"1\":{\"714\":1}}],[\"的地址和端口换成\",{\"1\":{\"346\":1}}],[\"的代码如下所示\",{\"1\":{\"711\":1}}],[\"的代理服务是否可用\",{\"1\":{\"344\":1}}],[\"的获取配置项的方法\",{\"1\":{\"708\":1}}],[\"的签名url\",{\"1\":{\"676\":1}}],[\"的状态\",{\"1\":{\"676\":1}}],[\"的常用\",{\"0\":{\"674\":1}}],[\"的基本对象\",{\"1\":{\"673\":1}}],[\"的逻辑空间\",{\"1\":{\"673\":1}}],[\"的存储机制使用纠删码\",{\"1\":{\"668\":1}}],[\"的产品\",{\"1\":{\"668\":1}}],[\"的编排\",{\"1\":{\"668\":1}}],[\"的替代品\",{\"1\":{\"668\":1}}],[\"的特性\",{\"1\":{\"648\":1}}],[\"的简短描述\",{\"1\":{\"619\":1}}],[\"的区别\",{\"0\":{\"615\":1}}],[\"的这种用法有点类似于我们用\",{\"1\":{\"593\":1}}],[\"的函数不要求非得有\",{\"1\":{\"593\":1}}],[\"的函数中\",{\"1\":{\"593\":1}}],[\"的ascii值为32\",{\"1\":{\"585\":1}}],[\"的矩阵中\",{\"1\":{\"567\":1}}],[\"的运算\",{\"1\":{\"553\":1}}],[\"的运行进程\",{\"1\":{\"354\":1}}],[\"的高度\",{\"1\":{\"545\":1}}],[\"的高度只存在于平衡二叉树\",{\"1\":{\"94\":1}}],[\"的顺序保存的\",{\"1\":{\"545\":1}}],[\"的效率\",{\"1\":{\"544\":1}}],[\"的事务是自动提交\",{\"1\":{\"541\":1}}],[\"的任何一个\",{\"1\":{\"534\":1}}],[\"的行\",{\"1\":{\"519\":1}}],[\"的员工\",{\"1\":{\"513\":1}}],[\"的性能会更高些\",{\"1\":{\"507\":1}}],[\"的范围内\",{\"1\":{\"486\":1}}],[\"的路径数目\",{\"1\":{\"480\":1}}],[\"的路径元素和为\",{\"1\":{\"480\":1}}],[\"的有向边\",{\"1\":{\"474\":1}}],[\"的烂橘子\",{\"1\":{\"468\":1}}],[\"的新鲜橘子都会腐烂\",{\"1\":{\"467\":1}}],[\"的滑动窗口从数组的最左侧移动到数组的最右侧\",{\"1\":{\"455\":1}}],[\"的含义是\",{\"1\":{\"450\":1}}],[\"的中序遍历是升序的\",{\"1\":{\"437\":1}}],[\"的左子树与\",{\"1\":{\"431\":1}}],[\"的左子树是否对称\",{\"1\":{\"431\":1}}],[\"的左儿子为\",{\"1\":{\"237\":1}}],[\"的右子树是否对称\",{\"1\":{\"431\":1}}],[\"的右子树与\",{\"1\":{\"431\":1}}],[\"的右儿子为\",{\"1\":{\"237\":1}}],[\"的子节点列表中\",{\"1\":{\"425\":2}}],[\"的子序列\",{\"1\":{\"449\":2}}],[\"的子序列的字符串长度最长是多少\",{\"1\":{\"123\":1}}],[\"的子序列又是\",{\"1\":{\"123\":1}}],[\"的列表存储当前节点对应出现过的字符的子节点\",{\"1\":{\"425\":1}}],[\"的位置会直接返回\",{\"1\":{\"443\":1}}],[\"的位置\",{\"1\":{\"425\":1,\"445\":1}}],[\"的前缀之一为\",{\"1\":{\"424\":1}}],[\"的前提下\",{\"1\":{\"231\":1}}],[\"的索引\",{\"1\":{\"419\":1}}],[\"的深度尽可能大\",{\"1\":{\"406\":1}}],[\"的祖先且\",{\"1\":{\"406\":1}}],[\"的两个节点\",{\"1\":{\"406\":1}}],[\"的连接地址\",{\"1\":{\"357\":1}}],[\"的机器上\",{\"1\":{\"352\":1}}],[\"的机器访问\",{\"1\":{\"346\":1}}],[\"的配置信息\",{\"1\":{\"717\":1}}],[\"的配置文件\",{\"1\":{\"354\":1}}],[\"的配置\",{\"1\":{\"347\":1}}],[\"的访问\",{\"1\":{\"346\":1}}],[\"的访问频次\",{\"1\":{\"294\":1}}],[\"的安全组\",{\"1\":{\"346\":1}}],[\"的扫描不会发觉任何异常\",{\"1\":{\"346\":1}}],[\"的设置界面\",{\"1\":{\"346\":1}}],[\"的设计思想\",{\"1\":{\"289\":1}}],[\"的空间\",{\"1\":{\"334\":1}}],[\"的情况\",{\"1\":{\"334\":1}}],[\"的布隆过滤器模块\",{\"1\":{\"334\":1}}],[\"的插件\",{\"1\":{\"328\":1}}],[\"的主要工作\",{\"1\":{\"311\":1}}],[\"的主要功能就是从某个节点向上遍历到根节点\",{\"1\":{\"94\":1}}],[\"的包装类型\",{\"1\":{\"647\":1}}],[\"的包\",{\"1\":{\"303\":1}}],[\"的文件夹下\",{\"1\":{\"302\":1}}],[\"的增强\",{\"1\":{\"300\":1}}],[\"的封装\",{\"1\":{\"300\":1}}],[\"的升级\",{\"1\":{\"294\":1}}],[\"的查询压力\",{\"1\":{\"293\":1}}],[\"的消息\",{\"1\":{\"293\":1}}],[\"的消费者中处理\",{\"1\":{\"291\":1}}],[\"的消费者\",{\"1\":{\"261\":1}}],[\"的指令\",{\"1\":{\"293\":1}}],[\"的指定位\",{\"1\":{\"158\":1}}],[\"的压力更小\",{\"1\":{\"293\":1}}],[\"的压力\",{\"1\":{\"293\":1}}],[\"的原理可以看这篇文章\",{\"1\":{\"293\":1}}],[\"的时间复杂度\",{\"1\":{\"291\":1}}],[\"的时候就会找到数据大概是\",{\"1\":{\"545\":1}}],[\"的时候\",{\"1\":{\"63\":1}}],[\"的实现类有\",{\"1\":{\"648\":1}}],[\"的实现\",{\"1\":{\"291\":1}}],[\"的构建\",{\"1\":{\"291\":1}}],[\"的评论内容\",{\"1\":{\"289\":1}}],[\"的好处是\",{\"1\":{\"283\":1}}],[\"的方法\",{\"1\":{\"707\":1}}],[\"的方法是同步的\",{\"1\":{\"648\":1}}],[\"的方式进行分发\",{\"1\":{\"282\":1}}],[\"的方案数\",{\"1\":{\"128\":1}}],[\"的吞吐模型理解为\",{\"1\":{\"282\":1}}],[\"的思路\",{\"1\":{\"281\":1,\"294\":1}}],[\"的瓶颈\",{\"1\":{\"273\":1}}],[\"的分布可能出现同一个值堆叠多个元素\",{\"1\":{\"273\":1}}],[\"的分页排序\",{\"1\":{\"273\":1}}],[\"的理解\",{\"1\":{\"272\":1}}],[\"的字段\",{\"1\":{\"264\":1}}],[\"的字符串以及\",{\"1\":{\"125\":1}}],[\"的字符串\",{\"1\":{\"123\":1}}],[\"的定义是\",{\"1\":{\"254\":1}}],[\"的用法和\",{\"1\":{\"243\":1}}],[\"的减法\",{\"1\":{\"243\":1}}],[\"的哈希值\",{\"1\":{\"241\":1}}],[\"的经验值是\",{\"1\":{\"241\":1}}],[\"的偏移量\",{\"1\":{\"236\":1}}],[\"的距离\",{\"1\":{\"236\":1}}],[\"的sg函数值构成的集合再执行mex\",{\"1\":{\"218\":1}}],[\"的每一个集合状态\",{\"1\":{\"212\":1}}],[\"的集合\",{\"1\":{\"212\":1}}],[\"的乘法逆元为\",{\"1\":{\"208\":1}}],[\"的乘法逆元\",{\"1\":{\"208\":1}}],[\"的模\",{\"1\":{\"208\":1}}],[\"的逆元不存在\",{\"1\":{\"208\":1}}],[\"的逆元\",{\"1\":{\"208\":1}}],[\"的解\",{\"1\":{\"203\":1}}],[\"的欧拉函数即为\",{\"1\":{\"200\":1}}],[\"的质因子\",{\"1\":{\"193\":1,\"200\":1}}],[\"的表中划去\",{\"1\":{\"192\":1}}],[\"的表中筛得素数的同时\",{\"1\":{\"192\":1}}],[\"的素数表\",{\"1\":{\"192\":1}}],[\"的约数\",{\"1\":{\"191\":1}}],[\"的唯一质因子\",{\"1\":{\"188\":1}}],[\"的因子\",{\"1\":{\"188\":3}}],[\"的更新方式为\",{\"1\":{\"174\":1}}],[\"的点\",{\"1\":{\"169\":1}}],[\"的个数\",{\"1\":{\"159\":2}}],[\"的低\",{\"1\":{\"158\":6}}],[\"的商和余数\",{\"1\":{\"150\":1}}],[\"的问题\",{\"1\":{\"143\":1,\"293\":1,\"334\":1}}],[\"的最大整数\",{\"1\":{\"243\":1}}],[\"的最大值\",{\"1\":{\"231\":1}}],[\"的最小整数的下标\",{\"1\":{\"243\":1}}],[\"的最小质因子也就是\",{\"1\":{\"193\":1}}],[\"的最小质因子就是\",{\"1\":{\"193\":1}}],[\"的最小质因子\",{\"1\":{\"193\":2,\"200\":3}}],[\"的最后一位\",{\"1\":{\"159\":1}}],[\"的最后一个元素\",{\"1\":{\"142\":1}}],[\"的最低位为\",{\"1\":{\"158\":1}}],[\"的最短hamilton路径\",{\"1\":{\"132\":1}}],[\"的所有数据\",{\"1\":{\"532\":2}}],[\"的所有组合情况\",{\"1\":{\"529\":1}}],[\"的所有因数\",{\"1\":{\"188\":1}}],[\"的所有出边\",{\"1\":{\"175\":1}}],[\"的所有路径\",{\"1\":{\"132\":1}}],[\"的所有方案\",{\"1\":{\"131\":1}}],[\"的棋盘可以摆放不同的\",{\"1\":{\"131\":1}}],[\"的树里各个数字有多少个\",{\"1\":{\"129\":1}}],[\"的各位数字有多少个\",{\"1\":{\"129\":2}}],[\"的出现次数\",{\"1\":{\"129\":1}}],[\"的一种划分\",{\"1\":{\"128\":1}}],[\"的一棵子树包括\",{\"1\":{\"24\":1}}],[\"的某个位置插入某个字符\",{\"1\":{\"126\":1}}],[\"的某个节点和这个节点的所有后代节点\",{\"1\":{\"24\":1}}],[\"的背包\",{\"1\":{\"119\":1}}],[\"的写法\",{\"1\":{\"118\":1}}],[\"的形式存储\",{\"1\":{\"173\":1}}],[\"的形式\",{\"1\":{\"111\":1}}],[\"的操作方式\",{\"1\":{\"126\":1}}],[\"的操作\",{\"1\":{\"94\":1,\"293\":1,\"655\":1,\"673\":1}}],[\"的不平衡状况\",{\"1\":{\"91\":1}}],[\"的正方形\",{\"1\":{\"83\":1}}],[\"的正余数\",{\"0\":{\"67\":1}}],[\"的数字\",{\"1\":{\"577\":1}}],[\"的数是否是质数\",{\"1\":{\"565\":1}}],[\"的数目\",{\"1\":{\"445\":1,\"479\":1}}],[\"的数据列是一个正数序列开始增长\",{\"1\":{\"506\":1}}],[\"的数据\",{\"1\":{\"294\":2}}],[\"的数整除\",{\"1\":{\"187\":1}}],[\"的数对的个数\",{\"1\":{\"144\":1}}],[\"的数组\",{\"1\":{\"82\":1}}],[\"的数列\",{\"1\":{\"81\":1,\"159\":1}}],[\"的组合有多少种\",{\"1\":{\"81\":1}}],[\"的差值必然是\",{\"1\":{\"81\":1}}],[\"的余数相等\",{\"1\":{\"81\":1}}],[\"的和\",{\"1\":{\"81\":1}}],[\"的和是k的倍数\",{\"1\":{\"81\":1}}],[\"的和是\",{\"1\":{\"81\":1}}],[\"的目的是可以在\",{\"1\":{\"75\":1}}],[\"的元素个数\",{\"1\":{\"545\":1}}],[\"的元素\",{\"1\":{\"243\":1,\"651\":1}}],[\"的元素的位置的迭代器\",{\"1\":{\"243\":1}}],[\"的元素到\",{\"1\":{\"74\":1}}],[\"的元素赋值到当前的\",{\"1\":{\"74\":1}}],[\"的二叉树\",{\"1\":{\"419\":1}}],[\"的二进制表示\",{\"1\":{\"159\":1}}],[\"的二进制表示中第\",{\"1\":{\"159\":1,\"201\":1}}],[\"的二进制表示下的每一位是不是\",{\"1\":{\"73\":1}}],[\"的二进制位右移\",{\"1\":{\"158\":1}}],[\"的二进制位\",{\"1\":{\"158\":1}}],[\"的二维整数数组\",{\"1\":{\"98\":1}}],[\"的二维字符数组作为迷宫\",{\"1\":{\"55\":1}}],[\"的倍数时\",{\"1\":{\"208\":1}}],[\"的倍数的个数\",{\"1\":{\"81\":1}}],[\"的倍数\",{\"1\":{\"68\":1,\"81\":3,\"203\":1,\"208\":1}}],[\"的成员函数c\",{\"1\":{\"63\":1}}],[\"的长度均不超过\",{\"1\":{\"124\":1}}],[\"的长度\",{\"1\":{\"63\":1,\"124\":1}}],[\"的长度时会被截断\",{\"1\":{\"63\":1}}],[\"的真实长度\",{\"1\":{\"63\":1}}],[\"的坐标\",{\"1\":{\"44\":1}}],[\"的初始网格描绘出来\",{\"1\":{\"44\":1,\"99\":1}}],[\"的网格中\",{\"1\":{\"44\":2,\"99\":2}}],[\"的第三个参数传入一个元素\",{\"1\":{\"243\":1}}],[\"的第一个元素\",{\"1\":{\"142\":1}}],[\"的第\",{\"1\":{\"43\":1}}],[\"的值为\",{\"1\":{\"158\":1}}],[\"的值\",{\"1\":{\"149\":1,\"209\":1,\"210\":1,\"419\":1,\"507\":2,\"583\":1}}],[\"的值比节点\",{\"1\":{\"36\":1}}],[\"的值越小\",{\"1\":{\"36\":1}}],[\"的优先级\",{\"1\":{\"35\":1}}],[\"的\",{\"1\":{\"35\":1,\"63\":2,\"89\":1,\"111\":1,\"264\":2,\"273\":1,\"279\":1,\"282\":1,\"289\":1,\"293\":2,\"294\":1,\"302\":1,\"310\":1,\"334\":2,\"346\":3,\"354\":1,\"451\":2,\"479\":1,\"493\":1,\"655\":1,\"708\":1,\"715\":2,\"721\":2,\"722\":1}}],[\"的节点作为下一个待遍历的节点\",{\"1\":{\"35\":1}}],[\"的节点作为下一个遍历的节点\",{\"1\":{\"34\":1}}],[\"的节点\",{\"1\":{\"35\":1}}],[\"的综合优先级\",{\"1\":{\"35\":1}}],[\"否则poll\",{\"1\":{\"649\":1}}],[\"否则停止\",{\"1\":{\"561\":1}}],[\"否则执行另一些语句\",{\"1\":{\"557\":1}}],[\"否则将会报错\",{\"1\":{\"500\":1}}],[\"否则将会得到超过限制限制的结果\",{\"1\":{\"69\":1}}],[\"否则不需要更换\",{\"1\":{\"651\":1}}],[\"否则不执行删除\",{\"1\":{\"502\":1}}],[\"否则不能操作\",{\"1\":{\"501\":1}}],[\"否则不是\",{\"1\":{\"487\":1}}],[\"否则不更新\",{\"1\":{\"456\":1}}],[\"否则不存在拓扑序列\",{\"1\":{\"169\":1}}],[\"否则匹配成功返回node\",{\"1\":{\"426\":1}}],[\"否则更新\",{\"1\":{\"425\":1}}],[\"否则两条同时发布的评论\",{\"1\":{\"261\":1}}],[\"否则返回一个负数值\",{\"1\":{\"654\":1}}],[\"否则返回null\",{\"1\":{\"649\":2}}],[\"否则返回最小生成树的树边权重之和\",{\"1\":{\"180\":1}}],[\"否则返回\",{\"1\":{\"148\":1,\"474\":1}}],[\"否则返回flase\",{\"1\":{\"148\":1}}],[\"否则返回false\",{\"1\":{\"148\":1,\"176\":1,\"642\":1,\"646\":2,\"647\":3,\"648\":1,\"649\":2,\"650\":1,\"651\":1}}],[\"否则需要再加一辆车\",{\"1\":{\"110\":1}}],[\"否则输出no\",{\"1\":{\"557\":1}}],[\"否则输出\",{\"1\":{\"55\":1,\"93\":1,\"94\":1}}],[\"否则\",{\"1\":{\"24\":1,\"25\":1,\"122\":1,\"424\":2,\"473\":1}}],[\"返回存储桶的列表\",{\"1\":{\"675\":1}}],[\"返回布尔值\",{\"1\":{\"675\":1}}],[\"返回list1中最后一个等于list2的子列表的索引\",{\"1\":{\"654\":1}}],[\"返回list1中第一个等于list2的子列表的索引\",{\"1\":{\"654\":1}}],[\"返回集合中最小的元素\",{\"1\":{\"654\":1}}],[\"返回集合中最大的元素\",{\"1\":{\"654\":1}}],[\"返回栈中元素个数\",{\"1\":{\"648\":1}}],[\"返回栈顶元素\",{\"1\":{\"242\":1,\"610\":1}}],[\"返回出栈元素e\",{\"1\":{\"648\":1}}],[\"返回这个映射的值\",{\"1\":{\"647\":1}}],[\"返回这个映射的键\",{\"1\":{\"647\":1}}],[\"返回这两个字符串的最长公共子序列的长度\",{\"1\":{\"449\":1}}],[\"返回map中中键值对<k\",{\"1\":{\"647\":1}}],[\"返回map中key对应的value\",{\"1\":{\"647\":2}}],[\"返回map\",{\"1\":{\"647\":1}}],[\"返回value值\",{\"1\":{\"647\":1}}],[\"返回有序集合中第一个元素\",{\"1\":{\"646\":1}}],[\"返回有多少个1\",{\"1\":{\"242\":1}}],[\"返回false\",{\"1\":{\"646\":1}}],[\"返回动态数组所存元素个数\",{\"1\":{\"645\":1}}],[\"返回之前的内容\",{\"1\":{\"645\":1}}],[\"返回缓冲字符串长度\",{\"1\":{\"643\":1}}],[\"返回index位置的char\",{\"1\":{\"643\":1}}],[\"返回index位置的字符char\",{\"1\":{\"642\":1}}],[\"返回str最后出现的位置\",{\"1\":{\"642\":1}}],[\"返回str第一个出现的位置\",{\"1\":{\"642\":1}}],[\"返回从begin开始后面所有的字符片段\",{\"1\":{\"642\":1}}],[\"返回从右侧所能看到的节点值\",{\"1\":{\"388\":1}}],[\"返回字符片段\",{\"1\":{\"642\":1}}],[\"返回字符串所在字符数组的起始地址\",{\"1\":{\"242\":1}}],[\"返回字符串长度\",{\"1\":{\"242\":1,\"642\":1}}],[\"返回与arr类型相同的一个数组\",{\"1\":{\"640\":1}}],[\"返回此\",{\"1\":{\"619\":1}}],[\"返回一个随机数\",{\"1\":{\"653\":1}}],[\"返回一个collection<v>\",{\"1\":{\"647\":1}}],[\"返回一个set\",{\"1\":{\"647\":1}}],[\"返回一个与构建起或缓冲器内容相同的字符串\",{\"1\":{\"643\":1}}],[\"返回一个新的字符串全部转成大写\",{\"1\":{\"642\":1}}],[\"返回一个新的字符串全部转成小写\",{\"1\":{\"642\":1}}],[\"返回一个新字符串string\",{\"1\":{\"642\":1}}],[\"返回一个字符串\",{\"1\":{\"640\":1}}],[\"返回一个包含堆栈层次的数组\",{\"1\":{\"619\":1}}],[\"返回一个\",{\"1\":{\"619\":1}}],[\"返回一个整型值\",{\"1\":{\"583\":1}}],[\"返回关于发生的异常的详细信息\",{\"1\":{\"619\":1}}],[\"返回关键字对应的值\",{\"1\":{\"613\":1}}],[\"返回小于等于key的最大元素\",{\"1\":{\"612\":1,\"613\":1}}],[\"返回元素位置在index的元素e\",{\"1\":{\"645\":1}}],[\"返回元素数\",{\"1\":{\"612\":1,\"613\":1}}],[\"返回元素个数\",{\"1\":{\"242\":1}}],[\"返回类型为double\",{\"1\":{\"653\":1}}],[\"返回类型和\",{\"0\":{\"592\":1}}],[\"返回类型\",{\"1\":{\"582\":1}}],[\"返回长度\",{\"1\":{\"578\":1,\"609\":1,\"610\":1,\"611\":1}}],[\"返回数组长度\",{\"1\":{\"575\":1}}],[\"返回到原始状态\",{\"1\":{\"542\":1}}],[\"返回翻转后的二叉树的根节点\",{\"1\":{\"463\":1}}],[\"返回每次的根节点即可\",{\"1\":{\"462\":1}}],[\"返回不为空\",{\"1\":{\"426\":1}}],[\"返回不为空且节点标记为尾节点\",{\"1\":{\"426\":1}}],[\"返回根节点\",{\"1\":{\"420\":1}}],[\"返回该pair的字符串表示\",{\"1\":{\"655\":1}}],[\"返回该pair的value值\",{\"1\":{\"655\":1}}],[\"返回该pair的key值\",{\"1\":{\"655\":1}}],[\"返回该节点的最大深度\",{\"1\":{\"414\":1}}],[\"返回该树的\",{\"1\":{\"412\":1}}],[\"返回其最大深度\",{\"1\":{\"400\":1}}],[\"返回其节点值的\",{\"1\":{\"394\":1}}],[\"返回其\",{\"1\":{\"370\":1}}],[\"返回当前结点值\",{\"1\":{\"365\":1}}],[\"返回即可\",{\"1\":{\"363\":1}}],[\"返回给前端\",{\"1\":{\"310\":2}}],[\"返回脱敏后的用户信息\",{\"1\":{\"309\":1}}],[\"返回值大于0\",{\"1\":{\"651\":1}}],[\"返回值为栈顶元素e\",{\"1\":{\"648\":1}}],[\"返回值为元素e\",{\"1\":{\"648\":1}}],[\"返回值默认为\",{\"1\":{\"311\":1}}],[\"返回值\",{\"1\":{\"308\":1}}],[\"返回指向第一个大于等于\",{\"1\":{\"243\":1}}],[\"返回去重\",{\"1\":{\"243\":1}}],[\"返回大于等于key的最小元素\",{\"1\":{\"612\":1,\"613\":1}}],[\"返回大于等于x的最小的数的迭代器\",{\"1\":{\"242\":1}}],[\"返回大于x的最小的数的迭代器\",{\"1\":{\"242\":1}}],[\"返回某一个数的个数\",{\"1\":{\"242\":1}}],[\"返回前驱和后继\",{\"1\":{\"242\":1}}],[\"返回堆顶元素\",{\"1\":{\"242\":1}}],[\"返回队中元素个数\",{\"1\":{\"649\":1}}],[\"返回队头\",{\"1\":{\"611\":1}}],[\"返回队头元素\",{\"1\":{\"242\":1}}],[\"返回队尾元素\",{\"1\":{\"242\":1}}],[\"返回子串\",{\"1\":{\"242\":1}}],[\"返回是否为空\",{\"1\":{\"242\":1}}],[\"返回x应该插入的位置\",{\"1\":{\"240\":1}}],[\"返回x的下标\",{\"1\":{\"240\":1}}],[\"返回x的祖宗节点\",{\"1\":{\"234\":1,\"235\":1,\"236\":1}}],[\"返回a的b次方\",{\"1\":{\"653\":1}}],[\"返回a的绝对值\",{\"1\":{\"653\":1}}],[\"返回a和b的最小值\",{\"1\":{\"653\":1}}],[\"返回a和b的最大值\",{\"1\":{\"653\":1}}],[\"返回a\",{\"1\":{\"148\":1}}],[\"返回true\",{\"1\":{\"148\":2}}],[\"返回父亲节点\",{\"1\":{\"90\":1}}],[\"返回按照查找规则找到的第一个字符或者子串的位置\",{\"1\":{\"72\":1}}],[\"返回c风格字符串长度\",{\"1\":{\"63\":1}}],[\"返回答案\",{\"1\":{\"43\":1}}],[\"返回找到的结果路径\",{\"1\":{\"35\":1}}],[\"返回\",{\"1\":{\"24\":2,\"25\":3,\"63\":3,\"72\":1,\"76\":2,\"159\":1,\"323\":1,\"382\":1,\"424\":4,\"449\":1,\"455\":1,\"463\":1,\"467\":2,\"468\":1,\"473\":2,\"474\":1,\"578\":1,\"593\":1,\"693\":2}}],[\"中常见的\",{\"1\":{\"680\":1}}],[\"中配置\",{\"1\":{\"673\":1}}],[\"中配置全局逻辑删除属性\",{\"1\":{\"310\":2}}],[\"中文文档地址\",{\"1\":{\"668\":1}}],[\"中文官网\",{\"1\":{\"666\":1}}],[\"中新增了一个\",{\"1\":{\"655\":1}}],[\"中也可以使用\",{\"1\":{\"650\":1}}],[\"中实现堆栈数据结构\",{\"1\":{\"648\":1}}],[\"中键如果是基本数据类型\",{\"1\":{\"647\":1}}],[\"中标准的对象创建方式\",{\"1\":{\"642\":1}}],[\"中注解占据了更重要的角色\",{\"1\":{\"624\":1}}],[\"中所有偶数的和\",{\"1\":{\"566\":1}}],[\"中所有数的立方和\",{\"1\":{\"561\":1,\"563\":1}}],[\"中不同类型变量的输出格式\",{\"1\":{\"555\":1}}],[\"中间表至少包含两个外键\",{\"1\":{\"526\":1}}],[\"中间件流式消费\",{\"1\":{\"283\":1}}],[\"中间件解决了异构网络环境下软件互联和互操作等共性问题\",{\"1\":{\"14\":1}}],[\"中间件与操作系统和数据库共同构成基础软件三大支柱\",{\"1\":{\"14\":1}}],[\"中间件不仅仅实现互连\",{\"1\":{\"14\":1}}],[\"中间件是一类软件统称\",{\"1\":{\"14\":1}}],[\"中间件在客户服务器的操作系统\",{\"1\":{\"14\":1}}],[\"中间件\",{\"0\":{\"14\":1},\"1\":{\"14\":1},\"2\":{\"664\":1,\"669\":1,\"677\":1}}],[\"中是\",{\"1\":{\"522\":1}}],[\"中是否包含和\",{\"1\":{\"24\":1}}],[\"中等长度文本数据\",{\"1\":{\"507\":1}}],[\"中数据库的常见操作\",{\"1\":{\"498\":1}}],[\"中序建树\",{\"1\":{\"419\":1}}],[\"中序遍历很好地利用了二叉搜索树的性质\",{\"1\":{\"487\":1}}],[\"中序遍历即层序遍历\",{\"1\":{\"487\":1}}],[\"中序遍历性质\",{\"1\":{\"419\":1}}],[\"中序遍历\",{\"0\":{\"487\":1},\"1\":{\"382\":1,\"419\":1}}],[\"中序\",{\"1\":{\"382\":1,\"420\":1}}],[\"中添加如下配置\",{\"1\":{\"354\":1}}],[\"中下载已构建打包好的压缩包\",{\"1\":{\"352\":1}}],[\"中来自\",{\"1\":{\"346\":1}}],[\"中安装\",{\"1\":{\"346\":1}}],[\"中这\",{\"1\":{\"334\":1}}],[\"中可以取出基于该\",{\"1\":{\"310\":1}}],[\"中心仓库寻找\",{\"1\":{\"303\":1}}],[\"中查找小于等于\",{\"1\":{\"243\":1}}],[\"中查找大于等于\",{\"1\":{\"243\":1}}],[\"中能整除\",{\"1\":{\"212\":1}}],[\"中能被\",{\"1\":{\"212\":1}}],[\"中至少一个数整除的整数有多少个\",{\"1\":{\"212\":1}}],[\"中p的次数是\",{\"1\":{\"210\":1}}],[\"中国剩余定理\",{\"0\":{\"204\":1}}],[\"中计算过了\",{\"1\":{\"200\":1}}],[\"中与\",{\"1\":{\"199\":1}}],[\"中最多只包含一个大于\",{\"1\":{\"188\":1}}],[\"中找到\",{\"1\":{\"144\":2}}],[\"中的语法\",{\"1\":{\"680\":1}}],[\"中的语句\",{\"1\":{\"559\":1}}],[\"中的命令行可以看成是一个\",{\"1\":{\"680\":1}}],[\"中的方法在\",{\"1\":{\"650\":1}}],[\"中的元素和\",{\"1\":{\"647\":1}}],[\"中的子串\",{\"1\":{\"578\":1}}],[\"中的条件表达式作用一样\",{\"1\":{\"563\":1}}],[\"中的内容为可选参数\",{\"1\":{\"505\":1}}],[\"中的一个节点\",{\"1\":{\"443\":1}}],[\"中的文件\",{\"1\":{\"356\":1}}],[\"中的盐值和密码混淆都是用来提高密码安全性的防护措施\",{\"1\":{\"323\":1}}],[\"中的数据最终是面向运营体系提供服务能力\",{\"1\":{\"283\":1}}],[\"中的数据被\",{\"1\":{\"283\":1}}],[\"中的次数\",{\"1\":{\"210\":1}}],[\"中的所有质数\",{\"1\":{\"191\":1,\"567\":1}}],[\"中的每个数加上c\",{\"1\":{\"154\":1}}],[\"中的\",{\"1\":{\"142\":2,\"269\":1,\"334\":1,\"401\":1,\"655\":1,\"673\":1,\"707\":1}}],[\"中的某个字符替换为另一个字符\",{\"1\":{\"126\":1}}],[\"中的某个字符删除\",{\"1\":{\"126\":1}}],[\"中使用当前类的成员函数和成员变量\",{\"1\":{\"75\":1}}],[\"中含有空字符\",{\"1\":{\"63\":1}}],[\"中会使用一个标记数组\",{\"1\":{\"48\":1}}],[\"中删除\",{\"1\":{\"35\":1}}],[\"中选取优先级最高的节点\",{\"1\":{\"35\":1}}],[\"中\",{\"0\":{\"318\":1},\"1\":{\"35\":6,\"138\":1,\"140\":1,\"279\":1,\"282\":1,\"283\":2,\"318\":1,\"450\":1,\"451\":2,\"456\":1,\"467\":1,\"468\":1,\"624\":1,\"626\":1,\"648\":1,\"706\":1,\"708\":1}}],[\"和之前初始化\",{\"1\":{\"714\":1}}],[\"和之前讲过的\",{\"1\":{\"710\":1}}],[\"和定义常量来获取配置项的方式不同\",{\"1\":{\"704\":1}}],[\"和定义逻辑自恰\",{\"1\":{\"463\":1}}],[\"和校验和\",{\"1\":{\"668\":1}}],[\"和传统对象存储相比\",{\"1\":{\"668\":1}}],[\"和可变字符串\",{\"1\":{\"641\":1}}],[\"和a\",{\"1\":{\"593\":1}}],[\"和字段值的长度无关\",{\"1\":{\"507\":1}}],[\"和d\",{\"1\":{\"507\":2}}],[\"和一个整数\",{\"1\":{\"362\":1,\"479\":1}}],[\"和数据库服务器\",{\"1\":{\"353\":1}}],[\"和端口\",{\"1\":{\"347\":1}}],[\"和尽可能高的写吞吐\",{\"1\":{\"273\":1}}],[\"和上面类似\",{\"1\":{\"242\":1}}],[\"和条件\",{\"1\":{\"215\":1}}],[\"和前面每一个都组合一下\",{\"1\":{\"81\":1}}],[\"和第\",{\"1\":{\"43\":1}}],[\"和\",{\"1\":{\"24\":1,\"35\":2,\"43\":3,\"63\":2,\"81\":3,\"83\":1,\"93\":4,\"98\":1,\"100\":1,\"110\":1,\"111\":1,\"123\":2,\"124\":2,\"125\":1,\"126\":1,\"129\":2,\"137\":1,\"138\":1,\"141\":1,\"142\":1,\"143\":1,\"149\":1,\"150\":1,\"171\":1,\"182\":1,\"192\":2,\"203\":1,\"204\":2,\"212\":1,\"242\":1,\"264\":1,\"273\":2,\"280\":1,\"302\":1,\"343\":1,\"344\":1,\"347\":1,\"350\":1,\"353\":1,\"354\":1,\"408\":1,\"418\":1,\"442\":1,\"445\":2,\"449\":1,\"450\":1,\"451\":5,\"507\":2,\"532\":1,\"563\":1,\"648\":1,\"655\":1,\"663\":1,\"668\":2,\"704\":1,\"712\":1,\"715\":1,\"717\":1}}],[\"资料\",{\"1\":{\"343\":1}}],[\"资料等等\",{\"1\":{\"19\":1}}],[\"资源共享\",{\"1\":{\"14\":1}}],[\"常量的方式不易于修改\",{\"1\":{\"704\":1}}],[\"常量的方式较容易取错变量\",{\"1\":{\"704\":1}}],[\"常量\",{\"1\":{\"551\":1}}],[\"常作为临时表\",{\"1\":{\"538\":1}}],[\"常规的广度优先搜索只有一个起点\",{\"1\":{\"468\":1}}],[\"常见命令以\",{\"1\":{\"353\":1}}],[\"常见的有阿里云对象存储服务\",{\"1\":{\"667\":1}}],[\"常见的有\",{\"1\":{\"343\":1,\"680\":1}}],[\"常见模型\",{\"1\":{\"227\":1,\"230\":1}}],[\"常见问题分类\",{\"1\":{\"160\":1}}],[\"常见中间件主要分为\",{\"1\":{\"14\":1}}],[\"常用语言的\",{\"1\":{\"668\":1}}],[\"常用方法\",{\"1\":{\"642\":1}}],[\"常用注解\",{\"0\":{\"625\":1}}],[\"常用容器\",{\"0\":{\"608\":1}}],[\"常用ascii值\",{\"1\":{\"577\":1}}],[\"常用api\",{\"0\":{\"575\":1,\"628\":1,\"633\":1,\"639\":1},\"1\":{\"578\":1}}],[\"常用比较运算符\",{\"1\":{\"557\":1}}],[\"常用聚合函数\",{\"1\":{\"519\":1}}],[\"常用的操作符\",{\"1\":{\"535\":1,\"536\":1,\"537\":1}}],[\"常用的逻辑运算符如下\",{\"1\":{\"518\":1}}],[\"常用的比较运算符如下\",{\"1\":{\"518\":1}}],[\"常用库函数\",{\"0\":{\"243\":1}}],[\"常用来对一个数据的某些位设置为1\",{\"1\":{\"158\":1}}],[\"常用模版\",{\"1\":{\"127\":1}}],[\"常用于配合\",{\"1\":{\"72\":1}}],[\"常用框架\",{\"0\":{\"17\":1},\"2\":{\"730\":1}}],[\"为脚本解释器\",{\"1\":{\"680\":1}}],[\"为保持\",{\"1\":{\"654\":1}}],[\"为接口\",{\"1\":{\"649\":1}}],[\"为根的子树\",{\"1\":{\"486\":1}}],[\"为根的这棵二叉树已经被翻转\",{\"1\":{\"463\":1}}],[\"为根的这棵二叉树翻转\",{\"1\":{\"463\":1}}],[\"为子节点\",{\"1\":{\"425\":2}}],[\"为什么还会有其他\",{\"1\":{\"714\":1}}],[\"为什么每次遇到岛屿\",{\"1\":{\"443\":1}}],[\"为什么要配置进程守护呢\",{\"1\":{\"353\":1}}],[\"为什么基础功能的原子化实现需要架构的补充呢\",{\"1\":{\"261\":1}}],[\"为了提高范围查询效率\",{\"1\":{\"545\":1}}],[\"为了判断是否有永远不会腐烂的橘子\",{\"1\":{\"468\":1}}],[\"为了优化算法\",{\"1\":{\"365\":1}}],[\"为了更方便地管理防火墙和端口规则\",{\"1\":{\"345\":1}}],[\"为了某些学习目的\",{\"1\":{\"343\":1}}],[\"为了保证数据完整性\",{\"1\":{\"264\":1}}],[\"为方便前后端联调显示用户的登录状态\",{\"1\":{\"315\":1}}],[\"为业务在评论区获得更好的曝光展现\",{\"1\":{\"267\":1}}],[\"为一些长耗时\",{\"1\":{\"261\":1}}],[\"为评论基础功能的原子化实现\",{\"1\":{\"261\":1}}],[\"为多个内部管理后台提供服务\",{\"1\":{\"259\":1}}],[\"为用户营造更好的评论区氛围\",{\"1\":{\"255\":1}}],[\"为x的后继节点y1\",{\"1\":{\"218\":1}}],[\"为求出不属于集合s的最小非负整数的运算\",{\"1\":{\"217\":1}}],[\"为质数时\",{\"1\":{\"208\":1}}],[\"为避免这种情况\",{\"1\":{\"158\":1}}],[\"为右下角的子矩阵中的所有元素加上c\",{\"1\":{\"155\":1}}],[\"为右下角的子矩阵的和为\",{\"1\":{\"153\":1}}],[\"为左上角\",{\"1\":{\"153\":1,\"155\":1}}],[\"为高兴值\",{\"1\":{\"134\":1}}],[\"为父亲\",{\"1\":{\"134\":1}}],[\"为\",{\"1\":{\"94\":1,\"158\":2,\"208\":2,\"212\":1,\"289\":1,\"344\":1,\"346\":1,\"354\":1,\"419\":1,\"509\":1,\"513\":1}}],[\"为亲戚\",{\"1\":{\"93\":1}}],[\"为人数\",{\"1\":{\"93\":1}}],[\"为第\",{\"1\":{\"134\":2}}],[\"为第三段\",{\"1\":{\"82\":1}}],[\"为第一段\",{\"1\":{\"82\":1}}],[\"为起点\",{\"1\":{\"57\":1}}],[\"为路\",{\"1\":{\"56\":1,\"57\":1}}],[\"为墙\",{\"1\":{\"56\":1,\"57\":1}}],[\"为防止数组越界\",{\"1\":{\"48\":1}}],[\"为例\",{\"1\":{\"48\":1,\"49\":1,\"50\":1,\"55\":1,\"56\":1,\"57\":1}}],[\"为搜索方便\",{\"1\":{\"48\":1}}],[\"为节点\",{\"1\":{\"35\":1}}],[\"为终点\",{\"1\":{\"35\":1}}],[\"为空\",{\"1\":{\"25\":1}}],[\"为应用软件间共享资源提供了可复用的\",{\"1\":{\"14\":1}}],[\"为上层应用软件提供开发\",{\"1\":{\"14\":1}}],[\"并放到\",{\"1\":{\"706\":1}}],[\"并形成一个全局的命名空间\",{\"1\":{\"668\":1}}],[\"并调整堆\",{\"1\":{\"651\":1}}],[\"并令引用变量\",{\"1\":{\"642\":1}}],[\"并填入arr的值\",{\"1\":{\"640\":1}}],[\"并唤醒被该锁阻塞的其他线程\",{\"1\":{\"634\":1}}],[\"并返回原来的值\",{\"1\":{\"647\":1}}],[\"并返回删除元素e\",{\"1\":{\"645\":1}}],[\"并返回栈顶元素\",{\"1\":{\"610\":1}}],[\"并返回\",{\"1\":{\"583\":1}}],[\"并返回其根节点\",{\"1\":{\"461\":1}}],[\"并返回淹没的陆地面积\",{\"1\":{\"50\":1}}],[\"并更改大小为理论最大文件尺寸\",{\"1\":{\"354\":1}}],[\"并更新最大岛屿面积\",{\"1\":{\"50\":1}}],[\"并将这些块分散存储在不同的磁盘上\",{\"1\":{\"668\":1}}],[\"并将该对象转换为\",{\"1\":{\"522\":1}}],[\"并将该节点的左右子节点继续存到队列中进行下一层遍历\",{\"1\":{\"395\":1}}],[\"并将下文\",{\"1\":{\"353\":1}}],[\"并将热点标识传递至bff层\",{\"1\":{\"266\":1}}],[\"并持续运行以提供某种服务或执行特定任务\",{\"1\":{\"353\":1}}],[\"并解压\",{\"1\":{\"347\":1}}],[\"并添加如下配置\",{\"1\":{\"346\":1}}],[\"并把协议链接录入测试\",{\"1\":{\"344\":1}}],[\"并设置端口为\",{\"1\":{\"344\":1}}],[\"并设置安全组开放\",{\"1\":{\"344\":1,\"346\":1}}],[\"并设置优先级为\",{\"1\":{\"35\":1}}],[\"并与存储的加密密码进行比对\",{\"1\":{\"323\":1}}],[\"并记得要在\",{\"1\":{\"310\":1}}],[\"并运行\",{\"1\":{\"302\":1}}],[\"并提供了修改字符串的方法\",{\"1\":{\"641\":1}}],[\"并提供标准接口\",{\"1\":{\"14\":1}}],[\"并提升整个热评模块的可观测水平\",{\"1\":{\"273\":1}}],[\"并发事务导致的\",{\"1\":{\"270\":1}}],[\"并发查询楼中楼评论列表\",{\"1\":{\"263\":1}}],[\"并结合在线数据库刷新部分实时性要求较高的字段\",{\"1\":{\"259\":1}}],[\"并转换为视图模型\",{\"1\":{\"258\":1}}],[\"并在gi上行动一步\",{\"1\":{\"219\":1}}],[\"并不是第一行\",{\"1\":{\"205\":1}}],[\"并回代得到方程的解\",{\"1\":{\"205\":1}}],[\"并逐位执行操作\",{\"1\":{\"157\":1}}],[\"并进行路径压缩\",{\"1\":{\"90\":1}}],[\"并按引用捕获\",{\"1\":{\"75\":1}}],[\"并作为副本在函数体中使用\",{\"1\":{\"75\":1}}],[\"并作为引用在函数体中使用\",{\"1\":{\"75\":1}}],[\"并非真正的无穷大\",{\"1\":{\"174\":1}}],[\"并非字符串的首地址\",{\"1\":{\"63\":1}}],[\"并非所有场景下都能做到这一点\",{\"1\":{\"36\":1}}],[\"并没有return\",{\"1\":{\"43\":1}}],[\"并且除了\",{\"1\":{\"668\":1}}],[\"并且支持跨越多个数据中心\",{\"1\":{\"668\":1}}],[\"并且忽略挂起\",{\"1\":{\"660\":1}}],[\"并且相同索引对应的元素都相同\",{\"1\":{\"640\":1}}],[\"并且可以在语句执行完毕后确保每个资源都被自动关闭\",{\"1\":{\"622\":1}}],[\"并且可以捕获一定范围内的变量\",{\"1\":{\"75\":1}}],[\"并且底层已经实现了按照索引进行排序\",{\"1\":{\"545\":1}}],[\"并且设置外键为唯一的\",{\"1\":{\"525\":1}}],[\"并且\",{\"1\":{\"518\":1,\"668\":1}}],[\"并且学习课程\",{\"1\":{\"474\":1}}],[\"并且每座岛屿只能由水平方向和\",{\"1\":{\"442\":1}}],[\"并且每个节点之间的移动代价是相等的\",{\"1\":{\"33\":1}}],[\"并且对于相同前缀只存储一次\",{\"1\":{\"425\":1}}],[\"并且对于任意的整数\",{\"1\":{\"208\":1}}],[\"并且你需要频繁地查找第\",{\"1\":{\"364\":1}}],[\"并且需要对\",{\"1\":{\"344\":1}}],[\"并且给该\",{\"1\":{\"310\":1}}],[\"并且评论之间是通过赞数进行排序的\",{\"1\":{\"289\":1}}],[\"并且从每个局面向沿着合法行动能够到达的下一个局面连有向边\",{\"1\":{\"216\":1}}],[\"并且判断是否有解\",{\"1\":{\"204\":1}}],[\"并且边长之和最小\",{\"1\":{\"180\":1}}],[\"并且一般\",{\"1\":{\"127\":1}}],[\"并且速度很快\",{\"1\":{\"36\":1}}],[\"并加入\",{\"1\":{\"35\":1}}],[\"并查集核心操作\",{\"1\":{\"181\":1}}],[\"并查集的父节点数组\",{\"1\":{\"181\":1}}],[\"并查集是一种非常精巧实用的数据结构\",{\"1\":{\"87\":1}}],[\"并查集\",{\"0\":{\"86\":1,\"94\":1,\"233\":1,\"445\":1},\"1\":{\"3\":1},\"2\":{\"96\":1,\"447\":1}}],[\"lmin\",{\"1\":{\"656\":1}}],[\"lmax\",{\"1\":{\"656\":1}}],[\"lru\",{\"1\":{\"293\":1}}],[\"l代表区间左端点\",{\"1\":{\"251\":1}}],[\"lucas\",{\"0\":{\"209\":1},\"1\":{\"209\":4}}],[\"lcs\",{\"1\":{\"450\":2,\"451\":4}}],[\"lc\",{\"1\":{\"419\":1}}],[\"lcm\",{\"1\":{\"197\":1}}],[\"lca\",{\"1\":{\"87\":1}}],[\"ln2\",{\"1\":{\"334\":1}}],[\"ln\",{\"1\":{\"191\":4}}],[\"license\",{\"1\":{\"666\":1}}],[\"linkedhashset\",{\"1\":{\"646\":2}}],[\"linkedlist\",{\"1\":{\"474\":1,\"475\":1,\"645\":2,\"648\":1,\"649\":1}}],[\"linkedlist<>\",{\"1\":{\"390\":1,\"396\":1,\"402\":2,\"444\":1,\"469\":1,\"474\":1,\"475\":1,\"609\":1,\"611\":1,\"645\":1,\"649\":1,\"650\":1}}],[\"line\",{\"1\":{\"554\":1,\"622\":5}}],[\"linux运维\",{\"1\":{\"344\":1}}],[\"linux\",{\"0\":{\"660\":1,\"752\":1},\"1\":{\"7\":1,\"352\":3,\"353\":2,\"354\":2,\"660\":1,\"680\":2},\"2\":{\"699\":1}}],[\"lib\",{\"1\":{\"353\":1}}],[\"listobjectsargs\",{\"1\":{\"676\":1}}],[\"listobjects\",{\"1\":{\"676\":4}}],[\"listbuckets\",{\"1\":{\"675\":2}}],[\"list2\",{\"1\":{\"654\":2}}],[\"list1\",{\"1\":{\"654\":2}}],[\"list<bucket>\",{\"1\":{\"675\":1}}],[\"list<e>\",{\"1\":{\"645\":2,\"646\":1,\"654\":4}}],[\"list<>\",{\"1\":{\"609\":1}}],[\"list<int\",{\"1\":{\"469\":2}}],[\"list<integer>\",{\"1\":{\"389\":3,\"390\":3,\"396\":1,\"474\":3,\"475\":2,\"645\":2}}],[\"list<treenode>\",{\"1\":{\"402\":2}}],[\"list<list<integer>>\",{\"1\":{\"396\":2}}],[\"list<user>\",{\"1\":{\"313\":2}}],[\"listen\",{\"1\":{\"346\":1,\"354\":2}}],[\"list\",{\"0\":{\"609\":1,\"645\":1,\"732\":1},\"1\":{\"313\":1,\"345\":2,\"390\":2,\"396\":4,\"522\":3,\"645\":3,\"646\":2,\"649\":1}}],[\"lived\",{\"1\":{\"293\":1}}],[\"like\",{\"1\":{\"263\":1,\"264\":1,\"273\":2,\"313\":1,\"518\":1,\"545\":1}}],[\"limit\",{\"1\":{\"125\":3,\"263\":2,\"516\":2,\"522\":3}}],[\"lb\",{\"1\":{\"125\":4}}],[\"locks\",{\"1\":{\"634\":1}}],[\"lock\",{\"1\":{\"634\":5}}],[\"location\",{\"1\":{\"354\":3}}],[\"localhost\",{\"1\":{\"329\":2,\"662\":1,\"673\":1}}],[\"locales\",{\"1\":{\"302\":1}}],[\"local\",{\"1\":{\"294\":2}}],[\"loadproperties\",{\"1\":{\"706\":1}}],[\"loadcascadedpropertiesfromresources\",{\"1\":{\"706\":2}}],[\"load\",{\"1\":{\"294\":1}}],[\"logger\",{\"1\":{\"706\":1,\"722\":2}}],[\"log>\",{\"1\":{\"663\":1}}],[\"logpath>\",{\"1\":{\"663\":1}}],[\"logs<\",{\"1\":{\"663\":1}}],[\"log10\",{\"1\":{\"653\":1}}],[\"logic\",{\"1\":{\"310\":4}}],[\"login\",{\"1\":{\"310\":3,\"311\":1,\"313\":1,\"315\":1,\"329\":2}}],[\"logo\",{\"1\":{\"272\":1}}],[\"logk\",{\"1\":{\"201\":1}}],[\"log\",{\"1\":{\"181\":1,\"188\":1,\"197\":1,\"310\":1,\"653\":3,\"660\":4}}],[\"logn\",{\"1\":{\"94\":2,\"242\":3,\"273\":1,\"291\":1,\"640\":1,\"651\":2,\"654\":1}}],[\"lowestcommonancestor\",{\"1\":{\"408\":3}}],[\"lower\",{\"1\":{\"122\":1,\"144\":3,\"242\":4,\"243\":4}}],[\"lowbit\",{\"1\":{\"159\":5}}],[\"longtext\",{\"1\":{\"507\":1}}],[\"longblob\",{\"1\":{\"507\":1}}],[\"longestcommonsubsequence\",{\"1\":{\"451\":1}}],[\"long\",{\"1\":{\"81\":2,\"82\":2,\"83\":2,\"131\":2,\"144\":2,\"180\":2,\"192\":2,\"196\":2,\"204\":2,\"212\":2,\"241\":4,\"311\":3,\"314\":1,\"323\":3,\"481\":1,\"486\":5,\"487\":2,\"488\":12,\"522\":1,\"551\":1,\"656\":2}}],[\"lld\",{\"1\":{\"165\":1,\"204\":6}}],[\"ll\",{\"1\":{\"81\":4,\"82\":3,\"83\":1,\"131\":2,\"144\":3,\"180\":1,\"192\":7,\"196\":4,\"204\":15,\"208\":4,\"209\":10,\"212\":2}}],[\"lang\",{\"1\":{\"628\":8}}],[\"language\",{\"0\":{\"749\":1},\"1\":{\"496\":4,\"498\":1,\"511\":1}}],[\"lang3<\",{\"1\":{\"323\":1}}],[\"lang3\",{\"1\":{\"323\":3}}],[\"lazy\",{\"1\":{\"291\":1}}],[\"la\",{\"1\":{\"125\":4}}],[\"lamda\",{\"1\":{\"75\":1}}],[\"lambda\",{\"1\":{\"75\":4}}],[\"lambda表达式\",{\"0\":{\"75\":1}}],[\"lastindexofsublist\",{\"1\":{\"654\":1}}],[\"lastindexof\",{\"1\":{\"578\":2,\"642\":2}}],[\"lasttime\",{\"1\":{\"321\":2}}],[\"last\",{\"1\":{\"74\":2,\"129\":4,\"646\":1}}],[\"l\",{\"1\":{\"43\":2,\"44\":1,\"81\":8,\"122\":4,\"137\":8,\"138\":7,\"140\":2,\"141\":8,\"142\":8,\"143\":6,\"145\":5,\"152\":2,\"154\":2,\"161\":4,\"162\":5,\"224\":8,\"241\":4,\"247\":3,\"248\":5,\"249\":5,\"250\":10,\"251\":9,\"401\":2,\"414\":3,\"438\":5,\"463\":2,\"486\":4}}],[\"levelorder\",{\"1\":{\"396\":1}}],[\"len\",{\"1\":{\"64\":2,\"122\":5,\"127\":12}}],[\"len++\",{\"1\":{\"64\":1,\"127\":2}}],[\"length\",{\"1\":{\"63\":6,\"242\":1,\"310\":2,\"323\":3,\"420\":7,\"426\":2,\"438\":1,\"443\":4,\"444\":2,\"445\":2,\"451\":2,\"469\":4,\"578\":2,\"580\":1,\"591\":1,\"640\":1,\"642\":1,\"643\":1,\"676\":1}}],[\"leftnodes\",{\"1\":{\"365\":6,\"366\":6}}],[\"left\",{\"1\":{\"25\":3,\"363\":1,\"366\":3,\"377\":4,\"378\":2,\"389\":1,\"390\":2,\"396\":2,\"401\":1,\"402\":2,\"408\":4,\"414\":1,\"419\":2,\"420\":15,\"432\":3,\"438\":1,\"463\":2,\"481\":1,\"486\":4,\"487\":1,\"488\":4,\"532\":1}}],[\"leetcode\",{\"0\":{\"5\":1,\"737\":1},\"1\":{\"419\":1}}],[\"架构\",{\"1\":{\"277\":1}}],[\"架构以及系统架构方面的笔记知识点\",{\"1\":{\"6\":1}}],[\"架构设计等同于数据设计\",{\"1\":{\"279\":1}}],[\"架构设计最重要的就是\",{\"1\":{\"278\":1}}],[\"架构设计\",{\"0\":{\"6\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"261\":1,\"279\":1},\"2\":{\"275\":1,\"285\":1,\"295\":1}}],[\"剑指offer\",{\"0\":{\"20\":1}}],[\"剑指\",{\"0\":{\"4\":1},\"1\":{\"337\":1}}],[\"笔记\",{\"0\":{\"3\":1},\"2\":{\"45\":1,\"52\":1,\"59\":1,\"78\":1,\"84\":1,\"95\":1,\"104\":1,\"112\":1}}],[\"笔试题和面试题等\",{\"1\":{\"1\":1}}],[\"贪心\",{\"0\":{\"245\":1},\"1\":{\"2\":1},\"2\":{\"252\":1}}],[\"数值类型\",{\"1\":{\"507\":2}}],[\"数学符号大全\",{\"1\":{\"340\":1}}],[\"数学运算\",{\"1\":{\"323\":1}}],[\"数学\",{\"2\":{\"220\":1}}],[\"数学知识\",{\"0\":{\"185\":1},\"1\":{\"2\":1}}],[\"数之间用空格隔开\",{\"1\":{\"204\":1}}],[\"数对\",{\"1\":{\"144\":1}}],[\"数位统计类dp\",{\"0\":{\"129\":1}}],[\"数列\",{\"1\":{\"124\":1}}],[\"数字类型包装类都支持两个常量\",{\"1\":{\"656\":1}}],[\"数字三角形\",{\"0\":{\"121\":1}}],[\"数字\",{\"1\":{\"111\":1,\"535\":1}}],[\"数组长度\",{\"0\":{\"698\":1}}],[\"数组用小括号表示\",{\"1\":{\"695\":1}}],[\"数组中可以存放多个不同类型的值\",{\"1\":{\"694\":1}}],[\"数组中只包含\",{\"1\":{\"98\":1}}],[\"数组降序排序排序\",{\"1\":{\"640\":1}}],[\"数组越界\",{\"1\":{\"620\":1}}],[\"数组不可变长\",{\"1\":{\"575\":1}}],[\"数组排序\",{\"1\":{\"575\":1}}],[\"数组下标从0开始\",{\"1\":{\"572\":1}}],[\"数组是存储数据的强而有力的手段\",{\"1\":{\"568\":1}}],[\"数组是上一次迭代后\",{\"1\":{\"174\":1}}],[\"数组记录遍历过的节点防止走回头路\",{\"1\":{\"443\":1}}],[\"数组的范围遍历\",{\"0\":{\"574\":1}}],[\"数组的初始化\",{\"0\":{\"571\":1}}],[\"数组的定义方式和变量类似\",{\"1\":{\"570\":1}}],[\"数组的定义\",{\"0\":{\"570\":1}}],[\"数组的长度\",{\"1\":{\"334\":1}}],[\"数组的备份\",{\"1\":{\"174\":1}}],[\"数组时\",{\"1\":{\"231\":2}}],[\"数组和匹配的操作类似\",{\"1\":{\"231\":1}}],[\"数组模拟链表\",{\"0\":{\"222\":1}}],[\"数组进行备份\",{\"1\":{\"174\":1}}],[\"数组b也是从低位\",{\"1\":{\"147\":1,\"148\":1}}],[\"数组a\",{\"1\":{\"147\":1,\"148\":1}}],[\"数组\",{\"0\":{\"568\":1,\"640\":1,\"694\":1},\"1\":{\"48\":1,\"94\":1,\"231\":2,\"243\":2,\"443\":1,\"445\":1,\"591\":1,\"642\":1,\"645\":1,\"694\":1}}],[\"数据存储高容错\",{\"1\":{\"668\":1}}],[\"数据列表\",{\"1\":{\"522\":1}}],[\"数据类型\",{\"0\":{\"507\":1},\"1\":{\"524\":1}}],[\"数据控制语言\",{\"1\":{\"496\":1}}],[\"数据查询语言\",{\"1\":{\"496\":1}}],[\"数据操作语言\",{\"1\":{\"496\":1,\"511\":1}}],[\"数据定义语言\",{\"1\":{\"496\":1,\"498\":1}}],[\"数据转换\",{\"1\":{\"323\":1}}],[\"数据更新时间\",{\"1\":{\"321\":1}}],[\"数据更新方式\",{\"1\":{\"273\":1}}],[\"数据插入时间\",{\"1\":{\"321\":1}}],[\"数据表\",{\"1\":{\"319\":1}}],[\"数据表设计\",{\"0\":{\"289\":1},\"1\":{\"289\":1}}],[\"数据\",{\"1\":{\"289\":1,\"293\":1,\"545\":2,\"568\":1}}],[\"数据双向请求等\",{\"1\":{\"279\":1}}],[\"数据局部性集中与散列相结合\",{\"1\":{\"273\":1}}],[\"数据提供方很难也不应该承受热评业务的巨大流量\",{\"1\":{\"273\":1}}],[\"数据量级规模的增加\",{\"1\":{\"273\":1}}],[\"数据报表丰富\",{\"1\":{\"273\":1}}],[\"数据读写阶段均考虑了一致性风险\",{\"1\":{\"269\":1}}],[\"数据安全\",{\"0\":{\"269\":1},\"1\":{\"268\":1}}],[\"数据稀疏\",{\"1\":{\"266\":1}}],[\"数据组装在服务编排之后执行\",{\"1\":{\"258\":1}}],[\"数据字段多\",{\"1\":{\"258\":1}}],[\"数据保证\",{\"1\":{\"98\":1}}],[\"数据用空格隔开\",{\"1\":{\"83\":2}}],[\"数据范围较大时\",{\"1\":{\"118\":1}}],[\"数据范围\",{\"1\":{\"43\":1,\"81\":1,\"82\":1,\"83\":1,\"98\":1,\"100\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"118\":1,\"124\":1}}],[\"数据库实际上会添加唯一索引\",{\"1\":{\"546\":1}}],[\"数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构\",{\"1\":{\"545\":1}}],[\"数据库中间件\",{\"1\":{\"14\":1}}],[\"数据库支持的索引结构有很多\",{\"1\":{\"545\":1}}],[\"数据库系统提供的隔离机制\",{\"1\":{\"542\":1}}],[\"数据库自动生成\",{\"1\":{\"506\":1}}],[\"数据库不存在\",{\"1\":{\"500\":1}}],[\"数据库名\",{\"1\":{\"500\":1,\"501\":1,\"502\":1}}],[\"数据库操作\",{\"0\":{\"498\":1,\"511\":1,\"515\":1}}],[\"数据库操作阶段\",{\"1\":{\"497\":1}}],[\"数据库优化阶段\",{\"1\":{\"497\":1}}],[\"数据库的\",{\"1\":{\"495\":1}}],[\"数据库字段添加索引\",{\"1\":{\"320\":1}}],[\"数据库里有什么\",{\"1\":{\"319\":1}}],[\"数据库已经无法实现这样复杂的\",{\"1\":{\"273\":1}}],[\"数据库与缓存均是双机房独立部署的\",{\"1\":{\"267\":1}}],[\"数据库更新后\",{\"1\":{\"264\":1}}],[\"数据库设计阶段\",{\"1\":{\"497\":1}}],[\"数据库设计\",{\"0\":{\"263\":1,\"319\":1,\"497\":1}}],[\"数据库之间\",{\"1\":{\"14\":1}}],[\"数据库\",{\"0\":{\"11\":1},\"1\":{\"7\":1,\"290\":1,\"300\":1,\"496\":1,\"498\":1,\"502\":1}}],[\"数据结构中只需要经历两次磁盘\",{\"1\":{\"545\":1}}],[\"数据结构\",{\"0\":{\"221\":1},\"1\":{\"2\":1},\"2\":{\"27\":1,\"95\":1,\"244\":1,\"367\":1,\"373\":1,\"379\":1,\"385\":1,\"391\":1,\"397\":1,\"403\":1,\"409\":1,\"415\":1,\"421\":1,\"433\":1,\"439\":1,\"458\":1,\"464\":1,\"482\":1,\"489\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
