import{_ as n,c as e,a as s,b as t,d as i,o as r}from"./app-B0wmcdse.js";const p={};function h(l,a){return r(),e("div",null,[a[0]||(a[0]=s("h1",{id:"并发容器之-concurrenthashmap",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#并发容器之-concurrenthashmap"},[s("span",null,"并发容器之 ConcurrentHashMap")])],-1)),t(" more "),a[1]||(a[1]=i(`<h2 id="_1-concurrenthashmap-简介" tabindex="-1"><a class="header-anchor" href="#_1-concurrenthashmap-简介"><span>1. ConcurrentHashMap 简介</span></a></h2><p>在使用 HashMap 时在多线程情况下扩容会出现 CPU 接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的情况，因为 hashmap 并不是线程安全的，通常我们可以使用在 Java 体系中古老的 hashtable 类，该类基本上所有的方法都采用 synchronized 进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。另外一种方式通过 Collections 的 <code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code> 将 hashmap 包装成一个线程安全的 map。比如 SynchronzedMap 的 <code>put</code> 方法源码为：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> put</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (mutex) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> m</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, value);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上 SynchronizedMap 实现依然是采用 synchronized 独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。针对这种境况，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>o</mi><mi>u</mi><mi>g</mi><mtext> </mtext><mi>L</mi><mi>e</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Doug \\ Lea</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Do</span><span class="mord mathnormal" style="margin-right:0.03588em;">ug</span><span class="mspace"> </span><span class="mord mathnormal">L</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span></span></span></span> 大师不遗余力的为我们创造了一些线程安全的并发容器，让每一个 Java 开发人员倍感幸福。</p><p>相对于 hashMap 来说，ConcurrentHashMap 就是线程安全的 Map，其中利用了锁分段的思想提高了并发度。</p><p>ConcurrentHashMap 在 JDK1.6 的版本网上资料很多，有兴趣的可以去看看。</p><p>JDK 1.6版本关键要素：</p><ol><li>segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；</li><li>segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。</li></ol><p>而到了 JDK 1.8 的 ConcurrentHashMap 就有了很大的变化，光是代码量就足足增加了很多。</p><p>1.8 版本舍弃了 segment，并且大量使用了 synchronized，以及 CAS 无锁操作以保证 ConcurrentHashMap 操作的线程安全性。至于为什么不用 ReentrantLock 而是 Synchronzied 呢？实际上，synchronzied 做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级。因此，使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用<strong>数组+链表+红黑树</strong>的数据形式。</p>`,10))])}const c=n(p,[["render",h],["__file","14. 并发容器之ConcurrentHashMap.html.vue"]]),m=JSON.parse('{"path":"/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/14.%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap.html","title":"并发容器之 ConcurrentHashMap","lang":"zh-CN","frontmatter":{"category":["并发编程"],"tag":["JUC"],"head":[["meta",{"property":"og:url","content":"https://blog.braumace.cn/ByteLighting/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/14.%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap.html"}],["meta",{"property":"og:site_name","content":"ByteLighting"}],["meta",{"property":"og:title","content":"并发容器之 ConcurrentHashMap"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-13T13:50:46.000Z"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:modified_time","content":"2024-10-13T13:50:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发容器之 ConcurrentHashMap\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-13T13:50:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"BraumAce\\",\\"url\\":\\"https://blog.braumace.cn/article\\"}]}"]]},"headers":[{"level":2,"title":"1. ConcurrentHashMap 简介","slug":"_1-concurrenthashmap-简介","link":"#_1-concurrenthashmap-简介","children":[]}],"git":{"createdTime":1728827446000,"updatedTime":1728827446000,"contributors":[{"name":"BraumAce","email":"1693717911@qq.com","commits":1}]},"readingTime":{"minutes":1.93,"words":578},"filePathRelative":"computer/language/java/JUC 并发编程/14. 并发容器之ConcurrentHashMap.md","localizedDate":"2024年10月13日","excerpt":"\\n"}');export{c as comp,m as data};
