import{_ as o,c as p,a as e,b as r,d as l,e as t,f as i,g as n,r as m,o as c}from"./app-DxMLoS09.js";const g={};function u(d,a){const s=m("RouteLink");return c(),p("div",null,[a[7]||(a[7]=e("h1",{id:"并发容器之-blockingqueue",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#并发容器之-blockingqueue"},[e("span",null,"并发容器之 BlockingQueue")])],-1)),r(" more "),a[8]||(a[8]=e("h2",{id:"_1-blockingqueue-简介",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-blockingqueue-简介"},[e("span",null,"1. BlockingQueue 简介")])],-1)),e("p",null,[a[3]||(a[3]=l('在实际编程中，会经常使用到 JDK 中 Collection 集合框架中的各种容器类如实现 List，Map，Queue 接口的容器类，但是这些容器类基本上不是线程安全的，除了使用 Collections 可以将其转换为线程安全的容器，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>o</mi><mi>u</mi><mi>g</mi><mtext> </mtext><mi>L</mi><mi>e</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Doug \\ Lea</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Do</span><span class="mord mathnormal" style="margin-right:0.03588em;">ug</span><span class="mspace"> </span><span class="mord mathnormal">L</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span></span></span></span> 大师为我们都准备了对应的线程安全的容器，如实现 List 接口的 ',3)),t(s,{to:"/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/16.%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList.html"},{default:i(()=>a[0]||(a[0]=[n("CopyOnWriteArrayList")])),_:1}),a[4]||(a[4]=n("，实现 Map 接口的 ")),t(s,{to:"/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/14.%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap.html"},{default:i(()=>a[1]||(a[1]=[n("ConcurrentHashMap")])),_:1}),a[5]||(a[5]=n("，实现 Queue 接口的 ")),t(s,{to:"/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15.%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.html"},{default:i(()=>a[2]||(a[2]=[n("ConcurrentLinkedQueue")])),_:1}),a[6]||(a[6]=n("。"))]),a[9]||(a[9]=l('<p>最常用的 “<strong>生产者-消费者</strong>” 问题中，队列通常被视作线程间操作的数据容器，这样就可以对各个模块的业务功能进行解耦，生产者将 “生产” 出来的数据放置在数据容器中，而消费者仅仅只需要在 “数据容器” 中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。</p><p>阻塞队列（BlockingQueue）被广泛使用在 “生产者-消费者” 问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。<strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止</strong>。</p><h2 id="_2-基本操作" tabindex="-1"><a class="header-anchor" href="#_2-基本操作"><span>2. 基本操作</span></a></h2><p>BlockingQueue 基本操作总结如下（此图来源于 JAVA API 文档）：</p><figure><img src="https://cloud.bytelighting.cn/f/GRdHV/19.1 BlockingQueue基本操作.png" alt="BlockingQueue 基本操作" tabindex="0" loading="lazy"><figcaption>BlockingQueue 基本操作</figcaption></figure><p>BlockingQueue 继承于 Queue 接口，因此，对数据元素的基本操作有：</p><ol><li><p><strong>插入元素</strong></p><p><code>add(E e)</code>：往队列插入数据，当队列满时，插入元素时会抛出 IllegalStateException 异常。</p><p><code>offer(E e)</code>：当往队列插入数据时，插入成功返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>，否则则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span>。当队列满时不会抛出异常。</p></li><li><p><strong>删除元素</strong></p><p><code>remove(Object o)</code>：从队列中删除数据，成功则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>，否则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span>。</p><p><code>poll()</code>：删除数据，当队列为空时，返回 <code>null</code>。</p></li><li><p><strong>查看元素</strong></p><p><code>element()</code>：获取队头元素，如果队列为空时则抛出 NoSuchElementException 异常。</p><p><code>peek()</code>：获取队头元素，如果队列为空则抛出 NoSuchElementException 异常。</p></li></ol><p>BlockingQueue 具有的特殊操作：</p><ol><li><p><strong>插入数据</strong></p><p><code>put(E e)</code>：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用。</p><p><code>offer(E e, long timeout, TimeUnit unit)</code>：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与 <code>put</code> 方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出。</p></li><li><p><strong>删除数据</strong></p><p><code>take()</code>：当阻塞队列为空时，获取队头数据的线程会被阻塞。</p><p><code>poll(long timeout, TimeUnit unit)</code>：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出。</p></li></ol><h2 id="_3-常用的-blockingqueue" tabindex="-1"><a class="header-anchor" href="#_3-常用的-blockingqueue"><span>3. 常用的 BlockingQueue</span></a></h2><p>实现 BlockingQueue 接口的有 ArrayBlockingQueue，DelayQueue，LinkedBlockingDeque，LinkedBlockingQueue，LinkedTransferQueue，PriorityBlockingQueue，SynchronousQueue。而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：</p><ol><li><strong>ArrayBlockingQueue</strong></li></ol><p>ArrayBlockingQueue 是由数组实现的有界阻塞队列。该队列命令元素 FIFO（先进先出）。因此，队头元素是队列中存在时间最长的数据元素，而队尾数据则是当前队列最新的数据元素。</p><p>ArrayBlockingQueue 可作为 “有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。</p><p>ArrayBlockingQueue 一旦创建，容量不能改变。</p><p>当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。</p><p>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，一旦 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。<strong>如果保证公平性，通常会降低吞吐量</strong>。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayBlockingQueue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> blockingQueue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayBlockingQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>关于 ArrayBlockingQueue 的实现原理，在<a href="">下一篇文章</a>。</p><ol start="2"><li><strong>LinkedBlockingQueue</strong></li></ol><p>LinkedBlockingQueue 是用链表实现的有界阻塞队列，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量。</p><p>为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存，通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 <code>Integer.MAX_VALUE</code>。</p><ol start="3"><li><strong>PriorityBlockingQueue</strong></li></ol><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。</p><p>默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</p><ol start="4"><li><strong>SynchronousQueue</strong></li></ol><p>SynchronousQueue 每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue 实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。</p><p>SynchronousQueue 也可以通过构造器参数来为其指定公平性。</p><ol start="5"><li><strong>LinkedTransferQueue</strong></li></ol><p>LinkedTransferQueue 是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了 TransferQueue 接口，与其他阻塞队列相比主要有以下不同的方法：</p><p><code>transfer(E e)</code>：如果当前有线程（消费者）正在调用 <code>take()</code> 方法或者可延时的 <code>poll()</code> 方法在消费数据，生产者线程可以调用 <code>transfer</code> 方法将数据传递给消费者线程。如果当前没有消费者线程，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出。</p><p><code>tryTransfer(E e)</code>：如果当前有线程（消费者）正在调用 <code>take()</code> 方法或者具有超时特性的 <code>poll()</code> 方法在消费数据，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据，就立即返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span>。</p><p>因此，与 <code>transfer</code> 方法相比，<code>transfer</code> 方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而 <code>tryTransfer</code> 方法能够立即返回结果退出。</p><p><code>tryTransfer(E e,long timeout,imeUnit unit)</code>：与 <code>transfer</code> 基本功能一样，只是增加了超时特性，如果数据在规定的超时时间内没有消费者进行消费的话，就返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span>。</p><ol start="6"><li><strong>LinkedBlockingDeque</strong></li></ol><p>LinkedBlockingDeque 是基于链表数据结构的有界阻塞双端队列，如果在创建对象时未指定大小，其默认大小为 <code>Integer.MAX_VALUE</code>。</p><p>与 LinkedBlockingQueue 相比，主要的不同点在于 LinkedBlockingDeque 具有双端队列的特性。</p><p>LinkedBlockingDeque 基本操作如下图所示（来源于 Java 文档）</p><figure><img src="https://cloud.bytelighting.cn/f/8mgc3/19.2 LinkedBlockingDeque的基本操作.png" alt="LinkedBlockingDeque 的基本操作" tabindex="0" loading="lazy"><figcaption>LinkedBlockingDeque 的基本操作</figcaption></figure><p>如上图所示，LinkedBlockingDeque 的基本操作可以分为四种类型：</p><ol><li>特殊情况，抛出异常；</li><li>特殊情况，返回特殊值，如 <code>null</code> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span>；</li><li>当线程不满足操作条件时，线程会被阻塞直至条件满足；</li><li>操作具有超时特性。</li></ol><p>另外，LinkedBlockingDeque 实现了 BlockingDueue 接口而 LinkedBlockingQueue 实现的是 BlockingQueue，这两个接口的主要区别如下图所示（来源于 Java 文档）：</p><figure><img src="https://cloud.bytelighting.cn/f/KmrT9/19.3 BlockingQueue和BlockingDeque的区别.png" alt="BlockingQueue 和 BlockingDeque 的区别" tabindex="0" loading="lazy"><figcaption>BlockingQueue 和 BlockingDeque 的区别</figcaption></figure><p>从上图可以看出，两个接口的功能是可以等价使用的，比如 BlockingQueue 的 <code>add</code> 方法和 BlockingDeque 的 <code>addLast</code> 方法的功能是一样的。</p><ol start="7"><li><strong>DelayQueue</strong></li></ol><p>DelayQueue 是一个存放实现 Delayed 接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。</p><p>如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过 <code>poll</code> 等方法获取数据元素会返回 <code>null</code>。</p><p>所谓<strong>数据延时期满</strong>，是通过 Delayed 接口的 <code>getDelay(TimeUnit.NANOSECONDS)</code> 来进行判定，如果该方法返回的是小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 则说明该数据元素的延时期已满。</p>',48))])}const k=o(g,[["render",u],["__file","19. 并发容器之BlockingQueue.html.vue"]]),B=JSON.parse('{"path":"/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/19.%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.html","title":"并发容器之 BlockingQueue","lang":"zh-CN","frontmatter":{"category":["并发编程"],"tag":["JUC"],"head":[["meta",{"property":"og:url","content":"https://blog.bytelighting.cn/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/19.%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.html"}],["meta",{"property":"og:site_name","content":"ByteLighting"}],["meta",{"property":"og:title","content":"并发容器之 BlockingQueue"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cloud.bytelighting.cn/f/GRdHV/19.1%20BlockingQueue%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-17T02:42:14.000Z"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:modified_time","content":"2025-06-17T02:42:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发容器之 BlockingQueue\\",\\"image\\":[\\"https://cloud.bytelighting.cn/f/GRdHV/19.1%20BlockingQueue%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png\\",\\"https://cloud.bytelighting.cn/f/8mgc3/19.2%20LinkedBlockingDeque%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png\\",\\"https://cloud.bytelighting.cn/f/KmrT9/19.3%20BlockingQueue%E5%92%8CBlockingDeque%E7%9A%84%E5%8C%BA%E5%88%AB.png\\"],\\"dateModified\\":\\"2025-06-17T02:42:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"BraumAce\\",\\"url\\":\\"https://blog.bytelighting.cn/article\\"}]}"]]},"headers":[{"level":2,"title":"1. BlockingQueue 简介","slug":"_1-blockingqueue-简介","link":"#_1-blockingqueue-简介","children":[]},{"level":2,"title":"2. 基本操作","slug":"_2-基本操作","link":"#_2-基本操作","children":[]},{"level":2,"title":"3. 常用的 BlockingQueue","slug":"_3-常用的-blockingqueue","link":"#_3-常用的-blockingqueue","children":[]}],"git":{"createdTime":1730296210000,"updatedTime":1750128134000,"contributors":[{"name":"BraumAce","email":"1693717911@qq.com","commits":2}]},"readingTime":{"minutes":7.37,"words":2212},"filePathRelative":"computer/language/java/JUC 并发编程/19. 并发容器之BlockingQueue.md","localizedDate":"2024年10月30日","excerpt":"\\n"}');export{k as comp,B as data};
