import{_ as a,c as n,a as s,b as l,d as t,o as e}from"./app-Be5iA4J3.js";const h={};function p(k,i){return e(),n("div",null,[i[0]||(i[0]=s("h1",{id:"你真的了解-final-吗",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#你真的了解-final-吗"},[s("span",null,"你真的了解 final 吗")])],-1)),l(" more "),i[1]||(i[1]=t(`<h2 id="_1-final-简介" tabindex="-1"><a class="header-anchor" href="#_1-final-简介"><span>1. final 简介</span></a></h2><p>final 可以修饰<strong>变量，方法和类</strong>，用于表示所修饰的内容一旦赋值之后就不会再被改变。</p><p>比如 String 类就是一个 final 类型的类，它是一个<strong>不可变类</strong>。</p><h2 id="_2-final-的具体使用场景" tabindex="-1"><a class="header-anchor" href="#_2-final-的具体使用场景"><span>2. final 的具体使用场景</span></a></h2><h3 id="_2-1-变量" tabindex="-1"><a class="header-anchor" href="#_2-1-变量"><span>2.1 变量</span></a></h3><p>在 java 中变量，可以分为<strong>成员变量</strong>以及方法<strong>局部变量</strong>。</p><h4 id="_2-1-1-final-成员变量" tabindex="-1"><a class="header-anchor" href="#_2-1-1-final-成员变量"><span>2.1.1 final 成员变量</span></a></h4><p>通常每个类中的成员变量可以分为<strong>类变量（static修饰的变量）<strong>以及</strong>实例变量</strong>。</p><p>针对这两种类型的变量赋初值的时机是不同的：类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值；而实例变量可以在声明变量的时候给实例变量赋初值，在非静态初始化块中以及构造器中赋初值。</p><p>类变量有<strong>两个时机赋初值</strong>，而实例变量则可以有<strong>三个时机赋初值</strong>。当 final 变量未初始化时系统不会进行隐式初始化，会出现报错。下面用具体的代码来演示：</p><figure><img src="https://cloud.braumace.cn/f/GdrcV/6.1 final修饰成员变量.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>看上面的图片已经将每种情况整理出来了，现在将这几种情况归纳整理一下：</p><ol><li><strong>类变量</strong>：必须要在<strong>静态初始化块</strong>中指定初始值或者<strong>声明该类变量时</strong>指定初始值，而且只能在这<strong>两个地方</strong>之一进行指定</li><li><strong>实例变量</strong>：必要要在<strong>非静态初始化块</strong>，<strong>声明该实例变量</strong>或者在<strong>构造器中</strong>指定初始值，而且只能在这<strong>三个地方</strong>进行指定</li></ol><h4 id="_2-1-2-final-局部变量" tabindex="-1"><a class="header-anchor" href="#_2-1-2-final-局部变量"><span>2.1.2 final 局部变量</span></a></h4><p>final 局部变量由程序员进行显式初始化，如果 final 局部变量已经进行了初始化则后面就不能再次进行更改，如果 final 变量未进行初始化，可以进行赋值，<strong>当且仅有一次赋值</strong>，一旦赋值之后再次赋值就会出错。</p><p>下面用具体的代码演示 final 局部变量的情况：</p><figure><img src="https://cloud.braumace.cn/f/8RVs3/6.2 final修饰局部变量.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>现在我们来换一个角度进行考虑，final 修饰的是基本数据类型和引用类型有区别吗？</p><h4 id="_2-1-2-final-基本数据类型-vs-final-引用数据类型" tabindex="-1"><a class="header-anchor" href="#_2-1-2-final-基本数据类型-vs-final-引用数据类型"><span>2.1.2 final 基本数据类型 VS final 引用数据类型</span></a></h4><p>通过上面的例子我们能够看出，如果 final 修饰的是一个基本数据类型的数据，一旦赋值后就不能再次更改，那么，如果 final 是引用数据类型呢？这个引用的对象能够改变吗？</p><p>同样来看一段代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //在声明final实例成员变量时进行赋值</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Person</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> person </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Person</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">24</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 170</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //对final引用数据类型person进行更改</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">age</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 22</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> age</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> height</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Person</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> age</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> height</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">age</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">height</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> height;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Person{&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">                    &quot;age=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">                    &quot;, height=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> height </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">                    &#39;}&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们对 final 修饰的引用数据类型变量 <code>person</code> 的属性改成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>22</mn></mrow><annotation encoding="application/x-tex">22</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">22</span></span></span></span>，是可以成功操作的。</p><p>通过这个实验我们就可以看出来<strong>当 final 修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final 只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的</strong>。</p><div class="hint-container info"><p class="hint-container-title">宏变量</p><p>利用 final 变量的不可更改性，在满足一下三个条件时，该变量就会成为一个 “宏变量”，即是一个常量。</p><ol><li>使用 final 修饰符修饰</li><li>在定义该 final 变量时就指定了初始值</li><li>该初始值在编译时就能够唯一指定</li></ol><p>注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值</p></div><h3 id="_2-2-方法" tabindex="-1"><a class="header-anchor" href="#_2-2-方法"><span>2.2 方法</span></a></h3><h4 id="_2-2-1-重写" tabindex="-1"><a class="header-anchor" href="#_2-2-1-重写"><span>2.2.1 重写？</span></a></h4><p>当父类的方法被 final 修饰的时候，子类不能重写父类的该方法，比如在 Object 中，<code>getClass()</code> 方法就是 final 的，我们就不能重写该方法，但是 <code>hashCode()</code> 方法就不是被 final 所修饰的，我们就可以重写 <code>hashCode()</code> 方法。</p><p>写一个例子来加深理解：先定义一个父类，里面有 final 修饰的方法 <code>test();</code></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalExampleParent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后 FinalExample 继承该父类，当重写 <code>test()</code> 方法时出现报错，如下图：</p><figure><img src="https://cloud.braumace.cn/f/KP2H9/6.3 final方法不能重写.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过这个现象我们就可以看出来<strong>被 final 修饰的方法不能够被子类所重写</strong>。</p><h4 id="_2-2-2-重载" tabindex="-1"><a class="header-anchor" href="#_2-2-2-重载"><span>2.2.2 重载？</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalExampleParent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出被 final 修饰的方法是可以重载的。</p><p>经过我们的分析可以得出如下结论：</p><ol><li><strong>父类的 final 方法是不能够被子类重写的</strong></li><li><strong>final 方法是可以被重载的</strong></li></ol><h3 id="_2-3-类" tabindex="-1"><a class="header-anchor" href="#_2-3-类"><span>2.3 类</span></a></h3><p><strong>当一个类被 final 修饰时，表明该类是不能被子类继承的</strong>。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此，当一个类不希望被继承时就可以使用 final 修饰。</p><p>举一个小例子：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalExampleParent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>父类被 final 修饰，当子类继承该父类的时候，就会报错，如下图：</p><figure><img src="https://cloud.braumace.cn/f/jY0IO/6.4 final类不能继承.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_3-final-的例子" tabindex="-1"><a class="header-anchor" href="#_3-final-的例子"><span>3. final 的例子</span></a></h2><p>final 经常会被用作不变类上，利用 final 的不可更改性。我们先来看看什么是不可变类。</p><div class="hint-container info"><p class="hint-container-title">不可变类</p><p>不可变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。</p><p>满足以下条件则可以成为不可变类：</p><ol><li>使用 private 和 final 修饰符来修饰该类的成员变量</li><li>提供带参的构造器用于初始化类的成员变量</li><li>仅为该类的成员变量提供 <code>getter</code> 方法，不提供 <code>setter</code> 方法，因为普通方法无法修改 final 修饰的成员变量</li><li>如果有必要就重写 Object 类的 <code>hashCode()</code> 和 <code>equals()</code> 方法，应该保证用 <code>equals()</code> 判断相同的两个对象其 Hashcode 值也是相等的</li></ol></div><p>JDK 中提供的八个包装类和 String 类都是不可变类，我们来看看 String 的实现：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/** The value is used for character storage. */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出 String 的 value 就是 final 修饰的，上述其他几条性质也是吻合的。</p><h2 id="_4-多线程中你真的了解-final-吗" tabindex="-1"><a class="header-anchor" href="#_4-多线程中你真的了解-final-吗"><span>4. 多线程中你真的了解 final 吗？</span></a></h2><p>在 java 内存模型中我们知道，java 内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说，<strong>对于底层而言，java 内存模型就是一弱内存数据模型</strong>。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下，final 会进行怎样的重排序？会导致线程安全的问题吗？</p><h3 id="_4-1-final-域重排序规则" tabindex="-1"><a class="header-anchor" href="#_4-1-final-域重排序规则"><span>4.1 final 域重排序规则</span></a></h3><h4 id="_4-1-1-final-域为基本类型" tabindex="-1"><a class="header-anchor" href="#_4-1-1-final-域为基本类型"><span>4.1.1 final 域为基本类型</span></a></h4><p>先看一段示例代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   //普通域</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   //final域</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalDemo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> finalDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FinalDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1. 写普通域</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 2. 写final域</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> writer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        finalDemo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FinalDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        FinalDemo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> demo</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> finalDemo;   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 3.读对象引用</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;    </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//4.读普通域</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;    </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//5.读final域</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设线程 A 在执行 <code>writer()</code> 方法，线程 B 执行 <code>reader()</code> 方法。</p><div class="hint-container info"><p class="hint-container-title">写 final 域重排序规则</p><p>写 final 域的重排序规则为：<strong>禁止对final域的写重排序到构造函数之外</strong>。</p><p>这个规则的实现主要包含了两个方面：</p><ol><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外</li><li>编译器会在 final 域写之后，构造函数 return 之前，插入一个 storestore 屏障，这个屏障可以禁止处理器把 final 域的写重排序到构造函数之外。</li></ol></div><p>我们再来分析 <code>writer</code> 方法，虽然只有一行代码，但实际上做了两件事情：</p><ol><li>构造了一个 FinalDemo 对象；</li><li>把这个对象赋值给成员变量 finalDemo。</li></ol><p>我们来画下存在的一种可能执行时序图，如下：</p><figure><img src="https://cloud.braumace.cn/f/RrLtg/6.5 final域写可能的存在的执行时序.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于 <code>a</code>，<code>b</code> 之间没有数据依赖性，普通域（普通变量）<code>a</code> 可能会被重排序到构造函数之外，线程 B 就有可能读到的是普通变量 <code>a</code> 初始化之前的值（零值），这样就可能出现错误。</p><p>而 final 域变量 <code>b</code>，根据重排序规则，会禁止 final 修饰的变量 <code>b</code> 重排序到构造函数之外，从而 <code>b</code> 能够正确赋值，线程 B 就能够读到 final 变量初始化后的值。</p><p>因此，写 final 域的重排序规则可以确保：<strong>在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域就不具有这个保障</strong>。比如在上例，线程 B 有可能就是一个未正确初始化的对象 finalDemo。</p><div class="hint-container info"><p class="hint-container-title">读 final 域重排序规则</p><p>读 final 域重排序规则为：<strong>在一个线程中，初次读对象引用和初次读该对象包含的 final 域，JMM 会禁止这两个操作的重排序</strong>。</p><p>注意，这个规则仅仅是针对处理器。</p><p>处理器会在读 final 域操作的前面插入一个 LoadLoad 屏障。实际上，读对象的引用和读该对象的 final 域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p></div><p><code>read()</code> 方法主要包含了三个操作：</p><ol><li>初次读引用变量 finalDemo;</li><li>初次读引用变量 finalDemo 的普通域 <code>a</code>;</li><li>初次读引用变量 finalDemo 的 final 与 <code>b</code>;</li></ol><p>假设线程 A 写过程没有重排序，那么线程 A 和线程 B 有一种的可能执行时序为下图：</p><figure><img src="https://cloud.braumace.cn/f/35rhr/6.6 final域读可能存在的执行时序.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>读对象的普通域被重排序到了读对象引用的前面就会出现线程 B 还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而 final 域的读操作就 “限定” 了在读 final 域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p><p>读 final 域的重排序规则可以确保：<strong>在读一个对象的 final 域之前，一定会先读这个包含这个 final 域的对象的引用。</strong></p><h4 id="_4-1-2-final-域为引用类型" tabindex="-1"><a class="header-anchor" href="#_4-1-2-final-域为引用类型"><span>4.1.2 final 域为引用类型</span></a></h4><blockquote><p>对 final 修饰的对象的成员域写操作</p></blockquote><p>针对引用数据类型，final 域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对<strong>一个 final 修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量</strong>，这两个操作是不能被重排序的。</p><p>注意这里的是 “增加” 也就说前面对 final 基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalReferenceDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] arrays</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalReferenceDemo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> finalReferenceDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FinalReferenceDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        arrays </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        arrays[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;        </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> writerOne</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        finalReferenceDemo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FinalReferenceDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//3</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> writerTwo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        arrays[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//4</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (finalReferenceDemo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//5</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> temp</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> finalReferenceDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">arrays</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//6</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面的实例程序，线程线程 A 执行 <code>wirterOne</code> 方法，执行完后线程 B 执行 <code>writerTwo</code> 方法，然后线程 C 执行 <code>reader</code> 方法。下图就以这种执行时序出现的一种情况来讨论：</p><figure><img src="https://cloud.braumace.cn/f/7J3c9/6.7 写final修饰引用类型数据可能的执行时序.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于对 final 域的写禁止重排序到构造方法外，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 不能被重排序。由于一个 final 域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 不能重排序。</p><blockquote><p>对 final 修饰的对象的成员域读操作</p></blockquote><p>JMM 可以确保线程 C 至少能看到写线程 A 对 final 引用的对象的成员域的写入，即能看到 <code>arrays[0] = 1</code>，而写线程 B 对数组元素的写入可能看到也可能看不到。JMM 不保证线程 B 的写入对线程 C 可见，线程 B 和线程 C 之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者 volatile。</p><div class="hint-container tip"><p class="hint-container-title">关于 final 重排序的总结</p><p>按照 final 修饰的数据类型分类：</p><ol><li>基本数据类型: <ul><li>final 域写：禁止 <strong>final 域写</strong>与<strong>构造方法</strong>重排序，即禁止 final 域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的 final 域全部已经初始化过。</li><li>final 域读：禁止初次<strong>读对象的引用</strong>与<strong>读该对象包含的 final 域</strong>的重排序。</li></ul></li><li>引用数据类型： <ul><li>额外增加约束：禁止在构造函数对<strong>一个 final 修饰的对象的成员域的写入</strong>与随后将<strong>这个被构造的对象的引用赋值给引用变量</strong>重排序</li></ul></li></ol></div><h2 id="_5-final-的实现原理" tabindex="-1"><a class="header-anchor" href="#_5-final-的实现原理"><span>5. final 的实现原理</span></a></h2><p>上面我们提到过，写 final 域会要求编译器在 final 域写之后，构造函数返回前插入一个 StoreStore 屏障。读 final 域的重排序规则会要求编译器在读 final 域的操作前插入一个 LoadLoad 屏障。</p><p>有意思的是，如果以 X86 处理为例，X86 不会对写-写重排序，所以 <strong>StoreStore屏障可以省略</strong>。由于<strong>不会对有间接依赖性的操作重排序</strong>，所以在 X86 处理器中，读 final 域需要的 <strong>LoadLoad屏障也会被省略掉</strong>。也就是说，<strong>以 X86 为例的话，对 final 域的读/写的内存屏障都会被省略</strong>！具体是否插入还是得看是什么处理器。</p><h2 id="_6-为什么-final-引用不能从构造函数中-溢出" tabindex="-1"><a class="header-anchor" href="#_6-为什么-final-引用不能从构造函数中-溢出"><span>6. 为什么 final 引用不能从构造函数中 “溢出”</span></a></h2><p>上面对 final 域写重排序规则可以确保我们在使用一个对象引用的时候，该对象的 final 域已经在构造函数被初始化过了。</p><p>但是这里其实是有一个前提条件的，即：<strong>在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中 “溢出”</strong>。</p><p>以下面的例子来说：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalReferenceEscapeDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FinalReferenceEscapeDemo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> referenceDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FinalReferenceEscapeDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        referenceDemo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> writer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FinalReferenceEscapeDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (referenceDemo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//3</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> temp</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> referenceDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//4</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可能的执行时序如图所示：</p><figure><img src="https://cloud.braumace.cn/f/eN5s5/6.8 final域引用可能的执行时序.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>假设一个线程 A 执行 <code>writer</code> 方法另一个线程执行 <code>reader</code> 方法。因为构造函数中操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 之间没有数据依赖性，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 可以重排序，先执行了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，这个时候引用对象 referenceDemo 是个没有完全初始化的对象，而当线程 B 去读取该对象时就会出错。</p><p>尽管依然满足了 final 域写重排序规则：在引用对象对所有线程可见时，其 final 域已经完全初始化成功。但是，引用对象 “this” 溢出，该代码依然存在线程安全的问题。</p>`,95))])}const d=a(h,[["render",p],["__file","6. 你真的了解final吗.html.vue"]]),c=JSON.parse('{"path":"/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/6.%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3final%E5%90%97.html","title":"你真的了解 final 吗","lang":"zh-CN","frontmatter":{"category":["并发编程"],"tag":["JUC"],"head":[["meta",{"property":"og:url","content":"https://blog.braumace.cn/computer/language/java/JUC%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/6.%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3final%E5%90%97.html"}],["meta",{"property":"og:site_name","content":"ByteLighting"}],["meta",{"property":"og:title","content":"你真的了解 final 吗"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cloud.braumace.cn/f/GdrcV/6.1%20final%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-07T13:13:33.000Z"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:modified_time","content":"2024-10-07T13:13:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"你真的了解 final 吗\\",\\"image\\":[\\"https://cloud.braumace.cn/f/GdrcV/6.1%20final%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png\\",\\"https://cloud.braumace.cn/f/8RVs3/6.2%20final%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.png\\",\\"https://cloud.braumace.cn/f/KP2H9/6.3%20final%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99.png\\",\\"https://cloud.braumace.cn/f/jY0IO/6.4%20final%E7%B1%BB%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF.png\\",\\"https://cloud.braumace.cn/f/RrLtg/6.5%20final%E5%9F%9F%E5%86%99%E5%8F%AF%E8%83%BD%E7%9A%84%E5%AD%98%E5%9C%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F.png\\",\\"https://cloud.braumace.cn/f/35rhr/6.6%20final%E5%9F%9F%E8%AF%BB%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F.png\\",\\"https://cloud.braumace.cn/f/7J3c9/6.7%20%E5%86%99final%E4%BF%AE%E9%A5%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%83%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F.png\\",\\"https://cloud.braumace.cn/f/eN5s5/6.8%20final%E5%9F%9F%E5%BC%95%E7%94%A8%E5%8F%AF%E8%83%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F.png\\"],\\"dateModified\\":\\"2024-10-07T13:13:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"BraumAce\\",\\"url\\":\\"https://blog.braumace.cn/article\\"}]}"]]},"headers":[{"level":2,"title":"1. final 简介","slug":"_1-final-简介","link":"#_1-final-简介","children":[]},{"level":2,"title":"2. final 的具体使用场景","slug":"_2-final-的具体使用场景","link":"#_2-final-的具体使用场景","children":[{"level":3,"title":"2.1 变量","slug":"_2-1-变量","link":"#_2-1-变量","children":[{"level":4,"title":"2.1.1 final 成员变量","slug":"_2-1-1-final-成员变量","link":"#_2-1-1-final-成员变量","children":[]},{"level":4,"title":"2.1.2 final 局部变量","slug":"_2-1-2-final-局部变量","link":"#_2-1-2-final-局部变量","children":[]},{"level":4,"title":"2.1.2 final 基本数据类型 VS final 引用数据类型","slug":"_2-1-2-final-基本数据类型-vs-final-引用数据类型","link":"#_2-1-2-final-基本数据类型-vs-final-引用数据类型","children":[]}]},{"level":3,"title":"2.2 方法","slug":"_2-2-方法","link":"#_2-2-方法","children":[{"level":4,"title":"2.2.1 重写？","slug":"_2-2-1-重写","link":"#_2-2-1-重写","children":[]},{"level":4,"title":"2.2.2 重载？","slug":"_2-2-2-重载","link":"#_2-2-2-重载","children":[]}]},{"level":3,"title":"2.3 类","slug":"_2-3-类","link":"#_2-3-类","children":[]}]},{"level":2,"title":"3. final 的例子","slug":"_3-final-的例子","link":"#_3-final-的例子","children":[]},{"level":2,"title":"4. 多线程中你真的了解 final 吗？","slug":"_4-多线程中你真的了解-final-吗","link":"#_4-多线程中你真的了解-final-吗","children":[{"level":3,"title":"4.1 final 域重排序规则","slug":"_4-1-final-域重排序规则","link":"#_4-1-final-域重排序规则","children":[{"level":4,"title":"4.1.1 final 域为基本类型","slug":"_4-1-1-final-域为基本类型","link":"#_4-1-1-final-域为基本类型","children":[]},{"level":4,"title":"4.1.2 final 域为引用类型","slug":"_4-1-2-final-域为引用类型","link":"#_4-1-2-final-域为引用类型","children":[]}]}]},{"level":2,"title":"5. final 的实现原理","slug":"_5-final-的实现原理","link":"#_5-final-的实现原理","children":[]},{"level":2,"title":"6. 为什么 final 引用不能从构造函数中 “溢出”","slug":"_6-为什么-final-引用不能从构造函数中-溢出","link":"#_6-为什么-final-引用不能从构造函数中-溢出","children":[]}],"git":{"createdTime":1726999172000,"updatedTime":1728306813000,"contributors":[{"name":"BraumAce","email":"1693717911@qq.com","commits":1}]},"readingTime":{"minutes":13.76,"words":4129},"filePathRelative":"computer/language/java/JUC 并发编程/6. 你真的了解final吗.md","localizedDate":"2024年9月22日","excerpt":"\\n"}');export{d as comp,c as data};
